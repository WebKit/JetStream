module.exports = {
  "packages/test-utils/src/normalizeIcons.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nexport function normalizeIcons(str: string): string {\n  if (!str) {\n    return str;\n  }\n\n  // Make sure to keep in sync with `jest-util/src/specialChars`\n  return str\n    .replaceAll(new RegExp('\\u00D7', 'gu'), '\\u2715')\n    .replaceAll(new RegExp('\\u221A', 'gu'), '\\u2713');\n}\n",
  "packages/test-utils/src/normalizeIcons.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport declare function normalizeIcons(str: string): string;\n",
  "packages/test-utils/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nexport {alignedAnsiStyleSerializer} from './alignedAnsiStyleSerializer';\n\nexport {\n  isJestJasmineRun,\n  skipSuiteOnJasmine,\n  skipSuiteOnJestCircus,\n  onNodeVersions,\n} from './ConditionalTest';\n\nexport {makeGlobalConfig, makeProjectConfig} from './config';\n\nexport {normalizeIcons} from './normalizeIcons';\n",
  "packages/test-utils/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport { alignedAnsiStyleSerializer } from './alignedAnsiStyleSerializer';\nexport { isJestJasmineRun, skipSuiteOnJasmine, skipSuiteOnJestCircus, onNodeVersions, } from './ConditionalTest';\nexport { makeGlobalConfig, makeProjectConfig } from './config';\nexport { normalizeIcons } from './normalizeIcons';\n",
  "packages/test-utils/src/config.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {TestPathPatterns} from '@jest/pattern';\nimport type {Config} from '@jest/types';\n\nconst DEFAULT_GLOBAL_CONFIG: Config.GlobalConfig = {\n  bail: 0,\n  changedFilesWithAncestor: false,\n  changedSince: '',\n  ci: false,\n  collectCoverage: false,\n  collectCoverageFrom: [],\n  coverageDirectory: 'coverage',\n  coverageProvider: 'babel',\n  coverageReporters: [],\n  coverageThreshold: {global: {}},\n  detectLeaks: false,\n  detectOpenHandles: false,\n  errorOnDeprecated: false,\n  expand: false,\n  filter: undefined,\n  findRelatedTests: false,\n  forceExit: false,\n  globalSetup: undefined,\n  globalTeardown: undefined,\n  json: false,\n  lastCommit: false,\n  listTests: false,\n  logHeapUsage: false,\n  maxConcurrency: 5,\n  maxWorkers: 2,\n  noSCM: undefined,\n  noStackTrace: false,\n  nonFlagArgs: [],\n  notify: false,\n  notifyMode: 'failure-change',\n  onlyChanged: false,\n  onlyFailures: false,\n  openHandlesTimeout: 1000,\n  outputFile: undefined,\n  passWithNoTests: false,\n  projects: [],\n  replname: undefined,\n  reporters: [],\n  rootDir: '/test_root_dir/',\n  runInBand: false,\n  runTestsByPath: false,\n  seed: 1234,\n  silent: false,\n  skipFilter: false,\n  snapshotFormat: {},\n  testFailureExitCode: 1,\n  testNamePattern: '',\n  testPathPatterns: new TestPathPatterns([]),\n  testResultsProcessor: undefined,\n  testSequencer: '@jest/test-sequencer',\n  testTimeout: 5000,\n  updateSnapshot: 'none',\n  useStderr: false,\n  verbose: false,\n  waitForUnhandledRejections: false,\n  watch: false,\n  watchAll: false,\n  watchPlugins: [],\n  watchman: false,\n};\n\nconst DEFAULT_PROJECT_CONFIG: Config.ProjectConfig = {\n  automock: false,\n  cache: false,\n  cacheDirectory: '/test_cache_dir/',\n  clearMocks: false,\n  collectCoverageFrom: ['src', '!public'],\n  coverageDirectory: 'coverage',\n  coveragePathIgnorePatterns: [],\n  coverageReporters: [],\n  cwd: '/test_root_dir/',\n  detectLeaks: false,\n  detectOpenHandles: false,\n  displayName: undefined,\n  errorOnDeprecated: false,\n  extensionsToTreatAsEsm: [],\n  fakeTimers: {enableGlobally: false},\n  filter: undefined,\n  forceCoverageMatch: [],\n  globalSetup: undefined,\n  globalTeardown: undefined,\n  globals: {},\n  haste: {},\n  id: 'test_name',\n  injectGlobals: true,\n  moduleDirectories: [],\n  moduleFileExtensions: ['js'],\n  moduleNameMapper: [],\n  modulePathIgnorePatterns: [],\n  modulePaths: [],\n  openHandlesTimeout: 1000,\n  prettierPath: 'prettier',\n  reporters: [\n    'default',\n    'custom-reporter-1',\n    ['custom-reporter-2', {configValue: true}],\n  ],\n  resetMocks: false,\n  resetModules: false,\n  resolver: undefined,\n  restoreMocks: false,\n  rootDir: '/test_root_dir/',\n  roots: [],\n  runner: 'jest-runner',\n  runtime: '/test_module_loader_path',\n  sandboxInjectedGlobals: [],\n  setupFiles: [],\n  setupFilesAfterEnv: [],\n  skipFilter: false,\n  skipNodeResolution: false,\n  slowTestThreshold: 5,\n  snapshotFormat: {},\n  snapshotResolver: undefined,\n  snapshotSerializers: [],\n  testEnvironment: 'node',\n  testEnvironmentOptions: {},\n  testLocationInResults: false,\n  testMatch: [],\n  testPathIgnorePatterns: [],\n  testRegex: ['\\\\.test\\\\.js$'],\n  testRunner: 'jest-circus/runner',\n  testTimeout: 5000,\n  transform: [],\n  transformIgnorePatterns: [],\n  unmockedModulePathPatterns: undefined,\n  waitForUnhandledRejections: false,\n  watchPathIgnorePatterns: [],\n};\n\nexport const makeGlobalConfig = (\n  overrides: Partial<Config.GlobalConfig> = {},\n): Config.GlobalConfig => {\n  const overridesKeys = new Set(Object.keys(overrides));\n  for (const key of Object.keys(DEFAULT_GLOBAL_CONFIG)) {\n    overridesKeys.delete(key);\n  }\n\n  if (overridesKeys.size > 0) {\n    throw new Error(`\n      Properties that are not part of GlobalConfig type were passed:\n      ${JSON.stringify([...overridesKeys])}\n    `);\n  }\n\n  return {...DEFAULT_GLOBAL_CONFIG, ...overrides};\n};\n\nexport const makeProjectConfig = (\n  overrides: Partial<Config.ProjectConfig> = {},\n): Config.ProjectConfig => {\n  const overridesKeys = new Set(Object.keys(overrides));\n  for (const key of Object.keys(DEFAULT_PROJECT_CONFIG)) {\n    overridesKeys.delete(key);\n  }\n\n  if (overridesKeys.size > 0) {\n    throw new Error(`\n      Properties that are not part of ProjectConfig type were passed:\n      ${JSON.stringify([...overridesKeys])}\n    `);\n  }\n\n  return {...DEFAULT_PROJECT_CONFIG, ...overrides};\n};\n",
  "packages/test-utils/src/config.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config } from '@jest/types';\nexport declare const makeGlobalConfig: (overrides?: Partial<Config.GlobalConfig>) => Config.GlobalConfig;\nexport declare const makeProjectConfig: (overrides?: Partial<Config.ProjectConfig>) => Config.ProjectConfig;\n",
  "packages/test-utils/src/alignedAnsiStyleSerializer.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport ansiRegex from 'ansi-regex';\nimport style from 'ansi-styles';\nimport type {NewPlugin} from 'pretty-format';\n\nexport const alignedAnsiStyleSerializer: NewPlugin = {\n  serialize(val: string): string {\n    // Return the string itself, not escaped nor enclosed in double quote marks.\n    return val.replace(ansiRegex(), match => {\n      switch (match) {\n        case style.inverse.open:\n          return '<i>';\n        case style.inverse.close:\n          return '</i>';\n\n        case style.bold.open:\n          return '<b>';\n        case style.dim.open:\n          return '<d>';\n        case style.green.open:\n          return '<g>';\n        case style.red.open:\n          return '<r>';\n        case style.yellow.open:\n          return '<y>';\n        case style.bgYellow.open:\n          return '<Y>';\n\n        case style.bold.close:\n        case style.dim.close:\n        case style.green.close:\n        case style.red.close:\n        case style.yellow.close:\n        case style.bgYellow.close:\n          return '</>';\n\n        default:\n          return match; // unexpected escape sequence\n      }\n    });\n  },\n  test(val: unknown): val is string {\n    return typeof val === 'string';\n  },\n};\n",
  "packages/test-utils/src/alignedAnsiStyleSerializer.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { NewPlugin } from 'pretty-format';\nexport declare const alignedAnsiStyleSerializer: NewPlugin;\n",
  "packages/test-utils/src/ConditionalTest.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/* eslint-disable jest/no-focused-tests */\n\nimport * as semver from 'semver';\nimport {describe, test} from '@jest/globals';\n\nexport function isJestJasmineRun(): boolean {\n  return process.env.JEST_JASMINE === '1';\n}\n\nexport function skipSuiteOnJasmine(): void {\n  if (isJestJasmineRun()) {\n    test.only('does not work on Jasmine', () => {\n      console.warn('[SKIP] Does not work on Jasmine');\n    });\n  }\n}\n\nexport function skipSuiteOnJestCircus(): void {\n  if (!isJestJasmineRun()) {\n    test.only('does not work on jest-circus', () => {\n      console.warn('[SKIP] Does not work on jest-circus');\n    });\n  }\n}\n\nexport function onNodeVersions(\n  versionRange: string,\n  testBody: () => void,\n): void {\n  const description = `on node ${versionRange}`;\n  if (semver.satisfies(process.versions.node, versionRange)) {\n    describe(description, () => {\n      testBody();\n    });\n  } else {\n    describe.skip(description, () => {\n      testBody();\n    });\n  }\n}\n",
  "packages/test-utils/src/ConditionalTest.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport declare function isJestJasmineRun(): boolean;\nexport declare function skipSuiteOnJasmine(): void;\nexport declare function skipSuiteOnJestCircus(): void;\nexport declare function onNodeVersions(versionRange: string, testBody: () => void): void;\n",
  "packages/test-globals/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {Jest} from '@jest/environment';\nimport type {JestExpect} from '@jest/expect';\nimport type {Global} from '@jest/types';\nimport type {\n  ClassLike,\n  FunctionLike,\n  Mock as JestMock,\n  Mocked as JestMocked,\n  MockedClass as JestMockedClass,\n  MockedFunction as JestMockedFunction,\n  MockedObject as JestMockedObject,\n  Spied as JestSpied,\n  SpiedClass as JestSpiedClass,\n  SpiedFunction as JestSpiedFunction,\n  SpiedGetter as JestSpiedGetter,\n  SpiedSetter as JestSpiedSetter,\n  UnknownFunction,\n} from 'jest-mock';\n\ndeclare global {\n  const beforeAll: Global.TestFrameworkGlobals['beforeAll'];\n  const beforeEach: Global.TestFrameworkGlobals['beforeEach'];\n\n  const afterEach: Global.TestFrameworkGlobals['afterEach'];\n  const afterAll: Global.TestFrameworkGlobals['afterAll'];\n\n  const describe: Global.TestFrameworkGlobals['describe'];\n  const fdescribe: Global.TestFrameworkGlobals['fdescribe'];\n  const xdescribe: Global.TestFrameworkGlobals['xdescribe'];\n\n  const it: Global.TestFrameworkGlobals['it'];\n  const fit: Global.TestFrameworkGlobals['fit'];\n  const xit: Global.TestFrameworkGlobals['xit'];\n\n  const test: Global.TestFrameworkGlobals['test'];\n  const xtest: Global.TestFrameworkGlobals['xtest'];\n\n  const expect: JestExpect;\n\n  const jest: Jest;\n\n  // eslint-disable-next-line @typescript-eslint/no-namespace\n  namespace jest {\n    /**\n     * Constructs the type of a mock function, e.g. the return type of `jest.fn()`.\n     */\n    export type Mock<T extends FunctionLike = UnknownFunction> = JestMock<T>;\n    /**\n     * Wraps a class, function or object type with Jest mock type definitions.\n     */\n    export type Mocked<T extends object> = JestMocked<T>;\n    /**\n     * Wraps a class type with Jest mock type definitions.\n     */\n    export type MockedClass<T extends ClassLike> = JestMockedClass<T>;\n    /**\n     * Wraps a function type with Jest mock type definitions.\n     */\n    export type MockedFunction<T extends FunctionLike> = JestMockedFunction<T>;\n    /**\n     * Wraps an object type with Jest mock type definitions.\n     */\n    export type MockedObject<T extends object> = JestMockedObject<T>;\n    /**\n     * Constructs the type of a spied class or function.\n     */\n    export type Spied<T extends ClassLike | FunctionLike> = JestSpied<T>;\n    /**\n     * Constructs the type of a spied class.\n     */\n    export type SpiedClass<T extends ClassLike> = JestSpiedClass<T>;\n    /**\n     * Constructs the type of a spied function.\n     */\n    export type SpiedFunction<T extends FunctionLike> = JestSpiedFunction<T>;\n    /**\n     * Constructs the type of a spied getter.\n     */\n    export type SpiedGetter<T> = JestSpiedGetter<T>;\n    /**\n     * Constructs the type of a spied setter.\n     */\n    export type SpiedSetter<T> = JestSpiedSetter<T>;\n  }\n}\n",
  "packages/test-globals/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Jest } from '@jest/environment';\nimport type { JestExpect } from '@jest/expect';\nimport type { Global } from '@jest/types';\nimport type { ClassLike, FunctionLike, Mock as JestMock, Mocked as JestMocked, MockedClass as JestMockedClass, MockedFunction as JestMockedFunction, MockedObject as JestMockedObject, Spied as JestSpied, SpiedClass as JestSpiedClass, SpiedFunction as JestSpiedFunction, SpiedGetter as JestSpiedGetter, SpiedSetter as JestSpiedSetter, UnknownFunction } from 'jest-mock';\ndeclare global {\n    const beforeAll: Global.TestFrameworkGlobals['beforeAll'];\n    const beforeEach: Global.TestFrameworkGlobals['beforeEach'];\n    const afterEach: Global.TestFrameworkGlobals['afterEach'];\n    const afterAll: Global.TestFrameworkGlobals['afterAll'];\n    const describe: Global.TestFrameworkGlobals['describe'];\n    const fdescribe: Global.TestFrameworkGlobals['fdescribe'];\n    const xdescribe: Global.TestFrameworkGlobals['xdescribe'];\n    const it: Global.TestFrameworkGlobals['it'];\n    const fit: Global.TestFrameworkGlobals['fit'];\n    const xit: Global.TestFrameworkGlobals['xit'];\n    const test: Global.TestFrameworkGlobals['test'];\n    const xtest: Global.TestFrameworkGlobals['xtest'];\n    const expect: JestExpect;\n    const jest: Jest;\n    namespace jest {\n        /**\n         * Constructs the type of a mock function, e.g. the return type of `jest.fn()`.\n         */\n        type Mock<T extends FunctionLike = UnknownFunction> = JestMock<T>;\n        /**\n         * Wraps a class, function or object type with Jest mock type definitions.\n         */\n        type Mocked<T extends object> = JestMocked<T>;\n        /**\n         * Wraps a class type with Jest mock type definitions.\n         */\n        type MockedClass<T extends ClassLike> = JestMockedClass<T>;\n        /**\n         * Wraps a function type with Jest mock type definitions.\n         */\n        type MockedFunction<T extends FunctionLike> = JestMockedFunction<T>;\n        /**\n         * Wraps an object type with Jest mock type definitions.\n         */\n        type MockedObject<T extends object> = JestMockedObject<T>;\n        /**\n         * Constructs the type of a spied class or function.\n         */\n        type Spied<T extends ClassLike | FunctionLike> = JestSpied<T>;\n        /**\n         * Constructs the type of a spied class.\n         */\n        type SpiedClass<T extends ClassLike> = JestSpiedClass<T>;\n        /**\n         * Constructs the type of a spied function.\n         */\n        type SpiedFunction<T extends FunctionLike> = JestSpiedFunction<T>;\n        /**\n         * Constructs the type of a spied getter.\n         */\n        type SpiedGetter<T> = JestSpiedGetter<T>;\n        /**\n         * Constructs the type of a spied setter.\n         */\n        type SpiedSetter<T> = JestSpiedSetter<T>;\n    }\n}\n",
  "packages/pretty-format/src/types.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {SnapshotFormat} from '@jest/schemas';\n\nexport type Colors = {\n  comment: {close: string; open: string};\n  content: {close: string; open: string};\n  prop: {close: string; open: string};\n  tag: {close: string; open: string};\n  value: {close: string; open: string};\n};\ntype Indent = (arg0: string) => string;\nexport type Refs = Array<unknown>;\ntype Print = (arg0: unknown) => string;\n\nexport type Theme = Options['theme'];\n\nexport type CompareKeys = ((a: string, b: string) => number) | null | undefined;\n\ntype RequiredOptions = Required<PrettyFormatOptions>;\n\nexport interface Options\n  extends Omit<RequiredOptions, 'compareKeys' | 'theme'> {\n  compareKeys: CompareKeys;\n  theme: Required<RequiredOptions['theme']>;\n}\n\nexport interface PrettyFormatOptions\n  extends Omit<SnapshotFormat, 'compareKeys'> {\n  compareKeys?: CompareKeys;\n  plugins?: Plugins;\n}\n\nexport type OptionsReceived = PrettyFormatOptions;\n\nexport type Config = {\n  callToJSON: boolean;\n  compareKeys: CompareKeys;\n  colors: Colors;\n  escapeRegex: boolean;\n  escapeString: boolean;\n  indent: string;\n  maxDepth: number;\n  maxWidth: number;\n  min: boolean;\n  plugins: Plugins;\n  printBasicPrototype: boolean;\n  printFunctionName: boolean;\n  spacingInner: string;\n  spacingOuter: string;\n};\n\nexport type Printer = (\n  val: unknown,\n  config: Config,\n  indentation: string,\n  depth: number,\n  refs: Refs,\n  hasCalledToJSON?: boolean,\n) => string;\n\ntype Test = (arg0: any) => boolean;\n\nexport type NewPlugin = {\n  serialize: (\n    val: any,\n    config: Config,\n    indentation: string,\n    depth: number,\n    refs: Refs,\n    printer: Printer,\n  ) => string;\n  test: Test;\n};\n\ntype PluginOptions = {\n  edgeSpacing: string;\n  min: boolean;\n  spacing: string;\n};\n\nexport type OldPlugin = {\n  print: (\n    val: unknown,\n    print: Print,\n    indent: Indent,\n    options: PluginOptions,\n    colors: Colors,\n  ) => string;\n  test: Test;\n};\n\nexport type Plugin = NewPlugin | OldPlugin;\n\nexport type Plugins = Array<Plugin>;\n",
  "packages/pretty-format/src/types.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { SnapshotFormat } from '@jest/schemas';\nexport type Colors = {\n    comment: {\n        close: string;\n        open: string;\n    };\n    content: {\n        close: string;\n        open: string;\n    };\n    prop: {\n        close: string;\n        open: string;\n    };\n    tag: {\n        close: string;\n        open: string;\n    };\n    value: {\n        close: string;\n        open: string;\n    };\n};\ntype Indent = (arg0: string) => string;\nexport type Refs = Array<unknown>;\ntype Print = (arg0: unknown) => string;\nexport type Theme = Options['theme'];\nexport type CompareKeys = ((a: string, b: string) => number) | null | undefined;\ntype RequiredOptions = Required<PrettyFormatOptions>;\nexport interface Options extends Omit<RequiredOptions, 'compareKeys' | 'theme'> {\n    compareKeys: CompareKeys;\n    theme: Required<RequiredOptions['theme']>;\n}\nexport interface PrettyFormatOptions extends Omit<SnapshotFormat, 'compareKeys'> {\n    compareKeys?: CompareKeys;\n    plugins?: Plugins;\n}\nexport type OptionsReceived = PrettyFormatOptions;\nexport type Config = {\n    callToJSON: boolean;\n    compareKeys: CompareKeys;\n    colors: Colors;\n    escapeRegex: boolean;\n    escapeString: boolean;\n    indent: string;\n    maxDepth: number;\n    maxWidth: number;\n    min: boolean;\n    plugins: Plugins;\n    printBasicPrototype: boolean;\n    printFunctionName: boolean;\n    spacingInner: string;\n    spacingOuter: string;\n};\nexport type Printer = (val: unknown, config: Config, indentation: string, depth: number, refs: Refs, hasCalledToJSON?: boolean) => string;\ntype Test = (arg0: any) => boolean;\nexport type NewPlugin = {\n    serialize: (val: any, config: Config, indentation: string, depth: number, refs: Refs, printer: Printer) => string;\n    test: Test;\n};\ntype PluginOptions = {\n    edgeSpacing: string;\n    min: boolean;\n    spacing: string;\n};\nexport type OldPlugin = {\n    print: (val: unknown, print: Print, indent: Indent, options: PluginOptions, colors: Colors) => string;\n    test: Test;\n};\nexport type Plugin = NewPlugin | OldPlugin;\nexport type Plugins = Array<Plugin>;\nexport {};\n",
  "packages/pretty-format/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport style from 'ansi-styles';\nimport {\n  printIteratorEntries,\n  printIteratorValues,\n  printListItems,\n  printObjectProperties,\n} from './collections';\nimport AsymmetricMatcher from './plugins/AsymmetricMatcher';\nimport DOMCollection from './plugins/DOMCollection';\nimport DOMElement from './plugins/DOMElement';\nimport Immutable from './plugins/Immutable';\nimport ReactElement from './plugins/ReactElement';\nimport ReactTestComponent from './plugins/ReactTestComponent';\nimport type {\n  Colors,\n  Config,\n  NewPlugin,\n  Options,\n  OptionsReceived,\n  Plugin,\n  Plugins,\n  Refs,\n  Theme,\n} from './types';\n\nexport type {\n  Colors,\n  CompareKeys,\n  Config,\n  Options,\n  OptionsReceived,\n  OldPlugin,\n  NewPlugin,\n  Plugin,\n  Plugins,\n  PrettyFormatOptions,\n  Printer,\n  Refs,\n  Theme,\n} from './types';\n\nconst toString = Object.prototype.toString;\nconst toISOString = Date.prototype.toISOString;\nconst errorToString = Error.prototype.toString;\nconst regExpToString = RegExp.prototype.toString;\n\n/**\n * Explicitly comparing typeof constructor to function avoids undefined as name\n * when mock identity-obj-proxy returns the key as the value for any key.\n */\nconst getConstructorName = (val: new (...args: Array<any>) => unknown) =>\n  (typeof val.constructor === 'function' && val.constructor.name) || 'Object';\n\n/* global window */\n/** Is val is equal to global window object? Works even if it does not exist :) */\nconst isWindow = (val: unknown) =>\n  // eslint-disable-next-line unicorn/prefer-global-this\n  typeof window !== 'undefined' && val === window;\n\nconst SYMBOL_REGEXP = /^Symbol\\((.*)\\)(.*)$/;\nconst NEWLINE_REGEXP = /\\n/gi;\n\nclass PrettyFormatPluginError extends Error {\n  constructor(message: string, stack: string) {\n    super(message);\n    this.stack = stack;\n    this.name = this.constructor.name;\n  }\n}\n\nfunction isToStringedArrayType(toStringed: string): boolean {\n  return (\n    toStringed === '[object Array]' ||\n    toStringed === '[object ArrayBuffer]' ||\n    toStringed === '[object DataView]' ||\n    toStringed === '[object Float32Array]' ||\n    toStringed === '[object Float64Array]' ||\n    toStringed === '[object Int8Array]' ||\n    toStringed === '[object Int16Array]' ||\n    toStringed === '[object Int32Array]' ||\n    toStringed === '[object Uint8Array]' ||\n    toStringed === '[object Uint8ClampedArray]' ||\n    toStringed === '[object Uint16Array]' ||\n    toStringed === '[object Uint32Array]'\n  );\n}\n\nfunction printNumber(val: number): string {\n  return Object.is(val, -0) ? '-0' : String(val);\n}\n\nfunction printBigInt(val: bigint): string {\n  return String(`${val}n`);\n}\n\nfunction printFunction(val: Function, printFunctionName: boolean): string {\n  if (!printFunctionName) {\n    return '[Function]';\n  }\n  return `[Function ${val.name || 'anonymous'}]`;\n}\n\nfunction printSymbol(val: symbol): string {\n  return String(val).replace(SYMBOL_REGEXP, 'Symbol($1)');\n}\n\nfunction printError(val: Error): string {\n  return `[${errorToString.call(val)}]`;\n}\n\n/**\n * The first port of call for printing an object, handles most of the\n * data-types in JS.\n */\nfunction printBasicValue(\n  val: any,\n  printFunctionName: boolean,\n  escapeRegex: boolean,\n  escapeString: boolean,\n): string | null {\n  if (val === true || val === false) {\n    return `${val}`;\n  }\n  if (val === undefined) {\n    return 'undefined';\n  }\n  if (val === null) {\n    return 'null';\n  }\n\n  const typeOf = typeof val;\n\n  if (typeOf === 'number') {\n    return printNumber(val);\n  }\n  if (typeOf === 'bigint') {\n    return printBigInt(val);\n  }\n  if (typeOf === 'string') {\n    if (escapeString) {\n      return `\"${val.replaceAll(/\"|\\\\/g, '\\\\$&')}\"`;\n    }\n    return `\"${val}\"`;\n  }\n  if (typeOf === 'function') {\n    return printFunction(val, printFunctionName);\n  }\n  if (typeOf === 'symbol') {\n    return printSymbol(val);\n  }\n\n  const toStringed = toString.call(val);\n\n  if (toStringed === '[object WeakMap]') {\n    return 'WeakMap {}';\n  }\n  if (toStringed === '[object WeakSet]') {\n    return 'WeakSet {}';\n  }\n  if (\n    toStringed === '[object Function]' ||\n    toStringed === '[object GeneratorFunction]'\n  ) {\n    return printFunction(val, printFunctionName);\n  }\n  if (toStringed === '[object Symbol]') {\n    return printSymbol(val);\n  }\n  if (toStringed === '[object Date]') {\n    return Number.isNaN(+val) ? 'Date { NaN }' : toISOString.call(val);\n  }\n  if (toStringed === '[object Error]') {\n    return printError(val);\n  }\n  if (toStringed === '[object RegExp]') {\n    if (escapeRegex) {\n      // https://github.com/benjamingr/RegExp.escape/blob/main/polyfill.js\n      return regExpToString.call(val).replaceAll(/[$()*+.?[\\\\\\]^{|}]/g, '\\\\$&');\n    }\n    return regExpToString.call(val);\n  }\n\n  if (val instanceof Error) {\n    return printError(val);\n  }\n\n  return null;\n}\n\n/**\n * Handles more complex objects ( such as objects with circular references.\n * maps and sets etc )\n */\nfunction printComplexValue(\n  val: any,\n  config: Config,\n  indentation: string,\n  depth: number,\n  refs: Refs,\n  hasCalledToJSON?: boolean,\n): string {\n  if (refs.includes(val)) {\n    return '[Circular]';\n  }\n  refs = [...refs];\n  refs.push(val);\n\n  const hitMaxDepth = ++depth > config.maxDepth;\n  const min = config.min;\n\n  if (\n    config.callToJSON &&\n    !hitMaxDepth &&\n    val.toJSON &&\n    typeof val.toJSON === 'function' &&\n    !hasCalledToJSON\n  ) {\n    return printer(val.toJSON(), config, indentation, depth, refs, true);\n  }\n\n  const toStringed = toString.call(val);\n  if (toStringed === '[object Arguments]') {\n    return hitMaxDepth\n      ? '[Arguments]'\n      : `${min ? '' : 'Arguments '}[${printListItems(\n          val,\n          config,\n          indentation,\n          depth,\n          refs,\n          printer,\n        )}]`;\n  }\n  if (isToStringedArrayType(toStringed)) {\n    return hitMaxDepth\n      ? `[${val.constructor.name}]`\n      : `${\n          min\n            ? ''\n            : !config.printBasicPrototype && val.constructor.name === 'Array'\n              ? ''\n              : `${val.constructor.name} `\n        }[${printListItems(val, config, indentation, depth, refs, printer)}]`;\n  }\n  if (toStringed === '[object Map]') {\n    return hitMaxDepth\n      ? '[Map]'\n      : `Map {${printIteratorEntries(\n          val.entries(),\n          config,\n          indentation,\n          depth,\n          refs,\n          printer,\n          ' => ',\n        )}}`;\n  }\n  if (toStringed === '[object Set]') {\n    return hitMaxDepth\n      ? '[Set]'\n      : `Set {${printIteratorValues(\n          val.values(),\n          config,\n          indentation,\n          depth,\n          refs,\n          printer,\n        )}}`;\n  }\n\n  // Avoid failure to serialize global window object in jsdom test environment.\n  // For example, not even relevant if window is prop of React element.\n  return hitMaxDepth || isWindow(val)\n    ? `[${getConstructorName(val)}]`\n    : `${\n        min\n          ? ''\n          : !config.printBasicPrototype && getConstructorName(val) === 'Object'\n            ? ''\n            : `${getConstructorName(val)} `\n      }{${printObjectProperties(\n        val,\n        config,\n        indentation,\n        depth,\n        refs,\n        printer,\n      )}}`;\n}\n\nfunction isNewPlugin(plugin: Plugin): plugin is NewPlugin {\n  return (plugin as NewPlugin).serialize != null;\n}\n\nfunction printPlugin(\n  plugin: Plugin,\n  val: any,\n  config: Config,\n  indentation: string,\n  depth: number,\n  refs: Refs,\n): string {\n  let printed;\n\n  try {\n    printed = isNewPlugin(plugin)\n      ? plugin.serialize(val, config, indentation, depth, refs, printer)\n      : plugin.print(\n          val,\n          valChild => printer(valChild, config, indentation, depth, refs),\n          str => {\n            const indentationNext = indentation + config.indent;\n            return (\n              indentationNext +\n              str.replaceAll(NEWLINE_REGEXP, `\\n${indentationNext}`)\n            );\n          },\n          {\n            edgeSpacing: config.spacingOuter,\n            min: config.min,\n            spacing: config.spacingInner,\n          },\n          config.colors,\n        );\n  } catch (error: any) {\n    throw new PrettyFormatPluginError(error.message, error.stack);\n  }\n  if (typeof printed !== 'string') {\n    throw new TypeError(\n      `pretty-format: Plugin must return type \"string\" but instead returned \"${typeof printed}\".`,\n    );\n  }\n  return printed;\n}\n\nfunction findPlugin(plugins: Plugins, val: unknown) {\n  for (const plugin of plugins) {\n    try {\n      if (plugin.test(val)) {\n        return plugin;\n      }\n    } catch (error: any) {\n      throw new PrettyFormatPluginError(error.message, error.stack);\n    }\n  }\n\n  return null;\n}\n\nfunction printer(\n  val: unknown,\n  config: Config,\n  indentation: string,\n  depth: number,\n  refs: Refs,\n  hasCalledToJSON?: boolean,\n): string {\n  const plugin = findPlugin(config.plugins, val);\n  if (plugin !== null) {\n    return printPlugin(plugin, val, config, indentation, depth, refs);\n  }\n\n  const basicResult = printBasicValue(\n    val,\n    config.printFunctionName,\n    config.escapeRegex,\n    config.escapeString,\n  );\n  if (basicResult !== null) {\n    return basicResult;\n  }\n\n  return printComplexValue(\n    val,\n    config,\n    indentation,\n    depth,\n    refs,\n    hasCalledToJSON,\n  );\n}\n\nconst DEFAULT_THEME: Theme = {\n  comment: 'gray',\n  content: 'reset',\n  prop: 'yellow',\n  tag: 'cyan',\n  value: 'green',\n};\n\nconst DEFAULT_THEME_KEYS = Object.keys(DEFAULT_THEME) as Array<\n  keyof typeof DEFAULT_THEME\n>;\n\n// could be replaced by `satisfies` operator in the future: https://github.com/microsoft/TypeScript/issues/47920\nconst toOptionsSubtype = <T extends Options>(options: T) => options;\n\nexport const DEFAULT_OPTIONS = toOptionsSubtype({\n  callToJSON: true,\n  compareKeys: undefined,\n  escapeRegex: false,\n  escapeString: true,\n  highlight: false,\n  indent: 2,\n  maxDepth: Number.POSITIVE_INFINITY,\n  maxWidth: Number.POSITIVE_INFINITY,\n  min: false,\n  plugins: [],\n  printBasicPrototype: true,\n  printFunctionName: true,\n  theme: DEFAULT_THEME,\n});\n\nfunction validateOptions(options: OptionsReceived) {\n  for (const key of Object.keys(options)) {\n    if (!Object.prototype.hasOwnProperty.call(DEFAULT_OPTIONS, key)) {\n      throw new Error(`pretty-format: Unknown option \"${key}\".`);\n    }\n  }\n\n  if (options.min && options.indent !== undefined && options.indent !== 0) {\n    throw new Error(\n      'pretty-format: Options \"min\" and \"indent\" cannot be used together.',\n    );\n  }\n\n  if (options.theme !== undefined) {\n    if (options.theme === null) {\n      throw new Error('pretty-format: Option \"theme\" must not be null.');\n    }\n\n    if (typeof options.theme !== 'object') {\n      throw new TypeError(\n        `pretty-format: Option \"theme\" must be of type \"object\" but instead received \"${typeof options.theme}\".`,\n      );\n    }\n  }\n}\n\nconst getColorsHighlight = (options: OptionsReceived): Colors =>\n  DEFAULT_THEME_KEYS.reduce((colors, key) => {\n    const value =\n      options.theme && options.theme[key] !== undefined\n        ? options.theme[key]\n        : DEFAULT_THEME[key];\n    const color = value && (style as any)[value];\n    if (\n      color &&\n      typeof color.close === 'string' &&\n      typeof color.open === 'string'\n    ) {\n      colors[key] = color;\n    } else {\n      throw new Error(\n        `pretty-format: Option \"theme\" has a key \"${key}\" whose value \"${value}\" is undefined in ansi-styles.`,\n      );\n    }\n    return colors;\n  }, Object.create(null));\n\nconst getColorsEmpty = (): Colors =>\n  DEFAULT_THEME_KEYS.reduce((colors, key) => {\n    colors[key] = {close: '', open: ''};\n    return colors;\n  }, Object.create(null));\n\nconst getPrintFunctionName = (options?: OptionsReceived) =>\n  options?.printFunctionName ?? DEFAULT_OPTIONS.printFunctionName;\n\nconst getEscapeRegex = (options?: OptionsReceived) =>\n  options?.escapeRegex ?? DEFAULT_OPTIONS.escapeRegex;\n\nconst getEscapeString = (options?: OptionsReceived) =>\n  options?.escapeString ?? DEFAULT_OPTIONS.escapeString;\n\nconst getConfig = (options?: OptionsReceived): Config => ({\n  callToJSON: options?.callToJSON ?? DEFAULT_OPTIONS.callToJSON,\n  colors: options?.highlight ? getColorsHighlight(options) : getColorsEmpty(),\n  compareKeys:\n    typeof options?.compareKeys === 'function' || options?.compareKeys === null\n      ? options.compareKeys\n      : DEFAULT_OPTIONS.compareKeys,\n  escapeRegex: getEscapeRegex(options),\n  escapeString: getEscapeString(options),\n  indent: options?.min\n    ? ''\n    : createIndent(options?.indent ?? DEFAULT_OPTIONS.indent),\n  maxDepth: options?.maxDepth ?? DEFAULT_OPTIONS.maxDepth,\n  maxWidth: options?.maxWidth ?? DEFAULT_OPTIONS.maxWidth,\n  min: options?.min ?? DEFAULT_OPTIONS.min,\n  plugins: options?.plugins ?? DEFAULT_OPTIONS.plugins,\n  printBasicPrototype: options?.printBasicPrototype ?? true,\n  printFunctionName: getPrintFunctionName(options),\n  spacingInner: options?.min ? ' ' : '\\n',\n  spacingOuter: options?.min ? '' : '\\n',\n});\n\nfunction createIndent(indent: number): string {\n  return Array.from({length: indent + 1}).join(' ');\n}\n\n/**\n * Returns a presentation string of your `val` object\n * @param val any potential JavaScript object\n * @param options Custom settings\n */\nexport function format(val: unknown, options?: OptionsReceived): string {\n  if (options) {\n    validateOptions(options);\n    if (options.plugins) {\n      const plugin = findPlugin(options.plugins, val);\n      if (plugin !== null) {\n        return printPlugin(plugin, val, getConfig(options), '', 0, []);\n      }\n    }\n  }\n\n  const basicResult = printBasicValue(\n    val,\n    getPrintFunctionName(options),\n    getEscapeRegex(options),\n    getEscapeString(options),\n  );\n  if (basicResult !== null) {\n    return basicResult;\n  }\n\n  return printComplexValue(val, getConfig(options), '', 0, []);\n}\n\nexport const plugins = {\n  AsymmetricMatcher,\n  DOMCollection,\n  DOMElement,\n  Immutable,\n  ReactElement,\n  ReactTestComponent,\n};\n\nexport default format;\n",
  "packages/pretty-format/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { NewPlugin, OptionsReceived } from './types';\nexport type { Colors, CompareKeys, Config, Options, OptionsReceived, OldPlugin, NewPlugin, Plugin, Plugins, PrettyFormatOptions, Printer, Refs, Theme, } from './types';\nexport declare const DEFAULT_OPTIONS: {\n    callToJSON: boolean;\n    compareKeys: undefined;\n    escapeRegex: boolean;\n    escapeString: boolean;\n    highlight: boolean;\n    indent: number;\n    maxDepth: number;\n    maxWidth: number;\n    min: boolean;\n    plugins: never[];\n    printBasicPrototype: boolean;\n    printFunctionName: boolean;\n    theme: SnapshotFormat;\n};\n/**\n * Returns a presentation string of your `val` object\n * @param val any potential JavaScript object\n * @param options Custom settings\n */\nexport declare function format(val: unknown, options?: OptionsReceived): string;\nexport declare const plugins: {\n    AsymmetricMatcher: NewPlugin;\n    DOMCollection: NewPlugin;\n    DOMElement: NewPlugin;\n    Immutable: NewPlugin;\n    ReactElement: NewPlugin;\n    ReactTestComponent: NewPlugin;\n};\nexport default format;\n",
  "packages/pretty-format/src/collections.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {CompareKeys, Config, Printer, Refs} from './types';\n\nconst getKeysOfEnumerableProperties = (\n  object: Record<string, unknown>,\n  compareKeys: CompareKeys,\n) => {\n  const rawKeys = Object.keys(object);\n  const keys: Array<string | symbol> =\n    compareKeys === null ? rawKeys : rawKeys.sort(compareKeys);\n\n  if (Object.getOwnPropertySymbols) {\n    for (const symbol of Object.getOwnPropertySymbols(object)) {\n      if (Object.getOwnPropertyDescriptor(object, symbol)!.enumerable) {\n        keys.push(symbol);\n      }\n    }\n  }\n\n  return keys as Array<string>;\n};\n\n/**\n * Return entries (for example, of a map)\n * with spacing, indentation, and comma\n * without surrounding punctuation (for example, braces)\n */\nexport function printIteratorEntries(\n  iterator: Iterator<[unknown, unknown]>,\n  config: Config,\n  indentation: string,\n  depth: number,\n  refs: Refs,\n  printer: Printer,\n  // Too bad, so sad that separator for ECMAScript Map has been ' => '\n  // What a distracting diff if you change a data structure to/from\n  // ECMAScript Object or Immutable.Map/OrderedMap which use the default.\n  separator = ': ',\n): string {\n  let result = '';\n  let width = 0;\n  let current = iterator.next();\n\n  if (!current.done) {\n    result += config.spacingOuter;\n\n    const indentationNext = indentation + config.indent;\n\n    while (!current.done) {\n      result += indentationNext;\n\n      if (width++ === config.maxWidth) {\n        result += '…';\n        break;\n      }\n\n      const name = printer(\n        current.value[0],\n        config,\n        indentationNext,\n        depth,\n        refs,\n      );\n      const value = printer(\n        current.value[1],\n        config,\n        indentationNext,\n        depth,\n        refs,\n      );\n\n      result += name + separator + value;\n\n      current = iterator.next();\n\n      if (!current.done) {\n        result += `,${config.spacingInner}`;\n      } else if (!config.min) {\n        result += ',';\n      }\n    }\n\n    result += config.spacingOuter + indentation;\n  }\n\n  return result;\n}\n\n/**\n * Return values (for example, of a set)\n * with spacing, indentation, and comma\n * without surrounding punctuation (braces or brackets)\n */\nexport function printIteratorValues(\n  iterator: Iterator<unknown>,\n  config: Config,\n  indentation: string,\n  depth: number,\n  refs: Refs,\n  printer: Printer,\n): string {\n  let result = '';\n  let width = 0;\n  let current = iterator.next();\n\n  if (!current.done) {\n    result += config.spacingOuter;\n\n    const indentationNext = indentation + config.indent;\n\n    while (!current.done) {\n      result += indentationNext;\n\n      if (width++ === config.maxWidth) {\n        result += '…';\n        break;\n      }\n\n      result += printer(current.value, config, indentationNext, depth, refs);\n\n      current = iterator.next();\n\n      if (!current.done) {\n        result += `,${config.spacingInner}`;\n      } else if (!config.min) {\n        result += ',';\n      }\n    }\n\n    result += config.spacingOuter + indentation;\n  }\n\n  return result;\n}\n\n/**\n * Return items (for example, of an array)\n * with spacing, indentation, and comma\n * without surrounding punctuation (for example, brackets)\n **/\nexport function printListItems(\n  list: ArrayLike<unknown> | DataView | ArrayBuffer,\n  config: Config,\n  indentation: string,\n  depth: number,\n  refs: Refs,\n  printer: Printer,\n): string {\n  let result = '';\n  list = list instanceof ArrayBuffer ? new DataView(list) : list;\n  const isDataView = (l: unknown): l is DataView => l instanceof DataView;\n  const length = isDataView(list) ? list.byteLength : list.length;\n\n  if (length > 0) {\n    result += config.spacingOuter;\n\n    const indentationNext = indentation + config.indent;\n\n    for (let i = 0; i < length; i++) {\n      result += indentationNext;\n\n      if (i === config.maxWidth) {\n        result += '…';\n        break;\n      }\n\n      if (isDataView(list) || i in list) {\n        result += printer(\n          isDataView(list) ? list.getInt8(i) : list[i],\n          config,\n          indentationNext,\n          depth,\n          refs,\n        );\n      }\n\n      if (i < length - 1) {\n        result += `,${config.spacingInner}`;\n      } else if (!config.min) {\n        result += ',';\n      }\n    }\n\n    result += config.spacingOuter + indentation;\n  }\n\n  return result;\n}\n\n/**\n * Return properties of an object\n * with spacing, indentation, and comma\n * without surrounding punctuation (for example, braces)\n */\nexport function printObjectProperties(\n  val: Record<string, unknown>,\n  config: Config,\n  indentation: string,\n  depth: number,\n  refs: Refs,\n  printer: Printer,\n): string {\n  let result = '';\n  const keys = getKeysOfEnumerableProperties(val, config.compareKeys);\n\n  if (keys.length > 0) {\n    result += config.spacingOuter;\n\n    const indentationNext = indentation + config.indent;\n\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      const name = printer(key, config, indentationNext, depth, refs);\n      const value = printer(val[key], config, indentationNext, depth, refs);\n\n      result += `${indentationNext + name}: ${value}`;\n\n      if (i < keys.length - 1) {\n        result += `,${config.spacingInner}`;\n      } else if (!config.min) {\n        result += ',';\n      }\n    }\n\n    result += config.spacingOuter + indentation;\n  }\n\n  return result;\n}\n",
  "packages/pretty-format/src/collections.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport type { Config, Printer, Refs } from './types';\n/**\n * Return entries (for example, of a map)\n * with spacing, indentation, and comma\n * without surrounding punctuation (for example, braces)\n */\nexport declare function printIteratorEntries(iterator: Iterator<[unknown, unknown]>, config: Config, indentation: string, depth: number, refs: Refs, printer: Printer, separator?: string): string;\n/**\n * Return values (for example, of a set)\n * with spacing, indentation, and comma\n * without surrounding punctuation (braces or brackets)\n */\nexport declare function printIteratorValues(iterator: Iterator<unknown>, config: Config, indentation: string, depth: number, refs: Refs, printer: Printer): string;\n/**\n * Return items (for example, of an array)\n * with spacing, indentation, and comma\n * without surrounding punctuation (for example, brackets)\n **/\nexport declare function printListItems(list: ArrayLike<unknown> | DataView | ArrayBuffer, config: Config, indentation: string, depth: number, refs: Refs, printer: Printer): string;\n/**\n * Return properties of an object\n * with spacing, indentation, and comma\n * without surrounding punctuation (for example, braces)\n */\nexport declare function printObjectProperties(val: Record<string, unknown>, config: Config, indentation: string, depth: number, refs: Refs, printer: Printer): string;\n",
  "packages/pretty-format/src/plugins/ReactTestComponent.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {Config, NewPlugin, Printer, Refs} from '../types';\nimport {\n  printChildren,\n  printElement,\n  printElementAsLeaf,\n  printProps,\n} from './lib/markup';\n\nexport type ReactTestObject = {\n  $$typeof: symbol;\n  type: string;\n  props?: Record<string, unknown>;\n  children?: null | Array<ReactTestChild>;\n};\n\n// Child can be `number` in Stack renderer but not in Fiber renderer.\ntype ReactTestChild = ReactTestObject | string | number;\n\nconst testSymbol =\n  typeof Symbol === 'function' && Symbol.for\n    ? Symbol.for('react.test.json')\n    : 0xe_a7_13_57;\n\nconst getPropKeys = (object: ReactTestObject) => {\n  const {props} = object;\n\n  return props\n    ? Object.keys(props)\n        .filter(key => props[key] !== undefined)\n        .sort()\n    : [];\n};\n\nexport const serialize: NewPlugin['serialize'] = (\n  object: ReactTestObject,\n  config: Config,\n  indentation: string,\n  depth: number,\n  refs: Refs,\n  printer: Printer,\n) =>\n  ++depth > config.maxDepth\n    ? printElementAsLeaf(object.type, config)\n    : printElement(\n        object.type,\n        object.props\n          ? printProps(\n              getPropKeys(object),\n              object.props,\n              config,\n              indentation + config.indent,\n              depth,\n              refs,\n              printer,\n            )\n          : '',\n        object.children\n          ? printChildren(\n              object.children,\n              config,\n              indentation + config.indent,\n              depth,\n              refs,\n              printer,\n            )\n          : '',\n        config,\n        indentation,\n      );\n\nexport const test: NewPlugin['test'] = val =>\n  val && val.$$typeof === testSymbol;\n\nconst plugin: NewPlugin = {serialize, test};\n\nexport default plugin;\n",
  "packages/pretty-format/src/plugins/ReactTestComponent.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { NewPlugin } from '../types';\nexport type ReactTestObject = {\n    $$typeof: symbol;\n    type: string;\n    props?: Record<string, unknown>;\n    children?: null | Array<ReactTestChild>;\n};\ntype ReactTestChild = ReactTestObject | string | number;\nexport declare const serialize: NewPlugin['serialize'];\nexport declare const test: NewPlugin['test'];\ndeclare const plugin: NewPlugin;\nexport default plugin;\n",
  "packages/pretty-format/src/plugins/ReactElement.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as ReactIs from 'react-is';\nimport type {Config, NewPlugin, Printer, Refs} from '../types';\nimport {\n  printChildren,\n  printElement,\n  printElementAsLeaf,\n  printProps,\n} from './lib/markup';\n\n// Given element.props.children, or subtree during recursive traversal,\n// return flattened array of children.\nconst getChildren = (arg: unknown, children: Array<unknown> = []) => {\n  if (Array.isArray(arg)) {\n    for (const item of arg) {\n      getChildren(item, children);\n    }\n  } else if (arg != null && arg !== false && arg !== '') {\n    children.push(arg);\n  }\n  return children;\n};\n\nconst getType = (element: any) => {\n  const type = element.type;\n  if (typeof type === 'string') {\n    return type;\n  }\n  if (typeof type === 'function') {\n    return type.displayName || type.name || 'Unknown';\n  }\n\n  if (ReactIs.isFragment(element)) {\n    return 'React.Fragment';\n  }\n  if (ReactIs.isSuspense(element)) {\n    return 'React.Suspense';\n  }\n  if (typeof type === 'object' && type !== null) {\n    if (ReactIs.isContextProvider(element)) {\n      return 'Context.Provider';\n    }\n\n    if (ReactIs.isContextConsumer(element)) {\n      return 'Context.Consumer';\n    }\n\n    if (ReactIs.isForwardRef(element)) {\n      if (type.displayName) {\n        return type.displayName;\n      }\n\n      const functionName = type.render.displayName || type.render.name || '';\n\n      return functionName === '' ? 'ForwardRef' : `ForwardRef(${functionName})`;\n    }\n\n    if (ReactIs.isMemo(element)) {\n      const functionName =\n        type.displayName || type.type.displayName || type.type.name || '';\n\n      return functionName === '' ? 'Memo' : `Memo(${functionName})`;\n    }\n  }\n  return 'UNDEFINED';\n};\n\nconst getPropKeys = (element: any) => {\n  const {props} = element;\n\n  return Object.keys(props)\n    .filter(key => key !== 'children' && props[key] !== undefined)\n    .sort();\n};\n\nexport const serialize: NewPlugin['serialize'] = (\n  element: any,\n  config: Config,\n  indentation: string,\n  depth: number,\n  refs: Refs,\n  printer: Printer,\n) =>\n  ++depth > config.maxDepth\n    ? printElementAsLeaf(getType(element), config)\n    : printElement(\n        getType(element),\n        printProps(\n          getPropKeys(element),\n          element.props,\n          config,\n          indentation + config.indent,\n          depth,\n          refs,\n          printer,\n        ),\n        printChildren(\n          getChildren(element.props.children),\n          config,\n          indentation + config.indent,\n          depth,\n          refs,\n          printer,\n        ),\n        config,\n        indentation,\n      );\n\nexport const test: NewPlugin['test'] = (val: unknown) =>\n  val != null && ReactIs.isElement(val);\n\nconst plugin: NewPlugin = {serialize, test};\n\nexport default plugin;\n",
  "packages/pretty-format/src/plugins/ReactElement.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { NewPlugin } from '../types';\nexport declare const serialize: NewPlugin['serialize'];\nexport declare const test: NewPlugin['test'];\ndeclare const plugin: NewPlugin;\nexport default plugin;\n",
  "packages/pretty-format/src/plugins/Immutable.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {printIteratorEntries, printIteratorValues} from '../collections';\nimport type {Config, NewPlugin, Printer, Refs} from '../types';\n\n// SENTINEL constants are from https://github.com/facebook/immutable-js\nconst IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\nconst IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';\nconst IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\nconst IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';\nconst IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\nconst IS_RECORD_SENTINEL = '@@__IMMUTABLE_RECORD__@@'; // immutable v4\nconst IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';\nconst IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';\nconst IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';\n\nconst getImmutableName = (name: string) => `Immutable.${name}`;\nconst printAsLeaf = (name: string) => `[${name}]`;\nconst SPACE = ' ';\nconst LAZY = '…'; // Seq is lazy if it calls a method like filter\n\nconst printImmutableEntries = (\n  val: any,\n  config: Config,\n  indentation: string,\n  depth: number,\n  refs: Refs,\n  printer: Printer,\n  type: string,\n): string =>\n  ++depth > config.maxDepth\n    ? printAsLeaf(getImmutableName(type))\n    : `${getImmutableName(type) + SPACE}{${printIteratorEntries(\n        val.entries(),\n        config,\n        indentation,\n        depth,\n        refs,\n        printer,\n      )}}`;\n\n// Record has an entries method because it is a collection in immutable v3.\n// Return an iterator for Immutable Record from version v3 or v4.\nfunction getRecordEntries(val: any): Iterator<any> {\n  let i = 0;\n  return {\n    next() {\n      if (i < val._keys.length) {\n        const key = val._keys[i++];\n        return {done: false, value: [key, val.get(key)]};\n      }\n      return {done: true, value: undefined};\n    },\n  };\n}\n\nconst printImmutableRecord = (\n  val: any,\n  config: Config,\n  indentation: string,\n  depth: number,\n  refs: Refs,\n  printer: Printer,\n): string => {\n  // _name property is defined only for an Immutable Record instance\n  // which was constructed with a second optional descriptive name arg\n  const name = getImmutableName(val._name || 'Record');\n  return ++depth > config.maxDepth\n    ? printAsLeaf(name)\n    : `${name + SPACE}{${printIteratorEntries(\n        getRecordEntries(val),\n        config,\n        indentation,\n        depth,\n        refs,\n        printer,\n      )}}`;\n};\n\nconst printImmutableSeq = (\n  val: any,\n  config: Config,\n  indentation: string,\n  depth: number,\n  refs: Refs,\n  printer: Printer,\n): string => {\n  const name = getImmutableName('Seq');\n\n  if (++depth > config.maxDepth) {\n    return printAsLeaf(name);\n  }\n\n  if (val[IS_KEYED_SENTINEL]) {\n    return `${name + SPACE}{${\n      // from Immutable collection of entries or from ECMAScript object\n      val._iter || val._object\n        ? printIteratorEntries(\n            val.entries(),\n            config,\n            indentation,\n            depth,\n            refs,\n            printer,\n          )\n        : LAZY\n    }}`;\n  }\n\n  return `${name + SPACE}[${\n    val._iter || // from Immutable collection of values\n    val._array || // from ECMAScript array\n    val._collection || // from ECMAScript collection in immutable v4\n    val._iterable // from ECMAScript collection in immutable v3\n      ? printIteratorValues(\n          val.values(),\n          config,\n          indentation,\n          depth,\n          refs,\n          printer,\n        )\n      : LAZY\n  }]`;\n};\n\nconst printImmutableValues = (\n  val: any,\n  config: Config,\n  indentation: string,\n  depth: number,\n  refs: Refs,\n  printer: Printer,\n  type: string,\n): string =>\n  ++depth > config.maxDepth\n    ? printAsLeaf(getImmutableName(type))\n    : `${getImmutableName(type) + SPACE}[${printIteratorValues(\n        val.values(),\n        config,\n        indentation,\n        depth,\n        refs,\n        printer,\n      )}]`;\n\nexport const serialize: NewPlugin['serialize'] = (\n  val: any,\n  config: Config,\n  indentation: string,\n  depth: number,\n  refs: Refs,\n  printer: Printer,\n) => {\n  if (val[IS_MAP_SENTINEL]) {\n    return printImmutableEntries(\n      val,\n      config,\n      indentation,\n      depth,\n      refs,\n      printer,\n      val[IS_ORDERED_SENTINEL] ? 'OrderedMap' : 'Map',\n    );\n  }\n\n  if (val[IS_LIST_SENTINEL]) {\n    return printImmutableValues(\n      val,\n      config,\n      indentation,\n      depth,\n      refs,\n      printer,\n      'List',\n    );\n  }\n  if (val[IS_SET_SENTINEL]) {\n    return printImmutableValues(\n      val,\n      config,\n      indentation,\n      depth,\n      refs,\n      printer,\n      val[IS_ORDERED_SENTINEL] ? 'OrderedSet' : 'Set',\n    );\n  }\n  if (val[IS_STACK_SENTINEL]) {\n    return printImmutableValues(\n      val,\n      config,\n      indentation,\n      depth,\n      refs,\n      printer,\n      'Stack',\n    );\n  }\n\n  if (val[IS_SEQ_SENTINEL]) {\n    return printImmutableSeq(val, config, indentation, depth, refs, printer);\n  }\n\n  // For compatibility with immutable v3 and v4, let record be the default.\n  return printImmutableRecord(val, config, indentation, depth, refs, printer);\n};\n\n// Explicitly comparing sentinel properties to true avoids false positive\n// when mock identity-obj-proxy returns the key as the value for any key.\nexport const test: NewPlugin['test'] = (val: any) =>\n  val &&\n  (val[IS_ITERABLE_SENTINEL] === true || val[IS_RECORD_SENTINEL] === true);\n\nconst plugin: NewPlugin = {serialize, test};\n\nexport default plugin;\n",
  "packages/pretty-format/src/plugins/Immutable.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { NewPlugin } from '../types';\nexport declare const serialize: NewPlugin['serialize'];\nexport declare const test: NewPlugin['test'];\ndeclare const plugin: NewPlugin;\nexport default plugin;\n",
  "packages/pretty-format/src/plugins/DOMElement.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {Config, NewPlugin, Printer, Refs} from '../types';\nimport {\n  printChildren,\n  printComment,\n  printElement,\n  printElementAsLeaf,\n  printProps,\n  printText,\n} from './lib/markup';\n\nconst ELEMENT_NODE = 1;\nconst TEXT_NODE = 3;\nconst COMMENT_NODE = 8;\nconst FRAGMENT_NODE = 11;\n\nconst ELEMENT_REGEXP = /^((HTML|SVG)\\w*)?Element$/;\n\nconst testHasAttribute = (val: any) => {\n  try {\n    return typeof val.hasAttribute === 'function' && val.hasAttribute('is');\n  } catch {\n    return false;\n  }\n};\n\nconst isCustomElement = (val: any) => {\n  const tagName = val?.tagName;\n  return (\n    (typeof tagName === 'string' && tagName.includes('-')) ||\n    testHasAttribute(val)\n  );\n};\n\nconst testNode = (val: any) => {\n  const constructorName = val.constructor.name;\n  const {nodeType} = val;\n\n  return (\n    (nodeType === ELEMENT_NODE &&\n      (ELEMENT_REGEXP.test(constructorName) || isCustomElement(val))) ||\n    (nodeType === TEXT_NODE && constructorName === 'Text') ||\n    (nodeType === COMMENT_NODE && constructorName === 'Comment') ||\n    (nodeType === FRAGMENT_NODE && constructorName === 'DocumentFragment')\n  );\n};\n\nexport const test: NewPlugin['test'] = (val: any) =>\n  (val?.constructor?.name || isCustomElement(val)) && testNode(val);\n\ntype HandledType = Element | Text | Comment | DocumentFragment;\n\nfunction nodeIsText(node: HandledType): node is Text {\n  return node.nodeType === TEXT_NODE;\n}\n\nfunction nodeIsComment(node: HandledType): node is Comment {\n  return node.nodeType === COMMENT_NODE;\n}\n\nfunction nodeIsFragment(node: HandledType): node is DocumentFragment {\n  return node.nodeType === FRAGMENT_NODE;\n}\n\nexport const serialize: NewPlugin['serialize'] = (\n  node: HandledType,\n  config: Config,\n  indentation: string,\n  depth: number,\n  refs: Refs,\n  printer: Printer,\n) => {\n  if (nodeIsText(node)) {\n    return printText(node.data, config);\n  }\n\n  if (nodeIsComment(node)) {\n    return printComment(node.data, config);\n  }\n\n  const type = nodeIsFragment(node)\n    ? 'DocumentFragment'\n    : node.tagName.toLowerCase();\n\n  if (++depth > config.maxDepth) {\n    return printElementAsLeaf(type, config);\n  }\n\n  return printElement(\n    type,\n    printProps(\n      nodeIsFragment(node)\n        ? []\n        : Array.from(node.attributes, attr => attr.name).sort(),\n      nodeIsFragment(node)\n        ? {}\n        : [...node.attributes].reduce<Record<string, string>>(\n            (props, attribute) => {\n              props[attribute.name] = attribute.value;\n              return props;\n            },\n            {},\n          ),\n      config,\n      indentation + config.indent,\n      depth,\n      refs,\n      printer,\n    ),\n    printChildren(\n      Array.prototype.slice.call(node.childNodes || node.children),\n      config,\n      indentation + config.indent,\n      depth,\n      refs,\n      printer,\n    ),\n    config,\n    indentation,\n  );\n};\n\nconst plugin: NewPlugin = {serialize, test};\n\nexport default plugin;\n",
  "packages/pretty-format/src/plugins/DOMElement.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { NewPlugin } from '../types';\nexport declare const test: NewPlugin['test'];\nexport declare const serialize: NewPlugin['serialize'];\ndeclare const plugin: NewPlugin;\nexport default plugin;\n",
  "packages/pretty-format/src/plugins/DOMCollection.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {printListItems, printObjectProperties} from '../collections';\nimport type {Config, NewPlugin, Printer, Refs} from '../types';\n\nconst SPACE = ' ';\n\nconst OBJECT_NAMES = new Set(['DOMStringMap', 'NamedNodeMap']);\nconst ARRAY_REGEXP = /^(HTML\\w*Collection|NodeList)$/;\n\nconst testName = (name: any) =>\n  OBJECT_NAMES.has(name) || ARRAY_REGEXP.test(name);\n\nexport const test: NewPlugin['test'] = (val: object) =>\n  val &&\n  val.constructor &&\n  !!val.constructor.name &&\n  testName(val.constructor.name);\n\nconst isNamedNodeMap = (collection: object): collection is NamedNodeMap =>\n  collection.constructor.name === 'NamedNodeMap';\n\nexport const serialize: NewPlugin['serialize'] = (\n  collection: any | NamedNodeMap,\n  config: Config,\n  indentation: string,\n  depth: number,\n  refs: Refs,\n  printer: Printer,\n) => {\n  const name = collection.constructor.name;\n  if (++depth > config.maxDepth) {\n    return `[${name}]`;\n  }\n\n  return (\n    (config.min ? '' : name + SPACE) +\n    (OBJECT_NAMES.has(name)\n      ? `{${printObjectProperties(\n          isNamedNodeMap(collection)\n            ? [...collection].reduce<Record<string, string>>(\n                (props, attribute) => {\n                  props[attribute.name] = attribute.value;\n                  return props;\n                },\n                {},\n              )\n            : {...collection},\n          config,\n          indentation,\n          depth,\n          refs,\n          printer,\n        )}}`\n      : `[${printListItems(\n          [...collection],\n          config,\n          indentation,\n          depth,\n          refs,\n          printer,\n        )}]`)\n  );\n};\n\nconst plugin: NewPlugin = {serialize, test};\n\nexport default plugin;\n",
  "packages/pretty-format/src/plugins/DOMCollection.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { NewPlugin } from '../types';\nexport declare const test: NewPlugin['test'];\nexport declare const serialize: NewPlugin['serialize'];\ndeclare const plugin: NewPlugin;\nexport default plugin;\n",
  "packages/pretty-format/src/plugins/AsymmetricMatcher.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {printListItems, printObjectProperties} from '../collections';\nimport type {Config, NewPlugin, Printer, Refs} from '../types';\n\nconst asymmetricMatcher =\n  typeof Symbol === 'function' && Symbol.for\n    ? Symbol.for('jest.asymmetricMatcher')\n    : 0x13_57_a5;\nconst SPACE = ' ';\n\nexport const serialize: NewPlugin['serialize'] = (\n  val: any,\n  config: Config,\n  indentation: string,\n  depth: number,\n  refs: Refs,\n  printer: Printer,\n) => {\n  const stringedValue = val.toString();\n\n  if (\n    stringedValue === 'ArrayContaining' ||\n    stringedValue === 'ArrayNotContaining'\n  ) {\n    if (++depth > config.maxDepth) {\n      return `[${stringedValue}]`;\n    }\n    return `${stringedValue + SPACE}[${printListItems(\n      val.sample,\n      config,\n      indentation,\n      depth,\n      refs,\n      printer,\n    )}]`;\n  }\n\n  if (\n    stringedValue === 'ObjectContaining' ||\n    stringedValue === 'ObjectNotContaining'\n  ) {\n    if (++depth > config.maxDepth) {\n      return `[${stringedValue}]`;\n    }\n    return `${stringedValue + SPACE}{${printObjectProperties(\n      val.sample,\n      config,\n      indentation,\n      depth,\n      refs,\n      printer,\n    )}}`;\n  }\n\n  if (\n    stringedValue === 'StringMatching' ||\n    stringedValue === 'StringNotMatching'\n  ) {\n    return (\n      stringedValue +\n      SPACE +\n      printer(val.sample, config, indentation, depth, refs)\n    );\n  }\n\n  if (\n    stringedValue === 'StringContaining' ||\n    stringedValue === 'StringNotContaining'\n  ) {\n    return (\n      stringedValue +\n      SPACE +\n      printer(val.sample, config, indentation, depth, refs)\n    );\n  }\n\n  if (stringedValue === 'ArrayOf' || stringedValue === 'NotArrayOf') {\n    if (++depth > config.maxDepth) {\n      return `[${stringedValue}]`;\n    }\n    return `${stringedValue + SPACE}${printer(\n      val.sample,\n      config,\n      indentation,\n      depth,\n      refs,\n    )}`;\n  }\n\n  if (typeof val.toAsymmetricMatcher !== 'function') {\n    throw new TypeError(\n      `Asymmetric matcher ${val.constructor.name} does not implement toAsymmetricMatcher()`,\n    );\n  }\n\n  return val.toAsymmetricMatcher();\n};\n\nexport const test: NewPlugin['test'] = (val: any) =>\n  val && val.$$typeof === asymmetricMatcher;\n\nconst plugin: NewPlugin = {serialize, test};\n\nexport default plugin;\n",
  "packages/pretty-format/src/plugins/AsymmetricMatcher.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { NewPlugin } from '../types';\nexport declare const serialize: NewPlugin['serialize'];\nexport declare const test: NewPlugin['test'];\ndeclare const plugin: NewPlugin;\nexport default plugin;\n",
  "packages/pretty-format/src/plugins/lib/markup.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {Config, Printer, Refs} from '../../types';\nimport escapeHTML from './escapeHTML';\n\n// Return empty string if keys is empty.\nexport const printProps = (\n  keys: Array<string>,\n  props: Record<string, unknown>,\n  config: Config,\n  indentation: string,\n  depth: number,\n  refs: Refs,\n  printer: Printer,\n): string => {\n  const indentationNext = indentation + config.indent;\n  const colors = config.colors;\n  return keys\n    .map(key => {\n      const value = props[key];\n      let printed = printer(value, config, indentationNext, depth, refs);\n\n      if (typeof value !== 'string') {\n        if (printed.includes('\\n')) {\n          printed =\n            config.spacingOuter +\n            indentationNext +\n            printed +\n            config.spacingOuter +\n            indentation;\n        }\n        printed = `{${printed}}`;\n      }\n\n      return `${\n        config.spacingInner +\n        indentation +\n        colors.prop.open +\n        key +\n        colors.prop.close\n      }=${colors.value.open}${printed}${colors.value.close}`;\n    })\n    .join('');\n};\n\n// Return empty string if children is empty.\nexport const printChildren = (\n  children: Array<unknown>,\n  config: Config,\n  indentation: string,\n  depth: number,\n  refs: Refs,\n  printer: Printer,\n): string =>\n  children\n    .map(\n      child =>\n        config.spacingOuter +\n        indentation +\n        (typeof child === 'string'\n          ? printText(child, config)\n          : printer(child, config, indentation, depth, refs)),\n    )\n    .join('');\n\nexport const printText = (text: string, config: Config): string => {\n  const contentColor = config.colors.content;\n  return contentColor.open + escapeHTML(text) + contentColor.close;\n};\n\nexport const printComment = (comment: string, config: Config): string => {\n  const commentColor = config.colors.comment;\n  return `${commentColor.open}<!--${escapeHTML(comment)}-->${\n    commentColor.close\n  }`;\n};\n\n// Separate the functions to format props, children, and element,\n// so a plugin could override a particular function, if needed.\n// Too bad, so sad: the traditional (but unnecessary) space\n// in a self-closing tagColor requires a second test of printedProps.\nexport const printElement = (\n  type: string,\n  printedProps: string,\n  printedChildren: string,\n  config: Config,\n  indentation: string,\n): string => {\n  const tagColor = config.colors.tag;\n  return `${tagColor.open}<${type}${\n    printedProps &&\n    tagColor.close +\n      printedProps +\n      config.spacingOuter +\n      indentation +\n      tagColor.open\n  }${\n    printedChildren\n      ? `>${tagColor.close}${printedChildren}${config.spacingOuter}${indentation}${tagColor.open}</${type}`\n      : `${printedProps && !config.min ? '' : ' '}/`\n  }>${tagColor.close}`;\n};\n\nexport const printElementAsLeaf = (type: string, config: Config): string => {\n  const tagColor = config.colors.tag;\n  return `${tagColor.open}<${type}${tagColor.close} …${tagColor.open} />${tagColor.close}`;\n};\n",
  "packages/pretty-format/src/plugins/lib/markup.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config, Printer, Refs } from '../../types';\nexport declare const printProps: (keys: Array<string>, props: Record<string, unknown>, config: Config, indentation: string, depth: number, refs: Refs, printer: Printer) => string;\nexport declare const printChildren: (children: Array<unknown>, config: Config, indentation: string, depth: number, refs: Refs, printer: Printer) => string;\nexport declare const printText: (text: string, config: Config) => string;\nexport declare const printComment: (comment: string, config: Config) => string;\nexport declare const printElement: (type: string, printedProps: string, printedChildren: string, config: Config, indentation: string) => string;\nexport declare const printElementAsLeaf: (type: string, config: Config) => string;\n",
  "packages/pretty-format/src/plugins/lib/escapeHTML.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nexport default function escapeHTML(str: string): string {\n  return str.replaceAll('<', '&lt;').replaceAll('>', '&gt;');\n}\n",
  "packages/pretty-format/src/plugins/lib/escapeHTML.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport default function escapeHTML(str: string): string;\n",
  "packages/pretty-format/src/__tests__/setPrettyPrint.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport prettyFormat from '../';\nimport type {OptionsReceived, Plugins} from '../types';\n\ndeclare module 'expect' {\n  interface Matchers<R> {\n    toPrettyPrintTo(expected: unknown, options?: OptionsReceived): R;\n  }\n}\n\nconst setPrettyPrint = (plugins: Plugins) => {\n  expect.extend({\n    toPrettyPrintTo(\n      received: unknown,\n      expected: unknown,\n      options?: OptionsReceived,\n    ) {\n      const prettyFormatted = prettyFormat(received, {plugins, ...options});\n      const pass = prettyFormatted === expected;\n\n      return {\n        actual: prettyFormatted,\n        message: pass\n          ? () =>\n              `${this.utils.matcherHint('.not.toBe')}\\n\\n` +\n              'Expected value to not be:\\n' +\n              `  ${this.utils.printExpected(expected)}\\n` +\n              'Received:\\n' +\n              `  ${this.utils.printReceived(prettyFormatted)}`\n          : () => {\n              const diffString = this.utils.diff(expected, prettyFormatted, {\n                expand: this.expand,\n              });\n              return (\n                `${this.utils.matcherHint('.toBe')}\\n\\n` +\n                'Expected value to be:\\n' +\n                `  ${this.utils.printExpected(expected)}\\n` +\n                'Received:\\n' +\n                `  ${this.utils.printReceived(prettyFormatted)}${\n                  diffString == null ? '' : `\\n\\nDifference:\\n\\n${diffString}`\n                }`\n              );\n            },\n        pass,\n      };\n    },\n  });\n};\n\nexport default setPrettyPrint;\n",
  "packages/pretty-format/src/__tests__/setPrettyPrint.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { OptionsReceived, Plugins } from '../types';\ndeclare module 'expect' {\n    interface Matchers<R> {\n        toPrettyPrintTo(expected: unknown, options?: OptionsReceived): R;\n    }\n}\ndeclare const setPrettyPrint: (plugins: Plugins) => void;\nexport default setPrettyPrint;\n",
  "packages/pretty-format/src/__tests__/prettyFormat.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/* eslint-disable local/prefer-rest-params-eventually */\n\nimport prettyFormat, {type PrettyFormatOptions} from '../';\n\nfunction returnArguments(..._args: Array<unknown>) {\n  return arguments;\n}\n\nclass MyArray<T> extends Array<T> {}\n\nfunction MyObject(value: unknown) {\n  // @ts-expect-error\n  this.name = value;\n}\n\ndescribe('prettyFormat()', () => {\n  it('prints empty arguments', () => {\n    const val = returnArguments();\n    expect(prettyFormat(val)).toBe('Arguments []');\n  });\n\n  it('prints arguments', () => {\n    const val = returnArguments(1, 2, 3);\n    expect(prettyFormat(val)).toBe('Arguments [\\n  1,\\n  2,\\n  3,\\n]');\n  });\n\n  it('prints an empty array', () => {\n    const val: Array<never> = [];\n    expect(prettyFormat(val)).toBe('Array []');\n  });\n\n  it('prints an array with items', () => {\n    const val = [1, 2, 3];\n    expect(prettyFormat(val)).toBe('Array [\\n  1,\\n  2,\\n  3,\\n]');\n  });\n\n  it('prints a sparse array with only holes', () => {\n    // eslint-disable-next-line no-sparse-arrays\n    const val = [, , ,];\n    expect(prettyFormat(val)).toBe('Array [\\n  ,\\n  ,\\n  ,\\n]');\n  });\n\n  it('prints a sparse array with items', () => {\n    // eslint-disable-next-line no-sparse-arrays\n    const val = [1, , , 4];\n    expect(prettyFormat(val)).toBe('Array [\\n  1,\\n  ,\\n  ,\\n  4,\\n]');\n  });\n\n  it('prints a sparse array with value surrounded by holes', () => {\n    // eslint-disable-next-line no-sparse-arrays\n    const val = [, 5, ,];\n    expect(prettyFormat(val)).toBe('Array [\\n  ,\\n  5,\\n  ,\\n]');\n  });\n\n  it('prints a sparse array also containing undefined values', () => {\n    // eslint-disable-next-line no-sparse-arrays\n    const val = [1, , undefined, undefined, , 4];\n    expect(prettyFormat(val)).toBe(\n      'Array [\\n  1,\\n  ,\\n  undefined,\\n  undefined,\\n  ,\\n  4,\\n]',\n    );\n  });\n\n  it('prints a empty typed array', () => {\n    const val = new Uint32Array(0);\n    expect(prettyFormat(val)).toBe('Uint32Array []');\n  });\n\n  it('prints a typed array with items', () => {\n    const val = new Uint32Array(3);\n    expect(prettyFormat(val)).toBe('Uint32Array [\\n  0,\\n  0,\\n  0,\\n]');\n  });\n\n  it('prints an array buffer', () => {\n    const val = new ArrayBuffer(3);\n    expect(prettyFormat(val)).toBe('ArrayBuffer [\\n  0,\\n  0,\\n  0,\\n]');\n  });\n\n  it('prints an data view', () => {\n    const val = new DataView(new ArrayBuffer(3));\n    expect(prettyFormat(val)).toBe('DataView [\\n  0,\\n  0,\\n  0,\\n]');\n  });\n\n  it('prints a nested array', () => {\n    const val = [[1, 2, 3]];\n    expect(prettyFormat(val)).toBe(\n      'Array [\\n  Array [\\n    1,\\n    2,\\n    3,\\n  ],\\n]',\n    );\n  });\n\n  it('prints true', () => {\n    const val = true;\n    expect(prettyFormat(val)).toBe('true');\n  });\n\n  it('prints false', () => {\n    const val = false;\n    expect(prettyFormat(val)).toBe('false');\n  });\n\n  it('prints an error', () => {\n    const val = new Error();\n    expect(prettyFormat(val)).toBe('[Error]');\n  });\n\n  it('prints a typed error with a message', () => {\n    const val = new TypeError('message');\n    expect(prettyFormat(val)).toBe('[TypeError: message]');\n  });\n\n  it('prints a function constructor', () => {\n    /* eslint-disable no-new-func */\n    const val = new Function();\n    /* eslint-enable no-new-func */\n    // In Node >=8.1.4: val.name === 'anonymous'\n    expect(prettyFormat(val)).toBe('[Function anonymous]');\n  });\n\n  it('prints an anonymous callback function', () => {\n    let val;\n    function f(cb: () => void) {\n      val = cb;\n    }\n    f(() => {});\n    // In Node >=8.1.4: val.name === ''\n    expect(prettyFormat(val)).toBe('[Function anonymous]');\n  });\n\n  it('prints an anonymous assigned function', () => {\n    const val = () => {};\n    const formatted = prettyFormat(val);\n    // Node 6.5 infers function names\n    expect(\n      formatted === '[Function anonymous]' || formatted === '[Function val]',\n    ).toBeTruthy();\n  });\n\n  it('prints a named function', () => {\n    const val = function named() {};\n    expect(prettyFormat(val)).toBe('[Function named]');\n  });\n\n  it('prints a named generator function', () => {\n    const val = function* generate() {\n      yield 1;\n      yield 2;\n      yield 3;\n    };\n    expect(prettyFormat(val)).toBe('[Function generate]');\n  });\n\n  it('can customize function names', () => {\n    const val = function named() {};\n    expect(\n      prettyFormat(val, {\n        printFunctionName: false,\n      }),\n    ).toBe('[Function]');\n  });\n\n  it('prints Infinity', () => {\n    const val = Number.POSITIVE_INFINITY;\n    expect(prettyFormat(val)).toBe('Infinity');\n  });\n\n  it('prints -Infinity', () => {\n    const val = Number.NEGATIVE_INFINITY;\n    expect(prettyFormat(val)).toBe('-Infinity');\n  });\n\n  it('prints an empty map', () => {\n    const val = new Map();\n    expect(prettyFormat(val)).toBe('Map {}');\n  });\n\n  it('prints a map with values', () => {\n    const val = new Map();\n    val.set('prop1', 'value1');\n    val.set('prop2', 'value2');\n    expect(prettyFormat(val)).toBe(\n      'Map {\\n  \"prop1\" => \"value1\",\\n  \"prop2\" => \"value2\",\\n}',\n    );\n  });\n\n  it('prints a map with non-string keys', () => {\n    const val = new Map<unknown, unknown>([\n      [false, 'boolean'],\n      ['false', 'string'],\n      [0, 'number'],\n      ['0', 'string'],\n      [null, 'null'],\n      ['null', 'string'],\n      [undefined, 'undefined'],\n      ['undefined', 'string'],\n      [Symbol('description'), 'symbol'],\n      ['Symbol(description)', 'string'],\n      [['array', 'key'], 'array'],\n      [{key: 'value'}, 'object'],\n    ]);\n    const expected = [\n      'Map {',\n      '  false => \"boolean\",',\n      '  \"false\" => \"string\",',\n      '  0 => \"number\",',\n      '  \"0\" => \"string\",',\n      '  null => \"null\",',\n      '  \"null\" => \"string\",',\n      '  undefined => \"undefined\",',\n      '  \"undefined\" => \"string\",',\n      '  Symbol(description) => \"symbol\",',\n      '  \"Symbol(description)\" => \"string\",',\n      '  Array [',\n      '    \"array\",',\n      '    \"key\",',\n      '  ] => \"array\",',\n      '  Object {',\n      '    \"key\": \"value\",',\n      '  } => \"object\",',\n      '}',\n    ].join('\\n');\n    expect(prettyFormat(val)).toEqual(expected);\n  });\n\n  it('prints NaN', () => {\n    const val = Number.NaN;\n    expect(prettyFormat(val)).toBe('NaN');\n  });\n\n  it('prints null', () => {\n    const val = null;\n    expect(prettyFormat(val)).toBe('null');\n  });\n\n  it('prints a positive number', () => {\n    const val = 123;\n    expect(prettyFormat(val)).toBe('123');\n  });\n\n  it('prints a negative number', () => {\n    const val = -123;\n    expect(prettyFormat(val)).toBe('-123');\n  });\n\n  it('prints zero', () => {\n    const val = 0;\n    expect(prettyFormat(val)).toBe('0');\n  });\n\n  it('prints negative zero', () => {\n    const val = -0;\n    expect(prettyFormat(val)).toBe('-0');\n  });\n\n  it('prints a positive bigint', () => {\n    const val = BigInt(123);\n    expect(prettyFormat(val)).toBe('123n');\n  });\n\n  it('prints a negative bigint', () => {\n    const val = BigInt(-123);\n    expect(prettyFormat(val)).toBe('-123n');\n  });\n\n  it('prints zero bigint', () => {\n    const val = BigInt(0);\n    expect(prettyFormat(val)).toBe('0n');\n  });\n\n  it('prints negative zero bigint', () => {\n    const val = BigInt(-0);\n    expect(prettyFormat(val)).toBe('0n');\n  });\n\n  it('prints a date', () => {\n    const val = new Date(10e11);\n    expect(prettyFormat(val)).toBe('2001-09-09T01:46:40.000Z');\n  });\n\n  it('prints an invalid date', () => {\n    const val = new Date(Number.POSITIVE_INFINITY);\n    expect(prettyFormat(val)).toBe('Date { NaN }');\n  });\n\n  it('prints an empty object', () => {\n    const val = {};\n    expect(prettyFormat(val)).toBe('Object {}');\n  });\n\n  it('prints an object with properties', () => {\n    const val = {prop1: 'value1', prop2: 'value2'};\n    expect(prettyFormat(val)).toBe(\n      'Object {\\n  \"prop1\": \"value1\",\\n  \"prop2\": \"value2\",\\n}',\n    );\n  });\n\n  it('prints an object with properties and symbols', () => {\n    const val: any = {};\n    val[Symbol('symbol1')] = 'value2';\n    val[Symbol('symbol2')] = 'value3';\n    val.prop = 'value1';\n    expect(prettyFormat(val)).toBe(\n      'Object {\\n  \"prop\": \"value1\",\\n  Symbol(symbol1): \"value2\",\\n  Symbol(symbol2): \"value3\",\\n}',\n    );\n  });\n\n  it('prints an object without non-enumerable properties which have string key', () => {\n    const val: unknown = {\n      enumerable: true,\n    };\n    const key = 'non-enumerable';\n    Object.defineProperty(val, key, {\n      enumerable: false,\n      value: false,\n    });\n    expect(prettyFormat(val)).toBe('Object {\\n  \"enumerable\": true,\\n}');\n  });\n\n  it('prints an object without non-enumerable properties which have symbol key', () => {\n    const val: unknown = {\n      enumerable: true,\n    };\n    const key = Symbol('non-enumerable');\n    Object.defineProperty(val, key, {\n      enumerable: false,\n      value: false,\n    });\n    expect(prettyFormat(val)).toBe('Object {\\n  \"enumerable\": true,\\n}');\n  });\n\n  it('prints an object with sorted properties', () => {\n    // eslint-disable-next-line sort-keys\n    const val = {b: 1, a: 2};\n    expect(prettyFormat(val)).toBe('Object {\\n  \"a\": 2,\\n  \"b\": 1,\\n}');\n  });\n\n  it('prints an object with keys in their original order with the appropriate comparing function', () => {\n    // eslint-disable-next-line sort-keys\n    const val = {b: 1, a: 2};\n    const compareKeys = () => 0;\n    expect(prettyFormat(val, {compareKeys})).toBe(\n      'Object {\\n  \"b\": 1,\\n  \"a\": 2,\\n}',\n    );\n  });\n\n  it('prints an object with keys in their original order with compareKeys set to null', () => {\n    // eslint-disable-next-line sort-keys\n    const val = {b: 1, a: 2};\n    expect(prettyFormat(val, {compareKeys: null})).toBe(\n      'Object {\\n  \"b\": 1,\\n  \"a\": 2,\\n}',\n    );\n  });\n\n  it('prints an object with keys sorted in reverse order', () => {\n    const val = {a: 1, b: 2};\n    const compareKeys = (a: string, b: string) => (a > b ? -1 : 1);\n    expect(prettyFormat(val, {compareKeys})).toBe(\n      'Object {\\n  \"b\": 2,\\n  \"a\": 1,\\n}',\n    );\n  });\n\n  it('prints regular expressions from constructors', () => {\n    const val = new RegExp('regexp');\n    expect(prettyFormat(val)).toBe('/regexp/');\n  });\n\n  it('prints regular expressions from literals', () => {\n    const val = /regexp/gi;\n    expect(prettyFormat(val)).toBe('/regexp/gi');\n  });\n\n  it('prints regular expressions {escapeRegex: false}', () => {\n    const val = /regexp\\d/gi;\n    expect(prettyFormat(val)).toBe('/regexp\\\\d/gi');\n  });\n\n  it('prints regular expressions {escapeRegex: true}', () => {\n    const val = /regexp\\d/gi;\n    expect(prettyFormat(val, {escapeRegex: true})).toBe('/regexp\\\\\\\\d/gi');\n  });\n\n  it('escapes regular expressions nested inside object', () => {\n    const obj = {test: /regexp\\d/gi};\n    expect(prettyFormat(obj, {escapeRegex: true})).toBe(\n      'Object {\\n  \"test\": /regexp\\\\\\\\d/gi,\\n}',\n    );\n  });\n\n  it('prints an empty set', () => {\n    const val = new Set();\n    expect(prettyFormat(val)).toBe('Set {}');\n  });\n\n  it('prints a set with values', () => {\n    const val = new Set();\n    val.add('value1');\n    val.add('value2');\n    expect(prettyFormat(val)).toBe('Set {\\n  \"value1\",\\n  \"value2\",\\n}');\n  });\n\n  it('prints a string', () => {\n    const val = 'string';\n    expect(prettyFormat(val)).toBe('\"string\"');\n  });\n\n  it('prints and escape a string', () => {\n    const val = '\"\\'\\\\';\n    expect(prettyFormat(val)).toBe('\"\\\\\"\\'\\\\\\\\\"');\n  });\n\n  it(\"doesn't escape string with {escapeString: false}\", () => {\n    const val = '\"\\'\\\\n';\n    expect(prettyFormat(val, {escapeString: false})).toBe('\"\"\\'\\\\n\"');\n  });\n\n  it('prints a string with escapes', () => {\n    expect(prettyFormat('\"-\"')).toBe('\"\\\\\"-\\\\\"\"');\n    expect(prettyFormat('\\\\ \\\\\\\\')).toBe('\"\\\\\\\\ \\\\\\\\\\\\\\\\\"');\n  });\n\n  it('prints a multiline string', () => {\n    const val = ['line 1', 'line 2', 'line 3'].join('\\n');\n    expect(prettyFormat(val)).toBe(`\"${val}\"`);\n  });\n\n  it('prints a multiline string as value of object property', () => {\n    const polyline = {\n      props: {\n        id: 'J',\n        points: ['0.5,0.460', '0.5,0.875', '0.25,0.875'].join('\\n'),\n      },\n      type: 'polyline',\n    };\n    const val = {\n      props: {\n        children: polyline,\n      },\n      type: 'svg',\n    };\n    expect(prettyFormat(val)).toEqual(\n      [\n        'Object {',\n        '  \"props\": Object {',\n        '    \"children\": Object {',\n        '      \"props\": Object {',\n        '        \"id\": \"J\",',\n        '        \"points\": \"0.5,0.460',\n        '0.5,0.875',\n        '0.25,0.875\",',\n        '      },',\n        '      \"type\": \"polyline\",',\n        '    },',\n        '  },',\n        '  \"type\": \"svg\",',\n        '}',\n      ].join('\\n'),\n    );\n  });\n\n  it('prints a symbol', () => {\n    const val = Symbol('symbol');\n    expect(prettyFormat(val)).toBe('Symbol(symbol)');\n  });\n\n  it('prints undefined', () => {\n    const val = undefined;\n    expect(prettyFormat(val)).toBe('undefined');\n  });\n\n  it('prints a WeakMap', () => {\n    const val = new WeakMap();\n    expect(prettyFormat(val)).toBe('WeakMap {}');\n  });\n\n  it('prints a WeakSet', () => {\n    const val = new WeakSet();\n    expect(prettyFormat(val)).toBe('WeakSet {}');\n  });\n\n  it('prints deeply nested objects', () => {\n    const val = {prop: {prop: {prop: 'value'}}};\n    expect(prettyFormat(val)).toBe(\n      'Object {\\n  \"prop\": Object {\\n    \"prop\": Object {\\n      \"prop\": \"value\",\\n    },\\n  },\\n}',\n    );\n  });\n\n  it('prints circular references', () => {\n    const val: any = {};\n    val.prop = val;\n    expect(prettyFormat(val)).toBe('Object {\\n  \"prop\": [Circular],\\n}');\n  });\n\n  it('prints parallel references', () => {\n    const inner = {};\n    const val = {prop1: inner, prop2: inner};\n    expect(prettyFormat(val)).toBe(\n      'Object {\\n  \"prop1\": Object {},\\n  \"prop2\": Object {},\\n}',\n    );\n  });\n\n  describe('indent option', () => {\n    const val = [\n      {\n        id: '8658c1d0-9eda-4a90-95e1-8001e8eb6036',\n        text: 'Add alternative serialize API for pretty-format plugins',\n        type: 'ADD_TODO',\n      },\n      {\n        id: '8658c1d0-9eda-4a90-95e1-8001e8eb6036',\n        type: 'TOGGLE_TODO',\n      },\n    ];\n    const expected = [\n      'Array [',\n      '  Object {',\n      '    \"id\": \"8658c1d0-9eda-4a90-95e1-8001e8eb6036\",',\n      '    \"text\": \"Add alternative serialize API for pretty-format plugins\",',\n      '    \"type\": \"ADD_TODO\",',\n      '  },',\n      '  Object {',\n      '    \"id\": \"8658c1d0-9eda-4a90-95e1-8001e8eb6036\",',\n      '    \"type\": \"TOGGLE_TODO\",',\n      '  },',\n      ']',\n    ].join('\\n');\n    test('default implicit: 2 spaces', () => {\n      expect(prettyFormat(val)).toEqual(expected);\n    });\n    test('default explicit: 2 spaces', () => {\n      expect(prettyFormat(val, {indent: 2})).toEqual(expected);\n    });\n\n    // Tests assume that no strings in val contain multiple adjacent spaces!\n    test('non-default: 0 spaces', () => {\n      const indent = 0;\n      expect(prettyFormat(val, {indent})).toEqual(\n        expected.replaceAll(/ {2}/g, ' '.repeat(indent)),\n      );\n    });\n    test('non-default: 4 spaces', () => {\n      const indent = 4;\n      expect(prettyFormat(val, {indent})).toEqual(\n        expected.replaceAll(/ {2}/g, ' '.repeat(indent)),\n      );\n    });\n  });\n\n  it('can omit basic prototypes', () => {\n    const val = {\n      deeply: {nested: {object: {}}},\n      'empty array': {},\n      'empty object': {},\n      'nested array': [[[]]],\n      'typed array': new Uint8Array(),\n    };\n    expect(prettyFormat(val, {maxDepth: 2, printBasicPrototype: false})).toBe(\n      [\n        '{',\n        '  \"deeply\": {',\n        '    \"nested\": [Object],',\n        '  },',\n        '  \"empty array\": {},',\n        '  \"empty object\": {},',\n        '  \"nested array\": [',\n        '    [Array],',\n        '  ],',\n        '  \"typed array\": Uint8Array [],',\n        '}',\n      ].join('\\n'),\n    );\n  });\n\n  describe('maxWidth option', () => {\n    it('applies to arrays', () => {\n      const val = Array.from({length: 1_000_000}).fill('x');\n      expect(prettyFormat(val, {maxWidth: 5})).toEqual(\n        [\n          'Array [',\n          '  \"x\",',\n          '  \"x\",',\n          '  \"x\",',\n          '  \"x\",',\n          '  \"x\",',\n          '  …',\n          ']',\n        ].join('\\n'),\n      );\n    });\n\n    it('applies to sets', () => {\n      const val = new Set([1, 2, 3, 4, 5, 6, 7, 8, 9, 0]);\n      expect(prettyFormat(val, {maxWidth: 5})).toEqual(\n        ['Set {', '  1,', '  2,', '  3,', '  4,', '  5,', '  …', '}'].join(\n          '\\n',\n        ),\n      );\n    });\n\n    it('applies to maps', () => {\n      const val = new Map();\n      val.set('a', 1);\n      val.set('b', 2);\n      val.set('c', 3);\n      val.set('d', 4);\n      val.set('e', 5);\n      val.set('f', 6);\n      val.set('g', 7);\n      val.set('h', 8);\n      val.set('i', 9);\n      val.set('j', 10);\n      expect(prettyFormat(val, {maxWidth: 5})).toEqual(\n        [\n          'Map {',\n          '  \"a\" => 1,',\n          '  \"b\" => 2,',\n          '  \"c\" => 3,',\n          '  \"d\" => 4,',\n          '  \"e\" => 5,',\n          '  …',\n          '}',\n        ].join('\\n'),\n      );\n    });\n  });\n\n  it('can customize the max depth', () => {\n    const val = [\n      {\n        'arguments empty': returnArguments(),\n        'arguments non-empty': returnArguments('arg'),\n        'array literal empty': [],\n        'array literal non-empty': ['item'],\n        'extended array empty': new MyArray(),\n        'map empty': new Map(),\n        'map non-empty': new Map([['name', 'value']]),\n        'object literal empty': {},\n        'object literal non-empty': {name: 'value'},\n        // @ts-expect-error\n        'object with constructor': new MyObject('value'),\n        'object without constructor': Object.create(null),\n        'set empty': new Set(),\n        'set non-empty': new Set(['value']),\n      },\n    ];\n    expect(prettyFormat(val, {maxDepth: 2})).toEqual(\n      [\n        'Array [',\n        '  Object {',\n        '    \"arguments empty\": [Arguments],',\n        '    \"arguments non-empty\": [Arguments],',\n        '    \"array literal empty\": [Array],',\n        '    \"array literal non-empty\": [Array],',\n        '    \"extended array empty\": [MyArray],',\n        '    \"map empty\": [Map],',\n        '    \"map non-empty\": [Map],',\n        '    \"object literal empty\": [Object],',\n        '    \"object literal non-empty\": [Object],',\n        '    \"object with constructor\": [MyObject],',\n        '    \"object without constructor\": [Object],',\n        '    \"set empty\": [Set],',\n        '    \"set non-empty\": [Set],',\n        '  },',\n        ']',\n      ].join('\\n'),\n    );\n  });\n\n  it('throws on invalid options', () => {\n    expect(() => {\n      // @ts-expect-error: Testing runtime error\n      prettyFormat({}, {invalidOption: true});\n    }).toThrow('Unknown option \"invalidOption\".');\n  });\n\n  it('supports plugins', () => {\n    class Foo {}\n\n    expect(\n      prettyFormat(new Foo(), {\n        plugins: [\n          {\n            print: () => 'class Foo',\n            test(object) {\n              return object.constructor.name === 'Foo';\n            },\n          },\n        ],\n      }),\n    ).toBe('class Foo');\n  });\n\n  it('supports plugins that return empty string', () => {\n    const val = {\n      payload: '',\n    };\n    const options = {\n      plugins: [\n        {\n          print(val: any) {\n            return val.payload;\n          },\n          test(val: any) {\n            return val && typeof val.payload === 'string';\n          },\n        },\n      ],\n    };\n    expect(prettyFormat(val, options)).toBe('');\n  });\n\n  it('throws if plugin does not return a string', () => {\n    const val = 123;\n    const options: PrettyFormatOptions = {\n      plugins: [\n        {\n          // @ts-expect-error: Testing runtime error\n          print(val: unknown) {\n            return val;\n          },\n          test() {\n            return true;\n          },\n        },\n      ],\n    };\n    expect(() => {\n      prettyFormat(val, options);\n    }).toThrow(\n      'Plugin must return type \"string\" but instead returned \"number\".',\n    );\n  });\n\n  it('throws PrettyFormatPluginError if test throws an error', () => {\n    expect.hasAssertions();\n    const options = {\n      plugins: [\n        {\n          print: () => '',\n          test() {\n            throw new Error('Where is the error?');\n          },\n        },\n      ],\n    };\n\n    try {\n      prettyFormat('', options);\n    } catch (error: any) {\n      expect(error.name).toBe('PrettyFormatPluginError');\n    }\n  });\n\n  it('throws PrettyFormatPluginError if print throws an error', () => {\n    expect.hasAssertions();\n    const options = {\n      plugins: [\n        {\n          print: () => {\n            throw new Error('Where is the error?');\n          },\n          test: () => true,\n        },\n      ],\n    };\n\n    try {\n      prettyFormat('', options);\n    } catch (error: any) {\n      expect(error.name).toBe('PrettyFormatPluginError');\n    }\n  });\n\n  it('throws PrettyFormatPluginError if serialize throws an error', () => {\n    expect.hasAssertions();\n    const options = {\n      plugins: [\n        {\n          serialize: () => {\n            throw new Error('Where is the error?');\n          },\n          test: () => true,\n        },\n      ],\n    };\n\n    try {\n      prettyFormat('', options);\n    } catch (error: any) {\n      expect(error.name).toBe('PrettyFormatPluginError');\n    }\n  });\n\n  it('supports plugins with deeply nested arrays (#24)', () => {\n    const val = [\n      [1, 2],\n      [3, 4],\n    ];\n    expect(\n      prettyFormat(val, {\n        plugins: [\n          {\n            print(val: unknown, print: any) {\n              return (val as Array<unknown>)\n                .map(item => print(item))\n                .join(' - ');\n            },\n            test(val: unknown) {\n              return Array.isArray(val);\n            },\n          },\n        ],\n      }),\n    ).toBe('1 - 2 - 3 - 4');\n  });\n\n  it('should call plugins on nested basic values', () => {\n    const val = {prop: 42};\n    expect(\n      prettyFormat(val, {\n        plugins: [\n          {\n            print(_val, _print) {\n              return '[called]';\n            },\n            test(val) {\n              return typeof val === 'string' || typeof val === 'number';\n            },\n          },\n        ],\n      }),\n    ).toBe('Object {\\n  [called]: [called],\\n}');\n  });\n\n  it('prints objects with no constructor', () => {\n    expect(prettyFormat(Object.create(null))).toBe('Object {}');\n  });\n\n  it('prints identity-obj-proxy with string constructor', () => {\n    const val = Object.create(null);\n    val.constructor = 'constructor'; // mock the mock object :)\n    const expected = [\n      'Object {', // Object instead of undefined\n      '  \"constructor\": \"constructor\",',\n      '}',\n    ].join('\\n');\n    expect(prettyFormat(val)).toEqual(expected);\n  });\n\n  it('calls toJSON and prints its return value', () => {\n    expect(\n      prettyFormat({\n        toJSON: () => ({value: false}),\n        value: true,\n      }),\n    ).toBe('Object {\\n  \"value\": false,\\n}');\n  });\n\n  it('calls toJSON and prints an internal representation.', () => {\n    expect(\n      prettyFormat({\n        toJSON: () => '[Internal Object]',\n        value: true,\n      }),\n    ).toBe('\"[Internal Object]\"');\n  });\n\n  it('calls toJSON only on functions', () => {\n    expect(\n      prettyFormat({\n        toJSON: false,\n        value: true,\n      }),\n    ).toBe('Object {\\n  \"toJSON\": false,\\n  \"value\": true,\\n}');\n  });\n\n  it('does not call toJSON recursively', () => {\n    expect(\n      prettyFormat({\n        toJSON: () => ({toJSON: () => ({value: true})}),\n        value: false,\n      }),\n    ).toBe('Object {\\n  \"toJSON\": [Function toJSON],\\n}');\n  });\n\n  it('calls toJSON on Sets', () => {\n    const set = new Set([1]);\n    (set as any).toJSON = () => 'map';\n    expect(prettyFormat(set)).toBe('\"map\"');\n  });\n\n  it('disables toJSON calls through options', () => {\n    const value = {apple: 'banana', toJSON: jest.fn(() => '1')};\n    const name = value.toJSON.name || 'anonymous';\n    const set = new Set([value]);\n    (set as any).toJSON = jest.fn(() => 'map');\n    expect(\n      prettyFormat(set, {\n        callToJSON: false,\n      }),\n    ).toBe(\n      `Set {\\n  Object {\\n    \"apple\": \"banana\",\\n    \"toJSON\": [Function ${name}],\\n  },\\n}`,\n    );\n    expect((set as any).toJSON).not.toHaveBeenCalled();\n    expect(value.toJSON).not.toHaveBeenCalled();\n  });\n\n  describe('min', () => {\n    it('prints some basic values in min mode', () => {\n      const val = {\n        boolean: [false, true],\n        null: null,\n        number: [\n          0,\n          -0,\n          123,\n          -123,\n          Number.POSITIVE_INFINITY,\n          Number.NEGATIVE_INFINITY,\n          Number.NaN,\n        ],\n        string: ['', 'non-empty'],\n        undefined,\n      };\n      expect(\n        prettyFormat(val, {\n          min: true,\n        }),\n      ).toBe(\n        `{${[\n          '\"boolean\": [false, true]',\n          '\"null\": null',\n          '\"number\": [0, -0, 123, -123, Infinity, -Infinity, NaN]',\n          '\"string\": [\"\", \"non-empty\"]',\n          '\"undefined\": undefined',\n        ].join(', ')}}`,\n      );\n    });\n\n    it('prints some complex values in min mode', () => {\n      const val = {\n        'arguments empty': returnArguments(),\n        'arguments non-empty': returnArguments('arg'),\n        'array literal empty': [],\n        'array literal non-empty': ['item'],\n        'extended array empty': new MyArray(),\n        'map empty': new Map(),\n        'map non-empty': new Map([['name', 'value']]),\n        'object literal empty': {},\n        'object literal non-empty': {name: 'value'},\n        // @ts-expect-error\n        'object with constructor': new MyObject('value'),\n        'object without constructor': Object.create(null),\n        'set empty': new Set(),\n        'set non-empty': new Set(['value']),\n      };\n      expect(\n        prettyFormat(val, {\n          min: true,\n        }),\n      ).toBe(\n        `{${[\n          '\"arguments empty\": []',\n          '\"arguments non-empty\": [\"arg\"]',\n          '\"array literal empty\": []',\n          '\"array literal non-empty\": [\"item\"]',\n          '\"extended array empty\": []',\n          '\"map empty\": Map {}',\n          '\"map non-empty\": Map {\"name\" => \"value\"}',\n          '\"object literal empty\": {}',\n          '\"object literal non-empty\": {\"name\": \"value\"}',\n          '\"object with constructor\": {\"name\": \"value\"}',\n          '\"object without constructor\": {}',\n          '\"set empty\": Set {}',\n          '\"set non-empty\": Set {\"value\"}',\n        ].join(', ')}}`,\n      );\n    });\n\n    it('does not allow indent !== 0 in min mode', () => {\n      expect(() => {\n        prettyFormat(1, {indent: 1, min: true});\n      }).toThrow('Options \"min\" and \"indent\" cannot be used together.');\n    });\n  });\n});\n",
  "packages/pretty-format/src/__tests__/prettyFormat.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/pretty-format/src/__tests__/ReactElement.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as React from 'react';\nimport {plugins} from '../';\nimport setPrettyPrint from './setPrettyPrint';\n\nconst {ReactElement} = plugins;\n\nsetPrettyPrint([ReactElement]);\n\ndescribe('ReactElement Plugin', () => {\n  let forwardRefComponent: {\n    (_props: unknown, _ref: unknown): React.ReactElement | null;\n    displayName?: string;\n  };\n\n  let forwardRefExample: ReturnType<typeof React.forwardRef>;\n\n  beforeEach(() => {\n    forwardRefComponent = (_props, _ref) => null;\n\n    forwardRefExample = React.forwardRef(forwardRefComponent);\n\n    forwardRefExample.displayName = undefined;\n  });\n\n  test('serializes forwardRef without displayName', () => {\n    forwardRefExample = React.forwardRef((_props, _ref) => null);\n    expect(React.createElement(forwardRefExample)).toPrettyPrintTo(\n      '<ForwardRef />',\n    );\n  });\n\n  test('serializes forwardRef with displayName', () => {\n    forwardRefExample.displayName = 'Display';\n    expect(React.createElement(forwardRefExample)).toPrettyPrintTo(\n      '<Display />',\n    );\n  });\n\n  test('serializes forwardRef component with displayName', () => {\n    forwardRefComponent.displayName = 'Display';\n    expect(React.createElement(forwardRefExample)).toPrettyPrintTo(\n      '<ForwardRef(Display) />',\n    );\n  });\n});\n",
  "packages/pretty-format/src/__tests__/ReactElement.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/pretty-format/src/__tests__/Immutable.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/* eslint-disable local/prefer-rest-params-eventually */\n\nimport * as Immutable from 'immutable';\nimport * as React from 'react';\nimport {plugins} from '../';\nimport setPrettyPrint from './setPrettyPrint';\n\nconst {Immutable: ImmutablePlugin, ReactElement} = plugins;\n\nsetPrettyPrint([ReactElement, ImmutablePlugin]);\n\nit('does not incorrectly match identity-obj-proxy as Immutable object', () => {\n  // SENTINEL constant is from https://github.com/immutable-js/immutable-js\n  const IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\n  const val: any = {};\n  val[IS_ITERABLE_SENTINEL] = IS_ITERABLE_SENTINEL; // mock the mock object :)\n  const expected = `{\"${IS_ITERABLE_SENTINEL}\": \"${IS_ITERABLE_SENTINEL}\"}`;\n  expect(val).toPrettyPrintTo(expected, {min: true});\n});\n\ndescribe('Immutable.OrderedSet', () => {\n  it('supports an empty collection {min: true}', () => {\n    expect(Immutable.OrderedSet([])).toPrettyPrintTo(\n      'Immutable.OrderedSet []',\n      {min: true},\n    );\n  });\n\n  it('supports an empty collection {min: false}', () => {\n    expect(Immutable.OrderedSet([])).toPrettyPrintTo(\n      'Immutable.OrderedSet []',\n      {min: false},\n    );\n  });\n\n  it('supports a single string element', () => {\n    expect(Immutable.OrderedSet(['foo'])).toPrettyPrintTo(\n      'Immutable.OrderedSet [\"foo\"]',\n      {min: true},\n    );\n  });\n\n  it('supports a single integer element', () => {\n    expect(Immutable.OrderedSet([1])).toPrettyPrintTo(\n      'Immutable.OrderedSet [1]',\n      {min: true},\n    );\n  });\n\n  it('supports multiple string elements {min: true}', () => {\n    expect(Immutable.OrderedSet(['jhon', 'mike', 'cristian'])).toPrettyPrintTo(\n      'Immutable.OrderedSet [\"jhon\", \"mike\", \"cristian\"]',\n      {\n        min: true,\n      },\n    );\n  });\n\n  it('supports multiple string elements {min: false}', () => {\n    expect(Immutable.OrderedSet(['jhon', 'mike', 'cristian'])).toPrettyPrintTo(\n      'Immutable.OrderedSet [\\n  \"jhon\",\\n  \"mike\",\\n  \"cristian\",\\n]',\n      {min: false},\n    );\n  });\n\n  it('supports multiple integer elements {min: true}', () => {\n    expect(Immutable.OrderedSet([1, 2, 3])).toPrettyPrintTo(\n      'Immutable.OrderedSet [1, 2, 3]',\n      {min: true},\n    );\n  });\n\n  it('supports multiple integer elements {min: false}', () => {\n    expect(Immutable.OrderedSet([1, 2, 3])).toPrettyPrintTo(\n      'Immutable.OrderedSet [\\n  1,\\n  2,\\n  3,\\n]',\n      {\n        min: false,\n      },\n    );\n  });\n\n  it('supports object elements {min: true}', () => {\n    expect(Immutable.OrderedSet([{a: 1, b: 2, c: 3}])).toPrettyPrintTo(\n      'Immutable.OrderedSet [{\"a\": 1, \"b\": 2, \"c\": 3}]',\n      {\n        min: true,\n      },\n    );\n  });\n\n  it('supports object elements {min: false}', () => {\n    expect(Immutable.OrderedSet([{a: 1, b: 2, c: 3}])).toPrettyPrintTo(\n      'Immutable.OrderedSet [\\n  Object {\\n    \"a\": 1,\\n    \"b\": 2,\\n    \"c\": 3,\\n  },\\n]',\n      {min: false},\n    );\n  });\n\n  it('supports React elements {min: true}', () => {\n    const reactElement = React.createElement('Mouse', null, 'Hello World');\n    expect(Immutable.OrderedSet([reactElement, reactElement])).toPrettyPrintTo(\n      'Immutable.OrderedSet [<Mouse>Hello World</Mouse>]',\n      {\n        min: true,\n      },\n    );\n  });\n\n  it('supports React elements {min: false}', () => {\n    const reactElement = React.createElement('Mouse', null, 'Hello World');\n    expect(Immutable.OrderedSet([reactElement, reactElement])).toPrettyPrintTo(\n      'Immutable.OrderedSet [\\n  <Mouse>\\n    Hello World\\n  </Mouse>,\\n]',\n      {min: false},\n    );\n  });\n});\n\ndescribe('Immutable.List', () => {\n  it('supports an empty collection {min: true}', () => {\n    expect(Immutable.List([])).toPrettyPrintTo('Immutable.List []', {\n      min: true,\n    });\n  });\n\n  it('supports an empty collection {min: false}', () => {\n    expect(Immutable.List([])).toPrettyPrintTo('Immutable.List []', {\n      min: false,\n    });\n  });\n\n  it('supports a single string element', () => {\n    expect(Immutable.List(['foo'])).toPrettyPrintTo('Immutable.List [\"foo\"]', {\n      min: true,\n    });\n  });\n\n  it('supports a single integer element', () => {\n    expect(Immutable.List([1])).toPrettyPrintTo('Immutable.List [1]', {\n      min: true,\n    });\n  });\n\n  it('supports multiple string elements {min: true}', () => {\n    expect(Immutable.List(['jhon', 'mike', 'cristian'])).toPrettyPrintTo(\n      'Immutable.List [\"jhon\", \"mike\", \"cristian\"]',\n      {\n        min: true,\n      },\n    );\n  });\n\n  it('supports multiple string elements {min: false}', () => {\n    expect(Immutable.List(['jhon', 'mike', 'cristian'])).toPrettyPrintTo(\n      'Immutable.List [\\n  \"jhon\",\\n  \"mike\",\\n  \"cristian\",\\n]',\n    );\n  });\n\n  it('supports multiple integer elements {min: true}', () => {\n    expect(Immutable.List([1, 2, 3])).toPrettyPrintTo(\n      'Immutable.List [1, 2, 3]',\n      {min: true},\n    );\n  });\n\n  it('supports multiple integer elements {min: false}', () => {\n    expect(Immutable.List([1, 2, 3])).toPrettyPrintTo(\n      'Immutable.List [\\n  1,\\n  2,\\n  3,\\n]',\n    );\n  });\n\n  it('supports object elements {min: true}', () => {\n    expect(Immutable.List([{a: 1, b: 2, c: 3}])).toPrettyPrintTo(\n      'Immutable.List [{\"a\": 1, \"b\": 2, \"c\": 3}]',\n      {min: true},\n    );\n  });\n\n  it('supports object elements {min: false}', () => {\n    expect(Immutable.List([{a: 1, b: 2, c: 3}])).toPrettyPrintTo(\n      'Immutable.List [\\n  Object {\\n    \"a\": 1,\\n    \"b\": 2,\\n    \"c\": 3,\\n  },\\n]',\n    );\n  });\n\n  it('supports React elements {min: true}', () => {\n    const reactElement = React.createElement('Mouse', null, 'Hello World');\n    expect(Immutable.List([reactElement, reactElement])).toPrettyPrintTo(\n      'Immutable.List [<Mouse>Hello World</Mouse>, <Mouse>Hello World</Mouse>]',\n      {min: true},\n    );\n  });\n\n  it('supports React elements {min: false}', () => {\n    const reactElement = React.createElement('Mouse', null, 'Hello World');\n    expect(Immutable.List([reactElement, reactElement])).toPrettyPrintTo(\n      'Immutable.List [\\n  <Mouse>\\n    Hello World\\n  </Mouse>,\\n  <Mouse>\\n    Hello World\\n  </Mouse>,\\n]',\n    );\n  });\n});\n\ndescribe('Immutable.Stack', () => {\n  it('supports an empty collection {min: true}', () => {\n    expect(Immutable.Stack([])).toPrettyPrintTo('Immutable.Stack []', {\n      min: true,\n    });\n  });\n\n  it('supports an empty collection {min: false}', () => {\n    expect(Immutable.Stack([])).toPrettyPrintTo('Immutable.Stack []', {\n      min: false,\n    });\n  });\n\n  it('supports a single string element', () => {\n    expect(Immutable.Stack(['foo'])).toPrettyPrintTo(\n      'Immutable.Stack [\"foo\"]',\n      {min: true},\n    );\n  });\n\n  it('supports a single integer element', () => {\n    expect(Immutable.Stack([1])).toPrettyPrintTo('Immutable.Stack [1]', {\n      min: true,\n    });\n  });\n\n  it('supports multiple string elements {min: true}', () => {\n    expect(Immutable.Stack(['jhon', 'mike', 'cristian'])).toPrettyPrintTo(\n      'Immutable.Stack [\"jhon\", \"mike\", \"cristian\"]',\n      {\n        min: true,\n      },\n    );\n  });\n\n  it('supports multiple string elements {min: false}', () => {\n    expect(Immutable.Stack(['jhon', 'mike', 'cristian'])).toPrettyPrintTo(\n      'Immutable.Stack [\\n  \"jhon\",\\n  \"mike\",\\n  \"cristian\",\\n]',\n    );\n  });\n\n  it('supports multiple integer elements {min: true}', () => {\n    expect(Immutable.Stack([1, 2, 3])).toPrettyPrintTo(\n      'Immutable.Stack [1, 2, 3]',\n      {min: true},\n    );\n  });\n\n  it('supports multiple integer elements {min: false}', () => {\n    expect(Immutable.Stack([1, 2, 3])).toPrettyPrintTo(\n      'Immutable.Stack [\\n  1,\\n  2,\\n  3,\\n]',\n    );\n  });\n\n  it('supports object elements {min: true}', () => {\n    expect(Immutable.Stack([{a: 1, b: 2, c: 3}])).toPrettyPrintTo(\n      'Immutable.Stack [{\"a\": 1, \"b\": 2, \"c\": 3}]',\n      {\n        min: true,\n      },\n    );\n  });\n\n  it('supports object elements {min: false}', () => {\n    expect(Immutable.Stack([{a: 1, b: 2, c: 3}])).toPrettyPrintTo(\n      'Immutable.Stack [\\n  Object {\\n    \"a\": 1,\\n    \"b\": 2,\\n    \"c\": 3,\\n  },\\n]',\n    );\n  });\n\n  it('supports React elements {min: true}', () => {\n    const reactElement = React.createElement('Mouse', null, 'Hello World');\n    expect(Immutable.Stack([reactElement, reactElement])).toPrettyPrintTo(\n      'Immutable.Stack [<Mouse>Hello World</Mouse>, <Mouse>Hello World</Mouse>]',\n      {min: true},\n    );\n  });\n\n  it('supports React elements {min: false}', () => {\n    const reactElement = React.createElement('Mouse', null, 'Hello World');\n    expect(Immutable.Stack([reactElement, reactElement])).toPrettyPrintTo(\n      'Immutable.Stack [\\n  <Mouse>\\n    Hello World\\n  </Mouse>,\\n  <Mouse>\\n    Hello World\\n  </Mouse>,\\n]',\n    );\n  });\n});\n\ndescribe('Immutable.Set', () => {\n  it('supports an empty collection {min: true}', () => {\n    expect(Immutable.Set([])).toPrettyPrintTo('Immutable.Set []', {min: true});\n  });\n\n  it('supports an empty collection {min: false}', () => {\n    expect(Immutable.Set([])).toPrettyPrintTo('Immutable.Set []', {\n      min: false,\n    });\n  });\n\n  it('supports a single string element', () => {\n    expect(Immutable.Set(['foo'])).toPrettyPrintTo('Immutable.Set [\"foo\"]', {\n      min: true,\n    });\n  });\n\n  it('supports a single integer element', () => {\n    expect(Immutable.Set([1])).toPrettyPrintTo('Immutable.Set [1]', {\n      min: true,\n    });\n  });\n\n  it('supports multiple string elements {min: true}', () => {\n    expect(Immutable.Set(['jhon', 'mike', 'cristian'])).toPrettyPrintTo(\n      'Immutable.Set [\"jhon\", \"mike\", \"cristian\"]',\n      {\n        min: true,\n      },\n    );\n  });\n\n  it('supports multiple string elements {min: false}', () => {\n    expect(Immutable.Set(['jhon', 'mike', 'cristian'])).toPrettyPrintTo(\n      'Immutable.Set [\\n  \"jhon\",\\n  \"mike\",\\n  \"cristian\",\\n]',\n    );\n  });\n\n  it('supports multiple integer elements {min: true}', () => {\n    expect(Immutable.Set([1, 2, 3])).toPrettyPrintTo(\n      'Immutable.Set [1, 2, 3]',\n      {min: true},\n    );\n  });\n\n  it('supports multiple integer elements {min: false}', () => {\n    expect(Immutable.Set([1, 2, 3])).toPrettyPrintTo(\n      'Immutable.Set [\\n  1,\\n  2,\\n  3,\\n]',\n    );\n  });\n\n  it('supports object elements {min: true}', () => {\n    expect(Immutable.Set([{a: 1, b: 2, c: 3}])).toPrettyPrintTo(\n      'Immutable.Set [{\"a\": 1, \"b\": 2, \"c\": 3}]',\n      {min: true},\n    );\n  });\n\n  it('supports object elements {min: false}', () => {\n    expect(Immutable.Set([{a: 1, b: 2, c: 3}])).toPrettyPrintTo(\n      'Immutable.Set [\\n  Object {\\n    \"a\": 1,\\n    \"b\": 2,\\n    \"c\": 3,\\n  },\\n]',\n    );\n  });\n\n  it('supports React elements {min: true}', () => {\n    const reactElement = React.createElement('Mouse', null, 'Hello World');\n    expect(Immutable.Set([reactElement, reactElement])).toPrettyPrintTo(\n      'Immutable.Set [<Mouse>Hello World</Mouse>]',\n      {\n        min: true,\n      },\n    );\n  });\n\n  it('supports React elements {min: false}', () => {\n    const reactElement = React.createElement('Mouse', null, 'Hello World');\n    expect(Immutable.Set([reactElement, reactElement])).toPrettyPrintTo(\n      'Immutable.Set [\\n  <Mouse>\\n    Hello World\\n  </Mouse>,\\n]',\n    );\n  });\n});\n\ndescribe('Immutable.Map', () => {\n  it('supports an empty collection {min: true}', () => {\n    expect(Immutable.Map({})).toPrettyPrintTo('Immutable.Map {}', {min: true});\n  });\n\n  it('supports an empty collection {min: false}', () => {\n    expect(Immutable.Map({})).toPrettyPrintTo('Immutable.Map {}', {\n      min: false,\n    });\n  });\n\n  it('supports an object with single key', () => {\n    expect(Immutable.Map({a: 1})).toPrettyPrintTo('Immutable.Map {\"a\": 1}', {\n      min: true,\n    });\n  });\n\n  it('supports an object with multiple keys {min: true}', () => {\n    expect(Immutable.Map({a: 1, b: 2, c: 3})).toPrettyPrintTo(\n      'Immutable.Map {\"a\": 1, \"b\": 2, \"c\": 3}',\n      {min: true},\n    );\n  });\n\n  it('supports an object with multiple keys {min: false}', () => {\n    expect(Immutable.Map({a: 1, b: 2, c: 3})).toPrettyPrintTo(\n      'Immutable.Map {\\n  \"a\": 1,\\n  \"b\": 2,\\n  \"c\": 3,\\n}',\n    );\n  });\n\n  it('supports object elements {min: true}', () => {\n    expect(Immutable.Map({key: {a: 1, b: 2, c: 3}})).toPrettyPrintTo(\n      'Immutable.Map {\"key\": {\"a\": 1, \"b\": 2, \"c\": 3}}',\n      {\n        min: true,\n      },\n    );\n  });\n\n  it('supports object elements {min: false}', () => {\n    expect(Immutable.Map({key: {a: 1, b: 2, c: 3}})).toPrettyPrintTo(\n      'Immutable.Map {\\n  \"key\": Object {\\n    \"a\": 1,\\n    \"b\": 2,\\n    \"c\": 3,\\n  },\\n}',\n    );\n  });\n\n  it('supports React elements {min: true}', () => {\n    const reactElement = React.createElement('Mouse', null, 'Hello World');\n    expect(Immutable.Map({a: reactElement, b: reactElement})).toPrettyPrintTo(\n      'Immutable.Map {\"a\": <Mouse>Hello World</Mouse>, \"b\": <Mouse>Hello World</Mouse>}',\n      {min: true},\n    );\n  });\n\n  it('supports React elements {min: false}', () => {\n    const reactElement = React.createElement('Mouse', null, 'Hello World');\n    expect(Immutable.Map({a: reactElement, b: reactElement})).toPrettyPrintTo(\n      'Immutable.Map {\\n  \"a\": <Mouse>\\n    Hello World\\n  </Mouse>,\\n  \"b\": <Mouse>\\n    Hello World\\n  </Mouse>,\\n}',\n    );\n  });\n});\n\ndescribe('Immutable.OrderedMap', () => {\n  it('supports an empty collection {min: true}', () => {\n    expect(Immutable.OrderedMap({})).toPrettyPrintTo(\n      'Immutable.OrderedMap {}',\n      {min: true},\n    );\n  });\n\n  it('supports an empty collection {min: false}', () => {\n    expect(Immutable.OrderedMap({})).toPrettyPrintTo(\n      'Immutable.OrderedMap {}',\n      {min: false},\n    );\n  });\n\n  it('supports an object with single key', () => {\n    expect(Immutable.OrderedMap({a: 1})).toPrettyPrintTo(\n      'Immutable.OrderedMap {\"a\": 1}',\n      {min: true},\n    );\n  });\n\n  it('supports an object with multiple keys {min: true}', () => {\n    expect(Immutable.OrderedMap({a: 1, b: 2, c: 3})).toPrettyPrintTo(\n      'Immutable.OrderedMap {\"a\": 1, \"b\": 2, \"c\": 3}',\n      {\n        min: true,\n      },\n    );\n  });\n\n  it('supports an object with multiple keys {min: false}', () => {\n    expect(Immutable.OrderedMap({a: 1, b: 2, c: 3})).toPrettyPrintTo(\n      'Immutable.OrderedMap {\\n  \"a\": 1,\\n  \"b\": 2,\\n  \"c\": 3,\\n}',\n    );\n  });\n\n  it('supports object elements {min: true}', () => {\n    expect(Immutable.OrderedMap({key: {a: 1, b: 2, c: 3}})).toPrettyPrintTo(\n      'Immutable.OrderedMap {\"key\": {\"a\": 1, \"b\": 2, \"c\": 3}}',\n      {\n        min: true,\n      },\n    );\n  });\n\n  it('supports object elements {min: false}', () => {\n    expect(Immutable.OrderedMap({key: {a: 1, b: 2, c: 3}})).toPrettyPrintTo(\n      'Immutable.OrderedMap {\\n  \"key\": Object {\\n    \"a\": 1,\\n    \"b\": 2,\\n    \"c\": 3,\\n  },\\n}',\n    );\n  });\n\n  it('supports React elements {min: true}', () => {\n    const reactElement = React.createElement('Mouse', null, 'Hello World');\n    expect(\n      Immutable.OrderedMap({a: reactElement, b: reactElement}),\n    ).toPrettyPrintTo(\n      'Immutable.OrderedMap {\"a\": <Mouse>Hello World</Mouse>, \"b\": <Mouse>Hello World</Mouse>}',\n      {min: true},\n    );\n  });\n\n  it('supports React elements {min: false}', () => {\n    const reactElement = React.createElement('Mouse', null, 'Hello World');\n    expect(\n      Immutable.OrderedMap({a: reactElement, b: reactElement}),\n    ).toPrettyPrintTo(\n      'Immutable.OrderedMap {\\n  \"a\": <Mouse>\\n    Hello World\\n  </Mouse>,\\n  \"b\": <Mouse>\\n    Hello World\\n  </Mouse>,\\n}',\n    );\n  });\n\n  it('supports non-string keys', () => {\n    const val = Immutable.OrderedMap<unknown, unknown>([\n      [false, 'boolean'],\n      ['false', 'string'],\n      [0, 'number'],\n      ['0', 'string'],\n      [null, 'null'],\n      ['null', 'string'],\n      [undefined, 'undefined'],\n      ['undefined', 'string'],\n      [Symbol('description'), 'symbol'],\n      ['Symbol(description)', 'string'],\n      [['array', 'key'], 'array'],\n      [{key: 'value'}, 'object'],\n      [Immutable.Map({key: 'value'}), 'immutable map'],\n    ]);\n    const expected = [\n      'Immutable.OrderedMap {',\n      '  false: \"boolean\",',\n      '  \"false\": \"string\",',\n      '  0: \"number\",',\n      '  \"0\": \"string\",',\n      '  null: \"null\",',\n      '  \"null\": \"string\",',\n      '  undefined: \"undefined\",',\n      '  \"undefined\": \"string\",',\n      '  Symbol(description): \"symbol\",',\n      '  \"Symbol(description)\": \"string\",',\n      '  Array [',\n      '    \"array\",',\n      '    \"key\",',\n      '  ]: \"array\",',\n      '  Object {',\n      '    \"key\": \"value\",',\n      '  }: \"object\",',\n      '  Immutable.Map {',\n      '    \"key\": \"value\",',\n      '  }: \"immutable map\",',\n      '}',\n    ].join('\\n');\n    expect(val).toPrettyPrintTo(expected);\n  });\n});\n\ndescribe('Immutable.Record', () => {\n  it('supports an empty record {min: true}', () => {\n    const ABRecord = Immutable.Record({}, 'ABRecord');\n\n    expect(ABRecord()).toPrettyPrintTo('Immutable.ABRecord {}', {\n      min: true,\n    });\n  });\n\n  it('supports an empty record {min: false}', () => {\n    const ABRecord = Immutable.Record({}, 'ABRecord');\n\n    expect(ABRecord()).toPrettyPrintTo('Immutable.ABRecord {}', {\n      min: false,\n    });\n  });\n\n  it('supports a record with descriptive name', () => {\n    const ABRecord = Immutable.Record({a: 1, b: 2}, 'ABRecord');\n\n    expect(ABRecord()).toPrettyPrintTo('Immutable.ABRecord {\"a\": 1, \"b\": 2}', {\n      min: true,\n    });\n  });\n\n  it('supports a record without descriptive name', () => {\n    const ABRecord = Immutable.Record({a: 1, b: 2});\n\n    expect(ABRecord()).toPrettyPrintTo('Immutable.Record {\"a\": 1, \"b\": 2}', {\n      min: true,\n    });\n  });\n\n  it('supports a record with values {min: true}', () => {\n    const ABRecord = Immutable.Record({a: 1, b: 2}, 'ABRecord');\n\n    expect(ABRecord({a: 3, b: 4})).toPrettyPrintTo(\n      'Immutable.ABRecord {\"a\": 3, \"b\": 4}',\n      {min: true},\n    );\n  });\n\n  it('supports a record with values {min: false}', () => {\n    const ABRecord = Immutable.Record({a: 1, b: 2}, 'ABRecord');\n\n    expect(ABRecord({a: 3, b: 4})).toPrettyPrintTo(\n      'Immutable.ABRecord {\\n  \"a\": 3,\\n  \"b\": 4,\\n}',\n    );\n  });\n\n  it('supports a record with Map value {min: true}', () => {\n    const ABRecord = Immutable.Record(\n      {a: Immutable.Map({c: 1}), b: 2},\n      'ABRecord',\n    );\n\n    expect(ABRecord()).toPrettyPrintTo(\n      'Immutable.ABRecord {\"a\": Immutable.Map {\"c\": 1}, \"b\": 2}',\n      {\n        min: true,\n      },\n    );\n  });\n\n  it('supports a record with Map value {min: false}', () => {\n    const ABRecord = Immutable.Record(\n      {a: Immutable.Map({c: 1}), b: 2},\n      'ABRecord',\n    );\n\n    expect(ABRecord()).toPrettyPrintTo(\n      'Immutable.ABRecord {\\n  \"a\": Immutable.Map {\\n    \"c\": 1,\\n  },\\n  \"b\": 2,\\n}',\n    );\n  });\n\n  it('supports imbricated Record {min: true}', () => {\n    const CDRecord = Immutable.Record({c: 3, d: 4}, 'CDRecord');\n    const ABRecord = Immutable.Record({a: CDRecord(), b: 2}, 'ABRecord');\n\n    expect(ABRecord()).toPrettyPrintTo(\n      'Immutable.ABRecord {\"a\": Immutable.CDRecord {\"c\": 3, \"d\": 4}, \"b\": 2}',\n      {min: true},\n    );\n  });\n\n  it('supports imbricated Record {min: false}', () => {\n    const CDRecord = Immutable.Record({c: 3, d: 4}, 'CDRecord');\n    const ABRecord = Immutable.Record({a: CDRecord(), b: 2}, 'ABRecord');\n\n    expect(ABRecord()).toPrettyPrintTo(\n      'Immutable.ABRecord {\\n  \"a\": Immutable.CDRecord {\\n    \"c\": 3,\\n    \"d\": 4,\\n  },\\n  \"b\": 2,\\n}',\n    );\n  });\n});\n\ndescribe('indentation of heterogeneous collections', () => {\n  // Don’t interpret tests that pretty-format and plugins are compatible\n  // as recommendation to compose immutable and non-immutable collections.\n  test('empty Immutable.List as child of Object', () => {\n    const val = {\n      filter: 'all',\n      todos: Immutable.List([]),\n    };\n    expect(val).toPrettyPrintTo(\n      [\n        'Object {',\n        '  \"filter\": \"all\",',\n        '  \"todos\": Immutable.List [],',\n        '}',\n      ].join('\\n'),\n    );\n  });\n  test('empty Immutable.Map as child of Array', () => {\n    const val = [Immutable.Map({})];\n    expect(val).toPrettyPrintTo(\n      ['Array [', '  Immutable.Map {},', ']'].join('\\n'),\n    );\n  });\n\n  test('non-empty Array as child of Immutable.Map', () => {\n    const val = Immutable.Map({\n      filter: 'completed',\n      todos: [\n        Immutable.Map({\n          completed: true,\n          text: 'Replace print with serialize',\n        }),\n      ],\n    });\n    expect(val).toPrettyPrintTo(\n      [\n        'Immutable.Map {',\n        '  \"filter\": \"completed\",',\n        '  \"todos\": Array [',\n        '    Immutable.Map {',\n        '      \"completed\": true,',\n        '      \"text\": \"Replace print with serialize\",',\n        '    },',\n        '  ],',\n        '}',\n      ].join('\\n'),\n    );\n  });\n  test('non-empty Object as child of Immutable.List', () => {\n    const val = Immutable.List([\n      {\n        completed: true,\n        text: 'Replace print with serialize',\n      },\n    ]);\n    expect(val).toPrettyPrintTo(\n      [\n        'Immutable.List [',\n        '  Object {',\n        '    \"completed\": true,',\n        '    \"text\": \"Replace print with serialize\",',\n        '  },',\n        ']',\n      ].join('\\n'),\n    );\n  });\n});\n\ndescribe('indent option', () => {\n  const val = Immutable.Map({\n    filter: 'completed',\n    todos: Immutable.List([\n      Immutable.Map({\n        completed: true,\n        text: 'Replace print with serialize',\n      }),\n      Immutable.Map({\n        completed: false,\n        text: 'Return if depth exceeds max',\n      }),\n    ]),\n  });\n  const expected = [\n    'Immutable.Map {',\n    '  \"filter\": \"completed\",',\n    '  \"todos\": Immutable.List [',\n    '    Immutable.Map {',\n    '      \"completed\": true,',\n    '      \"text\": \"Replace print with serialize\",',\n    '    },',\n    '    Immutable.Map {',\n    '      \"completed\": false,',\n    '      \"text\": \"Return if depth exceeds max\",',\n    '    },',\n    '  ],',\n    '}',\n  ].join('\\n');\n  test('default implicit: 2 spaces', () => {\n    expect(val).toPrettyPrintTo(expected);\n  });\n  test('default explicit: 2 spaces', () => {\n    expect(val).toPrettyPrintTo(expected, {indent: 2});\n  });\n\n  // Tests assume that no strings in val contain multiple adjacent spaces!\n  test('non-default: 0 spaces', () => {\n    const indent = 0;\n    expect(val).toPrettyPrintTo(\n      expected.replaceAll(/ {2}/g, ' '.repeat(indent)),\n      {\n        indent,\n      },\n    );\n  });\n  test('non-default: 4 spaces', () => {\n    const indent = 4;\n    expect(val).toPrettyPrintTo(\n      expected.replaceAll(/ {2}/g, ' '.repeat(indent)),\n      {\n        indent,\n      },\n    );\n  });\n});\n\ndescribe('maxDepth option', () => {\n  // Don’t interpret tests that pretty-format and plugins are compatible\n  // as recommendation to compose immutable and non-immutable collections.\n  test('Immutable.List as child of Object', () => {\n    const val = {\n      // ++depth === 1\n      filter: 'all',\n      todos: Immutable.List([\n        Immutable.Map({\n          completed: true,\n          text: 'Return if depth exceeds max',\n        }),\n      ]),\n    };\n    const expected = [\n      'Object {',\n      '  \"filter\": \"all\",',\n      '  \"todos\": [Immutable.List],',\n      '}',\n    ].join('\\n');\n    expect(val).toPrettyPrintTo(expected, {maxDepth: 1});\n  });\n  test('Immutable.Map as child of Array', () => {\n    const val = [\n      // ++depth === 1\n      Immutable.Map({\n        completed: false,\n        text: 'Return if depth exceeds max',\n      }),\n    ];\n    const expected = ['Array [', '  [Immutable.Map],', ']'].join('\\n');\n    expect(val).toPrettyPrintTo(expected, {maxDepth: 1});\n  });\n\n  test('Immutable.Seq as child of Immutable.Map', () => {\n    const val = {\n      // ++depth === 1\n      filter: 'all',\n      todos: Immutable.Seq(\n        Immutable.List([\n          Immutable.Map({\n            completed: true,\n            text: 'Return if depth exceeds max',\n          }),\n        ]),\n      ),\n    };\n    const expected = [\n      'Object {',\n      '  \"filter\": \"all\",',\n      '  \"todos\": [Immutable.Seq],',\n      '}',\n    ].join('\\n');\n    expect(val).toPrettyPrintTo(expected, {maxDepth: 1});\n  });\n  test('Immutable.Map as descendants in immutable collection', () => {\n    const val = Immutable.Map({\n      // ++depth === 1\n      filter: 'uncompleted',\n      todos: Immutable.List([\n        // ++depth === 2\n        Immutable.Map({\n          // ++depth === 3\n          completed: true,\n          text: 'Replace print with serialize',\n        }),\n        Immutable.Map({\n          // ++depth === 3\n          completed: true,\n          text: 'Return if depth exceeds max',\n        }),\n      ]),\n    });\n    const expected = [\n      'Immutable.Map {',\n      '  \"filter\": \"uncompleted\",',\n      '  \"todos\": Immutable.List [',\n      '    [Immutable.Map],',\n      '    [Immutable.Map],',\n      '  ],',\n      '}',\n    ].join('\\n');\n    expect(val).toPrettyPrintTo(expected, {maxDepth: 2});\n  });\n});\n\ndescribe('Immutable.Seq', () => {\n  it('supports an empty sequence from array {min: true}', () => {\n    expect(Immutable.Seq([])).toPrettyPrintTo('Immutable.Seq []', {min: true});\n  });\n  it('supports an empty sequence from array {min: false}', () => {\n    expect(Immutable.Seq([])).toPrettyPrintTo('Immutable.Seq []', {min: false});\n  });\n  it('supports a non-empty sequence from array {min: true}', () => {\n    expect(Immutable.Seq([0, 1, 2])).toPrettyPrintTo(\n      'Immutable.Seq [0, 1, 2]',\n      {min: true},\n    );\n  });\n  it('supports a non-empty sequence from array {min: false}', () => {\n    expect(Immutable.Seq([0, 1, 2])).toPrettyPrintTo(\n      'Immutable.Seq [\\n  0,\\n  1,\\n  2,\\n]',\n      {min: false},\n    );\n  });\n\n  it('supports a non-empty sequence from arguments', () => {\n    function returnArguments(..._args: Array<any>) {\n      return arguments;\n    }\n    expect(Immutable.Seq(returnArguments(0, 1, 2))).toPrettyPrintTo(\n      'Immutable.Seq [\\n  0,\\n  1,\\n  2,\\n]',\n    );\n  });\n\n  it('supports an empty sequence from object {min: true}', () => {\n    expect(Immutable.Seq({})).toPrettyPrintTo('Immutable.Seq {}', {min: true});\n  });\n  it('supports an empty sequence from object {min: false}', () => {\n    expect(Immutable.Seq({})).toPrettyPrintTo('Immutable.Seq {}', {min: false});\n  });\n  it('supports a non-empty sequence from object {min: true}', () => {\n    expect(Immutable.Seq({key: 'value'})).toPrettyPrintTo(\n      'Immutable.Seq {\"key\": \"value\"}',\n      {\n        min: true,\n      },\n    );\n  });\n  it('supports a non-empty sequence from object {min: false}', () => {\n    expect(Immutable.Seq({key: 'value'})).toPrettyPrintTo(\n      'Immutable.Seq {\\n  \"key\": \"value\",\\n}',\n      {\n        min: false,\n      },\n    );\n  });\n\n  it('supports a sequence of entries from Immutable.Map', () => {\n    expect(Immutable.Seq(Immutable.Map({key: 'value'}))).toPrettyPrintTo(\n      'Immutable.Seq {\\n  \"key\": \"value\",\\n}',\n    );\n  });\n\n  it('supports a sequence of values from ECMAScript Set', () => {\n    expect(Immutable.Seq(new Set([0, 1, 2]))).toPrettyPrintTo(\n      'Immutable.Seq [\\n  0,\\n  1,\\n  2,\\n]',\n    );\n  });\n  it('supports a sequence of values from Immutable.List', () => {\n    expect(Immutable.Seq(Immutable.List([0, 1, 2]))).toPrettyPrintTo(\n      'Immutable.Seq [\\n  0,\\n  1,\\n  2,\\n]',\n    );\n  });\n  it('supports a sequence of values from Immutable.Set', () => {\n    expect(Immutable.Seq(Immutable.Set([0, 1, 2]))).toPrettyPrintTo(\n      'Immutable.Seq [\\n  0,\\n  1,\\n  2,\\n]',\n    );\n  });\n  it('supports a sequence of values from Immutable.Stack', () => {\n    expect(Immutable.Seq(Immutable.Stack([0, 1, 2]))).toPrettyPrintTo(\n      'Immutable.Seq [\\n  0,\\n  1,\\n  2,\\n]',\n    );\n  });\n});\n\ndescribe('Immutable.Seq lazy entries', () => {\n  const expected = 'Immutable.Seq {…}';\n  const object = {key0: '', key1: '1'};\n  const filterer = (value: string) => value.length > 0;\n\n  // undefined size confirms correct criteria for lazy Seq\n  test('from object properties', () => {\n    const val = Immutable.Seq(object).filter(filterer);\n    expect(val.size).toBeUndefined();\n    expect(val).toPrettyPrintTo(expected);\n  });\n  test('from Immutable.Map entries', () => {\n    const val = Immutable.Seq(Immutable.Map<string, string>(object)).filter(\n      filterer,\n    );\n    expect(val.size).toBeUndefined();\n    expect(val).toPrettyPrintTo(expected);\n  });\n});\n\ndescribe('Immutable.Seq lazy values', () => {\n  const expected = 'Immutable.Seq […]';\n  const array = ['', '1', '22'];\n  const filterer = (item: string) => item.length > 0;\n\n  test('from Immutable.Range', () => {\n    const val = Immutable.Range(1, Number.POSITIVE_INFINITY);\n    expect(val.size).toBe(Number.POSITIVE_INFINITY);\n    expect(val).toPrettyPrintTo(expected);\n  });\n\n  // undefined size confirms correct criteria for lazy Seq\n  test('from iterator', () => {\n    function returnIterator<T>(values: Array<T>): IterableIterator<T> {\n      let i = 0;\n      return {\n        next() {\n          return i < values.length\n            ? {done: false, value: values[i++]}\n            : {done: true, value: undefined};\n        },\n        [Symbol.iterator]() {\n          return this;\n        },\n      };\n    }\n    const val = Immutable.Seq(returnIterator(array)).filter(filterer);\n    expect(val.size).toBeUndefined();\n    expect(val).toPrettyPrintTo(expected);\n  });\n  test('from array items', () => {\n    const val = Immutable.Seq(array).filter(filterer);\n    expect(val.size).toBeUndefined();\n    expect(val).toPrettyPrintTo(expected);\n  });\n  test('from Immutable.List values', () => {\n    const val = Immutable.Seq(Immutable.List(array)).filter(filterer);\n    expect(val.size).toBeUndefined();\n    expect(val).toPrettyPrintTo(expected);\n  });\n  test('from ECMAScript Set values', () => {\n    const val = Immutable.Seq(new Set(array)).filter(filterer);\n    expect(val.size).toBeUndefined();\n    expect(val).toPrettyPrintTo(expected);\n  });\n});\n",
  "packages/pretty-format/src/__tests__/Immutable.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/pretty-format/src/__tests__/DOMElement.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @jest-environment jsdom\n */\n\n/// <reference lib=\"dom\" />\n\n/* global document */\n\nimport prettyFormat, {plugins} from '../';\nimport setPrettyPrint from './setPrettyPrint';\n\nconst {DOMElement} = plugins;\n\nsetPrettyPrint([DOMElement]);\n\ndescribe('pretty-format', () => {\n  // Test is not related to plugin but is related to jsdom testing environment.\n  it('prints global window as constructor name alone', () => {\n    expect(prettyFormat(globalThis)).toBe('[Window]');\n  });\n});\n\ndescribe('DOMElement Plugin', () => {\n  it('supports a single HTML element', () => {\n    expect(document.createElement('div')).toPrettyPrintTo('<div />');\n  });\n\n  it('supports an HTML element with a class property', () => {\n    const parent = document.createElement('div');\n    parent.className = 'classy';\n\n    expect(parent).toPrettyPrintTo('<div\\n  class=\"classy\"\\n/>');\n  });\n\n  it('supports an HTML element with a title property', () => {\n    const parent = document.createElement('div');\n    parent.title = 'title text';\n\n    expect(parent).toPrettyPrintTo('<div\\n  title=\"title text\"\\n/>');\n  });\n\n  test('escapes double quote in attribute value', () => {\n    const parent = document.createElement('div');\n    parent.setAttribute('title', '\"escape\"');\n\n    expect(parent).toPrettyPrintTo('<div\\n  title=\"\\\\\"escape\\\\\"\"\\n/>');\n  });\n\n  it('supports an HTML element with a single attribute', () => {\n    const parent = document.createElement('div');\n    parent.setAttribute('class', 'classy');\n\n    expect(parent).toPrettyPrintTo('<div\\n  class=\"classy\"\\n/>');\n  });\n\n  it('supports an HTML element with multiple attributes', () => {\n    const parent = document.createElement('div');\n    // set attributes in unsorted order by name to verify sorting\n    parent.setAttribute('id', '123');\n    parent.setAttribute('class', 'classy');\n\n    expect(parent).toPrettyPrintTo('<div\\n  class=\"classy\"\\n  id=\"123\"\\n/>');\n  });\n\n  it('supports an HTML element with attribute and text content', () => {\n    const parent = document.createElement('div');\n    parent.setAttribute('style', 'color: #99424F');\n    const text = document.createTextNode('Jest');\n    parent.append(text);\n\n    expect(parent).toPrettyPrintTo(\n      '<div\\n  style=\"color: #99424F\"\\n>\\n  Jest\\n</div>',\n    );\n  });\n\n  it('supports an element with text content', () => {\n    const parent = document.createElement('div');\n    const child = document.createTextNode('texty texty');\n    parent.append(child);\n\n    expect(parent).toPrettyPrintTo('<div>\\n  texty texty\\n</div>');\n  });\n\n  it('supports nested elements', () => {\n    const parent = document.createElement('div');\n    const child = document.createElement('span');\n    parent.append(child);\n    expect(parent).toPrettyPrintTo('<div>\\n  <span />\\n</div>');\n  });\n\n  it('supports nested elements with attributes', () => {\n    const parent = document.createElement('div');\n    const child = document.createElement('span');\n    parent.append(child);\n\n    // set attributes in sorted order by name\n    child.setAttribute('class', 'classy');\n    child.setAttribute('id', '123');\n\n    expect(parent).toPrettyPrintTo(\n      '<div>\\n  <span\\n    class=\"classy\"\\n    id=\"123\"\\n  />\\n</div>',\n    );\n  });\n\n  it('supports nested elements with attribute and text content', () => {\n    const parent = document.createElement('div');\n    const child = document.createElement('span');\n    parent.append(child);\n\n    child.setAttribute('style', 'color: #99424F');\n    const text = document.createTextNode('Jest');\n    child.append(text);\n\n    expect(parent).toPrettyPrintTo(\n      '<div>\\n  <span\\n    style=\"color: #99424F\"\\n  >\\n    Jest\\n  </span>\\n</div>',\n    );\n  });\n\n  it('supports nested elements with text content', () => {\n    const parent = document.createElement('div');\n    const child = document.createElement('span');\n    parent.append(child);\n    child.textContent = 'texty texty';\n\n    expect(parent).toPrettyPrintTo(\n      '<div>\\n  <span>\\n    texty texty\\n  </span>\\n</div>',\n    );\n  });\n\n  it('supports siblings', () => {\n    const parent = document.createElement('div');\n    parent.innerHTML = '<span>some </span><span>text</span>';\n\n    expect(parent).toPrettyPrintTo(\n      [\n        '<div>',\n        '  <span>',\n        '    some ',\n        '  </span>',\n        '  <span>',\n        '    text',\n        '  </span>',\n        '</div>',\n      ].join('\\n'),\n    );\n  });\n\n  it('supports multiline text node in pre', () => {\n    const parent = document.createElement('pre');\n    parent.innerHTML = [\n      // prettier-ignore\n      'function sum(a, b) {',\n      '  return a + b;',\n      '}',\n    ].join('\\n');\n\n    // Ouch. Two lines of text have same indentation for different reason:\n    // First line of text node because it is at child level.\n    // Second line of text node because they are in its content.\n    expect(parent).toPrettyPrintTo(\n      // prettier-ignore\n      [\n        '<pre>',\n        '  function sum(a, b) {',\n        '  return a + b;',\n        '}',\n        '</pre>'\n      ].join('\\n'),\n    );\n  });\n\n  it('supports multiline text node preceding span in pre', () => {\n    const parent = document.createElement('pre');\n    parent.innerHTML = [\n      '<span class=\"token keyword\">function</span> sum(a, b) {',\n      '  <span class=\"token keyword\">return</span> a + b;',\n      '}',\n    ].join('\\n');\n\n    expect(parent).toPrettyPrintTo(\n      [\n        '<pre>',\n        '  <span',\n        '    class=\"token keyword\"',\n        '  >',\n        '    function',\n        '  </span>',\n        '   sum(a, b) {',\n        '  ',\n        '  <span',\n        '    class=\"token keyword\"',\n        '  >',\n        '    return',\n        '  </span>',\n        '   a + b;',\n        '}',\n        '</pre>',\n      ].join('\\n'),\n    );\n  });\n\n  it('supports multiline text node in textarea', () => {\n    const textarea = document.createElement('textarea');\n    textarea.setAttribute('name', 'tagline');\n    textarea.innerHTML = `Painless.\nJavaScript.\nTesting.`;\n\n    expect(textarea).toPrettyPrintTo(\n      [\n        '<textarea',\n        '  name=\"tagline\"',\n        '>',\n        '  Painless.',\n        'JavaScript.',\n        'Testing.',\n        '</textarea>',\n      ].join('\\n'),\n    );\n  });\n\n  it('supports empty text node', () => {\n    // React 16 does not render text in comments (see below)\n    const parent = document.createElement('span');\n    const text = document.createTextNode('');\n    parent.append(text);\n    const abbr = document.createElement('abbr');\n    abbr.setAttribute('title', 'meter');\n    abbr.innerHTML = 'm';\n    parent.append(abbr);\n\n    expect(parent).toPrettyPrintTo(\n      [\n        '<span>',\n        '  ',\n        '  <abbr',\n        '    title=\"meter\"',\n        '  >',\n        '    m',\n        '  </abbr>',\n        '</span>',\n      ].join('\\n'),\n    );\n  });\n\n  it('supports non-empty text node', () => {\n    // React 16 does not render text in comments (see below)\n    const parent = document.createElement('p');\n    parent.innerHTML = [\n      '<strong>Jest</strong>',\n      ' means ',\n      '<em>painless</em>',\n      ' Javascript testing',\n    ].join('');\n\n    expect(parent).toPrettyPrintTo(\n      [\n        '<p>',\n        '  <strong>',\n        '    Jest',\n        '  </strong>',\n        '   means ',\n        '  <em>',\n        '    painless',\n        '  </em>',\n        '   Javascript testing',\n        '</p>',\n      ].join('\\n'),\n    );\n  });\n\n  it('supports comment node', () => {\n    // React 15 does render text in comments\n    const parent = document.createElement('p');\n    parent.innerHTML = [\n      '<strong>Jest</strong>',\n      '<!-- react-text: 3 -->',\n      ' means ',\n      '<!-- /react-text -->',\n      '<em>painless</em>',\n      '<!-- react-text: 5 -->',\n      ' Javascript testing',\n      '<!-- /react-text -->',\n    ].join('');\n\n    expect(parent).toPrettyPrintTo(\n      [\n        '<p>',\n        '  <strong>',\n        '    Jest',\n        '  </strong>',\n        '  <!-- react-text: 3 -->',\n        '   means ',\n        '  <!-- /react-text -->',\n        '  <em>',\n        '    painless',\n        '  </em>',\n        '  <!-- react-text: 5 -->',\n        '   Javascript testing',\n        '  <!-- /react-text -->',\n        '</p>',\n      ].join('\\n'),\n    );\n  });\n\n  it('supports fragment node', () => {\n    const fragment = document.createDocumentFragment();\n    const browsers = [\n      'Firefox',\n      'Chrome',\n      'Opera',\n      'Safari',\n      'Internet Explorer',\n    ];\n\n    for (const browser of browsers) {\n      const li = document.createElement('li');\n      li.textContent = browser;\n      fragment.append(li);\n    }\n\n    expect(fragment).toPrettyPrintTo(\n      [\n        '<DocumentFragment>',\n        '  <li>',\n        '    Firefox',\n        '  </li>',\n        '  <li>',\n        '    Chrome',\n        '  </li>',\n        '  <li>',\n        '    Opera',\n        '  </li>',\n        '  <li>',\n        '    Safari',\n        '  </li>',\n        '  <li>',\n        '    Internet Explorer',\n        '  </li>',\n        '</DocumentFragment>',\n      ].join('\\n'),\n    );\n  });\n\n  it('supports custom elements', () => {\n    class CustomElement extends HTMLElement {}\n    class CustomParagraphElement extends HTMLParagraphElement {}\n    class CustomExtendedElement extends CustomElement {}\n\n    customElements.define('custom-element', CustomElement);\n    customElements.define('custom-extended-element', CustomExtendedElement);\n    customElements.define('custom-paragraph', CustomParagraphElement, {\n      extends: 'p',\n    });\n    customElements.define('anonymous-element', class extends HTMLElement {});\n\n    const parent = document.createElement('div');\n    parent.innerHTML = [\n      '<custom-element></custom-element>',\n      '<custom-extended-element></custom-extended-element>',\n      '<p is=\"custom-paragraph\"></p>',\n      '<anonymous-element></anonymous-element>',\n    ].join('');\n\n    expect(parent).toPrettyPrintTo(\n      [\n        '<div>',\n        '  <custom-element />',\n        '  <custom-extended-element />',\n        '  <p',\n        '    is=\"custom-paragraph\"',\n        '  />',\n        '  <anonymous-element />',\n        '</div>',\n      ].join('\\n'),\n    );\n  });\n\n  describe('matches constructor name of SVG elements', () => {\n    // Too bad, so sad, element.constructor.name of SVG elements\n    // is HTMLUnknownElement in jsdom v9 and v10\n    // is Element in jsdom v11\n    // instead of SVG…Element in browser DOM\n    const expected = [\n      '<svg',\n      '  viewBox=\"0 0 1 1\"',\n      '>',\n      '  <title>',\n      '    JS community logo',\n      '  </title>',\n      '</svg>',\n    ].join('\\n');\n\n    test('jsdom 9 and 10', () => {\n      // Mock element objects to make sure the plugin really matches them.\n      class SVGSVGElement {\n        childNodes: Array<SVGTitleElement>;\n        nodeType = 1;\n        tagName = 'svg'; // lower case;\n\n        constructor(\n          public attributes: Array<Record<string, string>>,\n          ...children: Array<SVGTitleElement>\n        ) {\n          this.childNodes = children;\n        }\n      }\n\n      class SVGTitleElement {\n        attributes: Array<Record<string, string>> = [];\n        childNodes: Array<ChildNode>;\n        nodeType = 1;\n        tagName = 'title'; // lower case;\n\n        constructor(title: string) {\n          this.childNodes = [document.createTextNode(title)];\n        }\n      }\n\n      const title = new SVGTitleElement('JS community logo');\n      const svg = new SVGSVGElement(\n        [{name: 'viewBox', value: '0 0 1 1'}],\n        title,\n      );\n\n      expect(svg).toPrettyPrintTo(expected);\n    });\n    test('jsdom 11', () => {\n      // Mock element objects to make sure the plugin really matches them.\n      class Element {\n        childNodes: Array<Element | string>;\n        nodeType = 1;\n\n        constructor(\n          public tagName: string,\n          public attributes: Array<Record<string, string>>,\n          ...children: Array<Element | string>\n        ) {\n          this.childNodes = children;\n        }\n      }\n\n      const title = new Element('title', [], 'JS community logo');\n      const svg = new Element(\n        'svg',\n        [{name: 'viewBox', value: '0 0 1 1'}],\n        title,\n      );\n\n      expect(svg).toPrettyPrintTo(expected);\n    });\n  });\n\n  it('supports SVG elements', () => {\n    // In jsdom v9, this is NOT a regression test. See above.\n    const namespace = 'http://www.w3.org/2000/svg';\n\n    const title = document.createElementNS(namespace, 'title');\n    title.append(document.createTextNode('JS community logo'));\n\n    const rect = document.createElementNS(namespace, 'rect');\n    // printProps sorts attributes in order by name\n    rect.setAttribute('width', '1');\n    rect.setAttribute('height', '1');\n    rect.setAttribute('fill', '#f7df1e');\n\n    const polyline = document.createElementNS(namespace, 'polyline');\n    polyline.setAttribute('id', 'J');\n    polyline.setAttribute('points', '0.5,0.460 0.5,0.875 0.25,0.875');\n    const comment = document.createComment('polyline for S');\n\n    const g = document.createElementNS(namespace, 'g');\n    g.setAttribute('fill', 'none');\n    g.setAttribute('stroke', '#000000');\n    g.setAttribute('stroke-width', '0.095');\n    g.append(polyline);\n    g.append(comment);\n\n    const svg = document.createElementNS(namespace, 'svg');\n    svg.setAttribute('viewBox', '0 0 1 1');\n    svg.append(title);\n    svg.append(rect);\n    svg.append(g);\n\n    const parent = document.createElement('div');\n    parent.setAttribute('id', 'JS');\n    parent.append(svg);\n\n    expect(parent).toPrettyPrintTo(\n      [\n        '<div',\n        '  id=\"JS\"',\n        '>',\n        '  <svg',\n        '    viewBox=\"0 0 1 1\"',\n        '  >',\n        '    <title>',\n        '      JS community logo',\n        '    </title>',\n        '    <rect',\n        '      fill=\"#f7df1e\"',\n        '      height=\"1\"',\n        '      width=\"1\"',\n        '    />',\n        '    <g',\n        '      fill=\"none\"',\n        '      stroke=\"#000000\"',\n        '      stroke-width=\"0.095\"',\n        '    >',\n        '      <polyline',\n        '        id=\"J\"',\n        '        points=\"0.5,0.460 0.5,0.875 0.25,0.875\"',\n        '      />',\n        '      <!--polyline for S-->',\n        '    </g>',\n        '  </svg>',\n        '</div>',\n      ].join('\\n'),\n    );\n  });\n\n  it('supports indentation for array of elements', () => {\n    // For example, Array.prototype.slice.call(document.getElementsByTagName(…))\n    const dd1 = document.createElement('dd');\n    dd1.innerHTML = 'to talk in a playful manner';\n\n    const dd2 = document.createElement('dd');\n    dd2.innerHTML = 'painless JavaScript testing';\n    dd2.setAttribute('style', 'color: #99424F');\n\n    expect([dd1, dd2]).toPrettyPrintTo(\n      [\n        'Array [',\n        '  <dd>',\n        '    to talk in a playful manner',\n        '  </dd>,',\n        '  <dd',\n        '    style=\"color: #99424F\"',\n        '  >',\n        '    painless JavaScript testing',\n        '  </dd>,',\n        ']',\n      ].join('\\n'),\n    );\n  });\n\n  it('supports maxDepth option', () => {\n    const dt = document.createElement('dt');\n    dt.innerHTML = 'jest';\n\n    const dd1 = document.createElement('dd');\n    dd1.innerHTML = 'to talk in a <em>playful</em> manner';\n\n    const dd2 = document.createElement('dd');\n    dd2.innerHTML = '<em>painless</em> JavaScript testing';\n    dd2.setAttribute('style', 'color: #99424F');\n\n    const dl = document.createElement('dl');\n    dl.append(dt);\n    dl.append(dd1);\n    dl.append(dd2);\n\n    expect(dl).toPrettyPrintTo(\n      [\n        '<dl>',\n        '  <dt>',\n        '    jest',\n        '  </dt>',\n        '  <dd>',\n        '    to talk in a ',\n        '    <em … />',\n        '     manner',\n        '  </dd>',\n        '  <dd',\n        '    style=\"color: #99424F\"',\n        '  >',\n        '    <em … />',\n        '     JavaScript testing',\n        '  </dd>',\n        '</dl>',\n      ].join('\\n'),\n      {maxDepth: 2},\n    );\n  });\n\n  it('handles `tagName` not being a string', () => {\n    expect({\n      name: 'value',\n      tagName: {text: 'param'},\n      type: 'string',\n    }).toPrettyPrintTo(\n      [\n        'Object {',\n        '  \"name\": \"value\",',\n        '  \"tagName\": Object {',\n        '    \"text\": \"param\",',\n        '  },',\n        '  \"type\": \"string\",',\n        '}',\n      ].join('\\n'),\n    );\n  });\n\n  it('handles jsdom attributes properly', () => {\n    const attributes = require('jsdom/lib/jsdom/living/attributes');\n    expect(DOMElement.test(attributes)).toBe(false);\n  });\n});\n",
  "packages/pretty-format/src/__tests__/DOMElement.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @jest-environment jsdom\n */\nexport {};\n",
  "packages/pretty-format/src/__tests__/DOMCollection.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @jest-environment jsdom\n */\n\n/// <reference lib=\"dom\" />\n\n/* global document */\n\nimport {plugins} from '../';\nimport setPrettyPrint from './setPrettyPrint';\n\nconst {DOMCollection, DOMElement} = plugins;\n\nsetPrettyPrint([DOMCollection, DOMElement]);\n\ndescribe('DOMCollection plugin for object properties', () => {\n  it('supports DOMStringMap', () => {\n    const el = document.createElement('div');\n    el.dataset.foo = 'bar';\n\n    expect(el.dataset).toPrettyPrintTo('DOMStringMap {\\n  \"foo\": \"bar\",\\n}');\n  });\n\n  it('supports NamedNodeMap', () => {\n    const el = document.createElement('div');\n    el.setAttribute('foo', 'bar');\n\n    expect(el.attributes).toPrettyPrintTo('NamedNodeMap {\\n  \"foo\": \"bar\",\\n}');\n  });\n\n  it('supports config.min option', () => {\n    const el = document.createElement('div');\n    el.setAttribute('name1', 'value1');\n    el.setAttribute('name2', 'value2');\n\n    expect(el.attributes).toPrettyPrintTo(\n      '{\"name1\": \"value1\", \"name2\": \"value2\"}',\n      {min: true},\n    );\n  });\n});\n\ndescribe('DOMCollection plugin for list items', () => {\n  const select = document.createElement('select');\n  select.innerHTML = [\n    '<option value=\"1\">one</option>',\n    '<option value=\"2\">two</option>',\n    '<option value=\"3\">three</option>',\n  ].join('');\n\n  const form = document.createElement('form');\n  form.append(select);\n\n  const expectedOption1 = [\n    '  <option',\n    '    value=\"1\"',\n    '  >',\n    '    one',\n    '  </option>,', // comma because item\n  ].join('\\n');\n  const expectedOption2 = [\n    '  <option',\n    '    value=\"2\"',\n    '  >',\n    '    two',\n    '  </option>,', // comma because item\n  ].join('\\n');\n  const expectedOption3 = [\n    '  <option',\n    '    value=\"3\"',\n    '  >',\n    '    three',\n    '  </option>,', // comma because item\n  ].join('\\n');\n\n  const expectedHTMLCollection = [\n    'HTMLCollection [',\n    expectedOption1,\n    expectedOption2,\n    expectedOption3,\n    ']',\n  ].join('\\n');\n\n  it('supports HTMLCollection for getElementsByTagName', () => {\n    // eslint-disable-next-line unicorn/prefer-query-selector\n    const options = form.getElementsByTagName('option');\n    expect(options).toPrettyPrintTo(expectedHTMLCollection);\n  });\n\n  it('supports HTMLCollection for children', () => {\n    expect(select.children).toPrettyPrintTo(expectedHTMLCollection);\n  });\n\n  it('supports config.maxDepth option', () => {\n    expect(select.children).toPrettyPrintTo('[HTMLCollection]', {maxDepth: 0});\n  });\n\n  const expectedNodeList = [\n    'NodeList [',\n    expectedOption1,\n    expectedOption2,\n    expectedOption3,\n    ']',\n  ].join('\\n');\n\n  it('supports NodeList for querySelectorAll', () => {\n    const options = form.querySelectorAll('option');\n    expect(options).toPrettyPrintTo(expectedNodeList);\n  });\n\n  it('supports NodeList for childNodes', () => {\n    expect(select.childNodes).toPrettyPrintTo(expectedNodeList);\n  });\n\n  const expectedHTMLOptionsCollection = [\n    'HTMLOptionsCollection [',\n    expectedOption1,\n    expectedOption2,\n    expectedOption3,\n    ']',\n  ].join('\\n');\n\n  it('supports HTMLOptionsCollection for select options', () => {\n    expect(select.options).toPrettyPrintTo(expectedHTMLOptionsCollection);\n  });\n\n  const expectedHTMLFormControlsCollection = [\n    'HTMLFormControlsCollection [',\n    '  <select>',\n    '    <option',\n    '      value=\"1\"',\n    '    >',\n    '      one',\n    '    </option>', // no comma because element\n    '    <option',\n    '      value=\"2\"',\n    '    >',\n    '      two',\n    '    </option>', // no comma because element\n    '    <option',\n    '      value=\"3\"',\n    '    >',\n    '      three',\n    '    </option>', // no comma because element\n    '  </select>,', // comma because item\n    ']',\n  ].join('\\n');\n\n  it('supports HTMLCollection for form elements', () => {\n    expect(form.elements).toPrettyPrintTo(expectedHTMLFormControlsCollection);\n  });\n});\n",
  "packages/pretty-format/src/__tests__/DOMCollection.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @jest-environment jsdom\n */\nexport {};\n",
  "packages/pretty-format/src/__tests__/AsymmetricMatcher.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport prettyFormat, {plugins} from '../';\nimport type {OptionsReceived} from '../types';\n\nconst {AsymmetricMatcher} = plugins;\nlet options: OptionsReceived;\n\nfunction fnNameFor(func: (...any: Array<any>) => unknown) {\n  if (func.name) {\n    return func.name;\n  }\n\n  const matches = func.toString().match(/^\\s*function\\s*(\\w*)\\s*\\(/);\n  return matches ? matches[1] : '<anonymous>';\n}\n\nbeforeEach(() => {\n  options = {plugins: [AsymmetricMatcher]};\n});\n\nfor (const type of [\n  String,\n  Function,\n  Array,\n  Object,\n  RegExp,\n  Symbol,\n  Function,\n  () => {},\n  function namedFunction() {},\n]) {\n  test(`supports any(${fnNameFor(type)})`, () => {\n    const result = prettyFormat(expect.any(type), options);\n    expect(result).toBe(`Any<${fnNameFor(type)}>`);\n  });\n\n  test(`supports nested any(${fnNameFor(type)})`, () => {\n    const result = prettyFormat(\n      {\n        test: {\n          nested: expect.any(type),\n        },\n      },\n      options,\n    );\n    expect(result).toBe(\n      `Object {\\n  \"test\": Object {\\n    \"nested\": Any<${fnNameFor(\n        type,\n      )}>,\\n  },\\n}`,\n    );\n  });\n}\n\ntest('anything()', () => {\n  const result = prettyFormat(expect.anything(), options);\n  expect(result).toBe('Anything');\n});\n\ntest('arrayContaining()', () => {\n  const result = prettyFormat(expect.arrayContaining([1, 2]), options);\n  expect(result).toBe(`ArrayContaining [\n  1,\n  2,\n]`);\n});\n\ntest('arrayNotContaining()', () => {\n  const result = prettyFormat(expect.not.arrayContaining([1, 2]), options);\n  expect(result).toBe(`ArrayNotContaining [\n  1,\n  2,\n]`);\n});\n\ntest('arrayOf()', () => {\n  const result = prettyFormat(expect.arrayOf(expect.any(String)), options);\n  expect(result).toBe('ArrayOf Any<String>');\n});\n\ntest('notArrayOf()', () => {\n  const result = prettyFormat(expect.not.arrayOf(expect.any(String)), options);\n  expect(result).toBe('NotArrayOf Any<String>');\n});\n\ntest('objectContaining()', () => {\n  const result = prettyFormat(expect.objectContaining({a: 'test'}), options);\n  expect(result).toBe(`ObjectContaining {\n  \"a\": \"test\",\n}`);\n});\n\ntest('objectNotContaining()', () => {\n  const result = prettyFormat(\n    expect.not.objectContaining({a: 'test'}),\n    options,\n  );\n  expect(result).toBe(`ObjectNotContaining {\n  \"a\": \"test\",\n}`);\n});\n\ntest('stringContaining(string)', () => {\n  const result = prettyFormat(expect.stringContaining('jest'), options);\n  expect(result).toBe('StringContaining \"jest\"');\n});\n\ntest('not.stringContaining(string)', () => {\n  const result = prettyFormat(expect.not.stringContaining('jest'), options);\n  expect(result).toBe('StringNotContaining \"jest\"');\n});\n\ntest('stringMatching(string)', () => {\n  const result = prettyFormat(expect.stringMatching('jest'), options);\n  expect(result).toBe('StringMatching /jest/');\n});\n\ntest('stringMatching(regexp)', () => {\n  const result = prettyFormat(expect.stringMatching(/(jest|niema).*/), options);\n  expect(result).toBe('StringMatching /(jest|niema).*/');\n});\n\ntest('stringMatching(regexp) {escapeRegex: false}', () => {\n  const result = prettyFormat(expect.stringMatching(/regexp\\d/gi), options);\n  expect(result).toBe('StringMatching /regexp\\\\d/gi');\n});\n\ntest('stringMatching(regexp) {escapeRegex: true}', () => {\n  const result = prettyFormat(expect.stringMatching(/regexp\\d/gi), {\n    ...options,\n    escapeRegex: true,\n  });\n  expect(result).toBe('StringMatching /regexp\\\\\\\\d/gi');\n});\n\ntest('stringNotMatching(string)', () => {\n  const result = prettyFormat(expect.not.stringMatching('jest'), options);\n  expect(result).toBe('StringNotMatching /jest/');\n});\n\ntest('closeTo(number, precision)', () => {\n  const result = prettyFormat(expect.closeTo(1.2345, 4), options);\n  expect(result).toBe('NumberCloseTo 1.2345 (4 digits)');\n});\n\ntest('notCloseTo(number, precision)', () => {\n  const result = prettyFormat(expect.not.closeTo(1.2345, 1), options);\n  expect(result).toBe('NumberNotCloseTo 1.2345 (1 digit)');\n});\n\ntest('closeTo(number)', () => {\n  const result = prettyFormat(expect.closeTo(1.2345), options);\n  expect(result).toBe('NumberCloseTo 1.2345 (2 digits)');\n});\n\ntest('closeTo(Infinity)', () => {\n  const result = prettyFormat(\n    expect.closeTo(Number.NEGATIVE_INFINITY),\n    options,\n  );\n  expect(result).toBe('NumberCloseTo -Infinity (2 digits)');\n});\n\ntest('closeTo(scientific number)', () => {\n  const result = prettyFormat(expect.closeTo(1.56e-3, 4), options);\n  expect(result).toBe('NumberCloseTo 0.00156 (4 digits)');\n});\n\ntest('closeTo(very small scientific number)', () => {\n  const result = prettyFormat(expect.closeTo(1.56e-10, 4), options);\n  expect(result).toBe('NumberCloseTo 1.56e-10 (4 digits)');\n});\n\ntest('correctly handles inability to pretty-print matcher', () => {\n  expect(() => prettyFormat(new DummyMatcher(1), options)).toThrow(\n    'Asymmetric matcher DummyMatcher does not implement toAsymmetricMatcher()',\n  );\n});\n\ntest('supports multiple nested asymmetric matchers', () => {\n  const result = prettyFormat(\n    {\n      test: {\n        nested: expect.objectContaining({\n          a: expect.arrayContaining([1]),\n          b: expect.anything(),\n          c: expect.any(String),\n          d: expect.stringContaining('jest'),\n          e: expect.stringMatching('jest'),\n          f: expect.objectContaining({test: 'case'}),\n          g: expect.arrayOf(\n            expect.objectContaining({\n              nested: expect.any(Number),\n            }),\n          ),\n        }),\n      },\n    },\n    options,\n  );\n  expect(result).toBe(`Object {\n  \"test\": Object {\n    \"nested\": ObjectContaining {\n      \"a\": ArrayContaining [\n        1,\n      ],\n      \"b\": Anything,\n      \"c\": Any<String>,\n      \"d\": StringContaining \"jest\",\n      \"e\": StringMatching /jest/,\n      \"f\": ObjectContaining {\n        \"test\": \"case\",\n      },\n      \"g\": ArrayOf ObjectContaining {\n        \"nested\": Any<Number>,\n      },\n    },\n  },\n}`);\n});\n\ndescribe('indent option', () => {\n  const val = {\n    nested: expect.objectContaining({\n      a: expect.arrayContaining([1]),\n      b: expect.anything(),\n      c: expect.any(String),\n      d: expect.stringContaining('jest'),\n      e: expect.stringMatching('jest'),\n      f: expect.objectContaining({\n        composite: ['exact', 'match'],\n        primitive: 'string',\n      }),\n    }),\n  };\n  const result = `Object {\n  \"nested\": ObjectContaining {\n    \"a\": ArrayContaining [\n      1,\n    ],\n    \"b\": Anything,\n    \"c\": Any<String>,\n    \"d\": StringContaining \"jest\",\n    \"e\": StringMatching /jest/,\n    \"f\": ObjectContaining {\n      \"composite\": Array [\n        \"exact\",\n        \"match\",\n      ],\n      \"primitive\": \"string\",\n    },\n  },\n}`;\n\n  test('default implicit: 2 spaces', () => {\n    expect(prettyFormat(val, options)).toEqual(result);\n  });\n  test('default explicit: 2 spaces', () => {\n    expect(prettyFormat(val, {...options, indent: 2})).toEqual(result);\n  });\n\n  // Tests assume that no strings in val contain multiple adjacent spaces!\n  test('non-default: 0 spaces', () => {\n    expect(prettyFormat(val, {...options, indent: 0})).toEqual(\n      result.replaceAll(/ {2}/g, ''),\n    );\n  });\n  test('non-default: 4 spaces', () => {\n    expect(prettyFormat(val, {...options, indent: 4})).toEqual(\n      result.replaceAll(/ {2}/g, ' '.repeat(4)),\n    );\n  });\n});\n\ndescribe('maxDepth option', () => {\n  test('matchers as leaf nodes', () => {\n    const val = {\n      // ++depth === 1\n      nested: [\n        // ++depth === 2\n        expect.arrayContaining(\n          // ++depth === 3\n          [1],\n        ),\n        expect.objectContaining({\n          // ++depth === 3\n          composite: ['exact', 'match'],\n          primitive: 'string',\n        }),\n        expect.stringContaining('jest'),\n        expect.stringMatching('jest'),\n        expect.any(String),\n        expect.anything(),\n      ],\n    };\n    const result = prettyFormat(val, {...options, maxDepth: 2});\n    expect(result).toBe(`Object {\n  \"nested\": Array [\n    [ArrayContaining],\n    [ObjectContaining],\n    StringContaining \"jest\",\n    StringMatching /jest/,\n    Any<String>,\n    Anything,\n  ],\n}`);\n  });\n  test('matchers as internal nodes', () => {\n    const val = [\n      // ++depth === 1\n      expect.arrayContaining([\n        // ++depth === 2\n        'printed',\n        {\n          // ++depth === 3\n          properties: 'not printed',\n        },\n      ]),\n      expect.objectContaining({\n        // ++depth === 2\n        array: [\n          // ++depth === 3\n          'items',\n          'not',\n          'printed',\n        ],\n        primitive: 'printed',\n      }),\n    ];\n    const result = prettyFormat(val, {...options, maxDepth: 2});\n    expect(result).toBe(`Array [\n  ArrayContaining [\n    \"printed\",\n    [Object],\n  ],\n  ObjectContaining {\n    \"array\": [Array],\n    \"primitive\": \"printed\",\n  },\n]`);\n  });\n});\n\ntest('min option', () => {\n  const result = prettyFormat(\n    {\n      test: {\n        nested: expect.objectContaining({\n          a: expect.arrayContaining([1]),\n          b: expect.anything(),\n          c: expect.any(String),\n          d: expect.stringContaining('jest'),\n          e: expect.stringMatching('jest'),\n          f: expect.objectContaining({test: 'case'}),\n        }),\n      },\n    },\n    {...options, min: true},\n  );\n  expect(result).toBe(\n    '{\"test\": {\"nested\": ObjectContaining {\"a\": ArrayContaining [1], \"b\": Anything, \"c\": Any<String>, \"d\": StringContaining \"jest\", \"e\": StringMatching /jest/, \"f\": ObjectContaining {\"test\": \"case\"}}}}',\n  );\n});\n\nclass DummyMatcher {\n  $$typeof = Symbol.for('jest.asymmetricMatcher');\n\n  constructor(private readonly sample: number) {}\n\n  asymmetricMatch(other: number) {\n    return this.sample === other;\n  }\n\n  toString() {\n    return 'DummyMatcher';\n  }\n\n  getExpectedType() {\n    return 'number';\n  }\n}\n",
  "packages/pretty-format/src/__tests__/AsymmetricMatcher.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-worker/src/types.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {ForkOptions} from 'child_process';\nimport type {ResourceLimits} from 'worker_threads';\n\ntype ReservedKeys = 'end' | 'getStderr' | 'getStdout' | 'setup' | 'teardown';\ntype ExcludeReservedKeys<K> = Exclude<K, ReservedKeys>;\n\ntype FunctionLike = (...args: any) => unknown;\n\ntype MethodLikeKeys<T> = {\n  [K in keyof T]: T[K] extends FunctionLike ? K : never;\n}[keyof T];\n\ntype Promisify<T extends FunctionLike> =\n  ReturnType<T> extends Promise<infer R>\n    ? (...args: Parameters<T>) => Promise<R>\n    : (...args: Parameters<T>) => Promise<ReturnType<T>>;\n\nexport type WorkerModule<T> = {\n  [K in keyof T as Extract<\n    ExcludeReservedKeys<K>,\n    MethodLikeKeys<T>\n  >]: T[K] extends FunctionLike ? Promisify<T[K]> : never;\n};\n\n// Because of the dynamic nature of a worker communication process, all messages\n// coming from any of the other processes cannot be typed. Thus, many types\n// include \"unknown\" as a TS type, which is (unfortunately) correct here.\n\nexport const CHILD_MESSAGE_INITIALIZE = 0;\nexport const CHILD_MESSAGE_CALL = 1;\nexport const CHILD_MESSAGE_END = 2;\nexport const CHILD_MESSAGE_MEM_USAGE = 3;\nexport const CHILD_MESSAGE_CALL_SETUP = 4;\n\nexport const PARENT_MESSAGE_OK = 0;\nexport const PARENT_MESSAGE_CLIENT_ERROR = 1;\nexport const PARENT_MESSAGE_SETUP_ERROR = 2;\nexport const PARENT_MESSAGE_CUSTOM = 3;\nexport const PARENT_MESSAGE_MEM_USAGE = 4;\n\nexport type PARENT_MESSAGE_ERROR =\n  | typeof PARENT_MESSAGE_CLIENT_ERROR\n  | typeof PARENT_MESSAGE_SETUP_ERROR;\n\nexport type WorkerCallback = (\n  workerId: number,\n  request: ChildMessage,\n  onStart: OnStart,\n  onEnd: OnEnd,\n  onCustomMessage: OnCustomMessage,\n) => void;\n\nexport interface WorkerPoolInterface {\n  getStderr(): NodeJS.ReadableStream;\n  getStdout(): NodeJS.ReadableStream;\n  getWorkers(): Array<WorkerInterface>;\n  createWorker(options: WorkerOptions): WorkerInterface;\n  send: WorkerCallback;\n  start(): Promise<void>;\n  end(): Promise<PoolExitResult>;\n}\n\nexport interface WorkerInterface {\n  get state(): WorkerStates;\n\n  send(\n    request: ChildMessage,\n    onProcessStart: OnStart,\n    onProcessEnd: OnEnd,\n    onCustomMessage: OnCustomMessage,\n  ): void;\n\n  waitForExit(): Promise<void>;\n  forceExit(): void;\n\n  getWorkerId(): number;\n  getStderr(): NodeJS.ReadableStream | null;\n  getStdout(): NodeJS.ReadableStream | null;\n  /**\n   * Some system level identifier for the worker. IE, process id, thread id, etc.\n   */\n  getWorkerSystemId(): number;\n  getMemoryUsage(): Promise<number | null>;\n  /**\n   * Checks to see if the child worker is actually running.\n   */\n  isWorkerRunning(): boolean;\n  /**\n   * When the worker child is started and ready to start handling requests.\n   *\n   * @remarks\n   * This mostly exists to help with testing so that you don't check the status\n   * of things like isWorkerRunning before it actually is.\n   */\n  waitForWorkerReady(): Promise<void>;\n}\n\nexport type PoolExitResult = {\n  forceExited: boolean;\n};\n\nexport interface PromiseWithCustomMessage<T> extends Promise<T> {\n  UNSTABLE_onCustomMessage?: (listener: OnCustomMessage) => () => void;\n}\n\n// Option objects.\n\nexport interface TaskQueue {\n  /**\n   * Enqueues the task in the queue for the specified worker or adds it to the\n   * queue shared by all workers\n   * @param task the task to queue\n   * @param workerId the id of the worker that should process this task or undefined\n   * if there's no preference.\n   */\n  enqueue(task: QueueChildMessage, workerId?: number): void;\n\n  /**\n   * Dequeues the next item from the queue for the specified worker\n   * @param workerId the id of the worker for which the next task should be retrieved\n   */\n  dequeue(workerId: number): QueueChildMessage | null;\n}\n\nexport type WorkerSchedulingPolicy = 'round-robin' | 'in-order';\n\nexport type WorkerFarmOptions = {\n  computeWorkerKey?: (method: string, ...args: Array<unknown>) => string | null;\n  enableWorkerThreads?: boolean;\n  exposedMethods?: ReadonlyArray<string>;\n  forkOptions?: ForkOptions;\n  maxRetries?: number;\n  numWorkers?: number;\n  resourceLimits?: ResourceLimits;\n  setupArgs?: Array<unknown>;\n  taskQueue?: TaskQueue;\n  WorkerPool?: new (\n    workerPath: string,\n    options?: WorkerPoolOptions,\n  ) => WorkerPoolInterface;\n  workerSchedulingPolicy?: WorkerSchedulingPolicy;\n  idleMemoryLimit?: number;\n};\n\nexport type WorkerPoolOptions = {\n  setupArgs: Array<unknown>;\n  forkOptions: ForkOptions;\n  resourceLimits: ResourceLimits;\n  maxRetries: number;\n  numWorkers: number;\n  enableWorkerThreads: boolean;\n  idleMemoryLimit?: number;\n};\n\nexport type WorkerOptions = {\n  forkOptions: ForkOptions;\n  resourceLimits: ResourceLimits;\n  setupArgs: Array<unknown>;\n  maxRetries: number;\n  workerId: number;\n  workerData?: unknown;\n  workerPath: string;\n  /**\n   * After a job has executed the memory usage it should return to.\n   *\n   * @remarks\n   * Note this is different from ResourceLimits in that it checks at idle, after\n   * a job is complete. So you could have a resource limit of 500MB but an idle\n   * limit of 50MB. The latter will only trigger if after a job has completed the\n   * memory usage hasn't returned back down under 50MB.\n   *\n   * Special case: setting this to 0 will restart the worker process after each\n   * job completes, providing complete process isolation between test files\n   * regardless of memory usage.\n   */\n  idleMemoryLimit?: number;\n  /**\n   * This mainly exists so the path can be changed during testing.\n   * https://github.com/jestjs/jest/issues/9543\n   */\n  childWorkerPath?: string;\n  /**\n   * This is useful for debugging individual tests allowing you to see\n   * the raw output of the worker.\n   */\n  silent?: boolean;\n  /**\n   * Used to immediately bind event handlers.\n   */\n  on?: {\n    [WorkerEvents.STATE_CHANGE]:\n      | OnStateChangeHandler\n      | ReadonlyArray<OnStateChangeHandler>;\n  };\n};\n\nexport type OnStateChangeHandler = (\n  state: WorkerStates,\n  oldState: WorkerStates,\n) => void;\n\n// Messages passed from the parent to the children.\n\nexport type ChildMessageInitialize = [\n  type: typeof CHILD_MESSAGE_INITIALIZE,\n  isProcessed: boolean,\n  fileName: string,\n  setupArgs: Array<unknown>,\n  workerId: string | undefined,\n];\n\nexport type ChildMessageCall = [\n  type: typeof CHILD_MESSAGE_CALL,\n  isProcessed: boolean,\n  methodName: string,\n  args: Array<unknown>,\n];\n\nexport type ChildMessageEnd = [\n  type: typeof CHILD_MESSAGE_END,\n  isProcessed: boolean,\n];\n\nexport type ChildMessageMemUsage = [type: typeof CHILD_MESSAGE_MEM_USAGE];\n\nexport type ChildMessageCallSetup = [type: typeof CHILD_MESSAGE_CALL_SETUP];\n\nexport type ChildMessage =\n  | ChildMessageInitialize\n  | ChildMessageCall\n  | ChildMessageEnd\n  | ChildMessageMemUsage\n  | ChildMessageCallSetup;\n\n// Messages passed from the children to the parent.\n\nexport type ParentMessageCustom = [\n  type: typeof PARENT_MESSAGE_CUSTOM,\n  result: unknown,\n];\n\nexport type ParentMessageOk = [type: typeof PARENT_MESSAGE_OK, result: unknown];\n\nexport type ParentMessageMemUsage = [\n  type: typeof PARENT_MESSAGE_MEM_USAGE,\n  usedMemory: number,\n];\n\nexport type ParentMessageError = [\n  type: PARENT_MESSAGE_ERROR,\n  constructorName: string,\n  message: string,\n  stack: string,\n  extra: unknown,\n];\n\nexport type ParentMessage =\n  | ParentMessageOk\n  | ParentMessageError\n  | ParentMessageCustom\n  | ParentMessageMemUsage;\n\n// Queue types.\n\nexport type OnStart = (worker: WorkerInterface) => void;\nexport type OnEnd = (err: Error | null, result: unknown) => void;\nexport type OnCustomMessage = (message: Array<unknown> | unknown) => void;\n\nexport type QueueChildMessage = {\n  request: ChildMessageCall;\n  onStart: OnStart;\n  onEnd: OnEnd;\n  onCustomMessage: OnCustomMessage;\n};\n\nexport enum WorkerStates {\n  STARTING = 'starting',\n  OK = 'ok',\n  OUT_OF_MEMORY = 'oom',\n  RESTARTING = 'restarting',\n  SHUTTING_DOWN = 'shutting-down',\n  SHUT_DOWN = 'shut-down',\n}\n\nexport enum WorkerEvents {\n  STATE_CHANGE = 'state-change',\n}\n",
  "packages/jest-worker/src/types.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { ForkOptions } from 'child_process';\nimport type { ResourceLimits } from 'worker_threads';\ntype ReservedKeys = 'end' | 'getStderr' | 'getStdout' | 'setup' | 'teardown';\ntype ExcludeReservedKeys<K> = Exclude<K, ReservedKeys>;\ntype FunctionLike = (...args: any) => unknown;\ntype MethodLikeKeys<T> = {\n    [K in keyof T]: T[K] extends FunctionLike ? K : never;\n}[keyof T];\ntype Promisify<T extends FunctionLike> = ReturnType<T> extends Promise<infer R> ? (...args: Parameters<T>) => Promise<R> : (...args: Parameters<T>) => Promise<ReturnType<T>>;\nexport type WorkerModule<T> = {\n    [K in keyof T as Extract<ExcludeReservedKeys<K>, MethodLikeKeys<T>>]: T[K] extends FunctionLike ? Promisify<T[K]> : never;\n};\nexport declare const CHILD_MESSAGE_INITIALIZE = 0;\nexport declare const CHILD_MESSAGE_CALL = 1;\nexport declare const CHILD_MESSAGE_END = 2;\nexport declare const CHILD_MESSAGE_MEM_USAGE = 3;\nexport declare const CHILD_MESSAGE_CALL_SETUP = 4;\nexport declare const PARENT_MESSAGE_OK = 0;\nexport declare const PARENT_MESSAGE_CLIENT_ERROR = 1;\nexport declare const PARENT_MESSAGE_SETUP_ERROR = 2;\nexport declare const PARENT_MESSAGE_CUSTOM = 3;\nexport declare const PARENT_MESSAGE_MEM_USAGE = 4;\nexport type PARENT_MESSAGE_ERROR = typeof PARENT_MESSAGE_CLIENT_ERROR | typeof PARENT_MESSAGE_SETUP_ERROR;\nexport type WorkerCallback = (workerId: number, request: ChildMessage, onStart: OnStart, onEnd: OnEnd, onCustomMessage: OnCustomMessage) => void;\nexport interface WorkerPoolInterface {\n    getStderr(): NodeJS.ReadableStream;\n    getStdout(): NodeJS.ReadableStream;\n    getWorkers(): Array<WorkerInterface>;\n    createWorker(options: WorkerOptions): WorkerInterface;\n    send: WorkerCallback;\n    start(): Promise<void>;\n    end(): Promise<PoolExitResult>;\n}\nexport interface WorkerInterface {\n    get state(): WorkerStates;\n    send(request: ChildMessage, onProcessStart: OnStart, onProcessEnd: OnEnd, onCustomMessage: OnCustomMessage): void;\n    waitForExit(): Promise<void>;\n    forceExit(): void;\n    getWorkerId(): number;\n    getStderr(): NodeJS.ReadableStream | null;\n    getStdout(): NodeJS.ReadableStream | null;\n    /**\n     * Some system level identifier for the worker. IE, process id, thread id, etc.\n     */\n    getWorkerSystemId(): number;\n    getMemoryUsage(): Promise<number | null>;\n    /**\n     * Checks to see if the child worker is actually running.\n     */\n    isWorkerRunning(): boolean;\n    /**\n     * When the worker child is started and ready to start handling requests.\n     *\n     * @remarks\n     * This mostly exists to help with testing so that you don't check the status\n     * of things like isWorkerRunning before it actually is.\n     */\n    waitForWorkerReady(): Promise<void>;\n}\nexport type PoolExitResult = {\n    forceExited: boolean;\n};\nexport interface PromiseWithCustomMessage<T> extends Promise<T> {\n    UNSTABLE_onCustomMessage?: (listener: OnCustomMessage) => () => void;\n}\nexport interface TaskQueue {\n    /**\n     * Enqueues the task in the queue for the specified worker or adds it to the\n     * queue shared by all workers\n     * @param task the task to queue\n     * @param workerId the id of the worker that should process this task or undefined\n     * if there's no preference.\n     */\n    enqueue(task: QueueChildMessage, workerId?: number): void;\n    /**\n     * Dequeues the next item from the queue for the specified worker\n     * @param workerId the id of the worker for which the next task should be retrieved\n     */\n    dequeue(workerId: number): QueueChildMessage | null;\n}\nexport type WorkerSchedulingPolicy = 'round-robin' | 'in-order';\nexport type WorkerFarmOptions = {\n    computeWorkerKey?: (method: string, ...args: Array<unknown>) => string | null;\n    enableWorkerThreads?: boolean;\n    exposedMethods?: ReadonlyArray<string>;\n    forkOptions?: ForkOptions;\n    maxRetries?: number;\n    numWorkers?: number;\n    resourceLimits?: ResourceLimits;\n    setupArgs?: Array<unknown>;\n    taskQueue?: TaskQueue;\n    WorkerPool?: new (workerPath: string, options?: WorkerPoolOptions) => WorkerPoolInterface;\n    workerSchedulingPolicy?: WorkerSchedulingPolicy;\n    idleMemoryLimit?: number;\n};\nexport type WorkerPoolOptions = {\n    setupArgs: Array<unknown>;\n    forkOptions: ForkOptions;\n    resourceLimits: ResourceLimits;\n    maxRetries: number;\n    numWorkers: number;\n    enableWorkerThreads: boolean;\n    idleMemoryLimit?: number;\n};\nexport type WorkerOptions = {\n    forkOptions: ForkOptions;\n    resourceLimits: ResourceLimits;\n    setupArgs: Array<unknown>;\n    maxRetries: number;\n    workerId: number;\n    workerData?: unknown;\n    workerPath: string;\n    /**\n     * After a job has executed the memory usage it should return to.\n     *\n     * @remarks\n     * Note this is different from ResourceLimits in that it checks at idle, after\n     * a job is complete. So you could have a resource limit of 500MB but an idle\n     * limit of 50MB. The latter will only trigger if after a job has completed the\n     * memory usage hasn't returned back down under 50MB.\n     *\n     * Special case: setting this to 0 will restart the worker process after each\n     * job completes, providing complete process isolation between test files\n     * regardless of memory usage.\n     */\n    idleMemoryLimit?: number;\n    /**\n     * This mainly exists so the path can be changed during testing.\n     * https://github.com/jestjs/jest/issues/9543\n     */\n    childWorkerPath?: string;\n    /**\n     * This is useful for debugging individual tests allowing you to see\n     * the raw output of the worker.\n     */\n    silent?: boolean;\n    /**\n     * Used to immediately bind event handlers.\n     */\n    on?: {\n        [WorkerEvents.STATE_CHANGE]: OnStateChangeHandler | ReadonlyArray<OnStateChangeHandler>;\n    };\n};\nexport type OnStateChangeHandler = (state: WorkerStates, oldState: WorkerStates) => void;\nexport type ChildMessageInitialize = [\n    type: typeof CHILD_MESSAGE_INITIALIZE,\n    isProcessed: boolean,\n    fileName: string,\n    setupArgs: Array<unknown>,\n    workerId: string | undefined\n];\nexport type ChildMessageCall = [\n    type: typeof CHILD_MESSAGE_CALL,\n    isProcessed: boolean,\n    methodName: string,\n    args: Array<unknown>\n];\nexport type ChildMessageEnd = [\n    type: typeof CHILD_MESSAGE_END,\n    isProcessed: boolean\n];\nexport type ChildMessageMemUsage = [type: typeof CHILD_MESSAGE_MEM_USAGE];\nexport type ChildMessageCallSetup = [type: typeof CHILD_MESSAGE_CALL_SETUP];\nexport type ChildMessage = ChildMessageInitialize | ChildMessageCall | ChildMessageEnd | ChildMessageMemUsage | ChildMessageCallSetup;\nexport type ParentMessageCustom = [\n    type: typeof PARENT_MESSAGE_CUSTOM,\n    result: unknown\n];\nexport type ParentMessageOk = [type: typeof PARENT_MESSAGE_OK, result: unknown];\nexport type ParentMessageMemUsage = [\n    type: typeof PARENT_MESSAGE_MEM_USAGE,\n    usedMemory: number\n];\nexport type ParentMessageError = [\n    type: PARENT_MESSAGE_ERROR,\n    constructorName: string,\n    message: string,\n    stack: string,\n    extra: unknown\n];\nexport type ParentMessage = ParentMessageOk | ParentMessageError | ParentMessageCustom | ParentMessageMemUsage;\nexport type OnStart = (worker: WorkerInterface) => void;\nexport type OnEnd = (err: Error | null, result: unknown) => void;\nexport type OnCustomMessage = (message: Array<unknown> | unknown) => void;\nexport type QueueChildMessage = {\n    request: ChildMessageCall;\n    onStart: OnStart;\n    onEnd: OnEnd;\n    onCustomMessage: OnCustomMessage;\n};\nexport declare enum WorkerStates {\n    STARTING = \"starting\",\n    OK = \"ok\",\n    OUT_OF_MEMORY = \"oom\",\n    RESTARTING = \"restarting\",\n    SHUTTING_DOWN = \"shutting-down\",\n    SHUT_DOWN = \"shut-down\"\n}\nexport declare enum WorkerEvents {\n    STATE_CHANGE = \"state-change\"\n}\nexport {};\n",
  "packages/jest-worker/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {availableParallelism} from 'os';\nimport {isAbsolute} from 'path';\nimport {fileURLToPath} from 'url';\nimport Farm from './Farm';\nimport WorkerPool from './WorkerPool';\nimport type {\n  PoolExitResult,\n  WorkerFarmOptions,\n  WorkerModule,\n  WorkerPoolInterface,\n  WorkerPoolOptions,\n} from './types';\n\nexport {default as PriorityQueue} from './PriorityQueue';\nexport {default as FifoQueue} from './FifoQueue';\nexport {default as messageParent} from './workers/messageParent';\n\nexport type {\n  PromiseWithCustomMessage,\n  TaskQueue,\n  WorkerFarmOptions,\n  WorkerPoolInterface,\n  WorkerPoolOptions,\n} from './types';\n\nexport type JestWorkerFarm<T extends Record<string, unknown>> = Worker &\n  WorkerModule<T>;\n\nfunction getExposedMethods(\n  workerPath: string,\n  options: WorkerFarmOptions,\n): ReadonlyArray<string> {\n  let exposedMethods = options.exposedMethods;\n\n  // If no methods list is given, try getting it by auto-requiring the module.\n  if (!exposedMethods) {\n    const module: Record<string, unknown> = require(workerPath);\n\n    exposedMethods = Object.keys(module).filter(\n      name => typeof module[name] === 'function',\n    );\n\n    if (typeof module === 'function') {\n      exposedMethods = [...exposedMethods, 'default'];\n    }\n  }\n\n  return exposedMethods;\n}\n\n/**\n * The Jest farm (publicly called \"Worker\") is a class that allows you to queue\n * methods across multiple child processes, in order to parallelize work. This\n * is done by providing an absolute path to a module that will be loaded on each\n * of the child processes, and bridged to the main process.\n *\n * Bridged methods are specified by using the \"exposedMethods\" property of the\n * \"options\" object. This is an array of strings, where each of them corresponds\n * to the exported name in the loaded module.\n *\n * You can also control the amount of workers by using the \"numWorkers\" property\n * of the \"options\" object, and the settings passed to fork the process through\n * the \"forkOptions\" property. The amount of workers defaults to the amount of\n * CPUS minus one.\n *\n * Queueing calls can be done in two ways:\n *   - Standard method: calls will be redirected to the first available worker,\n *     so they will get executed as soon as they can.\n *\n *   - Sticky method: if a \"computeWorkerKey\" method is provided within the\n *     config, the resulting string of this method will be used as a key.\n *     Every time this key is returned, it is guaranteed that your job will be\n *     processed by the same worker. This is specially useful if your workers\n *     are caching results.\n */\nexport class Worker {\n  private _ending: boolean;\n  private readonly _farm: Farm;\n  private readonly _options: WorkerFarmOptions;\n  private readonly _workerPool: WorkerPoolInterface;\n\n  constructor(workerPath: string | URL, options?: WorkerFarmOptions) {\n    this._options = {...options};\n    this._ending = false;\n\n    if (typeof workerPath !== 'string') {\n      workerPath = workerPath.href;\n    }\n\n    if (workerPath.startsWith('file:')) {\n      workerPath = fileURLToPath(workerPath);\n    } else if (!isAbsolute(workerPath)) {\n      throw new Error(`'workerPath' must be absolute, got '${workerPath}'`);\n    }\n\n    const workerPoolOptions: WorkerPoolOptions = {\n      enableWorkerThreads: this._options.enableWorkerThreads ?? false,\n      forkOptions: this._options.forkOptions ?? {},\n      idleMemoryLimit: this._options.idleMemoryLimit,\n      maxRetries: this._options.maxRetries ?? 3,\n      numWorkers:\n        this._options.numWorkers ?? Math.max(availableParallelism() - 1, 1),\n      resourceLimits: this._options.resourceLimits ?? {},\n      setupArgs: this._options.setupArgs ?? [],\n    };\n\n    if (this._options.WorkerPool) {\n      this._workerPool = new this._options.WorkerPool(\n        workerPath,\n        workerPoolOptions,\n      );\n    } else {\n      this._workerPool = new WorkerPool(workerPath, workerPoolOptions);\n    }\n\n    this._farm = new Farm(\n      workerPoolOptions.numWorkers,\n      this._workerPool.send.bind(this._workerPool),\n      {\n        computeWorkerKey: this._options.computeWorkerKey,\n        taskQueue: this._options.taskQueue,\n        workerSchedulingPolicy: this._options.workerSchedulingPolicy,\n      },\n    );\n\n    this._bindExposedWorkerMethods(workerPath, this._options);\n  }\n\n  private _bindExposedWorkerMethods(\n    workerPath: string,\n    options: WorkerFarmOptions,\n  ): void {\n    for (const name of getExposedMethods(workerPath, options)) {\n      if (name.startsWith('_')) {\n        continue;\n      }\n\n      // eslint-disable-next-line no-prototype-builtins\n      if (this.constructor.prototype.hasOwnProperty(name)) {\n        throw new TypeError(`Cannot define a method called ${name}`);\n      }\n\n      // @ts-expect-error: dynamic extension of the class instance is expected.\n      this[name] = this._callFunctionWithArgs.bind(this, name);\n    }\n  }\n\n  private _callFunctionWithArgs(\n    method: string,\n    ...args: Array<unknown>\n  ): Promise<unknown> {\n    if (this._ending) {\n      throw new Error('Farm is ended, no more calls can be done to it');\n    }\n\n    return this._farm.doWork(method, ...args);\n  }\n\n  getStderr(): NodeJS.ReadableStream {\n    return this._workerPool.getStderr();\n  }\n\n  getStdout(): NodeJS.ReadableStream {\n    return this._workerPool.getStdout();\n  }\n\n  async start(): Promise<void> {\n    await this._workerPool.start();\n  }\n\n  async end(): Promise<PoolExitResult> {\n    if (this._ending) {\n      throw new Error('Farm is ended, no more calls can be done to it');\n    }\n    this._ending = true;\n\n    return this._workerPool.end();\n  }\n}\n",
  "packages/jest-worker/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { PoolExitResult, WorkerFarmOptions, WorkerModule } from './types';\nexport { default as PriorityQueue } from './PriorityQueue';\nexport { default as FifoQueue } from './FifoQueue';\nexport { default as messageParent } from './workers/messageParent';\nexport type { PromiseWithCustomMessage, TaskQueue, WorkerFarmOptions, WorkerPoolInterface, WorkerPoolOptions, } from './types';\nexport type JestWorkerFarm<T extends Record<string, unknown>> = Worker & WorkerModule<T>;\n/**\n * The Jest farm (publicly called \"Worker\") is a class that allows you to queue\n * methods across multiple child processes, in order to parallelize work. This\n * is done by providing an absolute path to a module that will be loaded on each\n * of the child processes, and bridged to the main process.\n *\n * Bridged methods are specified by using the \"exposedMethods\" property of the\n * \"options\" object. This is an array of strings, where each of them corresponds\n * to the exported name in the loaded module.\n *\n * You can also control the amount of workers by using the \"numWorkers\" property\n * of the \"options\" object, and the settings passed to fork the process through\n * the \"forkOptions\" property. The amount of workers defaults to the amount of\n * CPUS minus one.\n *\n * Queueing calls can be done in two ways:\n *   - Standard method: calls will be redirected to the first available worker,\n *     so they will get executed as soon as they can.\n *\n *   - Sticky method: if a \"computeWorkerKey\" method is provided within the\n *     config, the resulting string of this method will be used as a key.\n *     Every time this key is returned, it is guaranteed that your job will be\n *     processed by the same worker. This is specially useful if your workers\n *     are caching results.\n */\nexport declare class Worker {\n    private _ending;\n    private readonly _farm;\n    private readonly _options;\n    private readonly _workerPool;\n    constructor(workerPath: string | URL, options?: WorkerFarmOptions);\n    private _bindExposedWorkerMethods;\n    private _callFunctionWithArgs;\n    getStderr(): NodeJS.ReadableStream;\n    getStdout(): NodeJS.ReadableStream;\n    start(): Promise<void>;\n    end(): Promise<PoolExitResult>;\n}\n",
  "packages/jest-worker/src/WorkerPool.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport BaseWorkerPool from './base/BaseWorkerPool';\nimport type {\n  ChildMessage,\n  OnCustomMessage,\n  OnEnd,\n  OnStart,\n  WorkerInterface,\n  WorkerOptions,\n  WorkerPoolInterface,\n} from './types';\n\nclass WorkerPool extends BaseWorkerPool implements WorkerPoolInterface {\n  send(\n    workerId: number,\n    request: ChildMessage,\n    onStart: OnStart,\n    onEnd: OnEnd,\n    onCustomMessage: OnCustomMessage,\n  ): void {\n    this.restartWorkerIfShutDown(workerId);\n    this.getWorkerById(workerId).send(request, onStart, onEnd, onCustomMessage);\n  }\n\n  override createWorker(workerOptions: WorkerOptions): WorkerInterface {\n    let Worker;\n    if (this._options.enableWorkerThreads) {\n      Worker = require('./workers/NodeThreadsWorker').default;\n    } else {\n      Worker = require('./workers/ChildProcessWorker').default;\n    }\n\n    return new Worker(workerOptions);\n  }\n}\n\nexport default WorkerPool;\n",
  "packages/jest-worker/src/WorkerPool.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport BaseWorkerPool from './base/BaseWorkerPool';\nimport type { ChildMessage, OnCustomMessage, OnEnd, OnStart, WorkerInterface, WorkerOptions, WorkerPoolInterface } from './types';\ndeclare class WorkerPool extends BaseWorkerPool implements WorkerPoolInterface {\n    send(workerId: number, request: ChildMessage, onStart: OnStart, onEnd: OnEnd, onCustomMessage: OnCustomMessage): void;\n    createWorker(workerOptions: WorkerOptions): WorkerInterface;\n}\nexport default WorkerPool;\n",
  "packages/jest-worker/src/PriorityQueue.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {QueueChildMessage, TaskQueue} from './types';\n\nexport type ComputeTaskPriorityCallback = (\n  method: string,\n  ...args: Array<unknown>\n) => number;\n\ntype QueueItem = {\n  task: QueueChildMessage;\n  priority: number;\n};\n\n/**\n * Priority queue that processes tasks in natural ordering (lower priority first)\n * according to the priority computed by the function passed in the constructor.\n *\n * FIFO ordering isn't guaranteed for tasks with the same priority.\n *\n * Worker specific tasks with the same priority as a non-worker specific task\n * are always processed first.\n */\nexport default class PriorityQueue implements TaskQueue {\n  private _queue: Array<MinHeap<QueueItem>> = [];\n  private readonly _sharedQueue = new MinHeap<QueueItem>();\n\n  constructor(private readonly _computePriority: ComputeTaskPriorityCallback) {}\n\n  enqueue(task: QueueChildMessage, workerId?: number): void {\n    if (workerId == null) {\n      this._enqueue(task, this._sharedQueue);\n    } else {\n      const queue = this._getWorkerQueue(workerId);\n      this._enqueue(task, queue);\n    }\n  }\n\n  _enqueue(task: QueueChildMessage, queue: MinHeap<QueueItem>): void {\n    const item = {\n      priority: this._computePriority(task.request[2], ...task.request[3]),\n      task,\n    };\n\n    queue.add(item);\n  }\n\n  dequeue(workerId: number): QueueChildMessage | null {\n    const workerQueue = this._getWorkerQueue(workerId);\n\n    const workerTop = workerQueue.peek();\n    const sharedTop = this._sharedQueue.peek();\n\n    // use the task from the worker queue if there's no task in the shared queue\n    // or if the priority of the worker queue is smaller or equal to the\n    // priority of the top task in the shared queue. The tasks of the\n    // worker specific queue are preferred because no other worker can pick this\n    // specific task up.\n    if (\n      sharedTop == null ||\n      (workerTop != null && workerTop.priority <= sharedTop.priority)\n    ) {\n      return workerQueue.poll()?.task ?? null;\n    }\n\n    return this._sharedQueue.poll()!.task;\n  }\n\n  _getWorkerQueue(workerId: number): MinHeap<QueueItem> {\n    let queue = this._queue[workerId];\n    if (queue == null) {\n      queue = this._queue[workerId] = new MinHeap();\n    }\n\n    return queue;\n  }\n}\n\ntype HeapItem = {\n  priority: number;\n};\n\nclass MinHeap<TItem extends HeapItem> {\n  private readonly _heap: Array<TItem | null> = [];\n\n  peek(): TItem | null {\n    return this._heap[0] ?? null;\n  }\n\n  add(item: TItem): void {\n    const nodes = this._heap;\n    nodes.push(item);\n\n    if (nodes.length === 1) {\n      return;\n    }\n\n    let currentIndex = nodes.length - 1;\n\n    // Bubble up the added node as long as the parent is bigger\n    while (currentIndex > 0) {\n      const parentIndex = Math.floor((currentIndex + 1) / 2) - 1;\n      const parent = nodes[parentIndex]!;\n\n      if (parent.priority <= item.priority) {\n        break;\n      }\n\n      nodes[currentIndex] = parent;\n      nodes[parentIndex] = item;\n\n      currentIndex = parentIndex;\n    }\n  }\n\n  poll(): TItem | null {\n    const nodes = this._heap;\n    const result = nodes[0];\n\n    const lastElement = nodes.pop();\n\n    // heap was empty or removed the last element\n    if (result == null || nodes.length === 0) {\n      return result ?? null;\n    }\n\n    let index = 0;\n    nodes[0] = lastElement ?? null;\n    const element = nodes[0]!;\n\n    while (true) {\n      let swapIndex = null;\n      const rightChildIndex = (index + 1) * 2;\n      const leftChildIndex = rightChildIndex - 1;\n      const rightChild = nodes[rightChildIndex];\n      const leftChild = nodes[leftChildIndex];\n\n      // if the left child is smaller, swap with the left\n      if (leftChild != null && leftChild.priority < element.priority) {\n        swapIndex = leftChildIndex;\n      }\n\n      // If the right child is smaller or the right child is smaller than the left\n      // then swap with the right child\n      if (\n        rightChild != null &&\n        rightChild.priority <\n          (swapIndex == null ? element : leftChild!).priority\n      ) {\n        swapIndex = rightChildIndex;\n      }\n\n      if (swapIndex == null) {\n        break;\n      }\n\n      nodes[index] = nodes[swapIndex];\n      nodes[swapIndex] = element;\n\n      index = swapIndex;\n    }\n\n    return result;\n  }\n}\n",
  "packages/jest-worker/src/PriorityQueue.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { QueueChildMessage, TaskQueue } from './types';\nexport type ComputeTaskPriorityCallback = (method: string, ...args: Array<unknown>) => number;\ntype QueueItem = {\n    task: QueueChildMessage;\n    priority: number;\n};\n/**\n * Priority queue that processes tasks in natural ordering (lower priority first)\n * according to the priority computed by the function passed in the constructor.\n *\n * FIFO ordering isn't guaranteed for tasks with the same priority.\n *\n * Worker specific tasks with the same priority as a non-worker specific task\n * are always processed first.\n */\nexport default class PriorityQueue implements TaskQueue {\n    private readonly _computePriority;\n    private _queue;\n    private readonly _sharedQueue;\n    constructor(_computePriority: ComputeTaskPriorityCallback);\n    enqueue(task: QueueChildMessage, workerId?: number): void;\n    _enqueue(task: QueueChildMessage, queue: MinHeap<QueueItem>): void;\n    dequeue(workerId: number): QueueChildMessage | null;\n    _getWorkerQueue(workerId: number): MinHeap<QueueItem>;\n}\ntype HeapItem = {\n    priority: number;\n};\ndeclare class MinHeap<TItem extends HeapItem> {\n    private readonly _heap;\n    peek(): TItem | null;\n    add(item: TItem): void;\n    poll(): TItem | null;\n}\nexport {};\n",
  "packages/jest-worker/src/FifoQueue.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {QueueChildMessage, TaskQueue} from './types';\n\ntype WorkerQueueValue = {\n  task: QueueChildMessage;\n\n  /**\n   * The task that was at the top of the shared queue at the time this\n   * worker specific task was enqueued. Required to maintain FIFO ordering\n   * across queues. The worker specific task should only be dequeued if the\n   * previous shared task is null or has been processed.\n   */\n  previousSharedTask: QueueChildMessage | null;\n};\n\n/**\n * First-in, First-out task queue that manages a dedicated pool\n * for each worker as well as a shared queue. The FIFO ordering is guaranteed\n * across the worker specific and shared queue.\n */\nexport default class FifoQueue implements TaskQueue {\n  private _workerQueues: Array<InternalQueue<WorkerQueueValue> | undefined> =\n    [];\n  private readonly _sharedQueue = new InternalQueue<QueueChildMessage>();\n\n  enqueue(task: QueueChildMessage, workerId?: number): void {\n    if (workerId == null) {\n      this._sharedQueue.enqueue(task);\n      return;\n    }\n\n    let workerQueue = this._workerQueues[workerId];\n    if (workerQueue == null) {\n      workerQueue = this._workerQueues[workerId] =\n        new InternalQueue<WorkerQueueValue>();\n    }\n\n    const sharedTop = this._sharedQueue.peekLast();\n    const item = {previousSharedTask: sharedTop, task};\n\n    workerQueue.enqueue(item);\n  }\n\n  dequeue(workerId: number): QueueChildMessage | null {\n    const workerTop = this._workerQueues[workerId]?.peek();\n    const sharedTaskIsProcessed =\n      workerTop?.previousSharedTask?.request[1] ?? true;\n\n    // Process the top task from the shared queue if\n    // - there's no task in the worker specific queue or\n    // - if the non-worker-specific task after which this worker specific task\n    //   has been queued wasn't processed yet\n    if (workerTop != null && sharedTaskIsProcessed) {\n      return this._workerQueues[workerId]?.dequeue()?.task ?? null;\n    }\n\n    return this._sharedQueue.dequeue();\n  }\n}\n\ntype QueueItem<TValue> = {\n  value: TValue;\n  next: QueueItem<TValue> | null;\n};\n\n/**\n * FIFO queue for a single worker / shared queue.\n */\nclass InternalQueue<TValue> {\n  private _head: QueueItem<TValue> | null = null;\n  private _last: QueueItem<TValue> | null = null;\n\n  enqueue(value: TValue): void {\n    const item = {next: null, value};\n\n    if (this._last == null) {\n      this._head = item;\n    } else {\n      this._last.next = item;\n    }\n\n    this._last = item;\n  }\n\n  dequeue(): TValue | null {\n    if (this._head == null) {\n      return null;\n    }\n\n    const item = this._head;\n    this._head = item.next;\n\n    if (this._head == null) {\n      this._last = null;\n    }\n\n    return item.value;\n  }\n\n  peek(): TValue | null {\n    return this._head?.value ?? null;\n  }\n\n  peekLast(): TValue | null {\n    return this._last?.value ?? null;\n  }\n}\n",
  "packages/jest-worker/src/FifoQueue.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { QueueChildMessage, TaskQueue } from './types';\n/**\n * First-in, First-out task queue that manages a dedicated pool\n * for each worker as well as a shared queue. The FIFO ordering is guaranteed\n * across the worker specific and shared queue.\n */\nexport default class FifoQueue implements TaskQueue {\n    private _workerQueues;\n    private readonly _sharedQueue;\n    enqueue(task: QueueChildMessage, workerId?: number): void;\n    dequeue(workerId: number): QueueChildMessage | null;\n}\n",
  "packages/jest-worker/src/Farm.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport FifoQueue from './FifoQueue';\nimport {\n  CHILD_MESSAGE_CALL,\n  type ChildMessage,\n  type OnCustomMessage,\n  type OnEnd,\n  type OnStart,\n  type PromiseWithCustomMessage,\n  type QueueChildMessage,\n  type TaskQueue,\n  type WorkerCallback,\n  type WorkerFarmOptions,\n  type WorkerInterface,\n  type WorkerSchedulingPolicy,\n} from './types';\n\nexport default class Farm {\n  private readonly _computeWorkerKey: WorkerFarmOptions['computeWorkerKey'];\n  private readonly _workerSchedulingPolicy: WorkerSchedulingPolicy;\n  private readonly _cacheKeys: Record<string, WorkerInterface> =\n    Object.create(null);\n  private readonly _locks: Array<boolean> = [];\n  private _offset = 0;\n  private readonly _taskQueue: TaskQueue;\n\n  constructor(\n    private readonly _numOfWorkers: number,\n    private readonly _callback: WorkerCallback,\n    options: WorkerFarmOptions = {},\n  ) {\n    this._computeWorkerKey = options.computeWorkerKey;\n    this._workerSchedulingPolicy =\n      options.workerSchedulingPolicy ?? 'round-robin';\n    this._taskQueue = options.taskQueue ?? new FifoQueue();\n  }\n\n  doWork(\n    method: string,\n    ...args: Array<unknown>\n  ): PromiseWithCustomMessage<unknown> {\n    const customMessageListeners = new Set<OnCustomMessage>();\n\n    const addCustomMessageListener = (listener: OnCustomMessage) => {\n      customMessageListeners.add(listener);\n      return () => {\n        customMessageListeners.delete(listener);\n      };\n    };\n\n    const onCustomMessage: OnCustomMessage = message => {\n      for (const listener of customMessageListeners) listener(message);\n    };\n\n    const promise: PromiseWithCustomMessage<unknown> = new Promise(\n      // Bind args to this function so it won't reference to the parent scope.\n      // This prevents a memory leak in v8, because otherwise the function will\n      // retain args for the closure.\n      ((\n        args: Array<unknown>,\n        resolve: (value: unknown) => void,\n        reject: (reason?: any) => void,\n      ) => {\n        const computeWorkerKey = this._computeWorkerKey;\n        const request: ChildMessage = [CHILD_MESSAGE_CALL, false, method, args];\n\n        let worker: WorkerInterface | null = null;\n        let hash: string | null = null;\n\n        if (computeWorkerKey) {\n          hash = computeWorkerKey.call(this, method, ...args);\n          worker = hash == null ? null : this._cacheKeys[hash];\n        }\n\n        const onStart: OnStart = (worker: WorkerInterface) => {\n          if (hash != null) {\n            this._cacheKeys[hash] = worker;\n          }\n        };\n\n        const onEnd: OnEnd = (error: Error | null, result: unknown) => {\n          customMessageListeners.clear();\n          if (error) {\n            reject(error);\n          } else {\n            resolve(result);\n          }\n        };\n\n        const task = {onCustomMessage, onEnd, onStart, request};\n\n        if (worker) {\n          this._taskQueue.enqueue(task, worker.getWorkerId());\n          this._process(worker.getWorkerId());\n        } else {\n          this._push(task);\n        }\n      }).bind(null, args),\n    );\n\n    promise.UNSTABLE_onCustomMessage = addCustomMessageListener;\n\n    return promise;\n  }\n\n  private _process(workerId: number): Farm {\n    if (this._isLocked(workerId)) {\n      return this;\n    }\n\n    const task = this._taskQueue.dequeue(workerId);\n\n    if (!task) {\n      return this;\n    }\n\n    if (task.request[1]) {\n      throw new Error('Queue implementation returned processed task');\n    }\n\n    // Reference the task object outside so it won't be retained by onEnd,\n    // and other properties of the task object, such as task.request can be\n    // garbage collected.\n    let taskOnEnd: OnEnd | null = task.onEnd;\n    const onEnd: OnEnd = (error, result) => {\n      if (taskOnEnd) {\n        taskOnEnd(error, result);\n      }\n      taskOnEnd = null;\n\n      this._unlock(workerId);\n      this._process(workerId);\n    };\n\n    task.request[1] = true;\n\n    this._lock(workerId);\n    this._callback(\n      workerId,\n      task.request,\n      task.onStart,\n      onEnd,\n      task.onCustomMessage,\n    );\n\n    return this;\n  }\n\n  private _push(task: QueueChildMessage): Farm {\n    this._taskQueue.enqueue(task);\n\n    const offset = this._getNextWorkerOffset();\n    for (let i = 0; i < this._numOfWorkers; i++) {\n      this._process((offset + i) % this._numOfWorkers);\n\n      if (task.request[1]) {\n        break;\n      }\n    }\n\n    return this;\n  }\n\n  private _getNextWorkerOffset(): number {\n    switch (this._workerSchedulingPolicy) {\n      case 'in-order':\n        return 0;\n      case 'round-robin':\n        return this._offset++;\n    }\n  }\n\n  private _lock(workerId: number): void {\n    this._locks[workerId] = true;\n  }\n\n  private _unlock(workerId: number): void {\n    this._locks[workerId] = false;\n  }\n\n  private _isLocked(workerId: number): boolean {\n    return this._locks[workerId];\n  }\n}\n",
  "packages/jest-worker/src/Farm.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { type PromiseWithCustomMessage, type WorkerCallback, type WorkerFarmOptions } from './types';\nexport default class Farm {\n    private readonly _numOfWorkers;\n    private readonly _callback;\n    private readonly _computeWorkerKey;\n    private readonly _workerSchedulingPolicy;\n    private readonly _cacheKeys;\n    private readonly _locks;\n    private _offset;\n    private readonly _taskQueue;\n    constructor(_numOfWorkers: number, _callback: WorkerCallback, options?: WorkerFarmOptions);\n    doWork(method: string, ...args: Array<unknown>): PromiseWithCustomMessage<unknown>;\n    private _process;\n    private _push;\n    private _getNextWorkerOffset;\n    private _lock;\n    private _unlock;\n    private _isLocked;\n}\n",
  "packages/jest-worker/src/workers/threadChild.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {isMainThread, parentPort} from 'worker_threads';\nimport {isPromise} from 'jest-util';\nimport {\n  CHILD_MESSAGE_CALL,\n  CHILD_MESSAGE_CALL_SETUP,\n  CHILD_MESSAGE_END,\n  CHILD_MESSAGE_INITIALIZE,\n  CHILD_MESSAGE_MEM_USAGE,\n  type ChildMessageCall,\n  type ChildMessageInitialize,\n  PARENT_MESSAGE_CLIENT_ERROR,\n  type PARENT_MESSAGE_ERROR,\n  PARENT_MESSAGE_MEM_USAGE,\n  PARENT_MESSAGE_OK,\n  PARENT_MESSAGE_SETUP_ERROR,\n  type ParentMessageMemUsage,\n} from '../types';\nimport {isDataCloneError} from './isDataCloneError';\nimport {packMessage} from './safeMessageTransferring';\n\ntype UnknownFunction = (...args: Array<unknown>) => unknown | Promise<unknown>;\n\nlet file: string | null = null;\nlet setupArgs: Array<unknown> = [];\nlet initialized = false;\n\n/**\n * This file is a small bootstrapper for workers. It sets up the communication\n * between the worker and the parent process, interpreting parent messages and\n * sending results back.\n *\n * The file loaded will be lazily initialized the first time any of the workers\n * is called. This is done for optimal performance: if the farm is initialized,\n * but no call is made to it, child Node processes will be consuming the least\n * possible amount of memory.\n *\n * If an invalid message is detected, the child will exit (by throwing) with a\n * non-zero exit code.\n */\nconst messageListener = (request: any) => {\n  switch (request[0]) {\n    case CHILD_MESSAGE_INITIALIZE:\n      const init: ChildMessageInitialize = request;\n      file = init[2];\n      setupArgs = init[3];\n      process.env.JEST_WORKER_ID = init[4];\n      break;\n\n    case CHILD_MESSAGE_CALL:\n      const call: ChildMessageCall = request;\n      execMethod(call[2], call[3]);\n      break;\n\n    case CHILD_MESSAGE_END:\n      end();\n      break;\n\n    case CHILD_MESSAGE_MEM_USAGE:\n      reportMemoryUsage();\n      break;\n\n    case CHILD_MESSAGE_CALL_SETUP:\n      if (initialized) {\n        reportSuccess(void 0);\n      } else {\n        const main = require(file!);\n\n        initialized = true;\n\n        if (main.setup) {\n          execFunction(\n            main.setup,\n            main,\n            setupArgs,\n            reportSuccess,\n            reportInitializeError,\n          );\n        } else {\n          reportSuccess(void 0);\n        }\n      }\n      break;\n\n    default:\n      throw new TypeError(\n        `Unexpected request from parent process: ${request[0]}`,\n      );\n  }\n};\nparentPort!.on('message', messageListener);\n\nfunction reportMemoryUsage() {\n  if (isMainThread) {\n    throw new Error('Child can only be used on a forked process');\n  }\n\n  const msg: ParentMessageMemUsage = [\n    PARENT_MESSAGE_MEM_USAGE,\n    process.memoryUsage().heapUsed,\n  ];\n\n  parentPort!.postMessage(msg);\n}\n\nfunction reportSuccess(result: unknown) {\n  if (isMainThread) {\n    throw new Error('Child can only be used on a forked process');\n  }\n\n  try {\n    parentPort!.postMessage([PARENT_MESSAGE_OK, result]);\n  } catch (error) {\n    let resolvedError = error;\n    // Try to handle https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal\n    // for `symbols` and `functions`\n    if (isDataCloneError(error)) {\n      try {\n        parentPort!.postMessage([PARENT_MESSAGE_OK, packMessage(result)]);\n        return;\n      } catch (secondTryError) {\n        resolvedError = secondTryError;\n      }\n    }\n    // Handling it here to avoid unhandled rejection\n    // which is hard to distinguish on the parent side\n    reportClientError(resolvedError as Error);\n  }\n}\n\nfunction reportClientError(error: Error) {\n  return reportError(error, PARENT_MESSAGE_CLIENT_ERROR);\n}\n\nfunction reportInitializeError(error: Error) {\n  return reportError(error, PARENT_MESSAGE_SETUP_ERROR);\n}\n\nfunction reportError(error: Error, type: PARENT_MESSAGE_ERROR) {\n  if (isMainThread) {\n    throw new Error('Child can only be used on a forked process');\n  }\n\n  if (error == null) {\n    error = new Error('\"null\" or \"undefined\" thrown');\n  }\n\n  parentPort!.postMessage([\n    type,\n    error.constructor && error.constructor.name,\n    error.message,\n    error.stack,\n    typeof error === 'object' ? {...error} : error,\n  ]);\n}\n\nfunction end(): void {\n  const main = require(file!);\n\n  if (!main.teardown) {\n    exitProcess();\n\n    return;\n  }\n\n  execFunction(main.teardown, main, [], exitProcess, exitProcess);\n}\n\nfunction exitProcess(): void {\n  // Clean up open handles so the worker ideally exits gracefully\n  parentPort!.removeListener('message', messageListener);\n}\n\nfunction execMethod(method: string, args: Array<unknown>): void {\n  const main = require(file!);\n\n  let fn: UnknownFunction;\n\n  if (method === 'default') {\n    fn = main.__esModule ? main.default : main;\n  } else {\n    fn = main[method];\n  }\n\n  function execHelper() {\n    execFunction(fn, main, args, reportSuccess, reportClientError);\n  }\n\n  if (initialized || !main.setup) {\n    execHelper();\n\n    return;\n  }\n\n  initialized = true;\n\n  execFunction(main.setup, main, setupArgs, execHelper, reportInitializeError);\n}\n\nfunction execFunction(\n  fn: UnknownFunction,\n  ctx: unknown,\n  args: Array<unknown>,\n  onResult: (result: unknown) => void,\n  onError: (error: Error) => void,\n): void {\n  let result: unknown;\n\n  try {\n    result = fn.apply(ctx, args);\n  } catch (error: any) {\n    onError(error);\n\n    return;\n  }\n\n  if (isPromise(result)) {\n    result.then(onResult, onError);\n  } else {\n    onResult(result);\n  }\n}\n",
  "packages/jest-worker/src/workers/threadChild.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-worker/src/workers/safeMessageTransferring.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {\n  type SerializedRecord,\n  deserialize,\n  serialize,\n} from '@ungap/structured-clone';\n\ntype TransferringContainer = {\n  __STRUCTURED_CLONE_SERIALIZED__: true;\n  data: SerializedRecord;\n};\n\nexport function packMessage(message: unknown): TransferringContainer {\n  return {\n    __STRUCTURED_CLONE_SERIALIZED__: true,\n    /**\n     * Use the `json: true` option to avoid errors\n     * caused by `function` or `symbol` types.\n     * It's not ideal to lose `function` and `symbol` types,\n     * but reliability is more important.\n     */\n    data: serialize(message, {json: true}),\n  };\n}\n\nfunction isTransferringContainer(\n  message: unknown,\n): message is TransferringContainer {\n  return (\n    message != null &&\n    typeof message === 'object' &&\n    '__STRUCTURED_CLONE_SERIALIZED__' in message &&\n    'data' in message\n  );\n}\n\nexport function unpackMessage(message: unknown): unknown {\n  if (isTransferringContainer(message)) {\n    return deserialize(message.data);\n  }\n  return message;\n}\n",
  "packages/jest-worker/src/workers/safeMessageTransferring.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { type SerializedRecord } from '@ungap/structured-clone';\ntype TransferringContainer = {\n    __STRUCTURED_CLONE_SERIALIZED__: true;\n    data: SerializedRecord;\n};\nexport declare function packMessage(message: unknown): TransferringContainer;\nexport declare function unpackMessage(message: unknown): unknown;\nexport {};\n",
  "packages/jest-worker/src/workers/processChild.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {types} from 'node:util';\nimport {isPromise} from 'jest-util';\nimport {\n  CHILD_MESSAGE_CALL,\n  CHILD_MESSAGE_CALL_SETUP,\n  CHILD_MESSAGE_END,\n  CHILD_MESSAGE_INITIALIZE,\n  CHILD_MESSAGE_MEM_USAGE,\n  type ChildMessageCall,\n  type ChildMessageInitialize,\n  PARENT_MESSAGE_CLIENT_ERROR,\n  type PARENT_MESSAGE_ERROR,\n  PARENT_MESSAGE_MEM_USAGE,\n  PARENT_MESSAGE_OK,\n  PARENT_MESSAGE_SETUP_ERROR,\n  type ParentMessageMemUsage,\n} from '../types';\nimport {packMessage} from './safeMessageTransferring';\n\ntype UnknownFunction = (...args: Array<unknown>) => unknown | Promise<unknown>;\n\nlet file: string | null = null;\nlet setupArgs: Array<unknown> = [];\nlet initialized = false;\n\n/**\n * This file is a small bootstrapper for workers. It sets up the communication\n * between the worker and the parent process, interpreting parent messages and\n * sending results back.\n *\n * The file loaded will be lazily initialized the first time any of the workers\n * is called. This is done for optimal performance: if the farm is initialized,\n * but no call is made to it, child Node processes will be consuming the least\n * possible amount of memory.\n *\n * If an invalid message is detected, the child will exit (by throwing) with a\n * non-zero exit code.\n */\nconst messageListener: NodeJS.MessageListener = (request: any) => {\n  switch (request[0]) {\n    case CHILD_MESSAGE_INITIALIZE:\n      const init: ChildMessageInitialize = request;\n      file = init[2];\n      setupArgs = init[3];\n      break;\n\n    case CHILD_MESSAGE_CALL:\n      const call: ChildMessageCall = request;\n      execMethod(call[2], call[3]);\n      break;\n\n    case CHILD_MESSAGE_END:\n      end();\n      break;\n\n    case CHILD_MESSAGE_MEM_USAGE:\n      reportMemoryUsage();\n      break;\n\n    case CHILD_MESSAGE_CALL_SETUP:\n      if (initialized) {\n        reportSuccess(void 0);\n      } else {\n        const main = require(file!);\n\n        initialized = true;\n\n        if (main.setup) {\n          execFunction(\n            main.setup,\n            main,\n            setupArgs,\n            reportSuccess,\n            reportInitializeError,\n          );\n        } else {\n          reportSuccess(void 0);\n        }\n      }\n      break;\n\n    default:\n      throw new TypeError(\n        `Unexpected request from parent process: ${request[0]}`,\n      );\n  }\n};\nprocess.on('message', messageListener);\n\nfunction reportSuccess(result: unknown) {\n  if (!process || !process.send) {\n    throw new Error('Child can only be used on a forked process');\n  }\n\n  try {\n    process.send([PARENT_MESSAGE_OK, result]);\n  } catch (error) {\n    if (\n      types.isNativeError(error) &&\n      // if .send is a function, it's a serialization issue\n      !error.message.includes('.send is not a function')\n    ) {\n      // Apply specific serialization only in error cases\n      // to avoid affecting performance in regular cases.\n      process.send([PARENT_MESSAGE_OK, packMessage(result)]);\n    } else {\n      throw error;\n    }\n  }\n}\n\nfunction reportClientError(error: Error) {\n  return reportError(error, PARENT_MESSAGE_CLIENT_ERROR);\n}\n\nfunction reportInitializeError(error: Error) {\n  return reportError(error, PARENT_MESSAGE_SETUP_ERROR);\n}\n\nfunction reportMemoryUsage() {\n  if (!process || !process.send) {\n    throw new Error('Child can only be used on a forked process');\n  }\n\n  const msg: ParentMessageMemUsage = [\n    PARENT_MESSAGE_MEM_USAGE,\n    process.memoryUsage().heapUsed,\n  ];\n\n  process.send(msg);\n}\n\nfunction reportError(error: Error, type: PARENT_MESSAGE_ERROR) {\n  if (!process || !process.send) {\n    throw new Error('Child can only be used on a forked process');\n  }\n\n  if (error == null) {\n    error = new Error('\"null\" or \"undefined\" thrown');\n  }\n\n  process.send([\n    type,\n    error.constructor && error.constructor.name,\n    error.message,\n    error.stack,\n    typeof error === 'object' ? {...error} : error,\n  ]);\n}\n\nfunction end(): void {\n  const main = require(file!);\n\n  if (!main.teardown) {\n    exitProcess();\n\n    return;\n  }\n\n  execFunction(main.teardown, main, [], exitProcess, exitProcess);\n}\n\nfunction exitProcess(): void {\n  // Clean up open handles so the process ideally exits gracefully\n  process.removeListener('message', messageListener);\n}\n\nfunction execMethod(method: string, args: Array<unknown>): void {\n  const main = require(file!);\n\n  let fn: UnknownFunction;\n\n  if (method === 'default') {\n    fn = main.__esModule ? main.default : main;\n  } else {\n    fn = main[method];\n  }\n\n  function execHelper() {\n    execFunction(fn, main, args, reportSuccess, reportClientError);\n  }\n\n  if (initialized || !main.setup) {\n    execHelper();\n\n    return;\n  }\n\n  initialized = true;\n\n  execFunction(main.setup, main, setupArgs, execHelper, reportInitializeError);\n}\n\nfunction execFunction(\n  fn: UnknownFunction,\n  ctx: unknown,\n  args: Array<unknown>,\n  onResult: (result: unknown) => void,\n  onError: (error: Error) => void,\n): void {\n  let result: unknown;\n\n  try {\n    result = fn.apply(ctx, args);\n  } catch (error: any) {\n    onError(error);\n\n    return;\n  }\n\n  if (isPromise(result)) {\n    result.then(onResult, onError);\n  } else {\n    onResult(result);\n  }\n}\n",
  "packages/jest-worker/src/workers/processChild.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-worker/src/workers/messageParent.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {types} from 'node:util';\nimport {isMainThread, parentPort} from 'worker_threads';\nimport {PARENT_MESSAGE_CUSTOM} from '../types';\nimport {isDataCloneError} from './isDataCloneError';\nimport {packMessage} from './safeMessageTransferring';\n\nexport default function messageParent(\n  message: unknown,\n  parentProcess = process,\n): void {\n  if (!isMainThread && parentPort != null) {\n    try {\n      parentPort.postMessage([PARENT_MESSAGE_CUSTOM, message]);\n    } catch (error) {\n      // Try to handle https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal\n      // for `symbols` and `functions`\n      if (isDataCloneError(error)) {\n        parentPort.postMessage([PARENT_MESSAGE_CUSTOM, packMessage(message)]);\n      } else {\n        throw error;\n      }\n    }\n  } else if (typeof parentProcess.send === 'function') {\n    try {\n      parentProcess.send([PARENT_MESSAGE_CUSTOM, message]);\n    } catch (error) {\n      if (\n        types.isNativeError(error) &&\n        // if .send is a function, it's a serialization issue\n        !error.message.includes('.send is not a function')\n      ) {\n        // Apply specific serialization only in error cases\n        // to avoid affecting performance in regular cases.\n        parentProcess.send([PARENT_MESSAGE_CUSTOM, packMessage(message)]);\n      } else {\n        throw error;\n      }\n    }\n  } else {\n    throw new TypeError('\"messageParent\" can only be used inside a worker');\n  }\n}\n",
  "packages/jest-worker/src/workers/messageParent.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport default function messageParent(message: unknown, parentProcess?: NodeJS.Process): void;\n",
  "packages/jest-worker/src/workers/isDataCloneError.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// https://webidl.spec.whatwg.org/#datacloneerror\nconst DATA_CLONE_ERROR_CODE = 25;\n\n/**\n * Unfortunately, [`util.types.isNativeError(value)`](https://nodejs.org/api/util.html#utiltypesisnativeerrorvalue)\n * return `false` for `DataCloneError` error.\n * For this reason, try to detect it in this way\n */\nexport function isDataCloneError(error: unknown): error is DOMException {\n  return (\n    error != null &&\n    typeof error === 'object' &&\n    'name' in error &&\n    error.name === 'DataCloneError' &&\n    'message' in error &&\n    typeof error.message === 'string' &&\n    'code' in error &&\n    error.code === DATA_CLONE_ERROR_CODE\n  );\n}\n",
  "packages/jest-worker/src/workers/isDataCloneError.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n/**\n * Unfortunately, [`util.types.isNativeError(value)`](https://nodejs.org/api/util.html#utiltypesisnativeerrorvalue)\n * return `false` for `DataCloneError` error.\n * For this reason, try to detect it in this way\n */\nexport declare function isDataCloneError(error: unknown): error is DOMException;\n",
  "packages/jest-worker/src/workers/WorkerAbstract.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {EventEmitter, PassThrough} from 'stream';\nimport {\n  WorkerEvents,\n  type WorkerInterface,\n  type WorkerOptions,\n  WorkerStates,\n} from '../types';\n\nexport default abstract class WorkerAbstract\n  extends EventEmitter\n  implements Pick<WorkerInterface, 'waitForWorkerReady' | 'state'>\n{\n  /**\n   * DO NOT WRITE TO THIS DIRECTLY.\n   * Use this.state getter/setters so events are emitted correctly.\n   */\n  #state = WorkerStates.STARTING;\n\n  protected _fakeStream: PassThrough | null = null;\n\n  protected _exitPromise: Promise<void>;\n  protected _resolveExitPromise!: () => void;\n\n  protected _workerReadyPromise: Promise<void> | undefined;\n  protected _resolveWorkerReady: (() => void) | undefined;\n\n  public get state(): WorkerStates {\n    return this.#state;\n  }\n  protected set state(value: WorkerStates) {\n    if (this.#state !== value) {\n      const oldState = this.#state;\n      this.#state = value;\n\n      this.emit(WorkerEvents.STATE_CHANGE, value, oldState);\n    }\n  }\n\n  constructor(options: WorkerOptions) {\n    super();\n\n    if (typeof options.on === 'object') {\n      for (const [event, handlers] of Object.entries(options.on)) {\n        // Can't do Array.isArray on a ReadonlyArray<T>.\n        // https://github.com/microsoft/TypeScript/issues/17002\n        if (typeof handlers === 'function') {\n          super.on(event, handlers);\n        } else {\n          for (const handler of handlers) {\n            super.on(event, handler);\n          }\n        }\n      }\n    }\n\n    this._exitPromise = new Promise(resolve => {\n      this._resolveExitPromise = resolve;\n    });\n    this._exitPromise.then(() => {\n      this.state = WorkerStates.SHUT_DOWN;\n    });\n  }\n\n  /**\n   * Wait for the worker child process to be ready to handle requests.\n   *\n   * @returns Promise which resolves when ready.\n   */\n  public waitForWorkerReady(): Promise<void> {\n    if (!this._workerReadyPromise) {\n      this._workerReadyPromise = new Promise((resolve, reject) => {\n        let settled = false;\n        let to: NodeJS.Timeout | undefined;\n\n        switch (this.state) {\n          case WorkerStates.OUT_OF_MEMORY:\n          case WorkerStates.SHUTTING_DOWN:\n          case WorkerStates.SHUT_DOWN:\n            settled = true;\n            reject(\n              new Error(\n                `Worker state means it will never be ready: ${this.state}`,\n              ),\n            );\n            break;\n          case WorkerStates.STARTING:\n          case WorkerStates.RESTARTING:\n            this._resolveWorkerReady = () => {\n              settled = true;\n              resolve();\n\n              if (to) {\n                clearTimeout(to);\n              }\n            };\n            break;\n          case WorkerStates.OK:\n            settled = true;\n            resolve();\n            break;\n        }\n\n        if (!settled) {\n          to = setTimeout(() => {\n            if (!settled) {\n              reject(new Error('Timeout starting worker'));\n            }\n          }, 500);\n        }\n      });\n    }\n\n    return this._workerReadyPromise;\n  }\n\n  /**\n   * Used to shut down the current working instance once the children have been\n   * killed off.\n   */\n  protected _shutdown(): void {\n    this.state = WorkerStates.SHUT_DOWN;\n\n    // End the permanent stream so the merged stream end too\n    if (this._fakeStream) {\n      this._fakeStream.end();\n      this._fakeStream = null;\n    }\n\n    this._resolveExitPromise();\n  }\n\n  protected _getFakeStream(): PassThrough {\n    if (!this._fakeStream) {\n      this._fakeStream = new PassThrough();\n    }\n    return this._fakeStream;\n  }\n}\n",
  "packages/jest-worker/src/workers/WorkerAbstract.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { EventEmitter, PassThrough } from 'stream';\nimport { type WorkerInterface, type WorkerOptions, WorkerStates } from '../types';\nexport default abstract class WorkerAbstract extends EventEmitter implements Pick<WorkerInterface, 'waitForWorkerReady' | 'state'> {\n    #private;\n    protected _fakeStream: PassThrough | null;\n    protected _exitPromise: Promise<void>;\n    protected _resolveExitPromise: () => void;\n    protected _workerReadyPromise: Promise<void> | undefined;\n    protected _resolveWorkerReady: (() => void) | undefined;\n    get state(): WorkerStates;\n    protected set state(value: WorkerStates);\n    constructor(options: WorkerOptions);\n    /**\n     * Wait for the worker child process to be ready to handle requests.\n     *\n     * @returns Promise which resolves when ready.\n     */\n    waitForWorkerReady(): Promise<void>;\n    /**\n     * Used to shut down the current working instance once the children have been\n     * killed off.\n     */\n    protected _shutdown(): void;\n    protected _getFakeStream(): PassThrough;\n}\n",
  "packages/jest-worker/src/workers/NodeThreadsWorker.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {totalmem} from 'os';\nimport {Worker} from 'worker_threads';\nimport mergeStream from 'merge-stream';\nimport {\n  CHILD_MESSAGE_INITIALIZE,\n  CHILD_MESSAGE_MEM_USAGE,\n  type ChildMessage,\n  type OnCustomMessage,\n  type OnEnd,\n  type OnStart,\n  PARENT_MESSAGE_CLIENT_ERROR,\n  PARENT_MESSAGE_CUSTOM,\n  PARENT_MESSAGE_MEM_USAGE,\n  PARENT_MESSAGE_OK,\n  PARENT_MESSAGE_SETUP_ERROR,\n  type ParentMessage,\n  type WorkerInterface,\n  type WorkerOptions,\n  WorkerStates,\n} from '../types';\nimport WorkerAbstract from './WorkerAbstract';\nimport {unpackMessage} from './safeMessageTransferring';\n\nexport default class ExperimentalWorker\n  extends WorkerAbstract\n  implements WorkerInterface\n{\n  private _worker!: Worker;\n  private readonly _options: WorkerOptions;\n\n  private _request: ChildMessage | null;\n  private _retries!: number;\n  private _onProcessEnd!: OnEnd;\n  private _onCustomMessage!: OnCustomMessage;\n\n  private _stdout: ReturnType<typeof mergeStream> | null;\n  private _stderr: ReturnType<typeof mergeStream> | null;\n\n  private _memoryUsagePromise: Promise<number> | undefined;\n  private _resolveMemoryUsage: ((arg0: number) => void) | undefined;\n\n  private readonly _childWorkerPath: string;\n\n  private _childIdleMemoryUsage: number | null;\n  private readonly _childIdleMemoryUsageLimit: number | null;\n  private _memoryUsageCheck = false;\n\n  constructor(options: WorkerOptions) {\n    super(options);\n\n    this._options = options;\n\n    this._request = null;\n\n    this._stdout = null;\n    this._stderr = null;\n\n    this._childWorkerPath =\n      options.childWorkerPath || require.resolve('./threadChild');\n\n    this._childIdleMemoryUsage = null;\n    this._childIdleMemoryUsageLimit = options.idleMemoryLimit || null;\n\n    this.initialize();\n  }\n\n  initialize(): void {\n    if (\n      this.state === WorkerStates.OUT_OF_MEMORY ||\n      this.state === WorkerStates.SHUTTING_DOWN ||\n      this.state === WorkerStates.SHUT_DOWN\n    ) {\n      return;\n    }\n\n    if (this._worker) {\n      this._worker.terminate();\n    }\n\n    this.state = WorkerStates.STARTING;\n\n    this._worker = new Worker(this._childWorkerPath, {\n      eval: false,\n      resourceLimits: this._options.resourceLimits,\n      stderr: true,\n      stdout: true,\n      workerData: this._options.workerData,\n      ...this._options.forkOptions,\n    });\n\n    if (this._worker.stdout) {\n      if (!this._stdout) {\n        // We need to add a permanent stream to the merged stream to prevent it\n        // from ending when the subprocess stream ends\n        this._stdout = mergeStream(this._getFakeStream());\n      }\n\n      this._stdout.add(this._worker.stdout);\n    }\n\n    if (this._worker.stderr) {\n      if (!this._stderr) {\n        // We need to add a permanent stream to the merged stream to prevent it\n        // from ending when the subprocess stream ends\n        this._stderr = mergeStream(this._getFakeStream());\n      }\n\n      this._stderr.add(this._worker.stderr);\n    }\n\n    // This can be useful for debugging.\n    if (!(this._options.silent ?? true)) {\n      this._worker.stdout.setEncoding('utf8');\n      // eslint-disable-next-line no-console\n      this._worker.stdout.on('data', console.log);\n      this._worker.stderr.setEncoding('utf8');\n      this._worker.stderr.on('data', console.error);\n    }\n\n    this._worker.on('message', this._onMessage.bind(this));\n    this._worker.on('exit', this._onExit.bind(this));\n    this._worker.on('error', this._onError.bind(this));\n\n    this._worker.postMessage([\n      CHILD_MESSAGE_INITIALIZE,\n      false,\n      this._options.workerPath,\n      this._options.setupArgs,\n      String(this._options.workerId + 1), // 0-indexed workerId, 1-indexed JEST_WORKER_ID\n    ]);\n\n    this._retries++;\n\n    // If we exceeded the amount of retries, we will emulate an error reply\n    // coming from the child. This avoids code duplication related with cleaning\n    // the queue, and scheduling the next call.\n    if (this._retries > this._options.maxRetries) {\n      const error = new Error('Call retries were exceeded');\n\n      this._onMessage([\n        PARENT_MESSAGE_CLIENT_ERROR,\n        error.name,\n        error.message,\n        error.stack!,\n        {type: 'WorkerError'},\n      ]);\n    }\n\n    this.state = WorkerStates.OK;\n    if (this._resolveWorkerReady) {\n      this._resolveWorkerReady();\n    }\n  }\n\n  private _onError(error: Error) {\n    if (error.message.includes('heap out of memory')) {\n      this.state = WorkerStates.OUT_OF_MEMORY;\n\n      // Threads don't behave like processes, they don't crash when they run out of\n      // memory. But for consistency we want them to behave like processes so we call\n      // terminate to simulate a crash happening that was not planned\n      this._worker.terminate();\n    }\n  }\n\n  private _onMessage(response: ParentMessage) {\n    // Ignore messages not intended for us\n    if (!Array.isArray(response)) return;\n\n    let error;\n\n    switch (response[0]) {\n      case PARENT_MESSAGE_OK:\n        this._onProcessEnd(null, unpackMessage(response[1]));\n        break;\n\n      case PARENT_MESSAGE_CLIENT_ERROR:\n        error = response[4];\n\n        if (error != null && typeof error === 'object') {\n          const extra = error;\n          // @ts-expect-error: no index\n          const NativeCtor = globalThis[response[1]];\n          const Ctor = typeof NativeCtor === 'function' ? NativeCtor : Error;\n\n          error = new Ctor(response[2]);\n          error.type = response[1];\n          error.stack = response[3];\n\n          for (const key in extra) {\n            // @ts-expect-error: no index\n            error[key] = extra[key];\n          }\n        }\n\n        this._onProcessEnd(error, null);\n        break;\n\n      case PARENT_MESSAGE_SETUP_ERROR:\n        error = new Error(`Error when calling setup: ${response[2]}`);\n\n        // @ts-expect-error: adding custom properties to errors.\n        error.type = response[1];\n        error.stack = response[3];\n\n        this._onProcessEnd(error, null);\n        break;\n\n      case PARENT_MESSAGE_CUSTOM:\n        this._onCustomMessage(unpackMessage(response[1]));\n        break;\n\n      case PARENT_MESSAGE_MEM_USAGE:\n        this._childIdleMemoryUsage = response[1];\n\n        if (this._resolveMemoryUsage) {\n          this._resolveMemoryUsage(response[1]);\n\n          this._resolveMemoryUsage = undefined;\n          this._memoryUsagePromise = undefined;\n        }\n\n        this._performRestartIfRequired();\n        break;\n\n      default:\n        // Ignore messages not intended for us\n        break;\n    }\n  }\n\n  private _onExit(exitCode: number) {\n    this._workerReadyPromise = undefined;\n    this._resolveWorkerReady = undefined;\n\n    if (exitCode !== 0 && this.state === WorkerStates.OUT_OF_MEMORY) {\n      this._onProcessEnd(\n        new Error('Jest worker ran out of memory and crashed'),\n        null,\n      );\n\n      this._shutdown();\n    } else if (\n      (exitCode !== 0 &&\n        this.state !== WorkerStates.SHUTTING_DOWN &&\n        this.state !== WorkerStates.SHUT_DOWN) ||\n      this.state === WorkerStates.RESTARTING\n    ) {\n      this.initialize();\n\n      if (this._request) {\n        this._worker.postMessage(this._request);\n      }\n    } else {\n      // If the worker thread exits while a request is still pending, throw an\n      // error. This is unexpected and tests may not have run to completion.\n      const isRequestStillPending = !!this._request;\n      if (isRequestStillPending) {\n        this._onProcessEnd(\n          new Error(\n            'A Jest worker thread exited unexpectedly before finishing tests for an unknown reason. One of the ways this can happen is if process.exit() was called in testing code.',\n          ),\n          null,\n        );\n      }\n\n      this._shutdown();\n    }\n  }\n\n  waitForExit(): Promise<void> {\n    return this._exitPromise;\n  }\n\n  forceExit(): void {\n    this.state = WorkerStates.SHUTTING_DOWN;\n    this._worker.terminate();\n  }\n\n  send(\n    request: ChildMessage,\n    onProcessStart: OnStart,\n    onProcessEnd: OnEnd | null,\n    onCustomMessage: OnCustomMessage,\n  ): void {\n    onProcessStart(this);\n    this._onProcessEnd = (...args) => {\n      const hasRequest = !!this._request;\n\n      // Clean the request to avoid sending past requests to workers that fail\n      // while waiting for a new request (timers, unhandled rejections...)\n      this._request = null;\n\n      if (this._childIdleMemoryUsageLimit && hasRequest) {\n        this.checkMemoryUsage();\n      }\n\n      const res = onProcessEnd?.(...args);\n\n      // Clean up the reference so related closures can be garbage collected.\n      onProcessEnd = null;\n\n      return res;\n    };\n\n    this._onCustomMessage = (...arg) => onCustomMessage(...arg);\n\n    this._request = request;\n    this._retries = 0;\n\n    this._worker.postMessage(request);\n  }\n\n  getWorkerId(): number {\n    return this._options.workerId;\n  }\n\n  getStdout(): NodeJS.ReadableStream | null {\n    return this._stdout;\n  }\n\n  getStderr(): NodeJS.ReadableStream | null {\n    return this._stderr;\n  }\n\n  private _performRestartIfRequired(): void {\n    if (this._memoryUsageCheck) {\n      this._memoryUsageCheck = false;\n\n      let limit = this._childIdleMemoryUsageLimit;\n\n      // TODO: At some point it would make sense to make use of\n      // stringToBytes found in jest-config, however as this\n      // package does not have any dependencies on an other jest\n      // packages that can wait until some other time.\n      if (limit && limit > 0 && limit <= 1) {\n        limit = Math.floor(totalmem() * limit);\n      } else if (limit) {\n        limit = Math.floor(limit);\n      }\n\n      if (\n        limit &&\n        this._childIdleMemoryUsage &&\n        this._childIdleMemoryUsage > limit\n      ) {\n        this.state = WorkerStates.RESTARTING;\n\n        this._worker.terminate();\n      }\n    }\n  }\n\n  /**\n   * Gets the last reported memory usage.\n   *\n   * @returns Memory usage in bytes.\n   */\n  getMemoryUsage(): Promise<number | null> {\n    if (!this._memoryUsagePromise) {\n      let rejectCallback!: (err: Error) => void;\n\n      const promise = new Promise<number>((resolve, reject) => {\n        this._resolveMemoryUsage = resolve;\n        rejectCallback = reject;\n      });\n      this._memoryUsagePromise = promise;\n\n      if (!this._worker.threadId) {\n        rejectCallback(new Error('Child process is not running.'));\n\n        this._memoryUsagePromise = undefined;\n        this._resolveMemoryUsage = undefined;\n\n        return promise;\n      }\n\n      try {\n        this._worker.postMessage([CHILD_MESSAGE_MEM_USAGE]);\n      } catch (error: any) {\n        this._memoryUsagePromise = undefined;\n        this._resolveMemoryUsage = undefined;\n\n        rejectCallback(error);\n      }\n\n      return promise;\n    }\n\n    return this._memoryUsagePromise;\n  }\n\n  /**\n   * Gets updated memory usage and restarts if required\n   */\n  checkMemoryUsage(): void {\n    if (this._childIdleMemoryUsageLimit) {\n      this._memoryUsageCheck = true;\n      this._worker.postMessage([CHILD_MESSAGE_MEM_USAGE]);\n    } else {\n      console.warn(\n        'Memory usage of workers can only be checked if a limit is set',\n      );\n    }\n  }\n\n  /**\n   * Gets the thread id of the worker.\n   *\n   * @returns Thread id.\n   */\n  getWorkerSystemId(): number {\n    return this._worker.threadId;\n  }\n\n  isWorkerRunning(): boolean {\n    return this._worker.threadId >= 0;\n  }\n}\n",
  "packages/jest-worker/src/workers/NodeThreadsWorker.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { type ChildMessage, type OnCustomMessage, type OnEnd, type OnStart, type WorkerInterface, type WorkerOptions } from '../types';\nimport WorkerAbstract from './WorkerAbstract';\nexport default class ExperimentalWorker extends WorkerAbstract implements WorkerInterface {\n    private _worker;\n    private readonly _options;\n    private _request;\n    private _retries;\n    private _onProcessEnd;\n    private _onCustomMessage;\n    private _stdout;\n    private _stderr;\n    private _memoryUsagePromise;\n    private _resolveMemoryUsage;\n    private readonly _childWorkerPath;\n    private _childIdleMemoryUsage;\n    private readonly _childIdleMemoryUsageLimit;\n    private _memoryUsageCheck;\n    constructor(options: WorkerOptions);\n    initialize(): void;\n    private _onError;\n    private _onMessage;\n    private _onExit;\n    waitForExit(): Promise<void>;\n    forceExit(): void;\n    send(request: ChildMessage, onProcessStart: OnStart, onProcessEnd: OnEnd | null, onCustomMessage: OnCustomMessage): void;\n    getWorkerId(): number;\n    getStdout(): NodeJS.ReadableStream | null;\n    getStderr(): NodeJS.ReadableStream | null;\n    private _performRestartIfRequired;\n    /**\n     * Gets the last reported memory usage.\n     *\n     * @returns Memory usage in bytes.\n     */\n    getMemoryUsage(): Promise<number | null>;\n    /**\n     * Gets updated memory usage and restarts if required\n     */\n    checkMemoryUsage(): void;\n    /**\n     * Gets the thread id of the worker.\n     *\n     * @returns Thread id.\n     */\n    getWorkerSystemId(): number;\n    isWorkerRunning(): boolean;\n}\n",
  "packages/jest-worker/src/workers/ChildProcessWorker.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {type ChildProcess, type ForkOptions, fork} from 'child_process';\nimport {totalmem} from 'os';\nimport mergeStream from 'merge-stream';\nimport {stdout as stdoutSupportsColor} from 'supports-color';\nimport {\n  CHILD_MESSAGE_INITIALIZE,\n  CHILD_MESSAGE_MEM_USAGE,\n  type ChildMessage,\n  type OnCustomMessage,\n  type OnEnd,\n  type OnStart,\n  PARENT_MESSAGE_CLIENT_ERROR,\n  PARENT_MESSAGE_CUSTOM,\n  PARENT_MESSAGE_MEM_USAGE,\n  PARENT_MESSAGE_OK,\n  PARENT_MESSAGE_SETUP_ERROR,\n  type ParentMessage,\n  type WorkerInterface,\n  type WorkerOptions,\n  WorkerStates,\n} from '../types';\nimport WorkerAbstract from './WorkerAbstract';\nimport {unpackMessage} from './safeMessageTransferring';\n\nconst SIGNAL_BASE_EXIT_CODE = 128;\nconst SIGKILL_EXIT_CODE = SIGNAL_BASE_EXIT_CODE + 9;\nconst SIGTERM_EXIT_CODE = SIGNAL_BASE_EXIT_CODE + 15;\n\n// How long to wait after SIGTERM before sending SIGKILL\nexport const SIGKILL_DELAY = 500;\n\n/**\n * This class wraps the child process and provides a nice interface to\n * communicate with. It takes care of:\n *\n *  - Re-spawning the process if it dies.\n *  - Queues calls while the worker is busy.\n *  - Re-sends the requests if the worker blew up.\n *\n * The reason for queueing them here (since childProcess.send also has an\n * internal queue) is because the worker could be doing asynchronous work, and\n * this would lead to the child process to read its receiving buffer and start a\n * second call. By queueing calls here, we don't send the next call to the\n * children until we receive the result of the previous one.\n *\n * As soon as a request starts to be processed by a worker, its \"processed\"\n * field is changed to \"true\", so that other workers which might encounter the\n * same call skip it.\n */\nexport default class ChildProcessWorker\n  extends WorkerAbstract\n  implements WorkerInterface\n{\n  private _child!: ChildProcess;\n  private readonly _options: WorkerOptions;\n\n  private _request: ChildMessage | null;\n  private _retries!: number;\n  private _onProcessEnd!: OnEnd;\n  private _onCustomMessage!: OnCustomMessage;\n\n  private _stdout: ReturnType<typeof mergeStream> | null;\n  private _stderr: ReturnType<typeof mergeStream> | null;\n\n  private _stderrBuffer: Array<Buffer> = [];\n\n  private _memoryUsagePromise: Promise<number> | undefined;\n  private _resolveMemoryUsage: ((arg0: number) => void) | undefined;\n\n  private _childIdleMemoryUsage: number | null;\n  private readonly _childIdleMemoryUsageLimit: number | null;\n  private _memoryUsageCheck = false;\n\n  private readonly _childWorkerPath: string;\n\n  constructor(options: WorkerOptions) {\n    super(options);\n\n    this._options = options;\n\n    this._request = null;\n\n    this._stdout = null;\n    this._stderr = null;\n    this._childIdleMemoryUsage = null;\n    this._childIdleMemoryUsageLimit = options.idleMemoryLimit ?? null;\n\n    this._childWorkerPath =\n      options.childWorkerPath || require.resolve('./processChild');\n\n    this.state = WorkerStates.STARTING;\n    this.initialize();\n  }\n\n  initialize(): void {\n    if (\n      this.state === WorkerStates.OUT_OF_MEMORY ||\n      this.state === WorkerStates.SHUTTING_DOWN ||\n      this.state === WorkerStates.SHUT_DOWN\n    ) {\n      return;\n    }\n\n    if (this._child && this._child.connected) {\n      this._child.kill('SIGKILL');\n    }\n\n    this.state = WorkerStates.STARTING;\n\n    const forceColor = stdoutSupportsColor ? {FORCE_COLOR: '1'} : {};\n    const silent = this._options.silent ?? true;\n\n    if (!silent) {\n      // NOTE: Detecting an out of memory crash is independent of idle memory usage monitoring. We want to\n      // monitor for a crash occurring so that it can be handled as required and so we can tell the difference\n      // between an OOM crash and another kind of crash. We need to do this because if a worker crashes due to\n      // an OOM event sometimes it isn't seen by the worker pool and it just sits there waiting for the worker\n      // to respond and it never will.\n      console.warn('Unable to detect out of memory event if silent === false');\n    }\n\n    this._stderrBuffer = [];\n\n    const options: ForkOptions = {\n      cwd: process.cwd(),\n      env: {\n        ...process.env,\n        JEST_WORKER_ID: String(this._options.workerId + 1), // 0-indexed workerId, 1-indexed JEST_WORKER_ID\n        ...forceColor,\n      },\n      // Suppress --debug / --inspect flags while preserving others (like --harmony).\n      execArgv: process.execArgv.filter(v => !/^--(debug|inspect)/.test(v)),\n      // default to advanced serialization in order to match worker threads\n      serialization: 'advanced',\n      silent,\n      ...this._options.forkOptions,\n    };\n\n    this._child = fork(this._childWorkerPath, [], options);\n\n    if (this._child.stdout) {\n      if (!this._stdout) {\n        // We need to add a permanent stream to the merged stream to prevent it\n        // from ending when the subprocess stream ends\n        this._stdout = mergeStream(this._getFakeStream());\n      }\n\n      this._stdout.add(this._child.stdout);\n    }\n\n    if (this._child.stderr) {\n      if (!this._stderr) {\n        // We need to add a permanent stream to the merged stream to prevent it\n        // from ending when the subprocess stream ends\n        this._stderr = mergeStream(this._getFakeStream());\n      }\n\n      this._stderr.add(this._child.stderr);\n\n      this._child.stderr.on('data', this.stderrDataHandler.bind(this));\n    }\n\n    this._child.on('message', this._onMessage.bind(this));\n    this._child.on('exit', this._onExit.bind(this));\n    this._child.on('disconnect', this._onDisconnect.bind(this));\n\n    this._child.send([\n      CHILD_MESSAGE_INITIALIZE,\n      false,\n      this._options.workerPath,\n      this._options.setupArgs,\n    ]);\n\n    this._retries++;\n\n    // If we exceeded the amount of retries, we will emulate an error reply\n    // coming from the child. This avoids code duplication related with cleaning\n    // the queue, and scheduling the next call.\n    if (this._retries > this._options.maxRetries) {\n      const error = new Error(\n        `Jest worker encountered ${this._retries} child process exceptions, exceeding retry limit`,\n      );\n\n      this._onMessage([\n        PARENT_MESSAGE_CLIENT_ERROR,\n        error.name,\n        error.message,\n        error.stack!,\n        {type: 'WorkerError'},\n      ]);\n\n      // Clear the request so we don't keep executing it.\n      this._request = null;\n    }\n\n    this.state = WorkerStates.OK;\n    if (this._resolveWorkerReady) {\n      this._resolveWorkerReady();\n    }\n  }\n\n  private stderrDataHandler(chunk: any): void {\n    if (chunk) {\n      this._stderrBuffer.push(Buffer.from(chunk));\n    }\n\n    this._detectOutOfMemoryCrash();\n\n    if (this.state === WorkerStates.OUT_OF_MEMORY) {\n      this._workerReadyPromise = undefined;\n      this._resolveWorkerReady = undefined;\n\n      this.killChild();\n      this._shutdown();\n    }\n  }\n\n  private _detectOutOfMemoryCrash(): void {\n    try {\n      const bufferStr = Buffer.concat(this._stderrBuffer).toString('utf8');\n\n      if (\n        bufferStr.includes('heap out of memory') ||\n        bufferStr.includes('allocation failure;') ||\n        bufferStr.includes('Last few GCs')\n      ) {\n        if (\n          this.state === WorkerStates.OK ||\n          this.state === WorkerStates.STARTING ||\n          this.state === WorkerStates.SHUT_DOWN\n        ) {\n          this.state = WorkerStates.OUT_OF_MEMORY;\n        }\n      }\n    } catch (error) {\n      console.error('Error looking for out of memory crash', error);\n    }\n  }\n\n  private _onDisconnect() {\n    this._workerReadyPromise = undefined;\n    this._resolveWorkerReady = undefined;\n\n    this._detectOutOfMemoryCrash();\n\n    if (this.state === WorkerStates.OUT_OF_MEMORY) {\n      this.killChild();\n      this._shutdown();\n    }\n  }\n\n  private _onMessage(response: ParentMessage) {\n    // Ignore messages not intended for us\n    if (!Array.isArray(response)) return;\n\n    // TODO: Add appropriate type check\n    let error: any;\n\n    switch (response[0]) {\n      case PARENT_MESSAGE_OK:\n        this._onProcessEnd(null, unpackMessage(response[1]));\n        break;\n\n      case PARENT_MESSAGE_CLIENT_ERROR:\n        error = response[4];\n\n        if (error != null && typeof error === 'object') {\n          const extra = error;\n          // @ts-expect-error: no index\n          const NativeCtor = globalThis[response[1]];\n          const Ctor = typeof NativeCtor === 'function' ? NativeCtor : Error;\n\n          error = new Ctor(response[2]);\n          error.type = response[1];\n          error.stack = response[3];\n\n          for (const key in extra) {\n            error[key] = extra[key];\n          }\n        }\n\n        this._onProcessEnd(error, null);\n        break;\n\n      case PARENT_MESSAGE_SETUP_ERROR:\n        error = new Error(`Error when calling setup: ${response[2]}`);\n\n        error.type = response[1];\n        error.stack = response[3];\n\n        this._onProcessEnd(error, null);\n        break;\n\n      case PARENT_MESSAGE_CUSTOM:\n        this._onCustomMessage(unpackMessage(response[1]));\n        break;\n\n      case PARENT_MESSAGE_MEM_USAGE:\n        this._childIdleMemoryUsage = response[1];\n\n        if (this._resolveMemoryUsage) {\n          this._resolveMemoryUsage(response[1]);\n\n          this._resolveMemoryUsage = undefined;\n          this._memoryUsagePromise = undefined;\n        }\n\n        this._performRestartIfRequired();\n        break;\n\n      default:\n        // Ignore messages not intended for us\n        break;\n    }\n  }\n\n  private _performRestartIfRequired(): void {\n    if (this._memoryUsageCheck) {\n      this._memoryUsageCheck = false;\n\n      let limit = this._childIdleMemoryUsageLimit;\n\n      // TODO: At some point it would make sense to make use of\n      // stringToBytes found in jest-config, however as this\n      // package does not have any dependencies on an other jest\n      // packages that can wait until some other time.\n      if (limit && limit > 0 && limit <= 1) {\n        limit = Math.floor(totalmem() * limit);\n      } else if (limit) {\n        limit = Math.floor(limit);\n      }\n\n      if (\n        limit &&\n        this._childIdleMemoryUsage &&\n        this._childIdleMemoryUsage > limit\n      ) {\n        this._restart();\n      }\n    }\n  }\n\n  private _restart(): void {\n    this.state = WorkerStates.RESTARTING;\n    this.killChild();\n  }\n\n  private _onExit(exitCode: number | null, signal: NodeJS.Signals | null) {\n    this._workerReadyPromise = undefined;\n    this._resolveWorkerReady = undefined;\n\n    this._detectOutOfMemoryCrash();\n\n    if (exitCode !== 0 && this.state === WorkerStates.OUT_OF_MEMORY) {\n      this._onProcessEnd(\n        new Error('Jest worker ran out of memory and crashed'),\n        null,\n      );\n\n      this._shutdown();\n    } else if (\n      (exitCode !== 0 &&\n        exitCode !== null &&\n        exitCode !== SIGTERM_EXIT_CODE &&\n        exitCode !== SIGKILL_EXIT_CODE &&\n        this.state !== WorkerStates.SHUTTING_DOWN) ||\n      this.state === WorkerStates.RESTARTING\n    ) {\n      this.state = WorkerStates.RESTARTING;\n\n      this.initialize();\n\n      if (this._request) {\n        this._child.send(this._request);\n      }\n    } else {\n      // At this point, it's not clear why the child process exited. There could\n      // be several reasons:\n      //\n      //  1. The child process exited successfully after finishing its work.\n      //     This is the most likely case.\n      //  2. The child process crashed in a manner that wasn't caught through\n      //     any of the heuristic-based checks above.\n      //  3. The child process was killed by another process or daemon unrelated\n      //     to Jest. For example, oom-killer on Linux may have picked the child\n      //     process to kill because overall system memory is constrained.\n      //\n      // If there's a pending request to the child process in any of those\n      // situations, the request still needs to be handled in some manner before\n      // entering the shutdown phase. Otherwise the caller expecting a response\n      // from the worker will never receive indication that something unexpected\n      // happened and hang forever.\n      //\n      // In normal operation, the request is handled and cleared before the\n      // child process exits. If it's still present, it's not clear what\n      // happened and probably best to throw an error. In practice, this usually\n      // happens when the child process is killed externally.\n      //\n      // There's a reasonable argument that the child process should be retried\n      // with request re-sent in this scenario. However, if the problem was due\n      // to situations such as oom-killer attempting to free up system\n      // resources, retrying would exacerbate the problem.\n      const isRequestStillPending = !!this._request;\n      if (isRequestStillPending) {\n        // If a signal is present, we can be reasonably confident the process\n        // was killed externally. Log this fact so it's more clear to users that\n        // something went wrong externally, rather than a bug in Jest itself.\n        const error = new Error(\n          signal == null\n            ? `A jest worker process (pid=${this._child.pid}) crashed for an unknown reason: exitCode=${exitCode}`\n            : `A jest worker process (pid=${this._child.pid}) was terminated by another process: signal=${signal}, exitCode=${exitCode}. Operating system logs may contain more information on why this occurred.`,\n        );\n\n        this._onProcessEnd(error, null);\n      }\n\n      this._shutdown();\n    }\n  }\n\n  send(\n    request: ChildMessage,\n    onProcessStart: OnStart,\n    onProcessEnd: OnEnd,\n    onCustomMessage: OnCustomMessage,\n  ): void {\n    this._stderrBuffer = [];\n\n    onProcessStart(this);\n\n    this._onProcessEnd = (...args) => {\n      const hasRequest = !!this._request;\n\n      // Clean the request to avoid sending past requests to workers that fail\n      // while waiting for a new request (timers, unhandled rejections...)\n      this._request = null;\n\n      if (\n        this._childIdleMemoryUsageLimit !== null &&\n        this._child.connected &&\n        hasRequest\n      ) {\n        if (this._childIdleMemoryUsageLimit === 0) {\n          // Special case: `idleMemoryLimit` of `0` means always restart.\n          this._restart();\n        } else {\n          this.checkMemoryUsage();\n        }\n      }\n\n      return onProcessEnd(...args);\n    };\n\n    this._onCustomMessage = (...arg) => onCustomMessage(...arg);\n\n    this._request = request;\n    this._retries = 0;\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    this._child.send(request, () => {});\n  }\n\n  waitForExit(): Promise<void> {\n    return this._exitPromise;\n  }\n\n  killChild(): NodeJS.Timeout {\n    // We store a reference so that there's no way we can accidentally\n    // kill a new worker that has been spawned.\n    const childToKill = this._child;\n\n    childToKill.kill('SIGTERM');\n    return setTimeout(() => childToKill.kill('SIGKILL'), SIGKILL_DELAY);\n  }\n\n  forceExit(): void {\n    this.state = WorkerStates.SHUTTING_DOWN;\n\n    const sigkillTimeout = this.killChild();\n    this._exitPromise.then(() => clearTimeout(sigkillTimeout));\n  }\n\n  getWorkerId(): number {\n    return this._options.workerId;\n  }\n\n  /**\n   * Gets the process id of the worker.\n   *\n   * @returns Process id.\n   */\n  getWorkerSystemId(): number {\n    return this._child.pid!;\n  }\n\n  getStdout(): NodeJS.ReadableStream | null {\n    return this._stdout;\n  }\n\n  getStderr(): NodeJS.ReadableStream | null {\n    return this._stderr;\n  }\n\n  /**\n   * Gets the last reported memory usage.\n   *\n   * @returns Memory usage in bytes.\n   */\n  getMemoryUsage(): Promise<number | null> {\n    if (!this._memoryUsagePromise) {\n      let rejectCallback!: (err: Error) => void;\n\n      const promise = new Promise<number>((resolve, reject) => {\n        this._resolveMemoryUsage = resolve;\n        rejectCallback = reject;\n      });\n      this._memoryUsagePromise = promise;\n\n      if (!this._child.connected && rejectCallback) {\n        rejectCallback(new Error('Child process is not running.'));\n\n        this._memoryUsagePromise = undefined;\n        this._resolveMemoryUsage = undefined;\n\n        return promise;\n      }\n\n      this._child.send([CHILD_MESSAGE_MEM_USAGE], err => {\n        if (err && rejectCallback) {\n          this._memoryUsagePromise = undefined;\n          this._resolveMemoryUsage = undefined;\n\n          rejectCallback(err);\n        }\n      });\n\n      return promise;\n    }\n\n    return this._memoryUsagePromise;\n  }\n\n  /**\n   * Gets updated memory usage and restarts if required\n   */\n  checkMemoryUsage(): void {\n    if (this._childIdleMemoryUsageLimit === null) {\n      console.warn(\n        'Memory usage of workers can only be checked if a limit is set',\n      );\n    } else {\n      this._memoryUsageCheck = true;\n      this._child.send([CHILD_MESSAGE_MEM_USAGE], err => {\n        if (err) {\n          console.error('Unable to check memory usage', err);\n        }\n      });\n    }\n  }\n\n  isWorkerRunning(): boolean {\n    return this._child.connected && !this._child.killed;\n  }\n}\n",
  "packages/jest-worker/src/workers/ChildProcessWorker.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { type ChildMessage, type OnCustomMessage, type OnEnd, type OnStart, type WorkerInterface, type WorkerOptions } from '../types';\nimport WorkerAbstract from './WorkerAbstract';\nexport declare const SIGKILL_DELAY = 500;\n/**\n * This class wraps the child process and provides a nice interface to\n * communicate with. It takes care of:\n *\n *  - Re-spawning the process if it dies.\n *  - Queues calls while the worker is busy.\n *  - Re-sends the requests if the worker blew up.\n *\n * The reason for queueing them here (since childProcess.send also has an\n * internal queue) is because the worker could be doing asynchronous work, and\n * this would lead to the child process to read its receiving buffer and start a\n * second call. By queueing calls here, we don't send the next call to the\n * children until we receive the result of the previous one.\n *\n * As soon as a request starts to be processed by a worker, its \"processed\"\n * field is changed to \"true\", so that other workers which might encounter the\n * same call skip it.\n */\nexport default class ChildProcessWorker extends WorkerAbstract implements WorkerInterface {\n    private _child;\n    private readonly _options;\n    private _request;\n    private _retries;\n    private _onProcessEnd;\n    private _onCustomMessage;\n    private _stdout;\n    private _stderr;\n    private _stderrBuffer;\n    private _memoryUsagePromise;\n    private _resolveMemoryUsage;\n    private _childIdleMemoryUsage;\n    private readonly _childIdleMemoryUsageLimit;\n    private _memoryUsageCheck;\n    private readonly _childWorkerPath;\n    constructor(options: WorkerOptions);\n    initialize(): void;\n    private stderrDataHandler;\n    private _detectOutOfMemoryCrash;\n    private _onDisconnect;\n    private _onMessage;\n    private _performRestartIfRequired;\n    private _restart;\n    private _onExit;\n    send(request: ChildMessage, onProcessStart: OnStart, onProcessEnd: OnEnd, onCustomMessage: OnCustomMessage): void;\n    waitForExit(): Promise<void>;\n    killChild(): NodeJS.Timeout;\n    forceExit(): void;\n    getWorkerId(): number;\n    /**\n     * Gets the process id of the worker.\n     *\n     * @returns Process id.\n     */\n    getWorkerSystemId(): number;\n    getStdout(): NodeJS.ReadableStream | null;\n    getStderr(): NodeJS.ReadableStream | null;\n    /**\n     * Gets the last reported memory usage.\n     *\n     * @returns Memory usage in bytes.\n     */\n    getMemoryUsage(): Promise<number | null>;\n    /**\n     * Gets updated memory usage and restarts if required\n     */\n    checkMemoryUsage(): void;\n    isWorkerRunning(): boolean;\n}\n",
  "packages/jest-worker/src/workers/__tests__/threadChild.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {EventEmitter} from 'events';\nimport type {MessagePort} from 'worker_threads';\nimport {\n  CHILD_MESSAGE_CALL,\n  CHILD_MESSAGE_END,\n  CHILD_MESSAGE_INITIALIZE,\n  PARENT_MESSAGE_CLIENT_ERROR,\n  PARENT_MESSAGE_OK,\n} from '../../types';\n\nclass MockedParentPort extends EventEmitter {\n  postMessage = jest.fn();\n}\n\njest.mock('worker_threads', () => {\n  return {\n    isMainThread: false,\n    parentPort: new MockedParentPort(),\n  };\n});\n\nclass MockExtendedError extends ReferenceError {\n  baz = 123;\n  qux = 456;\n}\n\nconst mockError = new TypeError('Boo');\nconst mockExtendedError = new MockExtendedError('Boo extended');\nconst uninitializedParam = {};\nconst sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\n\nlet ended: boolean;\nlet mockCount: number;\nlet initializeParm = uninitializedParam;\n\nlet messagePort: MessagePort;\n\nbeforeEach(() => {\n  mockCount = 0;\n  ended = false;\n\n  jest.mock(\n    '../my-fancy-worker',\n    () => {\n      mockCount++;\n\n      return {\n        fooPromiseThrows() {\n          return new Promise((_resolve, reject) => {\n            setTimeout(() => reject(mockError), 5);\n          });\n        },\n\n        fooPromiseWorks() {\n          return new Promise(resolve => {\n            setTimeout(() => resolve(1989), 5);\n          });\n        },\n\n        fooThrows() {\n          throw mockError;\n        },\n\n        fooThrowsANumber() {\n          // eslint-disable-next-line no-throw-literal\n          throw 412;\n        },\n\n        fooThrowsAnErrorWithExtraProperties() {\n          throw mockExtendedError;\n        },\n\n        fooThrowsNull() {\n          // eslint-disable-next-line no-throw-literal\n          throw null;\n        },\n\n        fooWorks() {\n          return 1989;\n        },\n\n        setup(param: Record<string, unknown>) {\n          initializeParm = param;\n        },\n\n        teardown() {\n          ended = true;\n        },\n      };\n    },\n    {virtual: true},\n  );\n\n  jest.mock('../my-fancy-standalone-worker', () => jest.fn(() => 12_345), {\n    virtual: true,\n  });\n\n  // This mock emulates a transpiled Babel module that carries a default export\n  // that corresponds to a method.\n  jest.mock(\n    '../my-fancy-babel-worker',\n    () => ({\n      __esModule: true,\n      default: jest.fn(() => 67_890),\n    }),\n    {virtual: true},\n  );\n\n  messagePort = (require('worker_threads') as typeof import('worker_threads'))\n    .parentPort!;\n\n  // Require the child!\n  require('../threadChild');\n});\n\nbeforeEach(() => {\n  jest.mocked(messagePort.postMessage).mockClear();\n});\n\nafterEach(() => {\n  jest.resetModules();\n\n  messagePort.removeAllListeners('message');\n});\n\nit('sets env.JEST_WORKER_ID', () => {\n  messagePort.emit('message', [\n    CHILD_MESSAGE_INITIALIZE,\n    true,\n    './my-fancy-worker',\n    [],\n    '3',\n  ]);\n\n  expect(process.env.JEST_WORKER_ID).toBe('3');\n});\n\nit('lazily requires the file', () => {\n  expect(mockCount).toBe(0);\n\n  messagePort.emit('message', [\n    CHILD_MESSAGE_INITIALIZE,\n    true,\n    './my-fancy-worker',\n  ]);\n\n  expect(mockCount).toBe(0);\n  expect(initializeParm).toBe(uninitializedParam); // Not called yet.\n\n  messagePort.emit('message', [CHILD_MESSAGE_CALL, true, 'fooWorks', []]);\n\n  expect(mockCount).toBe(1);\n  expect(initializeParm).toBeUndefined();\n});\n\nit('calls initialize with the correct arguments', () => {\n  expect(mockCount).toBe(0);\n\n  messagePort.emit('message', [\n    CHILD_MESSAGE_INITIALIZE,\n    true,\n    './my-fancy-worker',\n    ['foo'], // Pass empty initialize params so the initialize method is called.\n  ]);\n\n  messagePort.emit('message', [CHILD_MESSAGE_CALL, true, 'fooWorks', []]);\n\n  expect(initializeParm).toBe('foo');\n});\n\nit('returns results immediately when function is synchronous', () => {\n  messagePort.emit('message', [\n    CHILD_MESSAGE_INITIALIZE,\n    true,\n    './my-fancy-worker',\n  ]);\n\n  messagePort.emit('message', [CHILD_MESSAGE_CALL, true, 'fooWorks', []]);\n\n  expect(jest.mocked(messagePort.postMessage).mock.calls[0][0]).toEqual([\n    PARENT_MESSAGE_OK,\n    1989,\n  ]);\n\n  messagePort.emit('message', [CHILD_MESSAGE_CALL, true, 'fooThrows', []]);\n\n  expect(jest.mocked(messagePort.postMessage).mock.calls[1][0]).toEqual([\n    PARENT_MESSAGE_CLIENT_ERROR,\n    'TypeError',\n    'Boo',\n    mockError.stack,\n    {},\n  ]);\n\n  messagePort.emit('message', [\n    CHILD_MESSAGE_CALL,\n    true,\n    'fooThrowsANumber',\n    [],\n  ]);\n\n  expect(jest.mocked(messagePort.postMessage).mock.calls[2][0]).toEqual([\n    PARENT_MESSAGE_CLIENT_ERROR,\n    'Number',\n    void 0,\n    void 0,\n    412,\n  ]);\n\n  messagePort.emit('message', [\n    CHILD_MESSAGE_CALL,\n    true,\n    'fooThrowsAnErrorWithExtraProperties',\n    [],\n  ]);\n\n  expect(jest.mocked(messagePort.postMessage).mock.calls[3][0]).toEqual([\n    PARENT_MESSAGE_CLIENT_ERROR,\n    'MockExtendedError',\n    'Boo extended',\n    mockExtendedError.stack,\n    {baz: 123, qux: 456},\n  ]);\n\n  messagePort.emit('message', [CHILD_MESSAGE_CALL, true, 'fooThrowsNull', []]);\n\n  expect(jest.mocked(messagePort.postMessage).mock.calls[4][0][0]).toBe(\n    PARENT_MESSAGE_CLIENT_ERROR,\n  );\n  expect(jest.mocked(messagePort.postMessage).mock.calls[4][0][1]).toBe(\n    'Error',\n  );\n  expect(jest.mocked(messagePort.postMessage).mock.calls[4][0][2]).toBe(\n    '\"null\" or \"undefined\" thrown',\n  );\n\n  expect(messagePort.postMessage).toHaveBeenCalledTimes(5);\n});\n\nit('returns results when it gets resolved if function is asynchronous', async () => {\n  messagePort.emit('message', [\n    CHILD_MESSAGE_INITIALIZE,\n    true,\n    './my-fancy-worker',\n  ]);\n\n  messagePort.emit('message', [\n    CHILD_MESSAGE_CALL,\n    true,\n    'fooPromiseWorks',\n    [],\n  ]);\n\n  await sleep(10);\n\n  expect(jest.mocked(messagePort.postMessage).mock.calls[0][0]).toEqual([\n    PARENT_MESSAGE_OK,\n    1989,\n  ]);\n\n  messagePort.emit('message', [\n    CHILD_MESSAGE_CALL,\n    true,\n    'fooPromiseThrows',\n    [],\n  ]);\n\n  await sleep(10);\n\n  expect(jest.mocked(messagePort.postMessage).mock.calls[1][0]).toEqual([\n    PARENT_MESSAGE_CLIENT_ERROR,\n    'TypeError',\n    'Boo',\n    mockError.stack,\n    {},\n  ]);\n\n  expect(messagePort.postMessage).toHaveBeenCalledTimes(2);\n});\n\nit('calls the main module if the method call is \"default\"', () => {\n  messagePort.emit('message', [\n    CHILD_MESSAGE_INITIALIZE,\n    true,\n    './my-fancy-standalone-worker',\n  ]);\n\n  messagePort.emit('message', [CHILD_MESSAGE_CALL, true, 'default', []]);\n\n  expect(jest.mocked(messagePort.postMessage).mock.calls[0][0]).toEqual([\n    PARENT_MESSAGE_OK,\n    12_345,\n  ]);\n});\n\nit('calls the main export if the method call is \"default\" and it is a Babel transpiled one', () => {\n  messagePort.emit('message', [\n    CHILD_MESSAGE_INITIALIZE,\n    true,\n    './my-fancy-babel-worker',\n  ]);\n\n  messagePort.emit('message', [CHILD_MESSAGE_CALL, true, 'default', []]);\n\n  expect(jest.mocked(messagePort.postMessage).mock.calls[0][0]).toEqual([\n    PARENT_MESSAGE_OK,\n    67_890,\n  ]);\n});\n\nit('removes the message listener on END message', () => {\n  // So that there are no more open handles preventing Node from exiting\n  messagePort.emit('message', [\n    CHILD_MESSAGE_INITIALIZE,\n    true,\n    './my-fancy-worker',\n  ]);\n\n  messagePort.emit('message', [CHILD_MESSAGE_END, true]);\n\n  expect(messagePort.listenerCount('message')).toBe(0);\n});\n\nit('calls the teardown method ', () => {\n  messagePort.emit('message', [\n    CHILD_MESSAGE_INITIALIZE,\n    true,\n    './my-fancy-worker',\n  ]);\n\n  messagePort.emit('message', [CHILD_MESSAGE_END, true]);\n\n  expect(ended).toBe(true);\n});\n\nit('throws if an invalid message is detected', () => {\n  // Type 27 does not exist.\n  expect(() => {\n    messagePort.emit('message', [27]);\n  }).toThrow(TypeError);\n});\n\nit('throws if child is not forked', () => {\n  // @ts-expect-error: Testing purpose\n  delete messagePort.postMessage;\n\n  messagePort.emit('message', [\n    CHILD_MESSAGE_INITIALIZE,\n    true,\n    './my-fancy-worker',\n  ]);\n\n  expect(() => {\n    messagePort.emit('message', [CHILD_MESSAGE_CALL, true, 'fooWorks', []]);\n  }).toThrow('_worker_threads.parentPort.postMessage is not a function');\n\n  expect(() => {\n    messagePort.emit('message', [CHILD_MESSAGE_CALL, true, 'fooThrows', []]);\n  }).toThrow('_worker_threads.parentPort.postMessage is not a function');\n});\n\nit('handle error if `postMessage` throws an error', () => {\n  messagePort.emit('message', [\n    CHILD_MESSAGE_INITIALIZE,\n    true,\n    './my-fancy-worker',\n  ]);\n\n  jest.mocked(messagePort.postMessage).mockImplementationOnce(() => {\n    throw mockError;\n  });\n\n  messagePort.emit('message', [CHILD_MESSAGE_CALL, true, 'fooWorks', []]);\n  expect(jest.mocked(messagePort.postMessage).mock.calls[1][0]).toEqual([\n    PARENT_MESSAGE_CLIENT_ERROR,\n    'TypeError',\n    'Boo',\n    mockError.stack,\n    {},\n  ]);\n});\n",
  "packages/jest-worker/src/workers/__tests__/threadChild.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-worker/src/workers/__tests__/processChild.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {\n  CHILD_MESSAGE_CALL,\n  CHILD_MESSAGE_END,\n  CHILD_MESSAGE_INITIALIZE,\n  CHILD_MESSAGE_MEM_USAGE,\n  PARENT_MESSAGE_CLIENT_ERROR,\n  PARENT_MESSAGE_MEM_USAGE,\n  PARENT_MESSAGE_OK,\n} from '../../types';\n\nconst spyProcessSend = jest.spyOn(process, 'send');\n\nclass MockExtendedError extends ReferenceError {\n  baz = 123;\n  qux = 456;\n}\n\nconst mockError = new TypeError('Boo');\nconst mockExtendedError = new MockExtendedError('Boo extended');\nconst uninitializedParam = {};\nconst sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\n\nlet ended: boolean;\nlet mockCount: number;\nlet initializeParm = uninitializedParam;\n\nbeforeEach(() => {\n  mockCount = 0;\n  ended = false;\n\n  jest.mock(\n    '../my-fancy-worker',\n    () => {\n      mockCount++;\n\n      return {\n        fooCircularResult() {\n          const circular = {self: undefined as unknown};\n          circular.self = circular;\n          return {error: circular};\n        },\n\n        fooPromiseThrows() {\n          return new Promise((_resolve, reject) => {\n            setTimeout(() => reject(mockError), 5);\n          });\n        },\n\n        fooPromiseWorks() {\n          return new Promise(resolve => {\n            setTimeout(() => resolve(1989), 5);\n          });\n        },\n\n        fooThrows() {\n          throw mockError;\n        },\n\n        fooThrowsANumber() {\n          // eslint-disable-next-line no-throw-literal\n          throw 412;\n        },\n\n        fooThrowsAnErrorWithExtraProperties() {\n          mockExtendedError.baz = 123;\n          mockExtendedError.qux = 456;\n\n          throw mockExtendedError;\n        },\n\n        fooThrowsNull() {\n          // eslint-disable-next-line no-throw-literal\n          throw null;\n        },\n\n        fooWorks() {\n          return 1989;\n        },\n\n        setup(param: Record<string, unknown>) {\n          initializeParm = param;\n        },\n\n        teardown() {\n          ended = true;\n        },\n      };\n    },\n    {virtual: true},\n  );\n\n  jest.mock(\n    '../my-fancy-standalone-worker',\n    () => jest.fn().mockImplementation(() => 12_345),\n    {virtual: true},\n  );\n\n  // This mock emulates a transpiled Babel module that carries a default export\n  // that corresponds to a method.\n  jest.mock(\n    '../my-fancy-babel-worker',\n    () => ({\n      __esModule: true,\n      default: jest.fn().mockImplementation(() => 67_890),\n    }),\n    {virtual: true},\n  );\n\n  // Require the child!\n  require('../processChild');\n});\n\nafterEach(() => {\n  jest.clearAllMocks().resetModules();\n\n  process.removeAllListeners('message');\n});\n\nit('lazily requires the file', () => {\n  expect(mockCount).toBe(0);\n\n  process.emit(\n    'message',\n    [\n      CHILD_MESSAGE_INITIALIZE,\n      true, // Not really used here, but for type purity.\n      './my-fancy-worker',\n    ],\n    null,\n  );\n\n  expect(mockCount).toBe(0);\n  expect(initializeParm).toBe(uninitializedParam); // Not called yet.\n\n  process.emit(\n    'message',\n    [\n      CHILD_MESSAGE_CALL,\n      true, // Not really used here, but for type purity.\n      'fooWorks',\n      [],\n    ],\n    null,\n  );\n\n  expect(mockCount).toBe(1);\n  expect(initializeParm).toBeUndefined();\n});\n\nit('should return memory usage', () => {\n  expect(mockCount).toBe(0);\n\n  process.emit('message', [CHILD_MESSAGE_MEM_USAGE], null);\n\n  expect(spyProcessSend.mock.calls[0][0]).toEqual([\n    PARENT_MESSAGE_MEM_USAGE,\n    expect.any(Number),\n  ]);\n});\n\nit('calls initialize with the correct arguments', () => {\n  expect(mockCount).toBe(0);\n\n  process.emit(\n    'message',\n    [\n      CHILD_MESSAGE_INITIALIZE,\n      true, // Not really used here, but for type purity.\n      './my-fancy-worker',\n      ['foo'], // Pass empty initialize params so the initialize method is called.\n    ],\n    null,\n  );\n\n  process.emit(\n    'message',\n    [\n      CHILD_MESSAGE_CALL,\n      true, // Not really used here, but for type purity.\n      'fooWorks',\n      [],\n    ],\n    null,\n  );\n\n  expect(initializeParm).toBe('foo');\n});\n\nit('returns results immediately when function is synchronous', () => {\n  process.emit(\n    'message',\n    [\n      CHILD_MESSAGE_INITIALIZE,\n      true, // Not really used here, but for type purity.\n      './my-fancy-worker',\n    ],\n    null,\n  );\n\n  process.emit(\n    'message',\n    [\n      CHILD_MESSAGE_CALL,\n      true, // Not really used here, but for type purity.\n      'fooWorks',\n      [],\n    ],\n    null,\n  );\n\n  expect(spyProcessSend.mock.calls[0][0]).toEqual([PARENT_MESSAGE_OK, 1989]);\n\n  process.emit(\n    'message',\n    [\n      CHILD_MESSAGE_CALL,\n      true, // Not really used here, but for type purity.\n      'fooThrows',\n      [],\n    ],\n    null,\n  );\n\n  expect(spyProcessSend.mock.calls[1][0]).toEqual([\n    PARENT_MESSAGE_CLIENT_ERROR,\n    'TypeError',\n    'Boo',\n    mockError.stack,\n    {},\n  ]);\n\n  process.emit(\n    'message',\n    [\n      CHILD_MESSAGE_CALL,\n      true, // Not really used here, but for type purity.\n      'fooThrowsANumber',\n      [],\n    ],\n    null,\n  );\n\n  expect(spyProcessSend.mock.calls[2][0]).toEqual([\n    PARENT_MESSAGE_CLIENT_ERROR,\n    'Number',\n    void 0,\n    void 0,\n    412,\n  ]);\n\n  process.emit(\n    'message',\n    [\n      CHILD_MESSAGE_CALL,\n      true, // Not really used here, but for type purity.\n      'fooThrowsAnErrorWithExtraProperties',\n      [],\n    ],\n    null,\n  );\n\n  expect(spyProcessSend.mock.calls[3][0]).toEqual([\n    PARENT_MESSAGE_CLIENT_ERROR,\n    'MockExtendedError',\n    'Boo extended',\n    mockExtendedError.stack,\n    {baz: 123, qux: 456},\n  ]);\n\n  process.emit(\n    'message',\n    [\n      CHILD_MESSAGE_CALL,\n      true, // Not really used here, but for type purity.\n      'fooThrowsNull',\n      [],\n    ],\n    null,\n  );\n\n  expect(spyProcessSend.mock.calls[4][0][0]).toBe(PARENT_MESSAGE_CLIENT_ERROR);\n  expect(spyProcessSend.mock.calls[4][0][1]).toBe('Error');\n  expect(spyProcessSend.mock.calls[4][0][2]).toBe(\n    '\"null\" or \"undefined\" thrown',\n  );\n\n  expect(spyProcessSend).toHaveBeenCalledTimes(5);\n});\n\nit('returns results when it gets resolved if function is asynchronous', async () => {\n  process.emit(\n    'message',\n    [\n      CHILD_MESSAGE_INITIALIZE,\n      true, // Not really used here, but for type purity.\n      './my-fancy-worker',\n    ],\n    null,\n  );\n\n  process.emit(\n    'message',\n    [\n      CHILD_MESSAGE_CALL,\n      true, // Not really used here, but for type purity.\n      'fooPromiseWorks',\n      [],\n    ],\n    null,\n  );\n\n  await sleep(10);\n\n  expect(spyProcessSend.mock.calls[0][0]).toEqual([PARENT_MESSAGE_OK, 1989]);\n\n  process.emit(\n    'message',\n    [\n      CHILD_MESSAGE_CALL,\n      true, // Not really used here, but for type purity.\n      'fooPromiseThrows',\n      [],\n    ],\n    null,\n  );\n\n  await sleep(10);\n\n  expect(spyProcessSend.mock.calls[1][0]).toEqual([\n    PARENT_MESSAGE_CLIENT_ERROR,\n    'TypeError',\n    'Boo',\n    mockError.stack,\n    {},\n  ]);\n\n  expect(spyProcessSend).toHaveBeenCalledTimes(2);\n});\n\nit('returns results with circular references', () => {\n  process.emit(\n    'message',\n    [\n      CHILD_MESSAGE_INITIALIZE,\n      true, // Not really used here, but for type purity.\n      './my-fancy-worker',\n    ],\n    null,\n  );\n\n  process.emit(\n    'message',\n    [\n      CHILD_MESSAGE_CALL,\n      true, // Not really used here, but for type purity.\n      'fooCircularResult',\n      [],\n    ],\n    null,\n  );\n\n  const processCallError = spyProcessSend.mock.calls[0][0][1].error;\n  expect(processCallError.self).toBe(processCallError.self.self);\n});\n\nit('calls the main module if the method call is \"default\"', () => {\n  process.emit(\n    'message',\n    [\n      CHILD_MESSAGE_INITIALIZE,\n      true, // Not really used here, but for type purity.\n      './my-fancy-standalone-worker',\n    ],\n    null,\n  );\n\n  process.emit(\n    'message',\n    [\n      CHILD_MESSAGE_CALL,\n      true, // Not really used here, but for type purity.\n      'default',\n      [],\n    ],\n    null,\n  );\n\n  expect(spyProcessSend.mock.calls[0][0]).toEqual([PARENT_MESSAGE_OK, 12_345]);\n});\n\nit('calls the main export if the method call is \"default\" and it is a Babel transpiled one', () => {\n  process.emit(\n    'message',\n    [\n      CHILD_MESSAGE_INITIALIZE,\n      true, // Not really used here, but for type purity.\n      './my-fancy-babel-worker',\n    ],\n    null,\n  );\n\n  process.emit(\n    'message',\n    [\n      CHILD_MESSAGE_CALL,\n      true, // Not really used here, but for type purity.\n      'default',\n      [],\n    ],\n    null,\n  );\n\n  expect(spyProcessSend.mock.calls[0][0]).toEqual([PARENT_MESSAGE_OK, 67_890]);\n});\n\nit('removes the message listener on END message', () => {\n  // So that there are no more open handles preventing Node from exiting\n  process.emit(\n    'message',\n    [\n      CHILD_MESSAGE_INITIALIZE,\n      true, // Not really used here, but for type purity.\n      './my-fancy-worker',\n    ],\n    null,\n  );\n\n  process.emit('message', [CHILD_MESSAGE_END], null);\n\n  expect(process.listenerCount('message')).toBe(0);\n});\n\nit('calls the teardown method ', () => {\n  process.emit(\n    'message',\n    [\n      CHILD_MESSAGE_INITIALIZE,\n      true, // Not really used here, but for type purity.\n      './my-fancy-worker',\n    ],\n    null,\n  );\n\n  process.emit(\n    'message',\n    [\n      CHILD_MESSAGE_END,\n      true, // Not really used here, but for type purity.\n    ],\n    null,\n  );\n\n  expect(ended).toBe(true);\n});\n\nit('throws if an invalid message is detected', () => {\n  // Type 27 does not exist.\n  expect(() => {\n    process.emit('message', [27], null);\n  }).toThrow(TypeError);\n});\n\nit('throws if child is not forked', () => {\n  delete process.send;\n\n  process.emit(\n    'message',\n    [\n      CHILD_MESSAGE_INITIALIZE,\n      true, // Not really used here, but for type purity.\n      './my-fancy-worker',\n    ],\n    null,\n  );\n\n  expect(() => {\n    process.emit(\n      'message',\n      [\n        CHILD_MESSAGE_CALL,\n        true, // Not really used here, but for type purity.\n        'fooWorks',\n        [],\n      ],\n      null,\n    );\n  }).toThrow('Child can only be used on a forked process');\n\n  expect(() => {\n    process.emit(\n      'message',\n      [\n        CHILD_MESSAGE_CALL,\n        true, // Not really used here, but for type purity.\n        'fooThrows',\n        [],\n      ],\n      null,\n    );\n  }).toThrow('Child can only be used on a forked process');\n});\n",
  "packages/jest-worker/src/workers/__tests__/processChild.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-worker/src/workers/__tests__/WorkerEdgeCases.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {access, mkdir, rm, writeFile} from 'fs/promises';\nimport {dirname, join} from 'path';\nimport {transformFileAsync} from '@babel/core';\nimport {\n  CHILD_MESSAGE_CALL,\n  WorkerEvents,\n  type WorkerOptions,\n  WorkerStates,\n} from '../../types';\nimport ChildProcessWorker, {SIGKILL_DELAY} from '../ChildProcessWorker';\nimport ThreadsWorker from '../NodeThreadsWorker';\n\njest.setTimeout(10_000);\n\nconst root = join('../../');\nconst filesToBuild = [\n  'workers/processChild',\n  'workers/threadChild',\n  'workers/safeMessageTransferring',\n  'workers/isDataCloneError',\n  'types',\n];\nconst writeDestination = join(__dirname, '__temp__');\nconst processChildWorkerPath = join(\n  writeDestination,\n  'workers/processChild.js',\n);\nconst threadChildWorkerPath = join(writeDestination, 'workers/threadChild.js');\n\n// https://github.com/nodejs/node/issues/51766\nif (\n  process.platform === 'win32' &&\n  (process.version.startsWith('v21.') ||\n    process.version.startsWith('v22.') ||\n    process.version.startsWith('v23.'))\n) {\n  // eslint-disable-next-line jest/no-focused-tests\n  test.only('skipping test on broken platform', () => {\n    console.warn('Skipping test on broken platform');\n  });\n}\n\nbeforeAll(async () => {\n  await mkdir(writeDestination, {recursive: true});\n\n  for (const file of filesToBuild) {\n    const sourcePath = join(__dirname, root, `${file}.ts`);\n    const writePath = join(writeDestination, `${file}.js`);\n\n    await mkdir(dirname(writePath), {recursive: true});\n\n    const result = await transformFileAsync(sourcePath);\n\n    await writeFile(writePath, result!.code!, 'utf8');\n  }\n});\n\nafterAll(async () => {\n  await rm(writeDestination, {force: true, recursive: true});\n});\n\ntest.each(filesToBuild)('%s.js should exist', file => {\n  const path = join(writeDestination, `${file}.js`);\n\n  expect(async () => access(path)).not.toThrow();\n});\n\nasync function closeWorkerAfter(\n  worker: ChildProcessWorker | ThreadsWorker,\n  testBody: (worker: ChildProcessWorker | ThreadsWorker) => Promise<void>,\n) {\n  try {\n    await testBody(worker);\n  } finally {\n    worker.forceExit();\n    await worker.waitForExit();\n  }\n}\n\ndescribe.each([\n  {\n    name: 'ProcessWorker',\n    workerClass: ChildProcessWorker,\n    workerPath: processChildWorkerPath,\n  },\n  {\n    name: 'ThreadWorker',\n    workerClass: ThreadsWorker,\n    workerPath: threadChildWorkerPath,\n  },\n])('$name', ({workerClass, workerPath}) => {\n  let int: NodeJS.Timeout;\n\n  afterEach(async () => {\n    clearInterval(int);\n  });\n\n  function waitForChange(fn: () => unknown) {\n    const initial = fn();\n\n    return new Promise((resolve, reject) => {\n      let count = 0;\n\n      int = setInterval(() => {\n        const updated = fn();\n\n        if (initial !== updated) {\n          resolve(updated);\n          clearInterval(int);\n        }\n\n        if (count > 100_000) {\n          reject(new Error('Timeout waiting for change'));\n        }\n\n        count++;\n      }, 1);\n    });\n  }\n\n  test('should get memory usage', async () => {\n    await closeWorkerAfter(\n      new workerClass({\n        childWorkerPath: workerPath,\n        maxRetries: 0,\n        workerPath: join(__dirname, '__fixtures__', 'EdgeCasesWorker'),\n      } as WorkerOptions),\n      async (worker: ChildProcessWorker | ThreadsWorker) => {\n        const memoryUsagePromise = worker.getMemoryUsage();\n        expect(memoryUsagePromise).toBeInstanceOf(Promise);\n\n        expect(await memoryUsagePromise).toBeGreaterThan(0);\n      },\n    );\n  });\n\n  test('should recycle on idle limit breach', async () => {\n    await closeWorkerAfter(\n      new workerClass({\n        childWorkerPath: workerPath,\n        // There is no way this is fitting into 1000 bytes, so it should restart\n        // after requesting a memory usage update\n        idleMemoryLimit: 1000,\n        maxRetries: 0,\n        workerPath: join(__dirname, '__fixtures__', 'EdgeCasesWorker'),\n      } as WorkerOptions),\n      async (worker: ChildProcessWorker | ThreadsWorker) => {\n        const startSystemId = worker.getWorkerSystemId();\n        expect(startSystemId).toBeGreaterThanOrEqual(0);\n\n        worker.checkMemoryUsage();\n\n        await waitForChange(() => worker.getWorkerSystemId());\n\n        const systemId = worker.getWorkerSystemId();\n        expect(systemId).toBeGreaterThanOrEqual(0);\n        expect(systemId).not.toEqual(startSystemId);\n\n        await new Promise(resolve => {\n          setTimeout(resolve, SIGKILL_DELAY + 100);\n        });\n\n        expect(worker.isWorkerRunning()).toBeTruthy();\n      },\n    );\n  });\n\n  describe('should automatically recycle on idle limit breach', () => {\n    let startPid: number;\n    let worker: ChildProcessWorker | ThreadsWorker;\n    const orderOfEvents: Array<WorkerStates> = [];\n\n    beforeAll(() => {\n      worker = new workerClass({\n        childWorkerPath: workerPath,\n        // There is no way this is fitting into 1000 bytes, so it should restart\n        // after requesting a memory usage update\n        idleMemoryLimit: 1000,\n        maxRetries: 0,\n        on: {\n          [WorkerEvents.STATE_CHANGE]: (state: WorkerStates) => {\n            orderOfEvents.push(state);\n          },\n        },\n        silent: true,\n        workerPath: join(__dirname, '__fixtures__', 'EdgeCasesWorker'),\n      } as unknown as WorkerOptions);\n    });\n\n    afterAll(async () => {\n      if (worker) {\n        worker.forceExit();\n        await worker.waitForExit();\n      }\n    });\n\n    test('initial state', async () => {\n      startPid = worker.getWorkerSystemId();\n      expect(startPid).toBeGreaterThanOrEqual(0);\n      expect(worker.state).toEqual(WorkerStates.OK);\n\n      expect(orderOfEvents).toEqual(['ok']);\n    });\n\n    test('new worker starts', async () => {\n      const onStart = jest.fn();\n      const onEnd = jest.fn();\n      const onCustom = jest.fn();\n\n      worker.send(\n        [CHILD_MESSAGE_CALL, true, 'safeFunction', []],\n        onStart,\n        onEnd,\n        onCustom,\n      );\n\n      await waitForChange(() => worker.getWorkerSystemId());\n\n      const endPid = worker.getWorkerSystemId();\n      expect(endPid).toBeGreaterThanOrEqual(0);\n      expect(endPid).not.toEqual(startPid);\n      expect(worker.isWorkerRunning()).toBeTruthy();\n      expect(worker.state).toEqual(WorkerStates.OK);\n    });\n\n    test(\n      'worker continues to run after kill delay',\n      async () => {\n        await new Promise(resolve => {\n          setTimeout(resolve, SIGKILL_DELAY + 100);\n        });\n\n        expect(worker.state).toEqual(WorkerStates.OK);\n        expect(worker.isWorkerRunning()).toBeTruthy();\n      },\n      SIGKILL_DELAY * 3,\n    );\n\n    test('expected state order', () => {\n      expect(orderOfEvents).toEqual(['ok', 'restarting', 'starting', 'ok']);\n    });\n  });\n\n  describe('should cleanly exit on out of memory crash', () => {\n    const workerHeapLimit = 50;\n\n    let worker: ChildProcessWorker | ThreadsWorker;\n    let orderOfEvents: Array<WorkerStates> = [];\n\n    beforeAll(() => {\n      orderOfEvents = [];\n\n      const options = {\n        childWorkerPath: workerPath,\n        maxRetries: 0,\n        on: {\n          [WorkerEvents.STATE_CHANGE]: (state: WorkerStates) => {\n            orderOfEvents.push(state);\n          },\n        },\n        silent: true,\n        workerPath: join(__dirname, '__fixtures__', 'EdgeCasesWorker'),\n      } as unknown as WorkerOptions;\n\n      if (workerClass === ThreadsWorker) {\n        options.resourceLimits = {\n          codeRangeSizeMb: workerHeapLimit * 2,\n          maxOldGenerationSizeMb: workerHeapLimit,\n          maxYoungGenerationSizeMb: workerHeapLimit * 2,\n          stackSizeMb: workerHeapLimit * 2,\n        };\n      } else if (workerClass === ChildProcessWorker) {\n        options.forkOptions = {\n          // Forcibly set the heap limit so we can crash the process easily.\n          execArgv: [`--max-old-space-size=${workerHeapLimit}`],\n        };\n      }\n\n      worker = new workerClass(options);\n    });\n\n    afterAll(async () => {\n      await new Promise<void>(resolve => {\n        setTimeout(async () => {\n          if (worker) {\n            worker.forceExit();\n            await worker.waitForExit();\n          }\n\n          resolve();\n        }, 500);\n      });\n    });\n\n    test('starting state', async () => {\n      const startPid = worker.getWorkerSystemId();\n      expect(startPid).toBeGreaterThanOrEqual(0);\n    });\n\n    test('worker ready', async () => {\n      await worker.waitForWorkerReady();\n      expect(worker.state).toEqual(WorkerStates.OK);\n    });\n\n    test('worker crashes and exits', async () => {\n      const onStart = jest.fn();\n      const onEnd = jest.fn();\n      const onCustom = jest.fn();\n\n      worker.send(\n        [CHILD_MESSAGE_CALL, true, 'leakMemory', []],\n        onStart,\n        onEnd,\n        onCustom,\n      );\n\n      await worker.waitForExit();\n\n      expect(worker.state).not.toEqual(WorkerStates.OK);\n    });\n\n    test('worker stays dead', async () => {\n      await expect(async () => worker.waitForWorkerReady()).rejects.toThrow(\n        'Worker state means it will never be ready: shut-down',\n      );\n      expect(worker.isWorkerRunning()).toBeFalsy();\n    });\n\n    test('expected state order', () => {\n      expect(orderOfEvents).toEqual([\n        WorkerStates.OK,\n        WorkerStates.OUT_OF_MEMORY,\n        WorkerStates.SHUT_DOWN,\n      ]);\n    });\n  });\n\n  describe('should handle regular fatal crashes', () => {\n    let worker: ChildProcessWorker | ThreadsWorker;\n    let startedWorkers = 0;\n\n    beforeAll(() => {\n      worker = new workerClass({\n        childWorkerPath: workerPath,\n        maxRetries: 4,\n        on: {\n          [WorkerEvents.STATE_CHANGE]: (state: WorkerStates) => {\n            if (state === WorkerStates.OK) {\n              startedWorkers++;\n            }\n          },\n        },\n        workerPath: join(__dirname, '__fixtures__', 'EdgeCasesWorker'),\n      } as unknown as WorkerOptions);\n    });\n\n    afterAll(async () => {\n      if (worker) {\n        worker.forceExit();\n        await worker.waitForExit();\n      }\n    });\n\n    test('starting state', async () => {\n      const startPid = worker.getWorkerSystemId();\n      expect(startPid).toBeGreaterThanOrEqual(0);\n    });\n\n    test('processes restart', async () => {\n      const onStart = jest.fn();\n      const onEnd = jest.fn();\n      const onCustom = jest.fn();\n\n      worker.send(\n        [CHILD_MESSAGE_CALL, true, 'fatalExitCode', []],\n        onStart,\n        onEnd,\n        onCustom,\n      );\n\n      // Give it some time to restart some workers\n      await new Promise(resolve => setTimeout(resolve, 4000));\n\n      expect(startedWorkers).toBe(6);\n\n      expect(worker.isWorkerRunning()).toBeTruthy();\n      expect(worker.state).toEqual(WorkerStates.OK);\n    });\n\n    test('processes exits', async () => {\n      worker.forceExit();\n\n      await expect(() => worker.waitForWorkerReady()).rejects.toThrow(\n        'Worker state means it will never be ready: shutting-down',\n      );\n    });\n  });\n\n  describe('should not hang when worker is killed or unexpectedly terminated', () => {\n    let worker: ChildProcessWorker | ThreadsWorker;\n\n    beforeEach(() => {\n      const options = {\n        childWorkerPath: processChildWorkerPath,\n        maxRetries: 0,\n        silent: true,\n        workerPath: join(__dirname, '__fixtures__', 'SelfKillWorker'),\n      } as unknown as WorkerOptions;\n\n      worker = new ChildProcessWorker(options);\n    });\n\n    afterEach(async () => {\n      await new Promise<void>(resolve => {\n        setTimeout(async () => {\n          if (worker) {\n            worker.forceExit();\n            await worker.waitForExit();\n          }\n\n          resolve();\n        }, 500);\n      });\n    });\n\n    // Regression test for https://github.com/jestjs/jest/issues/13183\n    test('onEnd callback is called', async () => {\n      let onEndPromiseResolve: () => void;\n      let onEndPromiseReject: (err: Error) => void;\n      const onEndPromise = new Promise<void>((resolve, reject) => {\n        onEndPromiseResolve = resolve;\n        onEndPromiseReject = reject;\n      });\n\n      const onStart = jest.fn();\n      const onEnd = jest.fn((err: Error | null) => {\n        if (err) {\n          return onEndPromiseReject(err);\n        }\n        onEndPromiseResolve();\n      });\n      const onCustom = jest.fn();\n\n      await worker.waitForWorkerReady();\n\n      // The SelfKillWorker simulates an external process calling SIGTERM on it,\n      // but just SIGTERMs itself underneath the hood to make this test easier.\n      worker.send(\n        [CHILD_MESSAGE_CALL, true, 'selfKill', []],\n        onStart,\n        onEnd,\n        onCustom,\n      );\n\n      // The onEnd callback should be called when the child process exits.\n      await expect(onEndPromise).rejects.toBeInstanceOf(Error);\n      expect(onEnd).toHaveBeenCalled();\n    });\n  });\n});\n",
  "packages/jest-worker/src/workers/__tests__/WorkerEdgeCases.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-worker/src/workers/__tests__/NodeThreadsWorker.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {EventEmitter} from 'events';\nimport {PassThrough} from 'stream';\nimport getStream from 'get-stream';\nimport {\n  CHILD_MESSAGE_CALL,\n  CHILD_MESSAGE_INITIALIZE,\n  type ChildMessageCall,\n  PARENT_MESSAGE_CLIENT_ERROR,\n  PARENT_MESSAGE_CUSTOM,\n  PARENT_MESSAGE_OK,\n  type WorkerOptions,\n} from '../../types';\n\nlet Worker: typeof import('../NodeThreadsWorker').default;\nlet workerThreads: typeof import('worker_threads').Worker;\nlet originalExecArgv: typeof process.execArgv;\n\nclass MockedWorker extends EventEmitter {\n  postMessage = jest.fn();\n  terminate = jest.fn();\n  stdout = new PassThrough();\n  stderr = new PassThrough();\n}\n\nbeforeEach(() => {\n  jest.mock('worker_threads', () => {\n    return {\n      Worker: jest.fn(() => new MockedWorker()),\n    };\n  });\n  originalExecArgv = process.execArgv;\n\n  workerThreads = (require('worker_threads') as typeof import('worker_threads'))\n    .Worker;\n\n  Worker = (\n    require('../NodeThreadsWorker') as typeof import('../NodeThreadsWorker')\n  ).default;\n});\n\nafterEach(() => {\n  jest.resetModules();\n  process.execArgv = originalExecArgv;\n});\n\nit('passes fork options down to worker_threads.Worker, adding the defaults', () => {\n  const thread = require.resolve('../threadChild');\n\n  // eslint-disable-next-line no-new\n  new Worker({\n    forkOptions: {\n      execArgv: ['--inspect', '-p'],\n      execPath: 'hello',\n    },\n    maxRetries: 3,\n    workerData: {\n      foo: 'bar',\n    },\n    workerId: Number(process.env.JEST_WORKER_ID) - 1,\n    workerPath: '/tmp/foo/bar/baz.js',\n  } as WorkerOptions);\n\n  expect(jest.mocked(workerThreads).mock.calls[0][0]).toBe(thread);\n  expect(jest.mocked(workerThreads).mock.calls[0][1]).toEqual({\n    eval: false,\n    execArgv: ['--inspect', '-p'],\n    execPath: 'hello', // Added option.\n    resourceLimits: undefined,\n    stderr: true,\n    stdout: true,\n    workerData: {\n      // Added option.\n      foo: 'bar',\n    },\n  });\n});\n\nit('initializes the thread with the given workerPath and workerId', () => {\n  const worker = new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    setupArgs: ['foo', 'bar'],\n    workerId: 2,\n    workerPath: '/tmp/foo/bar/baz.js',\n  } as WorkerOptions);\n\n  // @ts-expect-error: Testing internal method\n  expect(jest.mocked(worker._worker.postMessage).mock.calls[0][0]).toEqual([\n    CHILD_MESSAGE_INITIALIZE,\n    false,\n    '/tmp/foo/bar/baz.js',\n    ['foo', 'bar'],\n    '3',\n  ]);\n});\n\nit('stops initializing the worker after the amount of retries is exceeded', () => {\n  const worker = new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    workerPath: '/tmp/foo/bar/baz.js',\n  } as WorkerOptions);\n\n  const request = [CHILD_MESSAGE_CALL, false, 'foo', []] as ChildMessageCall;\n  const onProcessStart = jest.fn();\n  const onProcessEnd = jest.fn();\n\n  worker.send(request, onProcessStart, onProcessEnd, () => {});\n\n  // We fail four times (initial + three retries).\n  // @ts-expect-error: Testing internal method\n  worker._worker.emit('exit');\n  // @ts-expect-error: Testing internal method\n  worker._worker.emit('exit');\n  // @ts-expect-error: Testing internal method\n  worker._worker.emit('exit');\n  // @ts-expect-error: Testing internal method\n  worker._worker.emit('exit');\n\n  expect(workerThreads).toHaveBeenCalledTimes(5);\n  expect(onProcessStart).toHaveBeenCalledWith(worker);\n  expect(onProcessEnd).toHaveBeenCalledTimes(1);\n  expect(onProcessEnd.mock.calls[0][0]).toBeInstanceOf(Error);\n  expect(onProcessEnd.mock.calls[0][0]).toMatchObject({type: 'WorkerError'});\n  expect(onProcessEnd.mock.calls[0][1]).toBeNull();\n});\n\nit('provides stdout and stderr from the threads', async () => {\n  const worker = new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  const stdout = worker.getStdout();\n  const stderr = worker.getStderr();\n\n  // @ts-expect-error: Testing internal method\n  worker._worker.stdout.end('Hello ', 'utf8');\n  // @ts-expect-error: Testing internal method\n  worker._worker.stderr.end('Jest ', 'utf8');\n  // @ts-expect-error: Testing internal method\n  worker._worker.emit('exit');\n  // @ts-expect-error: Testing internal method\n  worker._worker.stdout.end('World!', 'utf8');\n  // @ts-expect-error: Testing internal method\n  worker._worker.stderr.end('Workers!', 'utf8');\n  // @ts-expect-error: Testing internal method\n  worker._worker.emit('exit', 0);\n\n  await expect(getStream(stdout!)).resolves.toBe('Hello World!');\n  await expect(getStream(stderr!)).resolves.toBe('Jest Workers!');\n});\n\nit('sends the task to the thread', () => {\n  const worker = new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  const request = [CHILD_MESSAGE_CALL, false, 'foo', []] as ChildMessageCall;\n\n  worker.send(\n    request,\n    () => {},\n    () => {},\n    () => {},\n  );\n\n  // Skipping call \"0\" because it corresponds to the \"initialize\" one.\n  // @ts-expect-error: Testing internal method\n  expect(jest.mocked(worker._worker.postMessage).mock.calls[1][0]).toEqual(\n    request,\n  );\n});\n\nit('resends the task to the thread after a retry', () => {\n  const worker = new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    workerPath: '/tmp/foo/bar/baz.js',\n  } as WorkerOptions);\n\n  const request = [CHILD_MESSAGE_CALL, false, 'foo', []] as ChildMessageCall;\n\n  worker.send(\n    request,\n    () => {},\n    () => {},\n    () => {},\n  );\n\n  // Skipping call \"0\" because it corresponds to the \"initialize\" one.\n  // @ts-expect-error: Testing internal method\n  expect(jest.mocked(worker._worker.postMessage).mock.calls[1][0]).toEqual(\n    request,\n  );\n\n  // @ts-expect-error: Testing internal method\n  const previousWorker = worker._worker;\n  // @ts-expect-error: Testing internal method\n  worker._worker.emit('exit');\n\n  // @ts-expect-error: Testing internal method\n  expect(worker._worker).not.toBe(previousWorker);\n\n  // Skipping call \"0\" because it corresponds to the \"initialize\" one.\n  // @ts-expect-error: Testing internal method\n  expect(jest.mocked(worker._worker.postMessage).mock.calls[1][0]).toEqual(\n    request,\n  );\n});\n\nit('calls the onProcessStart method synchronously if the queue is empty', () => {\n  const worker = new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  const onProcessStart = jest.fn();\n  const onProcessEnd = jest.fn();\n\n  worker.send(\n    [CHILD_MESSAGE_CALL, false, 'foo', []],\n    onProcessStart,\n    onProcessEnd,\n    () => {},\n  );\n\n  // Only onProcessStart has been called\n  expect(onProcessStart).toHaveBeenCalledTimes(1);\n  expect(onProcessEnd).not.toHaveBeenCalled();\n\n  // then first call replies...\n  // @ts-expect-error: Testing internal method\n  worker._worker.emit('message', [PARENT_MESSAGE_OK]);\n\n  expect(onProcessEnd).toHaveBeenCalledTimes(1);\n});\n\nit('can send multiple messages to parent', () => {\n  const worker = new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  const onProcessStart = jest.fn();\n  const onProcessEnd = jest.fn();\n  const onCustomMessage = jest.fn();\n\n  worker.send(\n    [CHILD_MESSAGE_CALL, false, 'foo', []],\n    onProcessStart,\n    onProcessEnd,\n    onCustomMessage,\n  );\n\n  // Only onProcessStart has been called\n  expect(onProcessStart).toHaveBeenCalledTimes(1);\n  expect(onProcessEnd).not.toHaveBeenCalled();\n  expect(onCustomMessage).not.toHaveBeenCalled();\n\n  // then first call replies...\n  // @ts-expect-error: Testing internal method\n  worker._worker.emit('message', [\n    PARENT_MESSAGE_CUSTOM,\n    {message: 'foo bar', otherKey: 1},\n  ]);\n\n  expect(onProcessEnd).not.toHaveBeenCalled();\n  expect(onCustomMessage).toHaveBeenCalledTimes(1);\n  expect(onCustomMessage).toHaveBeenCalledWith({\n    message: 'foo bar',\n    otherKey: 1,\n  });\n});\n\nit('creates error instances for known errors', () => {\n  const worker = new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  const callback1 = jest.fn();\n  const callback2 = jest.fn();\n  const callback3 = jest.fn();\n\n  // Testing a generic ECMAScript error.\n  worker.send(\n    [CHILD_MESSAGE_CALL, false, 'method', []],\n    () => {},\n    callback1,\n    () => {},\n  );\n\n  // @ts-expect-error: Testing internal method\n  worker._worker.emit('message', [\n    PARENT_MESSAGE_CLIENT_ERROR,\n    'TypeError',\n    'bar',\n    'TypeError: bar',\n    {},\n  ]);\n\n  expect(callback1.mock.calls[0][0]).toBeInstanceOf(TypeError);\n  expect(callback1.mock.calls[0][0]).toMatchObject({\n    message: 'bar',\n    stack: 'TypeError: bar',\n    type: 'TypeError',\n  });\n\n  // Testing a custom error.\n  worker.send(\n    [CHILD_MESSAGE_CALL, false, 'method', []],\n    () => {},\n    callback2,\n    () => {},\n  );\n\n  // @ts-expect-error: Testing internal method\n  worker._worker.emit('message', [\n    PARENT_MESSAGE_CLIENT_ERROR,\n    'RandomCustomError',\n    'bar',\n    'RandomCustomError: bar',\n    {qux: 'extra property'},\n  ]);\n\n  expect(callback2.mock.calls[0][0]).toBeInstanceOf(Error);\n  expect(callback2.mock.calls[0][0]).toMatchObject({\n    message: 'bar',\n    qux: 'extra property',\n    stack: 'RandomCustomError: bar',\n    type: 'RandomCustomError',\n  });\n\n  // Testing a non-object throw.\n  worker.send(\n    [CHILD_MESSAGE_CALL, false, 'method', []],\n    () => {},\n    callback3,\n    () => {},\n  );\n\n  // @ts-expect-error: Testing internal method\n  worker._worker.emit('message', [\n    PARENT_MESSAGE_CLIENT_ERROR,\n    'Number',\n    null,\n    null,\n    412,\n  ]);\n\n  expect(callback3.mock.calls[0][0]).toBe(412);\n});\n\nit('does not throw when the thread returns a strange message', () => {\n  const worker = new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  worker.send(\n    [CHILD_MESSAGE_CALL, false, 'method', []],\n    () => {},\n    () => {},\n    () => {},\n  );\n\n  // Type 27 does not exist.\n  // @ts-expect-error: Testing internal method\n  worker._worker.emit('message', [27]);\n\n  // @ts-expect-error: Testing internal method\n  worker._worker.emit('message', 'test');\n\n  // @ts-expect-error: Testing internal method\n  worker._worker.emit('message', {foo: 'bar'});\n\n  // @ts-expect-error: Testing internal method\n  worker._worker.emit('message', 0);\n\n  // @ts-expect-error: Testing internal method\n  worker._worker.emit('message', null);\n\n  // @ts-expect-error: Testing internal method\n  worker._worker.emit('message', Symbol('test'));\n\n  // @ts-expect-error: Testing internal method\n  worker._worker.emit('message', true);\n});\n\nit('does not restart the thread if it cleanly exited', () => {\n  const worker = new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  expect(workerThreads).toHaveBeenCalledTimes(1);\n  // @ts-expect-error: Testing internal method\n  worker._worker.emit('exit', 0);\n  expect(workerThreads).toHaveBeenCalledTimes(1);\n});\n\nit('resolves waitForExit() after the thread cleanly exited', async () => {\n  const worker = new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  expect(workerThreads).toHaveBeenCalledTimes(1);\n  // @ts-expect-error: Testing internal method\n  worker._worker.emit('exit', 0);\n  await worker.waitForExit(); // should not timeout\n});\n\nit('restarts the thread when the thread dies', () => {\n  const worker = new Worker({\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  expect(workerThreads).toHaveBeenCalledTimes(1);\n  // @ts-expect-error: Testing internal method\n  worker._worker.emit('exit', 1);\n  expect(workerThreads).toHaveBeenCalledTimes(2);\n});\n\nit('terminates the thread when forceExit() is called', () => {\n  const worker = new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  worker.forceExit();\n  // @ts-expect-error: Testing internal method\n  expect(worker._worker.terminate).toHaveBeenCalled();\n});\n",
  "packages/jest-worker/src/workers/__tests__/NodeThreadsWorker.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-worker/src/workers/__tests__/ChildProcessWorker.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {EventEmitter} from 'events';\nimport {PassThrough} from 'stream';\nimport getStream from 'get-stream';\nimport {\n  CHILD_MESSAGE_CALL,\n  CHILD_MESSAGE_INITIALIZE,\n  CHILD_MESSAGE_MEM_USAGE,\n  type ChildMessage,\n  type ChildMessageCall,\n  PARENT_MESSAGE_CLIENT_ERROR,\n  PARENT_MESSAGE_CUSTOM,\n  PARENT_MESSAGE_MEM_USAGE,\n  PARENT_MESSAGE_OK,\n  type WorkerOptions,\n  WorkerStates,\n} from '../../types';\n\njest.useFakeTimers();\n\njest.mock('child_process');\n\nlet Worker: typeof import('../ChildProcessWorker').default;\nlet childProcess: typeof import('child_process');\nlet forkInterface: ReturnType<typeof childProcess.fork>;\nlet originalExecArgv: typeof process.execArgv;\nlet originalForceColor: string | undefined;\n\nconst totalmem = jest.spyOn(require('os') as typeof import('os'), 'totalmem');\n\nclass MockedForkInterface extends EventEmitter {\n  connected = true;\n  kill = jest.fn();\n  send = jest.fn();\n  stderr = new PassThrough();\n  stdout = new PassThrough();\n}\n\nbeforeEach(() => {\n  originalForceColor = process.env.FORCE_COLOR;\n  delete process.env.FORCE_COLOR;\n\n  originalExecArgv = process.execArgv;\n\n  childProcess = require('child_process') as typeof import('child_process');\n  jest.mocked(childProcess.fork).mockImplementation(() => {\n    forkInterface = new MockedForkInterface() as unknown as ReturnType<\n      typeof childProcess.fork\n    >;\n\n    return forkInterface;\n  });\n\n  totalmem.mockReset();\n\n  Worker = (\n    require('../ChildProcessWorker') as typeof import('../ChildProcessWorker')\n  ).default;\n});\n\nafterEach(() => {\n  jest.resetModules();\n  process.execArgv = originalExecArgv;\n  process.env.FORCE_COLOR = originalForceColor;\n});\n\nit('passes fork options down to child_process.fork, adding the defaults', () => {\n  const child = require.resolve('../processChild');\n\n  process.execArgv = ['--inspect', '-p'];\n\n  // eslint-disable-next-line no-new\n  new Worker({\n    forkOptions: {\n      cwd: '/tmp',\n      execPath: 'hello',\n    },\n    maxRetries: 3,\n    workerId: Number(process.env.JEST_WORKER_ID) - 1,\n    workerPath: '/tmp/foo/bar/baz.js',\n  } as WorkerOptions);\n\n  expect(jest.mocked(childProcess.fork).mock.calls[0][0]).toBe(child);\n  expect(jest.mocked(childProcess.fork).mock.calls[0][2]).toEqual({\n    cwd: '/tmp', // Overridden default option.\n    env: process.env, // Default option.\n    execArgv: ['-p'], // Filtered option.\n    execPath: 'hello', // Added option.\n    serialization: 'advanced', // Default option.\n    silent: true, // Default option.\n  });\n});\n\nit('passes workerId to the child process and assign it to 1-indexed env.JEST_WORKER_ID', () => {\n  // eslint-disable-next-line no-new\n  new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    workerId: 2,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  expect(jest.mocked(childProcess.fork).mock.calls[0][2]).toMatchObject({\n    env: {JEST_WORKER_ID: '3'},\n  });\n});\n\nit('initializes the child process with the given workerPath', () => {\n  // eslint-disable-next-line no-new\n  new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    setupArgs: ['foo', 'bar'],\n    workerPath: '/tmp/foo/bar/baz.js',\n  } as WorkerOptions);\n\n  expect(jest.mocked(forkInterface.send).mock.calls[0][0]).toEqual([\n    CHILD_MESSAGE_INITIALIZE,\n    false,\n    '/tmp/foo/bar/baz.js',\n    ['foo', 'bar'],\n  ]);\n});\n\nit('stops initializing the worker after the amount of retries is exceeded', () => {\n  const worker = new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    workerPath: '/tmp/foo/bar/baz.js',\n  } as WorkerOptions);\n\n  const request: ChildMessageCall = [CHILD_MESSAGE_CALL, false, 'foo', []];\n  const onProcessStart = jest.fn();\n  const onProcessEnd = jest.fn();\n\n  worker.send(request, onProcessStart, onProcessEnd, () => {});\n\n  // We fail four times (initial + three retries).\n  forkInterface.emit('exit', 1);\n  forkInterface.emit('exit', 1);\n  forkInterface.emit('exit', 1);\n  forkInterface.emit('exit', 1);\n\n  expect(childProcess.fork).toHaveBeenCalledTimes(5);\n  expect(onProcessStart).toHaveBeenCalledWith(worker);\n  expect(onProcessEnd).toHaveBeenCalledTimes(1);\n  expect(onProcessEnd.mock.calls[0][0]).toBeInstanceOf(Error);\n  expect(onProcessEnd.mock.calls[0][0]).toMatchObject({\n    type: 'WorkerError',\n  });\n  expect(onProcessEnd.mock.calls[0][1]).toBeNull();\n});\n\nit('provides stdout and stderr from the child processes', async () => {\n  const worker = new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  const stdout = worker.getStdout()!;\n  const stderr = worker.getStderr()!;\n\n  (forkInterface.stdout as PassThrough).end('Hello ', 'utf8');\n  (forkInterface.stderr as PassThrough).end('Jest ', 'utf8');\n  forkInterface.emit('exit', 1);\n  (forkInterface.stdout as PassThrough).end('World!', 'utf8');\n  (forkInterface.stderr as PassThrough).end('Workers!', 'utf8');\n  forkInterface.emit('exit', 0);\n\n  await expect(getStream(stdout)).resolves.toBe('Hello World!');\n  await expect(getStream(stderr)).resolves.toBe('Jest Workers!');\n});\n\nit('sends the task to the child process', () => {\n  const worker = new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    setupArgs: [],\n    workerPath: '/tmp/foo',\n  } as unknown as WorkerOptions);\n\n  const request: ChildMessage = [CHILD_MESSAGE_CALL, false, 'foo', []];\n\n  worker.send(\n    request,\n    () => {},\n    () => {},\n    () => {},\n  );\n\n  // Skipping call \"0\" because it corresponds to the \"initialize\" one.\n  expect(jest.mocked(forkInterface.send).mock.calls[1][0]).toEqual(request);\n});\n\nit('resends the task to the child process after a retry', () => {\n  const worker = new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    workerPath: '/tmp/foo/bar/baz.js',\n  } as WorkerOptions);\n\n  const request: ChildMessage = [CHILD_MESSAGE_CALL, false, 'foo', []];\n\n  worker.send(\n    request,\n    () => {},\n    () => {},\n    () => {},\n  );\n\n  // Skipping call \"0\" because it corresponds to the \"initialize\" one.\n  expect(jest.mocked(forkInterface.send).mock.calls[1][0]).toEqual(request);\n\n  const previousForkInterface = forkInterface;\n  forkInterface.emit('exit', 1);\n\n  expect(forkInterface).not.toBe(previousForkInterface);\n\n  // Skipping call \"0\" because it corresponds to the \"initialize\" one.\n  expect(jest.mocked(forkInterface.send).mock.calls[1][0]).toEqual(request);\n});\n\nit('calls the onProcessStart method synchronously if the queue is empty', () => {\n  const worker = new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  const onProcessStart = jest.fn();\n  const onProcessEnd = jest.fn();\n\n  worker.send(\n    [CHILD_MESSAGE_CALL, false, 'foo', []],\n    onProcessStart,\n    onProcessEnd,\n    () => {},\n  );\n\n  // Only onProcessStart has been called\n  expect(onProcessStart).toHaveBeenCalledTimes(1);\n  expect(onProcessEnd).not.toHaveBeenCalled();\n\n  // then first call replies...\n  forkInterface.emit('message', [PARENT_MESSAGE_OK]);\n\n  expect(onProcessEnd).toHaveBeenCalledTimes(1);\n});\n\nit('can send multiple messages to parent', () => {\n  const worker = new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  const onProcessStart = jest.fn();\n  const onProcessEnd = jest.fn();\n  const onCustomMessage = jest.fn();\n\n  worker.send(\n    [CHILD_MESSAGE_CALL, false, 'foo', []],\n    onProcessStart,\n    onProcessEnd,\n    onCustomMessage,\n  );\n\n  // Only onProcessStart has been called\n  expect(onProcessStart).toHaveBeenCalledTimes(1);\n  expect(onProcessEnd).not.toHaveBeenCalled();\n  expect(onCustomMessage).not.toHaveBeenCalled();\n\n  // then first call replies...\n  forkInterface.emit('message', [\n    PARENT_MESSAGE_CUSTOM,\n    {message: 'foo bar', otherKey: 1},\n  ]);\n\n  expect(onProcessEnd).not.toHaveBeenCalled();\n  expect(onCustomMessage).toHaveBeenCalledTimes(1);\n  expect(onCustomMessage).toHaveBeenCalledWith({\n    message: 'foo bar',\n    otherKey: 1,\n  });\n});\n\nit('creates error instances for known errors', () => {\n  const worker = new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  const callback1 = jest.fn();\n  const callback2 = jest.fn();\n  const callback3 = jest.fn();\n\n  // Testing a generic ECMAScript error.\n  worker.send(\n    [CHILD_MESSAGE_CALL, false, 'method', []],\n    () => {},\n    callback1,\n    () => {},\n  );\n\n  forkInterface.emit('message', [\n    PARENT_MESSAGE_CLIENT_ERROR,\n    'TypeError',\n    'bar',\n    'TypeError: bar',\n    {},\n  ]);\n\n  expect(callback1.mock.calls[0][0]).toBeInstanceOf(TypeError);\n  expect(callback1.mock.calls[0][0]).toMatchObject({\n    message: 'bar',\n    stack: 'TypeError: bar',\n    type: 'TypeError',\n  });\n\n  // Testing a custom error.\n  worker.send(\n    [CHILD_MESSAGE_CALL, false, 'method', []],\n    () => {},\n    callback2,\n    () => {},\n  );\n\n  forkInterface.emit('message', [\n    PARENT_MESSAGE_CLIENT_ERROR,\n    'RandomCustomError',\n    'bar',\n    'RandomCustomError: bar',\n    {qux: 'extra property'},\n  ]);\n\n  expect(callback2.mock.calls[0][0]).toBeInstanceOf(Error);\n  expect(callback2.mock.calls[0][0]).toMatchObject({\n    message: 'bar',\n    qux: 'extra property',\n    stack: 'RandomCustomError: bar',\n    type: 'RandomCustomError',\n  });\n\n  // Testing a non-object throw.\n  worker.send(\n    [CHILD_MESSAGE_CALL, false, 'method', []],\n    () => {},\n    callback3,\n    () => {},\n  );\n\n  forkInterface.emit('message', [\n    PARENT_MESSAGE_CLIENT_ERROR,\n    'Number',\n    null,\n    null,\n    412,\n  ]);\n\n  expect(callback3.mock.calls[0][0]).toBe(412);\n});\n\nit('does not throw when the child process returns a strange message', () => {\n  const worker = new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  worker.send(\n    [CHILD_MESSAGE_CALL, false, 'method', []],\n    () => {},\n    () => {},\n    () => {},\n  );\n\n  // Type 27 does not exist.\n  forkInterface.emit('message', [27]);\n\n  forkInterface.emit('message', 'test');\n  forkInterface.emit('message', {foo: 'bar'});\n  forkInterface.emit('message', 0);\n  forkInterface.emit('message', null);\n  forkInterface.emit('message', Symbol('test'));\n  forkInterface.emit('message', true);\n});\n\nit('does not restart the child if it cleanly exited', () => {\n  // eslint-disable-next-line no-new\n  new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  expect(childProcess.fork).toHaveBeenCalledTimes(1);\n  forkInterface.emit('exit', 0);\n  expect(childProcess.fork).toHaveBeenCalledTimes(1);\n});\n\nit('resolves waitForExit() after the child process cleanly exited', async () => {\n  const worker = new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  expect(childProcess.fork).toHaveBeenCalledTimes(1);\n  forkInterface.emit('exit', 0);\n  await worker.waitForExit(); // should not timeout\n});\n\nit('restarts the child when the child process dies', () => {\n  // eslint-disable-next-line no-new\n  new Worker({\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  expect(childProcess.fork).toHaveBeenCalledTimes(1);\n  forkInterface.emit('exit', 1);\n  expect(childProcess.fork).toHaveBeenCalledTimes(2);\n});\n\nit('when out of memory occurs the worker is killed and exits', async () => {\n  const worker = new Worker({\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  expect(childProcess.fork).toHaveBeenCalledTimes(1);\n\n  const onProcessStart = jest.fn();\n  const onProcessEnd = jest.fn();\n  const onCustomMessage = jest.fn();\n\n  worker.send(\n    [CHILD_MESSAGE_CALL, false, 'foo', []],\n    onProcessStart,\n    onProcessEnd,\n    onCustomMessage,\n  );\n\n  // Only onProcessStart has been called\n  expect(onProcessStart).toHaveBeenCalledTimes(1);\n  expect(onProcessEnd).not.toHaveBeenCalled();\n  expect(onCustomMessage).not.toHaveBeenCalled();\n\n  // Splitting the emit into 2 to check concat is happening.\n  forkInterface.stderr!.emit(\n    'data',\n    `<--- Last few GCs --->\n\n  [20048:0x7fa356200000]      349 ms: Mark-sweep (reduce) 49.2 (80.6) -> 49.0 (51.6) MB, 6.8 / 0.0 ms  (+ 59.5 ms in 35 steps since start of marking, biggest step 2.3 ms, walltime since start of marking 68 ms) (average mu = 0.679, current mu = 0.679) finali[20048:0x7fa356200000]      418 ms: Mark-sweep 50.0 (51.6) -> 49.9 (55.6) MB, 67.8 / 0.0 ms  (average mu = 0.512, current mu = 0.004) allocation failure scavenge might not succeed\n\n\n  <--- JS stacktrace --->\n\n  FATAL ERROR: Reached heap limit Allocation failed - JavaScript he`,\n  );\n\n  forkInterface.stderr!.emit(\n    'data',\n    `ap out of memory\n   1: 0x10da153a5 node::Abort() (.cold.1) [/Users/paul/.nvm/versions/node/v16.10.0/bin/node]\n   2: 0x10c6f09b9 node::Abort() [/Users/paul/.nvm/versions/node/v16.10.0/bin/node]`,\n  );\n  forkInterface.stderr!.emit('end');\n\n  forkInterface.emit('exit', null, 'SIGABRT');\n\n  // We don't want it to try and restart.\n  expect(childProcess.fork).toHaveBeenCalledTimes(1);\n  expect(onProcessEnd).toHaveBeenCalledTimes(1);\n  expect(onProcessEnd).toHaveBeenCalledWith(\n    new Error('Jest worker ran out of memory and crashed'),\n    null,\n  );\n\n  // It should not hang\n  await worker.waitForExit();\n});\n\nit('sends SIGTERM when forceExit() is called', async () => {\n  const worker = new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  worker.forceExit();\n  expect(jest.mocked(forkInterface.kill).mock.calls).toEqual([['SIGTERM']]);\n});\n\nit('sends SIGKILL some time after SIGTERM', async () => {\n  const worker = new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  worker.forceExit();\n  jest.runAllTimers();\n  expect(jest.mocked(forkInterface.kill).mock.calls).toEqual([\n    ['SIGTERM'],\n    ['SIGKILL'],\n  ]);\n});\n\nit('does not send SIGKILL if SIGTERM exited the process', async () => {\n  const worker = new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  worker.forceExit();\n  forkInterface.emit('exit', 143 /* SIGTERM exit code */);\n  await Promise.resolve();\n\n  jest.runAllTimers();\n  expect(jest.mocked(forkInterface.kill).mock.calls).toEqual([['SIGTERM']]);\n});\n\nit('should check for memory limits and not restart if under percentage limit', async () => {\n  const memoryConfig = {\n    limit: 0.2,\n    processHeap: 2500,\n    totalMem: 16_000,\n  };\n\n  const worker = new Worker({\n    forkOptions: {},\n    idleMemoryLimit: memoryConfig.limit,\n    maxRetries: 3,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  const onProcessStart = jest.fn();\n  const onProcessEnd = jest.fn();\n  const onCustomMessage = jest.fn();\n\n  worker.send(\n    [CHILD_MESSAGE_CALL, false, 'foo', []],\n    onProcessStart,\n    onProcessEnd,\n    onCustomMessage,\n  );\n\n  // Only onProcessStart has been called\n  expect(onProcessStart).toHaveBeenCalledTimes(1);\n  expect(onProcessEnd).not.toHaveBeenCalled();\n  expect(onCustomMessage).not.toHaveBeenCalled();\n\n  // then first call replies...\n  forkInterface.emit('message', [PARENT_MESSAGE_OK]);\n\n  expect(onProcessEnd).toHaveBeenCalledTimes(1);\n\n  // This is the initialization call.\n  expect(jest.mocked(forkInterface.send).mock.calls[0][0]).toEqual([\n    CHILD_MESSAGE_INITIALIZE,\n    false,\n    '/tmp/foo',\n    undefined,\n  ]);\n\n  // This is the child message\n  expect(jest.mocked(forkInterface.send).mock.calls[1][0]).toEqual([\n    CHILD_MESSAGE_CALL,\n    false,\n    'foo',\n    [],\n  ]);\n\n  // This is the subsequent call to get memory usage\n  expect(jest.mocked(forkInterface.send).mock.calls[2][0]).toEqual([\n    CHILD_MESSAGE_MEM_USAGE,\n  ]);\n\n  totalmem.mockReturnValue(memoryConfig.totalMem);\n\n  forkInterface.emit('message', [\n    PARENT_MESSAGE_MEM_USAGE,\n    memoryConfig.processHeap,\n  ]);\n\n  expect(totalmem).toHaveBeenCalledTimes(1);\n  expect(forkInterface.kill).not.toHaveBeenCalled();\n});\n\nit('should check for memory limits and not restart if under absolute limit', async () => {\n  const memoryConfig = {\n    limit: 2600,\n    processHeap: 2500,\n    totalMem: 16_000,\n  };\n\n  const worker = new Worker({\n    forkOptions: {},\n    idleMemoryLimit: memoryConfig.limit,\n    maxRetries: 3,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  worker.checkMemoryUsage();\n\n  totalmem.mockReturnValue(memoryConfig.totalMem);\n\n  forkInterface.emit('message', [\n    PARENT_MESSAGE_MEM_USAGE,\n    memoryConfig.processHeap,\n  ]);\n\n  expect(totalmem).not.toHaveBeenCalled();\n  expect(forkInterface.kill).not.toHaveBeenCalled();\n});\n\nit('should check for memory limits and restart if above percentage limit', async () => {\n  const memoryConfig = {\n    limit: 0.01,\n    processHeap: 2500,\n    totalMem: 16_000,\n  };\n\n  const worker = new Worker({\n    forkOptions: {},\n    idleMemoryLimit: memoryConfig.limit,\n    maxRetries: 3,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  worker.checkMemoryUsage();\n\n  totalmem.mockReturnValue(memoryConfig.totalMem);\n\n  forkInterface.emit('message', [\n    PARENT_MESSAGE_MEM_USAGE,\n    memoryConfig.processHeap,\n  ]);\n\n  expect(totalmem).toHaveBeenCalledTimes(1);\n  expect(forkInterface.kill).toHaveBeenCalledTimes(1);\n});\n\nit('should check for memory limits and restart if above absolute limit', async () => {\n  const memoryConfig = {\n    limit: 2000,\n    processHeap: 2500,\n    totalMem: 16_000,\n  };\n\n  const worker = new Worker({\n    forkOptions: {},\n    idleMemoryLimit: memoryConfig.limit,\n    maxRetries: 3,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  worker.checkMemoryUsage();\n\n  totalmem.mockReturnValue(memoryConfig.totalMem);\n\n  forkInterface.emit('message', [\n    PARENT_MESSAGE_MEM_USAGE,\n    memoryConfig.processHeap,\n  ]);\n\n  expect(totalmem).not.toHaveBeenCalled();\n  expect(forkInterface.kill).toHaveBeenCalledTimes(1);\n});\n\nit('should restart immediately when limit is 0 without checking memory', () => {\n  const worker = new Worker({\n    forkOptions: {},\n    idleMemoryLimit: 0,\n    maxRetries: 3,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  const onProcessStart = jest.fn();\n  const onProcessEnd = jest.fn();\n  const onCustomMessage = jest.fn();\n\n  worker.send(\n    [CHILD_MESSAGE_CALL, false, 'test', []] as ChildMessageCall,\n    onProcessStart,\n    onProcessEnd,\n    onCustomMessage,\n  );\n\n  expect(onProcessStart).toHaveBeenCalledTimes(1);\n  expect(onProcessEnd).not.toHaveBeenCalled();\n  expect(onCustomMessage).not.toHaveBeenCalled();\n\n  forkInterface.emit('message', [PARENT_MESSAGE_OK]);\n  expect(onProcessEnd).toHaveBeenCalledTimes(1);\n  expect(onCustomMessage).not.toHaveBeenCalled();\n\n  expect(totalmem).not.toHaveBeenCalled();\n  expect(forkInterface.send).not.toHaveBeenCalledWith(\n    [CHILD_MESSAGE_MEM_USAGE],\n    expect.any(Function),\n  );\n  expect(worker.state).toBe(WorkerStates.RESTARTING);\n  expect(forkInterface.kill).toHaveBeenCalledTimes(1);\n});\n",
  "packages/jest-worker/src/workers/__tests__/ChildProcessWorker.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-worker/src/base/BaseWorkerPool.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport mergeStream from 'merge-stream';\nimport {\n  CHILD_MESSAGE_CALL_SETUP,\n  CHILD_MESSAGE_END,\n  type PoolExitResult,\n  type WorkerInterface,\n  type WorkerOptions,\n  type WorkerPoolOptions,\n  WorkerStates,\n} from '../types';\n\n// How long to wait for the child process to terminate\n// after CHILD_MESSAGE_END before sending force exiting.\nconst FORCE_EXIT_DELAY = 500;\n\n/* istanbul ignore next */\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nconst emptyMethod = () => {};\n\nexport default class BaseWorkerPool {\n  private readonly _stderr: NodeJS.ReadableStream;\n  private readonly _stdout: NodeJS.ReadableStream;\n  protected readonly _options: WorkerPoolOptions;\n  private readonly _workers: Array<WorkerInterface>;\n  private readonly _workerPath: string;\n\n  constructor(workerPath: string, options: WorkerPoolOptions) {\n    this._options = options;\n    this._workerPath = workerPath;\n    this._workers = Array.from({length: options.numWorkers});\n\n    const stdout = mergeStream();\n    const stderr = mergeStream();\n\n    const {forkOptions, maxRetries, resourceLimits, setupArgs} = options;\n\n    for (let i = 0; i < options.numWorkers; i++) {\n      const workerOptions: WorkerOptions = {\n        forkOptions,\n        idleMemoryLimit: this._options.idleMemoryLimit,\n        maxRetries,\n        resourceLimits,\n        setupArgs,\n        workerId: i,\n        workerPath,\n      };\n\n      const worker = this.createWorker(workerOptions);\n      const workerStdout = worker.getStdout();\n      const workerStderr = worker.getStderr();\n\n      if (workerStdout) {\n        stdout.add(workerStdout);\n      }\n\n      if (workerStderr) {\n        stderr.add(workerStderr);\n      }\n\n      this._workers[i] = worker;\n    }\n\n    this._stdout = stdout;\n    this._stderr = stderr;\n  }\n\n  getStderr(): NodeJS.ReadableStream {\n    return this._stderr;\n  }\n\n  getStdout(): NodeJS.ReadableStream {\n    return this._stdout;\n  }\n\n  getWorkers(): Array<WorkerInterface> {\n    return this._workers;\n  }\n\n  getWorkerById(workerId: number): WorkerInterface {\n    return this._workers[workerId];\n  }\n\n  restartWorkerIfShutDown(workerId: number): void {\n    if (this._workers[workerId].state === WorkerStates.SHUT_DOWN) {\n      const {forkOptions, maxRetries, resourceLimits, setupArgs} =\n        this._options;\n      const workerOptions: WorkerOptions = {\n        forkOptions,\n        idleMemoryLimit: this._options.idleMemoryLimit,\n        maxRetries,\n        resourceLimits,\n        setupArgs,\n        workerId,\n        workerPath: this._workerPath,\n      };\n      const worker = this.createWorker(workerOptions);\n      this._workers[workerId] = worker;\n    }\n  }\n\n  createWorker(_workerOptions: WorkerOptions): WorkerInterface {\n    throw new Error('Missing method createWorker in WorkerPool');\n  }\n\n  async start(): Promise<void> {\n    await Promise.all(\n      this._workers.map(async worker => {\n        await worker.waitForWorkerReady();\n\n        await new Promise<void>((resolve, reject) => {\n          worker.send(\n            [CHILD_MESSAGE_CALL_SETUP],\n            emptyMethod,\n            error => {\n              if (error) {\n                reject(error);\n              } else {\n                resolve();\n              }\n            },\n            emptyMethod,\n          );\n        });\n      }),\n    );\n  }\n\n  async end(): Promise<PoolExitResult> {\n    // We do not cache the request object here. If so, it would only be only\n    // processed by one of the workers, and we want them all to close.\n    const workerExitPromises = this._workers.map(async worker => {\n      worker.send(\n        [CHILD_MESSAGE_END, false],\n        emptyMethod,\n        emptyMethod,\n        emptyMethod,\n      );\n\n      // Schedule a force exit in case worker fails to exit gracefully so\n      // await worker.waitForExit() never takes longer than FORCE_EXIT_DELAY\n      let forceExited = false;\n      const forceExitTimeout = setTimeout(() => {\n        worker.forceExit();\n        forceExited = true;\n      }, FORCE_EXIT_DELAY);\n\n      await worker.waitForExit();\n      // Worker ideally exited gracefully, don't send force exit then\n      clearTimeout(forceExitTimeout);\n\n      return forceExited;\n    });\n\n    const workerExits = await Promise.all(workerExitPromises);\n    return workerExits.reduce<PoolExitResult>(\n      (result, forceExited) => ({\n        forceExited: result.forceExited || forceExited,\n      }),\n      {forceExited: false},\n    );\n  }\n}\n",
  "packages/jest-worker/src/base/BaseWorkerPool.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { type PoolExitResult, type WorkerInterface, type WorkerOptions, type WorkerPoolOptions } from '../types';\nexport default class BaseWorkerPool {\n    private readonly _stderr;\n    private readonly _stdout;\n    protected readonly _options: WorkerPoolOptions;\n    private readonly _workers;\n    private readonly _workerPath;\n    constructor(workerPath: string, options: WorkerPoolOptions);\n    getStderr(): NodeJS.ReadableStream;\n    getStdout(): NodeJS.ReadableStream;\n    getWorkers(): Array<WorkerInterface>;\n    getWorkerById(workerId: number): WorkerInterface;\n    restartWorkerIfShutDown(workerId: number): void;\n    createWorker(_workerOptions: WorkerOptions): WorkerInterface;\n    start(): Promise<void>;\n    end(): Promise<PoolExitResult>;\n}\n",
  "packages/jest-worker/src/base/__tests__/BaseWorkerPool.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {\n  CHILD_MESSAGE_END,\n  type WorkerInterface,\n  type WorkerOptions,\n  type WorkerPoolOptions,\n} from '../../types';\nimport BaseWorkerPool from '../BaseWorkerPool';\n\nconst Worker =\n  jest.fn<\n    (workerOptions: Omit<WorkerOptions, 'resourceLimits'>) => WorkerInterface\n  >();\n\nconst mockSend = jest.fn();\n\nclass MockWorkerPool extends BaseWorkerPool {\n  override createWorker(workerOptions: WorkerOptions) {\n    return new Worker(workerOptions);\n  }\n  send(...args: Array<unknown>) {\n    return mockSend(...args);\n  }\n}\n\ndescribe('BaseWorkerPool', () => {\n  beforeEach(() => {\n    Worker.mockClear();\n    Worker.mockImplementation(\n      () =>\n        ({\n          forceExit: jest.fn(),\n          getStderr: () =>\n            ({once() {}, pipe() {}}) as unknown as NodeJS.ReadStream,\n          getStdout: () =>\n            ({once() {}, pipe() {}}) as unknown as NodeJS.ReadStream,\n          send: jest.fn(),\n          waitForExit: () => Promise.resolve(),\n        }) as unknown as WorkerInterface,\n    );\n  });\n\n  it('throws error when createWorker is not defined', () => {\n    expect(\n      () =>\n        new BaseWorkerPool('/tmp/baz.js', {\n          forkOptions: {execArgv: []},\n          maxRetries: 6,\n          numWorkers: 4,\n          setupArgs: [],\n        } as unknown as WorkerPoolOptions),\n    ).toThrow('Missing method createWorker in WorkerPool');\n  });\n\n  it('creates and exposes n workers', () => {\n    const pool = new MockWorkerPool('/tmp/baz.js', {\n      forkOptions: {execArgv: []},\n      maxRetries: 6,\n      numWorkers: 4,\n      setupArgs: [],\n    } as unknown as WorkerPoolOptions);\n\n    expect(pool.getWorkers()).toHaveLength(4);\n    expect(pool.getWorkerById(0)).toBeDefined();\n    expect(pool.getWorkerById(1)).toBeDefined();\n    expect(pool.getWorkerById(2)).toBeDefined();\n    expect(pool.getWorkerById(3)).toBeDefined();\n  });\n\n  it('creates workers with the right options', () => {\n    // eslint-disable-next-line no-new\n    new MockWorkerPool('/tmp/baz.js', {\n      forkOptions: {execArgv: []},\n      maxRetries: 6,\n      numWorkers: 4,\n      setupArgs: [{foo: 'bar'}],\n    } as unknown as WorkerPoolOptions);\n\n    expect(Worker).toHaveBeenCalledTimes(4);\n    expect(Worker).toHaveBeenNthCalledWith(1, {\n      forkOptions: {execArgv: []},\n      maxRetries: 6,\n      setupArgs: [{foo: 'bar'}],\n      workerId: 0,\n      workerPath: '/tmp/baz.js',\n    });\n    expect(Worker).toHaveBeenNthCalledWith(2, {\n      forkOptions: {execArgv: []},\n      maxRetries: 6,\n      setupArgs: [{foo: 'bar'}],\n      workerId: 1,\n      workerPath: '/tmp/baz.js',\n    });\n    expect(Worker).toHaveBeenNthCalledWith(3, {\n      forkOptions: {execArgv: []},\n      maxRetries: 6,\n      setupArgs: [{foo: 'bar'}],\n      workerId: 2,\n      workerPath: '/tmp/baz.js',\n    });\n    expect(Worker).toHaveBeenNthCalledWith(4, {\n      forkOptions: {execArgv: []},\n      maxRetries: 6,\n      setupArgs: [{foo: 'bar'}],\n      workerId: 3,\n      workerPath: '/tmp/baz.js',\n    });\n  });\n\n  it('create multiple workers with unique worker ids', () => {\n    // eslint-disable-next-line no-new\n    new MockWorkerPool('/tmp/baz.js', {\n      exposedMethods: ['foo', 'bar'],\n      forkOptions: {execArgv: []},\n      maxRetries: 6,\n      numWorkers: 3,\n    } as unknown as WorkerPoolOptions);\n\n    expect(Worker).toHaveBeenCalledTimes(3);\n    expect(Worker.mock.calls[0][0].workerId).toBe(0);\n    expect(Worker.mock.calls[1][0].workerId).toBe(1);\n    expect(Worker.mock.calls[2][0].workerId).toBe(2);\n  });\n\n  it('aggregates all stdouts and stderrs from all workers', () => {\n    const out: Array<NodeJS.WritableStream> = [];\n    const err: Array<NodeJS.WritableStream> = [];\n\n    Worker.mockImplementation(\n      () =>\n        ({\n          getStderr: () =>\n            ({\n              once() {},\n              pipe(errStream: NodeJS.WritableStream) {\n                err.push(errStream);\n              },\n            }) as unknown as NodeJS.ReadableStream,\n          getStdout: () =>\n            ({\n              once() {},\n              pipe(outStream: NodeJS.WritableStream) {\n                out.push(outStream);\n              },\n            }) as unknown as NodeJS.ReadableStream,\n        }) as WorkerInterface,\n    );\n\n    const farm = new MockWorkerPool('/tmp/baz.js', {\n      exposedMethods: ['foo', 'bar'],\n      numWorkers: 2,\n    } as unknown as WorkerPoolOptions);\n\n    expect(out).toHaveLength(2);\n    expect(err).toHaveLength(2);\n\n    const stdout = jest.fn<(a: string) => void>();\n    const stderr = jest.fn<(a: string) => void>();\n\n    farm.getStdout().on('data', stdout);\n    farm.getStderr().on('data', stderr);\n\n    out[0].write(Buffer.from('hello'));\n    out[1].write(Buffer.from('bye'));\n    err[1].write(Buffer.from('house'));\n    err[0].write(Buffer.from('tree'));\n\n    expect(stdout.mock.calls[0][0].toString()).toBe('hello');\n    expect(stdout.mock.calls[1][0].toString()).toBe('bye');\n    expect(stderr.mock.calls[0][0].toString()).toBe('house');\n    expect(stderr.mock.calls[1][0].toString()).toBe('tree');\n  });\n\n  it('works when stdout and stderr are not piped to the parent', () => {\n    Worker.mockImplementation(\n      () =>\n        ({\n          getStderr: () => null,\n          getStdout: () => null,\n          send: () => null,\n        }) as unknown as WorkerInterface,\n    );\n\n    const farm = new MockWorkerPool('/tmp/baz.js', {\n      exposedMethods: ['foo', 'bar'],\n      forkOptions: {\n        silent: false,\n        stdio: 'inherit',\n      },\n      numWorkers: 2,\n    } as unknown as WorkerPoolOptions);\n\n    expect(() => farm.send()).not.toThrow();\n    expect(() => farm.send()).not.toThrow();\n  });\n\n  describe('end', () => {\n    it('ends all workers', async () => {\n      const pool = new MockWorkerPool('/tmp/baz.js', {\n        forkOptions: {execArgv: []},\n        maxRetries: 6,\n        numWorkers: 4,\n        setupArgs: [],\n      } as unknown as WorkerPoolOptions);\n\n      const workers = pool.getWorkers();\n      await pool.end();\n\n      const endMessage = [CHILD_MESSAGE_END, false];\n      expect(jest.mocked(workers[0].send).mock.calls[0][0]).toEqual(endMessage);\n      expect(jest.mocked(workers[1].send).mock.calls[0][0]).toEqual(endMessage);\n      expect(jest.mocked(workers[2].send).mock.calls[0][0]).toEqual(endMessage);\n      expect(jest.mocked(workers[3].send).mock.calls[0][0]).toEqual(endMessage);\n    });\n\n    it('resolves with forceExited=false if workers exited gracefully', async () => {\n      Worker.mockImplementation(\n        () =>\n          ({\n            forceExit: jest.fn(),\n            getStderr: () => null,\n            getStdout: () => null,\n            send: jest.fn(),\n            waitForExit: () => Promise.resolve(),\n          }) as unknown as WorkerInterface,\n      );\n\n      const pool = new MockWorkerPool('/tmp/baz.js', {\n        forkOptions: {execArgv: []},\n        maxRetries: 6,\n        numWorkers: 4,\n        setupArgs: [],\n      } as unknown as WorkerPoolOptions);\n\n      expect(await pool.end()).toEqual({forceExited: false});\n    });\n\n    it('force exits workers that do not exit gracefully and resolves with forceExited=true', async () => {\n      // Set it up so that the first worker does not resolve waitForExit immediately,\n      // but only when forceExit() is called\n      let worker0Exited: (a?: unknown) => void;\n      Worker.mockImplementationOnce(\n        () =>\n          ({\n            forceExit: () => {\n              worker0Exited();\n            },\n            getStderr: () => null,\n            getStdout: () => null,\n            send: jest.fn(),\n            waitForExit: () =>\n              new Promise(resolve => (worker0Exited = resolve)),\n          }) as unknown as WorkerInterface,\n      ).mockImplementation(\n        () =>\n          ({\n            forceExit: jest.fn(),\n            getStderr: () => null,\n            getStdout: () => null,\n            send: jest.fn(),\n            waitForExit: () => Promise.resolve(),\n          }) as unknown as WorkerInterface,\n      );\n\n      const pool = new MockWorkerPool('/tmp/baz.js', {\n        forkOptions: {execArgv: []},\n        maxRetries: 6,\n        numWorkers: 2,\n        setupArgs: [],\n      } as unknown as WorkerPoolOptions);\n\n      const workers = pool.getWorkers();\n      expect(await pool.end()).toEqual({forceExited: true});\n\n      expect(workers[1].forceExit).not.toHaveBeenCalled();\n    });\n  });\n});\n",
  "packages/jest-worker/src/base/__tests__/BaseWorkerPool.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-worker/src/__tests__/thread-integration.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {EventEmitter} from 'events';\nimport type {Worker as ThreadWorker} from 'worker_threads';\nimport type {JestWorkerFarm, Worker} from '../';\nimport {CHILD_MESSAGE_CALL, PARENT_MESSAGE_OK} from '../types';\n\nlet WorkerFarm: typeof Worker;\nlet mockForkedProcesses: Array<ThreadWorker>;\n\nfunction replySuccess(i: number, result: unknown) {\n  mockForkedProcesses[i].emit('message', [PARENT_MESSAGE_OK, result]);\n}\n\nfunction assertCallsToChild(\n  childNum: number,\n  ...calls: Array<[unknown, ...[unknown]]>\n) {\n  expect(mockForkedProcesses[childNum].postMessage).toHaveBeenCalledTimes(\n    calls.length + 1,\n  );\n\n  for (const [numCall, [methodName, ...args]] of calls.entries()) {\n    expect(\n      jest.mocked(mockForkedProcesses[childNum].postMessage).mock.calls[\n        numCall + 1\n      ][0],\n    ).toEqual([CHILD_MESSAGE_CALL, true, methodName, args]);\n  }\n}\n\ndescribe('Jest Worker Process Integration', () => {\n  beforeEach(() => {\n    mockForkedProcesses = [];\n\n    class MockForkedProcess extends EventEmitter {\n      postMessage = jest.fn();\n    }\n\n    jest.mock('worker_threads', () => {\n      const fakeClass = jest.fn(() => {\n        const forkedProcess =\n          new MockForkedProcess() as unknown as ThreadWorker;\n\n        mockForkedProcesses.push(forkedProcess);\n\n        return forkedProcess;\n      });\n\n      return {\n        Worker: fakeClass,\n        __esModule: true,\n      };\n    });\n\n    WorkerFarm = (require('../') as typeof import('../')).Worker;\n  });\n\n  afterEach(() => {\n    jest.resetModules();\n  });\n\n  it('calls a single method from the worker', async () => {\n    const farm = new WorkerFarm('/tmp/baz.js', {\n      enableWorkerThreads: true,\n      exposedMethods: ['foo', 'bar'],\n      numWorkers: 4,\n    }) as JestWorkerFarm<{foo(): void}>;\n\n    const promise = farm.foo();\n\n    replySuccess(0, 42);\n\n    expect(await promise).toBe(42);\n  });\n\n  it('distributes sequential calls across child processes', async () => {\n    const farm = new WorkerFarm('/tmp/baz.js', {\n      enableWorkerThreads: true,\n      exposedMethods: ['foo', 'bar'],\n      numWorkers: 4,\n    }) as JestWorkerFarm<{foo(a: unknown): void}>;\n\n    // The first call will go to the first child process.\n    const promise0 = farm.foo('param-0');\n    assertCallsToChild(0, ['foo', 'param-0']);\n    replySuccess(0, 'worker-0');\n    expect(await promise0).toBe('worker-0');\n\n    // The second call will go to the second child process.\n    const promise1 = farm.foo(1);\n    assertCallsToChild(1, ['foo', 1]);\n    replySuccess(1, 'worker-1');\n    expect(await promise1).toBe('worker-1');\n  });\n\n  it('schedules the task on the first available child processes if the scheduling policy is in-order', async () => {\n    const farm = new WorkerFarm('/tmp/baz.js', {\n      enableWorkerThreads: true,\n      exposedMethods: ['foo', 'bar'],\n      numWorkers: 4,\n      workerSchedulingPolicy: 'in-order',\n    }) as JestWorkerFarm<{foo(a: unknown): void}>;\n\n    // The first call will go to the first child process.\n    const promise0 = farm.foo('param-0');\n    assertCallsToChild(0, ['foo', 'param-0']);\n\n    // The second call will go to the second child process.\n    const promise1 = farm.foo(1);\n\n    // The first task on worker 0 completes.\n    replySuccess(0, 'worker-0');\n    expect(await promise0).toBe('worker-0');\n\n    // The second task on worker 1 completes.\n    assertCallsToChild(1, ['foo', 1]);\n    replySuccess(1, 'worker-1');\n    expect(await promise1).toBe('worker-1');\n\n    // The third call will go to the first child process.\n    const promise2 = farm.foo('param-2');\n    assertCallsToChild(0, ['foo', 'param-0'], ['foo', 'param-2']);\n    replySuccess(0, 'worker-0');\n    expect(await promise2).toBe('worker-0');\n  });\n\n  it('schedules the task on the first available child processes', async () => {\n    const farm = new WorkerFarm('/tmp/baz.js', {\n      enableWorkerThreads: true,\n      exposedMethods: ['foo', 'bar'],\n      numWorkers: 4,\n    }) as JestWorkerFarm<{foo(a: unknown): void}>;\n\n    // The first call will go to the first child process.\n    const promise0 = farm.foo('param-0');\n    assertCallsToChild(0, ['foo', 'param-0']);\n    replySuccess(0, 'worker-0');\n    expect(await promise0).toBe('worker-0');\n\n    // The second call will go to the second child process.\n    const promise1 = farm.foo(1);\n    assertCallsToChild(1, ['foo', 1]);\n    replySuccess(1, 'worker-1');\n    expect(await promise1).toBe('worker-1');\n  });\n\n  it('distributes concurrent calls across child processes', async () => {\n    const farm = new WorkerFarm('/tmp/baz.js', {\n      enableWorkerThreads: true,\n      exposedMethods: ['foo', 'bar'],\n      numWorkers: 4,\n    }) as JestWorkerFarm<{foo(a: unknown): void}>;\n\n    // Do 3 calls to the farm in parallel.\n    const promise0 = farm.foo('param-0');\n    const promise1 = farm.foo('param-1');\n    const promise2 = farm.foo('param-2');\n\n    // Check that the method calls are sent to each separate child process.\n    assertCallsToChild(0, ['foo', 'param-0']);\n    assertCallsToChild(1, ['foo', 'param-1']);\n    assertCallsToChild(2, ['foo', 'param-2']);\n\n    // Send different responses from each child.\n    replySuccess(0, 'worker-0');\n    replySuccess(1, 'worker-1');\n    replySuccess(2, 'worker-2');\n\n    // Check\n    expect(await promise0).toBe('worker-0');\n    expect(await promise1).toBe('worker-1');\n    expect(await promise2).toBe('worker-2');\n  });\n\n  it('sticks parallel calls to children', async () => {\n    const farm = new WorkerFarm('/tmp/baz.js', {\n      computeWorkerKey: () => '1234567890abcdef',\n      enableWorkerThreads: true,\n      exposedMethods: ['foo', 'bar'],\n      numWorkers: 4,\n    }) as JestWorkerFarm<{foo(a: unknown): void}>;\n\n    // Do 3 calls to the farm in parallel.\n    const promise0 = farm.foo('param-0');\n    const promise1 = farm.foo('param-1');\n    const promise2 = farm.foo('param-2');\n\n    // Send different responses for each call (from the same child).\n    replySuccess(0, 'worker-0');\n    replySuccess(0, 'worker-1');\n    replySuccess(0, 'worker-2');\n\n    // Check that all the calls have been received by the same child.\n    assertCallsToChild(\n      0,\n      ['foo', 'param-0'],\n      ['foo', 'param-1'],\n      ['foo', 'param-2'],\n    );\n\n    // Check that responses are correct.\n    expect(await promise0).toBe('worker-0');\n    expect(await promise1).toBe('worker-1');\n    expect(await promise2).toBe('worker-2');\n  });\n});\n",
  "packages/jest-worker/src/__tests__/thread-integration.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-worker/src/__tests__/process-integration.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {EventEmitter} from 'events';\nimport type {JestWorkerFarm, Worker} from '../';\nimport {\n  CHILD_MESSAGE_CALL,\n  CHILD_MESSAGE_MEM_USAGE,\n  PARENT_MESSAGE_OK,\n} from '../types';\n\nclass MockChildProcess extends EventEmitter {\n  connected = true;\n  send = jest.fn<(message: unknown) => boolean>();\n}\n\nlet WorkerFarm: typeof Worker;\nlet mockForkedProcesses: Array<MockChildProcess>;\n\nfunction replySuccess(i: number, result: unknown) {\n  mockForkedProcesses[i].emit('message', [PARENT_MESSAGE_OK, result]);\n}\n\nfunction assertCallsToChild(\n  childNum: number,\n  ...calls: Array<[unknown, ...[unknown]]>\n) {\n  expect(mockForkedProcesses[childNum].send).toHaveBeenCalledTimes(\n    calls.length + 1,\n  );\n\n  for (const [numCall, [methodName, ...args]] of calls.entries()) {\n    expect(\n      jest.mocked(mockForkedProcesses[childNum].send).mock.calls[\n        numCall + 1\n      ][0],\n    ).toEqual([CHILD_MESSAGE_CALL, true, methodName, args]);\n  }\n}\n\ndescribe('Jest Worker Integration', () => {\n  beforeEach(() => {\n    mockForkedProcesses = [];\n\n    jest.mock('child_process', () => ({\n      fork() {\n        const forkedProcess = new MockChildProcess();\n        mockForkedProcesses.push(forkedProcess);\n\n        return forkedProcess;\n      },\n    }));\n\n    WorkerFarm = (require('../') as typeof import('../')).Worker;\n  });\n\n  afterEach(() => {\n    jest.resetModules();\n  });\n\n  it('calls a single method from the worker', async () => {\n    const farm = new WorkerFarm('/tmp/baz.js', {\n      exposedMethods: ['foo', 'bar'],\n      numWorkers: 4,\n    }) as JestWorkerFarm<{foo(): void}>;\n\n    const promise = farm.foo();\n\n    replySuccess(0, 42);\n\n    expect(await promise).toBe(42);\n  });\n\n  it('distributes sequential calls across child processes', async () => {\n    const farm = new WorkerFarm('/tmp/baz.js', {\n      exposedMethods: ['foo', 'bar'],\n      numWorkers: 4,\n    }) as JestWorkerFarm<{foo(a: unknown): void}>;\n\n    // The first call will go to the first child process.\n    const promise0 = farm.foo('param-0');\n    assertCallsToChild(0, ['foo', 'param-0']);\n    replySuccess(0, 'worker-0');\n    expect(await promise0).toBe('worker-0');\n\n    // The second call will go to the second child process.\n    const promise1 = farm.foo(1);\n    assertCallsToChild(1, ['foo', 1]);\n    replySuccess(1, 'worker-1');\n    expect(await promise1).toBe('worker-1');\n  });\n\n  it('schedules the task on the first available child processes if the scheduling policy is in-order', async () => {\n    const farm = new WorkerFarm('/tmp/baz.js', {\n      exposedMethods: ['foo', 'bar'],\n      numWorkers: 4,\n      workerSchedulingPolicy: 'in-order',\n    }) as JestWorkerFarm<{foo(a: unknown): void}>;\n\n    // The first call will go to the first child process.\n    const promise0 = farm.foo('param-0');\n    assertCallsToChild(0, ['foo', 'param-0']);\n\n    // The second call will go to the second child process.\n    const promise1 = farm.foo(1);\n\n    // The first task on worker 0 completes.\n    replySuccess(0, 'worker-0');\n    expect(await promise0).toBe('worker-0');\n\n    // The second task on worker 1 completes.\n    assertCallsToChild(1, ['foo', 1]);\n    replySuccess(1, 'worker-1');\n    expect(await promise1).toBe('worker-1');\n\n    // The third call will go to the first child process.\n    const promise2 = farm.foo('param-2');\n    assertCallsToChild(0, ['foo', 'param-0'], ['foo', 'param-2']);\n    replySuccess(0, 'worker-0');\n    expect(await promise2).toBe('worker-0');\n  });\n\n  it('distributes concurrent calls across child processes', async () => {\n    const farm = new WorkerFarm('/tmp/baz.js', {\n      exposedMethods: ['foo', 'bar'],\n      numWorkers: 4,\n    }) as JestWorkerFarm<{foo(a: unknown): void}>;\n\n    // Do 3 calls to the farm in parallel.\n    const promise0 = farm.foo('param-0');\n    const promise1 = farm.foo('param-1');\n    const promise2 = farm.foo('param-2');\n\n    // Check that the method calls are sent to each separate child process.\n    assertCallsToChild(0, ['foo', 'param-0']);\n    assertCallsToChild(1, ['foo', 'param-1']);\n    assertCallsToChild(2, ['foo', 'param-2']);\n\n    // Send different responses from each child.\n    replySuccess(0, 'worker-0');\n    replySuccess(1, 'worker-1');\n    replySuccess(2, 'worker-2');\n\n    // Check\n    expect(await promise0).toBe('worker-0');\n    expect(await promise1).toBe('worker-1');\n    expect(await promise2).toBe('worker-2');\n  });\n\n  it('sticks parallel calls to children', async () => {\n    const farm = new WorkerFarm('/tmp/baz.js', {\n      computeWorkerKey: () => '1234567890abcdef',\n      exposedMethods: ['foo', 'bar'],\n      numWorkers: 4,\n    }) as JestWorkerFarm<{foo(a: unknown): void}>;\n\n    // Do 3 calls to the farm in parallel.\n    const promise0 = farm.foo('param-0');\n    const promise1 = farm.foo('param-1');\n    const promise2 = farm.foo('param-2');\n\n    // Send different responses for each call (from the same child).\n    replySuccess(0, 'worker-0');\n    replySuccess(0, 'worker-1');\n    replySuccess(0, 'worker-2');\n\n    // Check that all the calls have been received by the same child.\n    assertCallsToChild(\n      0,\n      ['foo', 'param-0'],\n      ['foo', 'param-1'],\n      ['foo', 'param-2'],\n    );\n\n    // Check that responses are correct.\n    expect(await promise0).toBe('worker-0');\n    expect(await promise1).toBe('worker-1');\n    expect(await promise2).toBe('worker-2');\n  });\n\n  it('should check for memory limits', async () => {\n    const farm = new WorkerFarm('/tmp/baz.js', {\n      exposedMethods: ['foo', 'bar'],\n      idleMemoryLimit: 0.4,\n      numWorkers: 2,\n    }) as JestWorkerFarm<{foo(a: unknown): void}>;\n\n    // Send a call to the farm\n    farm.foo('param-0');\n\n    // Send different responses for each call (from the same child).\n    replySuccess(0, 'worker-0');\n\n    // Check that all the calls have been received by the same child.\n    // We're not using the assertCallsToChild helper because we need to check\n    // for other send types.\n    expect(mockForkedProcesses[0].send).toHaveBeenCalledTimes(3);\n    expect(jest.mocked(mockForkedProcesses[0].send).mock.calls[1][0]).toEqual([\n      CHILD_MESSAGE_CALL,\n      true,\n      'foo',\n      ['param-0'],\n    ]);\n    expect(jest.mocked(mockForkedProcesses[0].send).mock.calls[2][0]).toEqual([\n      CHILD_MESSAGE_MEM_USAGE,\n    ]);\n  });\n});\n",
  "packages/jest-worker/src/__tests__/process-integration.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-worker/src/__tests__/leak-integration.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport {join} from 'path';\nimport {writeFileSync} from 'graceful-fs';\nimport LeakDetector from 'jest-leak-detector';\nimport {type JestWorkerFarm, Worker} from '../../build';\n\ndescribe('WorkerThreads leaks', () => {\n  let workerFile: string;\n  beforeAll(() => {\n    workerFile = join(tmpdir(), 'baz.js');\n    writeFileSync(workerFile, 'module.exports.fn = () => {};');\n  });\n\n  let worker: JestWorkerFarm<{fn(a: unknown): void}>;\n  beforeEach(() => {\n    worker = new Worker(workerFile, {\n      enableWorkerThreads: true,\n      exposedMethods: ['fn'],\n    }) as JestWorkerFarm<{fn(a: unknown): void}>;\n  });\n  afterEach(async () => {\n    await worker.end();\n  });\n\n  it('does not retain arguments after a task finished', async () => {\n    let leakDetector: LeakDetector;\n    await new Promise((resolve, reject) => {\n      const obj = {};\n      leakDetector = new LeakDetector(obj);\n      worker.fn(obj).then(resolve, reject);\n    });\n\n    expect(await leakDetector!.isLeaking()).toBe(false);\n  });\n});\n\ndescribe('Worker leaks', () => {\n  let workerFile!: string;\n  beforeAll(() => {\n    workerFile = join(tmpdir(), 'baz.js');\n    writeFileSync(workerFile, 'module.exports.fn = (obj) => [obj];');\n  });\n\n  let worker: JestWorkerFarm<{fn(a: unknown): void}>;\n  beforeEach(() => {\n    worker = new Worker(workerFile, {\n      enableWorkerThreads: false,\n      exposedMethods: ['fn'],\n      forkOptions: {serialization: 'json'},\n    }) as JestWorkerFarm<{fn(a: unknown): void}>;\n  });\n  afterEach(async () => {\n    await worker.end();\n  });\n\n  it('does not retain result after next task call', async () => {\n    let leakDetector: LeakDetector;\n    await new Promise((resolve, reject) => {\n      const obj = {};\n      worker\n        .fn(obj)\n        .then((result: unknown) => {\n          leakDetector = new LeakDetector(result);\n          return result;\n        })\n        .then(resolve, reject);\n    });\n    await new Promise((resolve, reject) => {\n      const obj = {};\n      worker.fn(obj).then(resolve, reject);\n    });\n\n    expect(await leakDetector!.isLeaking()).toBe(false);\n  });\n});\n",
  "packages/jest-worker/src/__tests__/leak-integration.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-worker/src/__tests__/index.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {pathToFileURL} from 'url';\nimport type {JestWorkerFarm, Worker, WorkerFarmOptions} from '../';\nimport type FarmClass from '../Farm';\nimport type WorkerPoolClass from '../WorkerPool';\n\nlet WorkerFarm: typeof Worker;\nlet WorkerPool: typeof WorkerPoolClass;\nlet Farm: typeof FarmClass;\n\nbeforeEach(() => {\n  jest.mock('../Farm', () => {\n    const fakeClass = jest.fn(() => ({\n      doWork: jest.fn(() => 42),\n    }));\n\n    return {\n      __esModule: true,\n      default: fakeClass,\n    };\n  });\n\n  jest.mock('../WorkerPool', () => {\n    const fakeWorker = jest.fn(() => ({\n      createWorker: jest.fn(),\n      end: jest.fn(),\n      getStderr: () => '<mocked stderr>',\n      getStdout: () => '<mocked stdout>',\n      send: jest.fn(),\n    }));\n\n    return {\n      __esModule: true,\n      default: fakeWorker,\n    };\n  });\n\n  jest.mock(\n    '/fake-worker.js',\n    () => ({\n      _shouldNotExist1() {},\n      methodA() {},\n      methodB() {},\n    }),\n    {virtual: true},\n  );\n\n  jest.mock('/fake-worker-with-default-method.js', () => () => {}, {\n    virtual: true,\n  });\n\n  WorkerFarm = (require('../') as typeof import('../')).Worker;\n  Farm = (require('../Farm') as typeof import('../Farm')).default;\n  WorkerPool = (require('../WorkerPool') as typeof import('../WorkerPool'))\n    .default;\n});\n\nafterEach(() => {\n  jest.resetModules();\n});\n\nit('makes a non-existing relative worker throw', () => {\n  expect(() => {\n    // eslint-disable-next-line no-new\n    new WorkerFarm('./relative/worker-module.js');\n  }).toThrow(\"'workerPath' must be absolute\");\n});\n\nit('supports URLs', () => {\n  const workerPathUrl = pathToFileURL(__filename);\n\n  // eslint-disable-next-line no-new\n  new WorkerFarm(workerPathUrl, {exposedMethods: ['foo', 'bar']});\n  // eslint-disable-next-line no-new\n  new WorkerFarm(workerPathUrl.href, {exposedMethods: ['foo', 'bar']});\n\n  expect(WorkerPool).toHaveBeenCalledTimes(2);\n  expect(WorkerPool).toHaveBeenNthCalledWith(1, __filename, expect.anything());\n  expect(WorkerPool).toHaveBeenNthCalledWith(2, __filename, expect.anything());\n});\n\nit('exposes the right API using default working', () => {\n  const farm = new WorkerFarm('/tmp/baz.js', {\n    exposedMethods: ['foo', 'bar'],\n    numWorkers: 4,\n  }) as JestWorkerFarm<{foo(): void; bar(): void}>;\n\n  expect(typeof farm.foo).toBe('function');\n  expect(typeof farm.bar).toBe('function');\n});\n\nit('exposes the right API using passed worker', () => {\n  const WorkerPool = jest.fn(() => ({\n    createWorker: jest.fn(),\n    end: jest.fn(),\n    getStderr: jest.fn(),\n    getStdout: jest.fn(),\n    getWorkers: jest.fn(),\n    send: jest.fn(),\n    start: jest.fn(),\n  }));\n\n  const farm = new WorkerFarm('/tmp/baz.js', {\n    WorkerPool,\n    exposedMethods: ['foo', 'bar'],\n    numWorkers: 4,\n  } as WorkerFarmOptions) as JestWorkerFarm<{foo(): void; bar(): void}>;\n\n  expect(typeof farm.foo).toBe('function');\n  expect(typeof farm.bar).toBe('function');\n});\n\nit('breaks if any of the forbidden methods is tried to be exposed', () => {\n  expect(\n    () => new WorkerFarm('/tmp/baz.js', {exposedMethods: ['getStdout']}),\n  ).toThrow('Cannot define a method called getStdout');\n\n  expect(\n    () => new WorkerFarm('/tmp/baz.js', {exposedMethods: ['getStderr']}),\n  ).toThrow('Cannot define a method called getStderr');\n\n  expect(\n    () => new WorkerFarm('/tmp/baz.js', {exposedMethods: ['end']}),\n  ).toThrow('Cannot define a method called end');\n});\n\nit('works with minimal options', () => {\n  const farm1 = new WorkerFarm('/fake-worker.js') as JestWorkerFarm<{\n    methodA(): void;\n    methodB(): void;\n  }>;\n\n  expect(Farm).toHaveBeenCalledTimes(1);\n  expect(WorkerPool).toHaveBeenCalledTimes(1);\n  expect(typeof farm1.methodA).toBe('function');\n  expect(typeof farm1.methodB).toBe('function');\n  expect(farm1).toEqual(\n    expect.not.objectContaining({\n      _shouldNotExist: expect.anything,\n    }),\n  );\n\n  const farm2 = new WorkerFarm(\n    '/fake-worker-with-default-method.js',\n  ) as JestWorkerFarm<{default(): void}>;\n\n  expect(typeof farm2.default).toBe('function');\n});\n\nit('does not let make calls after the farm is ended', () => {\n  const farm = new WorkerFarm('/tmp/baz.js', {\n    exposedMethods: ['foo', 'bar'],\n    numWorkers: 4,\n  }) as JestWorkerFarm<{foo(): void; bar(): void}>;\n\n  farm.end();\n\n  // @ts-expect-error: Testing internal method\n  expect(farm._workerPool.end).toHaveBeenCalledTimes(1);\n  expect(() => farm.foo()).toThrow(\n    'Farm is ended, no more calls can be done to it',\n  );\n  expect(() => farm.bar()).toThrow(\n    'Farm is ended, no more calls can be done to it',\n  );\n});\n\nit('does not let end the farm after it is ended', async () => {\n  const farm = new WorkerFarm('/tmp/baz.js', {\n    exposedMethods: ['foo', 'bar'],\n    numWorkers: 4,\n  });\n\n  farm.end();\n  // @ts-expect-error: Testing internal method\n  expect(farm._workerPool.end).toHaveBeenCalledTimes(1);\n  await expect(farm.end()).rejects.toThrow(\n    'Farm is ended, no more calls can be done to it',\n  );\n  await expect(farm.end()).rejects.toThrow(\n    'Farm is ended, no more calls can be done to it',\n  );\n  // @ts-expect-error: Testing internal method\n  expect(farm._workerPool.end).toHaveBeenCalledTimes(1);\n});\n\nit('calls doWork', async () => {\n  const farm = new WorkerFarm('/tmp/baz.js', {\n    exposedMethods: ['foo', 'bar'],\n    numWorkers: 1,\n  }) as JestWorkerFarm<{foo(a: string, b: string): number}>;\n\n  const promise = farm.foo('car', 'plane');\n\n  expect(await promise).toBe(42);\n});\n\nit('calls getStderr and getStdout from worker', async () => {\n  const farm = new WorkerFarm('/tmp/baz.js', {\n    exposedMethods: ['foo', 'bar'],\n    numWorkers: 1,\n  });\n\n  expect(farm.getStderr()).toBe('<mocked stderr>');\n  expect(farm.getStdout()).toBe('<mocked stdout>');\n});\n",
  "packages/jest-worker/src/__tests__/index.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-worker/src/__tests__/WorkerPool.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport WorkerPool from '../WorkerPool';\nimport type {ChildMessage, WorkerPoolOptions} from '../types';\nimport ChildProcessWorker from '../workers/ChildProcessWorker';\nimport NodeThreadWorker from '../workers/NodeThreadsWorker';\n\njest.mock('../workers/ChildProcessWorker', () => {\n  const fakeClass = jest.fn(() => ({\n    getStderr: jest.fn(),\n    getStdout: jest.fn(),\n    send: jest.fn(),\n  }));\n\n  return {\n    __esModule: true,\n    default: fakeClass,\n  };\n});\n\njest.mock('../workers/NodeThreadsWorker', () => {\n  const fakeClass = jest.fn(() => ({\n    getStderr: jest.fn(),\n    getStdout: jest.fn(),\n    send: jest.fn(),\n  }));\n\n  return {\n    __esModule: true,\n    default: fakeClass,\n  };\n});\n\ndescribe('WorkerPool', () => {\n  beforeEach(() => {\n    jest.mocked(ChildProcessWorker).mockClear();\n    jest.mocked(NodeThreadWorker).mockClear();\n  });\n\n  it('should create a ChildProcessWorker and send to it', () => {\n    jest.mock('worker_threads', () => {\n      throw new Error('Undefined');\n    });\n    const workerPool = new WorkerPool('/path', {\n      forkOptions: {},\n      maxRetries: 1,\n      numWorkers: 1,\n    } as WorkerPoolOptions);\n\n    const request = {foo: 'bar'} as unknown as ChildMessage;\n    const onStart = () => {};\n    const onEnd = () => {};\n    const onCustomMessage = () => {};\n\n    workerPool.send(0, request, onStart, onEnd, onCustomMessage);\n\n    expect(ChildProcessWorker).toHaveBeenCalledWith({\n      forkOptions: {},\n      maxRetries: 1,\n      workerId: 0,\n      workerPath: '/path',\n    });\n    expect(NodeThreadWorker).not.toHaveBeenCalled();\n    // @ts-expect-error: Testing internal method\n    expect(workerPool._workers[0].send).toHaveBeenCalledWith(\n      request,\n      onStart,\n      onEnd,\n      onCustomMessage,\n    );\n  });\n\n  it('should create a NodeThreadWorker and send to it', () => {\n    jest.mock('worker_threads', () => 'Defined');\n    const workerPool = new WorkerPool('/path', {\n      enableWorkerThreads: true,\n      forkOptions: {},\n      maxRetries: 1,\n      numWorkers: 1,\n    } as WorkerPoolOptions);\n\n    const request = {foo: 'bar'} as unknown as ChildMessage;\n    const onStart = () => {};\n    const onEnd = () => {};\n    const onCustomMessage = () => {};\n\n    workerPool.send(0, request, onStart, onEnd, onCustomMessage);\n\n    expect(NodeThreadWorker).toHaveBeenCalledWith({\n      forkOptions: {},\n      maxRetries: 1,\n      workerId: 0,\n      workerPath: '/path',\n    });\n    expect(ChildProcessWorker).not.toHaveBeenCalled();\n    // @ts-expect-error: Testing internal method\n    expect(workerPool._workers[0].send).toHaveBeenCalledWith(\n      request,\n      onStart,\n      onEnd,\n      onCustomMessage,\n    );\n  });\n\n  it('should avoid NodeThreadWorker if not passed enableWorkerThreads', () => {\n    jest.mock('worker_threads', () => 'Defined');\n    const workerPool = new WorkerPool('/path', {\n      forkOptions: {},\n      maxRetries: 1,\n      numWorkers: 1,\n    } as WorkerPoolOptions);\n\n    const request = {foo: 'bar'} as unknown as ChildMessage;\n    const onStart = () => {};\n    const onEnd = () => {};\n    const onCustomMessage = () => {};\n\n    workerPool.send(0, request, onStart, onEnd, onCustomMessage);\n\n    expect(ChildProcessWorker).toHaveBeenCalledWith({\n      forkOptions: {},\n      maxRetries: 1,\n      workerId: 0,\n      workerPath: '/path',\n    });\n    expect(NodeThreadWorker).not.toHaveBeenCalled();\n    // @ts-expect-error: Testing internal method\n    expect(workerPool._workers[0].send).toHaveBeenCalledWith(\n      request,\n      onStart,\n      onEnd,\n      onCustomMessage,\n    );\n  });\n});\n",
  "packages/jest-worker/src/__tests__/WorkerPool.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-worker/src/__tests__/PriorityQueue.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport PriorityQueue from '../PriorityQueue';\nimport {\n  CHILD_MESSAGE_CALL,\n  type ChildMessageCall,\n  type QueueChildMessage,\n} from '../types';\n\nit('returns the tasks in order', () => {\n  const computePriority = (_method: string, task: unknown) =>\n    (task as {priority: number}).priority;\n  const queue = new PriorityQueue(computePriority);\n  const priorities = [10, 3, 4, 8, 2, 9, 7, 1, 2, 6, 5];\n\n  for (const priority of priorities) {\n    queue.enqueue(createQueueChildMessage({priority}));\n  }\n\n  priorities.sort((a, b) => a - b);\n  for (const priority of priorities) {\n    expect(queue.dequeue(0)).toEqual(\n      expect.objectContaining({\n        request: [CHILD_MESSAGE_CALL, false, 'test', [{priority}]],\n      }),\n    );\n  }\n\n  expect(queue.dequeue(0)).toBeNull();\n});\n\nit('returns the task with the lowest priority value if inserted in reversed order', () => {\n  const last = createQueueChildMessage({priority: 3});\n  const mid = createQueueChildMessage({priority: 2});\n  const first = createQueueChildMessage({priority: 1});\n\n  const computePriority = (_method: string, task: unknown) =>\n    (task as {priority: number}).priority;\n  const queue = new PriorityQueue(computePriority);\n\n  queue.enqueue(last, 1);\n  queue.enqueue(first, 1);\n  queue.enqueue(mid, 1);\n\n  expect(queue.dequeue(1)).toBe(first);\n  expect(queue.dequeue(1)).toBe(mid);\n  expect(queue.dequeue(1)).toBe(last);\n  expect(queue.dequeue(1)).toBeNull();\n});\n\nit('returns the task with the lowest priority value if inserted in correct order', () => {\n  const first = createQueueChildMessage({priority: 1});\n  const mid = createQueueChildMessage({priority: 2});\n  const last = createQueueChildMessage({priority: 3});\n\n  const computePriority = (_method: string, task: unknown) =>\n    (task as {priority: number}).priority;\n  const queue = new PriorityQueue(computePriority);\n\n  queue.enqueue(last, 1);\n  queue.enqueue(first, 1);\n  queue.enqueue(mid, 1);\n\n  expect(queue.dequeue(1)).toBe(first);\n  expect(queue.dequeue(1)).toBe(mid);\n  expect(queue.dequeue(1)).toBe(last);\n  expect(queue.dequeue(1)).toBeNull();\n});\n\nit('uses different queues for each worker', () => {\n  const task1Worker1 = createQueueChildMessage({priority: 1});\n  const task2Worker1 = createQueueChildMessage({priority: 3});\n  const task1Worker2 = createQueueChildMessage({priority: 1});\n  const task2Worker2 = createQueueChildMessage({priority: 3});\n\n  const computePriority = (_method: string, task: unknown) =>\n    (task as {priority: number}).priority;\n  const queue = new PriorityQueue(computePriority);\n\n  queue.enqueue(task2Worker1, 1);\n  queue.enqueue(task1Worker1, 1);\n  queue.enqueue(task2Worker2, 2);\n  queue.enqueue(task1Worker2, 2);\n\n  expect(queue.dequeue(1)).toBe(task1Worker1);\n  expect(queue.dequeue(1)).toBe(task2Worker1);\n  expect(queue.dequeue(2)).toBe(task1Worker2);\n  expect(queue.dequeue(2)).toBe(task2Worker2);\n  expect(queue.dequeue(1)).toBeNull();\n});\n\nit('process task in the global and shared queue in order', () => {\n  const computePriority = (_method: string, task: unknown) =>\n    (task as {priority: number}).priority;\n  const queue = new PriorityQueue(computePriority);\n\n  const sharedTask1 = createQueueChildMessage({priority: 1});\n  const sharedTask2 = createQueueChildMessage({priority: 3});\n  queue.enqueue(sharedTask1);\n  queue.enqueue(sharedTask2);\n\n  const worker1Task1 = createQueueChildMessage({priority: 0});\n  const worker1Task2 = createQueueChildMessage({priority: 2});\n  queue.enqueue(worker1Task1, 1);\n  queue.enqueue(worker1Task2, 1);\n\n  const worker2Task1 = createQueueChildMessage({priority: 3});\n  queue.enqueue(worker2Task1, 2);\n\n  expect(queue.dequeue(1)).toBe(worker1Task1);\n  expect(queue.dequeue(1)).toBe(sharedTask1);\n  expect(queue.dequeue(1)).toBe(worker1Task2);\n\n  expect(queue.dequeue(2)).toBe(worker2Task1);\n  expect(queue.dequeue(2)).toBe(sharedTask2);\n\n  expect(queue.dequeue(1)).toBeNull();\n  expect(queue.dequeue(2)).toBeNull();\n});\n\nfunction createQueueChildMessage(...args: Array<unknown>): QueueChildMessage {\n  const request: ChildMessageCall = [CHILD_MESSAGE_CALL, false, 'test', args];\n\n  return {\n    onCustomMessage: () => {},\n    onEnd: () => {},\n    onStart: () => {},\n    request,\n  };\n}\n",
  "packages/jest-worker/src/__tests__/PriorityQueue.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-worker/src/__tests__/FifoQueue.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport FifoQueue from '../FifoQueue';\nimport {\n  CHILD_MESSAGE_CALL,\n  type ChildMessageCall,\n  type QueueChildMessage,\n} from '../types';\n\nit('returns the shared tasks in FIFO ordering', () => {\n  const queue = new FifoQueue();\n\n  const task1 = createQueueChildMessage();\n  const task2 = createQueueChildMessage();\n  const task3 = createQueueChildMessage();\n\n  queue.enqueue(task1);\n  queue.enqueue(task2);\n  queue.enqueue(task3);\n\n  expect(queue.dequeue(1)).toBe(task1);\n  expect(queue.dequeue(2)).toBe(task2);\n  expect(queue.dequeue(3)).toBe(task3);\n\n  expect(queue.dequeue(1)).toBeNull();\n  expect(queue.dequeue(2)).toBeNull();\n  expect(queue.dequeue(3)).toBeNull();\n});\n\nit('returns the worker specific tasks in FIFO ordering', () => {\n  const queue = new FifoQueue();\n\n  const task1 = createQueueChildMessage();\n  const task2 = createQueueChildMessage();\n  const task3 = createQueueChildMessage();\n\n  queue.enqueue(task1, 1);\n  queue.enqueue(task2, 1);\n  queue.enqueue(task3, 1);\n\n  expect(queue.dequeue(1)).toBe(task1);\n  expect(queue.dequeue(1)).toBe(task2);\n  expect(queue.dequeue(1)).toBe(task3);\n\n  expect(queue.dequeue(1)).toBeNull();\n});\n\nit('maintains global FIFO ordering between worker specific and shared tasks', () => {\n  const queue = new FifoQueue();\n\n  const sharedTask1 = createQueueChildMessage({name: 'sharedTask1'});\n  const sharedTask2 = createQueueChildMessage({name: 'sharedTask2'});\n  const sharedTask3 = createQueueChildMessage({name: 'sharedTask3'});\n  const worker1Task1 = createQueueChildMessage({name: 'worker1Task1'});\n  const worker1Task2 = createQueueChildMessage({name: 'worker1Task2'});\n  const worker2Task2 = createQueueChildMessage({name: 'worker2Task1'});\n\n  queue.enqueue(worker1Task1, 1);\n  queue.enqueue(sharedTask1);\n  queue.enqueue(sharedTask2);\n  queue.enqueue(worker1Task2, 1);\n  queue.enqueue(worker2Task2, 2);\n  queue.enqueue(sharedTask3);\n\n  expect(queue.dequeue(1)).toBe(worker1Task1);\n  expect(queue.dequeue(2)).toBe(sharedTask1);\n  sharedTask1.request[1] = true;\n\n  expect(queue.dequeue(1)).toBe(sharedTask2);\n  sharedTask2.request[1] = true;\n\n  expect(queue.dequeue(1)).toBe(worker1Task2);\n  expect(queue.dequeue(1)).toBe(sharedTask3);\n  sharedTask3.request[1] = true;\n\n  expect(queue.dequeue(2)).toBe(worker2Task2);\n\n  expect(queue.dequeue(1)).toBeNull();\n  expect(queue.dequeue(2)).toBeNull();\n});\n\nfunction createQueueChildMessage(...args: Array<unknown>): QueueChildMessage {\n  const request: ChildMessageCall = [CHILD_MESSAGE_CALL, false, 'test', args];\n\n  return {\n    onCustomMessage: () => {},\n    onEnd: () => {},\n    onStart: () => {},\n    request,\n  };\n}\n",
  "packages/jest-worker/src/__tests__/FifoQueue.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-worker/src/__tests__/Farm.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport Farm from '../Farm';\nimport type {\n  ChildMessage,\n  OnCustomMessage,\n  OnEnd,\n  OnStart,\n  WorkerCallback,\n  WorkerInterface,\n} from '../types';\n\nlet mockWorkerCalls: Array<{\n  onCustomMessage: OnCustomMessage;\n  onEnd: OnEnd;\n  onStart: OnStart;\n  passed: ChildMessage;\n  workerId: number;\n}>;\n\nlet callback: WorkerCallback;\n\nfunction workerReplyStart(i: number) {\n  mockWorkerCalls[i].onStart({\n    getWorkerId: () => mockWorkerCalls[i].workerId,\n  } as WorkerInterface);\n}\n\nfunction workerReplyEnd(i: number, error: Error | null, result?: unknown) {\n  mockWorkerCalls[i].onEnd(error, result);\n}\n\nfunction workerReply(i: number, error: Error | null = null, result?: unknown) {\n  workerReplyStart(i);\n  workerReplyEnd(i, error, result);\n}\n\nfunction workerReplyCustomMessage(i: number, message: unknown) {\n  mockWorkerCalls[i].onCustomMessage(message);\n}\n\ndescribe('Farm', () => {\n  beforeEach(() => {\n    mockWorkerCalls = [];\n    callback = jest.fn<WorkerCallback>(\n      (workerId, request, onStart, onEnd, onCustomMessage) => {\n        mockWorkerCalls.push({\n          onCustomMessage,\n          onEnd,\n          onStart,\n          passed: request,\n          workerId,\n        });\n      },\n    );\n  });\n\n  it('sends a request to one worker', () => {\n    const farm = new Farm(4, callback);\n\n    farm.doWork('foo', 42);\n\n    expect(callback).toHaveBeenCalledTimes(1);\n    expect(callback).toHaveBeenCalledWith(\n      0,\n      [1, true, 'foo', [42]],\n      expect.any(Function),\n      expect.any(Function),\n      expect.any(Function),\n    );\n  });\n\n  it('sends four requests to four unique workers', () => {\n    const farm = new Farm(4, callback);\n\n    farm.doWork('foo', 42);\n    farm.doWork('foo1', 43);\n    farm.doWork('foo2', 44);\n    farm.doWork('foo3', 45);\n\n    expect(callback).toHaveBeenCalledTimes(4);\n    expect(callback).toHaveBeenNthCalledWith(\n      1,\n      0, // first worker\n      [1, true, 'foo', [42]],\n      expect.any(Function),\n      expect.any(Function),\n      expect.any(Function),\n    );\n    expect(callback).toHaveBeenNthCalledWith(\n      2,\n      1, // second worker\n      [1, true, 'foo1', [43]],\n      expect.any(Function),\n      expect.any(Function),\n\n      expect.any(Function),\n    );\n    expect(callback).toHaveBeenNthCalledWith(\n      3,\n      2, // third worker\n      [1, true, 'foo2', [44]],\n      expect.any(Function),\n      expect.any(Function),\n      expect.any(Function),\n    );\n    expect(callback).toHaveBeenNthCalledWith(\n      4,\n      3, // fourth worker\n      [1, true, 'foo3', [45]],\n      expect.any(Function),\n      expect.any(Function),\n      expect.any(Function),\n    );\n  });\n\n  it('handles null computeWorkerKey, sending to first worker', async () => {\n    const computeWorkerKey = jest.fn<\n      (method: string, ...args: Array<unknown>) => string | null\n    >(() => null);\n\n    const farm = new Farm(4, callback, {computeWorkerKey});\n\n    const p0 = farm.doWork('foo', 42);\n    workerReply(0);\n    await p0;\n\n    expect(computeWorkerKey).toHaveBeenCalledTimes(1);\n    expect(computeWorkerKey).toHaveBeenNthCalledWith(1, 'foo', 42);\n\n    expect(callback).toHaveBeenCalledTimes(1);\n    expect(callback).toHaveBeenNthCalledWith(\n      1,\n      0, // first worker\n      [1, true, 'foo', [42]],\n      expect.any(Function),\n      expect.any(Function),\n      expect.any(Function),\n    );\n  });\n\n  it('sends the same worker key to the same worker', async () => {\n    const computeWorkerKey = jest\n      .fn<(method: string, ...args: Array<unknown>) => string | null>()\n      .mockReturnValueOnce('one')\n      .mockReturnValueOnce('two')\n      .mockReturnValueOnce('one');\n\n    const farm = new Farm(4, callback, {computeWorkerKey});\n\n    const p0 = farm.doWork('foo', 42);\n    workerReply(0);\n    await p0;\n\n    const p1 = farm.doWork('foo1', 43);\n    workerReply(1);\n    await p1;\n\n    const p2 = farm.doWork('foo2', 44);\n    workerReply(2);\n    await p2;\n\n    expect(computeWorkerKey).toHaveBeenCalledTimes(3);\n    expect(computeWorkerKey).toHaveBeenNthCalledWith(1, 'foo', 42);\n    expect(computeWorkerKey).toHaveBeenNthCalledWith(2, 'foo1', 43);\n    expect(computeWorkerKey).toHaveBeenNthCalledWith(3, 'foo2', 44);\n\n    expect(callback).toHaveBeenCalledTimes(3);\n    expect(callback).toHaveBeenNthCalledWith(\n      1,\n      0, // first worker\n      [1, true, 'foo', [42]],\n      expect.any(Function),\n      expect.any(Function),\n      expect.any(Function),\n    );\n    expect(callback).toHaveBeenNthCalledWith(\n      2,\n      1, // second worker\n      [1, true, 'foo1', [43]],\n      expect.any(Function),\n      expect.any(Function),\n      expect.any(Function),\n    );\n    expect(callback).toHaveBeenNthCalledWith(\n      3,\n      0, // first worker again\n      [1, true, 'foo2', [44]],\n      expect.any(Function),\n      expect.any(Function),\n      expect.any(Function),\n    );\n  });\n\n  it('returns the result if the call worked', async () => {\n    const farm = new Farm(4, callback);\n\n    const promise = farm.doWork('car', 'plane');\n\n    workerReply(0, null, 34);\n    const result = await promise;\n\n    expect(result).toBe(34);\n  });\n\n  it('throws if the call failed', async () => {\n    const farm = new Farm(4, callback);\n\n    const promise = farm.doWork('car', 'plane');\n    let thrownError = null;\n\n    workerReply(0, new TypeError('Massively broken'));\n\n    try {\n      await promise;\n    } catch (error) {\n      thrownError = error;\n    }\n\n    expect(thrownError).not.toBeNull();\n    expect(thrownError).toBeInstanceOf(TypeError);\n  });\n\n  it('checks that once a sticked task finishes, next time is sent to that worker', async () => {\n    const farm = new Farm(4, callback, {\n      computeWorkerKey: () => '1234567890abcdef',\n    });\n\n    // Worker 1 successfully replies with \"17\" as a result.\n    const p0 = farm.doWork('car', 'plane');\n    workerReply(0, null, 17);\n    await p0;\n\n    // Note that the stickiness is not created by the method name or the\n    // arguments it is solely controlled by the provided \"computeWorkerKey\"\n    // method, which in the test example always returns the same key, so all\n    // calls should be redirected to worker 1 (which is the one that resolved\n    // the first call).\n    const p1 = farm.doWork('foo', 'bar');\n    workerReply(1, null, 17);\n    await p1;\n\n    // The first time, a call with a \"1234567890abcdef\" hash had never been\n    // done earlier (\"foo\" call), so it got queued to all workers. Later, since\n    // the one that resolved the call was the one in position 1, all subsequent\n    // calls are only redirected to that worker.\n    expect(callback).toHaveBeenCalledTimes(2); // Only \"foo\".\n    expect(callback).toHaveBeenNthCalledWith(\n      1,\n      0, // first worker\n      [1, true, 'car', ['plane']],\n      expect.any(Function),\n      expect.any(Function),\n      expect.any(Function),\n    );\n    expect(callback).toHaveBeenNthCalledWith(\n      2,\n      0, // first worker\n      [1, true, 'foo', ['bar']],\n      expect.any(Function),\n      expect.any(Function),\n      expect.any(Function),\n    );\n  });\n\n  it('checks that even before a sticked task finishes, next time is sent to that worker', async () => {\n    const farm = new Farm(4, callback, {\n      computeWorkerKey: () => '1234567890abcdef',\n    });\n\n    // Note that the worker is sending a start response synchronously.\n    const p0 = farm.doWork('car', 'plane');\n    workerReplyStart(0);\n\n    // Note that the worker is sending a start response synchronously.\n    const p1 = farm.doWork('foo', 'bar');\n\n    // The first call is sent the worker, the second is queued\n    expect(callback).toHaveBeenCalledTimes(1);\n\n    // Flush the queue\n    workerReplyEnd(0, null, 17);\n    await p0;\n    workerReply(1, null, 17);\n    await p1;\n\n    // Both requests are send to the same worker.  The first time, a call with\n    // a \"1234567890abcdef\" hash had never been done earlier (\"foo\" call), so\n    // it got queued to all workers. Later, since the one that resolved the\n    // call was the one in position 1, all subsequent calls are only redirected\n    // to that worker.\n    expect(callback).toHaveBeenCalledTimes(2);\n    expect(callback).toHaveBeenNthCalledWith(\n      1,\n      0, // first worker\n      [1, true, 'car', ['plane']],\n      expect.any(Function),\n      expect.any(Function),\n      expect.any(Function),\n    );\n    expect(callback).toHaveBeenNthCalledWith(\n      2,\n      0, // first worker\n      [1, true, 'foo', ['bar']],\n      expect.any(Function),\n      expect.any(Function),\n      expect.any(Function),\n    );\n  });\n\n  it('checks that locking works, and jobs are never lost', async () => {\n    const hash = jest\n      .fn<() => string>()\n      // This will go to both queues, but picked by the first worker.\n      .mockReturnValueOnce('0')\n      // This will go to both queues too, but picked by the second worker.\n      .mockReturnValueOnce('1')\n      // This will go to worker '0', now only assigned to it.\n      .mockReturnValueOnce('0')\n      // This will go to worker '1', now only assigned to it.\n      .mockReturnValueOnce('1')\n      // This will go to both queues too, but will wait, since workers are busy.\n      .mockReturnValueOnce('2')\n      // This will only go to the first queue.\n      .mockReturnValueOnce('0')\n      // This will be gone if the queue implementation is wrong.\n      .mockReturnValueOnce('0')\n      // Push onto the second queue; potentially wiping the earlier job.\n      .mockReturnValueOnce('1');\n\n    const farm = new Farm(2, callback, {computeWorkerKey: hash});\n\n    // First and second jobs get resolved, so that their hash is sticked to\n    // the right worker: worker assignment is performed when workers reply, not\n    // when the call is made.\n    const p0 = farm.doWork('work-0');\n    const p1 = farm.doWork('work-1');\n    workerReply(0, null, 'response-0');\n    await p0;\n    workerReply(1, null, 'response-1');\n    await p1;\n\n    // Now we perform the rest of the calls (7 resolves before 5 and 6, since 4\n    // is in both queues, and as soon as you resolve 4, 7 will be picked).\n    const p2 = farm.doWork('work-2');\n    const p3 = farm.doWork('work-3');\n    const p4 = farm.doWork('work-4');\n    const p5 = farm.doWork('work-5');\n    const p6 = farm.doWork('work-6');\n    const p7 = farm.doWork('work-7');\n    workerReply(2, null, 'response-2');\n    await p2;\n    workerReply(3, null, 'response-3');\n    await p3;\n    workerReply(4, null, 'response-4');\n    await p4;\n    workerReply(5, null, 'response-7');\n    await p7;\n    workerReply(6, null, 'response-5');\n    await p5;\n    workerReply(7, null, 'response-6');\n    await p6;\n\n    await expect(p0).resolves.toBe('response-0');\n    await expect(p1).resolves.toBe('response-1');\n    await expect(p2).resolves.toBe('response-2');\n    await expect(p3).resolves.toBe('response-3');\n    await expect(p4).resolves.toBe('response-4');\n    await expect(p5).resolves.toBe('response-5');\n    await expect(p6).resolves.toBe('response-6');\n    await expect(p7).resolves.toBe('response-7');\n  });\n\n  it('can receive custom messages from workers', async () => {\n    expect.assertions(2);\n    const farm = new Farm(2, callback);\n\n    const p0 = farm.doWork('work-0');\n    const p1 = farm.doWork('work-1');\n\n    const unsubscribe = p0.UNSTABLE_onCustomMessage!(message => {\n      expect(message).toEqual({key: 0, message: 'foo'});\n    });\n\n    p1.UNSTABLE_onCustomMessage!(message => {\n      expect(message).toEqual({key: 1, message: 'bar'});\n    });\n\n    workerReplyStart(0);\n    workerReplyStart(1);\n    workerReplyCustomMessage(0, {key: 0, message: 'foo'});\n    workerReplyCustomMessage(1, {key: 1, message: 'bar'});\n\n    unsubscribe();\n    // This message will not received because the listener already\n    // unsubscribed.\n    workerReplyCustomMessage(0, {key: 0, message: 'baz'});\n\n    workerReply(0, null, 17);\n    workerReply(1, null, 17);\n    await p0;\n    await p1;\n  });\n});\n",
  "packages/jest-worker/src/__tests__/Farm.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-worker/__typetests__/testWorker.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nexport function runTest(a: string, b: boolean): void {}\nexport async function runTestAsync(c: number, d: number): Promise<void> {}\n\nexport function doSomething(): void {}\nexport async function doSomethingAsync(): Promise<void> {}\n\nfunction getResult(): string {\n  return 'result';\n}\nexport const isResult = true;\n\n// reserved keys should be excluded from returned type\n\nexport function end(): void {}\nexport function getStderr(): string {\n  return 'get-err';\n}\nexport function getStdout(): string {\n  return 'get-out';\n}\nexport function setup(): void {}\nexport function teardown(): void {}\n",
  "packages/jest-worker/__typetests__/testWorker.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport declare function runTest(a: string, b: boolean): void;\nexport declare function runTestAsync(c: number, d: number): Promise<void>;\nexport declare function doSomething(): void;\nexport declare function doSomethingAsync(): Promise<void>;\nexport declare const isResult = true;\nexport declare function end(): void;\nexport declare function getStderr(): string;\nexport declare function getStdout(): string;\nexport declare function setup(): void;\nexport declare function teardown(): void;\n",
  "packages/jest-worker/__typetests__/jest-worker.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {expect, test} from 'tstyche';\nimport type {JestWorkerFarm} from 'jest-worker';\nimport type * as testWorker from './testWorker';\n\ntype TestWorker = {\n  runTest: (a: string, b: number) => void;\n  doSomething: () => void;\n  isResult: boolean;\n\n  // the reserved keys should not be included in the resulting type\n  end: () => void;\n  getStderr: () => string;\n  getStdout: () => string;\n  setup: () => void;\n  teardown: () => void;\n};\n\ndeclare const unknownWorkerFarm: JestWorkerFarm<Record<string, unknown>>;\n\ntest('unknown JestWorkerFarm', () => {\n  expect(unknownWorkerFarm).type.not.toHaveProperty('runTest');\n  expect(unknownWorkerFarm).type.not.toHaveProperty('runTestAsync');\n\n  expect(unknownWorkerFarm).type.not.toHaveProperty('getResult');\n  expect(unknownWorkerFarm).type.not.toHaveProperty('isResult');\n\n  expect(unknownWorkerFarm).type.not.toHaveProperty('setup');\n  expect(unknownWorkerFarm).type.not.toHaveProperty('teardown');\n\n  expect(unknownWorkerFarm.start()).type.toBe<Promise<void>>();\n  expect(unknownWorkerFarm.end()).type.toBe<Promise<{forceExited: boolean}>>();\n\n  expect(unknownWorkerFarm.getStderr()).type.toBe<NodeJS.ReadableStream>();\n  expect(unknownWorkerFarm.getStdout()).type.toBe<NodeJS.ReadableStream>();\n});\n\ndeclare const inferredWorkerFarm: JestWorkerFarm<typeof testWorker>;\n\ntest('inferred JestWorkerFarm', () => {\n  expect(inferredWorkerFarm.runTest('abc', true)).type.toBe<Promise<void>>();\n  expect(inferredWorkerFarm.runTestAsync(123, 456)).type.toBe<Promise<void>>();\n\n  expect(inferredWorkerFarm.doSomething()).type.toBe<Promise<void>>();\n  expect(inferredWorkerFarm.doSomething()).type.toBe<Promise<void>>();\n  expect(inferredWorkerFarm.doSomethingAsync()).type.toBe<Promise<void>>();\n  expect(inferredWorkerFarm.doSomethingAsync()).type.toBe<Promise<void>>();\n\n  expect(inferredWorkerFarm.runTest).type.not.toBeCallableWith();\n  expect(inferredWorkerFarm.runTest).type.not.toBeCallableWith('abc');\n  expect(inferredWorkerFarm.runTestAsync).type.not.toBeCallableWith();\n  expect(inferredWorkerFarm.runTestAsync).type.not.toBeCallableWith(123);\n  expect(inferredWorkerFarm.doSomething).type.not.toBeCallableWith(123);\n  expect(inferredWorkerFarm.doSomethingAsync).type.not.toBeCallableWith('abc');\n\n  expect(inferredWorkerFarm).type.not.toHaveProperty('getResult');\n  expect(inferredWorkerFarm).type.not.toHaveProperty('isResult');\n\n  expect(inferredWorkerFarm).type.not.toHaveProperty('setup');\n  expect(inferredWorkerFarm).type.not.toHaveProperty('teardown');\n\n  expect(inferredWorkerFarm.start()).type.toBe<Promise<void>>();\n  expect(inferredWorkerFarm.end()).type.toBe<Promise<{forceExited: boolean}>>();\n\n  expect(inferredWorkerFarm.getStderr()).type.toBe<NodeJS.ReadableStream>();\n  expect(inferredWorkerFarm.getStdout()).type.toBe<NodeJS.ReadableStream>();\n});\n\ndeclare const typedWorkerFarm: JestWorkerFarm<TestWorker>;\n\ntest('typed JestWorkerFarm', () => {\n  expect(typedWorkerFarm.runTest('abc', 123)).type.toBe<Promise<void>>();\n  expect(typedWorkerFarm.doSomething()).type.toBe<Promise<void>>();\n\n  expect(typedWorkerFarm.runTest).type.not.toBeCallableWith();\n  expect(typedWorkerFarm.runTest).type.not.toBeCallableWith('abc');\n  expect(typedWorkerFarm.doSomething).type.not.toBeCallableWith('abc');\n\n  expect(typedWorkerFarm).type.not.toHaveProperty('isResult');\n  expect(typedWorkerFarm).type.not.toHaveProperty('runTestAsync');\n\n  expect(typedWorkerFarm).type.not.toHaveProperty('setup');\n  expect(typedWorkerFarm).type.not.toHaveProperty('teardown');\n\n  expect(typedWorkerFarm.start()).type.toBe<Promise<void>>();\n  expect(typedWorkerFarm.end()).type.toBe<Promise<{forceExited: boolean}>>();\n\n  expect(typedWorkerFarm.getStderr()).type.toBe<NodeJS.ReadableStream>();\n  expect(typedWorkerFarm.getStdout()).type.toBe<NodeJS.ReadableStream>();\n});\n",
  "packages/jest-worker/__typetests__/jest-worker.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-watcher/src/types.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {ReadStream, WriteStream} from 'tty';\nimport type {AggregatedResult} from '@jest/test-result';\nimport type {Config} from '@jest/types';\n\ntype TestSuiteInfo = {\n  config: Config.ProjectConfig;\n  duration?: number;\n  testPath: string;\n};\n\nexport type JestHookExposedFS = {\n  projects: Array<{\n    config: Config.ProjectConfig;\n    testPaths: Array<string>;\n  }>;\n};\n\nexport type FileChange = (fs: JestHookExposedFS) => void;\nexport type ShouldRunTestSuite = (\n  testSuiteInfo: TestSuiteInfo,\n) => Promise<boolean>;\nexport type TestRunComplete = (results: AggregatedResult) => void;\n\nexport type JestHookSubscriber = {\n  onFileChange: (fn: FileChange) => void;\n  onTestRunComplete: (fn: TestRunComplete) => void;\n  shouldRunTestSuite: (fn: ShouldRunTestSuite) => void;\n};\n\nexport type JestHookEmitter = {\n  onFileChange: (fs: JestHookExposedFS) => void;\n  onTestRunComplete: (results: AggregatedResult) => void;\n  shouldRunTestSuite: (\n    testSuiteInfo: TestSuiteInfo,\n  ) => Promise<boolean> | boolean;\n};\n\nexport type UsageData = {\n  key: string;\n  prompt: string;\n};\n\nexport type AllowedConfigOptions = Partial<\n  Pick<\n    Config.GlobalConfig,\n    | 'bail'\n    | 'changedSince'\n    | 'collectCoverage'\n    | 'collectCoverageFrom'\n    | 'coverageDirectory'\n    | 'coverageReporters'\n    | 'findRelatedTests'\n    | 'nonFlagArgs'\n    | 'notify'\n    | 'notifyMode'\n    | 'onlyFailures'\n    | 'reporters'\n    | 'testNamePattern'\n    | 'updateSnapshot'\n    | 'verbose'\n  > & {\n    mode: 'watch' | 'watchAll';\n    testPathPatterns: Array<string>;\n  }\n>;\n\nexport type UpdateConfigCallback = (config?: AllowedConfigOptions) => void;\n\nexport interface WatchPlugin {\n  isInternal?: boolean;\n  apply?: (hooks: JestHookSubscriber) => void;\n  getUsageInfo?: (globalConfig: Config.GlobalConfig) => UsageData | null;\n  onKey?: (value: string) => void;\n  run?: (\n    globalConfig: Config.GlobalConfig,\n    updateConfigAndRun: UpdateConfigCallback,\n  ) => Promise<void | boolean>;\n}\nexport type WatchPluginClass = new (options: {\n  config: Record<string, unknown>;\n  stdin: ReadStream;\n  stdout: WriteStream;\n}) => WatchPlugin;\n\nexport type ScrollOptions = {\n  offset: number;\n  max: number;\n};\n",
  "packages/jest-watcher/src/types.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { ReadStream, WriteStream } from 'tty';\nimport type { AggregatedResult } from '@jest/test-result';\nimport type { Config } from '@jest/types';\ntype TestSuiteInfo = {\n    config: Config.ProjectConfig;\n    duration?: number;\n    testPath: string;\n};\nexport type JestHookExposedFS = {\n    projects: Array<{\n        config: Config.ProjectConfig;\n        testPaths: Array<string>;\n    }>;\n};\nexport type FileChange = (fs: JestHookExposedFS) => void;\nexport type ShouldRunTestSuite = (testSuiteInfo: TestSuiteInfo) => Promise<boolean>;\nexport type TestRunComplete = (results: AggregatedResult) => void;\nexport type JestHookSubscriber = {\n    onFileChange: (fn: FileChange) => void;\n    onTestRunComplete: (fn: TestRunComplete) => void;\n    shouldRunTestSuite: (fn: ShouldRunTestSuite) => void;\n};\nexport type JestHookEmitter = {\n    onFileChange: (fs: JestHookExposedFS) => void;\n    onTestRunComplete: (results: AggregatedResult) => void;\n    shouldRunTestSuite: (testSuiteInfo: TestSuiteInfo) => Promise<boolean> | boolean;\n};\nexport type UsageData = {\n    key: string;\n    prompt: string;\n};\nexport type AllowedConfigOptions = Partial<Pick<Config.GlobalConfig, 'bail' | 'changedSince' | 'collectCoverage' | 'collectCoverageFrom' | 'coverageDirectory' | 'coverageReporters' | 'findRelatedTests' | 'nonFlagArgs' | 'notify' | 'notifyMode' | 'onlyFailures' | 'reporters' | 'testNamePattern' | 'updateSnapshot' | 'verbose'> & {\n    mode: 'watch' | 'watchAll';\n    testPathPatterns: Array<string>;\n}>;\nexport type UpdateConfigCallback = (config?: AllowedConfigOptions) => void;\nexport interface WatchPlugin {\n    isInternal?: boolean;\n    apply?: (hooks: JestHookSubscriber) => void;\n    getUsageInfo?: (globalConfig: Config.GlobalConfig) => UsageData | null;\n    onKey?: (value: string) => void;\n    run?: (globalConfig: Config.GlobalConfig, updateConfigAndRun: UpdateConfigCallback) => Promise<void | boolean>;\n}\nexport type WatchPluginClass = new (options: {\n    config: Record<string, unknown>;\n    stdin: ReadStream;\n    stdout: WriteStream;\n}) => WatchPlugin;\nexport type ScrollOptions = {\n    offset: number;\n    max: number;\n};\nexport {};\n",
  "packages/jest-watcher/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nexport {default as BaseWatchPlugin} from './BaseWatchPlugin';\nexport {default as JestHook} from './JestHooks';\nexport {default as PatternPrompt} from './PatternPrompt';\nexport {default as TestWatcher} from './TestWatcher';\nexport * from './constants';\nexport type {\n  AllowedConfigOptions,\n  JestHookEmitter,\n  JestHookSubscriber,\n  ScrollOptions,\n  UpdateConfigCallback,\n  UsageData,\n  WatchPlugin,\n  WatchPluginClass,\n} from './types';\nexport {default as Prompt} from './lib/Prompt';\nexport * from './lib/patternModeHelpers';\n",
  "packages/jest-watcher/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport { default as BaseWatchPlugin } from './BaseWatchPlugin';\nexport { default as JestHook } from './JestHooks';\nexport { default as PatternPrompt } from './PatternPrompt';\nexport { default as TestWatcher } from './TestWatcher';\nexport * from './constants';\nexport type { AllowedConfigOptions, JestHookEmitter, JestHookSubscriber, ScrollOptions, UpdateConfigCallback, UsageData, WatchPlugin, WatchPluginClass, } from './types';\nexport { default as Prompt } from './lib/Prompt';\nexport * from './lib/patternModeHelpers';\n",
  "packages/jest-watcher/src/constants.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst isWindows = process.platform === 'win32';\n\nexport const KEYS = {\n  ARROW_DOWN: '\\u001B[B',\n  ARROW_LEFT: '\\u001B[D',\n  ARROW_RIGHT: '\\u001B[C',\n  ARROW_UP: '\\u001B[A',\n  BACKSPACE: Buffer.from(isWindows ? '08' : '7f', 'hex').toString(),\n  CONTROL_C: '\\u0003',\n  CONTROL_D: '\\u0004',\n  CONTROL_U: '\\u0015',\n  ENTER: '\\r',\n  ESCAPE: '\\u001B',\n};\n",
  "packages/jest-watcher/src/constants.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport declare const KEYS: {\n    ARROW_DOWN: string;\n    ARROW_LEFT: string;\n    ARROW_RIGHT: string;\n    ARROW_UP: string;\n    BACKSPACE: string;\n    CONTROL_C: string;\n    CONTROL_D: string;\n    CONTROL_U: string;\n    ENTER: string;\n    ESCAPE: string;\n};\n",
  "packages/jest-watcher/src/TestWatcher.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport Emittery from 'emittery';\n\ntype State = {\n  interrupted: boolean;\n};\n\nexport default class TestWatcher extends Emittery<{change: State}> {\n  state: State;\n  private readonly _isWatchMode: boolean;\n\n  constructor({isWatchMode}: {isWatchMode: boolean}) {\n    super();\n    this.state = {interrupted: false};\n    this._isWatchMode = isWatchMode;\n  }\n\n  async setState(state: State): Promise<void> {\n    Object.assign(this.state, state);\n    await this.emit('change', this.state);\n  }\n\n  isInterrupted(): boolean {\n    return this.state.interrupted;\n  }\n\n  isWatchMode(): boolean {\n    return this._isWatchMode;\n  }\n}\n",
  "packages/jest-watcher/src/TestWatcher.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport Emittery from 'emittery';\ntype State = {\n    interrupted: boolean;\n};\nexport default class TestWatcher extends Emittery<{\n    change: State;\n}> {\n    state: State;\n    private readonly _isWatchMode;\n    constructor({ isWatchMode }: {\n        isWatchMode: boolean;\n    });\n    setState(state: State): Promise<void>;\n    isInterrupted(): boolean;\n    isWatchMode(): boolean;\n}\nexport {};\n",
  "packages/jest-watcher/src/PatternPrompt.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport ansiEscapes from 'ansi-escapes';\nimport chalk from 'chalk';\nimport {specialChars} from 'jest-util';\nimport type Prompt from './lib/Prompt';\nimport type {ScrollOptions} from './types';\n\nconst {CLEAR} = specialChars;\n\nconst usage = (entity: string) =>\n  `\\n${chalk.bold('Pattern Mode Usage')}\\n` +\n  ` ${chalk.dim('\\u203A Press')} Esc ${chalk.dim('to exit pattern mode.')}\\n` +\n  ` ${chalk.dim('\\u203A Press')} Enter ` +\n  `${chalk.dim(`to filter by a ${entity} regex pattern.`)}\\n` +\n  '\\n';\n\nconst usageRows = usage('').split('\\n').length;\n\nexport default abstract class PatternPrompt {\n  protected _currentUsageRows: number;\n\n  constructor(\n    protected _pipe: NodeJS.WritableStream,\n    protected _prompt: Prompt,\n    protected _entityName = '',\n  ) {\n    this._currentUsageRows = usageRows;\n  }\n\n  run(\n    onSuccess: (value: string) => void,\n    onCancel: () => void,\n    options?: {header: string},\n  ): void {\n    this._pipe.write(ansiEscapes.cursorHide);\n    this._pipe.write(CLEAR);\n\n    if (typeof options?.header === 'string' && options.header) {\n      this._pipe.write(`${options.header}\\n`);\n      this._currentUsageRows = usageRows + options.header.split('\\n').length;\n    } else {\n      this._currentUsageRows = usageRows;\n    }\n\n    this._pipe.write(usage(this._entityName));\n    this._pipe.write(ansiEscapes.cursorShow);\n\n    this._prompt.enter(this._onChange.bind(this), onSuccess, onCancel);\n  }\n\n  protected _onChange(_pattern: string, _options: ScrollOptions): void {\n    this._pipe.write(ansiEscapes.eraseLine);\n    this._pipe.write(ansiEscapes.cursorLeft);\n  }\n}\n",
  "packages/jest-watcher/src/PatternPrompt.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type Prompt from './lib/Prompt';\nimport type { ScrollOptions } from './types';\nexport default abstract class PatternPrompt {\n    protected _pipe: NodeJS.WritableStream;\n    protected _prompt: Prompt;\n    protected _entityName: string;\n    protected _currentUsageRows: number;\n    constructor(_pipe: NodeJS.WritableStream, _prompt: Prompt, _entityName?: string);\n    run(onSuccess: (value: string) => void, onCancel: () => void, options?: {\n        header: string;\n    }): void;\n    protected _onChange(_pattern: string, _options: ScrollOptions): void;\n}\n",
  "packages/jest-watcher/src/JestHooks.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {\n  FileChange,\n  JestHookEmitter,\n  JestHookSubscriber,\n  ShouldRunTestSuite,\n  TestRunComplete,\n} from './types';\n\ntype AvailableHooks =\n  | 'onFileChange'\n  | 'onTestRunComplete'\n  | 'shouldRunTestSuite';\n\nclass JestHooks {\n  private readonly _listeners: {\n    onFileChange: Array<FileChange>;\n    onTestRunComplete: Array<TestRunComplete>;\n    shouldRunTestSuite: Array<ShouldRunTestSuite>;\n  };\n\n  private readonly _subscriber: JestHookSubscriber;\n  private readonly _emitter: JestHookEmitter;\n\n  constructor() {\n    this._listeners = {\n      onFileChange: [],\n      onTestRunComplete: [],\n      shouldRunTestSuite: [],\n    };\n\n    this._subscriber = {\n      onFileChange: fn => {\n        this._listeners.onFileChange.push(fn);\n      },\n      onTestRunComplete: fn => {\n        this._listeners.onTestRunComplete.push(fn);\n      },\n      shouldRunTestSuite: fn => {\n        this._listeners.shouldRunTestSuite.push(fn);\n      },\n    };\n\n    this._emitter = {\n      onFileChange: fs => {\n        for (const listener of this._listeners.onFileChange) listener(fs);\n      },\n      onTestRunComplete: results => {\n        for (const listener of this._listeners.onTestRunComplete)\n          listener(results);\n      },\n      shouldRunTestSuite: async testSuiteInfo => {\n        const result = await Promise.all(\n          this._listeners.shouldRunTestSuite.map(listener =>\n            listener(testSuiteInfo),\n          ),\n        );\n\n        return result.every(Boolean);\n      },\n    };\n  }\n\n  isUsed(hook: AvailableHooks): boolean {\n    return this._listeners[hook]?.length > 0;\n  }\n\n  getSubscriber(): Readonly<JestHookSubscriber> {\n    return this._subscriber;\n  }\n\n  getEmitter(): Readonly<JestHookEmitter> {\n    return this._emitter;\n  }\n}\n\nexport default JestHooks;\n",
  "packages/jest-watcher/src/JestHooks.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { JestHookEmitter, JestHookSubscriber } from './types';\ntype AvailableHooks = 'onFileChange' | 'onTestRunComplete' | 'shouldRunTestSuite';\ndeclare class JestHooks {\n    private readonly _listeners;\n    private readonly _subscriber;\n    private readonly _emitter;\n    constructor();\n    isUsed(hook: AvailableHooks): boolean;\n    getSubscriber(): Readonly<JestHookSubscriber>;\n    getEmitter(): Readonly<JestHookEmitter>;\n}\nexport default JestHooks;\n",
  "packages/jest-watcher/src/BaseWatchPlugin.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {ReadStream, WriteStream} from 'tty';\nimport type {Config} from '@jest/types';\nimport type {\n  JestHookSubscriber,\n  UpdateConfigCallback,\n  UsageData,\n  WatchPlugin,\n} from './types';\n\nabstract class BaseWatchPlugin implements WatchPlugin {\n  protected _stdin: ReadStream;\n  protected _stdout: WriteStream;\n\n  constructor({stdin, stdout}: {stdin: ReadStream; stdout: WriteStream}) {\n    this._stdin = stdin;\n    this._stdout = stdout;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  apply(_hooks: JestHookSubscriber): void {}\n\n  getUsageInfo(_globalConfig: Config.GlobalConfig): UsageData | null {\n    return null;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  onKey(_key: string): void {}\n\n  run(\n    _globalConfig: Config.GlobalConfig,\n    _updateConfigAndRun: UpdateConfigCallback,\n  ): Promise<void | boolean> {\n    return Promise.resolve();\n  }\n}\n\nexport default BaseWatchPlugin;\n",
  "packages/jest-watcher/src/BaseWatchPlugin.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { ReadStream, WriteStream } from 'tty';\nimport type { Config } from '@jest/types';\nimport type { JestHookSubscriber, UpdateConfigCallback, UsageData, WatchPlugin } from './types';\ndeclare abstract class BaseWatchPlugin implements WatchPlugin {\n    protected _stdin: ReadStream;\n    protected _stdout: WriteStream;\n    constructor({ stdin, stdout }: {\n        stdin: ReadStream;\n        stdout: WriteStream;\n    });\n    apply(_hooks: JestHookSubscriber): void;\n    getUsageInfo(_globalConfig: Config.GlobalConfig): UsageData | null;\n    onKey(_key: string): void;\n    run(_globalConfig: Config.GlobalConfig, _updateConfigAndRun: UpdateConfigCallback): Promise<void | boolean>;\n}\nexport default BaseWatchPlugin;\n",
  "packages/jest-watcher/src/lib/scroll.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {ScrollOptions} from '../types';\n\nexport default function scroll(\n  size: number,\n  {offset, max}: ScrollOptions,\n): {end: number; index: number; start: number} {\n  let start = 0;\n  let index = Math.min(offset, size);\n\n  const halfScreen = max / 2;\n\n  if (index <= halfScreen) {\n    start = 0;\n  } else {\n    if (size >= max) {\n      start = Math.min(index - halfScreen - 1, size - max);\n    }\n    index = Math.min(index - start, size);\n  }\n\n  return {\n    end: Math.min(size, start + max),\n    index,\n    start,\n  };\n}\n",
  "packages/jest-watcher/src/lib/scroll.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { ScrollOptions } from '../types';\nexport default function scroll(size: number, { offset, max }: ScrollOptions): {\n    end: number;\n    index: number;\n    start: number;\n};\n",
  "packages/jest-watcher/src/lib/patternModeHelpers.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport ansiEscapes from 'ansi-escapes';\nimport chalk from 'chalk';\nimport stringLength from 'string-length';\n\nexport function printPatternCaret(\n  pattern: string,\n  pipe: NodeJS.WritableStream,\n): void {\n  const inputText = `${chalk.dim(' pattern \\u203A')} ${pattern}`;\n\n  pipe.write(ansiEscapes.eraseDown);\n  pipe.write(inputText);\n  pipe.write(ansiEscapes.cursorSavePosition);\n}\n\nexport function printRestoredPatternCaret(\n  pattern: string,\n  currentUsageRows: number,\n  pipe: NodeJS.WritableStream,\n): void {\n  const inputText = `${chalk.dim(' pattern \\u203A')} ${pattern}`;\n\n  pipe.write(\n    ansiEscapes.cursorTo(stringLength(inputText), currentUsageRows - 1),\n  );\n  pipe.write(ansiEscapes.cursorRestorePosition);\n}\n",
  "packages/jest-watcher/src/lib/patternModeHelpers.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport declare function printPatternCaret(pattern: string, pipe: NodeJS.WritableStream): void;\nexport declare function printRestoredPatternCaret(pattern: string, currentUsageRows: number, pipe: NodeJS.WritableStream): void;\n",
  "packages/jest-watcher/src/lib/formatTestNameByPattern.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk from 'chalk';\nimport colorize from './colorize';\n\nconst DOTS = '...';\nconst ENTER = '⏎';\n\nexport default function formatTestNameByPattern(\n  testName: string,\n  pattern: string,\n  width: number,\n): string {\n  const inlineTestName = testName.replaceAll(/(\\r\\n|\\n|\\r)/gm, ENTER);\n\n  let regexp;\n\n  try {\n    regexp = new RegExp(pattern, 'i');\n  } catch {\n    return chalk.dim(inlineTestName);\n  }\n\n  const match = inlineTestName.match(regexp);\n\n  if (!match) {\n    return chalk.dim(inlineTestName);\n  }\n\n  const startPatternIndex = Math.max(match.index ?? 0, 0);\n  const endPatternIndex = startPatternIndex + match[0].length;\n\n  if (inlineTestName.length <= width) {\n    return colorize(inlineTestName, startPatternIndex, endPatternIndex);\n  }\n\n  const slicedTestName = inlineTestName.slice(0, width - DOTS.length);\n\n  if (startPatternIndex < slicedTestName.length) {\n    if (endPatternIndex > slicedTestName.length) {\n      return colorize(\n        slicedTestName + DOTS,\n        startPatternIndex,\n        slicedTestName.length + DOTS.length,\n      );\n    } else {\n      return colorize(\n        slicedTestName + DOTS,\n        Math.min(startPatternIndex, slicedTestName.length),\n        endPatternIndex,\n      );\n    }\n  }\n\n  return `${chalk.dim(slicedTestName)}${chalk.reset(DOTS)}`;\n}\n",
  "packages/jest-watcher/src/lib/formatTestNameByPattern.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport default function formatTestNameByPattern(testName: string, pattern: string, width: number): string;\n",
  "packages/jest-watcher/src/lib/colorize.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk from 'chalk';\n\nexport default function colorize(\n  str: string,\n  start: number,\n  end: number,\n): string {\n  return (\n    chalk.dim(str.slice(0, start)) +\n    chalk.reset(str.slice(start, end)) +\n    chalk.dim(str.slice(end))\n  );\n}\n",
  "packages/jest-watcher/src/lib/colorize.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport default function colorize(str: string, start: number, end: number): string;\n",
  "packages/jest-watcher/src/lib/Prompt.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {KEYS} from '../constants';\nimport type {ScrollOptions} from '../types';\n\nexport default class Prompt {\n  private _entering: boolean;\n  private _value: string;\n  private _onChange: () => void;\n  private _onSuccess: (value: string) => void;\n  private _onCancel: (value: string) => void;\n  private _offset: number;\n  private _promptLength: number;\n  private _selection: string | null;\n\n  constructor() {\n    // Copied from `enter` to satisfy TS\n    this._entering = true;\n    this._value = '';\n    this._selection = null;\n    this._offset = -1;\n    this._promptLength = 0;\n\n    /* eslint-disable @typescript-eslint/no-empty-function */\n    this._onChange = () => {};\n    this._onSuccess = () => {};\n    this._onCancel = () => {};\n    /* eslint-enable */\n  }\n\n  private readonly _onResize = (): void => {\n    this._onChange();\n  };\n\n  enter(\n    onChange: (pattern: string, options: ScrollOptions) => void,\n    onSuccess: (pattern: string) => void,\n    onCancel: () => void,\n  ): void {\n    this._entering = true;\n    this._value = '';\n    this._onSuccess = onSuccess;\n    this._onCancel = onCancel;\n    this._selection = null;\n    this._offset = -1;\n    this._promptLength = 0;\n    this._onChange = () =>\n      onChange(this._value, {\n        max: 10,\n        offset: this._offset,\n      });\n\n    this._onChange();\n\n    process.stdout.on('resize', this._onResize);\n  }\n\n  setPromptLength(length: number): void {\n    this._promptLength = length;\n  }\n\n  setPromptSelection(selected: string): void {\n    this._selection = selected;\n  }\n\n  put(key: string): void {\n    switch (key) {\n      case KEYS.ENTER:\n        this._entering = false;\n        this._onSuccess(this._selection ?? this._value);\n        this.abort();\n        break;\n      case KEYS.ESCAPE:\n        this._entering = false;\n        this._onCancel(this._value);\n        this.abort();\n        break;\n      case KEYS.ARROW_DOWN:\n        this._offset = Math.min(this._offset + 1, this._promptLength - 1);\n        this._onChange();\n        break;\n      case KEYS.ARROW_UP:\n        this._offset = Math.max(this._offset - 1, -1);\n        this._onChange();\n        break;\n      case KEYS.ARROW_LEFT:\n      case KEYS.ARROW_RIGHT:\n        break;\n      case KEYS.CONTROL_U:\n        this._value = '';\n        this._offset = -1;\n        this._selection = null;\n        this._onChange();\n        break;\n      default:\n        this._value =\n          key === KEYS.BACKSPACE ? this._value.slice(0, -1) : this._value + key;\n        this._offset = -1;\n        this._selection = null;\n        this._onChange();\n        break;\n    }\n  }\n\n  abort(): void {\n    this._entering = false;\n    this._value = '';\n    process.stdout.removeListener('resize', this._onResize);\n  }\n\n  isEntering(): boolean {\n    return this._entering;\n  }\n}\n",
  "packages/jest-watcher/src/lib/Prompt.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { ScrollOptions } from '../types';\nexport default class Prompt {\n    private _entering;\n    private _value;\n    private _onChange;\n    private _onSuccess;\n    private _onCancel;\n    private _offset;\n    private _promptLength;\n    private _selection;\n    constructor();\n    private readonly _onResize;\n    enter(onChange: (pattern: string, options: ScrollOptions) => void, onSuccess: (pattern: string) => void, onCancel: () => void): void;\n    setPromptLength(length: number): void;\n    setPromptSelection(selected: string): void;\n    put(key: string): void;\n    abort(): void;\n    isEntering(): boolean;\n}\n",
  "packages/jest-watcher/src/lib/__tests__/scroll.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport scroll from '../scroll';\n\nit('When offset is -1', () => {\n  expect(scroll(25, {max: 10, offset: -1})).toEqual({\n    end: 10,\n    index: -1,\n    start: 0,\n  });\n});\n\nit('When offset is in the first set of items', () => {\n  expect(scroll(25, {max: 10, offset: 4})).toEqual({\n    end: 10,\n    index: 4,\n    start: 0,\n  });\n\n  expect(scroll(25, {max: 10, offset: 6})).toEqual({\n    end: 10,\n    index: 6,\n    start: 0,\n  });\n});\n\nit('When offset is in the middle of the list', () => {\n  expect(scroll(25, {max: 10, offset: 7})).toEqual({\n    end: 11,\n    index: 6,\n    start: 1,\n  });\n\n  expect(scroll(25, {max: 10, offset: 14})).toEqual({\n    end: 18,\n    index: 6,\n    start: 8,\n  });\n});\n\nit('When offset is at the end of the list', () => {\n  expect(scroll(25, {max: 10, offset: 23})).toEqual({\n    end: 25,\n    index: 8,\n    start: 15,\n  });\n\n  expect(scroll(25, {max: 10, offset: 25})).toEqual({\n    end: 25,\n    index: 10,\n    start: 15,\n  });\n\n  expect(scroll(25, {max: 10, offset: 35})).toEqual({\n    end: 25,\n    index: 10,\n    start: 15,\n  });\n});\n\nit('When offset is at the end and size is smaller than max', () => {\n  expect(scroll(8, {max: 10, offset: 6})).toEqual({\n    end: 8,\n    index: 6,\n    start: 0,\n  });\n\n  expect(scroll(5, {max: 6, offset: 4})).toEqual({\n    end: 5,\n    index: 4,\n    start: 0,\n  });\n});\n",
  "packages/jest-watcher/src/lib/__tests__/scroll.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-watcher/src/lib/__tests__/prompt.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {KEYS} from '../../constants';\nimport Prompt from '../Prompt';\n\nit('calls handler on change value', () => {\n  const options = {max: 10, offset: -1};\n  const prompt = new Prompt();\n  const onChange = jest.fn();\n\n  prompt.enter(onChange, jest.fn(), jest.fn());\n\n  expect(onChange).toHaveBeenLastCalledWith('', options);\n\n  prompt.put('t');\n  expect(onChange).toHaveBeenLastCalledWith('t', options);\n\n  prompt.put('e');\n  expect(onChange).toHaveBeenLastCalledWith('te', options);\n\n  prompt.put('s');\n  expect(onChange).toHaveBeenLastCalledWith('tes', options);\n\n  prompt.put('t');\n  expect(onChange).toHaveBeenLastCalledWith('test', options);\n\n  expect(onChange).toHaveBeenCalledTimes(5);\n});\n\nit('calls handler on success prompt', () => {\n  const prompt = new Prompt();\n  const onSuccess = jest.fn();\n\n  prompt.enter(jest.fn(), onSuccess, jest.fn());\n\n  prompt.put('t');\n  prompt.put('e');\n  prompt.put('s');\n  prompt.put('t');\n  prompt.put(KEYS.ENTER);\n\n  expect(onSuccess).toHaveBeenCalledWith('test');\n});\n\nit('calls handler on cancel prompt', () => {\n  const prompt = new Prompt();\n  const onCancel = jest.fn();\n\n  prompt.enter(jest.fn(), jest.fn(), onCancel);\n\n  prompt.put('t');\n  prompt.put('e');\n  prompt.put('s');\n  prompt.put('t');\n  prompt.put(KEYS.ESCAPE);\n\n  expect(onCancel).toHaveBeenCalled();\n});\n\nit('clears the line when CONTROL_U is pressed', () => {\n  const prompt = new Prompt();\n  const onChange = jest.fn();\n  const options = {max: 10, offset: -1};\n\n  prompt.enter(onChange, jest.fn(), jest.fn());\n\n  prompt.put('t');\n  prompt.put('e');\n  prompt.put('s');\n  prompt.put('t');\n  expect(onChange).toHaveBeenLastCalledWith('test', options);\n\n  prompt.put(KEYS.CONTROL_U);\n  expect(onChange).toHaveBeenLastCalledWith('', options);\n});\n",
  "packages/jest-watcher/src/lib/__tests__/prompt.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport {};\n",
  "packages/jest-watcher/src/lib/__tests__/formatTestNameByPattern.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport formatTestNameByPattern from '../formatTestNameByPattern';\n\ndescribe('for multiline test name returns', () => {\n  const testNames = [\n    'should\\n name the \\nfunction you attach',\n    'should\\r\\n name the \\r\\nfunction you attach',\n    'should\\r name the \\rfunction you attach',\n  ];\n\n  it('test name with highlighted pattern and replaced line breaks', () => {\n    const pattern = 'name';\n\n    for (const testName of testNames) {\n      expect(formatTestNameByPattern(testName, pattern, 36)).toMatchSnapshot();\n    }\n  });\n});\n\ndescribe('for one line test name', () => {\n  const testName = 'should name the function you attach';\n\n  describe('with pattern in the head returns', () => {\n    const pattern = 'should';\n\n    it('test name with highlighted pattern', () => {\n      expect(formatTestNameByPattern(testName, pattern, 35)).toMatchSnapshot();\n    });\n\n    it('test name with cutted tail and highlighted pattern', () => {\n      expect(formatTestNameByPattern(testName, pattern, 30)).toMatchSnapshot();\n    });\n\n    it('test name with cutted tail and cutted highlighted pattern', () => {\n      expect(formatTestNameByPattern(testName, pattern, 8)).toMatchSnapshot();\n    });\n  });\n\n  describe('pattern in the middle', () => {\n    const pattern = 'name';\n\n    it('test name with highlighted pattern returns', () => {\n      expect(formatTestNameByPattern(testName, pattern, 35)).toMatchSnapshot();\n    });\n\n    it('test name with cutted tail and highlighted pattern', () => {\n      expect(formatTestNameByPattern(testName, pattern, 25)).toMatchSnapshot();\n    });\n\n    it('test name with cutted tail and cutted highlighted pattern', () => {\n      expect(formatTestNameByPattern(testName, pattern, 13)).toMatchSnapshot();\n    });\n\n    it('test name with highlighted cutted', () => {\n      expect(formatTestNameByPattern(testName, pattern, 6)).toMatchSnapshot();\n    });\n  });\n\n  describe('pattern in the tail returns', () => {\n    const pattern = 'attach';\n\n    it('test name with highlighted pattern', () => {\n      expect(formatTestNameByPattern(testName, pattern, 35)).toMatchSnapshot();\n    });\n\n    it('test name with cutted tail and cutted highlighted pattern', () => {\n      expect(formatTestNameByPattern(testName, pattern, 33)).toMatchSnapshot();\n    });\n\n    it('test name with highlighted cutted', () => {\n      expect(formatTestNameByPattern(testName, pattern, 6)).toMatchSnapshot();\n    });\n  });\n});\n",
  "packages/jest-watcher/src/lib/__tests__/formatTestNameByPattern.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-validate/src/warnings.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk from 'chalk';\nimport type {ValidationOptions} from './types';\nimport {\n  WARNING,\n  createDidYouMeanMessage,\n  format,\n  logValidationWarning,\n} from './utils';\n\nexport const unknownOptionWarning = (\n  config: Record<string, unknown>,\n  exampleConfig: Record<string, unknown>,\n  option: string,\n  options: ValidationOptions,\n  path?: Array<string>,\n): void => {\n  const didYouMean = createDidYouMeanMessage(\n    option,\n    Object.keys(exampleConfig),\n  );\n  const message = `  Unknown option ${chalk.bold(\n    `\"${path && path.length > 0 ? `${path.join('.')}.` : ''}${option}\"`,\n  )} with value ${chalk.bold(format(config[option]))} was found.${\n    didYouMean && ` ${didYouMean}`\n  }\\n  This is probably a typing mistake. Fixing it will remove this message.`;\n\n  const comment = options.comment;\n  const name = (options.title && options.title.warning) || WARNING;\n\n  logValidationWarning(name, message, comment);\n};\n",
  "packages/jest-validate/src/warnings.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { ValidationOptions } from './types';\nexport declare const unknownOptionWarning: (config: Record<string, unknown>, exampleConfig: Record<string, unknown>, option: string, options: ValidationOptions, path?: Array<string>) => void;\n",
  "packages/jest-validate/src/validateCLIOptions.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport camelcase from 'camelcase';\nimport chalk from 'chalk';\nimport type {Options} from 'yargs';\nimport type {Config} from '@jest/types';\nimport type {\n  DeprecatedOptionFunc,\n  DeprecatedOptions,\n  DeprecationItem,\n} from './types';\nimport {\n  ValidationError,\n  createDidYouMeanMessage,\n  format,\n  logValidationWarning,\n} from './utils';\n\nconst BULLET: string = chalk.bold('\\u25CF');\nexport const DOCUMENTATION_NOTE = `  ${chalk.bold('CLI Options Documentation:')}\n  https://jestjs.io/docs/cli\n`;\n\nconst createCLIValidationError = (\n  unrecognizedOptions: Array<string>,\n  allowedOptions: Set<string>,\n) => {\n  let title = `${BULLET} Unrecognized CLI Parameter`;\n  let message;\n  const comment =\n    `  ${chalk.bold('CLI Options Documentation')}:\\n` +\n    '  https://jestjs.io/docs/cli\\n';\n\n  if (unrecognizedOptions.length === 1) {\n    const unrecognized = unrecognizedOptions[0];\n    const didYouMeanMessage =\n      unrecognized.length > 1\n        ? createDidYouMeanMessage(unrecognized, [...allowedOptions])\n        : '';\n    message = `  Unrecognized option ${chalk.bold(format(unrecognized))}.${\n      didYouMeanMessage ? ` ${didYouMeanMessage}` : ''\n    }`;\n  } else {\n    title += 's';\n    message =\n      '  Following options were not recognized:\\n' +\n      `  ${chalk.bold(format(unrecognizedOptions))}`;\n  }\n\n  return new ValidationError(title, message, comment);\n};\n\nconst validateDeprecatedOptions = (\n  deprecatedOptions: Array<DeprecationItem>,\n  deprecationEntries: DeprecatedOptions,\n  argv: Config.Argv,\n) => {\n  for (const opt of deprecatedOptions) {\n    const name = opt.name;\n    const message = deprecationEntries[name](argv);\n    const comment = DOCUMENTATION_NOTE;\n\n    if (opt.fatal) {\n      throw new ValidationError(name, message, comment);\n    } else {\n      logValidationWarning(name, message, comment);\n    }\n  }\n};\n\nexport default function validateCLIOptions(\n  argv: Config.Argv,\n  options: Record<string, Options> & {\n    deprecationEntries?: DeprecatedOptions;\n  } = {},\n  rawArgv: Array<string> = [],\n): boolean {\n  const yargsSpecialOptions = ['$0', '_', 'help', 'h'];\n\n  const allowedOptions = Object.keys(options).reduce(\n    (acc, option) =>\n      acc.add(option).add((options[option].alias as string) || option),\n    new Set(yargsSpecialOptions),\n  );\n\n  const deprecationEntries = options.deprecationEntries ?? {};\n  const CLIDeprecations = Object.keys(deprecationEntries).reduce<\n    Record<string, DeprecatedOptionFunc>\n  >((acc, entry) => {\n    acc[entry] = deprecationEntries[entry];\n    if (options[entry]) {\n      const alias = options[entry].alias as string;\n      if (alias) {\n        acc[alias] = deprecationEntries[entry];\n      }\n    }\n    return acc;\n  }, {});\n  const deprecations = new Set(Object.keys(CLIDeprecations));\n  const deprecatedOptions = Object.keys(argv)\n    .filter(arg => deprecations.has(arg) && argv[arg] != null)\n    .map(arg => ({fatal: !allowedOptions.has(arg), name: arg}));\n\n  if (deprecatedOptions.length > 0) {\n    validateDeprecatedOptions(deprecatedOptions, CLIDeprecations, argv);\n  }\n\n  const unrecognizedOptions = Object.keys(argv).filter(\n    arg =>\n      !allowedOptions.has(camelcase(arg, {locale: 'en-US'})) &&\n      !allowedOptions.has(arg) &&\n      (rawArgv.length === 0 || rawArgv.includes(arg)),\n  );\n\n  if (unrecognizedOptions.length > 0) {\n    throw createCLIValidationError(unrecognizedOptions, allowedOptions);\n  }\n\n  return true;\n}\n",
  "packages/jest-validate/src/validateCLIOptions.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Options } from 'yargs';\nimport type { Config } from '@jest/types';\nimport type { DeprecatedOptions } from './types';\nexport declare const DOCUMENTATION_NOTE: string;\nexport default function validateCLIOptions(argv: Config.Argv, options?: Record<string, Options> & {\n    deprecationEntries?: DeprecatedOptions;\n}, rawArgv?: Array<string>): boolean;\n",
  "packages/jest-validate/src/validate.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport defaultConfig from './defaultConfig';\nimport type {ValidationOptions} from './types';\nimport {ValidationError} from './utils';\n\nlet hasDeprecationWarnings = false;\n\nconst shouldSkipValidationForPath = (\n  path: Array<string>,\n  key: string,\n  denylist?: Array<string>,\n) => (denylist ? denylist.includes([...path, key].join('.')) : false);\n\nconst _validate = (\n  config: Record<string, any>,\n  exampleConfig: Record<string, any>,\n  options: ValidationOptions,\n  path: Array<string> = [],\n): {hasDeprecationWarnings: boolean} => {\n  if (\n    typeof config !== 'object' ||\n    config == null ||\n    typeof exampleConfig !== 'object' ||\n    exampleConfig == null\n  ) {\n    return {hasDeprecationWarnings};\n  }\n\n  for (const key in config) {\n    if (\n      options.deprecatedConfig &&\n      key in options.deprecatedConfig &&\n      typeof options.deprecate === 'function'\n    ) {\n      const isDeprecatedKey = options.deprecate(\n        config,\n        key,\n        options.deprecatedConfig,\n        options,\n      );\n\n      hasDeprecationWarnings = hasDeprecationWarnings || isDeprecatedKey;\n    } else if (allowsMultipleTypes(key)) {\n      const value = config[key];\n\n      if (\n        typeof options.condition === 'function' &&\n        typeof options.error === 'function'\n      ) {\n        if (key === 'maxWorkers' && !isOfTypeStringOrNumber(value)) {\n          throw new ValidationError(\n            'Validation Error',\n            `${key} has to be of type string or number`,\n            'maxWorkers=50% or\\nmaxWorkers=3',\n          );\n        }\n      }\n    } else if (Object.hasOwnProperty.call(exampleConfig, key)) {\n      if (\n        typeof options.condition === 'function' &&\n        typeof options.error === 'function' &&\n        !options.condition(config[key], exampleConfig[key])\n      ) {\n        options.error(key, config[key], exampleConfig[key], options, path);\n      }\n    } else if (\n      shouldSkipValidationForPath(path, key, options.recursiveDenylist)\n    ) {\n      // skip validating unknown options inside blacklisted paths\n    } else {\n      options.unknown?.(config, exampleConfig, key, options, path);\n    }\n\n    if (\n      options.recursive &&\n      !Array.isArray(exampleConfig[key]) &&\n      options.recursiveDenylist &&\n      !shouldSkipValidationForPath(path, key, options.recursiveDenylist)\n    ) {\n      _validate(config[key], exampleConfig[key], options, [...path, key]);\n    }\n  }\n\n  return {hasDeprecationWarnings};\n};\n\nconst allowsMultipleTypes = (key: string): boolean => key === 'maxWorkers';\nconst isOfTypeStringOrNumber = (value: unknown): boolean =>\n  typeof value === 'number' || typeof value === 'string';\n\nconst validate = (\n  config: Record<string, unknown>,\n  options: ValidationOptions,\n): {hasDeprecationWarnings: boolean; isValid: boolean} => {\n  hasDeprecationWarnings = false;\n\n  // Preserve default denylist entries even with user-supplied denylist\n  const combinedDenylist: Array<string> = [\n    ...(defaultConfig.recursiveDenylist || []),\n    ...(options.recursiveDenylist || []),\n  ];\n\n  const defaultedOptions: ValidationOptions = Object.assign({\n    ...defaultConfig,\n    ...options,\n    recursiveDenylist: combinedDenylist,\n    title: options.title || defaultConfig.title,\n  });\n\n  const {hasDeprecationWarnings: hdw} = _validate(\n    config,\n    options.exampleConfig,\n    defaultedOptions,\n  );\n\n  return {\n    hasDeprecationWarnings: hdw,\n    isValid: true,\n  };\n};\n\nexport default validate;\n",
  "packages/jest-validate/src/validate.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { ValidationOptions } from './types';\ndeclare const validate: (config: Record<string, unknown>, options: ValidationOptions) => {\n    hasDeprecationWarnings: boolean;\n    isValid: boolean;\n};\nexport default validate;\n",
  "packages/jest-validate/src/utils.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk from 'chalk';\nimport leven from 'leven';\nimport {format as prettyFormat} from 'pretty-format';\n\nconst BULLET: string = chalk.bold('\\u25CF');\nexport const DEPRECATION = `${BULLET} Deprecation Warning`;\nexport const ERROR = `${BULLET} Validation Error`;\nexport const WARNING = `${BULLET} Validation Warning`;\n\nexport const format = (value: unknown): string =>\n  typeof value === 'function'\n    ? value.toString()\n    : prettyFormat(value, {min: true});\n\nexport const formatPrettyObject = (value: unknown): string =>\n  typeof value === 'function'\n    ? value.toString()\n    : value === undefined\n      ? 'undefined'\n      : JSON.stringify(value, null, 2).split('\\n').join('\\n    ');\n\nexport class ValidationError extends Error {\n  override name: string;\n  override message: string;\n\n  constructor(name: string, message: string, comment?: string | null) {\n    super();\n    comment = comment ? `\\n\\n${comment}` : '\\n';\n    this.name = '';\n    this.message = chalk.red(`${chalk.bold(name)}:\\n\\n${message}${comment}`);\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    Error.captureStackTrace(this, () => {});\n  }\n}\n\nexport const logValidationWarning = (\n  name: string,\n  message: string,\n  comment?: string | null,\n): void => {\n  comment = comment ? `\\n\\n${comment}` : '\\n';\n  console.warn(chalk.yellow(`${chalk.bold(name)}:\\n\\n${message}${comment}`));\n};\n\nexport const createDidYouMeanMessage = (\n  unrecognized: string,\n  allowedOptions: Array<string>,\n): string => {\n  const suggestion = allowedOptions.find(option => {\n    const steps: number = leven(option, unrecognized);\n    return steps < 3;\n  });\n\n  return suggestion ? `Did you mean ${chalk.bold(format(suggestion))}?` : '';\n};\n",
  "packages/jest-validate/src/utils.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport declare const DEPRECATION: string;\nexport declare const ERROR: string;\nexport declare const WARNING: string;\nexport declare const format: (value: unknown) => string;\nexport declare const formatPrettyObject: (value: unknown) => string;\nexport declare class ValidationError extends Error {\n    name: string;\n    message: string;\n    constructor(name: string, message: string, comment?: string | null);\n}\nexport declare const logValidationWarning: (name: string, message: string, comment?: string | null) => void;\nexport declare const createDidYouMeanMessage: (unrecognized: string, allowedOptions: Array<string>) => string;\n",
  "packages/jest-validate/src/types.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ntype Title = {\n  deprecation?: string;\n  error?: string;\n  warning?: string;\n};\n\nexport type DeprecatedOptionFunc = (arg: Record<string, unknown>) => string;\n\nexport type DeprecatedOptions = Record<string, DeprecatedOptionFunc>;\n\nexport type DeprecationItem = {fatal: boolean; name: string};\n\nexport type ValidationOptions = {\n  comment?: string;\n  condition?: (option: unknown, validOption: unknown) => boolean;\n  deprecate?: (\n    config: Record<string, unknown>,\n    option: string,\n    deprecatedOptions: DeprecatedOptions,\n    options: ValidationOptions,\n  ) => boolean;\n  deprecatedConfig?: DeprecatedOptions;\n  error?: (\n    option: string,\n    received: unknown,\n    defaultValue: unknown,\n    options: ValidationOptions,\n    path?: Array<string>,\n  ) => void;\n  exampleConfig: Record<string, unknown>;\n  recursive?: boolean;\n  recursiveDenylist?: Array<string>;\n  title?: Title;\n  unknown?: (\n    config: Record<string, unknown>,\n    exampleConfig: Record<string, unknown>,\n    option: string,\n    options: ValidationOptions,\n    path?: Array<string>,\n  ) => void;\n};\n",
  "packages/jest-validate/src/types.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\ntype Title = {\n    deprecation?: string;\n    error?: string;\n    warning?: string;\n};\nexport type DeprecatedOptionFunc = (arg: Record<string, unknown>) => string;\nexport type DeprecatedOptions = Record<string, DeprecatedOptionFunc>;\nexport type DeprecationItem = {\n    fatal: boolean;\n    name: string;\n};\nexport type ValidationOptions = {\n    comment?: string;\n    condition?: (option: unknown, validOption: unknown) => boolean;\n    deprecate?: (config: Record<string, unknown>, option: string, deprecatedOptions: DeprecatedOptions, options: ValidationOptions) => boolean;\n    deprecatedConfig?: DeprecatedOptions;\n    error?: (option: string, received: unknown, defaultValue: unknown, options: ValidationOptions, path?: Array<string>) => void;\n    exampleConfig: Record<string, unknown>;\n    recursive?: boolean;\n    recursiveDenylist?: Array<string>;\n    title?: Title;\n    unknown?: (config: Record<string, unknown>, exampleConfig: Record<string, unknown>, option: string, options: ValidationOptions, path?: Array<string>) => void;\n};\nexport {};\n",
  "packages/jest-validate/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nexport {\n  ValidationError,\n  createDidYouMeanMessage,\n  format,\n  logValidationWarning,\n} from './utils';\nexport type {DeprecatedOptions} from './types';\nexport {default as validate} from './validate';\nexport {default as validateCLIOptions} from './validateCLIOptions';\nexport {multipleValidOptions} from './condition';\n",
  "packages/jest-validate/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport { ValidationError, createDidYouMeanMessage, format, logValidationWarning, } from './utils';\nexport type { DeprecatedOptions } from './types';\nexport { default as validate } from './validate';\nexport { default as validateCLIOptions } from './validateCLIOptions';\nexport { multipleValidOptions } from './condition';\n",
  "packages/jest-validate/src/exampleConfig.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {ValidationOptions} from './types';\n\nconst config: ValidationOptions = {\n  comment: '  A comment',\n  condition: () => true,\n  deprecate: () => false,\n  deprecatedConfig: {\n    key: (): string => 'Deprecation message',\n  },\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  error: () => {},\n  exampleConfig: {key: 'value', test: 'case'},\n  recursive: true,\n  recursiveDenylist: [],\n  title: {\n    deprecation: 'Deprecation Warning',\n    error: 'Validation Error',\n    warning: 'Validation Warning',\n  },\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  unknown: () => {},\n};\n\nexport default config;\n",
  "packages/jest-validate/src/exampleConfig.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { ValidationOptions } from './types';\ndeclare const config: ValidationOptions;\nexport default config;\n",
  "packages/jest-validate/src/errors.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk from 'chalk';\nimport {getType} from '@jest/get-type';\nimport {getValues} from './condition';\nimport type {ValidationOptions} from './types';\nimport {ERROR, ValidationError, formatPrettyObject} from './utils';\n\nexport const errorMessage = (\n  option: string,\n  received: unknown,\n  defaultValue: unknown,\n  options: ValidationOptions,\n  path?: Array<string>,\n): void => {\n  const conditions = getValues(defaultValue);\n  const validTypes: Array<string> = [...new Set(conditions.map(getType))];\n\n  const message = `  Option ${chalk.bold(\n    `\"${path && path.length > 0 ? `${path.join('.')}.` : ''}${option}\"`,\n  )} must be of type:\n    ${validTypes.map(e => chalk.bold.green(e)).join(' or ')}\n  but instead received:\n    ${chalk.bold.red(getType(received))}\n\n  Example:\n${formatExamples(option, conditions)}`;\n\n  const comment = options.comment;\n  const name = (options.title && options.title.error) || ERROR;\n\n  throw new ValidationError(name, message, comment);\n};\n\nfunction formatExamples(option: string, examples: Array<unknown>) {\n  return examples.map(\n    e => `  {\n    ${chalk.bold(`\"${option}\"`)}: ${chalk.bold(formatPrettyObject(e))}\n  }`,\n  ).join(`\n\n  or\n\n`);\n}\n",
  "packages/jest-validate/src/errors.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { ValidationOptions } from './types';\nexport declare const errorMessage: (option: string, received: unknown, defaultValue: unknown, options: ValidationOptions, path?: Array<string>) => void;\n",
  "packages/jest-validate/src/deprecated.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {DeprecatedOptions, ValidationOptions} from './types';\nimport {DEPRECATION, logValidationWarning} from './utils';\n\nconst deprecationMessage = (message: string, options: ValidationOptions) => {\n  const comment = options.comment;\n  const name = (options.title && options.title.deprecation) || DEPRECATION;\n\n  logValidationWarning(name, message, comment);\n};\n\nexport const deprecationWarning = (\n  config: Record<string, unknown>,\n  option: string,\n  deprecatedOptions: DeprecatedOptions,\n  options: ValidationOptions,\n): boolean => {\n  if (option in deprecatedOptions) {\n    deprecationMessage(deprecatedOptions[option](config), options);\n\n    return true;\n  }\n\n  return false;\n};\n",
  "packages/jest-validate/src/deprecated.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { DeprecatedOptions, ValidationOptions } from './types';\nexport declare const deprecationWarning: (config: Record<string, unknown>, option: string, deprecatedOptions: DeprecatedOptions, options: ValidationOptions) => boolean;\n",
  "packages/jest-validate/src/defaultConfig.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {validationCondition} from './condition';\nimport {deprecationWarning} from './deprecated';\nimport {errorMessage} from './errors';\nimport type {ValidationOptions} from './types';\nimport {DEPRECATION, ERROR, WARNING} from './utils';\nimport {unknownOptionWarning} from './warnings';\n\nconst validationOptions: ValidationOptions = {\n  comment: '',\n  condition: validationCondition,\n  deprecate: deprecationWarning,\n  deprecatedConfig: {},\n  error: errorMessage,\n  exampleConfig: {},\n  recursive: true,\n  // Allow NPM-sanctioned comments in package.json. Use a \"//\" key.\n  recursiveDenylist: ['//'],\n  title: {\n    deprecation: DEPRECATION,\n    error: ERROR,\n    warning: WARNING,\n  },\n  unknown: unknownOptionWarning,\n};\n\nexport default validationOptions;\n",
  "packages/jest-validate/src/defaultConfig.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { ValidationOptions } from './types';\ndeclare const validationOptions: ValidationOptions;\nexport default validationOptions;\n",
  "packages/jest-validate/src/condition.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst toString = Object.prototype.toString;\n\nconst MULTIPLE_VALID_OPTIONS_SYMBOL = Symbol('JEST_MULTIPLE_VALID_OPTIONS');\n\nfunction validationConditionSingle(\n  option: unknown,\n  validOption: unknown,\n): boolean {\n  return (\n    option === null ||\n    option === undefined ||\n    (typeof option === 'function' && typeof validOption === 'function') ||\n    toString.call(option) === toString.call(validOption)\n  );\n}\n\nexport function getValues<T = unknown>(validOption: T): Array<T> {\n  if (\n    Array.isArray(validOption) &&\n    // @ts-expect-error: no index signature\n    validOption[MULTIPLE_VALID_OPTIONS_SYMBOL]\n  ) {\n    return validOption;\n  }\n  return [validOption];\n}\n\nexport function validationCondition(\n  option: unknown,\n  validOption: unknown,\n): boolean {\n  return getValues(validOption).some(e => validationConditionSingle(option, e));\n}\n\nexport function multipleValidOptions<T extends Array<unknown>>(\n  ...args: T\n): T[number] {\n  const options = [...args] as T;\n  // @ts-expect-error: no index signature\n  options[MULTIPLE_VALID_OPTIONS_SYMBOL] = true;\n\n  return options;\n}\n",
  "packages/jest-validate/src/condition.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport declare function getValues<T = unknown>(validOption: T): Array<T>;\nexport declare function validationCondition(option: unknown, validOption: unknown): boolean;\nexport declare function multipleValidOptions<T extends Array<unknown>>(...args: T): T[number];\n",
  "packages/jest-validate/src/__tests__/validateCLIOptions.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {DeprecatedOptions} from '../types';\nimport validateCLIOptions from '../validateCLIOptions';\n\ntest('validates yargs special options', () => {\n  const argv = {\n    $0: 'foo',\n    _: ['bar'],\n    h: false,\n    help: false,\n  };\n\n  expect(validateCLIOptions(argv)).toBe(true);\n});\n\ntest('fails for unknown option', () => {\n  const argv = {\n    $0: 'foo',\n    _: ['bar'],\n    unknown: 'unknown',\n  };\n\n  expect(() => validateCLIOptions(argv)).toThrowErrorMatchingSnapshot();\n});\n\ntest('fails for multiple unknown options', () => {\n  const argv = {\n    $0: 'foo',\n    _: ['bar'],\n    jest: 'cool',\n    test: 'unknown',\n  };\n\n  expect(() => validateCLIOptions(argv)).toThrowErrorMatchingSnapshot();\n});\n\ntest('does not show suggestion when unrecognized cli param length <= 1', () => {\n  const argv = {\n    $0: 'foo',\n    _: ['bar'],\n    l: true,\n  };\n\n  expect(() => validateCLIOptions(argv)).toThrowErrorMatchingSnapshot();\n});\n\ntest('shows suggestion when unrecognized cli param length > 1', () => {\n  const argv = {\n    $0: 'foo',\n    _: ['bar'],\n    hell: true,\n  };\n\n  expect(() => validateCLIOptions(argv)).toThrowErrorMatchingSnapshot();\n});\n\ndescribe('handles deprecated CLI options', () => {\n  beforeEach(() => {\n    jest.spyOn(console, 'warn');\n  });\n\n  afterEach(() => {\n    jest.mocked(console.warn).mockRestore();\n  });\n\n  test('print warning for deprecated options that are listed in config', () => {\n    const optionName = 'foo';\n    const argv = {\n      $0: 'foo',\n      _: ['bar'],\n      [optionName]: true,\n    };\n\n    validateCLIOptions(argv, {\n      deprecationEntries: {\n        [optionName]: () => 'Deprecation message',\n      } as DeprecatedOptions,\n      [optionName]: {},\n    });\n\n    expect(jest.mocked(console.warn).mock.calls[0][0]).toMatchSnapshot();\n  });\n\n  test('throw an error for deprecated options that are not listed in config', () => {\n    const optionName = 'foo';\n\n    const argv = {\n      $0: 'foo',\n      _: ['bar'],\n      [optionName]: true,\n    };\n\n    expect(() =>\n      validateCLIOptions(argv, {\n        deprecationEntries: {\n          [optionName]: () => 'Deprecation message',\n        } as DeprecatedOptions,\n      }),\n    ).toThrowErrorMatchingSnapshot();\n  });\n});\n",
  "packages/jest-validate/src/__tests__/validateCLIOptions.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport {};\n",
  "packages/jest-validate/src/__tests__/validate.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {multipleValidOptions} from '../condition';\nimport jestValidateDefaultConfig from '../defaultConfig';\nimport jestValidateExampleConfig from '../exampleConfig';\nimport validate from '../validate';\nimport {\n  defaultConfig,\n  deprecatedConfig,\n  validConfig,\n} from './__fixtures__/jestConfig';\n\nconst spyConsoleWarn = jest.spyOn(console, 'warn');\n\nbeforeEach(() => {\n  spyConsoleWarn.mockImplementation(() => {});\n});\n\nafterEach(() => {\n  spyConsoleWarn.mockReset();\n});\n\ntest('recursively validates default Jest config', () => {\n  expect(\n    validate(defaultConfig, {\n      exampleConfig: validConfig,\n    }),\n  ).toEqual({\n    hasDeprecationWarnings: false,\n    isValid: true,\n  });\n});\n\ntest('recursively validates default jest-validate config', () => {\n  expect(\n    validate(jestValidateDefaultConfig, {\n      exampleConfig: jestValidateExampleConfig,\n    }),\n  ).toEqual({\n    hasDeprecationWarnings: false,\n    isValid: true,\n  });\n});\n\ntest.each([\n  ['Boolean', {automock: []}],\n  ['Array', {coverageReporters: {}}],\n  ['String', {preset: 1337}],\n  ['Object', {haste: 42}],\n])('pretty prints valid config for %s', (_type, config) => {\n  expect(() =>\n    validate(config, {\n      exampleConfig: validConfig,\n    }),\n  ).toThrowErrorMatchingSnapshot();\n});\n\ntest('pretty prints valid config for Function', () => {\n  const config = {fn: 'test'};\n  const validConfig = {\n    fn: (_config: unknown, _option: unknown, _deprecatedOptions: unknown) =>\n      true,\n  };\n  expect(() =>\n    validate(config, {\n      exampleConfig: validConfig,\n    }),\n  ).toThrowErrorMatchingSnapshot();\n});\n\ntest('omits null and undefined config values', () => {\n  const config = {\n    haste: undefined,\n    preset: null,\n  };\n  expect(validate(config, {exampleConfig: validConfig})).toEqual({\n    hasDeprecationWarnings: false,\n    isValid: true,\n  });\n});\n\ntest('recursively omits null and undefined config values', () => {\n  const config = {\n    coverageThreshold: {\n      global: null,\n    },\n  };\n  expect(\n    validate(config, {exampleConfig: validConfig, recursive: true}),\n  ).toEqual({\n    hasDeprecationWarnings: false,\n    isValid: true,\n  });\n});\n\ntest.each([\n  [function () {}, function () {}],\n  [async function () {}, function () {}],\n  [function () {}, async function () {}],\n  [async function () {}, async function () {}],\n])(\n  'treat async and non-async functions as equivalent',\n  (value, exampleValue) => {\n    expect(\n      validate({name: value}, {exampleConfig: {name: exampleValue}}),\n    ).toEqual({hasDeprecationWarnings: false, isValid: true});\n  },\n);\n\ntest('respects recursiveDenylist', () => {\n  const config = {\n    something: {\n      nested: {\n        some_random_key: 'value',\n        some_random_key2: 'value2',\n      },\n    },\n  };\n  const exampleConfig = {\n    something: {\n      nested: {\n        test: true,\n      },\n    },\n  };\n\n  validate(config, {exampleConfig});\n\n  expect(spyConsoleWarn).toHaveBeenCalled();\n\n  spyConsoleWarn.mockReset();\n\n  validate(config, {\n    exampleConfig,\n    recursiveDenylist: ['something.nested'],\n  });\n\n  expect(spyConsoleWarn).not.toHaveBeenCalled();\n});\n\ntest('displays warning for unknown config options', () => {\n  const config = {unkwon: {}};\n  const validConfig = {unknown: 'string'};\n\n  validate(config, {exampleConfig: validConfig});\n\n  expect(spyConsoleWarn.mock.calls[0][0]).toMatchSnapshot();\n});\n\ntest('displays warning for deprecated config options', () => {\n  const config = {scriptPreprocessor: 'test'};\n\n  expect(\n    validate(config, {\n      deprecatedConfig,\n      exampleConfig: validConfig,\n    }),\n  ).toEqual({\n    hasDeprecationWarnings: true,\n    isValid: true,\n  });\n\n  expect(spyConsoleWarn.mock.calls[0][0]).toMatchSnapshot();\n});\n\ntest('works with custom warnings', () => {\n  const config = {unknown: 'string'};\n  const validConfig = {test: [1, 2]};\n  const options = {\n    comment: 'My custom comment',\n    deprecatedConfig,\n    exampleConfig: validConfig,\n    title: {\n      warning: 'My Custom Warning',\n    },\n  };\n\n  validate(config, options);\n\n  expect(spyConsoleWarn.mock.calls[0][0]).toMatchSnapshot();\n});\n\ntest('works with custom errors', () => {\n  const config = {test: 'string'};\n  const validConfig = {test: [1, 2]};\n  const options = {\n    comment: 'My custom comment',\n    deprecatedConfig,\n    exampleConfig: validConfig,\n    title: {\n      error: 'My Custom Error',\n    },\n  };\n\n  expect(() => validate(config, options)).toThrowErrorMatchingSnapshot();\n});\n\ntest('works with custom deprecations', () => {\n  const config = {scriptPreprocessor: 'test'};\n  const options = {\n    comment: 'My custom comment',\n    deprecatedConfig,\n    exampleConfig: validConfig,\n    title: {\n      deprecation: 'My Custom Deprecation Warning',\n    },\n  };\n\n  validate(config, options);\n\n  expect(spyConsoleWarn.mock.calls[0][0]).toMatchSnapshot();\n});\n\ntest('works with multiple valid types', () => {\n  const exampleConfig = {\n    foo: multipleValidOptions('text', ['text']),\n  };\n\n  expect(\n    validate(\n      {foo: 'foo'},\n      {\n        exampleConfig,\n      },\n    ),\n  ).toEqual({\n    hasDeprecationWarnings: false,\n    isValid: true,\n  });\n  expect(\n    validate(\n      {foo: ['foo']},\n      {\n        exampleConfig,\n      },\n    ),\n  ).toEqual({\n    hasDeprecationWarnings: false,\n    isValid: true,\n  });\n});\n\ntest('reports errors nicely when failing with multiple valid options', () => {\n  const exampleConfig = {\n    foo: multipleValidOptions('text', ['text']),\n  };\n\n  expect(() =>\n    validate(\n      {foo: 2},\n      {\n        exampleConfig,\n      },\n    ),\n  ).toThrowErrorMatchingSnapshot();\n});\n\ntest('Repeated types within multiple valid examples are coalesced in error report', () => {\n  const exampleConfig = {\n    foo: multipleValidOptions('foo', 'bar', 2),\n  };\n\n  expect(() =>\n    validate(\n      {foo: false},\n      {\n        exampleConfig,\n      },\n    ),\n  ).toThrowErrorMatchingSnapshot();\n});\n\ntest('Comments in config JSON using \"//\" key are not warned', () => {\n  const config = {'//': 'a comment'};\n\n  validate(config, {\n    exampleConfig: validConfig,\n  });\n  expect(spyConsoleWarn).not.toHaveBeenCalled();\n\n  spyConsoleWarn.mockReset();\n\n  validate(config, {\n    exampleConfig: validConfig,\n    recursiveDenylist: ['myCustomKey' as \"don't validate this\"],\n  });\n  expect(spyConsoleWarn).not.toHaveBeenCalled();\n});\n",
  "packages/jest-validate/src/__tests__/validate.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport {};\n",
  "packages/jest-validate/src/__tests__/__fixtures__/jestConfig.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport chalk from 'chalk';\n\nconst NODE_MODULES = `${path.sep}node_modules${path.sep}`;\nconst replacePathSepForRegex = (string: string) => {\n  if (path.sep === '\\\\') {\n    return string.replaceAll(/(\\/|\\\\(?!\\.))/g, '\\\\\\\\');\n  }\n  return string;\n};\n\nconst NODE_MODULES_REGEXP = replacePathSepForRegex(NODE_MODULES);\n\nexport const defaultConfig = {\n  automock: false,\n  bail: 0,\n  cacheDirectory: path.join(tmpdir(), 'jest'),\n  clearMocks: false,\n  coveragePathIgnorePatterns: [NODE_MODULES_REGEXP],\n  coverageReporters: ['json', 'text', 'lcov', 'clover'],\n  expand: false,\n  fakeTimers: {enableGlobally: false},\n  globals: {},\n  haste: {},\n  moduleDirectories: ['node_modules'],\n  moduleFileExtensions: ['js', 'json', 'jsx', 'node'],\n  moduleNameMapper: {},\n  modulePathIgnorePatterns: [],\n  noStackTrace: false,\n  notify: false,\n  notifyMode: 'failure-change',\n  preset: null,\n  prettierPath: 'prettier',\n  resetMocks: false,\n  resetModules: false,\n  restoreMocks: false,\n  roots: ['<rootDir>'],\n  snapshotSerializers: [],\n  testEnvironment: 'jest-environment-node',\n  testPathIgnorePatterns: [NODE_MODULES_REGEXP],\n  testRegex: '(/__tests__/.*|(\\\\.|/)(test|spec))\\\\.[mc]?[jt]sx?$',\n  testResultsProcessor: null,\n  transformIgnorePatterns: [NODE_MODULES_REGEXP],\n  useStderr: false,\n  verbose: null,\n  watch: false,\n  watchPathIgnorePatterns: [],\n};\n\nexport const validConfig = {\n  automock: false,\n  bail: 0,\n  cache: true,\n  cacheDirectory: '/tmp/user/jest',\n  clearMocks: false,\n  collectCoverage: true,\n  collectCoverageFrom: ['src', '!public'],\n  coverageDirectory: 'coverage',\n  coveragePathIgnorePatterns: [NODE_MODULES_REGEXP],\n  coverageReporters: ['json', 'text', 'lcov', 'clover'],\n  coverageThreshold: {\n    global: {\n      branches: 50,\n    },\n  },\n  expand: false,\n  fakeTimers: {enableGlobally: false},\n  forceExit: false,\n  globals: {},\n  haste: {},\n  id: 'string',\n  logHeapUsage: true,\n  moduleDirectories: ['node_modules'],\n  moduleFileExtensions: ['js', 'json', 'jsx', 'node'],\n  moduleNameMapper: {\n    '^React$': '<rootDir>/node_modules/react',\n    '^Vue$': ['<rootDir>/node_modules/vue', '<rootDir>/node_modules/vue3'],\n  },\n  modulePathIgnorePatterns: ['<rootDir>/build/'],\n  modulePaths: ['/shared/vendor/modules'],\n  noStackTrace: false,\n  notify: false,\n  notifyMode: 'failure-change',\n  preset: 'react-native',\n  prettierPath: '<rootDir>/node_modules/prettier',\n  resetMocks: false,\n  resetModules: false,\n  restoreMocks: false,\n  rootDir: '/',\n  roots: ['<rootDir>'],\n  runtime: '<rootDir>',\n  setupFiles: ['<rootDir>/setup.js'],\n  setupFilesAfterEnv: ['<rootDir>/testSetupFile.js'],\n  silent: true,\n  snapshotSerializers: ['my-serializer-module'],\n  testEnvironment: 'jest-environment-node',\n  testNamePattern: 'test signature',\n  testPathIgnorePatterns: [NODE_MODULES_REGEXP],\n  testRegex: '(/__tests__/.*|(\\\\.|/)(test|spec))\\\\.[mc]?[jt]sx?$',\n  testResultsProcessor: 'processor-node-module',\n  testRunner: 'circus',\n  transform: {\n    '\\\\.js$': '<rootDir>/preprocessor.js',\n  },\n  transformIgnorePatterns: [NODE_MODULES_REGEXP],\n  unmockedModulePathPatterns: ['mock'],\n  updateSnapshot: true,\n  useStderr: false,\n  verbose: false,\n  watch: false,\n  watchPathIgnorePatterns: [],\n  watchman: true,\n};\n\nconst format = (value: string) =>\n  (require('pretty-format') as typeof import('pretty-format')).format(value, {\n    min: true,\n  });\n\nexport const deprecatedConfig = {\n  preprocessorIgnorePatterns: (config: Record<string, unknown>) =>\n    `  Option ${chalk.bold(\n      'preprocessorIgnorePatterns',\n    )} was replaced by ${chalk.bold(\n      'transformIgnorePatterns',\n    )}, which support multiple preprocessors.\n\n  Jest now treats your current configuration as:\n  {\n    ${chalk.bold('\"transformIgnorePatterns\"')}: ${chalk.bold(\n      `${format(config.preprocessorIgnorePatterns as string)}`,\n    )}\n  }\n\n  Please update your configuration.`,\n\n  scriptPreprocessor: (config: Record<string, unknown>) =>\n    `  Option ${chalk.bold('scriptPreprocessor')} was replaced by ${chalk.bold(\n      'transform',\n    )}, which support multiple preprocessors.\n\n  Jest now treats your current configuration as:\n  {\n    ${chalk.bold('\"transform\"')}: ${chalk.bold(\n      `{\".*\": ${format(config.scriptPreprocessor as string)}}`,\n    )}\n  }\n\n  Please update your configuration.`,\n};\n",
  "packages/jest-validate/src/__tests__/__fixtures__/jestConfig.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport declare const defaultConfig: {\n    automock: boolean;\n    bail: number;\n    cacheDirectory: string;\n    clearMocks: boolean;\n    coveragePathIgnorePatterns: string[];\n    coverageReporters: string[];\n    expand: boolean;\n    fakeTimers: {\n        enableGlobally: boolean;\n    };\n    globals: {};\n    haste: {};\n    moduleDirectories: string[];\n    moduleFileExtensions: string[];\n    moduleNameMapper: {};\n    modulePathIgnorePatterns: never[];\n    noStackTrace: boolean;\n    notify: boolean;\n    notifyMode: string;\n    preset: null;\n    prettierPath: string;\n    resetMocks: boolean;\n    resetModules: boolean;\n    restoreMocks: boolean;\n    roots: string[];\n    snapshotSerializers: never[];\n    testEnvironment: string;\n    testPathIgnorePatterns: string[];\n    testRegex: string;\n    testResultsProcessor: null;\n    transformIgnorePatterns: string[];\n    useStderr: boolean;\n    verbose: null;\n    watch: boolean;\n    watchPathIgnorePatterns: never[];\n};\nexport declare const validConfig: {\n    automock: boolean;\n    bail: number;\n    cache: boolean;\n    cacheDirectory: string;\n    clearMocks: boolean;\n    collectCoverage: boolean;\n    collectCoverageFrom: string[];\n    coverageDirectory: string;\n    coveragePathIgnorePatterns: string[];\n    coverageReporters: string[];\n    coverageThreshold: {\n        global: {\n            branches: number;\n        };\n    };\n    expand: boolean;\n    fakeTimers: {\n        enableGlobally: boolean;\n    };\n    forceExit: boolean;\n    globals: {};\n    haste: {};\n    id: string;\n    logHeapUsage: boolean;\n    moduleDirectories: string[];\n    moduleFileExtensions: string[];\n    moduleNameMapper: {\n        '^React$': string;\n        '^Vue$': string[];\n    };\n    modulePathIgnorePatterns: string[];\n    modulePaths: string[];\n    noStackTrace: boolean;\n    notify: boolean;\n    notifyMode: string;\n    preset: string;\n    prettierPath: string;\n    resetMocks: boolean;\n    resetModules: boolean;\n    restoreMocks: boolean;\n    rootDir: string;\n    roots: string[];\n    runtime: string;\n    setupFiles: string[];\n    setupFilesAfterEnv: string[];\n    silent: boolean;\n    snapshotSerializers: string[];\n    testEnvironment: string;\n    testNamePattern: string;\n    testPathIgnorePatterns: string[];\n    testRegex: string;\n    testResultsProcessor: string;\n    testRunner: string;\n    transform: {\n        '\\\\.js$': string;\n    };\n    transformIgnorePatterns: string[];\n    unmockedModulePathPatterns: string[];\n    updateSnapshot: boolean;\n    useStderr: boolean;\n    verbose: boolean;\n    watch: boolean;\n    watchPathIgnorePatterns: never[];\n    watchman: boolean;\n};\nexport declare const deprecatedConfig: {\n    preprocessorIgnorePatterns: (config: Record<string, unknown>) => string;\n    scriptPreprocessor: (config: Record<string, unknown>) => string;\n};\n",
  "packages/jest-util/src/tryRealpath.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {realpathSync} from 'graceful-fs';\n\nexport default function tryRealpath(path: string): string {\n  try {\n    path = realpathSync.native(path);\n  } catch (error: any) {\n    if (error.code !== 'ENOENT' && error.code !== 'EISDIR') {\n      throw error;\n    }\n  }\n\n  return path;\n}\n",
  "packages/jest-util/src/tryRealpath.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport default function tryRealpath(path: string): string;\n",
  "packages/jest-util/src/specialChars.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst isWindows = process.platform === 'win32';\n\nexport const ARROW = ' \\u203A ';\nexport const ICONS = {\n  failed: isWindows ? '\\u00D7' : '\\u2715',\n  pending: '\\u25CB',\n  success: isWindows ? '\\u221A' : '\\u2713',\n  todo: '\\u270E',\n};\n\nexport const CLEAR = isWindows\n  ? '\\u001B[2J\\u001B[0f'\n  : '\\u001B[2J\\u001B[3J\\u001B[H';\n",
  "packages/jest-util/src/specialChars.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport declare const ARROW = \" \\u203A \";\nexport declare const ICONS: {\n    failed: string;\n    pending: string;\n    success: string;\n    todo: string;\n};\nexport declare const CLEAR: string;\n",
  "packages/jest-util/src/setGlobal.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {Global} from '@jest/types';\nimport {\n  canDeleteProperties,\n  protectProperties,\n} from './garbage-collection-utils';\n\nexport default function setGlobal(\n  globalToMutate: typeof globalThis | Global.Global,\n  key: string | symbol,\n  value: unknown,\n  afterTeardown: 'clean' | 'retain' = 'clean',\n): void {\n  Reflect.set(globalToMutate, key, value);\n  if (afterTeardown === 'retain' && canDeleteProperties(value)) {\n    protectProperties(value);\n  }\n}\n",
  "packages/jest-util/src/setGlobal.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Global } from '@jest/types';\nexport default function setGlobal(globalToMutate: typeof globalThis | Global.Global, key: string | symbol, value: unknown, afterTeardown?: 'clean' | 'retain'): void;\n",
  "packages/jest-util/src/requireOrImportModule.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {isAbsolute} from 'path';\nimport {pathToFileURL} from 'url';\nimport interopRequireDefault from './interopRequireDefault';\n\nasync function importModule(\n  filePath: string,\n  applyInteropRequireDefault: boolean,\n) {\n  try {\n    const moduleUrl = pathToFileURL(filePath);\n\n    // node `import()` supports URL, but TypeScript doesn't know that\n    const importedModule = await import(\n      /* webpackIgnore: true */ moduleUrl.href\n    );\n\n    if (!applyInteropRequireDefault) {\n      return importedModule;\n    }\n\n    if (!importedModule.default) {\n      throw new Error(\n        `Jest: Failed to load ESM at ${filePath} - did you use a default export?`,\n      );\n    }\n\n    return importedModule.default;\n  } catch (error: any) {\n    if (error.message === 'Not supported') {\n      throw new Error(\n        `Jest: Your version of Node does not support dynamic import - please enable it or use a .cjs file extension for file ${filePath}`,\n      );\n    }\n    throw error;\n  }\n}\n\nexport default async function requireOrImportModule<T>(\n  filePath: string,\n  applyInteropRequireDefault = true,\n): Promise<T> {\n  if (!isAbsolute(filePath) && filePath[0] === '.') {\n    throw new Error(\n      `Jest: requireOrImportModule path must be absolute, was \"${filePath}\"`,\n    );\n  }\n  try {\n    if (filePath.endsWith('.mjs')) {\n      return importModule(filePath, applyInteropRequireDefault);\n    }\n\n    const requiredModule = require(filePath);\n    if (!applyInteropRequireDefault) {\n      return requiredModule;\n    }\n    return interopRequireDefault(requiredModule).default;\n  } catch (error: any) {\n    if (\n      error.code === 'ERR_REQUIRE_ESM' ||\n      error.code === 'ERR_REQUIRE_ASYNC_MODULE'\n    ) {\n      return importModule(filePath, applyInteropRequireDefault);\n    } else {\n      throw error;\n    }\n  }\n}\n",
  "packages/jest-util/src/requireOrImportModule.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport default function requireOrImportModule<T>(filePath: string, applyInteropRequireDefault?: boolean): Promise<T>;\n",
  "packages/jest-util/src/replacePathSepForGlob.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nexport default function replacePathSepForGlob(path: string): string {\n  return path.replaceAll(/\\\\(?![$()+.?^{}])/g, '/');\n}\n",
  "packages/jest-util/src/replacePathSepForGlob.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport default function replacePathSepForGlob(path: string): string;\n",
  "packages/jest-util/src/preRunMessage.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {WriteStream} from 'tty';\nimport chalk from 'chalk';\nimport clearLine from './clearLine';\nimport isInteractive from './isInteractive';\n\nexport function print(stream: WriteStream): void {\n  if (isInteractive) {\n    stream.write(chalk.bold.dim('Determining test suites to run...'));\n  }\n}\n\nexport function remove(stream: WriteStream): void {\n  if (isInteractive) {\n    clearLine(stream);\n  }\n}\n",
  "packages/jest-util/src/preRunMessage.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { WriteStream } from 'tty';\nexport declare function print(stream: WriteStream): void;\nexport declare function remove(stream: WriteStream): void;\n",
  "packages/jest-util/src/pluralize.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nexport default function pluralize(\n  word: string,\n  count: number,\n  ending = 's',\n): string {\n  return `${count} ${word}${count === 1 ? '' : ending}`;\n}\n",
  "packages/jest-util/src/pluralize.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport default function pluralize(word: string, count: number, ending?: string): string;\n",
  "packages/jest-util/src/isPromise.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nexport default function isPromise<T = unknown>(\n  candidate: unknown,\n): candidate is PromiseLike<T> {\n  return (\n    candidate != null &&\n    (typeof candidate === 'object' || typeof candidate === 'function') &&\n    typeof (candidate as any).then === 'function'\n  );\n}\n",
  "packages/jest-util/src/isPromise.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport default function isPromise<T = unknown>(candidate: unknown): candidate is PromiseLike<T>;\n",
  "packages/jest-util/src/isNonNullable.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nexport default function isNonNullable<T>(value: T): value is NonNullable<T> {\n  return value != null;\n}\n",
  "packages/jest-util/src/isNonNullable.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport default function isNonNullable<T>(value: T): value is NonNullable<T>;\n",
  "packages/jest-util/src/isInteractive.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {isCI} from 'ci-info';\n\nfunction checkIsInteractive(): boolean {\n  if (isCI) {\n    return false;\n  }\n\n  // this can happen in a browser with polyfills: https://github.com/defunctzombie/node-process/issues/41\n  if (process.stdout == null) {\n    return false;\n  }\n\n  if (process.stdout.isTTY) {\n    return process.env.TERM !== 'dumb';\n  }\n\n  return false;\n}\n\nconst isInteractive = checkIsInteractive();\n\nexport default isInteractive;\n",
  "packages/jest-util/src/isInteractive.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\ndeclare const isInteractive: boolean;\nexport default isInteractive;\n",
  "packages/jest-util/src/invariant.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nexport default function invariant(\n  condition: unknown,\n  message = '',\n): asserts condition {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n",
  "packages/jest-util/src/invariant.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport default function invariant(condition: unknown, message?: string): asserts condition;\n",
  "packages/jest-util/src/interopRequireDefault.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// copied from https://github.com/babel/babel/blob/56044c7851d583d498f919e9546caddf8f80a72f/packages/babel-helpers/src/helpers.js#L558-L562\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport default function interopRequireDefault(obj: any): any {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n",
  "packages/jest-util/src/interopRequireDefault.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport default function interopRequireDefault(obj: any): any;\n",
  "packages/jest-util/src/installCommonGlobals.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as fs from 'graceful-fs';\nimport type {Config} from '@jest/types';\nimport createProcessObject from './createProcessObject';\nimport deepCyclicCopy from './deepCyclicCopy';\nimport {\n  type DeletionMode,\n  initializeGarbageCollectionUtils,\n} from './garbage-collection-utils';\n\nconst DTRACE = Object.keys(globalThis).filter(key => key.startsWith('DTRACE'));\n\nexport default function installCommonGlobals(\n  globalObject: typeof globalThis,\n  globals: Config.ConfigGlobals,\n  garbageCollectionDeletionMode?: DeletionMode,\n): typeof globalThis & Config.ConfigGlobals {\n  globalObject.process = createProcessObject();\n\n  const symbol = globalObject.Symbol as unknown as SymbolConstructor;\n  // Keep a reference to some globals that Jest needs\n  Object.defineProperties(globalObject, {\n    [symbol.for('jest-native-promise')]: {\n      enumerable: false,\n      value: Promise,\n      writable: false,\n    },\n    [symbol.for('jest-native-now')]: {\n      enumerable: false,\n      value: globalObject.Date.now.bind(globalObject.Date),\n      writable: false,\n    },\n    [symbol.for('jest-native-read-file')]: {\n      enumerable: false,\n      value: fs.readFileSync.bind(fs),\n      writable: false,\n    },\n    [symbol.for('jest-native-write-file')]: {\n      enumerable: false,\n      value: fs.writeFileSync.bind(fs),\n      writable: false,\n    },\n    [symbol.for('jest-native-exists-file')]: {\n      enumerable: false,\n      value: fs.existsSync.bind(fs),\n      writable: false,\n    },\n    'jest-symbol-do-not-touch': {\n      enumerable: false,\n      value: symbol,\n      writable: false,\n    },\n  });\n\n  // Forward some APIs.\n  for (const dtrace of DTRACE) {\n    // @ts-expect-error: no index\n    globalObject[dtrace] = function (...args: Array<any>) {\n      // @ts-expect-error: no index\n      return globalThis[dtrace].apply(this, args);\n    };\n  }\n\n  if (garbageCollectionDeletionMode) {\n    initializeGarbageCollectionUtils(\n      globalObject,\n      garbageCollectionDeletionMode,\n    );\n  }\n\n  return Object.assign(globalObject, deepCyclicCopy(globals));\n}\n",
  "packages/jest-util/src/installCommonGlobals.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config } from '@jest/types';\nimport { type DeletionMode } from './garbage-collection-utils';\nexport default function installCommonGlobals(globalObject: typeof globalThis, globals: Config.ConfigGlobals, garbageCollectionDeletionMode?: DeletionMode): typeof globalThis & Config.ConfigGlobals;\n",
  "packages/jest-util/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// need to do this for api-extractor: https://github.com/microsoft/rushstack/issues/2780\nimport * as preRunMessage from './preRunMessage';\nimport * as specialChars from './specialChars';\n\nexport {default as clearLine} from './clearLine';\nexport {default as createDirectory} from './createDirectory';\nexport {default as ErrorWithStack} from './ErrorWithStack';\nexport {default as installCommonGlobals} from './installCommonGlobals';\nexport {default as interopRequireDefault} from './interopRequireDefault';\nexport {default as isInteractive} from './isInteractive';\nexport {default as isPromise} from './isPromise';\nexport {default as setGlobal} from './setGlobal';\nexport {default as deepCyclicCopy} from './deepCyclicCopy';\nexport {default as convertDescriptorToString} from './convertDescriptorToString';\nexport {specialChars};\nexport {default as replacePathSepForGlob} from './replacePathSepForGlob';\nexport {default as globsToMatcher} from './globsToMatcher';\nexport {preRunMessage};\nexport {default as pluralize} from './pluralize';\nexport {default as formatTime} from './formatTime';\nexport {default as tryRealpath} from './tryRealpath';\nexport {default as requireOrImportModule} from './requireOrImportModule';\nexport {default as invariant} from './invariant';\nexport {default as isNonNullable} from './isNonNullable';\nexport {\n  type DeletionMode,\n  canDeleteProperties,\n  initializeGarbageCollectionUtils,\n  protectProperties,\n  deleteProperties,\n} from './garbage-collection-utils';\n",
  "packages/jest-util/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport * as preRunMessage from './preRunMessage';\nimport * as specialChars from './specialChars';\nexport { default as clearLine } from './clearLine';\nexport { default as createDirectory } from './createDirectory';\nexport { default as ErrorWithStack } from './ErrorWithStack';\nexport { default as installCommonGlobals } from './installCommonGlobals';\nexport { default as interopRequireDefault } from './interopRequireDefault';\nexport { default as isInteractive } from './isInteractive';\nexport { default as isPromise } from './isPromise';\nexport { default as setGlobal } from './setGlobal';\nexport { default as deepCyclicCopy } from './deepCyclicCopy';\nexport { default as convertDescriptorToString } from './convertDescriptorToString';\nexport { specialChars };\nexport { default as replacePathSepForGlob } from './replacePathSepForGlob';\nexport { default as globsToMatcher } from './globsToMatcher';\nexport { preRunMessage };\nexport { default as pluralize } from './pluralize';\nexport { default as formatTime } from './formatTime';\nexport { default as tryRealpath } from './tryRealpath';\nexport { default as requireOrImportModule } from './requireOrImportModule';\nexport { default as invariant } from './invariant';\nexport { default as isNonNullable } from './isNonNullable';\nexport { type DeletionMode, canDeleteProperties, initializeGarbageCollectionUtils, protectProperties, deleteProperties, } from './garbage-collection-utils';\n",
  "packages/jest-util/src/globsToMatcher.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport picomatch from 'picomatch';\nimport replacePathSepForGlob from './replacePathSepForGlob';\n\ntype Matcher = (str: string) => boolean;\n\nconst globsToMatchersMap = new Map<\n  string,\n  {isMatch: Matcher; negated: boolean}\n>();\n\nconst picomatchOptions = {dot: true};\n\n/**\n * Converts a list of globs into a function that matches a path against the\n * globs.\n *\n * Every time picomatch is called, it will parse the glob strings and turn\n * them into regexp instances. Instead of calling picomatch repeatedly with\n * the same globs, we can use this function which will build the picomatch\n * matchers ahead of time and then have an optimized path for determining\n * whether an individual path matches.\n *\n * This function is intended to match the behavior of `micromatch()`.\n *\n * @example\n * const isMatch = globsToMatcher(['*.js', '!*.test.js']);\n * isMatch('pizza.js'); // true\n * isMatch('pizza.test.js'); // false\n */\nexport default function globsToMatcher(globs: Array<string>): Matcher {\n  if (globs.length === 0) {\n    // Since there were no globs given, we can simply have a fast path here and\n    // return with a very simple function.\n    return () => false;\n  }\n\n  const matchers = globs.map(glob => {\n    if (!globsToMatchersMap.has(glob)) {\n      const isMatch = picomatch(glob, picomatchOptions, true);\n\n      const matcher = {\n        isMatch,\n        // Matchers that are negated have different behavior than matchers that\n        // are not negated, so we need to store this information ahead of time.\n        negated: isMatch.state.negated || !!isMatch.state.negatedExtglob,\n      };\n\n      globsToMatchersMap.set(glob, matcher);\n    }\n\n    return globsToMatchersMap.get(glob)!;\n  });\n\n  return path => {\n    const replacedPath = replacePathSepForGlob(path);\n    let kept = undefined;\n    let negatives = 0;\n\n    for (const matcher of matchers) {\n      const {isMatch, negated} = matcher;\n\n      if (negated) {\n        negatives++;\n      }\n\n      const matched = isMatch(replacedPath);\n\n      if (!matched && negated) {\n        // The path was not matched, and the matcher is a negated matcher, so we\n        // want to omit the path. This means that the negative matcher is\n        // filtering the path out.\n        kept = false;\n      } else if (matched && !negated) {\n        // The path was matched, and the matcher is not a negated matcher, so we\n        // want to keep the path.\n        kept = true;\n      }\n    }\n\n    // If all of the globs were negative globs, then we want to include the path\n    // as long as it was not explicitly not kept. Otherwise only include\n    // the path if it was kept. This allows sets of globs that are all negated\n    // to allow some paths to be matched, while sets of globs that are mixed\n    // negated and non-negated to cause the negated matchers to only omit paths\n    // and not keep them.\n    return negatives === matchers.length ? kept !== false : !!kept;\n  };\n}\n",
  "packages/jest-util/src/globsToMatcher.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\ntype Matcher = (str: string) => boolean;\n/**\n * Converts a list of globs into a function that matches a path against the\n * globs.\n *\n * Every time picomatch is called, it will parse the glob strings and turn\n * them into regexp instances. Instead of calling picomatch repeatedly with\n * the same globs, we can use this function which will build the picomatch\n * matchers ahead of time and then have an optimized path for determining\n * whether an individual path matches.\n *\n * This function is intended to match the behavior of `micromatch()`.\n *\n * @example\n * const isMatch = globsToMatcher(['*.js', '!*.test.js']);\n * isMatch('pizza.js'); // true\n * isMatch('pizza.test.js'); // false\n */\nexport default function globsToMatcher(globs: Array<string>): Matcher;\nexport {};\n",
  "packages/jest-util/src/garbage-collection-utils.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport chalk from 'chalk';\n\n/**\n * The symbol that is set on the global object to store the deletion mode.\n */\nconst DELETION_MODE_SYMBOL = Symbol.for('$$jest-deletion-mode');\n\n/**\n * The symbol that is set on objects to protect them from deletion.\n *\n * If the value is an empty array, then all properties will be protected.\n * If the value is an array of strings or symbols, then only those properties will be protected.\n */\nconst PROTECT_SYMBOL = Symbol.for('$$jest-protect-from-deletion');\n\n/**\n *  - <b>off</b>: deletion is completely turned off.\n *  - <b>soft</b>: doesn't delete objects, but instead wraps their getter/setter with a deprecation warning.\n *  - <b>on</b>: actually delete objects (using `delete`).\n */\nexport type DeletionMode = 'soft' | 'off' | 'on';\n\n/**\n * Initializes the garbage collection utils with the given deletion mode.\n *\n * @param globalObject the global object on which to store the deletion mode.\n * @param deletionMode the deletion mode to use.\n */\nexport function initializeGarbageCollectionUtils(\n  globalObject: typeof globalThis,\n  deletionMode: DeletionMode,\n): void {\n  const currentMode = Reflect.get(globalObject, DELETION_MODE_SYMBOL);\n  if (currentMode && currentMode !== deletionMode) {\n    console.warn(\n      chalk.yellow(\n        [\n          '[jest-util] garbage collection deletion mode already initialized, ignoring new mode',\n          `  Current: '${currentMode}'`,\n          `  Given: '${deletionMode}'`,\n        ].join('\\n'),\n      ),\n    );\n    return;\n  }\n  Reflect.set(globalObject, DELETION_MODE_SYMBOL, deletionMode);\n}\n\n/**\n * Deletes all the properties from the given value (if it's an object),\n * unless the value was protected via {@link #protectProperties}.\n *\n * @param value the given value.\n */\nexport function deleteProperties(value: unknown): void {\n  if (getDeletionMode() !== 'off' && canDeleteProperties(value)) {\n    const protectedKeys = getProtectedKeys(\n      value,\n      Reflect.get(value, PROTECT_SYMBOL),\n    );\n    for (const key of Reflect.ownKeys(value)) {\n      if (!protectedKeys.includes(key) && key !== PROTECT_SYMBOL) {\n        deleteProperty(value, key);\n      }\n    }\n  }\n}\n\n/**\n * Protects the given value from being deleted by {@link #deleteProperties}.\n *\n * @param value The given value.\n * @param properties If the array contains any property,\n * then only these properties will be protected; otherwise if the array is empty,\n * all properties will be protected.\n * @param depth Determines how \"deep\" the protection should be.\n * A value of 0 means that only the top-most properties will be protected,\n * while a value larger than 0 means that deeper levels of nesting will be protected as well.\n */\nexport function protectProperties<T>(\n  value: T,\n  properties: Array<keyof T> = [],\n  depth = 2,\n): boolean {\n  if (getDeletionMode() === 'off') {\n    return false;\n  }\n\n  // Reflect.get may cause deprecation warnings, so we disable them temporarily\n  const originalEmitWarning = process.emitWarning;\n\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    process.emitWarning = () => {};\n    if (\n      depth >= 0 &&\n      canDeleteProperties(value) &&\n      !Reflect.has(value, PROTECT_SYMBOL)\n    ) {\n      const result = Reflect.defineProperty(value, PROTECT_SYMBOL, {\n        configurable: true,\n        enumerable: false,\n        value: properties,\n        writable: true,\n      });\n      for (const key of getProtectedKeys(value, properties)) {\n        try {\n          const nested = Reflect.get(value, key);\n          protectProperties(nested, [], depth - 1);\n        } catch {\n          // Reflect.get might fail in certain edge-cases\n          // Instead of failing the entire process, we will skip the property.\n        }\n      }\n      return result;\n    }\n    return false;\n  } finally {\n    process.emitWarning = originalEmitWarning;\n  }\n}\n\n/**\n * Whether the given value has properties that can be deleted (regardless of protection).\n *\n * @param value The given value.\n */\nexport function canDeleteProperties(value: unknown): value is object {\n  if (value !== null) {\n    const type = typeof value;\n    return type === 'object' || type === 'function';\n  }\n\n  return false;\n}\n\n/**\n * Deletes the property of the given key from the given object.\n *\n * @param obj the given object.\n * @param key the given key.\n * @param mode there are two possible modes of deletion:\n *  - <b>soft</b>: doesn't delete the object, but instead wraps its getter/setter with a deprecation warning.\n *  - <b>hard</b>: actually deletes the object (`delete`).\n *\n * @returns whether the deletion was successful or not.\n */\nfunction deleteProperty(obj: object, key: string | symbol): boolean {\n  const descriptor = Reflect.getOwnPropertyDescriptor(obj, key);\n  if (!descriptor?.configurable) {\n    return false;\n  }\n\n  if (getDeletionMode() === 'on') {\n    return Reflect.deleteProperty(obj, key);\n  }\n\n  const originalGetter = descriptor.get ?? (() => descriptor.value);\n  const originalSetter =\n    descriptor.set ?? (value => Reflect.set(obj, key, value));\n\n  return Reflect.defineProperty(obj, key, {\n    configurable: true,\n    enumerable: descriptor.enumerable,\n    get() {\n      emitAccessWarning(obj, key);\n      return originalGetter();\n    },\n    set(value) {\n      emitAccessWarning(obj, key);\n      return originalSetter(value);\n    },\n  });\n}\n\nfunction getDeletionMode(): DeletionMode {\n  return Reflect.get(globalThis, DELETION_MODE_SYMBOL) ?? 'off';\n}\n\nconst warningCache = new WeakSet<object>();\n\nfunction emitAccessWarning(obj: object, key: string | symbol): void {\n  if (warningCache.has(obj)) {\n    return;\n  }\n  const objName = obj?.constructor?.name ?? 'unknown';\n  const propertyName = typeof key === 'symbol' ? key.description : key;\n\n  process.emitWarning(\n    `'${propertyName}' property was accessed on [${objName}] after it was soft deleted`,\n    {\n      code: 'JEST-01',\n      detail: [\n        'Jest deletes objects that were set on the global scope between test files to reduce memory leaks.',\n        'Currently it only \"soft\" deletes them and emits this warning if those objects were accessed after their deletion.',\n        'In future versions of Jest, this behavior will change to \"on\", which will likely fail tests.',\n        'You can change the behavior in your test configuration now to reduce memory usage.',\n      ]\n        .map(s => `  ${s}`)\n        .join('\\n'),\n      type: 'DeprecationWarning',\n    },\n  );\n  warningCache.add(obj);\n}\n\nfunction getProtectedKeys<T extends object>(\n  value: T,\n  properties: Array<keyof T> | undefined,\n): Array<string | symbol | number> {\n  if (properties === undefined) {\n    return [];\n  }\n  const protectedKeys =\n    properties.length > 0 ? properties : Reflect.ownKeys(value);\n  return protectedKeys.filter(key => PROTECT_SYMBOL !== key);\n}\n",
  "packages/jest-util/src/garbage-collection-utils.d.ts": "/**\n *  - <b>off</b>: deletion is completely turned off.\n *  - <b>soft</b>: doesn't delete objects, but instead wraps their getter/setter with a deprecation warning.\n *  - <b>on</b>: actually delete objects (using `delete`).\n */\nexport type DeletionMode = 'soft' | 'off' | 'on';\n/**\n * Initializes the garbage collection utils with the given deletion mode.\n *\n * @param globalObject the global object on which to store the deletion mode.\n * @param deletionMode the deletion mode to use.\n */\nexport declare function initializeGarbageCollectionUtils(globalObject: typeof globalThis, deletionMode: DeletionMode): void;\n/**\n * Deletes all the properties from the given value (if it's an object),\n * unless the value was protected via {@link #protectProperties}.\n *\n * @param value the given value.\n */\nexport declare function deleteProperties(value: unknown): void;\n/**\n * Protects the given value from being deleted by {@link #deleteProperties}.\n *\n * @param value The given value.\n * @param properties If the array contains any property,\n * then only these properties will be protected; otherwise if the array is empty,\n * all properties will be protected.\n * @param depth Determines how \"deep\" the protection should be.\n * A value of 0 means that only the top-most properties will be protected,\n * while a value larger than 0 means that deeper levels of nesting will be protected as well.\n */\nexport declare function protectProperties<T>(value: T, properties?: Array<keyof T>, depth?: number): boolean;\n/**\n * Whether the given value has properties that can be deleted (regardless of protection).\n *\n * @param value The given value.\n */\nexport declare function canDeleteProperties(value: unknown): value is object;\n",
  "packages/jest-util/src/formatTime.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nexport default function formatTime(\n  time: number,\n  prefixPower = -3,\n  padLeftLength = 0,\n): string {\n  const prefixes = ['n', 'μ', 'm', ''];\n  const prefixIndex = Math.max(\n    0,\n    Math.min(\n      Math.trunc(prefixPower / 3) + prefixes.length - 1,\n      prefixes.length - 1,\n    ),\n  );\n  return `${String(time).padStart(padLeftLength)} ${prefixes[prefixIndex]}s`;\n}\n",
  "packages/jest-util/src/formatTime.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport default function formatTime(time: number, prefixPower?: number, padLeftLength?: number): string;\n",
  "packages/jest-util/src/deepCyclicCopy.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst EMPTY = new Set<string>();\n\nexport type DeepCyclicCopyOptions = {\n  blacklist?: Set<string>;\n  keepPrototype?: boolean;\n};\n\nexport default function deepCyclicCopy<T>(\n  value: T,\n  options?: DeepCyclicCopyOptions,\n  cycles = new WeakMap<any, any>(),\n): T {\n  options = {blacklist: EMPTY, keepPrototype: false, ...options};\n  if (typeof value !== 'object' || value === null || Buffer.isBuffer(value)) {\n    return value;\n  } else if (cycles.has(value)) {\n    return cycles.get(value);\n  } else if (Array.isArray(value)) {\n    return deepCyclicCopyArray(value, options, cycles);\n  } else {\n    return deepCyclicCopyObject(value, options, cycles);\n  }\n}\n\nfunction deepCyclicCopyObject<T>(\n  object: T,\n  options: DeepCyclicCopyOptions,\n  cycles: WeakMap<any, any>,\n): T {\n  const newObject = options.keepPrototype\n    ? Object.create(Object.getPrototypeOf(object))\n    : {};\n\n  const descriptors = Object.getOwnPropertyDescriptors(object);\n\n  cycles.set(object, newObject);\n\n  for (const key of Object.keys(descriptors)) {\n    if (options.blacklist && options.blacklist.has(key)) {\n      delete descriptors[key];\n      continue;\n    }\n\n    const descriptor = descriptors[key];\n    if (descriptor.value !== undefined) {\n      descriptor.value = deepCyclicCopy(\n        descriptor.value,\n        {blacklist: EMPTY, keepPrototype: options.keepPrototype},\n        cycles,\n      );\n    }\n\n    descriptor.configurable = true;\n  }\n\n  return Object.defineProperties(newObject, descriptors);\n}\n\nfunction deepCyclicCopyArray<T>(\n  array: Array<T>,\n  options: DeepCyclicCopyOptions,\n  cycles: WeakMap<any, any>,\n): T {\n  const newArray = options.keepPrototype\n    ? new (Object.getPrototypeOf(array).constructor)(array.length)\n    : [];\n  const length = array.length;\n\n  cycles.set(array, newArray);\n\n  for (let i = 0; i < length; i++) {\n    newArray[i] = deepCyclicCopy(\n      array[i],\n      {blacklist: EMPTY, keepPrototype: options.keepPrototype},\n      cycles,\n    );\n  }\n\n  return newArray;\n}\n",
  "packages/jest-util/src/deepCyclicCopy.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport type DeepCyclicCopyOptions = {\n    blacklist?: Set<string>;\n    keepPrototype?: boolean;\n};\nexport default function deepCyclicCopy<T>(value: T, options?: DeepCyclicCopyOptions, cycles?: WeakMap<any, any>): T;\n",
  "packages/jest-util/src/createProcessObject.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type * as Process from 'process';\nimport deepCyclicCopy from './deepCyclicCopy';\n\nconst BLACKLIST = new Set(['env', 'mainModule', '_events']);\nconst isWin32 = process.platform === 'win32';\nconst proto: Record<string, unknown> = Object.getPrototypeOf(process.env);\n\n// The \"process.env\" object has a bunch of particularities: first, it does not\n// directly extend from Object; second, it converts any assigned value to a\n// string; and third, it is case-insensitive in Windows. We use a proxy here to\n// mimic it (see https://nodejs.org/api/process.html#process_process_env).\n\nfunction createProcessEnv(): NodeJS.ProcessEnv {\n  const real = Object.create(proto);\n  const lookup: typeof process.env = {};\n\n  function deletePropertyWin32(_target: unknown, key: unknown) {\n    for (const name in real) {\n      if (Object.prototype.hasOwnProperty.call(real, name)) {\n        if (typeof key === 'string') {\n          if (name.toLowerCase() === key.toLowerCase()) {\n            delete real[name];\n            delete lookup[name.toLowerCase()];\n          }\n        } else {\n          if (key === name) {\n            delete real[name];\n            delete lookup[name];\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n\n  function deleteProperty(_target: unknown, key: any) {\n    delete real[key];\n    delete lookup[key];\n\n    return true;\n  }\n\n  function getProperty(_target: unknown, key: any) {\n    return real[key];\n  }\n\n  function getPropertyWin32(_target: unknown, key: any) {\n    if (typeof key === 'string') {\n      return lookup[key in proto ? key : key.toLowerCase()];\n    } else {\n      return real[key];\n    }\n  }\n\n  const proxy = new Proxy(real, {\n    deleteProperty: isWin32 ? deletePropertyWin32 : deleteProperty,\n    get: isWin32 ? getPropertyWin32 : getProperty,\n\n    set(_target, key, value) {\n      const strValue = `${value}`;\n\n      if (typeof key === 'string') {\n        lookup[key.toLowerCase()] = strValue;\n      }\n\n      real[key] = strValue;\n\n      return true;\n    },\n  });\n\n  return Object.assign(proxy, process.env);\n}\n\nexport default function createProcessObject(): typeof Process {\n  const process = require('process');\n  const newProcess = deepCyclicCopy(process, {\n    blacklist: BLACKLIST,\n    keepPrototype: true,\n  });\n\n  try {\n    // This fails on Node 12, but it's already set to 'process'\n    newProcess[Symbol.toStringTag] = 'process';\n  } catch (error: any) {\n    // Make sure it's actually set instead of potentially ignoring errors\n    if (newProcess[Symbol.toStringTag] !== 'process') {\n      error.message = `Unable to set toStringTag on process. Please open up an issue at https://github.com/jestjs/jest\\n\\n${error.message}`;\n\n      throw error;\n    }\n  }\n\n  // Sequentially execute all constructors over the object.\n  let proto = process;\n\n  while ((proto = Object.getPrototypeOf(proto))) {\n    if (typeof proto.constructor === 'function') {\n      proto.constructor.call(newProcess);\n    }\n  }\n\n  newProcess.env = createProcessEnv();\n  newProcess.send = () => true;\n\n  Object.defineProperty(newProcess, 'domain', {\n    get() {\n      return process.domain;\n    },\n  });\n\n  return newProcess;\n}\n",
  "packages/jest-util/src/createProcessObject.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type * as Process from 'process';\nexport default function createProcessObject(): typeof Process;\n",
  "packages/jest-util/src/createDirectory.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as fs from 'graceful-fs';\n\nexport default function createDirectory(path: string): void {\n  try {\n    fs.mkdirSync(path, {recursive: true});\n  } catch (error: any) {\n    if (error.code !== 'EEXIST') {\n      throw error;\n    }\n  }\n}\n",
  "packages/jest-util/src/createDirectory.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport default function createDirectory(path: string): void;\n",
  "packages/jest-util/src/convertDescriptorToString.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {Global} from '@jest/types';\n\nexport default function convertDescriptorToString(\n  descriptor: Global.BlockNameLike | undefined,\n): string {\n  switch (typeof descriptor) {\n    case 'function':\n      if (descriptor.name) {\n        return descriptor.name;\n      }\n      break;\n\n    case 'number':\n    case 'undefined':\n      return `${descriptor}`;\n\n    case 'string':\n      return descriptor;\n  }\n\n  throw new Error(\n    `Invalid first argument, ${descriptor}. It must be a named class, named function, number, or string.`,\n  );\n}\n",
  "packages/jest-util/src/convertDescriptorToString.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Global } from '@jest/types';\nexport default function convertDescriptorToString(descriptor: Global.BlockNameLike | undefined): string;\n",
  "packages/jest-util/src/clearLine.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {WriteStream} from 'tty';\n\nexport default function clearLine(stream: WriteStream): void {\n  if (stream.isTTY) {\n    stream.write('\\u001B[999D\\u001B[K');\n  }\n}\n",
  "packages/jest-util/src/clearLine.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { WriteStream } from 'tty';\nexport default function clearLine(stream: WriteStream): void;\n",
  "packages/jest-util/src/ErrorWithStack.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nexport default class ErrorWithStack extends Error {\n  constructor(\n    message: string | undefined,\n    callsite: (...args: Array<any>) => unknown,\n    stackLimit?: number,\n  ) {\n    // Ensure we have a large stack length so we get full details.\n    const originalStackLimit = Error.stackTraceLimit;\n    if (stackLimit) {\n      Error.stackTraceLimit = Math.max(stackLimit, originalStackLimit || 10);\n    }\n\n    super(message);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, callsite);\n    }\n\n    Error.stackTraceLimit = originalStackLimit;\n  }\n}\n",
  "packages/jest-util/src/ErrorWithStack.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport default class ErrorWithStack extends Error {\n    constructor(message: string | undefined, callsite: (...args: Array<any>) => unknown, stackLimit?: number);\n}\n",
  "packages/jest-util/src/__tests__/isPromise.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport isPromise from '../isPromise';\n\ndescribe('not a Promise: ', () => {\n  test.each([undefined, null, true, 42, '1337', Symbol(), [], {}])(\n    '%p',\n    value => {\n      expect(isPromise(value)).toBe(false);\n    },\n  );\n});\n\ntest('a resolved Promise', () => {\n  expect(isPromise(Promise.resolve(42))).toBe(true);\n});\n\ntest('a rejected Promise', () => {\n  expect(isPromise(Promise.reject().catch(() => {}))).toBe(true);\n});\n\ntest('a thenable', () => {\n  // eslint-disable-next-line unicorn/no-thenable\n  expect(isPromise({then: () => 'hello'})).toBe(true);\n});\n\ntest('an async function', () => {\n  async function asyncFn() {}\n  expect(isPromise(asyncFn())).toBe(true);\n});\n",
  "packages/jest-util/src/__tests__/isPromise.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-util/src/__tests__/isInteractive.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as process from 'process';\n\nconst oldIsTTY = process.stdout.isTTY;\nconst oldTERM = process.env.TERM;\n\nafterEach(() => {\n  process.stdout.isTTY = oldIsTTY;\n  process.env.TERM = oldTERM;\n  jest.resetModules();\n});\n\nit('Returns true when running in an interactive environment', () => {\n  jest.doMock('ci-info', () => ({isCI: false}));\n  process.stdout.isTTY = true;\n  process.env.TERM = 'xterm-256color';\n\n  const isInteractive = (\n    require('../isInteractive') as typeof import('../isInteractive')\n  ).default;\n\n  expect(isInteractive).toBe(true);\n});\n\nit.each([\n  {isCI: false, isTTY: false, term: 'xterm-256color'},\n  {isCI: false, isTTY: false, term: 'xterm-256color'},\n  {isCI: true, isTTY: true, term: 'xterm-256color'},\n  {isCI: false, isTTY: false, term: 'dumb'},\n])(\n  'Returns false when running in a non-interactive environment',\n  ({isCI, isTTY, term}) => {\n    jest.doMock('ci-info', () => ({isCI}));\n    process.stdout.isTTY = isTTY;\n    process.env.TERM = term;\n\n    const isInteractive = (\n      require('../isInteractive') as typeof import('../isInteractive')\n    ).default;\n\n    expect(isInteractive).toBe(false);\n  },\n);\n",
  "packages/jest-util/src/__tests__/isInteractive.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-util/src/__tests__/installCommonGlobals.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {createContext, runInContext} from 'vm';\n\ndeclare global {\n  function DTRACE_NET_SERVER_CONNECTION(): unknown;\n}\n\nconst fake = jest.fn();\nglobalThis.DTRACE_NET_SERVER_CONNECTION = fake;\n\nlet installCommonGlobals: typeof import('../installCommonGlobals').default;\n\nfunction getGlobal(): typeof globalThis {\n  return runInContext('this', createContext()) as typeof globalThis;\n}\n\nbeforeEach(() => {\n  installCommonGlobals = (\n    require('../installCommonGlobals') as typeof import('../installCommonGlobals')\n  ).default;\n});\n\nafterEach(() => {\n  jest.clearAllMocks();\n  jest.resetModules();\n});\n\nit('returns the passed object', () => {\n  const myGlobal = getGlobal();\n\n  expect(installCommonGlobals(myGlobal, {})).toBe(myGlobal);\n});\n\nit('turns a V8 global object into a Node global object', () => {\n  const myGlobal = installCommonGlobals(getGlobal(), {});\n\n  expect(myGlobal.process).toBeDefined();\n  expect(myGlobal.DTRACE_NET_SERVER_CONNECTION).toBeDefined();\n  expect(myGlobal.DTRACE_NET_SERVER_CONNECTION).not.toBe(fake);\n\n  myGlobal.DTRACE_NET_SERVER_CONNECTION();\n\n  expect(fake).toHaveBeenCalledTimes(1);\n});\n",
  "packages/jest-util/src/__tests__/installCommonGlobals.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\ndeclare global {\n    function DTRACE_NET_SERVER_CONNECTION(): unknown;\n}\nexport {};\n",
  "packages/jest-util/src/__tests__/globsToMatcher.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport micromatch from 'micromatch';\nimport globsToMatcher from '../globsToMatcher';\n\nit('works like micromatch with only positive globs', () => {\n  const globs = ['**/*.test.js', '**/*.test.jsx'];\n  const matcher = globsToMatcher(globs);\n\n  expect(matcher('some-module.js')).toBe(\n    micromatch(['some-module.js'], globs).length > 0,\n  );\n\n  expect(matcher('some-module.test.js')).toBe(\n    micromatch(['some-module.test.js'], globs).length > 0,\n  );\n});\n\nit('works like micromatch with a mix of overlapping positive and negative globs', () => {\n  const globs = ['**/*.js', '!**/*.test.js', '**/*.test.js'];\n  const matcher = globsToMatcher(globs);\n\n  expect(matcher('some-module.js')).toBe(\n    micromatch(['some-module.js'], globs).length > 0,\n  );\n\n  expect(matcher('some-module.test.js')).toBe(\n    micromatch(['some-module.test.js'], globs).length > 0,\n  );\n\n  const globs2 = ['**/*.js', '!**/*.test.js', '**/*.test.js', '!**/*.test.js'];\n  const matcher2 = globsToMatcher(globs2);\n\n  expect(matcher2('some-module.js')).toBe(\n    micromatch(['some-module.js'], globs2).length > 0,\n  );\n\n  expect(matcher2('some-module.test.js')).toBe(\n    micromatch(['some-module.test.js'], globs2).length > 0,\n  );\n});\n\nit('works like micromatch with only negative globs', () => {\n  const globs = ['!**/*.test.js', '!**/*.test.jsx'];\n  const matcher = globsToMatcher(globs);\n\n  expect(matcher('some-module.js')).toBe(\n    micromatch(['some-module.js'], globs).length > 0,\n  );\n\n  expect(matcher('some-module.test.js')).toBe(\n    micromatch(['some-module.test.js'], globs).length > 0,\n  );\n});\n\nit('works like micromatch with empty globs', () => {\n  const globs: Array<string> = [];\n  const matcher = globsToMatcher(globs);\n\n  expect(matcher('some-module.js')).toBe(\n    micromatch(['some-module.js'], globs).length > 0,\n  );\n\n  expect(matcher('some-module.test.js')).toBe(\n    micromatch(['some-module.test.js'], globs).length > 0,\n  );\n});\n\nit('works like micromatch with pure negated extglobs', () => {\n  const globs = ['**/*.js', '!(some-module.test.js)'];\n  const matcher = globsToMatcher(globs);\n\n  expect(matcher('some-module.js')).toBe(\n    micromatch(['some-module.js'], globs).length > 0,\n  );\n\n  expect(matcher('some-module.test.js')).toBe(\n    micromatch(['some-module.test.js'], globs).length > 0,\n  );\n});\n\nit('works like micromatch with negated extglobs', () => {\n  const globs = ['**/*.js', '!(tests|coverage)/*.js'];\n  const matcher = globsToMatcher(globs);\n\n  expect(matcher('some-module.js')).toBe(\n    micromatch(['some-module.js'], globs).length > 0,\n  );\n\n  expect(matcher('tests/some-module.test.js')).toBe(\n    micromatch(['tests/some-module.test.js'], globs).length > 0,\n  );\n});\n",
  "packages/jest-util/src/__tests__/globsToMatcher.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-util/src/__tests__/garbage-collection-utils.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {protectProperties} from '../garbage-collection-utils';\n\nconst omit = require('lodash').omit;\n\nit('protection symbol doesnt leak', () => {\n  const obj = {a: 1, b: 2};\n  protectProperties(obj);\n  expect(obj).toStrictEqual(obj);\n  expect(omit(obj, 'a')).toStrictEqual({b: 2});\n  expect({b: 2}).toStrictEqual(omit(obj, 'a'));\n});\n",
  "packages/jest-util/src/__tests__/garbage-collection-utils.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-util/src/__tests__/formatTime.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport formatTime from '../formatTime';\n\nit('defaults to milliseconds', () => {\n  expect(formatTime(42)).toBe('42 ms');\n});\n\nit('formats seconds properly', () => {\n  expect(formatTime(42, 0)).toBe('42 s');\n});\n\nit('formats milliseconds properly', () => {\n  expect(formatTime(42, -3)).toBe('42 ms');\n});\n\nit('formats microseconds properly', () => {\n  expect(formatTime(42, -6)).toBe('42 μs');\n});\n\nit('formats nanoseconds properly', () => {\n  expect(formatTime(42, -9)).toBe('42 ns');\n});\n\nit('interprets lower than lowest powers as nanoseconds', () => {\n  expect(formatTime(42, -12)).toBe('42 ns');\n});\n\nit('interprets higher than highest powers as seconds', () => {\n  expect(formatTime(42, 3)).toBe('42 s');\n});\n\nit('interprets non-multiple-of-3 powers as next higher prefix', () => {\n  expect(formatTime(42, -4)).toBe('42 ms');\n});\n\nit('formats the quantity properly when pad length is lower', () => {\n  expect(formatTime(42, -3, 1)).toBe('42 ms');\n});\n\nit('formats the quantity properly when pad length is equal', () => {\n  expect(formatTime(42, -3, 2)).toBe('42 ms');\n});\n\nit('left pads the quantity properly when pad length is higher', () => {\n  expect(formatTime(42, -3, 5)).toBe('   42 ms');\n});\n",
  "packages/jest-util/src/__tests__/formatTime.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-util/src/__tests__/errorWithStack.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport ErrorWithStack from '../ErrorWithStack';\n\ndescribe('ErrorWithStack', () => {\n  const message = '💩 something went wrong';\n  const callsite = () => {};\n\n  it('calls Error.captureStackTrace with given callsite when capture exists', () => {\n    jest.spyOn(Error, 'captureStackTrace');\n\n    const actual = new ErrorWithStack(message, callsite);\n\n    expect(actual).toBeInstanceOf(Error);\n    expect(actual.message).toBe(message);\n    expect(Error.captureStackTrace).toHaveBeenCalledWith(actual, callsite);\n  });\n});\n",
  "packages/jest-util/src/__tests__/errorWithStack.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-util/src/__tests__/deepCyclicCopy.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport deepCyclicCopy from '../deepCyclicCopy';\n\nit('returns the same value for primitive or function values', () => {\n  const fn = () => {};\n\n  expect(deepCyclicCopy(undefined)).toBeUndefined();\n  expect(deepCyclicCopy(null)).toBeNull();\n  expect(deepCyclicCopy(true)).toBe(true);\n  expect(deepCyclicCopy(42)).toBe(42);\n  expect(Number.isNaN(deepCyclicCopy(Number.NaN))).toBe(true);\n  expect(deepCyclicCopy('foo')).toBe('foo');\n  expect(deepCyclicCopy(fn)).toBe(fn);\n});\n\nit('does not execute getters/setters, but copies them', () => {\n  const fn = jest.fn();\n  const obj = {\n    get foo() {\n      fn();\n      return;\n    },\n  };\n  const copy = deepCyclicCopy(obj);\n\n  expect(Object.getOwnPropertyDescriptor(copy, 'foo')).toBeDefined();\n  expect(fn).not.toHaveBeenCalled();\n});\n\nit('copies symbols', () => {\n  const symbol = Symbol('foo');\n  const obj = {[symbol]: 42};\n\n  expect(deepCyclicCopy(obj)[symbol]).toBe(42);\n});\n\nit('copies arrays as array objects', () => {\n  const array = [null, 42, 'foo', 'bar', [], {}];\n\n  expect(deepCyclicCopy(array)).toEqual(array);\n  expect(Array.isArray(deepCyclicCopy(array))).toBe(true);\n});\n\nit('handles cyclic dependencies', () => {\n  type Cyclic = {[key: string]: unknown | Cyclic} & {subcycle?: Cyclic};\n\n  const cyclic: Cyclic = {a: 42};\n\n  cyclic.subcycle = {};\n  cyclic.subcycle.baz = cyclic;\n  cyclic.bar = cyclic;\n\n  expect(() => deepCyclicCopy(cyclic)).not.toThrow();\n\n  const copy = deepCyclicCopy(cyclic);\n\n  expect(copy.a).toBe(42);\n  expect(copy.bar).toEqual(copy);\n  expect(copy.subcycle?.baz).toEqual(copy);\n});\n\nit('uses the blacklist to avoid copying properties on the first level', () => {\n  const obj = {\n    blacklisted: 41,\n    blacklisted2: 42,\n    subObj: {\n      blacklisted: 43,\n    },\n  };\n\n  expect(\n    deepCyclicCopy(obj, {\n      blacklist: new Set(['blacklisted', 'blacklisted2']),\n    }),\n  ).toEqual({\n    subObj: {\n      blacklisted: 43,\n    },\n  });\n});\n\nit('does not keep the prototype by default when top level is object', () => {\n  // @ts-expect-error: Testing purpose\n  const sourceObject = new (function () {})();\n  // @ts-expect-error: Testing purpose\n  sourceObject.nestedObject = new (function () {})();\n  // @ts-expect-error: Testing purpose\n  sourceObject.nestedArray = new (function () {\n    // @ts-expect-error: Testing purpose\n    this.length = 0;\n  })();\n\n  const spyArray = jest\n    .spyOn(Array, 'isArray')\n    .mockImplementation(object => object === sourceObject.nestedArray);\n\n  const copy = deepCyclicCopy(sourceObject, {keepPrototype: false});\n\n  expect(Object.getPrototypeOf(copy)).not.toBe(\n    Object.getPrototypeOf(sourceObject),\n  );\n  expect(Object.getPrototypeOf(copy.nestedObject)).not.toBe(\n    Object.getPrototypeOf(sourceObject.nestedObject),\n  );\n  expect(Object.getPrototypeOf(copy.nestedArray)).not.toBe(\n    Object.getPrototypeOf(sourceObject.nestedArray),\n  );\n\n  expect(Object.getPrototypeOf(copy)).toBe(Object.getPrototypeOf({}));\n  expect(Object.getPrototypeOf(copy.nestedObject)).toBe(\n    Object.getPrototypeOf({}),\n  );\n  expect(Object.getPrototypeOf(copy.nestedArray)).toBe(\n    Object.getPrototypeOf([]),\n  );\n\n  spyArray.mockRestore();\n});\n\nit('does not keep the prototype by default when top level is array', () => {\n  const spyArray = jest.spyOn(Array, 'isArray').mockImplementation(() => true);\n\n  // @ts-expect-error: Testing purpose\n  const sourceArray = new (function () {\n    // @ts-expect-error: Testing purpose\n    this.length = 0;\n  })();\n\n  const copy = deepCyclicCopy(sourceArray);\n  expect(Object.getPrototypeOf(copy)).not.toBe(\n    Object.getPrototypeOf(sourceArray),\n  );\n\n  expect(Object.getPrototypeOf(copy)).toBe(Object.getPrototypeOf([]));\n  spyArray.mockRestore();\n});\n\nit('does not keep the prototype of arrays when keepPrototype = false', () => {\n  const spyArray = jest.spyOn(Array, 'isArray').mockImplementation(() => true);\n\n  // @ts-expect-error: Testing purpose\n  const sourceArray = new (function () {\n    // @ts-expect-error: Testing purpose\n    this.length = 0;\n  })();\n\n  const copy = deepCyclicCopy(sourceArray, {keepPrototype: false});\n  expect(Object.getPrototypeOf(copy)).not.toBe(\n    Object.getPrototypeOf(sourceArray),\n  );\n\n  expect(Object.getPrototypeOf(copy)).toBe(Object.getPrototypeOf([]));\n  spyArray.mockRestore();\n});\n\nit('keeps the prototype of arrays when keepPrototype = true', () => {\n  const spyArray = jest.spyOn(Array, 'isArray').mockImplementation(() => true);\n\n  // @ts-expect-error: Testing purpose\n  const sourceArray = new (function () {\n    // @ts-expect-error: Testing purpose\n    this.length = 0;\n  })();\n\n  const copy = deepCyclicCopy(sourceArray, {keepPrototype: true});\n  expect(Object.getPrototypeOf(copy)).toBe(Object.getPrototypeOf(sourceArray));\n\n  spyArray.mockRestore();\n});\n\nit('does not keep the prototype for objects when keepPrototype = false', () => {\n  // @ts-expect-error: Testing purpose\n  const sourceObject = new (function () {})();\n  // @ts-expect-error\n  sourceObject.nestedObject = new (function () {})();\n  // @ts-expect-error: Testing purpose\n  sourceObject.nestedArray = new (function () {\n    // @ts-expect-error: Testing purpose\n    this.length = 0;\n  })();\n\n  const spyArray = jest\n    .spyOn(Array, 'isArray')\n    .mockImplementation(object => object === sourceObject.nestedArray);\n\n  const copy = deepCyclicCopy(sourceObject, {keepPrototype: false});\n\n  expect(Object.getPrototypeOf(copy)).not.toBe(\n    Object.getPrototypeOf(sourceObject),\n  );\n  expect(Object.getPrototypeOf(copy.nestedObject)).not.toBe(\n    Object.getPrototypeOf(sourceObject.nestedObject),\n  );\n  expect(Object.getPrototypeOf(copy.nestedArray)).not.toBe(\n    Object.getPrototypeOf(sourceObject.nestedArray),\n  );\n  expect(Object.getPrototypeOf(copy)).toBe(Object.getPrototypeOf({}));\n  expect(Object.getPrototypeOf(copy.nestedObject)).toBe(\n    Object.getPrototypeOf({}),\n  );\n  expect(Object.getPrototypeOf(copy.nestedArray)).toBe(\n    Object.getPrototypeOf([]),\n  );\n\n  spyArray.mockRestore();\n});\n\nit('keeps the prototype for objects when keepPrototype = true', () => {\n  // @ts-expect-error: Testing purpose\n  const sourceObject = new (function () {})();\n  // @ts-expect-error: Testing purpose\n  sourceObject.nestedObject = new (function () {})();\n  // @ts-expect-error: Testing purpose\n  sourceObject.nestedArray = new (function () {\n    // @ts-expect-error: Testing purpose\n    this.length = 0;\n  })();\n\n  const spyArray = jest\n    .spyOn(Array, 'isArray')\n    .mockImplementation(object => object === sourceObject.nestedArray);\n\n  const copy = deepCyclicCopy(sourceObject, {keepPrototype: true});\n\n  expect(Object.getPrototypeOf(copy)).toBe(Object.getPrototypeOf(sourceObject));\n  expect(Object.getPrototypeOf(copy.nestedObject)).toBe(\n    Object.getPrototypeOf(sourceObject.nestedObject),\n  );\n  expect(Object.getPrototypeOf(copy.nestedArray)).toBe(\n    Object.getPrototypeOf(sourceObject.nestedArray),\n  );\n  spyArray.mockRestore();\n});\n",
  "packages/jest-util/src/__tests__/deepCyclicCopy.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport {};\n",
  "packages/jest-util/src/__tests__/createProcessObject.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {EventEmitter} from 'events';\n\nlet createProcessObject: typeof import('../createProcessObject').default;\n\nfunction requireCreateProcessObject() {\n  jest.isolateModules(() => {\n    createProcessObject = (\n      require('../createProcessObject') as typeof import('../createProcessObject')\n    ).default;\n  });\n}\n\nit('creates a process object that looks like the original one', () => {\n  requireCreateProcessObject();\n  const fakeProcess = createProcessObject();\n\n  // \"process\" inherits from EventEmitter through the prototype chain.\n  expect(fakeProcess instanceof EventEmitter).toBe(true);\n\n  // They look the same, but they are NOT the same (deep copied object).\n  // The `_events` property is checked to ensure event emitter properties are\n  // properly copied.\n  for (const key of ['argv', 'env', '_events'] as const) {\n    // @ts-expect-error: Testing internal `_events` property\n    expect(fakeProcess[key]).toEqual(process[key]);\n    // @ts-expect-error: Testing internal `_events` property\n    expect(fakeProcess[key]).not.toBe(process[key]);\n  }\n\n  // Check that process.stdout/stderr are the same.\n  expect(process.stdout).toBe(fakeProcess.stdout);\n  expect(process.stderr).toBe(fakeProcess.stderr);\n});\n\nit('fakes require(\"process\") so it is equal to \"global.process\"', () => {\n  expect(require('process') === process).toBe(true);\n});\n\nit('checks that process.env works as expected on Linux platforms', () => {\n  Object.defineProperty(process, 'platform', {get: () => 'linux'});\n  requireCreateProcessObject();\n\n  // Existing properties inside process.env are copied to the fake environment.\n  process.env.PROP_STRING = 'foo';\n  // @ts-expect-error: Type 'number' is not assignable to type 'string'.\n  process.env.PROP_NUMBER = 3;\n  process.env.PROP_UNDEFINED = undefined;\n\n  const fake = createProcessObject().env;\n\n  // All values converted to strings.\n  expect(fake.PROP_STRING).toBe('foo');\n  expect(fake.PROP_NUMBER).toBe('3');\n  expect(fake.PROP_UNDEFINED).toBe('undefined');\n\n  // Mac and Linux are case sensitive.\n  expect(fake.PROP_string).toBeUndefined();\n\n  // Added properties to the fake object are not added to the real one.\n  fake.PROP_ADDED = 'new!';\n\n  expect(fake.PROP_ADDED).toBe('new!');\n  expect(process.env.PROP_ADDED).toBeUndefined();\n\n  // You can delete properties, but they are case sensitive!\n  fake.prop = 'foo';\n  fake.PROP = 'bar';\n\n  expect(fake.prop).toBe('foo');\n  expect(fake.PROP).toBe('bar');\n\n  delete fake.PROP;\n\n  expect(fake.prop).toBe('foo');\n  expect(fake.PROP).toBeUndefined();\n});\n\nit('checks that process.env works as expected in Windows platforms', () => {\n  Object.defineProperty(process, 'platform', {get: () => 'win32'});\n  requireCreateProcessObject();\n\n  // Windows is not case sensitive when it comes to property names.\n  process.env.PROP_STRING = 'foo';\n\n  const fake = createProcessObject().env;\n\n  expect(fake.PROP_STRING).toBe('foo');\n  expect(fake.PROP_string).toBe('foo');\n\n  // Inherited methods, however, are not affected by case insensitiveness.\n  expect(typeof fake.toString).toBe('function');\n  expect(typeof fake.valueOf).toBe('function');\n\n  expect(typeof fake.tostring).toBe('undefined');\n  expect(typeof fake.valueof).toBe('undefined');\n\n  // You can delete through case-insensitiveness too.\n  delete fake.prop_string;\n\n  expect(Object.prototype.hasOwnProperty.call(fake, 'PROP_string')).toBe(false);\n  expect(Object.prototype.hasOwnProperty.call(fake, 'PROP_string')).toBe(false);\n});\n",
  "packages/jest-util/src/__tests__/createProcessObject.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-util/src/__tests__/convertDescriptorToString.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport convertDescriptorToString from '../convertDescriptorToString';\n\ndescribe(convertDescriptorToString, () => {\n  test.each([\n    [undefined, 'undefined'],\n    ['name', 'name'],\n    [123, '123'],\n    [function named() {}, 'named'],\n    [class Named {}, 'Named'],\n  ])('%p', (input, output) => {\n    expect(convertDescriptorToString(input)).toBe(output);\n  });\n\n  test.each([\n    ['null', null],\n    ['array', ['abc']],\n    ['object', {abc: 'def'}],\n    ['anonymous function expression', function () {}],\n    ['anonymous arrow function', () => {}],\n    ['anonymous class expression', class {}],\n  ])('%s', (_, input) => {\n    expect(() => {\n      // @ts-expect-error: Testing runtime error\n      return convertDescriptorToString(input);\n    }).toThrow(\n      `Invalid first argument, ${String(\n        input,\n      )}. It must be a named class, named function, number, or string.`,\n    );\n  });\n});\n",
  "packages/jest-util/src/__tests__/convertDescriptorToString.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-types/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type * as Circus from './Circus';\nimport type * as Config from './Config';\nimport type * as Global from './Global';\nimport type * as TestResult from './TestResult';\nimport type * as TransformTypes from './Transform';\n\nexport type {Circus, Config, Global, TestResult, TransformTypes};\n",
  "packages/jest-types/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type * as Circus from './Circus';\nimport type * as Config from './Config';\nimport type * as Global from './Global';\nimport type * as TestResult from './TestResult';\nimport type * as TransformTypes from './Transform';\nexport type { Circus, Config, Global, TestResult, TransformTypes };\n",
  "packages/jest-types/src/Transform.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// this is here to make it possible to avoid huge dependency trees just for types\nexport type TransformResult = {\n  code: string;\n  originalCode: string;\n  sourceMapPath: string | null;\n};\n",
  "packages/jest-types/src/Transform.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport type TransformResult = {\n    code: string;\n    originalCode: string;\n    sourceMapPath: string | null;\n};\n",
  "packages/jest-types/src/TestResult.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ntype Status =\n  | 'passed'\n  | 'failed'\n  | 'skipped'\n  | 'pending'\n  | 'todo'\n  | 'disabled'\n  | 'focused';\n\ntype Callsite = {\n  column: number;\n  line: number;\n};\n\n// this is here to make it possible to avoid huge dependency trees just for types\nexport type AssertionResult = {\n  ancestorTitles: Array<string>;\n  duration?: number | null;\n  startAt?: number | null;\n  /**\n   * Whether [`test.failing()`](https://jestjs.io/docs/api#testfailingname-fn-timeout)\n   * was used.\n   */\n  failing?: boolean;\n  /**\n   * The raw values of the `function` or `symbol` types will be lost in some cases\n   * because it's not possible to serialize them correctly between workers.\n   * However, information about them will be available in the `failureMessages`.\n   */\n  failureDetails: Array<unknown>;\n  failureMessages: Array<string>;\n  fullName: string;\n  invocations?: number;\n  location?: Callsite | null;\n  numPassingAsserts: number;\n  retryReasons?: Array<string>;\n  status: Status;\n  title: string;\n};\n\nexport type SerializableError = {\n  code?: unknown;\n  message: string;\n  stack: string | null | undefined;\n  type?: string;\n};\n",
  "packages/jest-types/src/TestResult.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\ntype Status = 'passed' | 'failed' | 'skipped' | 'pending' | 'todo' | 'disabled' | 'focused';\ntype Callsite = {\n    column: number;\n    line: number;\n};\nexport type AssertionResult = {\n    ancestorTitles: Array<string>;\n    duration?: number | null;\n    startAt?: number | null;\n    /**\n     * Whether [`test.failing()`](https://jestjs.io/docs/api#testfailingname-fn-timeout)\n     * was used.\n     */\n    failing?: boolean;\n    /**\n     * The raw values of the `function` or `symbol` types will be lost in some cases\n     * because it's not possible to serialize them correctly between workers.\n     * However, information about them will be available in the `failureMessages`.\n     */\n    failureDetails: Array<unknown>;\n    failureMessages: Array<string>;\n    fullName: string;\n    invocations?: number;\n    location?: Callsite | null;\n    numPassingAsserts: number;\n    retryReasons?: Array<string>;\n    status: Status;\n    title: string;\n};\nexport type SerializableError = {\n    code?: unknown;\n    message: string;\n    stack: string | null | undefined;\n    type?: string;\n};\nexport {};\n",
  "packages/jest-types/src/Global.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {CoverageMapData} from 'istanbul-lib-coverage';\n\nexport type ValidTestReturnValues = void | undefined;\ntype TestReturnValuePromise = Promise<unknown>;\ntype TestReturnValueGenerator = Generator<void, unknown, void>;\nexport type TestReturnValue = ValidTestReturnValues | TestReturnValuePromise;\n\nexport type TestContext = Record<string, unknown>;\n\nexport type DoneFn = (reason?: string | Error) => void;\n\nexport type DoneTakingTestFn = (\n  this: TestContext,\n  done: DoneFn,\n) => ValidTestReturnValues;\nexport type PromiseReturningTestFn = (this: TestContext) => TestReturnValue;\nexport type GeneratorReturningTestFn = (\n  this: TestContext,\n) => TestReturnValueGenerator;\n\nexport type NameLike = number | Function;\n\nexport type TestName = string;\nexport type TestNameLike = TestName | NameLike;\nexport type TestFn =\n  | PromiseReturningTestFn\n  | GeneratorReturningTestFn\n  | DoneTakingTestFn;\nexport type ConcurrentTestFn = () => TestReturnValuePromise;\nexport type BlockFn = () => void;\nexport type BlockName = string;\nexport type BlockNameLike = BlockName | NameLike;\n\nexport type HookFn = TestFn;\n\nexport type Col = unknown;\nexport type Row = ReadonlyArray<Col>;\nexport type Table = ReadonlyArray<Row>;\nexport type ArrayTable = Table | Row;\nexport type TemplateTable = TemplateStringsArray;\nexport type TemplateData = ReadonlyArray<unknown>;\nexport type EachTable = ArrayTable | TemplateTable;\n\nexport type TestCallback = BlockFn | TestFn | ConcurrentTestFn;\n\nexport type EachTestFn<EachCallback extends TestCallback> = (\n  ...args: ReadonlyArray<any>\n) => ReturnType<EachCallback>;\n\ninterface Each<EachFn extends TestFn | BlockFn> {\n  // when the table is an array of object literals\n  <T extends Record<string, unknown>>(\n    table: ReadonlyArray<T>,\n  ): (\n    name: string | NameLike,\n    fn: (arg: T, done: DoneFn) => ReturnType<EachFn>,\n    timeout?: number,\n  ) => void;\n\n  // when the table is an array of tuples\n  <T extends readonly [unknown, ...Array<unknown>]>(\n    table: ReadonlyArray<T>,\n  ): (\n    name: string | NameLike,\n    fn: (...args: [...T]) => ReturnType<EachFn>,\n    timeout?: number,\n  ) => void;\n\n  // when the table is an array of arrays\n  <T extends ReadonlyArray<unknown>>(\n    table: ReadonlyArray<T>,\n  ): (\n    name: string | NameLike,\n    fn: (...args: T) => ReturnType<EachFn>,\n    timeout?: number,\n  ) => void;\n\n  // when the table is a tuple or array\n  <T>(\n    table: ReadonlyArray<T>,\n  ): (\n    name: string | NameLike,\n    fn: (arg: T, done: DoneFn) => ReturnType<EachFn>,\n    timeout?: number,\n  ) => void;\n\n  // when the table is a template literal\n  <T extends Array<unknown>>(\n    strings: TemplateStringsArray,\n    ...expressions: T\n  ): (\n    name: string | NameLike,\n    fn: (arg: Record<string, T[number]>, done: DoneFn) => ReturnType<EachFn>,\n    timeout?: number,\n  ) => void;\n\n  // when the table is a template literal with a type argument\n  <T extends Record<string, unknown>>(\n    strings: TemplateStringsArray,\n    ...expressions: Array<unknown>\n  ): (\n    name: string | NameLike,\n    fn: (arg: T, done: DoneFn) => ReturnType<EachFn>,\n    timeout?: number,\n  ) => void;\n}\n\nexport type HookBase = (fn: HookFn, timeout?: number) => void;\n\nexport interface Failing<T extends TestFn> {\n  (testName: TestNameLike, fn: T, timeout?: number): void;\n  each: Each<T>;\n}\n\nexport interface ItBase {\n  (testName: TestNameLike, fn: TestFn, timeout?: number): void;\n  each: Each<TestFn>;\n  failing: Failing<TestFn>;\n}\n\nexport interface It extends ItBase {\n  only: ItBase;\n  skip: ItBase;\n  todo: (testName: TestNameLike) => void;\n}\n\nexport interface ItConcurrentBase {\n  (testName: TestNameLike, testFn: ConcurrentTestFn, timeout?: number): void;\n  each: Each<ConcurrentTestFn>;\n  failing: Failing<ConcurrentTestFn>;\n}\n\nexport interface ItConcurrentExtended extends ItConcurrentBase {\n  only: ItConcurrentBase;\n  skip: ItConcurrentBase;\n}\n\nexport interface ItConcurrent extends It {\n  concurrent: ItConcurrentExtended;\n}\n\nexport interface DescribeBase {\n  (blockName: BlockNameLike, blockFn: BlockFn): void;\n  each: Each<BlockFn>;\n}\n\nexport interface Describe extends DescribeBase {\n  only: DescribeBase;\n  skip: DescribeBase;\n}\n\nexport interface TestFrameworkGlobals {\n  it: ItConcurrent;\n  test: ItConcurrent;\n  fit: ItBase & {concurrent?: ItConcurrentBase};\n  xit: ItBase;\n  xtest: ItBase;\n  describe: Describe;\n  xdescribe: DescribeBase;\n  fdescribe: DescribeBase;\n  beforeAll: HookBase;\n  beforeEach: HookBase;\n  afterEach: HookBase;\n  afterAll: HookBase;\n}\n\nexport interface GlobalAdditions extends TestFrameworkGlobals {\n  __coverage__: CoverageMapData;\n}\n\nexport interface Global\n  extends GlobalAdditions,\n    Omit<typeof globalThis, keyof GlobalAdditions> {\n  [extras: PropertyKey]: unknown;\n}\n",
  "packages/jest-types/src/Global.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { CoverageMapData } from 'istanbul-lib-coverage';\nexport type ValidTestReturnValues = void | undefined;\ntype TestReturnValuePromise = Promise<unknown>;\ntype TestReturnValueGenerator = Generator<void, unknown, void>;\nexport type TestReturnValue = ValidTestReturnValues | TestReturnValuePromise;\nexport type TestContext = Record<string, unknown>;\nexport type DoneFn = (reason?: string | Error) => void;\nexport type DoneTakingTestFn = (this: TestContext, done: DoneFn) => ValidTestReturnValues;\nexport type PromiseReturningTestFn = (this: TestContext) => TestReturnValue;\nexport type GeneratorReturningTestFn = (this: TestContext) => TestReturnValueGenerator;\nexport type NameLike = number | Function;\nexport type TestName = string;\nexport type TestNameLike = TestName | NameLike;\nexport type TestFn = PromiseReturningTestFn | GeneratorReturningTestFn | DoneTakingTestFn;\nexport type ConcurrentTestFn = () => TestReturnValuePromise;\nexport type BlockFn = () => void;\nexport type BlockName = string;\nexport type BlockNameLike = BlockName | NameLike;\nexport type HookFn = TestFn;\nexport type Col = unknown;\nexport type Row = ReadonlyArray<Col>;\nexport type Table = ReadonlyArray<Row>;\nexport type ArrayTable = Table | Row;\nexport type TemplateTable = TemplateStringsArray;\nexport type TemplateData = ReadonlyArray<unknown>;\nexport type EachTable = ArrayTable | TemplateTable;\nexport type TestCallback = BlockFn | TestFn | ConcurrentTestFn;\nexport type EachTestFn<EachCallback extends TestCallback> = (...args: ReadonlyArray<any>) => ReturnType<EachCallback>;\ninterface Each<EachFn extends TestFn | BlockFn> {\n    <T extends Record<string, unknown>>(table: ReadonlyArray<T>): (name: string | NameLike, fn: (arg: T, done: DoneFn) => ReturnType<EachFn>, timeout?: number) => void;\n    <T extends readonly [unknown, ...Array<unknown>]>(table: ReadonlyArray<T>): (name: string | NameLike, fn: (...args: [...T]) => ReturnType<EachFn>, timeout?: number) => void;\n    <T extends ReadonlyArray<unknown>>(table: ReadonlyArray<T>): (name: string | NameLike, fn: (...args: T) => ReturnType<EachFn>, timeout?: number) => void;\n    <T>(table: ReadonlyArray<T>): (name: string | NameLike, fn: (arg: T, done: DoneFn) => ReturnType<EachFn>, timeout?: number) => void;\n    <T extends Array<unknown>>(strings: TemplateStringsArray, ...expressions: T): (name: string | NameLike, fn: (arg: Record<string, T[number]>, done: DoneFn) => ReturnType<EachFn>, timeout?: number) => void;\n    <T extends Record<string, unknown>>(strings: TemplateStringsArray, ...expressions: Array<unknown>): (name: string | NameLike, fn: (arg: T, done: DoneFn) => ReturnType<EachFn>, timeout?: number) => void;\n}\nexport type HookBase = (fn: HookFn, timeout?: number) => void;\nexport interface Failing<T extends TestFn> {\n    (testName: TestNameLike, fn: T, timeout?: number): void;\n    each: Each<T>;\n}\nexport interface ItBase {\n    (testName: TestNameLike, fn: TestFn, timeout?: number): void;\n    each: Each<TestFn>;\n    failing: Failing<TestFn>;\n}\nexport interface It extends ItBase {\n    only: ItBase;\n    skip: ItBase;\n    todo: (testName: TestNameLike) => void;\n}\nexport interface ItConcurrentBase {\n    (testName: TestNameLike, testFn: ConcurrentTestFn, timeout?: number): void;\n    each: Each<ConcurrentTestFn>;\n    failing: Failing<ConcurrentTestFn>;\n}\nexport interface ItConcurrentExtended extends ItConcurrentBase {\n    only: ItConcurrentBase;\n    skip: ItConcurrentBase;\n}\nexport interface ItConcurrent extends It {\n    concurrent: ItConcurrentExtended;\n}\nexport interface DescribeBase {\n    (blockName: BlockNameLike, blockFn: BlockFn): void;\n    each: Each<BlockFn>;\n}\nexport interface Describe extends DescribeBase {\n    only: DescribeBase;\n    skip: DescribeBase;\n}\nexport interface TestFrameworkGlobals {\n    it: ItConcurrent;\n    test: ItConcurrent;\n    fit: ItBase & {\n        concurrent?: ItConcurrentBase;\n    };\n    xit: ItBase;\n    xtest: ItBase;\n    describe: Describe;\n    xdescribe: DescribeBase;\n    fdescribe: DescribeBase;\n    beforeAll: HookBase;\n    beforeEach: HookBase;\n    afterEach: HookBase;\n    afterAll: HookBase;\n}\nexport interface GlobalAdditions extends TestFrameworkGlobals {\n    __coverage__: CoverageMapData;\n}\nexport interface Global extends GlobalAdditions, Omit<typeof globalThis, keyof GlobalAdditions> {\n    [extras: PropertyKey]: unknown;\n}\nexport {};\n",
  "packages/jest-types/src/Config.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {ForegroundColor} from 'chalk';\nimport type {ReportOptions} from 'istanbul-reports';\nimport type {Arguments} from 'yargs';\nimport type {TestPathPatterns} from '@jest/pattern';\nimport type {InitialOptions, SnapshotFormat} from '@jest/schemas';\n\nexport type {InitialOptions} from '@jest/schemas';\n\ntype CoverageProvider = 'babel' | 'v8';\n\nexport type FakeableAPI =\n  | 'Date'\n  | 'hrtime'\n  | 'nextTick'\n  | 'performance'\n  | 'queueMicrotask'\n  | 'requestAnimationFrame'\n  | 'cancelAnimationFrame'\n  | 'requestIdleCallback'\n  | 'cancelIdleCallback'\n  | 'setImmediate'\n  | 'clearImmediate'\n  | 'setInterval'\n  | 'clearInterval'\n  | 'setTimeout'\n  | 'clearTimeout';\n\nexport type GlobalFakeTimersConfig = {\n  /**\n   * Whether fake timers should be enabled globally for all test files.\n   *\n   * @defaultValue\n   * The default is `false`.\n   */\n  enableGlobally?: boolean;\n};\n\nexport type FakeTimersConfig = {\n  /**\n   * If set to `true` all timers will be advanced automatically\n   * by 20 milliseconds every 20 milliseconds. A custom time delta\n   * may be provided by passing a number.\n   *\n   * @defaultValue\n   * The default is `false`.\n   */\n  advanceTimers?: boolean | number;\n  /**\n   * List of names of APIs (e.g. `Date`, `nextTick()`, `setImmediate()`,\n   * `setTimeout()`) that should not be faked.\n   *\n   * @defaultValue\n   * The default is `[]`, meaning all APIs are faked.\n   */\n  doNotFake?: Array<FakeableAPI>;\n  /**\n   * Sets current system time to be used by fake timers, in milliseconds.\n   *\n   * @defaultValue\n   * The default is `Date.now()`.\n   */\n  now?: number | Date;\n  /**\n   * The maximum number of recursive timers that will be run when calling\n   * `jest.runAllTimers()`.\n   *\n   * @defaultValue\n   * The default is `100_000` timers.\n   */\n  timerLimit?: number;\n  /**\n   * Use the old fake timers implementation instead of one backed by\n   * [`@sinonjs/fake-timers`](https://github.com/sinonjs/fake-timers).\n   *\n   * @defaultValue\n   * The default is `false`.\n   */\n  legacyFakeTimers?: false;\n};\n\nexport type LegacyFakeTimersConfig = {\n  /**\n   * Use the old fake timers implementation instead of one backed by\n   * [`@sinonjs/fake-timers`](https://github.com/sinonjs/fake-timers).\n   *\n   * @defaultValue\n   * The default is `false`.\n   */\n  legacyFakeTimers?: true;\n};\n\ntype FakeTimers = GlobalFakeTimersConfig &\n  (\n    | (FakeTimersConfig & {\n        now?: Exclude<FakeTimersConfig['now'], Date>;\n      })\n    | LegacyFakeTimersConfig\n  );\n\nexport type HasteConfig = {\n  /** Whether to hash files using SHA-1. */\n  computeSha1?: boolean;\n  /** The platform to use as the default, e.g. 'ios'. */\n  defaultPlatform?: string | null;\n  /** Force use of Node's `fs` APIs rather than shelling out to `find` */\n  forceNodeFilesystemAPI?: boolean;\n  /**\n   * Whether to follow symlinks when crawling for files.\n   *   This options cannot be used in projects which use watchman.\n   *   Projects with `watchman` set to true will error if this option is set to true.\n   */\n  enableSymlinks?: boolean;\n  /** string to a custom implementation of Haste. */\n  hasteImplModulePath?: string;\n  /** All platforms to target, e.g ['ios', 'android']. */\n  platforms?: Array<string>;\n  /** Whether to throw an error on module collision. */\n  throwOnModuleCollision?: boolean;\n  /** Custom HasteMap module */\n  hasteMapModulePath?: string;\n  /** Whether to retain all files, allowing e.g. search for tests in `node_modules`. */\n  retainAllFiles?: boolean;\n};\n\nexport type CoverageReporterName = keyof ReportOptions;\n\nexport type CoverageReporterWithOptions<K = CoverageReporterName> =\n  K extends CoverageReporterName\n    ? ReportOptions[K] extends never\n      ? never\n      : [K, Partial<ReportOptions[K]>]\n    : never;\n\nexport type CoverageReporters = Array<\n  CoverageReporterName | CoverageReporterWithOptions\n>;\n\nexport type ReporterConfig = [string, Record<string, unknown>];\nexport type TransformerConfig = [string, Record<string, unknown>];\n\nexport interface ConfigGlobals {\n  [K: string]: unknown;\n}\n\nexport type DefaultOptions = {\n  automock: boolean;\n  bail: number;\n  cache: boolean;\n  cacheDirectory: string;\n  changedFilesWithAncestor: boolean;\n  ci: boolean;\n  clearMocks: boolean;\n  collectCoverage: boolean;\n  coveragePathIgnorePatterns: Array<string>;\n  coverageReporters: Array<CoverageReporterName>;\n  coverageProvider: CoverageProvider;\n  detectLeaks: boolean;\n  detectOpenHandles: boolean;\n  errorOnDeprecated: boolean;\n  expand: boolean;\n  extensionsToTreatAsEsm: Array<string>;\n  fakeTimers: FakeTimers;\n  forceCoverageMatch: Array<string>;\n  globals: ConfigGlobals;\n  haste: HasteConfig;\n  injectGlobals: boolean;\n  listTests: boolean;\n  maxConcurrency: number;\n  maxWorkers: number | string;\n  moduleDirectories: Array<string>;\n  moduleFileExtensions: Array<string>;\n  moduleNameMapper: Record<string, string | Array<string>>;\n  modulePathIgnorePatterns: Array<string>;\n  noStackTrace: boolean;\n  notify: boolean;\n  notifyMode: NotifyMode;\n  openHandlesTimeout: number;\n  passWithNoTests: boolean;\n  prettierPath: string;\n  resetMocks: boolean;\n  resetModules: boolean;\n  restoreMocks: boolean;\n  roots: Array<string>;\n  runTestsByPath: boolean;\n  runner: string;\n  setupFiles: Array<string>;\n  setupFilesAfterEnv: Array<string>;\n  skipFilter: boolean;\n  slowTestThreshold: number;\n  snapshotFormat: SnapshotFormat;\n  snapshotSerializers: Array<string>;\n  testEnvironment: string;\n  testEnvironmentOptions: Record<string, unknown>;\n  testFailureExitCode: number;\n  testLocationInResults: boolean;\n  testMatch: Array<string>;\n  testPathIgnorePatterns: Array<string>;\n  testRegex: Array<string>;\n  testRunner: string;\n  testSequencer: string;\n  transformIgnorePatterns: Array<string>;\n  useStderr: boolean;\n  waitForUnhandledRejections: boolean;\n  watch: boolean;\n  watchPathIgnorePatterns: Array<string>;\n  watchman: boolean;\n  workerThreads: boolean;\n};\n\nexport type DisplayName = {\n  name: string;\n  color: typeof ForegroundColor;\n};\n\nexport type InitialOptionsWithRootDir = InitialOptions &\n  Required<Pick<InitialOptions, 'rootDir'>>;\n\nexport type InitialProjectOptions = Pick<\n  InitialOptions & {cwd?: string},\n  keyof ProjectConfig\n>;\n\nexport type SnapshotUpdateState = 'all' | 'new' | 'none';\n\ntype NotifyMode =\n  | 'always'\n  | 'failure'\n  | 'success'\n  | 'change'\n  | 'success-change'\n  | 'failure-change';\n\nexport type CoverageThresholdValue = {\n  branches?: number;\n  functions?: number;\n  lines?: number;\n  statements?: number;\n};\n\ntype CoverageThreshold = {\n  [path: string]: CoverageThresholdValue;\n  global: CoverageThresholdValue;\n};\n\ntype ShardConfig = {\n  shardIndex: number;\n  shardCount: number;\n};\n\nexport type GlobalConfig = {\n  bail: number;\n  changedSince?: string;\n  changedFilesWithAncestor: boolean;\n  ci: boolean;\n  collectCoverage: boolean;\n  collectCoverageFrom: Array<string>;\n  coverageDirectory: string;\n  coveragePathIgnorePatterns?: Array<string>;\n  coverageProvider: CoverageProvider;\n  coverageReporters: CoverageReporters;\n  coverageThreshold?: CoverageThreshold;\n  detectLeaks: boolean;\n  detectOpenHandles: boolean;\n  expand: boolean;\n  filter?: string;\n  findRelatedTests: boolean;\n  forceExit: boolean;\n  json: boolean;\n  globalSetup?: string;\n  globalTeardown?: string;\n  lastCommit: boolean;\n  logHeapUsage: boolean;\n  listTests: boolean;\n  maxConcurrency: number;\n  maxWorkers: number;\n  noStackTrace: boolean;\n  nonFlagArgs: Array<string>;\n  noSCM?: boolean;\n  notify: boolean;\n  notifyMode: NotifyMode;\n  outputFile?: string;\n  onlyChanged: boolean;\n  onlyFailures: boolean;\n  openHandlesTimeout: number;\n  passWithNoTests: boolean;\n  projects: Array<string>;\n  randomize?: boolean;\n  replname?: string;\n  reporters?: Array<ReporterConfig>;\n  runInBand: boolean;\n  runTestsByPath: boolean;\n  rootDir: string;\n  seed: number;\n  showSeed?: boolean;\n  shard?: ShardConfig;\n  silent?: boolean;\n  skipFilter: boolean;\n  snapshotFormat: SnapshotFormat;\n  errorOnDeprecated: boolean;\n  testFailureExitCode: number;\n  testNamePattern?: string;\n  testPathPatterns: TestPathPatterns;\n  testResultsProcessor?: string;\n  testSequencer: string;\n  testTimeout?: number;\n  updateSnapshot: SnapshotUpdateState;\n  useStderr: boolean;\n  verbose?: boolean;\n  waitForUnhandledRejections: boolean;\n  watch: boolean;\n  watchAll: boolean;\n  watchman: boolean;\n  watchPlugins?: Array<{\n    path: string;\n    config: Record<string, unknown>;\n  }> | null;\n  workerIdleMemoryLimit?: number;\n  // TODO: make non-optional in Jest 30\n  workerThreads?: boolean;\n};\n\nexport type ProjectConfig = {\n  automock: boolean;\n  cache: boolean;\n  cacheDirectory: string;\n  clearMocks: boolean;\n  collectCoverageFrom: Array<string>;\n  coverageDirectory: string;\n  coveragePathIgnorePatterns: Array<string>;\n  coverageReporters: CoverageReporters;\n  cwd: string;\n  dependencyExtractor?: string;\n  detectLeaks: boolean;\n  detectOpenHandles: boolean;\n  displayName?: DisplayName;\n  errorOnDeprecated: boolean;\n  extensionsToTreatAsEsm: Array<string>;\n  fakeTimers: FakeTimers;\n  filter?: string;\n  forceCoverageMatch: Array<string>;\n  globalSetup?: string;\n  globalTeardown?: string;\n  globals: ConfigGlobals;\n  haste: HasteConfig;\n  id: string;\n  injectGlobals: boolean;\n  moduleDirectories: Array<string>;\n  moduleFileExtensions: Array<string>;\n  moduleNameMapper: Array<[string, string]>;\n  modulePathIgnorePatterns: Array<string>;\n  modulePaths?: Array<string>;\n  openHandlesTimeout: number;\n  preset?: string;\n  prettierPath: string;\n  reporters: Array<string | ReporterConfig>;\n  resetMocks: boolean;\n  resetModules: boolean;\n  resolver?: string;\n  restoreMocks: boolean;\n  rootDir: string;\n  roots: Array<string>;\n  runner: string;\n  runtime?: string;\n  sandboxInjectedGlobals: Array<keyof typeof globalThis>;\n  setupFiles: Array<string>;\n  setupFilesAfterEnv: Array<string>;\n  skipFilter: boolean;\n  skipNodeResolution?: boolean;\n  slowTestThreshold: number;\n  snapshotResolver?: string;\n  snapshotSerializers: Array<string>;\n  snapshotFormat: SnapshotFormat;\n  testEnvironment: string;\n  testEnvironmentOptions: Record<string, unknown>;\n  testMatch: Array<string>;\n  testLocationInResults: boolean;\n  testPathIgnorePatterns: Array<string>;\n  testRegex: Array<string | RegExp>;\n  testRunner: string;\n  testTimeout: number;\n  transform: Array<[string, string, Record<string, unknown>]>;\n  transformIgnorePatterns: Array<string>;\n  watchPathIgnorePatterns: Array<string>;\n  unmockedModulePathPatterns?: Array<string>;\n  waitForUnhandledRejections: boolean;\n  workerIdleMemoryLimit?: number;\n};\n\nexport type SetupAfterEnvPerfStats = {\n  setupAfterEnvStart: number;\n  setupAfterEnvEnd: number;\n};\n\nexport type Argv = Arguments<\n  Partial<{\n    all: boolean;\n    automock: boolean;\n    bail: boolean | number;\n    cache: boolean;\n    cacheDirectory: string;\n    changedFilesWithAncestor: boolean;\n    changedSince: string;\n    ci: boolean;\n    clearCache: boolean;\n    clearMocks: boolean;\n    collectCoverage: boolean;\n    collectCoverageFrom: string;\n    color: boolean;\n    colors: boolean;\n    config: string;\n    coverage: boolean;\n    coverageDirectory: string;\n    coveragePathIgnorePatterns: Array<string>;\n    coverageReporters: Array<string>;\n    coverageThreshold: string;\n    debug: boolean;\n    env: string;\n    expand: boolean;\n    findRelatedTests: boolean;\n    forceExit: boolean;\n    globals: string;\n    globalSetup: string | null | undefined;\n    globalTeardown: string | null | undefined;\n    haste: string;\n    ignoreProjects: Array<string>;\n    injectGlobals: boolean;\n    json: boolean;\n    lastCommit: boolean;\n    logHeapUsage: boolean;\n    maxWorkers: number | string;\n    moduleDirectories: Array<string>;\n    moduleFileExtensions: Array<string>;\n    moduleNameMapper: string;\n    modulePathIgnorePatterns: Array<string>;\n    modulePaths: Array<string>;\n    noStackTrace: boolean;\n    notify: boolean;\n    notifyMode: string;\n    onlyChanged: boolean;\n    onlyFailures: boolean;\n    outputFile: string;\n    preset: string | null | undefined;\n    prettierPath: string | null | undefined;\n    projects: Array<string>;\n    randomize: boolean;\n    reporters: Array<string>;\n    resetMocks: boolean;\n    resetModules: boolean;\n    resolver: string | null | undefined;\n    restoreMocks: boolean;\n    rootDir: string;\n    roots: Array<string>;\n    runInBand: boolean;\n    seed: number;\n    showSeed: boolean;\n    selectProjects: Array<string>;\n    setupFiles: Array<string>;\n    setupFilesAfterEnv: Array<string>;\n    shard: string;\n    showConfig: boolean;\n    silent: boolean;\n    snapshotSerializers: Array<string>;\n    testEnvironment: string;\n    testEnvironmentOptions: string;\n    testFailureExitCode: string | null | undefined;\n    testMatch: string | Array<string>;\n    testNamePattern: string;\n    testPathIgnorePatterns: Array<string>;\n    testPathPatterns: Array<string>;\n    testRegex: string | Array<string>;\n    testResultsProcessor: string;\n    testRunner: string;\n    testSequencer: string;\n    testTimeout: number | null | undefined;\n    transform: string;\n    transformIgnorePatterns: Array<string>;\n    unmockedModulePathPatterns: Array<string> | null | undefined;\n    updateSnapshot: boolean;\n    useStderr: boolean;\n    verbose: boolean;\n    version: boolean;\n    watch: boolean;\n    watchAll: boolean;\n    watchman: boolean;\n    watchPathIgnorePatterns: Array<string>;\n    workerIdleMemoryLimit: number | string;\n    workerThreads: boolean;\n  }>\n>;\n",
  "packages/jest-types/src/Config.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { ForegroundColor } from 'chalk';\nimport type { ReportOptions } from 'istanbul-reports';\nimport type { Arguments } from 'yargs';\nimport type { TestPathPatterns } from '@jest/pattern';\nimport type { InitialOptions, SnapshotFormat } from '@jest/schemas';\nexport type { InitialOptions } from '@jest/schemas';\ntype CoverageProvider = 'babel' | 'v8';\nexport type FakeableAPI = 'Date' | 'hrtime' | 'nextTick' | 'performance' | 'queueMicrotask' | 'requestAnimationFrame' | 'cancelAnimationFrame' | 'requestIdleCallback' | 'cancelIdleCallback' | 'setImmediate' | 'clearImmediate' | 'setInterval' | 'clearInterval' | 'setTimeout' | 'clearTimeout';\nexport type GlobalFakeTimersConfig = {\n    /**\n     * Whether fake timers should be enabled globally for all test files.\n     *\n     * @defaultValue\n     * The default is `false`.\n     */\n    enableGlobally?: boolean;\n};\nexport type FakeTimersConfig = {\n    /**\n     * If set to `true` all timers will be advanced automatically\n     * by 20 milliseconds every 20 milliseconds. A custom time delta\n     * may be provided by passing a number.\n     *\n     * @defaultValue\n     * The default is `false`.\n     */\n    advanceTimers?: boolean | number;\n    /**\n     * List of names of APIs (e.g. `Date`, `nextTick()`, `setImmediate()`,\n     * `setTimeout()`) that should not be faked.\n     *\n     * @defaultValue\n     * The default is `[]`, meaning all APIs are faked.\n     */\n    doNotFake?: Array<FakeableAPI>;\n    /**\n     * Sets current system time to be used by fake timers, in milliseconds.\n     *\n     * @defaultValue\n     * The default is `Date.now()`.\n     */\n    now?: number | Date;\n    /**\n     * The maximum number of recursive timers that will be run when calling\n     * `jest.runAllTimers()`.\n     *\n     * @defaultValue\n     * The default is `100_000` timers.\n     */\n    timerLimit?: number;\n    /**\n     * Use the old fake timers implementation instead of one backed by\n     * [`@sinonjs/fake-timers`](https://github.com/sinonjs/fake-timers).\n     *\n     * @defaultValue\n     * The default is `false`.\n     */\n    legacyFakeTimers?: false;\n};\nexport type LegacyFakeTimersConfig = {\n    /**\n     * Use the old fake timers implementation instead of one backed by\n     * [`@sinonjs/fake-timers`](https://github.com/sinonjs/fake-timers).\n     *\n     * @defaultValue\n     * The default is `false`.\n     */\n    legacyFakeTimers?: true;\n};\ntype FakeTimers = GlobalFakeTimersConfig & ((FakeTimersConfig & {\n    now?: Exclude<FakeTimersConfig['now'], Date>;\n}) | LegacyFakeTimersConfig);\nexport type HasteConfig = {\n    /** Whether to hash files using SHA-1. */\n    computeSha1?: boolean;\n    /** The platform to use as the default, e.g. 'ios'. */\n    defaultPlatform?: string | null;\n    /** Force use of Node's `fs` APIs rather than shelling out to `find` */\n    forceNodeFilesystemAPI?: boolean;\n    /**\n     * Whether to follow symlinks when crawling for files.\n     *   This options cannot be used in projects which use watchman.\n     *   Projects with `watchman` set to true will error if this option is set to true.\n     */\n    enableSymlinks?: boolean;\n    /** string to a custom implementation of Haste. */\n    hasteImplModulePath?: string;\n    /** All platforms to target, e.g ['ios', 'android']. */\n    platforms?: Array<string>;\n    /** Whether to throw an error on module collision. */\n    throwOnModuleCollision?: boolean;\n    /** Custom HasteMap module */\n    hasteMapModulePath?: string;\n    /** Whether to retain all files, allowing e.g. search for tests in `node_modules`. */\n    retainAllFiles?: boolean;\n};\nexport type CoverageReporterName = keyof ReportOptions;\nexport type CoverageReporterWithOptions<K = CoverageReporterName> = K extends CoverageReporterName ? ReportOptions[K] extends never ? never : [K, Partial<ReportOptions[K]>] : never;\nexport type CoverageReporters = Array<CoverageReporterName | CoverageReporterWithOptions>;\nexport type ReporterConfig = [string, Record<string, unknown>];\nexport type TransformerConfig = [string, Record<string, unknown>];\nexport interface ConfigGlobals {\n    [K: string]: unknown;\n}\nexport type DefaultOptions = {\n    automock: boolean;\n    bail: number;\n    cache: boolean;\n    cacheDirectory: string;\n    changedFilesWithAncestor: boolean;\n    ci: boolean;\n    clearMocks: boolean;\n    collectCoverage: boolean;\n    coveragePathIgnorePatterns: Array<string>;\n    coverageReporters: Array<CoverageReporterName>;\n    coverageProvider: CoverageProvider;\n    detectLeaks: boolean;\n    detectOpenHandles: boolean;\n    errorOnDeprecated: boolean;\n    expand: boolean;\n    extensionsToTreatAsEsm: Array<string>;\n    fakeTimers: FakeTimers;\n    forceCoverageMatch: Array<string>;\n    globals: ConfigGlobals;\n    haste: HasteConfig;\n    injectGlobals: boolean;\n    listTests: boolean;\n    maxConcurrency: number;\n    maxWorkers: number | string;\n    moduleDirectories: Array<string>;\n    moduleFileExtensions: Array<string>;\n    moduleNameMapper: Record<string, string | Array<string>>;\n    modulePathIgnorePatterns: Array<string>;\n    noStackTrace: boolean;\n    notify: boolean;\n    notifyMode: NotifyMode;\n    openHandlesTimeout: number;\n    passWithNoTests: boolean;\n    prettierPath: string;\n    resetMocks: boolean;\n    resetModules: boolean;\n    restoreMocks: boolean;\n    roots: Array<string>;\n    runTestsByPath: boolean;\n    runner: string;\n    setupFiles: Array<string>;\n    setupFilesAfterEnv: Array<string>;\n    skipFilter: boolean;\n    slowTestThreshold: number;\n    snapshotFormat: SnapshotFormat;\n    snapshotSerializers: Array<string>;\n    testEnvironment: string;\n    testEnvironmentOptions: Record<string, unknown>;\n    testFailureExitCode: number;\n    testLocationInResults: boolean;\n    testMatch: Array<string>;\n    testPathIgnorePatterns: Array<string>;\n    testRegex: Array<string>;\n    testRunner: string;\n    testSequencer: string;\n    transformIgnorePatterns: Array<string>;\n    useStderr: boolean;\n    waitForUnhandledRejections: boolean;\n    watch: boolean;\n    watchPathIgnorePatterns: Array<string>;\n    watchman: boolean;\n    workerThreads: boolean;\n};\nexport type DisplayName = {\n    name: string;\n    color: typeof ForegroundColor;\n};\nexport type InitialOptionsWithRootDir = InitialOptions & Required<Pick<InitialOptions, 'rootDir'>>;\nexport type InitialProjectOptions = Pick<InitialOptions & {\n    cwd?: string;\n}, keyof ProjectConfig>;\nexport type SnapshotUpdateState = 'all' | 'new' | 'none';\ntype NotifyMode = 'always' | 'failure' | 'success' | 'change' | 'success-change' | 'failure-change';\nexport type CoverageThresholdValue = {\n    branches?: number;\n    functions?: number;\n    lines?: number;\n    statements?: number;\n};\ntype CoverageThreshold = {\n    [path: string]: CoverageThresholdValue;\n    global: CoverageThresholdValue;\n};\ntype ShardConfig = {\n    shardIndex: number;\n    shardCount: number;\n};\nexport type GlobalConfig = {\n    bail: number;\n    changedSince?: string;\n    changedFilesWithAncestor: boolean;\n    ci: boolean;\n    collectCoverage: boolean;\n    collectCoverageFrom: Array<string>;\n    coverageDirectory: string;\n    coveragePathIgnorePatterns?: Array<string>;\n    coverageProvider: CoverageProvider;\n    coverageReporters: CoverageReporters;\n    coverageThreshold?: CoverageThreshold;\n    detectLeaks: boolean;\n    detectOpenHandles: boolean;\n    expand: boolean;\n    filter?: string;\n    findRelatedTests: boolean;\n    forceExit: boolean;\n    json: boolean;\n    globalSetup?: string;\n    globalTeardown?: string;\n    lastCommit: boolean;\n    logHeapUsage: boolean;\n    listTests: boolean;\n    maxConcurrency: number;\n    maxWorkers: number;\n    noStackTrace: boolean;\n    nonFlagArgs: Array<string>;\n    noSCM?: boolean;\n    notify: boolean;\n    notifyMode: NotifyMode;\n    outputFile?: string;\n    onlyChanged: boolean;\n    onlyFailures: boolean;\n    openHandlesTimeout: number;\n    passWithNoTests: boolean;\n    projects: Array<string>;\n    randomize?: boolean;\n    replname?: string;\n    reporters?: Array<ReporterConfig>;\n    runInBand: boolean;\n    runTestsByPath: boolean;\n    rootDir: string;\n    seed: number;\n    showSeed?: boolean;\n    shard?: ShardConfig;\n    silent?: boolean;\n    skipFilter: boolean;\n    snapshotFormat: SnapshotFormat;\n    errorOnDeprecated: boolean;\n    testFailureExitCode: number;\n    testNamePattern?: string;\n    testPathPatterns: TestPathPatterns;\n    testResultsProcessor?: string;\n    testSequencer: string;\n    testTimeout?: number;\n    updateSnapshot: SnapshotUpdateState;\n    useStderr: boolean;\n    verbose?: boolean;\n    waitForUnhandledRejections: boolean;\n    watch: boolean;\n    watchAll: boolean;\n    watchman: boolean;\n    watchPlugins?: Array<{\n        path: string;\n        config: Record<string, unknown>;\n    }> | null;\n    workerIdleMemoryLimit?: number;\n    workerThreads?: boolean;\n};\nexport type ProjectConfig = {\n    automock: boolean;\n    cache: boolean;\n    cacheDirectory: string;\n    clearMocks: boolean;\n    collectCoverageFrom: Array<string>;\n    coverageDirectory: string;\n    coveragePathIgnorePatterns: Array<string>;\n    coverageReporters: CoverageReporters;\n    cwd: string;\n    dependencyExtractor?: string;\n    detectLeaks: boolean;\n    detectOpenHandles: boolean;\n    displayName?: DisplayName;\n    errorOnDeprecated: boolean;\n    extensionsToTreatAsEsm: Array<string>;\n    fakeTimers: FakeTimers;\n    filter?: string;\n    forceCoverageMatch: Array<string>;\n    globalSetup?: string;\n    globalTeardown?: string;\n    globals: ConfigGlobals;\n    haste: HasteConfig;\n    id: string;\n    injectGlobals: boolean;\n    moduleDirectories: Array<string>;\n    moduleFileExtensions: Array<string>;\n    moduleNameMapper: Array<[string, string]>;\n    modulePathIgnorePatterns: Array<string>;\n    modulePaths?: Array<string>;\n    openHandlesTimeout: number;\n    preset?: string;\n    prettierPath: string;\n    reporters: Array<string | ReporterConfig>;\n    resetMocks: boolean;\n    resetModules: boolean;\n    resolver?: string;\n    restoreMocks: boolean;\n    rootDir: string;\n    roots: Array<string>;\n    runner: string;\n    runtime?: string;\n    sandboxInjectedGlobals: Array<keyof typeof globalThis>;\n    setupFiles: Array<string>;\n    setupFilesAfterEnv: Array<string>;\n    skipFilter: boolean;\n    skipNodeResolution?: boolean;\n    slowTestThreshold: number;\n    snapshotResolver?: string;\n    snapshotSerializers: Array<string>;\n    snapshotFormat: SnapshotFormat;\n    testEnvironment: string;\n    testEnvironmentOptions: Record<string, unknown>;\n    testMatch: Array<string>;\n    testLocationInResults: boolean;\n    testPathIgnorePatterns: Array<string>;\n    testRegex: Array<string | RegExp>;\n    testRunner: string;\n    testTimeout: number;\n    transform: Array<[string, string, Record<string, unknown>]>;\n    transformIgnorePatterns: Array<string>;\n    watchPathIgnorePatterns: Array<string>;\n    unmockedModulePathPatterns?: Array<string>;\n    waitForUnhandledRejections: boolean;\n    workerIdleMemoryLimit?: number;\n};\nexport type SetupAfterEnvPerfStats = {\n    setupAfterEnvStart: number;\n    setupAfterEnvEnd: number;\n};\nexport type Argv = Arguments<Partial<{\n    all: boolean;\n    automock: boolean;\n    bail: boolean | number;\n    cache: boolean;\n    cacheDirectory: string;\n    changedFilesWithAncestor: boolean;\n    changedSince: string;\n    ci: boolean;\n    clearCache: boolean;\n    clearMocks: boolean;\n    collectCoverage: boolean;\n    collectCoverageFrom: string;\n    color: boolean;\n    colors: boolean;\n    config: string;\n    coverage: boolean;\n    coverageDirectory: string;\n    coveragePathIgnorePatterns: Array<string>;\n    coverageReporters: Array<string>;\n    coverageThreshold: string;\n    debug: boolean;\n    env: string;\n    expand: boolean;\n    findRelatedTests: boolean;\n    forceExit: boolean;\n    globals: string;\n    globalSetup: string | null | undefined;\n    globalTeardown: string | null | undefined;\n    haste: string;\n    ignoreProjects: Array<string>;\n    injectGlobals: boolean;\n    json: boolean;\n    lastCommit: boolean;\n    logHeapUsage: boolean;\n    maxWorkers: number | string;\n    moduleDirectories: Array<string>;\n    moduleFileExtensions: Array<string>;\n    moduleNameMapper: string;\n    modulePathIgnorePatterns: Array<string>;\n    modulePaths: Array<string>;\n    noStackTrace: boolean;\n    notify: boolean;\n    notifyMode: string;\n    onlyChanged: boolean;\n    onlyFailures: boolean;\n    outputFile: string;\n    preset: string | null | undefined;\n    prettierPath: string | null | undefined;\n    projects: Array<string>;\n    randomize: boolean;\n    reporters: Array<string>;\n    resetMocks: boolean;\n    resetModules: boolean;\n    resolver: string | null | undefined;\n    restoreMocks: boolean;\n    rootDir: string;\n    roots: Array<string>;\n    runInBand: boolean;\n    seed: number;\n    showSeed: boolean;\n    selectProjects: Array<string>;\n    setupFiles: Array<string>;\n    setupFilesAfterEnv: Array<string>;\n    shard: string;\n    showConfig: boolean;\n    silent: boolean;\n    snapshotSerializers: Array<string>;\n    testEnvironment: string;\n    testEnvironmentOptions: string;\n    testFailureExitCode: string | null | undefined;\n    testMatch: string | Array<string>;\n    testNamePattern: string;\n    testPathIgnorePatterns: Array<string>;\n    testPathPatterns: Array<string>;\n    testRegex: string | Array<string>;\n    testResultsProcessor: string;\n    testRunner: string;\n    testSequencer: string;\n    testTimeout: number | null | undefined;\n    transform: string;\n    transformIgnorePatterns: Array<string>;\n    unmockedModulePathPatterns: Array<string> | null | undefined;\n    updateSnapshot: boolean;\n    useStderr: boolean;\n    verbose: boolean;\n    version: boolean;\n    watch: boolean;\n    watchAll: boolean;\n    watchman: boolean;\n    watchPathIgnorePatterns: Array<string>;\n    workerIdleMemoryLimit: number | string;\n    workerThreads: boolean;\n}>>;\n",
  "packages/jest-types/src/Circus.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type * as ProcessModule from 'process';\nimport type * as Global from './Global';\n\ntype Process = typeof ProcessModule;\n\nexport type DoneFn = Global.DoneFn;\nexport type BlockFn = Global.BlockFn;\nexport type BlockName = Global.BlockName;\nexport type BlockNameLike = Global.BlockNameLike;\nexport type BlockMode = void | 'skip' | 'only' | 'todo';\nexport type TestMode = BlockMode;\nexport type TestName = Global.TestName;\nexport type TestNameLike = Global.TestNameLike;\nexport type TestFn = Global.TestFn;\nexport type ConcurrentTestFn = Global.ConcurrentTestFn;\nexport type HookFn = Global.HookFn;\nexport type AsyncFn = TestFn | HookFn;\nexport type SharedHookType = 'afterAll' | 'beforeAll';\nexport type HookType = SharedHookType | 'afterEach' | 'beforeEach';\nexport type TestContext = Global.TestContext;\nexport type Exception = any; // Since in JS anything can be thrown as an error.\nexport type FormattedError = string; // String representation of error.\nexport type Hook = {\n  asyncError: Error;\n  fn: HookFn;\n  type: HookType;\n  parent: DescribeBlock;\n  seenDone: boolean;\n  timeout: number | undefined | null;\n};\n\nexport interface EventHandler {\n  (event: AsyncEvent, state: State): void | Promise<void>;\n  (event: SyncEvent, state: State): void;\n}\n\nexport type Event = SyncEvent | AsyncEvent;\n\ninterface JestGlobals extends Global.TestFrameworkGlobals {\n  // we cannot type `expect` properly as it'd create circular dependencies\n  expect: unknown;\n}\n\nexport type SyncEvent =\n  | {\n      asyncError: Error;\n      mode: BlockMode;\n      name: 'start_describe_definition';\n      blockName: BlockName;\n    }\n  | {\n      mode: BlockMode;\n      name: 'finish_describe_definition';\n      blockName: BlockName;\n    }\n  | {\n      asyncError: Error;\n      name: 'add_hook';\n      hookType: HookType;\n      fn: HookFn;\n      timeout: number | undefined;\n    }\n  | {\n      asyncError: Error;\n      name: 'add_test';\n      testName: TestName;\n      fn: TestFn;\n      mode?: TestMode;\n      concurrent: boolean;\n      timeout: number | undefined;\n      failing: boolean;\n    }\n  | {\n      // Any unhandled error that happened outside of test/hooks (unless it is\n      // an `afterAll` hook)\n      name: 'error';\n      error: Exception;\n      promise?: Promise<unknown>;\n    }\n  | {\n      name: 'error_handled';\n      promise: Promise<unknown>;\n    };\n\nexport type AsyncEvent =\n  | {\n      // first action to dispatch. Good time to initialize all settings\n      name: 'setup';\n      testNamePattern?: string;\n      runtimeGlobals: JestGlobals;\n      parentProcess: Process;\n    }\n  | {\n      name: 'include_test_location_in_result';\n    }\n  | {\n      name: 'hook_start';\n      hook: Hook;\n    }\n  | {\n      name: 'hook_success';\n      describeBlock?: DescribeBlock;\n      test?: TestEntry;\n      hook: Hook;\n    }\n  | {\n      name: 'hook_failure';\n      error: string | Exception;\n      describeBlock?: DescribeBlock;\n      test?: TestEntry;\n      hook: Hook;\n    }\n  | {\n      name: 'test_fn_start';\n      test: TestEntry;\n    }\n  | {\n      name: 'test_fn_success';\n      test: TestEntry;\n    }\n  | {\n      name: 'test_fn_failure';\n      error: Exception;\n      test: TestEntry;\n    }\n  | {\n      name: 'test_retry';\n      test: TestEntry;\n    }\n  | {\n      // the `test` in this case is all hooks + it/test function, not just the\n      // function passed to `it/test`\n      name: 'test_start';\n      test: TestEntry;\n    }\n  | {\n      name: 'test_skip';\n      test: TestEntry;\n    }\n  | {\n      name: 'test_todo';\n      test: TestEntry;\n    }\n  | {\n      name: 'test_started';\n      test: TestEntry;\n    }\n  | {\n      // test failure is defined by presence of errors in `test.errors`,\n      // `test_done` indicates that the test and all its hooks were run,\n      // and nothing else will change it's state in the future. (except third\n      // party extensions/plugins)\n      name: 'test_done';\n      test: TestEntry;\n    }\n  | {\n      name: 'run_describe_start';\n      describeBlock: DescribeBlock;\n    }\n  | {\n      name: 'run_describe_finish';\n      describeBlock: DescribeBlock;\n    }\n  | {\n      name: 'run_start';\n    }\n  | {\n      name: 'run_finish';\n    }\n  | {\n      // Action dispatched after everything is finished and we're about to wrap\n      // things up and return test results to the parent process (caller).\n      name: 'teardown';\n    };\n\nexport type MatcherResults = {\n  actual: unknown;\n  expected: unknown;\n  name: string;\n  pass: boolean;\n};\n\nexport type TestStatus = 'skip' | 'done' | 'todo';\n\nexport type TestNamesPath = Array<TestName | BlockName>;\n\nexport type TestCaseStartInfo = {\n  ancestorTitles: Array<string>;\n  fullName: string;\n  mode: TestMode;\n  title: string;\n  startedAt?: number | null;\n};\n\nexport type TestResult = {\n  duration?: number | null;\n  errors: Array<FormattedError>;\n  errorsDetailed: Array<MatcherResults | unknown>;\n  /**\n   * Whether [`test.failing()`](https://jestjs.io/docs/api#testfailingname-fn-timeout)\n   * was used.\n   */\n  failing?: boolean;\n  invocations: number;\n  startedAt?: number | null;\n  status: TestStatus;\n  location?: {column: number; line: number} | null;\n  numPassingAsserts: number;\n  retryReasons: Array<FormattedError>;\n  testPath: TestNamesPath;\n};\n\nexport type RunResult = {\n  unhandledErrors: Array<FormattedError>;\n  testResults: TestResults;\n};\n\nexport type TestResults = Array<TestResult>;\n\nexport type GlobalErrorHandlers = {\n  rejectionHandled: Array<(promise: Promise<unknown>) => void>;\n  uncaughtException: Array<NodeJS.UncaughtExceptionListener>;\n  unhandledRejection: Array<NodeJS.UnhandledRejectionListener>;\n};\n\nexport type State = {\n  currentDescribeBlock: DescribeBlock;\n  currentlyRunningTest?: TestEntry | null; // including when hooks are being executed\n  expand?: boolean; // expand error messages\n  hasFocusedTests: boolean; // that are defined using test.only\n  hasStarted: boolean; // whether the rootDescribeBlock has started running\n  // Store process error handlers. During the run we inject our own\n  // handlers (so we could fail tests on unhandled errors) and later restore\n  // the original ones.\n  originalGlobalErrorHandlers?: GlobalErrorHandlers;\n  parentProcess: Process | null; // process object from the outer scope\n  randomize?: boolean;\n  rootDescribeBlock: DescribeBlock;\n  seed: number;\n  testNamePattern?: RegExp | null;\n  testTimeout: number;\n  unhandledErrors: Array<Exception>;\n  includeTestLocationInResult: boolean;\n  maxConcurrency: number;\n  unhandledRejectionErrorByPromise: Map<Promise<unknown>, Exception>;\n};\n\nexport type DescribeBlock = {\n  type: 'describeBlock';\n  children: Array<DescribeBlock | TestEntry>;\n  hooks: Array<Hook>;\n  mode: BlockMode;\n  name: BlockName;\n  parent?: DescribeBlock;\n  /** @deprecated Please get from `children` array instead */\n  tests: Array<TestEntry>;\n};\n\nexport type TestError = Exception | [Exception | undefined, Exception]; // the error from the test, as well as a backup error for async\n\nexport type TestEntry = {\n  type: 'test';\n  asyncError: Exception; // Used if the test failure contains no usable stack trace\n  errors: Array<TestError>;\n  retryReasons: Array<TestError>;\n  fn: TestFn;\n  invocations: number;\n  mode: TestMode;\n  concurrent: boolean;\n  name: TestName;\n  numPassingAsserts: number;\n  parent: DescribeBlock;\n  startedAt?: number | null;\n  duration?: number | null;\n  seenDone: boolean;\n  status?: TestStatus | null; // whether the test has been skipped or run already\n  timeout?: number;\n  failing: boolean;\n  unhandledRejectionErrorByPromise: Map<Promise<unknown>, Exception>;\n};\n",
  "packages/jest-types/src/Circus.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type * as ProcessModule from 'process';\nimport type * as Global from './Global';\ntype Process = typeof ProcessModule;\nexport type DoneFn = Global.DoneFn;\nexport type BlockFn = Global.BlockFn;\nexport type BlockName = Global.BlockName;\nexport type BlockNameLike = Global.BlockNameLike;\nexport type BlockMode = void | 'skip' | 'only' | 'todo';\nexport type TestMode = BlockMode;\nexport type TestName = Global.TestName;\nexport type TestNameLike = Global.TestNameLike;\nexport type TestFn = Global.TestFn;\nexport type ConcurrentTestFn = Global.ConcurrentTestFn;\nexport type HookFn = Global.HookFn;\nexport type AsyncFn = TestFn | HookFn;\nexport type SharedHookType = 'afterAll' | 'beforeAll';\nexport type HookType = SharedHookType | 'afterEach' | 'beforeEach';\nexport type TestContext = Global.TestContext;\nexport type Exception = any;\nexport type FormattedError = string;\nexport type Hook = {\n    asyncError: Error;\n    fn: HookFn;\n    type: HookType;\n    parent: DescribeBlock;\n    seenDone: boolean;\n    timeout: number | undefined | null;\n};\nexport interface EventHandler {\n    (event: AsyncEvent, state: State): void | Promise<void>;\n    (event: SyncEvent, state: State): void;\n}\nexport type Event = SyncEvent | AsyncEvent;\ninterface JestGlobals extends Global.TestFrameworkGlobals {\n    expect: unknown;\n}\nexport type SyncEvent = {\n    asyncError: Error;\n    mode: BlockMode;\n    name: 'start_describe_definition';\n    blockName: BlockName;\n} | {\n    mode: BlockMode;\n    name: 'finish_describe_definition';\n    blockName: BlockName;\n} | {\n    asyncError: Error;\n    name: 'add_hook';\n    hookType: HookType;\n    fn: HookFn;\n    timeout: number | undefined;\n} | {\n    asyncError: Error;\n    name: 'add_test';\n    testName: TestName;\n    fn: TestFn;\n    mode?: TestMode;\n    concurrent: boolean;\n    timeout: number | undefined;\n    failing: boolean;\n} | {\n    name: 'error';\n    error: Exception;\n    promise?: Promise<unknown>;\n} | {\n    name: 'error_handled';\n    promise: Promise<unknown>;\n};\nexport type AsyncEvent = {\n    name: 'setup';\n    testNamePattern?: string;\n    runtimeGlobals: JestGlobals;\n    parentProcess: Process;\n} | {\n    name: 'include_test_location_in_result';\n} | {\n    name: 'hook_start';\n    hook: Hook;\n} | {\n    name: 'hook_success';\n    describeBlock?: DescribeBlock;\n    test?: TestEntry;\n    hook: Hook;\n} | {\n    name: 'hook_failure';\n    error: string | Exception;\n    describeBlock?: DescribeBlock;\n    test?: TestEntry;\n    hook: Hook;\n} | {\n    name: 'test_fn_start';\n    test: TestEntry;\n} | {\n    name: 'test_fn_success';\n    test: TestEntry;\n} | {\n    name: 'test_fn_failure';\n    error: Exception;\n    test: TestEntry;\n} | {\n    name: 'test_retry';\n    test: TestEntry;\n} | {\n    name: 'test_start';\n    test: TestEntry;\n} | {\n    name: 'test_skip';\n    test: TestEntry;\n} | {\n    name: 'test_todo';\n    test: TestEntry;\n} | {\n    name: 'test_started';\n    test: TestEntry;\n} | {\n    name: 'test_done';\n    test: TestEntry;\n} | {\n    name: 'run_describe_start';\n    describeBlock: DescribeBlock;\n} | {\n    name: 'run_describe_finish';\n    describeBlock: DescribeBlock;\n} | {\n    name: 'run_start';\n} | {\n    name: 'run_finish';\n} | {\n    name: 'teardown';\n};\nexport type MatcherResults = {\n    actual: unknown;\n    expected: unknown;\n    name: string;\n    pass: boolean;\n};\nexport type TestStatus = 'skip' | 'done' | 'todo';\nexport type TestNamesPath = Array<TestName | BlockName>;\nexport type TestCaseStartInfo = {\n    ancestorTitles: Array<string>;\n    fullName: string;\n    mode: TestMode;\n    title: string;\n    startedAt?: number | null;\n};\nexport type TestResult = {\n    duration?: number | null;\n    errors: Array<FormattedError>;\n    errorsDetailed: Array<MatcherResults | unknown>;\n    /**\n     * Whether [`test.failing()`](https://jestjs.io/docs/api#testfailingname-fn-timeout)\n     * was used.\n     */\n    failing?: boolean;\n    invocations: number;\n    startedAt?: number | null;\n    status: TestStatus;\n    location?: {\n        column: number;\n        line: number;\n    } | null;\n    numPassingAsserts: number;\n    retryReasons: Array<FormattedError>;\n    testPath: TestNamesPath;\n};\nexport type RunResult = {\n    unhandledErrors: Array<FormattedError>;\n    testResults: TestResults;\n};\nexport type TestResults = Array<TestResult>;\nexport type GlobalErrorHandlers = {\n    rejectionHandled: Array<(promise: Promise<unknown>) => void>;\n    uncaughtException: Array<NodeJS.UncaughtExceptionListener>;\n    unhandledRejection: Array<NodeJS.UnhandledRejectionListener>;\n};\nexport type State = {\n    currentDescribeBlock: DescribeBlock;\n    currentlyRunningTest?: TestEntry | null;\n    expand?: boolean;\n    hasFocusedTests: boolean;\n    hasStarted: boolean;\n    originalGlobalErrorHandlers?: GlobalErrorHandlers;\n    parentProcess: Process | null;\n    randomize?: boolean;\n    rootDescribeBlock: DescribeBlock;\n    seed: number;\n    testNamePattern?: RegExp | null;\n    testTimeout: number;\n    unhandledErrors: Array<Exception>;\n    includeTestLocationInResult: boolean;\n    maxConcurrency: number;\n    unhandledRejectionErrorByPromise: Map<Promise<unknown>, Exception>;\n};\nexport type DescribeBlock = {\n    type: 'describeBlock';\n    children: Array<DescribeBlock | TestEntry>;\n    hooks: Array<Hook>;\n    mode: BlockMode;\n    name: BlockName;\n    parent?: DescribeBlock;\n    /** @deprecated Please get from `children` array instead */\n    tests: Array<TestEntry>;\n};\nexport type TestError = Exception | [Exception | undefined, Exception];\nexport type TestEntry = {\n    type: 'test';\n    asyncError: Exception;\n    errors: Array<TestError>;\n    retryReasons: Array<TestError>;\n    fn: TestFn;\n    invocations: number;\n    mode: TestMode;\n    concurrent: boolean;\n    name: TestName;\n    numPassingAsserts: number;\n    parent: DescribeBlock;\n    startedAt?: number | null;\n    duration?: number | null;\n    seenDone: boolean;\n    status?: TestStatus | null;\n    timeout?: number;\n    failing: boolean;\n    unhandledRejectionErrorByPromise: Map<Promise<unknown>, Exception>;\n};\nexport {};\n",
  "packages/jest-types/__typetests__/jest.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {expect} from 'tstyche';\nimport {jest} from '@jest/globals';\nimport type {\n  Mock,\n  MockInstance,\n  Mocked,\n  MockedClass,\n  MockedFunction,\n  MockedObject,\n  MockedShallow,\n  ModuleMocker,\n} from 'jest-mock';\n\nexpect(\n  jest\n    .autoMockOff()\n    .autoMockOn()\n    .clearAllMocks()\n    .disableAutomock()\n    .enableAutomock()\n    .deepUnmock('moduleName')\n    .doMock('moduleName')\n    .doMock('moduleName', jest.fn())\n    .doMock('moduleName', jest.fn(), {})\n    .doMock('moduleName', jest.fn(), {virtual: true})\n    .dontMock('moduleName')\n    .isolateModules(() => {})\n    .mock('moduleName')\n    .mock('moduleName', jest.fn())\n    .mock('moduleName', jest.fn(), {})\n    .mock('moduleName', jest.fn(), {virtual: true})\n    .unstable_mockModule('moduleName', jest.fn())\n    .unstable_mockModule('moduleName', () => Promise.resolve(jest.fn()))\n    .unstable_mockModule('moduleName', jest.fn(), {})\n    .unstable_mockModule('moduleName', () => Promise.resolve(jest.fn()), {})\n    .unstable_mockModule('moduleName', jest.fn(), {virtual: true})\n    .unstable_mockModule('moduleName', () => Promise.resolve(jest.fn()), {\n      virtual: true,\n    })\n    .resetAllMocks()\n    .resetModules()\n    .restoreAllMocks()\n    .retryTimes(3)\n    .setMock('moduleName', {a: 'b'})\n    .setTimeout(6000)\n    .unmock('moduleName')\n    .unstable_unmockModule('moduleName')\n    .useFakeTimers()\n    .useFakeTimers({legacyFakeTimers: true})\n    .useRealTimers(),\n).type.toBe<typeof jest>();\n\nexpect(jest.autoMockOff()).type.toBe<typeof jest>();\nexpect(jest.autoMockOff(true)).type.toRaiseError();\n\nexpect(jest.autoMockOn()).type.toBe<typeof jest>();\nexpect(jest.autoMockOn(false)).type.toRaiseError();\n\nconst someModule = {\n  methodA: () => {},\n  propertyB: 'B',\n};\n\nexpect(jest.createMockFromModule('moduleName')).type.toBe<unknown>();\nexpect(jest.createMockFromModule<typeof someModule>('moduleName')).type.toBe<\n  Mocked<typeof someModule>\n>();\nexpect(jest.createMockFromModule()).type.toRaiseError();\n\nexpect(jest.deepUnmock('moduleName')).type.toBe<typeof jest>();\nexpect(jest.deepUnmock()).type.toRaiseError();\n\nexpect(jest.doMock('moduleName')).type.toBe<typeof jest>();\nexpect(jest.doMock('moduleName', jest.fn())).type.toBe<typeof jest>();\nexpect(\n  jest.doMock<{some: 'test'}>('moduleName', () => ({some: 'test'})),\n).type.toBe<typeof jest>();\nexpect(jest.doMock('moduleName', jest.fn(), {})).type.toBe<typeof jest>();\nexpect(jest.doMock('moduleName', jest.fn(), {virtual: true})).type.toBe<\n  typeof jest\n>();\nexpect(jest.doMock()).type.toRaiseError();\nexpect(\n  jest.doMock<{some: 'test'}>('moduleName', () => false),\n).type.toRaiseError();\n\nexpect(jest.dontMock('moduleName')).type.toBe<typeof jest>();\nexpect(jest.dontMock()).type.toRaiseError();\n\nexpect(jest.disableAutomock()).type.toBe<typeof jest>();\nexpect(jest.disableAutomock(true)).type.toRaiseError();\n\nexpect(jest.enableAutomock()).type.toBe<typeof jest>();\nexpect(jest.enableAutomock('moduleName')).type.toRaiseError();\n\nexpect(jest.isolateModules(() => {})).type.toBe<typeof jest>();\nexpect(jest.isolateModules()).type.toRaiseError();\n\nexpect(jest.isolateModulesAsync(async () => {})).type.toBe<Promise<void>>();\nexpect(jest.isolateModulesAsync(() => {})).type.toRaiseError();\nexpect(jest.isolateModulesAsync()).type.toRaiseError();\n\nexpect(jest.mock('moduleName')).type.toBe<typeof jest>();\nexpect(jest.mock('moduleName', jest.fn())).type.toBe<typeof jest>();\nexpect(\n  jest.mock<{some: 'test'}>('moduleName', () => ({some: 'test'})),\n).type.toBe<typeof jest>();\nexpect(jest.mock('moduleName', jest.fn(), {})).type.toBe<typeof jest>();\nexpect(jest.mock('moduleName', jest.fn(), {virtual: true})).type.toBe<\n  typeof jest\n>();\nexpect(jest.mock()).type.toRaiseError();\nexpect(\n  jest.mock<{some: 'test'}>('moduleName', () => false),\n).type.toRaiseError();\n\nexpect(jest.unstable_mockModule('moduleName', jest.fn())).type.toBe<\n  typeof jest\n>();\nexpect(\n  jest.unstable_mockModule<{some: 'test'}>('moduleName', () => ({\n    some: 'test',\n  })),\n).type.toBe<typeof jest>();\nexpect(\n  jest.unstable_mockModule('moduleName', () => Promise.resolve(jest.fn())),\n).type.toBe<typeof jest>();\nexpect(\n  jest.unstable_mockModule<{some: 'test'}>('moduleName', () =>\n    Promise.resolve({\n      some: 'test',\n    }),\n  ),\n).type.toBe<typeof jest>();\nexpect(jest.unstable_mockModule('moduleName', jest.fn(), {})).type.toBe<\n  typeof jest\n>();\nexpect(\n  jest.unstable_mockModule('moduleName', () => Promise.resolve(jest.fn()), {}),\n).type.toBe<typeof jest>();\nexpect(\n  jest.unstable_mockModule('moduleName', jest.fn(), {virtual: true}),\n).type.toBe<typeof jest>();\nexpect(\n  jest.unstable_mockModule('moduleName', () => Promise.resolve(jest.fn()), {\n    virtual: true,\n  }),\n).type.toBe<typeof jest>();\nexpect(jest.unstable_mockModule('moduleName')).type.toRaiseError();\nexpect(\n  jest.unstable_mockModule<{some: 'test'}>('moduleName', () => false),\n).type.toRaiseError();\nexpect(\n  jest.unstable_mockModule<{some: 'test'}>('moduleName', () =>\n    Promise.resolve(false),\n  ),\n).type.toRaiseError();\n\nexpect(jest.requireActual('./pathToModule')).type.toBe<unknown>();\nexpect(jest.requireActual<{some: 'module'}>('./pathToModule')).type.toBe<{\n  some: 'module';\n}>();\nexpect(jest.requireActual()).type.toRaiseError();\n\nexpect(jest.requireMock('./pathToModule')).type.toBe<unknown>();\nexpect(jest.requireMock<{some: 'module'}>('./pathToModule')).type.toBe<{\n  some: 'module';\n}>();\nexpect(jest.requireMock()).type.toRaiseError();\n\nexpect(jest.resetModules()).type.toBe<typeof jest>();\nexpect(jest.resetModules('moduleName')).type.toRaiseError();\n\nexpect(jest.setMock('moduleName', {a: 'b'})).type.toBe<typeof jest>();\nexpect(jest.setMock('moduleName')).type.toRaiseError();\n\nexpect(jest.unmock('moduleName')).type.toBe<typeof jest>();\nexpect(jest.unmock()).type.toRaiseError();\n\nexpect(jest.unstable_unmockModule('moduleName')).type.toBe<typeof jest>();\nexpect(jest.unstable_unmockModule()).type.toRaiseError();\n\n// Mock Functions\n\nexpect(jest.clearAllMocks()).type.toBe<typeof jest>();\nexpect(jest.clearAllMocks('moduleName')).type.toRaiseError();\n\nexpect(jest.resetAllMocks()).type.toBe<typeof jest>();\nexpect(jest.resetAllMocks(true)).type.toRaiseError();\n\nexpect(jest.restoreAllMocks()).type.toBe<typeof jest>();\nexpect(jest.restoreAllMocks(false)).type.toRaiseError();\n\nexpect(jest.isMockFunction(() => {})).type.toBe<boolean>();\nexpect(jest.isMockFunction()).type.toRaiseError();\n\nconst maybeMock = (a: string, b: number) => true;\n\nif (jest.isMockFunction(maybeMock)) {\n  expect(maybeMock).type.toBe<Mock<(a: string, b: number) => boolean>>();\n\n  maybeMock.mockReturnValueOnce(false);\n  expect(maybeMock.mockReturnValueOnce(123)).type.toRaiseError();\n}\n\nif (!jest.isMockFunction(maybeMock)) {\n  expect(maybeMock).type.toBe<(a: string, b: number) => boolean>();\n}\n\nconst surelyMock = jest.fn((a: string, b: number) => true);\n\nif (jest.isMockFunction(surelyMock)) {\n  expect(surelyMock).type.toBe<Mock<(a: string, b: number) => boolean>>();\n\n  surelyMock.mockReturnValueOnce(false);\n  expect(surelyMock.mockReturnValueOnce(123)).type.toRaiseError();\n}\n\nif (!jest.isMockFunction(surelyMock)) {\n  expect(surelyMock).type.toBe<never>();\n}\n\nconst spiedObject = {\n  methodA(a: number, b: string) {\n    return true;\n  },\n};\n\nconst surelySpy = jest.spyOn(spiedObject, 'methodA');\n\nif (jest.isMockFunction(surelySpy)) {\n  expect(surelySpy).type.toBe<\n    MockInstance<(a: number, b: string) => boolean>\n  >();\n\n  surelySpy.mockReturnValueOnce(false);\n  expect(surelyMock.mockReturnValueOnce(123)).type.toRaiseError();\n}\n\nif (!jest.isMockFunction(surelySpy)) {\n  expect(surelySpy).type.toBe<never>();\n}\n\ndeclare const stringMaybeMock: string;\n\nif (jest.isMockFunction(stringMaybeMock)) {\n  expect(stringMaybeMock).type.toBe<\n    string & Mock<(...args: Array<unknown>) => unknown>\n  >();\n}\n\nif (!jest.isMockFunction(stringMaybeMock)) {\n  expect(stringMaybeMock).type.toBe<string>();\n}\n\ndeclare const anyMaybeMock: any;\n\nif (jest.isMockFunction(anyMaybeMock)) {\n  expect(anyMaybeMock).type.toBe<Mock<(...args: Array<unknown>) => unknown>>();\n}\n\nif (!jest.isMockFunction(anyMaybeMock)) {\n  expect(anyMaybeMock).type.toBe<any>();\n}\n\ndeclare const unknownMaybeMock: unknown;\n\nif (jest.isMockFunction(unknownMaybeMock)) {\n  expect(unknownMaybeMock).type.toBe<\n    Mock<(...args: Array<unknown>) => unknown>\n  >();\n}\n\nif (!jest.isMockFunction(unknownMaybeMock)) {\n  expect(unknownMaybeMock).type.toBe<unknown>();\n}\n\nexpect(jest.fn).type.toBe<ModuleMocker['fn']>();\n\nexpect(jest.spyOn).type.toBe<ModuleMocker['spyOn']>();\n\nexpect(jest.replaceProperty).type.toBe<ModuleMocker['replaceProperty']>();\n\n// Mock<T>\n\nexpect({} as jest.Mock<() => boolean>).type.toBe<Mock<() => boolean>>();\nexpect({} as jest.Mock<(a: string) => string>).type.toBe<\n  Mock<(a: string) => string>\n>();\n\n// Mocked*<T>\n\nclass SomeClass {\n  constructor(one: string, two?: boolean) {}\n\n  methodA() {\n    return true;\n  }\n  methodB(a: string, b?: number) {\n    return;\n  }\n}\n\nfunction someFunction(a: string, b?: number): boolean {\n  return true;\n}\n\nconst someObject = {\n  SomeClass,\n\n  _propertyC: false,\n\n  methodA() {\n    return;\n  },\n  methodB(b: string) {\n    return true;\n  },\n  methodC: (c: number) => true,\n\n  one: {\n    more: {\n      time: (t: number) => {\n        return;\n      },\n    },\n  },\n\n  propertyA: 123,\n\n  propertyB: 'value',\n\n  set propertyC(value) {\n    this._propertyC = value;\n  },\n  get propertyC() {\n    return this._propertyC;\n  },\n\n  someClassInstance: new SomeClass('value'),\n};\n\nexpect(someObject as jest.Mocked<typeof someObject>).type.toBe<\n  Mocked<typeof someObject>\n>();\n\nexpect(SomeClass as jest.MockedClass<typeof SomeClass>).type.toBe<\n  MockedClass<typeof SomeClass>\n>();\n\nexpect(someFunction as jest.MockedFunction<typeof someFunction>).type.toBe<\n  MockedFunction<typeof someFunction>\n>();\n\nexpect(someObject as jest.MockedObject<typeof someObject>).type.toBe<\n  MockedObject<typeof someObject>\n>();\n\n// mocked()\n\nexpect(jest.mocked(someObject)).type.toBe<Mocked<typeof someObject>>();\nexpect(jest.mocked(someObject, {shallow: false})).type.toBe<\n  Mocked<typeof someObject>\n>();\nexpect(jest.mocked(someObject, {shallow: true})).type.toBe<\n  MockedShallow<typeof someObject>\n>();\n\nexpect(jest.mocked('abc')).type.toRaiseError();\n\nconst mockObjectA = jest.mocked(someObject);\n\nexpect(mockObjectA.methodA.mock.calls[0]).type.toBe<[]>();\nexpect(mockObjectA.methodB.mock.calls[0]).type.toBe<[b: string]>();\nexpect(mockObjectA.methodC.mock.calls[0]).type.toBe<[c: number]>();\n\nexpect(mockObjectA.one.more.time.mock.calls[0]).type.toBe<[t: number]>();\n\nexpect(mockObjectA.SomeClass.mock.calls[0]).type.toBe<\n  [one: string, two?: boolean]\n>();\nexpect(mockObjectA.SomeClass.prototype.methodA.mock.calls[0]).type.toBe<[]>();\nexpect(mockObjectA.SomeClass.prototype.methodB.mock.calls[0]).type.toBe<\n  [a: string, b?: number]\n>();\n\nexpect(mockObjectA.someClassInstance.methodA.mock.calls[0]).type.toBe<[]>();\nexpect(mockObjectA.someClassInstance.methodB.mock.calls[0]).type.toBe<\n  [a: string, b?: number]\n>();\n\nexpect(mockObjectA.methodA.mockReturnValue(123)).type.toRaiseError();\nexpect(\n  mockObjectA.methodA.mockImplementation((a: number) => 123),\n).type.toRaiseError();\nexpect(mockObjectA.methodB.mockReturnValue(123)).type.toRaiseError();\nexpect(\n  mockObjectA.methodB.mockImplementation((b: number) => 123),\n).type.toRaiseError();\nexpect(mockObjectA.methodC.mockReturnValue(123)).type.toRaiseError();\nexpect(\n  mockObjectA.methodC.mockImplementation((c: number) => 123),\n).type.toRaiseError();\n\nexpect(mockObjectA.one.more.time.mockReturnValue(123)).type.toRaiseError();\nexpect(\n  mockObjectA.one.more.time.mockImplementation((t: boolean) => 123),\n).type.toRaiseError();\n\nexpect(\n  mockObjectA.SomeClass.prototype.methodA.mockReturnValue(123),\n).type.toRaiseError();\nexpect(\n  mockObjectA.SomeClass.prototype.methodA.mockImplementation(\n    (a: number) => 123,\n  ),\n).type.toRaiseError();\nexpect(\n  mockObjectA.SomeClass.prototype.methodB.mockReturnValue(123),\n).type.toRaiseError();\nexpect(\n  mockObjectA.SomeClass.prototype.methodB.mockImplementation(\n    (a: number) => 123,\n  ),\n).type.toRaiseError();\n\nexpect(\n  mockObjectA.someClassInstance.methodA.mockReturnValue(123),\n).type.toRaiseError();\nexpect(\n  mockObjectA.someClassInstance.methodA.mockImplementation((a: number) => 123),\n).type.toRaiseError();\nexpect(\n  mockObjectA.someClassInstance.methodB.mockReturnValue(123),\n).type.toRaiseError();\nexpect(\n  mockObjectA.someClassInstance.methodB.mockImplementation((a: number) => 123),\n).type.toRaiseError();\n\nexpect<typeof someObject>().type.toBeAssignableWith(mockObjectA);\n\n// shallow mocked()\n\nconst mockObjectB = jest.mocked(someObject, {shallow: true});\n\nexpect(mockObjectB.methodA.mock.calls[0]).type.toBe<[]>();\nexpect(mockObjectB.methodB.mock.calls[0]).type.toBe<[b: string]>();\nexpect(mockObjectB.methodC.mock.calls[0]).type.toBe<[c: number]>();\n\nexpect(mockObjectB.one.more.time.mock.calls[0]).type.toRaiseError();\n\nexpect(mockObjectB.SomeClass.mock.calls[0]).type.toBe<\n  [one: string, two?: boolean]\n>();\nexpect(mockObjectB.SomeClass.prototype.methodA.mock.calls[0]).type.toBe<[]>();\nexpect(mockObjectB.SomeClass.prototype.methodB.mock.calls[0]).type.toBe<\n  [a: string, b?: number]\n>();\n\nexpect(mockObjectB.someClassInstance.methodA.mock.calls[0]).type.toRaiseError();\nexpect(mockObjectB.someClassInstance.methodB.mock.calls[0]).type.toRaiseError();\n\nexpect(mockObjectB.methodA.mockReturnValue(123)).type.toRaiseError();\nexpect(\n  mockObjectB.methodA.mockImplementation((a: number) => 123),\n).type.toRaiseError();\nexpect(mockObjectB.methodB.mockReturnValue(123)).type.toRaiseError();\nexpect(\n  mockObjectB.methodB.mockImplementation((b: number) => 123),\n).type.toRaiseError();\nexpect(mockObjectB.methodC.mockReturnValue(123)).type.toRaiseError();\nexpect(\n  mockObjectB.methodC.mockImplementation((c: number) => 123),\n).type.toRaiseError();\n\nexpect(\n  mockObjectB.SomeClass.prototype.methodA.mockReturnValue(123),\n).type.toRaiseError();\nexpect(\n  mockObjectB.SomeClass.prototype.methodA.mockImplementation(\n    (a: number) => 123,\n  ),\n).type.toRaiseError();\nexpect(\n  mockObjectB.SomeClass.prototype.methodB.mockReturnValue(123),\n).type.toRaiseError();\nexpect(\n  mockObjectB.SomeClass.prototype.methodB.mockImplementation(\n    (a: number) => 123,\n  ),\n).type.toRaiseError();\n\nexpect<typeof someObject>().type.toBeAssignableWith(mockObjectB);\n\n// Replaced\n\nexpect<jest.Replaced<number>>().type.toBeAssignableWith(\n  jest.replaceProperty(someObject, 'propertyA', 123),\n);\n\n// Spied\n\nexpect<jest.Spied<typeof someObject.methodA>>().type.toBeAssignableWith(\n  jest.spyOn(someObject, 'methodA'),\n);\n\nexpect<jest.Spied<typeof someObject.SomeClass>>().type.toBeAssignableWith(\n  jest.spyOn(someObject, 'SomeClass'),\n);\n\n// Spied*\n\nexpect<jest.SpiedClass<typeof someObject.SomeClass>>().type.toBeAssignableWith(\n  jest.spyOn(someObject, 'SomeClass'),\n);\n\nexpect<jest.SpiedFunction<typeof someObject.methodB>>().type.toBeAssignableWith(\n  jest.spyOn(someObject, 'methodB'),\n);\n\nexpect<jest.SpiedGetter<typeof someObject.propertyC>>().type.toBeAssignableWith(\n  jest.spyOn(someObject, 'propertyC', 'get'),\n);\n\nexpect<jest.SpiedSetter<typeof someObject.propertyC>>().type.toBeAssignableWith(\n  jest.spyOn(someObject, 'propertyC', 'set'),\n);\n\n// Mock Timers\n\nexpect(jest.advanceTimersByTime(6000)).type.toBe<void>();\nexpect(jest.advanceTimersByTime()).type.toRaiseError();\n\nexpect(jest.advanceTimersByTimeAsync(6000)).type.toBe<Promise<void>>();\nexpect(jest.advanceTimersByTimeAsync()).type.toRaiseError();\n\nexpect(jest.advanceTimersToNextTimer()).type.toBe<void>();\nexpect(jest.advanceTimersToNextTimer(2)).type.toBe<void>();\nexpect(jest.advanceTimersToNextTimer('2')).type.toRaiseError();\n\nexpect(jest.advanceTimersToNextTimerAsync()).type.toBe<Promise<void>>();\nexpect(jest.advanceTimersToNextTimerAsync(2)).type.toBe<Promise<void>>();\nexpect(jest.advanceTimersToNextTimerAsync('2')).type.toRaiseError();\n\nexpect(jest.clearAllTimers()).type.toBe<void>();\nexpect(jest.clearAllTimers(false)).type.toRaiseError();\n\nexpect(jest.getTimerCount()).type.toBe<number>();\nexpect(jest.getTimerCount(true)).type.toRaiseError();\n\nexpect(jest.now()).type.toBe<number>();\nexpect(jest.now('1995-12-17T03:24:00')).type.toRaiseError();\n\nexpect(jest.getRealSystemTime()).type.toBe<number>();\nexpect(jest.getRealSystemTime(true)).type.toRaiseError();\n\nexpect(jest.runAllImmediates()).type.toBe<void>();\nexpect(jest.runAllImmediates(true)).type.toRaiseError();\n\nexpect(jest.runAllTicks()).type.toBe<void>();\nexpect(jest.runAllTicks(true)).type.toRaiseError();\n\nexpect(jest.runAllTimers()).type.toBe<void>();\nexpect(jest.runAllTimers(false)).type.toRaiseError();\n\nexpect(jest.runAllTimersAsync()).type.toBe<Promise<void>>();\nexpect(jest.runAllTimersAsync(false)).type.toRaiseError();\n\nexpect(jest.runOnlyPendingTimers()).type.toBe<void>();\nexpect(jest.runOnlyPendingTimers(true)).type.toRaiseError();\n\nexpect(jest.runOnlyPendingTimersAsync()).type.toBe<Promise<void>>();\nexpect(jest.runOnlyPendingTimersAsync(true)).type.toRaiseError();\n\nexpect(jest.advanceTimersToNextFrame()).type.toBe<void>();\nexpect(jest.advanceTimersToNextFrame(true)).type.toRaiseError();\nexpect(jest.advanceTimersToNextFrame(100)).type.toRaiseError();\n\nexpect(jest.setSystemTime()).type.toBe<void>();\nexpect(jest.setSystemTime(1_483_228_800_000)).type.toBe<void>();\nexpect(jest.setSystemTime(Date.now())).type.toBe<void>();\nexpect(jest.setSystemTime(new Date(1995, 11, 17))).type.toBe<void>();\nexpect(jest.setSystemTime('1995-12-17T03:24:00')).type.toRaiseError();\n\nexpect(jest.useFakeTimers()).type.toBe<typeof jest>();\n\nexpect(jest.useFakeTimers({advanceTimers: true})).type.toBe<typeof jest>();\nexpect(jest.useFakeTimers({advanceTimers: 10})).type.toBe<typeof jest>();\nexpect(jest.useFakeTimers({advanceTimers: 'fast'})).type.toRaiseError();\n\nexpect(jest.useFakeTimers({doNotFake: ['Date']})).type.toBe<typeof jest>();\nexpect(\n  jest.useFakeTimers({\n    doNotFake: [\n      'Date',\n      'hrtime',\n      'nextTick',\n      'performance',\n      'queueMicrotask',\n      'requestAnimationFrame',\n      'cancelAnimationFrame',\n      'requestIdleCallback',\n      'cancelIdleCallback',\n      'setImmediate',\n      'clearImmediate',\n      'setInterval',\n      'clearInterval',\n      'setTimeout',\n      'clearTimeout',\n    ],\n  }),\n).type.toBe<typeof jest>();\nexpect(jest.useFakeTimers({doNotFake: ['globalThis']})).type.toRaiseError();\n\nexpect(jest.useFakeTimers({legacyFakeTimers: true})).type.toBe<typeof jest>();\nexpect(jest.useFakeTimers({legacyFakeTimers: 1000})).type.toRaiseError();\nexpect(\n  jest.useFakeTimers({doNotFake: ['Date'], legacyFakeTimers: true}),\n).type.toRaiseError();\nexpect(\n  jest.useFakeTimers({enableGlobally: true, legacyFakeTimers: true}),\n).type.toRaiseError();\nexpect(\n  jest.useFakeTimers({legacyFakeTimers: true, now: 1_483_228_800_000}),\n).type.toRaiseError();\nexpect(\n  jest.useFakeTimers({legacyFakeTimers: true, timerLimit: 1000}),\n).type.toRaiseError();\n\nexpect(jest.useFakeTimers({now: 1_483_228_800_000})).type.toBe<typeof jest>();\nexpect(jest.useFakeTimers({now: Date.now()})).type.toBe<typeof jest>();\nexpect(jest.useFakeTimers({now: new Date(1995, 11, 17)})).type.toBe<\n  typeof jest\n>();\nexpect(jest.useFakeTimers({now: '1995-12-17T03:24:00'})).type.toRaiseError();\n\nexpect(jest.useFakeTimers({timerLimit: 1000})).type.toBe<typeof jest>();\nexpect(jest.useFakeTimers({timerLimit: true})).type.toRaiseError();\n\nexpect(jest.useFakeTimers({enableGlobally: true})).type.toRaiseError();\nexpect(jest.useFakeTimers('legacy')).type.toRaiseError();\nexpect(jest.useFakeTimers('modern')).type.toRaiseError();\n\nexpect(jest.useRealTimers()).type.toBe<typeof jest>();\nexpect(jest.useRealTimers(true)).type.toRaiseError();\n\n// Misc\n\nexpect(jest.retryTimes(3)).type.toBe<typeof jest>();\nexpect(jest.retryTimes(3, {logErrorsBeforeRetry: true})).type.toBe<\n  typeof jest\n>();\nexpect(jest.retryTimes(3, {logErrorsBeforeRetry: 'all'})).type.toRaiseError();\nexpect(jest.retryTimes({logErrorsBeforeRetry: true})).type.toRaiseError();\nexpect(jest.retryTimes(3, {waitBeforeRetry: 1000})).type.toBe<typeof jest>();\nexpect(jest.retryTimes(3, {waitBeforeRetry: true})).type.toRaiseError();\nexpect(jest.retryTimes(3, {retryImmediately: true})).type.toBe<typeof jest>();\nexpect(jest.retryTimes(3, {retryImmediately: 'now'})).type.toRaiseError();\nexpect(jest.retryTimes(3, {retryImmediately: 1000})).type.toRaiseError();\nexpect(jest.retryTimes({logErrorsBeforeRetry: 'all'})).type.toRaiseError();\nexpect(jest.retryTimes()).type.toRaiseError();\n\nexpect(jest.setTimeout(6000)).type.toBe<typeof jest>();\nexpect(jest.setTimeout()).type.toRaiseError();\n\nexpect(jest.getSeed()).type.toBe<number>();\nexpect(jest.getSeed(123)).type.toRaiseError();\n\nexpect(jest.isEnvironmentTornDown()).type.toBe<boolean>();\nexpect(jest.isEnvironmentTornDown(123)).type.toRaiseError();\n",
  "packages/jest-types/__typetests__/jest.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-types/__typetests__/globals.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {expect} from 'tstyche';\nimport {\n  afterAll,\n  afterEach,\n  beforeAll,\n  beforeEach,\n  describe,\n  test,\n} from '@jest/globals';\nimport type {Global} from '@jest/types';\n\nconst fn = () => {};\nconst asyncFn = async () => {};\nconst genFn = function* () {};\n\nconst table = [\n  [1, 2, 3],\n  [4, 5, 6],\n];\n\nconst testName = 'Test name';\nconst timeout = 5;\n\n// done\n\ntest(testName, done => {\n  done();\n});\n\ntest(testName, done => {\n  done('error message');\n});\n\ntest(testName, done => {\n  done(new Error('message'));\n});\n\ntest(testName, done => {\n  expect(done).type.toBe<Global.DoneFn>();\n});\n\ntest(testName, done => {\n  expect(done(123)).type.toRaiseError();\n});\n\n// beforeAll\n\nexpect(beforeAll(fn)).type.toBe<void>();\nexpect(beforeAll(asyncFn)).type.toBe<void>();\nexpect(beforeAll(genFn)).type.toBe<void>();\nexpect(\n  beforeAll(done => {\n    expect(done).type.toBe<Global.DoneFn>();\n  }),\n).type.toBe<void>();\n\nexpect(beforeAll(fn, timeout)).type.toBe<void>();\nexpect(beforeAll(asyncFn, timeout)).type.toBe<void>();\nexpect(beforeAll(genFn, timeout)).type.toBe<void>();\nexpect(\n  beforeAll(done => {\n    expect(done).type.toBe<Global.DoneFn>();\n  }, timeout),\n).type.toBe<void>();\n\nexpect(beforeAll()).type.toRaiseError();\nexpect(beforeAll('abc')).type.toRaiseError();\n\nexpect(\n  beforeAll(async done => {\n    done();\n  }),\n).type.toRaiseError();\nexpect(\n  beforeAll(function* (done) {\n    done();\n  }),\n).type.toRaiseError();\n\n// beforeEach\n\nexpect(beforeEach(fn)).type.toBe<void>();\nexpect(beforeEach(asyncFn)).type.toBe<void>();\nexpect(beforeEach(genFn)).type.toBe<void>();\nexpect(\n  beforeEach(done => {\n    expect(done).type.toBe<Global.DoneFn>();\n  }),\n).type.toBe<void>();\n\nexpect(beforeEach(fn, timeout)).type.toBe<void>();\nexpect(beforeEach(asyncFn, timeout)).type.toBe<void>();\nexpect(beforeEach(genFn, timeout)).type.toBe<void>();\nexpect(\n  beforeEach(done => {\n    expect(done).type.toBe<Global.DoneFn>();\n  }, timeout),\n).type.toBe<void>();\n\nexpect(beforeEach()).type.toRaiseError();\nexpect(beforeEach('abc')).type.toRaiseError();\n\nexpect(\n  beforeEach(async done => {\n    done();\n  }),\n).type.toRaiseError();\nexpect(\n  beforeEach(function* (done) {\n    done();\n  }),\n).type.toRaiseError();\n\n// afterAll\n\nexpect(afterAll(fn)).type.toBe<void>();\nexpect(afterAll(asyncFn)).type.toBe<void>();\nexpect(afterAll(genFn)).type.toBe<void>();\nexpect(\n  afterAll(done => {\n    expect(done).type.toBe<Global.DoneFn>();\n  }),\n).type.toBe<void>();\n\nexpect(afterAll(fn, timeout)).type.toBe<void>();\nexpect(afterAll(asyncFn, timeout)).type.toBe<void>();\nexpect(afterAll(genFn, timeout)).type.toBe<void>();\nexpect(\n  afterAll(done => {\n    expect(done).type.toBe<Global.DoneFn>();\n  }, timeout),\n).type.toBe<void>();\n\nexpect(afterAll()).type.toRaiseError();\nexpect(afterAll('abc')).type.toRaiseError();\n\nexpect(\n  afterAll(async done => {\n    done();\n  }),\n).type.toRaiseError();\nexpect(\n  afterAll(function* (done) {\n    done();\n  }),\n).type.toRaiseError();\n\n// afterEach\n\nexpect(afterEach(fn)).type.toBe<void>();\nexpect(afterEach(asyncFn)).type.toBe<void>();\nexpect(afterEach(genFn)).type.toBe<void>();\nexpect(\n  afterEach(done => {\n    expect(done).type.toBe<Global.DoneFn>();\n  }),\n).type.toBe<void>();\n\nexpect(afterEach(fn, timeout)).type.toBe<void>();\nexpect(afterEach(asyncFn, timeout)).type.toBe<void>();\nexpect(afterEach(genFn, timeout)).type.toBe<void>();\nexpect(\n  afterEach(done => {\n    expect(done).type.toBe<Global.DoneFn>();\n  }, timeout),\n).type.toBe<void>();\n\nexpect(afterEach()).type.toRaiseError();\nexpect(afterEach('abc')).type.toRaiseError();\n\nexpect(\n  afterEach(async done => {\n    done();\n  }),\n).type.toRaiseError();\nexpect(\n  afterEach(function* (done) {\n    done();\n  }),\n).type.toRaiseError();\n\n// test\n\nexpect(test(testName, fn)).type.toBe<void>();\nexpect(test(testName, asyncFn)).type.toBe<void>();\nexpect(test(testName, genFn)).type.toBe<void>();\nexpect(\n  test(testName, done => {\n    expect(done).type.toBe<Global.DoneFn>();\n  }),\n).type.toBe<void>();\n\nexpect(test(testName, fn, timeout)).type.toBe<void>();\nexpect(test(testName, asyncFn, timeout)).type.toBe<void>();\nexpect(test(testName, genFn, timeout)).type.toBe<void>();\nexpect(\n  test(\n    testName,\n    done => {\n      expect(done).type.toBe<Global.DoneFn>();\n    },\n    timeout,\n  ),\n).type.toBe<void>();\n\nexpect(test(123, fn)).type.toBe<void>();\nexpect(test(() => {}, fn)).type.toBe<void>();\nexpect(test(function named() {}, fn)).type.toBe<void>();\nexpect(test(class {}, fn)).type.toBe<void>();\nexpect(test(class Named {}, fn)).type.toBe<void>();\n\nexpect(test()).type.toRaiseError();\nexpect(test(testName)).type.toRaiseError();\nexpect(test(testName, timeout)).type.toRaiseError();\nexpect(test(testName, () => 42)).type.toRaiseError();\n\nexpect(\n  test(testName, async done => {\n    done();\n  }),\n).type.toRaiseError();\nexpect(\n  test(testName, function* (done) {\n    done();\n  }),\n).type.toRaiseError();\n\n// test.concurrent\n\nexpect(test.concurrent(testName, asyncFn)).type.toBe<void>();\nexpect(test.concurrent(testName, asyncFn, timeout)).type.toBe<void>();\n\nexpect(test.concurrent(123, asyncFn)).type.toBe<void>();\nexpect(test.concurrent(() => {}, asyncFn)).type.toBe<void>();\nexpect(test.concurrent(function named() {}, asyncFn)).type.toBe<void>();\nexpect(test.concurrent(class {}, asyncFn)).type.toBe<void>();\nexpect(test.concurrent(class Named {}, asyncFn)).type.toBe<void>();\n\nexpect(test.concurrent(testName, fn)).type.toRaiseError();\n\n// test.concurrent.each\n\nexpect(test.concurrent.each(table)(testName, asyncFn)).type.toBe<void>();\nexpect(\n  test.concurrent.each(table)(testName, asyncFn, timeout),\n).type.toBe<void>();\n\nexpect(test.concurrent.each(table)(123, asyncFn)).type.toBe<void>();\nexpect(test.concurrent.each(table)(() => {}, asyncFn)).type.toBe<void>();\nexpect(\n  test.concurrent.each(table)(function named() {}, asyncFn),\n).type.toBe<void>();\nexpect(test.concurrent.each(table)(class {}, asyncFn)).type.toBe<void>();\nexpect(test.concurrent.each(table)(class Named {}, asyncFn)).type.toBe<void>();\n\nexpect(test.concurrent.each(table)(testName, fn)).type.toRaiseError();\n\n// test.concurrent.failing\n\nexpect(test.concurrent.failing(testName, asyncFn)).type.toBe<void>();\nexpect(test.concurrent.failing(testName, asyncFn, timeout)).type.toBe<void>();\n\nexpect(test.concurrent.failing(123, asyncFn)).type.toBe<void>();\nexpect(test.concurrent.failing(() => {}, asyncFn)).type.toBe<void>();\nexpect(test.concurrent.failing(function named() {}, asyncFn)).type.toBe<void>();\nexpect(test.concurrent.failing(class {}, asyncFn)).type.toBe<void>();\nexpect(test.concurrent.failing(class Named {}, asyncFn)).type.toBe<void>();\n\nexpect(test.concurrent.failing.each).type.toBe(test.concurrent.each);\n\nexpect(test.concurrent.failing(testName, fn)).type.toRaiseError();\n\n// test.concurrent.only\n\nexpect(test.concurrent.only.each).type.toBe(test.concurrent.each);\nexpect(test.concurrent.only.failing).type.toBe(test.concurrent.failing);\nexpect(test.concurrent.only.failing.each).type.toBe(test.concurrent.each);\n\n// test.concurrent.skip\n\nexpect(test.concurrent.skip.each).type.toBe(test.concurrent.each);\nexpect(test.concurrent.skip.failing).type.toBe(test.concurrent.failing);\nexpect(test.concurrent.skip.failing.each).type.toBe(test.concurrent.each);\n\n// test.each\n\nexpect(test.each(table)(testName, fn)).type.toBe<void>();\nexpect(test.each(table)(testName, fn, timeout)).type.toBe<void>();\n\nexpect(test.each(table)(123, fn)).type.toBe<void>();\nexpect(test.each(table)(() => {}, fn)).type.toBe<void>();\nexpect(test.each(table)(function named() {}, fn)).type.toBe<void>();\nexpect(test.each(table)(class {}, fn)).type.toBe<void>();\nexpect(test.each(table)(class Named {}, fn)).type.toBe<void>();\n\n// test.failing\n\nexpect(test.failing(testName, fn)).type.toBe<void>();\nexpect(test.failing(testName, fn, timeout)).type.toBe<void>();\n\nexpect(test.failing(123, fn)).type.toBe<void>();\nexpect(test.failing(() => {}, fn)).type.toBe<void>();\nexpect(test.failing(function named() {}, fn)).type.toBe<void>();\nexpect(test.failing(class {}, fn)).type.toBe<void>();\nexpect(test.failing(class Named {}, fn)).type.toBe<void>();\n\nexpect(test.failing.each).type.toBe(test.each);\n\n// test.only\n\nexpect(test.only(testName, fn)).type.toBe<void>();\nexpect(test.only(testName, fn, timeout)).type.toBe<void>();\n\nexpect(test.only(123, fn)).type.toBe<void>();\nexpect(test.only(() => {}, fn)).type.toBe<void>();\nexpect(test.only(function named() {}, fn)).type.toBe<void>();\nexpect(test.only(class {}, fn)).type.toBe<void>();\nexpect(test.only(class Named {}, fn)).type.toBe<void>();\n\nexpect(test.only.each).type.toBe(test.each);\nexpect(test.only.failing).type.toBe(test.failing);\nexpect(test.only.failing.each).type.toBe(test.each);\n\n// test.skip\n\nexpect(test.skip(testName, fn)).type.toBe<void>();\nexpect(test.skip(testName, fn, timeout)).type.toBe<void>();\n\nexpect(test.skip(123, fn)).type.toBe<void>();\nexpect(test.skip(() => {}, fn)).type.toBe<void>();\nexpect(test.skip(function named() {}, fn)).type.toBe<void>();\nexpect(test.skip(class {}, fn)).type.toBe<void>();\nexpect(test.skip(class Named {}, fn)).type.toBe<void>();\n\nexpect(test.skip.each).type.toBe(test.each);\nexpect(test.skip.failing).type.toBe(test.failing);\nexpect(test.skip.failing.each).type.toBe(test.each);\n\n// test.todo\n\nexpect(test.todo(testName)).type.toBe<void>();\n\nexpect(test.todo(123)).type.toBe<void>();\nexpect(test.todo(() => {})).type.toBe<void>();\nexpect(test.todo(function named() {})).type.toBe<void>();\nexpect(test.todo(class {})).type.toBe<void>();\nexpect(test.todo(class Named {})).type.toBe<void>();\n\nexpect(test.todo()).type.toRaiseError();\nexpect(test.todo(testName, fn)).type.toRaiseError();\n\n// describe\n\nexpect(describe(testName, fn)).type.toBe<void>();\n\nexpect(describe()).type.toRaiseError();\nexpect(describe(fn)).type.toRaiseError();\nexpect(describe(testName, fn, timeout)).type.toRaiseError();\n\nexpect(describe(123, fn)).type.toBe<void>();\nexpect(describe(() => {}, fn)).type.toBe<void>();\nexpect(describe(function named() {}, fn)).type.toBe<void>();\nexpect(describe(class {}, fn)).type.toBe<void>();\nexpect(describe(class Named {}, fn)).type.toBe<void>();\n\nexpect(describe.each(table)(testName, fn)).type.toBe<void>();\nexpect(describe.each(table)(testName, fn, timeout)).type.toBe<void>();\n\nexpect(describe.each(table)(testName, fn)).type.toBe<void>();\nexpect(describe.each(table)(123, fn)).type.toBe<void>();\nexpect(describe.each(table)(() => {}, fn)).type.toBe<void>();\nexpect(describe.each(table)(function named() {}, fn)).type.toBe<void>();\nexpect(describe.each(table)(class Named {}, fn)).type.toBe<void>();\n\n// describe.only\n\nexpect(describe.only(testName, fn)).type.toBe<void>();\n\nexpect(describe.only()).type.toRaiseError();\nexpect(describe.only(fn)).type.toRaiseError();\nexpect(describe.only(testName, fn, timeout)).type.toRaiseError();\n\nexpect(describe.only(123, fn)).type.toBe<void>();\nexpect(describe.only(() => {}, fn)).type.toBe<void>();\nexpect(describe.only(function named() {}, fn)).type.toBe<void>();\nexpect(describe.only(class {}, fn)).type.toBe<void>();\nexpect(describe.only(class Named {}, fn)).type.toBe<void>();\n\nexpect(describe.only.each).type.toBe(describe.each);\n\n// describe.skip\n\nexpect(describe.skip(testName, fn)).type.toBe<void>();\n\nexpect(describe.skip()).type.toRaiseError();\nexpect(describe.skip(fn)).type.toRaiseError();\nexpect(describe.skip(testName, fn, timeout)).type.toRaiseError();\n\nexpect(describe.skip(123, fn)).type.toBe<void>();\nexpect(describe.skip(() => {}, fn)).type.toBe<void>();\nexpect(describe.skip(function named() {}, fn)).type.toBe<void>();\nexpect(describe.skip(class {}, fn)).type.toBe<void>();\nexpect(describe.skip(class Named {}, fn)).type.toBe<void>();\n\nexpect(describe.skip.each).type.toBe(describe.each);\n",
  "packages/jest-types/__typetests__/globals.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-types/__typetests__/each.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {expect} from 'tstyche';\nimport {describe, test} from '@jest/globals';\n\nconst list = [1, 2, 3];\nconst tupleList = ['one', 'two', 'three'] as const;\nconst table = [\n  [1, 2, 'three'],\n  [3, 4, 'seven'],\n];\nconst tupleTable: Array<[number, number, string, boolean?]> = [\n  [1, 2, 'three', true],\n  [3, 4, 'seven', false],\n  [5, 6, 'eleven'],\n];\nconst objectTable = [\n  {a: 1, b: 2, expected: 'three', extra: true},\n  {a: 3, b: 4, expected: 'seven', extra: false},\n  {a: 5, b: 6, expected: 'eleven'},\n];\n\n// test.each\n\nexpect(\n  test.each(list)('some test', (a, done) => {\n    expect(a).type.toBe<number>();\n\n    expect(done).type.toBe<(reason?: string | Error) => void>();\n  }),\n).type.toBe<void>();\nexpect(\n  test.each(list)(\n    'some test',\n    a => {\n      expect(a).type.toBe<number>();\n    },\n    1000,\n  ),\n).type.toBe<void>();\n\nexpect(\n  test.each(tupleList)('some test', (b, done) => {\n    expect(b).type.toBe<'one' | 'two' | 'three'>();\n\n    expect(done).type.toBe<(reason?: string | Error) => void>();\n  }),\n).type.toBe<void>();\nexpect(\n  test.each(tupleList)(\n    'some test',\n    b => {\n      expect(b).type.toBe<'one' | 'two' | 'three'>();\n    },\n    1000,\n  ),\n).type.toBe<void>();\n\nexpect(\n  test.each([3, 4, 'seven'])('some test', (c, done) => {\n    expect(c).type.toBe<string | number>();\n\n    expect(done).type.toBe<(reason?: string | Error) => void>();\n  }),\n).type.toBe<void>();\nexpect(\n  test.each([3, 4, 'seven'])(\n    'some test',\n    c => {\n      expect(c).type.toBe<string | number>();\n    },\n    1000,\n  ),\n).type.toBe<void>();\n\nexpect(\n  test.each(table)('some test', (a, b, expected) => {\n    expect(a).type.toBe<string | number>();\n    expect(b).type.toBe<string | number>();\n    expect(expected).type.toBe<string | number>();\n  }),\n).type.toBe<void>();\nexpect(\n  test.each(table)(\n    'some test',\n    (a, b, expected) => {\n      expect(a).type.toBe<string | number>();\n      expect(b).type.toBe<string | number>();\n      expect(expected).type.toBe<string | number>();\n    },\n    1000,\n  ),\n).type.toBe<void>();\n\nexpect(\n  test.each(tupleTable)('some test', (a, b, expected, extra) => {\n    expect(a).type.toBe<number>();\n    expect(b).type.toBe<number>();\n    expect(expected).type.toBe<string>();\n    expect(extra).type.toBe<boolean | undefined>();\n  }),\n).type.toBe<void>();\nexpect(\n  test.each(tupleTable)(\n    'some test',\n    (a, b, expected, extra) => {\n      expect(a).type.toBe<number>();\n      expect(b).type.toBe<number>();\n      expect(expected).type.toBe<string>();\n      expect(extra).type.toBe<boolean | undefined>();\n    },\n    1000,\n  ),\n).type.toBe<void>();\n\nexpect(\n  test.each([\n    [1, 2, 'three'],\n    [3, 4, 'seven'],\n  ])('some test', (a, b, expected) => {\n    expect(a).type.toBe<number>();\n    expect(b).type.toBe<number>();\n    expect(expected).type.toBe<string>();\n  }),\n).type.toBe<void>();\nexpect(\n  test.each([\n    [1, 2, 'three'],\n    [3, 4, 'seven'],\n  ])(\n    'some test',\n    (a, b, expected) => {\n      expect(a).type.toBe<number>();\n      expect(b).type.toBe<number>();\n      expect(expected).type.toBe<string>();\n    },\n    1000,\n  ),\n).type.toBe<void>();\n\nexpect(\n  test.each([\n    [1, 2, 'three'],\n    [3, 4, 'seven'],\n  ] as const)('some test', (a, b, expected) => {\n    expect(a).type.toBe<1 | 3>();\n    expect(b).type.toBe<2 | 4>();\n    expect(expected).type.toBe<'three' | 'seven'>();\n  }),\n).type.toBe<void>();\nexpect(\n  test.each([\n    [1, 2, 'three'],\n    [3, 4, 'seven'],\n  ] as const)(\n    'some test',\n    (a, b, expected) => {\n      expect(a).type.toBe<1 | 3>();\n      expect(b).type.toBe<2 | 4>();\n      expect(expected).type.toBe<'three' | 'seven'>();\n    },\n    1000,\n  ),\n).type.toBe<void>();\n\nexpect(\n  test.each(objectTable)('some test', ({a, b, expected, extra}, done) => {\n    expect(a).type.toBe<number>();\n    expect(b).type.toBe<number>();\n    expect(expected).type.toBe<string>();\n    expect(extra).type.toBe<boolean | undefined>();\n\n    expect(done).type.toBe<(reason?: string | Error) => void>();\n  }),\n).type.toBe<void>();\nexpect(\n  test.each([\n    {a: 1, b: 2, expected: 'three', extra: true},\n    {a: 3, b: 4, expected: 'seven', extra: false},\n    {a: 5, b: 6, expected: 'eleven'},\n  ])(\n    'some test',\n    ({a, b, expected, extra}, done) => {\n      expect(a).type.toBe<number>();\n      expect(b).type.toBe<number>();\n      expect(expected).type.toBe<string>();\n      expect(extra).type.toBe<boolean | undefined>();\n\n      expect(done).type.toBe<(reason?: string | Error) => void>();\n    },\n    1000,\n  ),\n).type.toBe<void>();\n\nexpect(\n  test.each`\n    a    | b    | expected\n    ${1} | ${1} | ${2}\n    ${1} | ${2} | ${3}\n    ${2} | ${1} | ${3}\n  `('some test', ({a, b, expected}, done) => {\n    expect(a).type.toBe<number>();\n    expect(b).type.toBe<number>();\n    expect(expected).type.toBe<number>();\n\n    expect(done).type.toBe<(reason?: string | Error) => void>();\n  }),\n).type.toBe<void>();\nexpect(\n  test.each`\n    item   | expected\n    ${'a'} | ${true}\n    ${'b'} | ${false}\n  `('some test', ({item, expected}) => {\n    expect(item).type.toBe<string | boolean>();\n    expect(expected).type.toBe<string | boolean>();\n  }),\n).type.toBe<void>();\nexpect(\n  test.each<{item: string; expected: boolean}>`\n    item   | expected\n    ${'a'} | ${true}\n    ${'b'} | ${false}\n  `('some test', ({item, expected}, done) => {\n    expect(item).type.toBe<string>();\n    expect(expected).type.toBe<boolean>();\n\n    expect(done).type.toBe<(reason?: string | Error) => void>();\n  }),\n).type.toBe<void>();\nexpect(\n  test.each`\n    a    | b    | expected\n    ${1} | ${1} | ${2}\n    ${1} | ${2} | ${3}\n    ${2} | ${1} | ${3}\n  `(\n    'some test',\n    ({a, b, expected}) => {\n      expect(a).type.toBe<number>();\n      expect(b).type.toBe<number>();\n      expect(expected).type.toBe<number>();\n    },\n    1000,\n  ),\n).type.toBe<void>();\nexpect(\n  test.each`\n    item   | expected\n    ${'a'} | ${true}\n    ${'b'} | ${false}\n  `(\n    'some test',\n    ({item, expected}) => {\n      expect(item).type.toBe<string | boolean>();\n      expect(expected).type.toBe<string | boolean>();\n    },\n    1000,\n  ),\n).type.toBe<void>();\nexpect(\n  test.each<{item: string; expected: boolean}>`\n    item   | expected\n    ${'a'} | ${true}\n    ${'b'} | ${false}\n  `(\n    'some test',\n    ({item, expected}) => {\n      expect(item).type.toBe<string>();\n      expect(expected).type.toBe<boolean>();\n    },\n    1000,\n  ),\n).type.toBe<void>();\n\nexpect(test.each).type.not.toBeCallableWith();\nexpect(test.each).type.not.toBeCallableWith('abc');\nexpect(test.each).type.not.toBeCallableWith(() => {});\n\nexpect(test.only.each).type.toBe(test.each);\nexpect(test.skip.each).type.toBe(test.each);\n\n// test.concurrent.each\n\nexpect(\n  test.concurrent.each(list)('some test', async a => {\n    expect(a).type.toBe<number>();\n  }),\n).type.toBe<void>();\nexpect(\n  test.concurrent.each(list)(\n    'some test',\n    async a => {\n      expect(a).type.toBe<number>();\n    },\n    1000,\n  ),\n).type.toBe<void>();\n\nexpect(\n  test.concurrent.each(tupleList)('some test', async b => {\n    expect(b).type.toBe<'one' | 'two' | 'three'>();\n  }),\n).type.toBe<void>();\nexpect(\n  test.concurrent.each(tupleList)(\n    'some test',\n    async b => {\n      expect(b).type.toBe<'one' | 'two' | 'three'>();\n    },\n    1000,\n  ),\n).type.toBe<void>();\n\nexpect(\n  test.concurrent.each([3, 4, 'seven'])('some test', async c => {\n    expect(c).type.toBe<string | number>();\n  }),\n).type.toBe<void>();\nexpect(\n  test.concurrent.each([3, 4, 'seven'])(\n    'some test',\n    async c => {\n      expect(c).type.toBe<string | number>();\n    },\n    1000,\n  ),\n).type.toBe<void>();\n\nexpect(\n  test.concurrent.each(table)('some test', async (a, b, expected) => {\n    expect(a).type.toBe<string | number>();\n    expect(b).type.toBe<string | number>();\n    expect(expected).type.toBe<string | number>();\n  }),\n).type.toBe<void>();\nexpect(\n  test.concurrent.each(table)(\n    'some test',\n    async (a, b, expected) => {\n      expect(a).type.toBe<string | number>();\n      expect(b).type.toBe<string | number>();\n      expect(expected).type.toBe<string | number>();\n    },\n    1000,\n  ),\n).type.toBe<void>();\n\nexpect(\n  test.concurrent.each(tupleTable)(\n    'some test',\n    async (a, b, expected, extra) => {\n      expect(a).type.toBe<number>();\n      expect(b).type.toBe<number>();\n      expect(expected).type.toBe<string>();\n      expect(extra).type.toBe<boolean | undefined>();\n    },\n  ),\n).type.toBe<void>();\nexpect(\n  test.concurrent.each(tupleTable)(\n    'some test',\n    async (a, b, expected, extra) => {\n      expect(a).type.toBe<number>();\n      expect(b).type.toBe<number>();\n      expect(expected).type.toBe<string>();\n      expect(extra).type.toBe<boolean | undefined>();\n    },\n    1000,\n  ),\n).type.toBe<void>();\n\nexpect(\n  test.concurrent.each`\n    a    | b    | expected\n    ${1} | ${1} | ${2}\n    ${1} | ${2} | ${3}\n    ${2} | ${1} | ${3}\n  `('some test', async ({a, b, expected}) => {\n    expect(a).type.toBe<number>();\n    expect(b).type.toBe<number>();\n    expect(expected).type.toBe<number>();\n  }),\n).type.toBe<void>();\nexpect(\n  test.concurrent.each`\n    item   | expected\n    ${'a'} | ${true}\n    ${'b'} | ${false}\n  `('some test', async ({item, expected}) => {\n    expect(item).type.toBe<string | boolean>();\n    expect(expected).type.toBe<string | boolean>();\n  }),\n).type.toBe<void>();\nexpect(\n  test.concurrent.each<{item: string; expected: boolean}>`\n    item   | expected\n    ${'a'} | ${true}\n    ${'b'} | ${false}\n  `('some test', async ({item, expected}) => {\n    expect(item).type.toBe<string>();\n    expect(expected).type.toBe<boolean>();\n  }),\n).type.toBe<void>();\nexpect(\n  test.concurrent.each`\n    a    | b    | expected\n    ${1} | ${1} | ${2}\n    ${1} | ${2} | ${3}\n    ${2} | ${1} | ${3}\n  `(\n    'some test',\n    async ({a, b, expected}) => {\n      expect(a).type.toBe<number>();\n      expect(b).type.toBe<number>();\n      expect(expected).type.toBe<number>();\n    },\n    1000,\n  ),\n).type.toBe<void>();\n\nexpect(\n  test.each`\n    item   | expected\n    ${'a'} | ${true}\n    ${'b'} | ${false}\n  `(\n    'some test',\n    ({item, expected}) => {\n      expect(item).type.toBe<string | boolean>();\n      expect(expected).type.toBe<string | boolean>();\n    },\n    1000,\n  ),\n).type.toBe<void>();\nexpect(\n  test.each<{item: string; expected: boolean}>`\n    item   | expected\n    ${'a'} | ${true}\n    ${'b'} | ${false}\n  `(\n    'some test',\n    ({item, expected}) => {\n      expect(item).type.toBe<string>();\n      expect(expected).type.toBe<boolean>();\n    },\n    1000,\n  ),\n).type.toBe<void>();\n\nexpect(test.concurrent.each).type.not.toBeCallableWith();\nexpect(test.concurrent.each).type.not.toBeCallableWith('abc');\nexpect(test.concurrent.each).type.not.toBeCallableWith(() => {});\n\nexpect(test.concurrent.only.each).type.toBe(test.concurrent.each);\nexpect(test.concurrent.skip.each).type.toBe(test.concurrent.each);\n\n// describe.each\n\nexpect(\n  describe.each(list)('describe each', a => {\n    expect(a).type.toBe<number>();\n  }),\n).type.toBe<void>();\nexpect(\n  describe.each(list)(\n    'describe each',\n    a => {\n      expect(a).type.toBe<number>();\n    },\n    1000,\n  ),\n).type.toBe<void>();\n\nexpect(\n  describe.each(tupleList)('describe each', b => {\n    expect(b).type.toBe<'one' | 'two' | 'three'>();\n  }),\n).type.toBe<void>();\nexpect(\n  describe.each(tupleList)(\n    'describe each',\n    b => {\n      expect(b).type.toBe<'one' | 'two' | 'three'>();\n    },\n    1000,\n  ),\n).type.toBe<void>();\n\nexpect(\n  describe.each([3, 4, 'seven'])('describe each', c => {\n    expect(c).type.toBe<string | number>();\n  }),\n).type.toBe<void>();\nexpect(\n  describe.each([3, 4, 'seven'])(\n    'describe each',\n    c => {\n      expect(c).type.toBe<string | number>();\n    },\n    1000,\n  ),\n).type.toBe<void>();\n\nexpect(\n  describe.each(table)('describe each', (a, b, expected) => {\n    expect(a).type.toBe<string | number>();\n    expect(b).type.toBe<string | number>();\n    expect(expected).type.toBe<string | number>();\n  }),\n).type.toBe<void>();\nexpect(\n  describe.each(table)(\n    'describe each',\n    (a, b, expected) => {\n      expect(a).type.toBe<string | number>();\n      expect(b).type.toBe<string | number>();\n      expect(expected).type.toBe<string | number>();\n    },\n    1000,\n  ),\n).type.toBe<void>();\n\nexpect(\n  describe.each(tupleTable)('describe each', (a, b, expected, extra) => {\n    expect(a).type.toBe<number>();\n    expect(b).type.toBe<number>();\n    expect(expected).type.toBe<string>();\n    expect(extra).type.toBe<boolean | undefined>();\n  }),\n).type.toBe<void>();\nexpect(\n  describe.each(tupleTable)(\n    'describe each',\n    (a, b, expected, extra) => {\n      expect(a).type.toBe<number>();\n      expect(b).type.toBe<number>();\n      expect(expected).type.toBe<string>();\n      expect(extra).type.toBe<boolean | undefined>();\n    },\n    1000,\n  ),\n).type.toBe<void>();\n\nexpect(\n  describe.each([\n    [1, 2, 'three'],\n    [3, 4, 'seven'],\n  ])('describe each', (a, b, expected) => {\n    expect(a).type.toBe<number>();\n    expect(b).type.toBe<number>();\n    expect(expected).type.toBe<string>();\n  }),\n).type.toBe<void>();\nexpect(\n  describe.each([\n    [1, 2, 'three'],\n    [3, 4, 'seven'],\n  ])(\n    'describe each',\n    (a, b, expected) => {\n      expect(a).type.toBe<number>();\n      expect(b).type.toBe<number>();\n      expect(expected).type.toBe<string>();\n    },\n    1000,\n  ),\n).type.toBe<void>();\n\nexpect(\n  describe.each([\n    [1, 2, 'three'],\n    [3, 4, 'seven'],\n  ] as const)('describe each', (a, b, expected) => {\n    expect(a).type.toBe<1 | 3>();\n    expect(b).type.toBe<2 | 4>();\n    expect(expected).type.toBe<'three' | 'seven'>();\n  }),\n).type.toBe<void>();\nexpect(\n  describe.each([\n    [1, 2, 'three'],\n    [3, 4, 'seven'],\n  ] as const)(\n    'describe each',\n    (a, b, expected) => {\n      expect(a).type.toBe<1 | 3>();\n      expect(b).type.toBe<2 | 4>();\n      expect(expected).type.toBe<'three' | 'seven'>();\n    },\n    1000,\n  ),\n).type.toBe<void>();\n\nexpect(\n  describe.each(objectTable)('describe each', ({a, b, expected, extra}) => {\n    expect(a).type.toBe<number>();\n    expect(b).type.toBe<number>();\n    expect(expected).type.toBe<string>();\n    expect(extra).type.toBe<boolean | undefined>();\n  }),\n).type.toBe<void>();\nexpect(\n  describe.each([\n    {a: 1, b: 2, expected: 'three', extra: true},\n    {a: 3, b: 4, expected: 'seven', extra: false},\n    {a: 5, b: 6, expected: 'eleven'},\n  ])(\n    'describe each',\n    ({a, b, expected, extra}) => {\n      expect(a).type.toBe<number>();\n      expect(b).type.toBe<number>();\n      expect(expected).type.toBe<string>();\n      expect(extra).type.toBe<boolean | undefined>();\n    },\n    1000,\n  ),\n).type.toBe<void>();\n\nexpect(\n  describe.each`\n    a    | b    | expected\n    ${1} | ${1} | ${2}\n    ${1} | ${2} | ${3}\n    ${2} | ${1} | ${3}\n  `('describe each', ({a, b, expected}) => {\n    expect(a).type.toBe<number>();\n    expect(b).type.toBe<number>();\n    expect(expected).type.toBe<number>();\n  }),\n).type.toBe<void>();\nexpect(\n  describe.each<{\n    a: number;\n    b: number;\n    expected: string;\n  }>`\n    a    | b    | expected\n    ${1} | ${1} | ${2}\n    ${1} | ${2} | ${3}\n    ${2} | ${1} | ${3}\n  `('describe each', ({a, b, expected}) => {\n    expect(a).type.toBe<number>();\n    expect(b).type.toBe<number>();\n    expect(expected).type.toBe<string>();\n  }),\n).type.toBe<void>();\nexpect(\n  describe.each`\n    a    | b    | expected\n    ${1} | ${1} | ${2}\n    ${1} | ${2} | ${3}\n    ${2} | ${1} | ${3}\n  `(\n    'describe each',\n    ({a, b, expected}) => {\n      expect(a).type.toBe<number>();\n      expect(b).type.toBe<number>();\n      expect(expected).type.toBe<number>();\n    },\n    1000,\n  ),\n).type.toBe<void>();\nexpect(\n  describe.each<{\n    a: number;\n    b: number;\n    expected: string;\n  }>`\n    a    | b    | expected\n    ${1} | ${1} | ${2}\n    ${1} | ${2} | ${3}\n    ${2} | ${1} | ${3}\n  `(\n    'describe each',\n    ({a, b, expected}) => {\n      expect(a).type.toBe<number>();\n      expect(b).type.toBe<number>();\n      expect(expected).type.toBe<string>();\n    },\n    1000,\n  ),\n).type.toBe<void>();\n\nexpect(describe.each).type.not.toBeCallableWith();\nexpect(describe.each).type.not.toBeCallableWith('abc');\nexpect(describe.each).type.not.toBeCallableWith(() => {});\n\nexpect(describe.only.each).type.toBe(describe.each);\nexpect(describe.skip.each).type.toBe(describe.each);\n",
  "packages/jest-types/__typetests__/each.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-types/__typetests__/config.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {describe, expect, test} from 'tstyche';\nimport type {Config} from 'jest';\n\nconst config: Config = {};\n\ndescribe('Config', () => {\n  test('coverageThreshold', () => {\n    expect(config).type.toBeAssignableWith({\n      coverageThreshold: {\n        './src/api/very-important-module.js': {\n          branches: 100,\n          functions: 100,\n          lines: 100,\n          statements: 100,\n        },\n        './src/components/': {\n          branches: 40,\n          statements: 40,\n        },\n        './src/reducers/**/*.js': {\n          statements: 90,\n        },\n        global: {\n          branches: 50,\n          functions: 50,\n          lines: 50,\n          statements: 50,\n        },\n      },\n    });\n  });\n\n  test('fakeTimers', () => {\n    const doNotFake = [\n      'Date' as const,\n      'hrtime' as const,\n      'nextTick' as const,\n      'performance' as const,\n      'queueMicrotask' as const,\n      'requestAnimationFrame' as const,\n      'cancelAnimationFrame' as const,\n      'requestIdleCallback' as const,\n      'cancelIdleCallback' as const,\n      'setImmediate' as const,\n      'clearImmediate' as const,\n      'setInterval' as const,\n      'clearInterval' as const,\n      'setTimeout' as const,\n      'clearTimeout' as const,\n    ];\n\n    expect(config).type.toBeAssignableWith({\n      fakeTimers: {\n        advanceTimers: true,\n        doNotFake,\n        enableGlobally: true,\n        now: 1_483_228_800_000,\n        timerLimit: 1000,\n      },\n    });\n\n    expect(config).type.toBeAssignableWith({\n      fakeTimers: {\n        advanceTimers: 40,\n        now: Date.now(),\n      },\n    });\n\n    expect(config).type.not.toBeAssignableWith({\n      fakeTimers: {\n        now: new Date(),\n      },\n    });\n\n    expect(config).type.toBeAssignableWith({\n      fakeTimers: {\n        enableGlobally: true,\n        legacyFakeTimers: true as const,\n      },\n    });\n\n    expect(config).type.not.toBeAssignableWith({\n      fakeTimers: {\n        advanceTimers: true,\n        legacyFakeTimers: true as const,\n      },\n    });\n\n    expect(config).type.not.toBeAssignableWith({\n      fakeTimers: {\n        doNotFake,\n        legacyFakeTimers: true as const,\n      },\n    });\n\n    expect(config).type.not.toBeAssignableWith({\n      fakeTimers: {\n        legacyFakeTimers: true as const,\n        now: 1_483_228_800_000,\n      },\n    });\n\n    expect(config).type.not.toBeAssignableWith({\n      fakeTimers: {\n        legacyFakeTimers: true as const,\n        timerLimit: 1000,\n      },\n    });\n  });\n\n  test('projects', () => {\n    expect(config).type.toBeAssignableWith({\n      projects: [\n        // projects can be globs or objects\n        './src/**',\n        {\n          displayName: 'A Project',\n          rootDir: './src/components',\n        },\n      ],\n    });\n  });\n});\n",
  "packages/jest-types/__typetests__/config.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-types/__typetests__/expect/toHaveBeenNthCalledWith.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {expect} from 'tstyche';\nimport {jest, expect as jestExpect} from '@jest/globals';\nimport type {overloaded} from './toHaveBeenCalledWith.test';\n\nexpect(jestExpect(jest.fn()).toHaveBeenNthCalledWith(2)).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn()).toHaveBeenNthCalledWith(1, 'value'),\n).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn()).toHaveBeenNthCalledWith(1, 'value', 123),\n).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn<(a: string, b: number) => void>()).toHaveBeenNthCalledWith(\n    1,\n    jestExpect.stringContaining('value'),\n    123,\n  ),\n).type.toBe<void>();\nexpect(jestExpect(jest.fn()).toHaveBeenNthCalledWith()).type.toRaiseError();\n\nexpect(jestExpect(jest.fn()).toHaveBeenNthCalledWith(2)).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn()).toHaveBeenNthCalledWith(1, 'value'),\n).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn()).toHaveBeenNthCalledWith(1, 'value', 123),\n).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn<(a: string, b: number) => void>()).toHaveBeenNthCalledWith(\n    1,\n    jestExpect.stringContaining('value'),\n    123,\n  ),\n).type.toBe<void>();\nexpect(jestExpect(jest.fn()).toHaveBeenNthCalledWith()).type.toRaiseError();\n\nexpect(\n  jestExpect(jest.fn<() => void>()).toHaveBeenNthCalledWith(1),\n).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn<() => void>()).toHaveBeenNthCalledWith(1, 123),\n).type.toRaiseError();\n\nexpect(jestExpect(() => {}).toHaveBeenNthCalledWith(1)).type.toBe<void>();\nexpect(\n  jestExpect(() => {}).toHaveBeenNthCalledWith(1, 123),\n).type.toRaiseError();\n\nexpect(\n  jestExpect(jest.fn<(n?: number) => void>()).toHaveBeenNthCalledWith(1),\n).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn<(n?: number) => void>()).toHaveBeenNthCalledWith(1, 123),\n).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn<(n?: number) => void>()).toHaveBeenNthCalledWith(\n    1,\n    'value',\n  ),\n).type.toRaiseError();\n\nexpect(\n  jestExpect(jest.fn<(n: number) => void>()).toHaveBeenNthCalledWith(1, 123),\n).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn<(n: number) => void>()).toHaveBeenNthCalledWith(1),\n).type.toRaiseError();\nexpect(\n  jestExpect(jest.fn<(n: number) => void>()).toHaveBeenNthCalledWith(\n    1,\n    'value',\n  ),\n).type.toRaiseError();\n\nexpect(\n  jestExpect((n: number) => {}).toHaveBeenNthCalledWith(1, 123),\n).type.toBe<void>();\nexpect(\n  jestExpect((n: number) => {}).toHaveBeenNthCalledWith(\n    1,\n    jestExpect.any(Number),\n  ),\n).type.toBe<void>();\nexpect(\n  jestExpect((n: number) => {}).toHaveBeenNthCalledWith(1),\n).type.toRaiseError();\nexpect(\n  jestExpect((n: number) => {}).toHaveBeenNthCalledWith(1, 'value'),\n).type.toRaiseError();\n\nexpect(\n  jestExpect(jest.fn<(s: string) => void>()).toHaveBeenNthCalledWith(\n    1,\n    'value',\n  ),\n).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn<(s: string) => void>()).toHaveBeenNthCalledWith(1),\n).type.toRaiseError();\nexpect(\n  jestExpect(jest.fn<(s: string) => void>()).toHaveBeenNthCalledWith(1, 123),\n).type.toRaiseError();\n\nexpect(\n  jestExpect(jest.fn<(n: number, s: string) => void>()).toHaveBeenNthCalledWith(\n    1,\n    123,\n    'value',\n  ),\n).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn<(n: number, s: string) => void>()).toHaveBeenNthCalledWith(\n    1,\n  ),\n).type.toRaiseError();\nexpect(\n  jestExpect(jest.fn<(n: number, s: string) => void>()).toHaveBeenNthCalledWith(\n    1,\n    123,\n  ),\n).type.toRaiseError();\nexpect(\n  jestExpect(jest.fn<(n: number, s: string) => void>()).toHaveBeenNthCalledWith(\n    1,\n    123,\n    123,\n  ),\n).type.toRaiseError();\nexpect(\n  jestExpect(jest.fn<(n: number, s: string) => void>()).toHaveBeenNthCalledWith(\n    1,\n    'value',\n    'value',\n  ),\n).type.toRaiseError();\nexpect(\n  jestExpect(jest.fn<(n: number, s: string) => void>()).toHaveBeenNthCalledWith(\n    1,\n    'value',\n    123,\n  ),\n).type.toRaiseError();\n\nexpect(\n  jestExpect(\n    jest.fn<(n: number, s?: string) => void>(),\n  ).toHaveBeenNthCalledWith(1, 123, 'value'),\n).type.toBe<void>();\nexpect(\n  jestExpect(\n    jest.fn<(n: number, s?: string) => void>(),\n  ).toHaveBeenNthCalledWith(1, 123),\n).type.toBe<void>();\nexpect(\n  jestExpect(\n    jest.fn<(n: number, s?: string) => void>(),\n  ).toHaveBeenNthCalledWith(1),\n).type.toRaiseError();\nexpect(\n  jestExpect(\n    jest.fn<(n: number, s?: string) => void>(),\n  ).toHaveBeenNthCalledWith(1, 'value'),\n).type.toRaiseError();\nexpect(\n  jestExpect(\n    jest.fn<(n: number, s?: string) => void>(),\n  ).toHaveBeenNthCalledWith(1, 'value', 'value'),\n).type.toRaiseError();\nexpect(\n  jestExpect(\n    jest.fn<(n: number, s?: string) => void>(),\n  ).toHaveBeenNthCalledWith(1, 'value', 123),\n).type.toRaiseError();\nexpect(\n  jestExpect(\n    jest.fn<(n: number, s?: string) => void>(),\n  ).toHaveBeenNthCalledWith(1, 123, 123),\n).type.toRaiseError();\n\nexpect(\n  jestExpect(jest.fn<typeof overloaded>()).toHaveBeenNthCalledWith(1),\n).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn<typeof overloaded>()).toHaveBeenNthCalledWith(1, 123),\n).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn<typeof overloaded>()).toHaveBeenNthCalledWith(\n    1,\n    123,\n    'value',\n  ),\n).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn<typeof overloaded>()).toHaveBeenNthCalledWith(\n    1,\n    123,\n    true,\n  ),\n).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn<typeof overloaded>()).toHaveBeenNthCalledWith(1, 123, 123),\n).type.toRaiseError();\nexpect(\n  jestExpect(jest.fn<typeof overloaded>()).toHaveBeenNthCalledWith(1, 'value'),\n).type.toRaiseError();\nexpect(\n  jestExpect(jest.fn<typeof overloaded>()).toHaveBeenNthCalledWith(1, true),\n).type.toRaiseError();\nexpect(\n  jestExpect(jest.fn<typeof overloaded>()).toHaveBeenNthCalledWith(\n    1,\n    'value',\n    'value',\n  ),\n).type.toRaiseError();\nexpect(\n  jestExpect(jest.fn<typeof overloaded>()).toHaveBeenNthCalledWith(\n    1,\n    true,\n    false,\n  ),\n).type.toRaiseError();\n\nexpect(\n  jestExpect(\n    jest.fn<(date: Date, name?: [string, string]) => void>(),\n  ).toHaveBeenNthCalledWith(1, jestExpect.any(Date), [\n    jestExpect.any(String),\n    jestExpect.any(String),\n  ]),\n).type.toBe<void>();\nexpect(\n  jestExpect(\n    jest.fn<(date: Date, name?: [string, string]) => void>(),\n  ).toHaveBeenNthCalledWith(1, jestExpect.any(Date), jestExpect.any(Array)),\n).type.toBe<void>();\nexpect(\n  jestExpect(\n    jest.fn<(date: Date, name?: [string, string]) => void>(),\n  ).toHaveBeenNthCalledWith(1, jestExpect.any(Date)),\n).type.toBe<void>();\nexpect(\n  jestExpect(\n    jest.fn<(date: Date, name?: [string, string]) => void>(),\n  ).toHaveBeenNthCalledWith(1, jestExpect.any(Date), []),\n).type.toRaiseError();\nexpect(\n  jestExpect(\n    jest.fn<(date: Date, name?: [string, string]) => void>(),\n  ).toHaveBeenNthCalledWith(1, jestExpect.any(Date), [jestExpect.any(String)]),\n).type.toRaiseError();\nexpect(\n  jestExpect(\n    jest.fn<(date: Date, name?: [string, string]) => void>(),\n  ).toHaveBeenNthCalledWith(1, jestExpect.any(Date), [\n    jestExpect.any(String),\n    123,\n  ]),\n).type.toRaiseError();\n\nexpect(\n  jestExpect(\n    jest.fn<(date: Date, name: {foo: string}) => void>(),\n  ).toHaveBeenNthCalledWith(1, jestExpect.any(Date), {\n    foo: jestExpect.any(String),\n  }),\n).type.toBe<void>();\nexpect(\n  jestExpect(\n    jest.fn<(date: Date, name: {foo: string}) => void>(),\n  ).toHaveBeenNthCalledWith(1, jestExpect.any(Date), jestExpect.any(Object)),\n).type.toBe<void>();\nexpect(\n  jestExpect(\n    jest.fn<(date: Date, name: {foo: string}) => void>(),\n  ).toHaveBeenNthCalledWith(1, jestExpect.any(Date)),\n).type.toRaiseError();\nexpect(\n  jestExpect(\n    jest.fn<(date: Date, name: {foo: string}) => void>(),\n  ).toHaveBeenNthCalledWith(1, jestExpect.any(Date), {\n    bar: jestExpect.any(String),\n  }),\n).type.toRaiseError();\nexpect(\n  jestExpect(\n    jest.fn<(date: Date, name: {foo: string}) => void>(),\n  ).toHaveBeenNthCalledWith(1, jestExpect.any(Date), {\n    bar: jestExpect.any(String),\n    foo: jestExpect.any(String),\n  }),\n).type.toRaiseError();\n\nexpect(\n  jestExpect(\n    jest.fn<(date: Date, name: [string, [string]]) => void>(),\n  ).toHaveBeenNthCalledWith(1, jestExpect.any(Date), [\n    jestExpect.any(String),\n    [jestExpect.any(String)],\n  ]),\n).type.toBe<void>();\nexpect(\n  jestExpect(\n    jest.fn<(date: Date, name: [string, [string]]) => void>(),\n  ).toHaveBeenNthCalledWith(1, jestExpect.any(Date), [\n    'value',\n    [jestExpect.any(String)],\n  ]),\n).type.toBe<void>();\nexpect(\n  jestExpect(\n    jest.fn<(date: Date, name: [string, [string]]) => void>(),\n  ).toHaveBeenNthCalledWith(1, jestExpect.any(Date), [\n    jestExpect.any(String),\n    ['value'],\n  ]),\n).type.toBe<void>();\nexpect(\n  jestExpect(\n    jest.fn<(date: Date, name: [string, [string]]) => void>(),\n  ).toHaveBeenNthCalledWith(1, jestExpect.any(Date), ['value', ['value']]),\n).type.toBe<void>();\n",
  "packages/jest-types/__typetests__/expect/toHaveBeenNthCalledWith.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-types/__typetests__/expect/toHaveBeenLastCalledWith.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {expect} from 'tstyche';\nimport {jest, expect as jestExpect} from '@jest/globals';\nimport type {overloaded} from './toHaveBeenCalledWith.test';\n\nexpect(jestExpect(jest.fn()).toHaveBeenLastCalledWith()).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn()).toHaveBeenLastCalledWith('value'),\n).type.toBe<void>();\nexpect(jestExpect(jest.fn()).toHaveBeenLastCalledWith(123)).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn()).toHaveBeenLastCalledWith(123, 'value'),\n).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn()).toHaveBeenLastCalledWith('value', 123),\n).type.toBe<void>();\nexpect(\n  jestExpect(\n    jest.fn<(a: string, b: number) => void>(),\n  ).toHaveBeenLastCalledWith(jestExpect.stringContaining('value'), 123),\n).type.toBe<void>();\n\nexpect(jestExpect(jest.fn()).toHaveBeenLastCalledWith()).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn()).toHaveBeenLastCalledWith('value'),\n).type.toBe<void>();\nexpect(jestExpect(jest.fn()).toHaveBeenLastCalledWith(123)).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn()).toHaveBeenLastCalledWith(123, 'value'),\n).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn()).toHaveBeenLastCalledWith('value', 123),\n).type.toBe<void>();\nexpect(\n  jestExpect(\n    jest.fn<(a: string, b: number) => void>(),\n  ).toHaveBeenLastCalledWith(jestExpect.stringContaining('value'), 123),\n).type.toBe<void>();\n\nexpect(\n  jestExpect(jest.fn<() => void>()).toHaveBeenLastCalledWith(),\n).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn<() => void>()).toHaveBeenLastCalledWith(1),\n).type.toRaiseError();\n\nexpect(jestExpect(() => {}).toHaveBeenLastCalledWith()).type.toBe<void>();\nexpect(jestExpect(() => {}).toHaveBeenLastCalledWith(123)).type.toRaiseError();\n\nexpect(\n  jestExpect(jest.fn<(n?: number) => void>()).toHaveBeenLastCalledWith(),\n).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn<(n?: number) => void>()).toHaveBeenLastCalledWith(123),\n).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn<(n?: number) => void>()).toHaveBeenLastCalledWith('value'),\n).type.toRaiseError();\n\nexpect(\n  jestExpect(jest.fn<(n: number) => void>()).toHaveBeenLastCalledWith(123),\n).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn<(n: number) => void>()).toHaveBeenLastCalledWith(),\n).type.toRaiseError();\nexpect(\n  jestExpect(jest.fn<(n: number) => void>()).toHaveBeenLastCalledWith('value'),\n).type.toRaiseError();\n\nexpect(\n  jestExpect((n: number) => {}).toHaveBeenLastCalledWith(123),\n).type.toBe<void>();\nexpect(\n  jestExpect((n: number) => {}).toHaveBeenLastCalledWith(\n    jestExpect.any(Number),\n  ),\n).type.toBe<void>();\nexpect(\n  jestExpect((n: number) => {}).toHaveBeenLastCalledWith(),\n).type.toRaiseError();\nexpect(\n  jestExpect((n: number) => {}).toHaveBeenLastCalledWith('value'),\n).type.toRaiseError();\n\nexpect(\n  jestExpect(jest.fn<(s: string) => void>()).toHaveBeenLastCalledWith('value'),\n).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn<(s: string) => void>()).toHaveBeenLastCalledWith(),\n).type.toRaiseError();\nexpect(\n  jestExpect(jest.fn<(s: string) => void>()).toHaveBeenLastCalledWith(123),\n).type.toRaiseError();\n\nexpect(\n  jestExpect(\n    jest.fn<(n: number, s: string) => void>(),\n  ).toHaveBeenLastCalledWith(123, 'value'),\n).type.toBe<void>();\nexpect(\n  jestExpect(\n    jest.fn<(n: number, s: string) => void>(),\n  ).toHaveBeenLastCalledWith(),\n).type.toRaiseError();\nexpect(\n  jestExpect(\n    jest.fn<(n: number, s: string) => void>(),\n  ).toHaveBeenLastCalledWith(123),\n).type.toRaiseError();\nexpect(\n  jestExpect(\n    jest.fn<(n: number, s: string) => void>(),\n  ).toHaveBeenLastCalledWith(123, 123),\n).type.toRaiseError();\nexpect(\n  jestExpect(\n    jest.fn<(n: number, s: string) => void>(),\n  ).toHaveBeenLastCalledWith('value', 'value'),\n).type.toRaiseError();\nexpect(\n  jestExpect(\n    jest.fn<(n: number, s: string) => void>(),\n  ).toHaveBeenLastCalledWith('value', 123),\n).type.toRaiseError();\n\nexpect(\n  jestExpect(\n    jest.fn<(n: number, s?: string) => void>(),\n  ).toHaveBeenLastCalledWith(123, 'value'),\n).type.toBe<void>();\nexpect(\n  jestExpect(\n    jest.fn<(n: number, s?: string) => void>(),\n  ).toHaveBeenLastCalledWith(123),\n).type.toBe<void>();\nexpect(\n  jestExpect(\n    jest.fn<(n: number, s?: string) => void>(),\n  ).toHaveBeenLastCalledWith(),\n).type.toRaiseError();\nexpect(\n  jestExpect(\n    jest.fn<(n: number, s?: string) => void>(),\n  ).toHaveBeenLastCalledWith('value'),\n).type.toRaiseError();\nexpect(\n  jestExpect(\n    jest.fn<(n: number, s?: string) => void>(),\n  ).toHaveBeenLastCalledWith('value', 'value'),\n).type.toRaiseError();\nexpect(\n  jestExpect(\n    jest.fn<(n: number, s?: string) => void>(),\n  ).toHaveBeenLastCalledWith('value', 123),\n).type.toRaiseError();\nexpect(\n  jestExpect(\n    jest.fn<(n: number, s?: string) => void>(),\n  ).toHaveBeenLastCalledWith(123, 123),\n).type.toRaiseError();\n\nexpect(\n  jestExpect(jest.fn<typeof overloaded>()).toHaveBeenLastCalledWith(),\n).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn<typeof overloaded>()).toHaveBeenLastCalledWith(123),\n).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn<typeof overloaded>()).toHaveBeenLastCalledWith(\n    123,\n    'value',\n  ),\n).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn<typeof overloaded>()).toHaveBeenLastCalledWith(123, true),\n).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn<typeof overloaded>()).toHaveBeenLastCalledWith(123, 123),\n).type.toRaiseError();\nexpect(\n  jestExpect(jest.fn<typeof overloaded>()).toHaveBeenLastCalledWith('value'),\n).type.toRaiseError();\nexpect(\n  jestExpect(jest.fn<typeof overloaded>()).toHaveBeenLastCalledWith(true),\n).type.toRaiseError();\nexpect(\n  jestExpect(jest.fn<typeof overloaded>()).toHaveBeenLastCalledWith(\n    'value',\n    'value',\n  ),\n).type.toRaiseError();\nexpect(\n  jestExpect(jest.fn<typeof overloaded>()).toHaveBeenLastCalledWith(\n    true,\n    false,\n  ),\n).type.toRaiseError();\n\nexpect(\n  jestExpect(\n    jest.fn<(date: Date, name?: [string, string]) => void>(),\n  ).toHaveBeenLastCalledWith(jestExpect.any(Date), [\n    jestExpect.any(String),\n    jestExpect.any(String),\n  ]),\n).type.toBe<void>();\nexpect(\n  jestExpect(\n    jest.fn<(date: Date, name?: [string, string]) => void>(),\n  ).toHaveBeenLastCalledWith(jestExpect.any(Date), jestExpect.any(Array)),\n).type.toBe<void>();\nexpect(\n  jestExpect(\n    jest.fn<(date: Date, name?: [string, string]) => void>(),\n  ).toHaveBeenLastCalledWith(jestExpect.any(Date)),\n).type.toBe<void>();\nexpect(\n  jestExpect(\n    jest.fn<(date: Date, name?: [string, string]) => void>(),\n  ).toHaveBeenLastCalledWith(jestExpect.any(Date), []),\n).type.toRaiseError();\nexpect(\n  jestExpect(\n    jest.fn<(date: Date, name?: [string, string]) => void>(),\n  ).toHaveBeenLastCalledWith(jestExpect.any(Date), [jestExpect.any(String)]),\n).type.toRaiseError();\nexpect(\n  jestExpect(\n    jest.fn<(date: Date, name?: [string, string]) => void>(),\n  ).toHaveBeenLastCalledWith(jestExpect.any(Date), [\n    jestExpect.any(String),\n    123,\n  ]),\n).type.toRaiseError();\n\nexpect(\n  jestExpect(\n    jest.fn<(date: Date, name: {foo: string}) => void>(),\n  ).toHaveBeenLastCalledWith(jestExpect.any(Date), {\n    foo: jestExpect.any(String),\n  }),\n).type.toBe<void>();\nexpect(\n  jestExpect(\n    jest.fn<(date: Date, name: {foo: string}) => void>(),\n  ).toHaveBeenLastCalledWith(jestExpect.any(Date), jestExpect.any(Object)),\n).type.toBe<void>();\nexpect(\n  jestExpect(\n    jest.fn<(date: Date, name: {foo: string}) => void>(),\n  ).toHaveBeenLastCalledWith(jestExpect.any(Date)),\n).type.toRaiseError();\nexpect(\n  jestExpect(\n    jest.fn<(date: Date, name: {foo: string}) => void>(),\n  ).toHaveBeenLastCalledWith(jestExpect.any(Date), {\n    bar: jestExpect.any(String),\n  }),\n).type.toRaiseError();\nexpect(\n  jestExpect(\n    jest.fn<(date: Date, name: {foo: string}) => void>(),\n  ).toHaveBeenLastCalledWith(jestExpect.any(Date), {\n    bar: jestExpect.any(String),\n    foo: jestExpect.any(String),\n  }),\n).type.toRaiseError();\n\nexpect(\n  jestExpect(\n    jest.fn<(date: Date, name: [string, [string]]) => void>(),\n  ).toHaveBeenLastCalledWith(jestExpect.any(Date), [\n    jestExpect.any(String),\n    [jestExpect.any(String)],\n  ]),\n).type.toBe<void>();\nexpect(\n  jestExpect(\n    jest.fn<(date: Date, name: [string, [string]]) => void>(),\n  ).toHaveBeenLastCalledWith(jestExpect.any(Date), [\n    'value',\n    [jestExpect.any(String)],\n  ]),\n).type.toBe<void>();\nexpect(\n  jestExpect(\n    jest.fn<(date: Date, name: [string, [string]]) => void>(),\n  ).toHaveBeenLastCalledWith(jestExpect.any(Date), [\n    jestExpect.any(String),\n    ['value'],\n  ]),\n).type.toBe<void>();\nexpect(\n  jestExpect(\n    jest.fn<(date: Date, name: [string, [string]]) => void>(),\n  ).toHaveBeenLastCalledWith(jestExpect.any(Date), ['value', ['value']]),\n).type.toBe<void>();\n",
  "packages/jest-types/__typetests__/expect/toHaveBeenLastCalledWith.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-types/__typetests__/expect/toHaveBeenCalledWith.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {expect} from 'tstyche';\nimport {jest, expect as jestExpect} from '@jest/globals';\n\nexport function overloaded(): void;\n// eslint-disable-next-line @typescript-eslint/unified-signatures\nexport function overloaded(n: number): void;\n// eslint-disable-next-line @typescript-eslint/unified-signatures\nexport function overloaded(n: number, s: string): void;\n// eslint-disable-next-line @typescript-eslint/unified-signatures\nexport function overloaded(n: number, b: boolean): void;\nexport function overloaded(n?: number, sOrB?: string | boolean): void {\n  // noop\n}\n\nexpect(\n  jestExpect(jest.fn()).toHaveBeenCalledWith(jestExpect.anything()),\n).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn()).toHaveBeenCalledWith(jestExpect.anything(true)),\n).type.toRaiseError();\n\nexpect(jestExpect(jest.fn()).toHaveBeenCalledWith()).type.toBe<void>();\nexpect(jestExpect(jest.fn()).toHaveBeenCalledWith(123)).type.toBe<void>();\nexpect(jestExpect(jest.fn()).toHaveBeenCalledWith('value')).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn()).toHaveBeenCalledWith(123, 'value'),\n).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn()).toHaveBeenCalledWith('value', 123),\n).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn<(a: string, b: number) => void>()).toHaveBeenCalledWith(\n    jestExpect.stringContaining('value'),\n    123,\n  ),\n).type.toBe<void>();\n\nexpect(jestExpect(jest.fn()).toHaveBeenCalledWith()).type.toBe<void>();\nexpect(jestExpect(jest.fn()).toHaveBeenCalledWith(123)).type.toBe<void>();\nexpect(jestExpect(jest.fn()).toHaveBeenCalledWith('value')).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn()).toHaveBeenCalledWith(123, 'value'),\n).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn()).toHaveBeenCalledWith('value', 123),\n).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn<(a: string, b: number) => void>()).toHaveBeenCalledWith(\n    jestExpect.stringContaining('value'),\n    123,\n  ),\n).type.toBe<void>();\n\nexpect(\n  jestExpect(jest.fn<() => void>()).toHaveBeenCalledWith(),\n).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn<() => void>()).toHaveBeenCalledWith(123),\n).type.toRaiseError();\n\nexpect(jestExpect(() => {}).toHaveBeenCalledWith()).type.toBe<void>();\nexpect(jestExpect(() => {}).toHaveBeenCalledWith(123)).type.toRaiseError();\n\nexpect(\n  jestExpect(jest.fn<(n?: number) => void>()).toHaveBeenCalledWith(),\n).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn<(n?: number) => void>()).toHaveBeenCalledWith(123),\n).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn<(n?: number) => void>()).toHaveBeenCalledWith('value'),\n).type.toRaiseError();\n\nexpect(\n  jestExpect(jest.fn<(n: number) => void>()).toHaveBeenCalledWith(123),\n).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn<(n: number) => void>()).toHaveBeenCalledWith(),\n).type.toRaiseError();\nexpect(\n  jestExpect(jest.fn<(n: number) => void>()).toHaveBeenCalledWith('value'),\n).type.toRaiseError();\n\nexpect(\n  jestExpect((n: number) => {}).toHaveBeenCalledWith(123),\n).type.toBe<void>();\nexpect(\n  jestExpect((n: number) => {}).toHaveBeenCalledWith(jestExpect.any(Number)),\n).type.toBe<void>();\nexpect(\n  jestExpect((n: number) => {}).toHaveBeenCalledWith(),\n).type.toRaiseError();\nexpect(\n  jestExpect((n: number) => {}).toHaveBeenCalledWith('value'),\n).type.toRaiseError();\n\nexpect(\n  jestExpect(jest.fn<(s: string) => void>()).toHaveBeenCalledWith('value'),\n).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn<(s: string) => void>()).toHaveBeenCalledWith(),\n).type.toRaiseError();\nexpect(\n  jestExpect(jest.fn<(s: string) => void>()).toHaveBeenCalledWith(123),\n).type.toRaiseError();\n\nexpect(\n  jestExpect(jest.fn<(n: number, s: string) => void>()).toHaveBeenCalledWith(\n    123,\n    'value',\n  ),\n).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn<(n: number, s: string) => void>()).toHaveBeenCalledWith(),\n).type.toRaiseError();\nexpect(\n  jestExpect(jest.fn<(n: number, s: string) => void>()).toHaveBeenCalledWith(\n    123,\n  ),\n).type.toRaiseError();\nexpect(\n  jestExpect(jest.fn<(n: number, s: string) => void>()).toHaveBeenCalledWith(\n    123,\n    123,\n  ),\n).type.toRaiseError();\nexpect(\n  jestExpect(jest.fn<(n: number, s: string) => void>()).toHaveBeenCalledWith(\n    'value',\n    'value',\n  ),\n).type.toRaiseError();\nexpect(\n  jestExpect(jest.fn<(n: number, s: string) => void>()).toHaveBeenCalledWith(\n    'value',\n    123,\n  ),\n).type.toRaiseError();\n\nexpect(\n  jestExpect(jest.fn<(n: number, s?: string) => void>()).toHaveBeenCalledWith(\n    123,\n    'value',\n  ),\n).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn<(n: number, s?: string) => void>()).toHaveBeenCalledWith(\n    123,\n  ),\n).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn<(n: number, s?: string) => void>()).toHaveBeenCalledWith(),\n).type.toRaiseError();\nexpect(\n  jestExpect(jest.fn<(n: number, s?: string) => void>()).toHaveBeenCalledWith(\n    'value',\n  ),\n).type.toRaiseError();\nexpect(\n  jestExpect(jest.fn<(n: number, s?: string) => void>()).toHaveBeenCalledWith(\n    'value',\n    'value',\n  ),\n).type.toRaiseError();\nexpect(\n  jestExpect(jest.fn<(n: number, s?: string) => void>()).toHaveBeenCalledWith(\n    'value',\n    123,\n  ),\n).type.toRaiseError();\nexpect(\n  jestExpect(jest.fn<(n: number, s?: string) => void>()).toHaveBeenCalledWith(\n    123,\n    123,\n  ),\n).type.toRaiseError();\n\nexpect(\n  jestExpect(jest.fn<typeof overloaded>()).toHaveBeenCalledWith(),\n).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn<typeof overloaded>()).toHaveBeenCalledWith(123),\n).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn<typeof overloaded>()).toHaveBeenCalledWith(123, 'value'),\n).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn<typeof overloaded>()).toHaveBeenCalledWith(123, true),\n).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn<typeof overloaded>()).toHaveBeenCalledWith(123, 123),\n).type.toRaiseError();\nexpect(\n  jestExpect(jest.fn<typeof overloaded>()).toHaveBeenCalledWith('value'),\n).type.toRaiseError();\nexpect(\n  jestExpect(jest.fn<typeof overloaded>()).toHaveBeenCalledWith(true),\n).type.toRaiseError();\nexpect(\n  jestExpect(jest.fn<typeof overloaded>()).toHaveBeenCalledWith(\n    'value',\n    'value',\n  ),\n).type.toRaiseError();\nexpect(\n  jestExpect(jest.fn<typeof overloaded>()).toHaveBeenCalledWith(true, false),\n).type.toRaiseError();\n\nexpect(\n  jestExpect(\n    jest.fn<(date: Date, name?: [string, string]) => void>(),\n  ).toHaveBeenCalledWith(jestExpect.any(Date), [\n    jestExpect.any(String),\n    jestExpect.any(String),\n  ]),\n).type.toBe<void>();\nexpect(\n  jestExpect(\n    jest.fn<(date: Date, name?: [string, string]) => void>(),\n  ).toHaveBeenCalledWith(jestExpect.any(Date), jestExpect.any(Array)),\n).type.toBe<void>();\nexpect(\n  jestExpect(\n    jest.fn<(date: Date, name?: [string, string]) => void>(),\n  ).toHaveBeenCalledWith(jestExpect.any(Date)),\n).type.toBe<void>();\nexpect(\n  jestExpect(\n    jest.fn<(date: Date, name?: [string, string]) => void>(),\n  ).toHaveBeenCalledWith(jestExpect.any(Date), []),\n).type.toRaiseError();\nexpect(\n  jestExpect(\n    jest.fn<(date: Date, name?: [string, string]) => void>(),\n  ).toHaveBeenCalledWith(jestExpect.any(Date), [jestExpect.any(String)]),\n).type.toRaiseError();\nexpect(\n  jestExpect(\n    jest.fn<(date: Date, name?: [string, string]) => void>(),\n  ).toHaveBeenCalledWith(jestExpect.any(Date), [jestExpect.any(String), 123]),\n).type.toRaiseError();\n\nexpect(\n  jestExpect(\n    jest.fn<(date: Date, name: {foo: string}) => void>(),\n  ).toHaveBeenCalledWith(jestExpect.any(Date), {foo: jestExpect.any(String)}),\n).type.toBe<void>();\nexpect(\n  jestExpect(\n    jest.fn<(date: Date, name: {foo: string}) => void>(),\n  ).toHaveBeenCalledWith(jestExpect.any(Date), jestExpect.any(Object)),\n).type.toBe<void>();\nexpect(\n  jestExpect(\n    jest.fn<(date: Date, name: {foo: string}) => void>(),\n  ).toHaveBeenCalledWith(jestExpect.any(Date)),\n).type.toRaiseError();\nexpect(\n  jestExpect(\n    jest.fn<(date: Date, name: {foo: string}) => void>(),\n  ).toHaveBeenCalledWith(jestExpect.any(Date), {bar: jestExpect.any(String)}),\n).type.toRaiseError();\nexpect(\n  jestExpect(\n    jest.fn<(date: Date, name: {foo: string}) => void>(),\n  ).toHaveBeenCalledWith(jestExpect.any(Date), {\n    bar: jestExpect.any(String),\n    foo: jestExpect.any(String),\n  }),\n).type.toRaiseError();\n\nexpect(\n  jestExpect(\n    jest.fn<(date: Date, name: [string, [string]]) => void>(),\n  ).toHaveBeenCalledWith(jestExpect.any(Date), [\n    jestExpect.any(String),\n    [jestExpect.any(String)],\n  ]),\n).type.toBe<void>();\nexpect(\n  jestExpect(\n    jest.fn<(date: Date, name: [string, [string]]) => void>(),\n  ).toHaveBeenCalledWith(jestExpect.any(Date), [\n    'value',\n    [jestExpect.any(String)],\n  ]),\n).type.toBe<void>();\nexpect(\n  jestExpect(\n    jest.fn<(date: Date, name: [string, [string]]) => void>(),\n  ).toHaveBeenCalledWith(jestExpect.any(Date), [\n    jestExpect.any(String),\n    ['value'],\n  ]),\n).type.toBe<void>();\nexpect(\n  jestExpect(\n    jest.fn<(date: Date, name: [string, [string]]) => void>(),\n  ).toHaveBeenCalledWith(jestExpect.any(Date), ['value', ['value']]),\n).type.toBe<void>();\n",
  "packages/jest-types/__typetests__/expect/toHaveBeenCalledWith.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport declare function overloaded(): void;\nexport declare function overloaded(n: number): void;\nexport declare function overloaded(n: number, s: string): void;\nexport declare function overloaded(n: number, b: boolean): void;\n",
  "packages/jest-types/__typetests__/expect/base.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {expect} from 'tstyche';\nimport type {EqualsFunction, Tester} from '@jest/expect-utils';\nimport {jest, expect as jestExpect} from '@jest/globals';\nimport type * as jestMatcherUtils from 'jest-matcher-utils';\n\n// asymmetric matchers\n\nexpect(jestExpect('value').toEqual(jestExpect.any(String))).type.toBe<void>();\nexpect(jestExpect(123).toEqual(jestExpect.any())).type.toRaiseError();\nexpect(jestExpect.not).type.not.toHaveProperty('any');\n\nexpect(jestExpect.not).type.not.toHaveProperty('anything');\n\nexpect(\n  jestExpect(['A', 'B']).toEqual(jestExpect.arrayContaining(['A'])),\n).type.toBe<void>();\nexpect(\n  jestExpect(['A']).toEqual(jestExpect.arrayContaining('A')),\n).type.toRaiseError();\nexpect(\n  jestExpect(['A']).toEqual(jestExpect.arrayContaining()),\n).type.toRaiseError();\nexpect(\n  jestExpect(['B']).toEqual(jestExpect.not.arrayContaining(['A'])),\n).type.toBe<void>();\nexpect(\n  jestExpect(['A']).toEqual(jestExpect.not.arrayContaining('A')),\n).type.toRaiseError();\nexpect(\n  jestExpect(['A']).toEqual(jestExpect.not.arrayContaining()),\n).type.toRaiseError();\n\nexpect(\n  jestExpect(0.1 + 0.2).toEqual(jestExpect.closeTo(0.3)),\n).type.toBe<void>();\nexpect(\n  jestExpect(0.1 + 0.2).toEqual(jestExpect.closeTo(0.3, 5)),\n).type.toBe<void>();\nexpect(\n  jestExpect(0.1 + 0.2).toEqual(jestExpect.closeTo('three')),\n).type.toRaiseError();\nexpect(\n  jestExpect(0.1 + 0.2).toEqual(jestExpect.closeTo(0.3, false)),\n).type.toRaiseError();\nexpect(jestExpect(0.1 + 0.2).toEqual(jestExpect.closeTo())).type.toRaiseError();\nexpect(\n  jestExpect(0.1 + 0.2).toEqual(jestExpect.not.closeTo(0.3)),\n).type.toBe<void>();\nexpect(\n  jestExpect(0.1 + 0.2).toEqual(jestExpect.not.closeTo(0.3, 5)),\n).type.toBe<void>();\nexpect(\n  jestExpect(0.1 + 0.2).toEqual(jestExpect.not.closeTo('three')),\n).type.toRaiseError();\nexpect(\n  jestExpect(0.1 + 0.2).toEqual(jestExpect.not.closeTo(0.3, false)),\n).type.toRaiseError();\nexpect(\n  jestExpect(0.1 + 0.2).toEqual(jestExpect.not.closeTo()),\n).type.toRaiseError();\n\nexpect(\n  jestExpect({a: 1}).toEqual(jestExpect.objectContaining({a: 1})),\n).type.toBe<void>();\nexpect(\n  jestExpect({a: 1}).toEqual(jestExpect.objectContaining(1)),\n).type.toRaiseError();\nexpect(\n  jestExpect({a: 1}).toEqual(jestExpect.objectContaining()),\n).type.toRaiseError();\nexpect(\n  jestExpect({b: 2}).toEqual(jestExpect.not.objectContaining({a: 1})),\n).type.toBe<void>();\nexpect(\n  jestExpect({a: 1}).toEqual(jestExpect.not.objectContaining(1)),\n).type.toRaiseError();\nexpect(\n  jestExpect({a: 1}).toEqual(jestExpect.not.objectContaining()),\n).type.toRaiseError();\n\nexpect(\n  jestExpect('one').toEqual(jestExpect.stringContaining('n')),\n).type.toBe<void>();\nexpect(\n  jestExpect('two').toEqual(jestExpect.stringContaining(2)),\n).type.toRaiseError();\nexpect(\n  jestExpect('three').toEqual(jestExpect.stringContaining()),\n).type.toRaiseError();\nexpect(\n  jestExpect('one').toEqual(jestExpect.not.stringContaining('m')),\n).type.toBe<void>();\nexpect(\n  jestExpect('two').toEqual(jestExpect.not.stringContaining(2)),\n).type.toRaiseError();\nexpect(\n  jestExpect('three').toEqual(jestExpect.not.stringContaining()),\n).type.toRaiseError();\n\nexpect(\n  jestExpect('one').toEqual(jestExpect.stringMatching(/^[No]ne/)),\n).type.toBe<void>();\nexpect(\n  jestExpect('one').toEqual(jestExpect.stringMatching(2)),\n).type.toRaiseError();\nexpect(\n  jestExpect('one').toEqual(jestExpect.stringMatching()),\n).type.toRaiseError();\nexpect(\n  jestExpect('two').toEqual(jestExpect.not.stringMatching(/^[No]ne/)),\n).type.toBe<void>();\nexpect(\n  jestExpect('two').toEqual(jestExpect.not.stringMatching(1)),\n).type.toRaiseError();\nexpect(\n  jestExpect('two').toEqual(jestExpect.not.stringMatching()),\n).type.toRaiseError();\n\n// modifiers and utilities\n\nexpect(jestExpect.assertions(2)).type.toBe<void>();\nexpect(jestExpect.assertions()).type.toRaiseError();\n\nexpect(jestExpect.hasAssertions()).type.toBe<void>();\nexpect(jestExpect.hasAssertions(true)).type.toRaiseError();\n\nexpect(jestExpect(Promise.resolve('lemon')).resolves.toBe('lemon')).type.toBe<\n  Promise<void>\n>();\n\nexpect(\n  jestExpect(Promise.resolve('lemon')).resolves.not.toBe('lemon'),\n).type.toBe<Promise<void>>();\n\nexpect(\n  jestExpect(Promise.reject(new Error('octopus'))).rejects.toThrow('octopus'),\n).type.toBe<Promise<void>>();\n\nexpect(\n  jestExpect(Promise.reject(new Error('octopus'))).rejects.not.toThrow(\n    'octopus',\n  ),\n).type.toBe<Promise<void>>();\n\nexpect(jestExpect(1).not).type.not.toHaveProperty('not');\nexpect(jestExpect(1).not).type.not.toHaveProperty('resolves');\nexpect(jestExpect(1).not).type.not.toHaveProperty('rejects');\n\nexpect(jestExpect(1).resolves).type.not.toHaveProperty('resolves');\nexpect(jestExpect(1).resolves).type.not.toHaveProperty('rejects');\n\nexpect(jestExpect(1).resolves.not).type.not.toHaveProperty('not');\nexpect(jestExpect(1).resolves.not).type.not.toHaveProperty('resolves');\nexpect(jestExpect(1).resolves.not).type.not.toHaveProperty('rejects');\n\nexpect(jestExpect(1).rejects).type.not.toHaveProperty('resolves');\nexpect(jestExpect(1).rejects).type.not.toHaveProperty('rejects');\n\nexpect(jestExpect(1).rejects.not).type.not.toHaveProperty('not');\nexpect(jestExpect(1).rejects.not).type.not.toHaveProperty('resolves');\nexpect(jestExpect(1).rejects.not).type.not.toHaveProperty('rejects');\n\n// equality and relational matchers\n\nexpect(jestExpect(2).toBe(2)).type.toBe<void>();\nexpect(jestExpect('three').not.toBe('four')).type.toBe<void>();\nexpect(jestExpect(false).toBe()).type.toRaiseError();\n\nexpect(jestExpect(0.2 + 0.1).toBeCloseTo(0.3)).type.toBe<void>();\nexpect(jestExpect(0.2 + 0.1).toBeCloseTo(0.3, 5)).type.toBe<void>();\nexpect(jestExpect(0.2 + 0.1).toBeCloseTo()).type.toRaiseError();\nexpect(jestExpect(0.2 + 0.1).toBeCloseTo('three')).type.toRaiseError();\nexpect(\n  jestExpect(BigInt(0.2 + 0.1)).toBeCloseTo(BigInt(0.3)),\n).type.toRaiseError();\nexpect(jestExpect(0.2 + 0.1).toBeCloseTo(0.3, false)).type.toRaiseError();\n\nexpect(jestExpect('value').toBeDefined()).type.toBe<void>();\nexpect(jestExpect(true).not.toBeDefined(false)).type.toRaiseError();\n\nexpect(jestExpect(0).toBeFalsy()).type.toBe<void>();\nexpect(jestExpect(true).not.toBeFalsy(true)).type.toRaiseError();\n\nexpect(jestExpect(10).toBeGreaterThan(5)).type.toBe<void>();\nexpect(\n  jestExpect(BigInt(5.65)).toBeGreaterThan(BigInt(5.61)),\n).type.toBe<void>();\nexpect(jestExpect(10).toBeGreaterThan()).type.toRaiseError();\nexpect(jestExpect(10).toBeGreaterThan('1')).type.toRaiseError();\n\nexpect(jestExpect(10).toBeGreaterThanOrEqual(5)).type.toBe<void>();\nexpect(\n  jestExpect(BigInt(5.65)).toBeGreaterThanOrEqual(BigInt(5.61)),\n).type.toBe<void>();\nexpect(jestExpect(10).toBeGreaterThanOrEqual()).type.toRaiseError();\nexpect(jestExpect(10).toBeGreaterThanOrEqual('1')).type.toRaiseError();\n\nexpect(jestExpect(5).toBeLessThan(10)).type.toBe<void>();\nexpect(jestExpect(BigInt(5.61)).toBeLessThan(BigInt(5.65))).type.toBe<void>();\nexpect(jestExpect(1).toBeLessThan()).type.toRaiseError();\nexpect(jestExpect(1).toBeLessThan('10')).type.toRaiseError();\n\nexpect(jestExpect(5).toBeLessThanOrEqual(10)).type.toBe<void>();\nexpect(\n  jestExpect(BigInt(5.61)).toBeLessThanOrEqual(BigInt(5.65)),\n).type.toBe<void>();\nexpect(jestExpect(1).toBeLessThanOrEqual()).type.toRaiseError();\nexpect(jestExpect(1).toBeLessThanOrEqual('10')).type.toRaiseError();\n\nexpect(jestExpect(() => {}).toBeInstanceOf(Function)).type.toBe<void>();\nexpect(jestExpect(() => {}).toBeInstanceOf()).type.toRaiseError();\n\nexpect(jestExpect(Number('ten')).toBeNaN()).type.toBe<void>();\nexpect(jestExpect(Number('10')).not.toBeNaN(true)).type.toRaiseError();\n\nexpect(jestExpect(null).toBeNull()).type.toBe<void>();\nexpect(jestExpect('not null').not.toBeNull(true)).type.toRaiseError();\n\nexpect(jestExpect('true').toBeTruthy()).type.toBe<void>();\nexpect(jestExpect(false).not.toBeTruthy(true)).type.toRaiseError();\n\nexpect(jestExpect(undefined).toBeUndefined()).type.toBe<void>();\nexpect(jestExpect('value').not.toBeUndefined(false)).type.toRaiseError();\n\nexpect(jestExpect(['lemon', 'lime']).not.toContain('orange')).type.toBe<void>();\nexpect(jestExpect('citrus fruits').toContain('fruit')).type.toBe<void>();\n\nconst a = {key1: true, key2: false};\nexpect(\n  jestExpect([{key1: true, key2: false}]).toContainEqual(a),\n).type.toBe<void>();\n\nexpect(jestExpect({a: 1, b: undefined}).toEqual({a: 1})).type.toBe<void>();\nexpect(jestExpect({a: 1}).toEqual()).type.toRaiseError();\n\nexpect(jestExpect({a: 1, b: 2}).toStrictEqual({a: 1, b: 2})).type.toBe<void>();\nexpect(jestExpect({a: 1}).toStrictEqual()).type.toRaiseError();\n\nexpect(jestExpect([1, 2, 3]).toHaveLength(3)).type.toBe<void>();\nexpect(jestExpect('abc').not.toHaveLength(5)).type.toBe<void>();\nexpect(jestExpect('abc').toHaveLength()).type.toRaiseError();\n\nexpect(\n  jestExpect({kitchen: {area: 20}}).toHaveProperty('kitchen.area', 20),\n).type.toBe<void>();\nexpect(\n  jestExpect({kitchen: {area: 20}}).not.toHaveProperty(['kitchen', 'color']),\n).type.toBe<void>();\nexpect(jestExpect({kitchen: {area: 20}}).toHaveProperty()).type.toRaiseError();\nexpect(\n  jestExpect({kitchen: {area: 20}}).toHaveProperty(true),\n).type.toRaiseError();\n\nexpect(jestExpect('grapefruits').toMatch(/fruit/)).type.toBe<void>();\nexpect(jestExpect('grapefruits').toMatch('fruit')).type.toBe<void>();\nexpect(jestExpect('grapefruits').toMatch(true)).type.toRaiseError();\n\nexpect(jestExpect({a: 1, b: 2}).toMatchObject({b: 2})).type.toBe<void>();\nexpect(\n  jestExpect([{a: 1}, {b: 2, c: true}]).toMatchObject([{a: 1}, {b: 2}]),\n).type.toBe<void>();\nexpect(jestExpect({c: true}).toMatchObject(true)).type.toRaiseError();\nexpect(jestExpect({c: true}).toMatchObject()).type.toRaiseError();\n\n// error matchers\n\nexpect(jestExpect(() => {}).toThrow()).type.toBe<void>();\nexpect(jestExpect(() => {}).toThrow(/error/)).type.toBe<void>();\nexpect(jestExpect(() => {}).toThrow('error')).type.toBe<void>();\nexpect(jestExpect(() => {}).toThrow(Error)).type.toBe<void>();\nexpect(jestExpect(() => {}).toThrow(new Error('error'))).type.toBe<void>();\n\n// mock matchers\nexpect(jestExpect(jest.fn()).toHaveBeenCalled()).type.toBe<void>();\nexpect(jestExpect(jest.fn()).toHaveBeenCalled(false)).type.toRaiseError();\nexpect(jestExpect(jest.fn()).toHaveBeenCalled('value')).type.toRaiseError();\n\nexpect(jestExpect(jest.fn()).toHaveBeenCalledTimes(3)).type.toBe<void>();\nexpect(jestExpect(jest.fn()).toHaveBeenCalledTimes(true)).type.toRaiseError();\nexpect(\n  jestExpect(jest.fn()).toHaveBeenCalledTimes('twice'),\n).type.toRaiseError();\nexpect(jestExpect(jest.fn()).toHaveBeenCalledTimes()).type.toRaiseError();\n\nexpect(jestExpect(jest.fn()).toHaveReturned()).type.toBe<void>();\nexpect(jestExpect(jest.fn()).toHaveReturned('value')).type.toRaiseError();\nexpect(jestExpect(jest.fn()).toHaveReturned(false)).type.toRaiseError();\n\nexpect(jestExpect(jest.fn()).toHaveReturnedTimes(3)).type.toBe<void>();\nexpect(jestExpect(jest.fn()).toHaveReturnedTimes('twice')).type.toRaiseError();\nexpect(jestExpect(jest.fn()).toHaveReturnedTimes(true)).type.toRaiseError();\nexpect(jestExpect(jest.fn()).toHaveReturnedTimes()).type.toRaiseError();\n\nexpect(jestExpect(jest.fn()).toHaveReturnedWith()).type.toBe<void>();\nexpect(jestExpect(jest.fn()).toHaveReturnedWith('value')).type.toBe<void>();\nexpect(jestExpect(jest.fn()).toHaveReturnedWith(123)).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn<() => string>()).toHaveReturnedWith(\n    jestExpect.stringContaining('value'),\n  ),\n).type.toBe<void>();\n\nexpect(jestExpect(jest.fn()).toHaveLastReturnedWith()).type.toBe<void>();\nexpect(jestExpect(jest.fn()).toHaveLastReturnedWith(123)).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn<() => string>()).toHaveLastReturnedWith(\n    jestExpect.stringContaining('value'),\n  ),\n).type.toBe<void>();\n\nexpect(jestExpect(jest.fn()).toHaveNthReturnedWith(1)).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn()).toHaveNthReturnedWith(1, 'value'),\n).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn<() => string>()).toHaveNthReturnedWith(\n    2,\n    jestExpect.stringContaining('value'),\n  ),\n).type.toBe<void>();\nexpect(jestExpect(jest.fn()).toHaveNthReturnedWith()).type.toRaiseError();\n\n// snapshot matchers\n\nexpect(jestExpect({a: 1}).toMatchSnapshot()).type.toBe<void>();\nexpect(jestExpect({a: 1}).toMatchSnapshot('hint')).type.toBe<void>();\nexpect(jestExpect({a: 1}).toMatchSnapshot(true)).type.toRaiseError();\n\nexpect(\n  jestExpect({\n    date: new Date(),\n    name: 'John Doe',\n  }).toMatchSnapshot({\n    date: jestExpect.any(Date),\n    name: jestExpect.any(String),\n  }),\n).type.toBe<void>();\n\nexpect(\n  jestExpect({\n    date: new Date(),\n    name: 'John Doe',\n  }).toMatchSnapshot(\n    {\n      date: jestExpect.any(Date),\n      name: jestExpect.any(String),\n    },\n    'hint',\n  ),\n).type.toBe<void>();\n\nexpect(\n  jestExpect({\n    date: new Date(),\n    name: 'John Doe',\n  }).toMatchSnapshot({\n    date: jestExpect.any(Date),\n    time: jestExpect.any(Date),\n  }),\n).type.toRaiseError();\n\nexpect(jestExpect('abc').toMatchInlineSnapshot()).type.toBe<void>();\nexpect(\n  jestExpect('abc').toMatchInlineSnapshot('inline snapshot here'),\n).type.toBe<void>();\nexpect(jestExpect('abc').toMatchInlineSnapshot(true)).type.toRaiseError();\n\nexpect(\n  jestExpect({\n    date: new Date(),\n    name: 'John Doe',\n  }).toMatchInlineSnapshot({\n    date: jestExpect.any(Date),\n    name: jestExpect.any(String),\n  }),\n).type.toBe<void>();\n\nexpect(\n  jestExpect({\n    date: new Date(),\n    name: 'John Doe',\n  }).toMatchInlineSnapshot(\n    {\n      date: jestExpect.any(Date),\n      name: jestExpect.any(String),\n    },\n    'inline snapshot here',\n  ),\n).type.toBe<void>();\n\nexpect(\n  jestExpect({\n    date: new Date(),\n    name: 'John Doe',\n  }).toMatchInlineSnapshot({\n    date: jestExpect.any(Date),\n    time: jestExpect.any(Date),\n  }),\n).type.toRaiseError();\n\nexpect(jestExpect(jest.fn()).toThrowErrorMatchingSnapshot()).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn()).toThrowErrorMatchingSnapshot('hint'),\n).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn()).toThrowErrorMatchingSnapshot(true),\n).type.toRaiseError();\n\nexpect(\n  jestExpect(jest.fn()).toThrowErrorMatchingInlineSnapshot(),\n).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn()).toThrowErrorMatchingInlineSnapshot(\n    'inline snapshot here',\n  ),\n).type.toBe<void>();\nexpect(\n  jestExpect(jest.fn()).toThrowErrorMatchingInlineSnapshot(true),\n).type.toRaiseError();\n\n// extend\n\ntype MatcherUtils = typeof jestMatcherUtils & {\n  iterableEquality: Tester;\n  subsetEquality: Tester;\n};\n\nexpect(\n  jestExpect.extend({\n    toBeWithinRange(actual: number, floor: number, ceiling: number) {\n      expect(this.assertionCalls).type.toBe<number>();\n      expect(this.currentTestName).type.toBe<string | undefined>();\n      expect(this.dontThrow).type.toBe<() => void>();\n      expect(this.error).type.toBe<Error | undefined>();\n      expect(this.equals).type.toBe<EqualsFunction>();\n      expect(this.expand).type.toBe<boolean | undefined>();\n      expect(this.expectedAssertionsNumber).type.toBe<number | null>();\n      expect(this.expectedAssertionsNumberError).type.toBe<Error | undefined>();\n      expect(this.isExpectingAssertions).type.toBe<boolean>();\n      expect(this.isExpectingAssertionsError).type.toBe<Error | undefined>();\n      expect(this.isNot).type.toBe<boolean | undefined>();\n      expect(this.numPassingAsserts).type.toBe<number>();\n      expect(this.promise).type.toBe<string | undefined>();\n      expect(this.suppressedErrors).type.toBe<Array<Error>>();\n      expect(this.testPath).type.toBe<string | undefined>();\n      expect(this.utils).type.toBe<MatcherUtils>();\n\n      const pass = actual >= floor && actual <= ceiling;\n      if (pass) {\n        return {\n          message: () =>\n            `expected ${actual} not to be within range ${floor} - ${ceiling}`,\n          pass: true,\n        };\n      } else {\n        return {\n          message: () =>\n            `expected ${actual} to be within range ${floor} - ${ceiling}`,\n          pass: false,\n        };\n      }\n    },\n  }),\n).type.toBe<void>();\n\ndeclare module 'expect' {\n  interface AsymmetricMatchers {\n    toBeWithinRange(floor: number, ceiling: number): void;\n  }\n  interface Matchers<R> {\n    toBeWithinRange(floor: number, ceiling: number): R;\n  }\n}\n\nexpect(jestExpect(100).toBeWithinRange(90, 110)).type.toBe<void>();\nexpect(jestExpect(101).not.toBeWithinRange(0, 100)).type.toBe<void>();\n\nexpect(\n  jestExpect({apples: 6, bananas: 3}).toEqual({\n    apples: jestExpect.toBeWithinRange(1, 10),\n    bananas: jestExpect.not.toBeWithinRange(11, 20),\n  }),\n).type.toBe<void>();\n",
  "packages/jest-types/__typetests__/expect/base.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\ndeclare module 'expect' {\n    interface AsymmetricMatchers {\n        toBeWithinRange(floor: number, ceiling: number): void;\n    }\n    interface Matchers<R> {\n        toBeWithinRange(floor: number, ceiling: number): R;\n    }\n}\nexport {};\n",
  "packages/jest-transform/src/types.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {EncodedSourceMap} from '@jridgewell/trace-mapping';\nimport type {Config, TransformTypes} from '@jest/types';\n\nexport interface ShouldInstrumentOptions\n  extends Pick<\n    Config.GlobalConfig,\n    'collectCoverage' | 'collectCoverageFrom' | 'coverageProvider'\n  > {\n  changedFiles?: Set<string>;\n  sourcesRelatedToTestsInChangedFiles?: Set<string>;\n}\n\nexport interface Options\n  extends ShouldInstrumentOptions,\n    CallerTransformOptions {\n  isInternalModule?: boolean;\n}\n\n// `babel` and `@jridgewell/trace-mapping` disagrees - `number` vs `3`\nexport interface FixedRawSourceMap extends Omit<EncodedSourceMap, 'version'> {\n  version: number;\n}\n\nexport type TransformedSource = {\n  code: string;\n  map?: FixedRawSourceMap | string | null;\n};\n\nexport type TransformResult = TransformTypes.TransformResult;\n\nexport interface CallerTransformOptions {\n  // names are copied from babel: https://babeljs.io/docs/en/options#caller\n  supportsDynamicImport: boolean;\n  supportsExportNamespaceFrom: boolean;\n  supportsStaticESM: boolean;\n  supportsTopLevelAwait: boolean;\n}\n\nexport interface ReducedTransformOptions extends CallerTransformOptions {\n  instrument: boolean;\n}\n\nexport interface RequireAndTranspileModuleOptions\n  extends ReducedTransformOptions {\n  applyInteropRequireDefault: boolean;\n}\n\nexport type StringMap = Map<string, string>;\n\nexport interface TransformOptions<TransformerConfig = unknown>\n  extends ReducedTransformOptions {\n  /** Cached file system which is used by `jest-runtime` to improve performance. */\n  cacheFS: StringMap;\n  /** Jest configuration of currently running project. */\n  config: Config.ProjectConfig;\n  /** Stringified version of the `config` - useful in cache busting. */\n  configString: string;\n  /** Transformer configuration passed through `transform` option by the user. */\n  transformerConfig: TransformerConfig;\n}\n\nexport interface SyncTransformer<TransformerConfig = unknown> {\n  /**\n   * Indicates if the transformer is capable of instrumenting the code for code coverage.\n   *\n   * If V8 coverage is _not_ active, and this is `true`, Jest will assume the code is instrumented.\n   * If V8 coverage is _not_ active, and this is `false`. Jest will instrument the code returned by this transformer using Babel.\n   */\n  canInstrument?: boolean;\n\n  getCacheKey?: (\n    sourceText: string,\n    sourcePath: string,\n    options: TransformOptions<TransformerConfig>,\n  ) => string;\n\n  getCacheKeyAsync?: (\n    sourceText: string,\n    sourcePath: string,\n    options: TransformOptions<TransformerConfig>,\n  ) => Promise<string>;\n\n  process: (\n    sourceText: string,\n    sourcePath: string,\n    options: TransformOptions<TransformerConfig>,\n  ) => TransformedSource;\n\n  processAsync?: (\n    sourceText: string,\n    sourcePath: string,\n    options: TransformOptions<TransformerConfig>,\n  ) => Promise<TransformedSource>;\n}\n\nexport interface AsyncTransformer<TransformerConfig = unknown> {\n  /**\n   * Indicates if the transformer is capable of instrumenting the code for code coverage.\n   *\n   * If V8 coverage is _not_ active, and this is `true`, Jest will assume the code is instrumented.\n   * If V8 coverage is _not_ active, and this is `false`. Jest will instrument the code returned by this transformer using Babel.\n   */\n  canInstrument?: boolean;\n\n  getCacheKey?: (\n    sourceText: string,\n    sourcePath: string,\n    options: TransformOptions<TransformerConfig>,\n  ) => string;\n\n  getCacheKeyAsync?: (\n    sourceText: string,\n    sourcePath: string,\n    options: TransformOptions<TransformerConfig>,\n  ) => Promise<string>;\n\n  process?: (\n    sourceText: string,\n    sourcePath: string,\n    options: TransformOptions<TransformerConfig>,\n  ) => TransformedSource;\n\n  processAsync: (\n    sourceText: string,\n    sourcePath: string,\n    options: TransformOptions<TransformerConfig>,\n  ) => Promise<TransformedSource>;\n}\n\n/**\n * We have both sync (`process`) and async (`processAsync`) code transformation, which both can be provided.\n * `require` will always use `process`, and `import` will use `processAsync` if it exists, otherwise fall back to `process`.\n * Meaning, if you use `import` exclusively you do not need `process`, but in most cases supplying both makes sense:\n * Jest transpiles on demand rather than ahead of time, so the sync one needs to exist.\n *\n * For more info on the sync vs async model, see https://jestjs.io/docs/code-transformation#writing-custom-transformers\n */\nexport type Transformer<TransformerConfig = unknown> =\n  | SyncTransformer<TransformerConfig>\n  | AsyncTransformer<TransformerConfig>;\n\nexport type TransformerCreator<\n  X extends Transformer<TransformerConfig>,\n  TransformerConfig = unknown,\n> = (transformerConfig?: TransformerConfig) => X | Promise<X>;\n\n/**\n * Instead of having your custom transformer implement the Transformer interface\n * directly, you can choose to export a factory function to dynamically create\n * transformers. This is to allow having a transformer config in your jest config.\n */\nexport type TransformerFactory<X extends Transformer> = {\n  createTransformer: TransformerCreator<X>;\n};\n",
  "packages/jest-transform/src/types.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { EncodedSourceMap } from '@jridgewell/trace-mapping';\nimport type { Config, TransformTypes } from '@jest/types';\nexport interface ShouldInstrumentOptions extends Pick<Config.GlobalConfig, 'collectCoverage' | 'collectCoverageFrom' | 'coverageProvider'> {\n    changedFiles?: Set<string>;\n    sourcesRelatedToTestsInChangedFiles?: Set<string>;\n}\nexport interface Options extends ShouldInstrumentOptions, CallerTransformOptions {\n    isInternalModule?: boolean;\n}\nexport interface FixedRawSourceMap extends Omit<EncodedSourceMap, 'version'> {\n    version: number;\n}\nexport type TransformedSource = {\n    code: string;\n    map?: FixedRawSourceMap | string | null;\n};\nexport type TransformResult = TransformTypes.TransformResult;\nexport interface CallerTransformOptions {\n    supportsDynamicImport: boolean;\n    supportsExportNamespaceFrom: boolean;\n    supportsStaticESM: boolean;\n    supportsTopLevelAwait: boolean;\n}\nexport interface ReducedTransformOptions extends CallerTransformOptions {\n    instrument: boolean;\n}\nexport interface RequireAndTranspileModuleOptions extends ReducedTransformOptions {\n    applyInteropRequireDefault: boolean;\n}\nexport type StringMap = Map<string, string>;\nexport interface TransformOptions<TransformerConfig = unknown> extends ReducedTransformOptions {\n    /** Cached file system which is used by `jest-runtime` to improve performance. */\n    cacheFS: StringMap;\n    /** Jest configuration of currently running project. */\n    config: Config.ProjectConfig;\n    /** Stringified version of the `config` - useful in cache busting. */\n    configString: string;\n    /** Transformer configuration passed through `transform` option by the user. */\n    transformerConfig: TransformerConfig;\n}\nexport interface SyncTransformer<TransformerConfig = unknown> {\n    /**\n     * Indicates if the transformer is capable of instrumenting the code for code coverage.\n     *\n     * If V8 coverage is _not_ active, and this is `true`, Jest will assume the code is instrumented.\n     * If V8 coverage is _not_ active, and this is `false`. Jest will instrument the code returned by this transformer using Babel.\n     */\n    canInstrument?: boolean;\n    getCacheKey?: (sourceText: string, sourcePath: string, options: TransformOptions<TransformerConfig>) => string;\n    getCacheKeyAsync?: (sourceText: string, sourcePath: string, options: TransformOptions<TransformerConfig>) => Promise<string>;\n    process: (sourceText: string, sourcePath: string, options: TransformOptions<TransformerConfig>) => TransformedSource;\n    processAsync?: (sourceText: string, sourcePath: string, options: TransformOptions<TransformerConfig>) => Promise<TransformedSource>;\n}\nexport interface AsyncTransformer<TransformerConfig = unknown> {\n    /**\n     * Indicates if the transformer is capable of instrumenting the code for code coverage.\n     *\n     * If V8 coverage is _not_ active, and this is `true`, Jest will assume the code is instrumented.\n     * If V8 coverage is _not_ active, and this is `false`. Jest will instrument the code returned by this transformer using Babel.\n     */\n    canInstrument?: boolean;\n    getCacheKey?: (sourceText: string, sourcePath: string, options: TransformOptions<TransformerConfig>) => string;\n    getCacheKeyAsync?: (sourceText: string, sourcePath: string, options: TransformOptions<TransformerConfig>) => Promise<string>;\n    process?: (sourceText: string, sourcePath: string, options: TransformOptions<TransformerConfig>) => TransformedSource;\n    processAsync: (sourceText: string, sourcePath: string, options: TransformOptions<TransformerConfig>) => Promise<TransformedSource>;\n}\n/**\n * We have both sync (`process`) and async (`processAsync`) code transformation, which both can be provided.\n * `require` will always use `process`, and `import` will use `processAsync` if it exists, otherwise fall back to `process`.\n * Meaning, if you use `import` exclusively you do not need `process`, but in most cases supplying both makes sense:\n * Jest transpiles on demand rather than ahead of time, so the sync one needs to exist.\n *\n * For more info on the sync vs async model, see https://jestjs.io/docs/code-transformation#writing-custom-transformers\n */\nexport type Transformer<TransformerConfig = unknown> = SyncTransformer<TransformerConfig> | AsyncTransformer<TransformerConfig>;\nexport type TransformerCreator<X extends Transformer<TransformerConfig>, TransformerConfig = unknown> = (transformerConfig?: TransformerConfig) => X | Promise<X>;\n/**\n * Instead of having your custom transformer implement the Transformer interface\n * directly, you can choose to export a factory function to dynamically create\n * transformers. This is to allow having a transformer config in your jest config.\n */\nexport type TransformerFactory<X extends Transformer> = {\n    createTransformer: TransformerCreator<X>;\n};\n",
  "packages/jest-transform/src/shouldInstrument.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport micromatch from 'micromatch';\nimport type {Config} from '@jest/types';\nimport {escapePathForRegex} from 'jest-regex-util';\nimport {globsToMatcher, replacePathSepForGlob} from 'jest-util';\nimport type {ShouldInstrumentOptions} from './types';\n\nconst MOCKS_PATTERN = new RegExp(\n  escapePathForRegex(`${path.sep}__mocks__${path.sep}`),\n);\n\nconst cachedRegexes = new Map<string, RegExp>();\nconst getRegex = (regexStr: string) => {\n  if (!cachedRegexes.has(regexStr)) {\n    cachedRegexes.set(regexStr, new RegExp(regexStr));\n  }\n\n  const regex = cachedRegexes.get(regexStr)!;\n\n  // prevent stateful regexes from breaking, just in case\n  regex.lastIndex = 0;\n\n  return regex;\n};\n\nexport default function shouldInstrument(\n  filename: string,\n  options: ShouldInstrumentOptions,\n  config: Config.ProjectConfig,\n  loadedFilenames?: Array<string>,\n): boolean {\n  if (!options.collectCoverage) {\n    return false;\n  }\n\n  if (\n    config.forceCoverageMatch.length > 0 &&\n    micromatch.any(filename, config.forceCoverageMatch)\n  ) {\n    return true;\n  }\n\n  if (\n    !config.testPathIgnorePatterns.some(pattern =>\n      getRegex(pattern).test(filename),\n    )\n  ) {\n    if (config.testRegex.some(regex => new RegExp(regex).test(filename))) {\n      return false;\n    }\n\n    if (globsToMatcher(config.testMatch)(replacePathSepForGlob(filename))) {\n      return false;\n    }\n  }\n\n  if (\n    options.collectCoverageFrom.length === 0 &&\n    loadedFilenames != null &&\n    !loadedFilenames.includes(filename)\n  ) {\n    return false;\n  }\n\n  if (\n    // still cover if `only` is specified\n    options.collectCoverageFrom.length > 0 &&\n    !globsToMatcher(options.collectCoverageFrom)(\n      replacePathSepForGlob(path.relative(config.rootDir, filename)),\n    )\n  ) {\n    return false;\n  }\n\n  if (\n    config.coveragePathIgnorePatterns.some(pattern =>\n      new RegExp(pattern).test(filename),\n    )\n  ) {\n    return false;\n  }\n\n  if (config.globalSetup === filename) {\n    return false;\n  }\n\n  if (config.globalTeardown === filename) {\n    return false;\n  }\n\n  if (config.setupFiles.includes(filename)) {\n    return false;\n  }\n\n  if (config.setupFilesAfterEnv.includes(filename)) {\n    return false;\n  }\n\n  if (MOCKS_PATTERN.test(filename)) {\n    return false;\n  }\n\n  if (options.changedFiles && !options.changedFiles.has(filename)) {\n    if (!options.sourcesRelatedToTestsInChangedFiles) {\n      return false;\n    }\n    if (!options.sourcesRelatedToTestsInChangedFiles.has(filename)) {\n      return false;\n    }\n  }\n\n  if (filename.endsWith('.json')) {\n    return false;\n  }\n\n  return true;\n}\n",
  "packages/jest-transform/src/shouldInstrument.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config } from '@jest/types';\nimport type { ShouldInstrumentOptions } from './types';\nexport default function shouldInstrument(filename: string, options: ShouldInstrumentOptions, config: Config.ProjectConfig, loadedFilenames?: Array<string>): boolean;\n",
  "packages/jest-transform/src/runtimeErrorsAndWarnings.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk from 'chalk';\nimport slash from 'slash';\n\nconst BULLET = '\\u25CF ';\nconst DOCUMENTATION_NOTE = `  ${chalk.bold(\n  'Code Transformation Documentation:',\n)}\n  https://jestjs.io/docs/code-transformation\n`;\nconst UPGRADE_NOTE = `  ${chalk.bold(\n  'This error may be caused by a breaking change in Jest 28:',\n)}\n  https://jest-archive-august-2023.netlify.app/docs/28.x/upgrading-to-jest28#transformer\n`;\n\nexport const makeInvalidReturnValueError = (transformPath: string): string =>\n  chalk.red(\n    [\n      chalk.bold(`${BULLET}Invalid return value:`),\n      '  `process()` or/and `processAsync()` method of code transformer found at ',\n      `  \"${slash(transformPath)}\" `,\n      '  should return an object or a Promise resolving to an object. The object ',\n      '  must have `code` property with a string of processed code.',\n      '',\n    ].join('\\n') +\n      UPGRADE_NOTE +\n      DOCUMENTATION_NOTE,\n  );\n\nexport const makeInvalidSourceMapWarning = (\n  filename: string,\n  transformPath: string,\n): string =>\n  chalk.yellow(\n    [\n      chalk.bold(`${BULLET}Invalid source map:`),\n      `  The source map for \"${slash(filename)}\" returned by \"${slash(\n        transformPath,\n      )}\" is invalid.`,\n      '  Proceeding without source mapping for that file.',\n    ].join('\\n'),\n  );\n\nexport const makeInvalidSyncTransformerError = (\n  transformPath: string,\n): string =>\n  chalk.red(\n    [\n      chalk.bold(`${BULLET}Invalid synchronous transformer module:`),\n      `  \"${slash(\n        transformPath,\n      )}\" specified in the \"transform\" object of Jest configuration`,\n      '  must export a `process` function.',\n      '',\n    ].join('\\n') + DOCUMENTATION_NOTE,\n  );\n\nexport const makeInvalidTransformerError = (transformPath: string): string =>\n  chalk.red(\n    [\n      chalk.bold(`${BULLET}Invalid transformer module:`),\n      `  \"${slash(\n        transformPath,\n      )}\" specified in the \"transform\" object of Jest configuration`,\n      '  must export a `process` or `processAsync` or `createTransformer` function.',\n      '',\n    ].join('\\n') + DOCUMENTATION_NOTE,\n  );\n",
  "packages/jest-transform/src/runtimeErrorsAndWarnings.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport declare const makeInvalidReturnValueError: (transformPath: string) => string;\nexport declare const makeInvalidSourceMapWarning: (filename: string, transformPath: string) => string;\nexport declare const makeInvalidSyncTransformerError: (transformPath: string) => string;\nexport declare const makeInvalidTransformerError: (transformPath: string) => string;\n",
  "packages/jest-transform/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nexport {\n  createScriptTransformer,\n  createTranspilingRequire,\n} from './ScriptTransformer';\nexport type {TransformerType as ScriptTransformer} from './ScriptTransformer';\nexport {default as shouldInstrument} from './shouldInstrument';\nexport type {\n  CallerTransformOptions,\n  Transformer,\n  SyncTransformer,\n  AsyncTransformer,\n  ShouldInstrumentOptions,\n  Options as TransformationOptions,\n  TransformerCreator,\n  TransformOptions,\n  TransformResult,\n  TransformedSource,\n  TransformerFactory,\n} from './types';\nexport {default as handlePotentialSyntaxError} from './enhanceUnexpectedTokenMessage';\n",
  "packages/jest-transform/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport { createScriptTransformer, createTranspilingRequire, } from './ScriptTransformer';\nexport type { TransformerType as ScriptTransformer } from './ScriptTransformer';\nexport { default as shouldInstrument } from './shouldInstrument';\nexport type { CallerTransformOptions, Transformer, SyncTransformer, AsyncTransformer, ShouldInstrumentOptions, Options as TransformationOptions, TransformerCreator, TransformOptions, TransformResult, TransformedSource, TransformerFactory, } from './types';\nexport { default as handlePotentialSyntaxError } from './enhanceUnexpectedTokenMessage';\n",
  "packages/jest-transform/src/enhanceUnexpectedTokenMessage.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk from 'chalk';\n\nconst DOT = ' \\u2022 ';\n\ninterface ErrorWithCodeFrame extends Error {\n  codeFrame?: string;\n}\n\nexport default function handlePotentialSyntaxError(\n  e: ErrorWithCodeFrame,\n): ErrorWithCodeFrame {\n  if (e.codeFrame != null) {\n    e.stack = `${e.message}\\n${e.codeFrame}`;\n  }\n\n  if (\n    // `instanceof` might come from the wrong context\n    e.name === 'SyntaxError' &&\n    !e.message.includes(' expected')\n  ) {\n    throw enhanceUnexpectedTokenMessage(e);\n  }\n\n  return e;\n}\n\nexport function enhanceUnexpectedTokenMessage(e: Error): Error {\n  e.stack = `${chalk.bold.red('Jest encountered an unexpected token')}\n\nJest failed to parse a file. This happens e.g. when your code or its dependencies use non-standard JavaScript syntax, or when Jest is not configured to support such syntax.\n\nOut of the box Jest supports Babel, which will be used to transform your files into valid JS based on your Babel configuration.\n\nBy default \"node_modules\" folder is ignored by transformers.\n\nHere's what you can do:\n${DOT}If you are trying to use ECMAScript Modules, see ${chalk.underline(\n    'https://jestjs.io/docs/ecmascript-modules',\n  )} for how to enable it.\n${DOT}If you are trying to use TypeScript, see ${chalk.underline(\n    'https://jestjs.io/docs/getting-started#using-typescript',\n  )}\n${DOT}To have some of your \"node_modules\" files transformed, you can specify a custom ${chalk.bold(\n    '\"transformIgnorePatterns\"',\n  )} in your config.\n${DOT}If you need a custom transformation, specify a ${chalk.bold(\n    '\"transform\"',\n  )} option in your config.\n${DOT}If you simply want to mock your non-JS modules (e.g. binary assets) you can stub them out with the ${chalk.bold(\n    '\"moduleNameMapper\"',\n  )} config option.\n\nYou'll find more details and examples of these config options in the docs:\n${chalk.cyan('https://jestjs.io/docs/configuration')}\nFor information about custom transformations, see:\n${chalk.cyan('https://jestjs.io/docs/code-transformation')}\n\n${chalk.bold.red('Details:')}\n\n${e.stack ?? ''}`.trimEnd();\n\n  return e;\n}\n",
  "packages/jest-transform/src/enhanceUnexpectedTokenMessage.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\ninterface ErrorWithCodeFrame extends Error {\n    codeFrame?: string;\n}\nexport default function handlePotentialSyntaxError(e: ErrorWithCodeFrame): ErrorWithCodeFrame;\nexport declare function enhanceUnexpectedTokenMessage(e: Error): Error;\nexport {};\n",
  "packages/jest-transform/src/ScriptTransformer.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {createHash} from 'crypto';\nimport * as path from 'path';\nimport {transformSync as babelTransform} from '@babel/core';\n// @ts-expect-error: should just be `require.resolve`, but the tests mess that up\nimport babelPluginIstanbul from 'babel-plugin-istanbul';\nimport {fromSource as sourcemapFromSource} from 'convert-source-map';\nimport stableStringify from 'fast-json-stable-stringify';\nimport * as fs from 'graceful-fs';\nimport {addHook} from 'pirates';\nimport slash from 'slash';\nimport {sync as writeFileAtomic} from 'write-file-atomic';\nimport type {Config} from '@jest/types';\nimport HasteMap from 'jest-haste-map';\nimport {\n  createDirectory,\n  invariant,\n  isPromise,\n  requireOrImportModule,\n  tryRealpath,\n} from 'jest-util';\nimport handlePotentialSyntaxError from './enhanceUnexpectedTokenMessage';\nimport {\n  makeInvalidReturnValueError,\n  makeInvalidSourceMapWarning,\n  makeInvalidSyncTransformerError,\n  makeInvalidTransformerError,\n} from './runtimeErrorsAndWarnings';\nimport shouldInstrument from './shouldInstrument';\nimport type {\n  FixedRawSourceMap,\n  Options,\n  ReducedTransformOptions,\n  RequireAndTranspileModuleOptions,\n  StringMap,\n  SyncTransformer,\n  TransformOptions,\n  TransformResult,\n  TransformedSource,\n  Transformer,\n  TransformerFactory,\n} from './types';\n// Use `require` to avoid TS rootDir\nconst {version: VERSION} = require('../package.json') as {version: string};\n\ntype ProjectCache = {\n  configString: string;\n  ignorePatternsRegExp?: RegExp;\n  transformRegExp?: Array<[RegExp, string, Record<string, unknown>]>;\n  transformedFiles: Map<string, TransformResult>;\n};\n\n// This data structure is used to avoid recalculating some data every time that\n// we need to transform a file. Since ScriptTransformer is instantiated for each\n// file we need to keep this object in the local scope of this module.\nconst projectCaches = new Map<string, ProjectCache>();\n\n// To reset the cache for specific changesets (rather than package version).\nconst CACHE_VERSION = '1';\n\nasync function waitForPromiseWithCleanup(\n  promise: Promise<unknown>,\n  cleanup: () => void,\n) {\n  try {\n    await promise;\n  } finally {\n    cleanup();\n  }\n}\n\n// type predicate\nfunction isTransformerFactory<X extends Transformer>(\n  t: Transformer | TransformerFactory<X>,\n): t is TransformerFactory<X> {\n  return typeof (t as TransformerFactory<X>).createTransformer === 'function';\n}\n\nclass ScriptTransformer {\n  private readonly _cache: ProjectCache;\n  private readonly _transformCache = new Map<\n    string,\n    {transformer: Transformer; transformerConfig: unknown}\n  >();\n  private _transformsAreLoaded = false;\n\n  constructor(\n    private readonly _config: Config.ProjectConfig,\n    private readonly _cacheFS: StringMap,\n  ) {\n    const configString = stableStringify(this._config);\n    let projectCache = projectCaches.get(configString);\n\n    if (!projectCache) {\n      projectCache = {\n        configString,\n        ignorePatternsRegExp: calcIgnorePatternRegExp(this._config),\n        transformRegExp: calcTransformRegExp(this._config),\n        transformedFiles: new Map(),\n      };\n\n      projectCaches.set(configString, projectCache);\n    }\n\n    this._cache = projectCache;\n  }\n\n  private _buildCacheKeyFromFileInfo(\n    fileData: string,\n    filename: string,\n    transformOptions: TransformOptions,\n    transformerCacheKey: string | undefined,\n  ): string {\n    if (transformerCacheKey != null) {\n      return createHash('sha1')\n        .update(transformerCacheKey)\n        .update(CACHE_VERSION)\n        .digest('hex')\n        .slice(0, 32);\n    }\n\n    return createHash('sha1')\n      .update(fileData)\n      .update(transformOptions.configString)\n      .update(transformOptions.instrument ? 'instrument' : '')\n      .update(filename)\n      .update(CACHE_VERSION)\n      .digest('hex')\n      .slice(0, 32);\n  }\n\n  private _buildTransformCacheKey(pattern: string, filepath: string) {\n    return pattern + filepath;\n  }\n\n  private _getCacheKey(\n    fileData: string,\n    filename: string,\n    options: ReducedTransformOptions,\n  ): string {\n    const configString = this._cache.configString;\n    const {transformer, transformerConfig = {}} =\n      this._getTransformer(filename) ?? {};\n    let transformerCacheKey = undefined;\n\n    const transformOptions: TransformOptions = {\n      ...options,\n      cacheFS: this._cacheFS,\n      config: this._config,\n      configString,\n      transformerConfig,\n    };\n\n    if (typeof transformer?.getCacheKey === 'function') {\n      transformerCacheKey = transformer.getCacheKey(\n        fileData,\n        filename,\n        transformOptions,\n      );\n    }\n\n    return this._buildCacheKeyFromFileInfo(\n      fileData,\n      filename,\n      transformOptions,\n      transformerCacheKey,\n    );\n  }\n\n  private async _getCacheKeyAsync(\n    fileData: string,\n    filename: string,\n    options: ReducedTransformOptions,\n  ): Promise<string> {\n    const configString = this._cache.configString;\n    const {transformer, transformerConfig = {}} =\n      this._getTransformer(filename) ?? {};\n    let transformerCacheKey = undefined;\n\n    const transformOptions: TransformOptions = {\n      ...options,\n      cacheFS: this._cacheFS,\n      config: this._config,\n      configString,\n      transformerConfig,\n    };\n\n    if (transformer) {\n      const getCacheKey =\n        transformer.getCacheKeyAsync ?? transformer.getCacheKey;\n\n      if (typeof getCacheKey === 'function') {\n        transformerCacheKey = await getCacheKey(\n          fileData,\n          filename,\n          transformOptions,\n        );\n      }\n    }\n\n    return this._buildCacheKeyFromFileInfo(\n      fileData,\n      filename,\n      transformOptions,\n      transformerCacheKey,\n    );\n  }\n\n  private _createCachedFilename(filename: string, cacheKey: string): string {\n    const HasteMapClass = HasteMap.getStatic(this._config);\n    const baseCacheDir = HasteMapClass.getCacheFilePath(\n      this._config.cacheDirectory,\n      `jest-transform-cache-${this._config.id}`,\n      VERSION,\n    );\n    // Create sub folders based on the cacheKey to avoid creating one\n    // directory with many files.\n    const cacheDir = path.join(baseCacheDir, cacheKey[0] + cacheKey[1]);\n    const cacheFilenamePrefix = path\n      .basename(filename, path.extname(filename))\n      .replaceAll(/\\W/g, '');\n    return slash(path.join(cacheDir, `${cacheFilenamePrefix}_${cacheKey}`));\n  }\n\n  private _getFileCachePath(\n    filename: string,\n    content: string,\n    options: ReducedTransformOptions,\n  ): string {\n    const cacheKey = this._getCacheKey(content, filename, options);\n\n    return this._createCachedFilename(filename, cacheKey);\n  }\n\n  private async _getFileCachePathAsync(\n    filename: string,\n    content: string,\n    options: ReducedTransformOptions,\n  ): Promise<string> {\n    const cacheKey = await this._getCacheKeyAsync(content, filename, options);\n\n    return this._createCachedFilename(filename, cacheKey);\n  }\n\n  private _getTransformPatternAndPath(filename: string) {\n    const transformEntry = this._cache.transformRegExp;\n    if (transformEntry == null) {\n      return undefined;\n    }\n\n    for (const item of transformEntry) {\n      const [transformRegExp, transformPath] = item;\n      if (transformRegExp.test(filename)) {\n        return [transformRegExp.source, transformPath];\n      }\n    }\n\n    return undefined;\n  }\n\n  private _getTransformPath(filename: string) {\n    const transformInfo = this._getTransformPatternAndPath(filename);\n    if (!Array.isArray(transformInfo)) {\n      return undefined;\n    }\n\n    return transformInfo[1];\n  }\n\n  async loadTransformers(): Promise<void> {\n    await Promise.all(\n      this._config.transform.map(\n        async ([transformPattern, transformPath, transformerConfig], i) => {\n          let transformer: Transformer | TransformerFactory<Transformer> =\n            await requireOrImportModule(transformPath);\n\n          if (transformer == null) {\n            throw new Error(makeInvalidTransformerError(transformPath));\n          }\n          if (isTransformerFactory(transformer)) {\n            transformer =\n              await transformer.createTransformer(transformerConfig);\n          }\n          if (\n            typeof transformer.process !== 'function' &&\n            typeof transformer.processAsync !== 'function'\n          ) {\n            throw new TypeError(makeInvalidTransformerError(transformPath));\n          }\n          const res = {transformer, transformerConfig};\n          const transformCacheKey = this._buildTransformCacheKey(\n            this._cache.transformRegExp?.[i]?.[0].source ??\n              new RegExp(transformPattern).source,\n            transformPath,\n          );\n          this._transformCache.set(transformCacheKey, res);\n        },\n      ),\n    );\n\n    this._transformsAreLoaded = true;\n  }\n\n  private _getTransformer(filename: string) {\n    if (!this._transformsAreLoaded) {\n      throw new Error(\n        'Jest: Transformers have not been loaded yet - make sure to run `loadTransformers` and wait for it to complete before starting to transform files',\n      );\n    }\n\n    if (this._config.transform.length === 0) {\n      return null;\n    }\n\n    const transformPatternAndPath = this._getTransformPatternAndPath(filename);\n    if (!Array.isArray(transformPatternAndPath)) {\n      return null;\n    }\n\n    const [transformPattern, transformPath] = transformPatternAndPath;\n    const transformCacheKey = this._buildTransformCacheKey(\n      transformPattern,\n      transformPath,\n    );\n    const transformer = this._transformCache.get(transformCacheKey);\n    if (transformer !== undefined) {\n      return transformer;\n    }\n\n    throw new Error(\n      `Jest was unable to load the transformer defined for ${filename}. This is a bug in Jest, please open up an issue`,\n    );\n  }\n\n  private _instrumentFile(\n    filename: string,\n    input: TransformedSource,\n    canMapToInput: boolean,\n    options: ReducedTransformOptions,\n  ): TransformedSource {\n    const inputCode = typeof input === 'string' ? input : input.code;\n    const inputMap = typeof input === 'string' ? null : input.map;\n\n    const result = babelTransform(inputCode, {\n      auxiliaryCommentBefore: ' istanbul ignore next ',\n      babelrc: false,\n      caller: {\n        name: '@jest/transform',\n        supportsDynamicImport: options.supportsDynamicImport,\n        supportsExportNamespaceFrom: options.supportsExportNamespaceFrom,\n        supportsStaticESM: options.supportsStaticESM,\n        supportsTopLevelAwait: options.supportsTopLevelAwait,\n      },\n      configFile: false,\n      filename,\n      plugins: [\n        [\n          babelPluginIstanbul,\n          {\n            compact: false,\n            // files outside `cwd` will not be instrumented\n            cwd: this._config.rootDir,\n            exclude: [],\n            extension: false,\n            inputSourceMap: inputMap,\n            useInlineSourceMaps: false,\n          },\n        ],\n      ],\n      sourceMaps: canMapToInput ? 'both' : false,\n    });\n\n    if (result?.code != null) {\n      return result as TransformResult;\n    }\n\n    return input;\n  }\n\n  private _buildTransformResult(\n    filename: string,\n    cacheFilePath: string,\n    content: string,\n    transformer: Transformer | undefined,\n    shouldCallTransform: boolean,\n    options: ReducedTransformOptions,\n    processed: TransformedSource | null,\n    sourceMapPath: string | null,\n  ): TransformResult {\n    let transformed: TransformedSource = {\n      code: content,\n      map: null,\n    };\n\n    if (transformer && shouldCallTransform) {\n      if (processed != null && typeof processed.code === 'string') {\n        transformed = processed;\n      } else {\n        const transformPath = this._getTransformPath(filename);\n        invariant(transformPath);\n        throw new Error(makeInvalidReturnValueError(transformPath));\n      }\n    }\n\n    if (transformed.map == null || transformed.map === '') {\n      try {\n        //Could be a potential freeze here.\n        //See: https://github.com/jestjs/jest/pull/5177#discussion_r158883570\n        const inlineSourceMap = sourcemapFromSource(transformed.code);\n        if (inlineSourceMap) {\n          transformed.map = inlineSourceMap.toObject() as FixedRawSourceMap;\n        }\n      } catch {\n        const transformPath = this._getTransformPath(filename);\n        invariant(transformPath);\n        console.warn(makeInvalidSourceMapWarning(filename, transformPath));\n      }\n    }\n\n    // That means that the transform has a custom instrumentation\n    // logic and will handle it based on `config.collectCoverage` option\n    const transformWillInstrument =\n      shouldCallTransform && transformer?.canInstrument;\n\n    // Apply instrumentation to the code if necessary, keeping the instrumented code and new map\n    let map = transformed.map;\n    let code;\n    if (transformWillInstrument !== true && options.instrument) {\n      /**\n       * We can map the original source code to the instrumented code ONLY if\n       * - the process of transforming the code produced a source map e.g. ts-jest\n       * - we did not transform the source code\n       *\n       * Otherwise we cannot make any statements about how the instrumented code corresponds to the original code,\n       * and we should NOT emit any source maps\n       *\n       */\n      const shouldEmitSourceMaps =\n        (transformer != null && map != null) || transformer == null;\n\n      const instrumented = this._instrumentFile(\n        filename,\n        transformed,\n        shouldEmitSourceMaps,\n        options,\n      );\n\n      code =\n        typeof instrumented === 'string' ? instrumented : instrumented.code;\n      map = typeof instrumented === 'string' ? null : instrumented.map;\n    } else {\n      code = transformed.code;\n    }\n\n    if (map == null) {\n      sourceMapPath = null;\n    } else {\n      const sourceMapContent =\n        typeof map === 'string' ? map : JSON.stringify(map);\n\n      invariant(sourceMapPath, 'We should always have default sourceMapPath');\n\n      writeCacheFile(sourceMapPath, sourceMapContent);\n    }\n\n    writeCodeCacheFile(cacheFilePath, code);\n\n    return {\n      code,\n      originalCode: content,\n      sourceMapPath,\n    };\n  }\n\n  transformSource(\n    filepath: string,\n    content: string,\n    options: ReducedTransformOptions,\n  ): TransformResult {\n    const filename = tryRealpath(filepath);\n    const {transformer, transformerConfig = {}} =\n      this._getTransformer(filename) ?? {};\n    const cacheFilePath = this._getFileCachePath(filename, content, options);\n    const sourceMapPath = `${cacheFilePath}.map`;\n    // Ignore cache if `config.cache` is set (--no-cache)\n    const code = this._config.cache ? readCodeCacheFile(cacheFilePath) : null;\n\n    if (code != null) {\n      // This is broken: we return the code, and a path for the source map\n      // directly from the cache. But, nothing ensures the source map actually\n      // matches that source code. They could have gotten out-of-sync in case\n      // two separate processes write concurrently to the same cache files.\n      return {\n        code,\n        originalCode: content,\n        sourceMapPath,\n      };\n    }\n\n    let processed: TransformedSource | null = null;\n\n    let shouldCallTransform = false;\n\n    if (transformer && this.shouldTransform(filename)) {\n      shouldCallTransform = true;\n\n      assertSyncTransformer(transformer, this._getTransformPath(filename));\n\n      processed = transformer.process(content, filename, {\n        ...options,\n        cacheFS: this._cacheFS,\n        config: this._config,\n        configString: this._cache.configString,\n        transformerConfig,\n      });\n    }\n\n    createDirectory(path.dirname(cacheFilePath));\n    return this._buildTransformResult(\n      filename,\n      cacheFilePath,\n      content,\n      transformer,\n      shouldCallTransform,\n      options,\n      processed,\n      sourceMapPath,\n    );\n  }\n\n  async transformSourceAsync(\n    filepath: string,\n    content: string,\n    options: ReducedTransformOptions,\n  ): Promise<TransformResult> {\n    const filename = tryRealpath(filepath);\n    const {transformer, transformerConfig = {}} =\n      this._getTransformer(filename) ?? {};\n    const cacheFilePath = await this._getFileCachePathAsync(\n      filename,\n      content,\n      options,\n    );\n    const sourceMapPath = `${cacheFilePath}.map`;\n    // Ignore cache if `config.cache` is set (--no-cache)\n    const code = this._config.cache ? readCodeCacheFile(cacheFilePath) : null;\n\n    if (code != null) {\n      // This is broken: we return the code, and a path for the source map\n      // directly from the cache. But, nothing ensures the source map actually\n      // matches that source code. They could have gotten out-of-sync in case\n      // two separate processes write concurrently to the same cache files.\n      return {\n        code,\n        originalCode: content,\n        sourceMapPath,\n      };\n    }\n\n    let processed = null;\n\n    let shouldCallTransform = false;\n\n    if (transformer && this.shouldTransform(filename)) {\n      shouldCallTransform = true;\n      const process = transformer.processAsync ?? transformer.process;\n\n      // This is probably dead code since `_getTransformerAsync` already asserts this\n      invariant(\n        typeof process === 'function',\n        'A transformer must always export either a `process` or `processAsync`',\n      );\n\n      processed = await process(content, filename, {\n        ...options,\n        cacheFS: this._cacheFS,\n        config: this._config,\n        configString: this._cache.configString,\n        transformerConfig,\n      });\n    }\n\n    createDirectory(path.dirname(cacheFilePath));\n    return this._buildTransformResult(\n      filename,\n      cacheFilePath,\n      content,\n      transformer,\n      shouldCallTransform,\n      options,\n      processed,\n      sourceMapPath,\n    );\n  }\n\n  private async _transformAndBuildScriptAsync(\n    filename: string,\n    options: Options,\n    transformOptions: ReducedTransformOptions,\n    fileSource?: string,\n  ): Promise<TransformResult> {\n    const {isInternalModule} = options;\n    let fileContent = fileSource ?? this._cacheFS.get(filename);\n    if (fileContent == null) {\n      fileContent = fs.readFileSync(filename, 'utf8');\n      this._cacheFS.set(filename, fileContent);\n    }\n    const content = stripShebang(fileContent);\n\n    let code = content;\n    let sourceMapPath: string | null = null;\n\n    const willTransform =\n      isInternalModule !== true &&\n      (transformOptions.instrument || this.shouldTransform(filename));\n\n    try {\n      if (willTransform) {\n        const transformedSource = await this.transformSourceAsync(\n          filename,\n          content,\n          transformOptions,\n        );\n\n        code = transformedSource.code;\n        sourceMapPath = transformedSource.sourceMapPath;\n      }\n\n      return {\n        code,\n        originalCode: content,\n        sourceMapPath,\n      };\n    } catch (error) {\n      if (!(error instanceof Error)) {\n        throw error;\n      }\n      throw handlePotentialSyntaxError(error);\n    }\n  }\n\n  private _transformAndBuildScript(\n    filename: string,\n    options: Options,\n    transformOptions: ReducedTransformOptions,\n    fileSource?: string,\n  ): TransformResult {\n    const {isInternalModule} = options;\n    let fileContent = fileSource ?? this._cacheFS.get(filename);\n    if (fileContent == null) {\n      fileContent = fs.readFileSync(filename, 'utf8');\n      this._cacheFS.set(filename, fileContent);\n    }\n    const content = stripShebang(fileContent);\n\n    let code = content;\n    let sourceMapPath: string | null = null;\n\n    const willTransform =\n      isInternalModule !== true &&\n      (transformOptions.instrument || this.shouldTransform(filename));\n\n    try {\n      if (willTransform) {\n        const transformedSource = this.transformSource(\n          filename,\n          content,\n          transformOptions,\n        );\n\n        code = transformedSource.code;\n        sourceMapPath = transformedSource.sourceMapPath;\n      }\n\n      return {\n        code,\n        originalCode: content,\n        sourceMapPath,\n      };\n    } catch (error) {\n      if (!(error instanceof Error)) {\n        throw error;\n      }\n      throw handlePotentialSyntaxError(error);\n    }\n  }\n\n  async transformAsync(\n    filename: string,\n    options: Options,\n    fileSource?: string,\n  ): Promise<TransformResult> {\n    const instrument =\n      options.coverageProvider === 'babel' &&\n      shouldInstrument(filename, options, this._config);\n    const scriptCacheKey = getScriptCacheKey(filename, instrument);\n    let result = this._cache.transformedFiles.get(scriptCacheKey);\n    if (result) {\n      return result;\n    }\n\n    result = await this._transformAndBuildScriptAsync(\n      filename,\n      options,\n      {...options, instrument},\n      fileSource,\n    );\n\n    if (scriptCacheKey) {\n      this._cache.transformedFiles.set(scriptCacheKey, result);\n    }\n\n    return result;\n  }\n\n  transform(\n    filename: string,\n    options: Options,\n    fileSource?: string,\n  ): TransformResult {\n    const instrument =\n      options.coverageProvider === 'babel' &&\n      shouldInstrument(filename, options, this._config);\n    const scriptCacheKey = getScriptCacheKey(filename, instrument);\n\n    let result = this._cache.transformedFiles.get(scriptCacheKey);\n    if (result) {\n      return result;\n    }\n\n    result = this._transformAndBuildScript(\n      filename,\n      options,\n      {...options, instrument},\n      fileSource,\n    );\n\n    if (scriptCacheKey) {\n      this._cache.transformedFiles.set(scriptCacheKey, result);\n    }\n\n    return result;\n  }\n\n  transformJson(\n    filename: string,\n    options: Options,\n    fileSource: string,\n  ): string {\n    const {isInternalModule} = options;\n    const willTransform =\n      isInternalModule !== true && this.shouldTransform(filename);\n\n    if (willTransform) {\n      const {code: transformedJsonSource} = this.transformSource(\n        filename,\n        fileSource,\n        {...options, instrument: false},\n      );\n      return transformedJsonSource;\n    }\n\n    return fileSource;\n  }\n\n  async requireAndTranspileModule<ModuleType = unknown>(\n    moduleName: string,\n    callback?: (module: ModuleType) => void | Promise<void>,\n    options?: RequireAndTranspileModuleOptions,\n  ): Promise<ModuleType> {\n    options = {\n      applyInteropRequireDefault: true,\n      instrument: false,\n      supportsDynamicImport: false,\n      supportsExportNamespaceFrom: false,\n      supportsStaticESM: false,\n      supportsTopLevelAwait: false,\n      ...options,\n    };\n    let transforming = false;\n    const {applyInteropRequireDefault, ...transformOptions} = options;\n    const revertHook = addHook(\n      (code, filename) => {\n        try {\n          transforming = true;\n          return (\n            this.transformSource(filename, code, transformOptions).code || code\n          );\n        } finally {\n          transforming = false;\n        }\n      },\n      {\n        // Exclude `mjs` extension when addHook because pirates don't support hijack es module\n        exts: this._config.moduleFileExtensions\n          .filter(ext => ext !== 'mjs')\n          .map(ext => `.${ext}`),\n        ignoreNodeModules: false,\n        matcher: filename => {\n          if (transforming) {\n            // Don't transform any dependency required by the transformer itself\n            return false;\n          }\n          return this.shouldTransform(filename);\n        },\n      },\n    );\n    try {\n      const module: ModuleType = await requireOrImportModule(\n        moduleName,\n        applyInteropRequireDefault,\n      );\n\n      if (!callback) {\n        revertHook();\n\n        return module;\n      }\n\n      const cbResult = callback(module);\n\n      if (isPromise(cbResult)) {\n        return await waitForPromiseWithCleanup(cbResult, revertHook).then(\n          () => module,\n        );\n      }\n\n      return module;\n    } finally {\n      revertHook();\n    }\n  }\n\n  shouldTransform(filename: string): boolean {\n    const ignoreRegexp = this._cache.ignorePatternsRegExp;\n    const isIgnored = ignoreRegexp ? ignoreRegexp.test(filename) : false;\n\n    return this._config.transform.length > 0 && !isIgnored;\n  }\n}\n\n// TODO: do we need to define the generics twice?\nexport async function createTranspilingRequire(\n  config: Config.ProjectConfig,\n): Promise<\n  <TModuleType = unknown>(\n    resolverPath: string,\n    applyInteropRequireDefault?: boolean,\n  ) => Promise<TModuleType>\n> {\n  const transformer = await createScriptTransformer(config);\n\n  return async function requireAndTranspileModule<TModuleType = unknown>(\n    resolverPath: string,\n    applyInteropRequireDefault = false,\n  ) {\n    const transpiledModule =\n      await transformer.requireAndTranspileModule<TModuleType>(\n        resolverPath,\n        // eslint-disable-next-line @typescript-eslint/no-empty-function\n        () => {},\n        {\n          applyInteropRequireDefault,\n          instrument: false,\n          supportsDynamicImport: false, // this might be true, depending on node version.\n          supportsExportNamespaceFrom: false,\n          supportsStaticESM: false,\n          supportsTopLevelAwait: false,\n        },\n      );\n\n    return transpiledModule;\n  };\n}\n\nconst removeFile = (path: string) => {\n  try {\n    fs.unlinkSync(path);\n  } catch {}\n};\n\nconst stripShebang = (content: string) => {\n  // If the file data starts with a shebang remove it. Leaves the empty line\n  // to keep stack trace line numbers correct.\n  if (content.startsWith('#!')) {\n    return content.replace(/^#!.*/, '');\n  } else {\n    return content;\n  }\n};\n\n/**\n * This is like `writeCacheFile` but with an additional sanity checksum. We\n * cannot use the same technique for source maps because we expose source map\n * cache file paths directly to callsites, with the expectation they can read\n * it right away. This is not a great system, because source map cache file\n * could get corrupted, out-of-sync, etc.\n */\nfunction writeCodeCacheFile(cachePath: string, code: string) {\n  const checksum = createHash('sha1').update(code).digest('hex').slice(0, 32);\n  writeCacheFile(cachePath, `${checksum}\\n${code}`);\n}\n\n/**\n * Read counterpart of `writeCodeCacheFile`. We verify that the content of the\n * file matches the checksum, in case some kind of corruption happened. This\n * could happen if an older version of `jest-runtime` writes non-atomically to\n * the same cache, for example.\n */\nfunction readCodeCacheFile(cachePath: string): string | null {\n  const content = readCacheFile(cachePath);\n  if (content == null) {\n    return null;\n  }\n  const code = content.slice(33);\n  const checksum = createHash('sha1').update(code).digest('hex').slice(0, 32);\n  if (checksum === content.slice(0, 32)) {\n    return code;\n  }\n  return null;\n}\n\n/**\n * Writing to the cache atomically relies on 'rename' being atomic on most\n * file systems. Doing atomic write reduces the risk of corruption by avoiding\n * two processes to write to the same file at the same time. It also reduces\n * the risk of reading a file that's being overwritten at the same time.\n */\nconst writeCacheFile = (cachePath: string, fileData: string) => {\n  try {\n    writeFileAtomic(cachePath, fileData, {encoding: 'utf8', fsync: false});\n  } catch (error) {\n    if (!(error instanceof Error)) {\n      throw error;\n    }\n    if (cacheWriteErrorSafeToIgnore(error)) {\n      return;\n    }\n\n    error.message = `jest: failed to cache transform results in: ${cachePath}\\nFailure message: ${error.message}`;\n    removeFile(cachePath);\n    throw error;\n  }\n};\n\n/**\n * On Windows, renames are not atomic, leading to EPERM exceptions when two\n * processes attempt to rename to the same target file at the same time.\n * If the target file exists we can be reasonably sure another process has\n * legitimately won a cache write race and ignore the error.\n * If the target does not exist we do not know if it is because it is still\n * being written by another process or is being overwritten by another process.\n */\nconst cacheWriteErrorSafeToIgnore = (e: NodeJS.ErrnoException) =>\n  process.platform === 'win32' && e.code === 'EPERM';\n\nconst readCacheFile = (cachePath: string): string | null => {\n  if (!fs.existsSync(cachePath)) {\n    return null;\n  }\n\n  let fileData;\n  try {\n    fileData = fs.readFileSync(cachePath, 'utf8');\n  } catch (error) {\n    if (!(error instanceof Error)) {\n      throw error;\n    }\n    // on windows write-file-atomic is not atomic which can\n    // result in this error\n    if (\n      (error as NodeJS.ErrnoException).code === 'ENOENT' &&\n      process.platform === 'win32'\n    ) {\n      return null;\n    }\n\n    error.message = `jest: failed to read cache file: ${cachePath}\\nFailure message: ${error.message}`;\n    removeFile(cachePath);\n    throw error;\n  }\n\n  if (fileData == null) {\n    // We must have somehow created the file but failed to write to it,\n    // let's delete it and retry.\n    removeFile(cachePath);\n  }\n  return fileData;\n};\n\nconst getScriptCacheKey = (filename: string, instrument: boolean) => {\n  const mtime = fs.statSync(filename).mtime;\n  return `${filename}_${mtime.getTime()}${instrument ? '_instrumented' : ''}`;\n};\n\nconst calcIgnorePatternRegExp = (config: Config.ProjectConfig) => {\n  if (\n    config.transformIgnorePatterns == null ||\n    config.transformIgnorePatterns.length === 0\n  ) {\n    return undefined;\n  }\n\n  return new RegExp(config.transformIgnorePatterns.join('|'));\n};\n\nconst calcTransformRegExp = (config: Config.ProjectConfig) => {\n  if (config.transform.length === 0) {\n    return undefined;\n  }\n\n  const transformRegexp: Array<[RegExp, string, Record<string, unknown>]> = [];\n  for (const item of config.transform) {\n    transformRegexp.push([new RegExp(item[0]), item[1], item[2]]);\n  }\n\n  return transformRegexp;\n};\n\nfunction assertSyncTransformer(\n  transformer: Transformer,\n  name: string | undefined,\n): asserts transformer is SyncTransformer {\n  invariant(name);\n  invariant(\n    typeof transformer.process === 'function',\n    makeInvalidSyncTransformerError(name),\n  );\n}\n\nexport type TransformerType = ScriptTransformer;\n\nexport async function createScriptTransformer(\n  config: Config.ProjectConfig,\n  cacheFS: StringMap = new Map(),\n): Promise<TransformerType> {\n  const transformer = new ScriptTransformer(config, cacheFS);\n\n  await transformer.loadTransformers();\n\n  return transformer;\n}\n",
  "packages/jest-transform/src/ScriptTransformer.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config } from '@jest/types';\nimport type { Options, ReducedTransformOptions, RequireAndTranspileModuleOptions, StringMap, TransformResult } from './types';\ndeclare class ScriptTransformer {\n    private readonly _config;\n    private readonly _cacheFS;\n    private readonly _cache;\n    private readonly _transformCache;\n    private _transformsAreLoaded;\n    constructor(_config: Config.ProjectConfig, _cacheFS: StringMap);\n    private _buildCacheKeyFromFileInfo;\n    private _buildTransformCacheKey;\n    private _getCacheKey;\n    private _getCacheKeyAsync;\n    private _createCachedFilename;\n    private _getFileCachePath;\n    private _getFileCachePathAsync;\n    private _getTransformPatternAndPath;\n    private _getTransformPath;\n    loadTransformers(): Promise<void>;\n    private _getTransformer;\n    private _instrumentFile;\n    private _buildTransformResult;\n    transformSource(filepath: string, content: string, options: ReducedTransformOptions): TransformResult;\n    transformSourceAsync(filepath: string, content: string, options: ReducedTransformOptions): Promise<TransformResult>;\n    private _transformAndBuildScriptAsync;\n    private _transformAndBuildScript;\n    transformAsync(filename: string, options: Options, fileSource?: string): Promise<TransformResult>;\n    transform(filename: string, options: Options, fileSource?: string): TransformResult;\n    transformJson(filename: string, options: Options, fileSource: string): string;\n    requireAndTranspileModule<ModuleType = unknown>(moduleName: string, callback?: (module: ModuleType) => void | Promise<void>, options?: RequireAndTranspileModuleOptions): Promise<ModuleType>;\n    shouldTransform(filename: string): boolean;\n}\nexport declare function createTranspilingRequire(config: Config.ProjectConfig): Promise<(<TModuleType = unknown>(resolverPath: string, applyInteropRequireDefault?: boolean) => Promise<TModuleType>)>;\nexport type TransformerType = ScriptTransformer;\nexport declare function createScriptTransformer(config: Config.ProjectConfig, cacheFS?: StringMap): Promise<TransformerType>;\nexport {};\n",
  "packages/jest-transform/src/__tests__/shouldInstrument.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {makeGlobalConfig, makeProjectConfig} from '@jest/test-utils';\nimport type {Config} from '@jest/types';\nimport shouldInstrument from '../shouldInstrument';\nimport type {Options} from '../types';\n\ndescribe('shouldInstrument', () => {\n  const defaultFilename = 'source_file.test.js';\n  const defaultOptions: Options = {\n    ...makeGlobalConfig({\n      collectCoverage: true,\n    }),\n    changedFiles: undefined,\n  };\n  const defaultConfig = makeProjectConfig({rootDir: '/'});\n  describe('should return true', () => {\n    const testShouldInstrument = (\n      filename = defaultFilename,\n      options: Partial<Options>,\n      config: Partial<Config.ProjectConfig>,\n      loadedFilenames?: Array<string>,\n    ) => {\n      const result = shouldInstrument(\n        filename,\n        {...defaultOptions, ...options},\n        {...defaultConfig, ...config},\n        loadedFilenames,\n      );\n      expect(result).toBe(true);\n    };\n\n    it('when testRegex is provided and file is not a test file', () => {\n      testShouldInstrument('source_file.js', defaultOptions, {\n        testRegex: ['.*\\\\.(test)\\\\.(js)$'],\n      });\n    });\n\n    it('when more than one testRegex is provided and filename is not a test file', () => {\n      testShouldInstrument('source_file.js', defaultOptions, {\n        testRegex: ['.*\\\\_(test)\\\\.(js)$', '.*\\\\.(test)\\\\.(js)$', 'never'],\n      });\n    });\n\n    it('when testMatch is provided and file is not a test file', () => {\n      testShouldInstrument('source_file.js', defaultOptions, {\n        testMatch: ['**/?(*.)(test).js', '!**/dont/**/*.js'],\n      });\n    });\n\n    it('when testPathIgnorePatterns is provided and file is not a test file', () => {\n      testShouldInstrument('src/test.js', defaultOptions, {\n        testPathIgnorePatterns: ['src/'],\n      });\n    });\n\n    it('when more than one testPathIgnorePatterns is provided and filename is not a test file', () => {\n      testShouldInstrument('src/test.js', defaultOptions, {\n        testPathIgnorePatterns: ['test/', 'src/'],\n      });\n    });\n\n    it('when testRegex and testPathIgnorePatterns are provided and file is not a test file', () => {\n      testShouldInstrument('src/source_file.js', defaultOptions, {\n        testPathIgnorePatterns: ['test/'],\n        testRegex: ['.*\\\\.(test)\\\\.(js)$'],\n      });\n    });\n\n    it('when testMatch and testPathIgnorePatterns are provided and file is not a test file', () => {\n      testShouldInstrument('src/source_file.js', defaultOptions, {\n        testMatch: ['**/?(*.)(test).js', '!**/dont/**/*.js'],\n        testPathIgnorePatterns: ['test/'],\n      });\n    });\n\n    it('should return true when filename matches collectCoverageFrom', () => {\n      testShouldInstrument(\n        'do/collect/coverage.js',\n        {\n          collectCoverageFrom: ['!**/dont/**/*.js', '**/do/**/*.js'],\n        },\n        defaultConfig,\n      );\n    });\n\n    it('should return true if the file is not in coveragePathIgnorePatterns', () => {\n      testShouldInstrument('do/collect/coverage.js', defaultOptions, {\n        coveragePathIgnorePatterns: ['dont'],\n      });\n    });\n\n    it('should return true if file is a testfile but forceCoverageMatch is set', () => {\n      testShouldInstrument('do/collect/sum.coverage.test.js', defaultOptions, {\n        forceCoverageMatch: ['**/*.(coverage).(test).js'],\n        testRegex: ['.*\\\\.(test)\\\\.(js)$'],\n      });\n    });\n\n    it('when file is in loadedFilenames list', () => {\n      testShouldInstrument(\n        'do/collect/coverage.js',\n        defaultOptions,\n        defaultConfig,\n        ['do/collect/coverage.js'],\n      );\n    });\n\n    it('when file is in not loadedFilenames list, but matches collectCoverageFrom', () => {\n      testShouldInstrument(\n        'do/collect/coverage.js',\n        {collectCoverageFrom: ['!**/dont/**/*.js', '**/do/**/*.js']},\n        defaultConfig,\n        ['dont/collect/coverage.js'],\n      );\n    });\n\n    it('when file is a .json module, but matches forceCoverageMatch', () => {\n      testShouldInstrument('do/collect/coverage.json', defaultOptions, {\n        forceCoverageMatch: ['**/do/**/*.json'],\n      });\n    });\n  });\n\n  describe('should return false', () => {\n    const testShouldInstrument = (\n      filename = defaultFilename,\n      options: Partial<Options>,\n      config: Partial<Config.ProjectConfig>,\n      loadedFilenames?: Array<string>,\n    ) => {\n      const result = shouldInstrument(\n        filename,\n        {...defaultOptions, ...options},\n        {...defaultConfig, ...config},\n        loadedFilenames,\n      );\n      expect(result).toBe(false);\n    };\n\n    it('if collectCoverage is falsy', () => {\n      testShouldInstrument(\n        'source_file.js',\n        {\n          collectCoverage: false,\n        },\n        defaultConfig,\n      );\n    });\n\n    it('when testRegex is provided and filename is a test file', () => {\n      testShouldInstrument(defaultFilename, defaultOptions, {\n        testRegex: ['.*\\\\.(test)\\\\.(js)$'],\n      });\n    });\n\n    it('when more than one testRegex is provided and filename matches one of the patterns', () => {\n      testShouldInstrument(defaultFilename, defaultOptions, {\n        testRegex: ['.*\\\\_(test)\\\\.(js)$', '.*\\\\.(test)\\\\.(js)$', 'never'],\n      });\n    });\n\n    it('when testMatch is provided and file is a test file', () => {\n      testShouldInstrument(defaultFilename, defaultOptions, {\n        testMatch: ['**/?(*.)(test).js'],\n      });\n    });\n\n    it('when testRegex and testPathIgnorePatterns are provided and filename is a test file', () => {\n      testShouldInstrument(`test/${defaultFilename}`, defaultOptions, {\n        testPathIgnorePatterns: ['src/'],\n        testRegex: ['.*\\\\.(test)\\\\.(js)$'],\n      });\n    });\n\n    it('when testMatch and testPathIgnorePatterns are provided and file is a test file', () => {\n      testShouldInstrument(`test/${defaultFilename}`, defaultOptions, {\n        testMatch: ['**/?(*.)(test).js'],\n        testPathIgnorePatterns: ['src/'],\n      });\n    });\n\n    it('when filename does not match collectCoverageFrom', () => {\n      testShouldInstrument(\n        'dont/collect/coverage.js',\n        {\n          collectCoverageFrom: ['!**/dont/**/*.js', '**/do/**/*.js'],\n        },\n        defaultConfig,\n      );\n    });\n\n    it('if the file is in coveragePathIgnorePatterns', () => {\n      testShouldInstrument('dont/collect/coverage.js', defaultOptions, {\n        coveragePathIgnorePatterns: ['dont'],\n      });\n    });\n\n    it('if file is in mock patterns', () => {\n      const filename =\n        process.platform === 'win32'\n          ? 'dont\\\\__mocks__\\\\collect\\\\coverage.js'\n          : 'dont/__mocks__/collect/coverage.js';\n\n      testShouldInstrument(filename, defaultOptions, defaultConfig);\n    });\n\n    it('if file is a globalSetup file', () => {\n      testShouldInstrument('globalSetup.js', defaultOptions, {\n        globalSetup: 'globalSetup.js',\n      });\n    });\n\n    it('if file is globalTeardown file', () => {\n      testShouldInstrument('globalTeardown.js', defaultOptions, {\n        globalTeardown: 'globalTeardown.js',\n      });\n    });\n\n    it('if file is in setupFiles', () => {\n      testShouldInstrument('setupTest.js', defaultOptions, {\n        setupFiles: ['setupTest.js'],\n      });\n    });\n\n    it('if file is in setupFilesAfterEnv', () => {\n      testShouldInstrument('setupTest.js', defaultOptions, {\n        setupFilesAfterEnv: ['setupTest.js'],\n      });\n    });\n\n    it('when file is not in loadedFilenames list', () => {\n      testShouldInstrument(\n        'dont/collect/coverage.js',\n        defaultOptions,\n        defaultConfig,\n        ['do/collect/coverage.js'],\n      );\n    });\n\n    it('when file is in not loadedFilenames list and does not match collectCoverageFrom', () => {\n      testShouldInstrument(\n        'dont/collect/coverage.js',\n        {collectCoverageFrom: ['!**/dont/**/*.js', '**/do/**/*.js']},\n        defaultConfig,\n        ['do/collect/coverage.js'],\n      );\n    });\n\n    it('when file is a .json module', () => {\n      testShouldInstrument(\n        'dont/collect/coverage.json',\n        defaultOptions,\n        defaultConfig,\n      );\n    });\n  });\n});\n",
  "packages/jest-transform/src/__tests__/shouldInstrument.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-transform/src/__tests__/ScriptTransformer.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {makeGlobalConfig, makeProjectConfig} from '@jest/test-utils';\nimport type {Config} from '@jest/types';\nimport type {\n  AsyncTransformer,\n  FixedRawSourceMap,\n  Options,\n  ReducedTransformOptions,\n  ShouldInstrumentOptions,\n  SyncTransformer,\n  TransformedSource,\n  Transformer,\n  TransformerFactory,\n} from '../types';\n\njest\n  .mock('graceful-fs', () => ({\n    ...jest.requireActual<typeof import('graceful-fs')>('graceful-fs'),\n    /* eslint-disable sort-keys */\n    readFileSync: jest.fn((path: string, options: string) => {\n      mockInvariant(typeof path === 'string');\n\n      expect(options).toBe('utf8');\n      if (mockFs[path]) {\n        return mockFs[path];\n      }\n\n      throw new Error(`Cannot read path '${path}'.`);\n    }),\n    writeFileSync: jest.fn<typeof import('fs').writeFileSync>(\n      (path, data, options) => {\n        mockInvariant(typeof path === 'string');\n        mockInvariant(typeof data === 'string');\n        expect(options).toBe('utf8');\n        mockFs[path] = data;\n      },\n    ),\n\n    unlinkSync: jest.fn<typeof import('fs').unlinkSync>(),\n    statSync: jest.fn<typeof import('fs').statSync>(path => ({\n      isFile() {\n        mockInvariant(typeof path === 'string');\n        return !!mockFs[path];\n      },\n      mtime: {getTime: () => 42, toString: () => '42'},\n    })),\n\n    existsSync: jest.fn<typeof import('fs').existsSync>(path => {\n      mockInvariant(typeof path === 'string');\n\n      return !!mockFs[path];\n    }),\n    /* eslint-enable */\n  }))\n  .mock('jest-haste-map', () => ({\n    getStatic() {\n      return {\n        getCacheFilePath: (cacheDir: string, baseDir: string) =>\n          cacheDir + baseDir,\n      };\n    },\n  }))\n  .mock('jest-util', () => ({\n    ...jest.requireActual<typeof import('jest-util')>('jest-util'),\n    createDirectory: jest.fn(),\n  }))\n  .mock('path', () => jest.requireActual<typeof import('path')>('path').posix);\n\njest.mock(\n  'test_preprocessor',\n  () => {\n    const transformer: Transformer = {\n      getCacheKey: jest.fn(() => 'ab'),\n      process: (content, filename, config) => ({\n        code: (require('dedent') as typeof import('dedent').default)`\n          const TRANSFORMED = {\n            filename: '${filename}',\n            script: '${content}',\n            config: '${JSON.stringify(config)}',\n          };\n        `,\n      }),\n    };\n\n    return transformer;\n  },\n  {virtual: true},\n);\n\njest.mock(\n  'test_async_preprocessor',\n  () => {\n    const transformer: AsyncTransformer = {\n      getCacheKeyAsync: jest.fn(() => Promise.resolve('ab')),\n      processAsync: (content, filename, config) =>\n        Promise.resolve({\n          code: (require('dedent') as typeof import('dedent').default)`\n          const TRANSFORMED = {\n            filename: '${filename}',\n            script: '${content}',\n            config: '${JSON.stringify(config)}',\n          };\n        `,\n        }),\n    };\n\n    return transformer;\n  },\n  {virtual: true},\n);\n\njest.mock(\n  'configureable-preprocessor',\n  () => ({\n    createTransformer: jest.fn(() => ({\n      process: jest.fn().mockReturnValue({code: 'processedCode'}),\n    })),\n  }),\n  {virtual: true},\n);\n\njest.mock(\n  'cache_fs_preprocessor',\n  () => {\n    const syncTransformer: SyncTransformer = {\n      getCacheKey: jest.fn(() => 'ab'),\n      process: jest.fn(() => ({code: 'processedCode'})),\n    };\n    return syncTransformer;\n  },\n  {virtual: true},\n);\n\njest.mock(\n  'cache_fs_async_preprocessor',\n  () => {\n    const asyncTransformer: AsyncTransformer = {\n      getCacheKeyAsync: jest.fn(() => Promise.resolve('ab')),\n      processAsync: jest.fn(() => Promise.resolve({code: 'processedCode'})),\n    };\n    return asyncTransformer;\n  },\n  {virtual: true},\n);\n\njest.mock(\n  'preprocessor-with-sourcemaps',\n  () => ({\n    getCacheKey: jest.fn(() => 'ab'),\n    process: jest.fn(),\n  }),\n  {virtual: true},\n);\n\njest.mock(\n  'async-preprocessor-with-sourcemaps',\n  () => ({\n    getCacheKeyAsync: jest.fn(() => 'ab'),\n    processAsync: jest.fn(),\n  }),\n  {virtual: true},\n);\n\njest.mock(\n  'css-preprocessor',\n  () => {\n    const transformer: Transformer = {\n      getCacheKey: jest.fn(() => 'cd'),\n      process: (content, filename) => ({\n        code: (require('dedent') as typeof import('dedent').default)`\n          module.exports = {\n            filename: ${filename},\n            rawFirstLine: ${content.split('\\n')[0]},\n          };\n        `,\n      }),\n    };\n\n    return transformer;\n  },\n  {virtual: true},\n);\n\njest.mock('passthrough-preprocessor', () => ({process: jest.fn()}), {\n  virtual: true,\n});\n\n// Bad preprocessor\njest.mock('skipped-required-props-preprocessor', () => ({}), {virtual: true});\n\n// Bad preprocessor\njest.mock(\n  'skipped-required-props-preprocessor-only-sync',\n  () => ({process: () => ({code: ''})}),\n  {virtual: true},\n);\n\n// Bad preprocessor\njest.mock(\n  'skipped-required-props-preprocessor-only-async',\n  () => ({processAsync: () => Promise.resolve({code: ''})}),\n  {virtual: true},\n);\n\n// Bad preprocessor\njest.mock(\n  'skipped-required-create-transformer-props-preprocessor',\n  () => ({\n    createTransformer() {\n      return {};\n    },\n  }),\n  {virtual: true},\n);\n\njest.mock(\n  'skipped-process-method-preprocessor',\n  () => ({\n    createTransformer() {\n      return {process: jest.fn().mockReturnValue({code: 'code'})};\n    },\n  }),\n  {virtual: true},\n);\n\njest.mock(\n  'async-factory',\n  () => ({\n    createTransformer() {\n      return Promise.resolve({\n        process: jest.fn().mockReturnValue({code: 'code'}),\n      });\n    },\n  }),\n  {virtual: true},\n);\n\njest.mock(\n  'factory-for-async-preprocessor',\n  () => {\n    const transformer: AsyncTransformer = {\n      processAsync: jest.fn(() => Promise.resolve({code: 'code'})),\n    };\n    return {\n      createTransformer() {\n        return transformer;\n      },\n    };\n  },\n  {virtual: true},\n);\n\nconst getCachePath = (\n  mockFs: Record<string, string>,\n  config: Config.ProjectConfig,\n) => {\n  for (const path in mockFs) {\n    if (path.startsWith(config.cacheDirectory)) {\n      return path;\n    }\n  }\n  return null;\n};\n\nlet createScriptTransformer: typeof import('../ScriptTransformer').createScriptTransformer;\nlet config: Config.ProjectConfig;\nlet fs: typeof import('fs');\nlet mockFs: Record<string, string>;\nlet object: <T>(input: T) => T;\nlet writeFileAtomic: typeof import('write-file-atomic');\n\njest.mock('write-file-atomic', () => ({\n  sync: jest.fn<typeof import('write-file-atomic').sync>((filePath, data) => {\n    mockInvariant(typeof data === 'string');\n    mockFs[filePath] = data;\n  }),\n}));\n\ndescribe('ScriptTransformer', () => {\n  const reset = () => {\n    jest.resetModules();\n\n    object = data =>\n      Object.assign(Object.create(null) as Record<string, unknown>, data);\n\n    mockFs = object({\n      '/fruits/avocado.js': ['module.exports = \"avocado\";'].join('\\n'),\n      '/fruits/banana.js': ['module.exports = \"banana\";'].join('\\n'),\n      '/fruits/banana:colon.js': ['module.exports = \"bananaColon\";'].join('\\n'),\n      '/fruits/grapefruit.js': [\n        'module.exports = function () { return \"grapefruit\"; }',\n      ].join('\\n'),\n      '/fruits/kiwi.js': ['module.exports = () => \"kiwi\";'].join('\\n'),\n      '/fruits/mango.js': ['module.exports = () => \"mango\";'].join('\\n'),\n      '/fruits/package.json': ['{\"name\": \"fruits\"}'].join('\\n'),\n      '/node_modules/react.js': ['module.exports = \"react\";'].join('\\n'),\n      '/styles/App.css': ['root {', '  font-family: Helvetica;', '}'].join(\n        '\\n',\n      ),\n    });\n\n    fs = require('graceful-fs') as typeof import('fs');\n\n    writeFileAtomic =\n      require('write-file-atomic') as typeof import('write-file-atomic');\n\n    config = makeProjectConfig({\n      cache: true,\n      cacheDirectory: '/cache/',\n      id: 'test',\n      rootDir: '/',\n      transformIgnorePatterns: ['/node_modules/'],\n    });\n\n    createScriptTransformer = (\n      require('../ScriptTransformer') as typeof import('../ScriptTransformer')\n    ).createScriptTransformer;\n  };\n\n  beforeEach(reset);\n  afterEach(() => {\n    jest.unmock('../shouldInstrument');\n  });\n\n  it('transforms a file properly', async () => {\n    const scriptTransformer = await createScriptTransformer(config);\n    const transformedBananaWithCoverage = scriptTransformer.transform(\n      '/fruits/banana.js',\n      getCoverageOptions({collectCoverage: true}),\n    );\n\n    expect(transformedBananaWithCoverage.code).toMatchSnapshot();\n\n    // no-cache case\n    expect(fs.readFileSync).toHaveBeenCalledTimes(1);\n    expect(fs.readFileSync).toHaveBeenCalledWith('/fruits/banana.js', 'utf8');\n\n    // in-memory cache\n    const transformedBananaWithCoverageAgain = scriptTransformer.transform(\n      '/fruits/banana.js',\n      getCoverageOptions({collectCoverage: true}),\n    );\n    expect(transformedBananaWithCoverageAgain).toBe(\n      transformedBananaWithCoverage,\n    );\n\n    const transformedKiwiWithCoverage = scriptTransformer.transform(\n      '/fruits/kiwi.js',\n      getCoverageOptions({collectCoverage: true}),\n    );\n    expect(transformedKiwiWithCoverage.code).toMatchSnapshot();\n\n    expect(transformedBananaWithCoverage.code).not.toEqual(\n      transformedKiwiWithCoverage.code,\n    );\n    expect(transformedBananaWithCoverage.code).not.toMatch(/instrumented kiwi/);\n\n    // If we disable coverage, we get a different result.\n    const transformedKiwiWithoutCoverage = scriptTransformer.transform(\n      '/fruits/kiwi.js',\n      getCoverageOptions({collectCoverage: false}),\n    );\n\n    expect(transformedKiwiWithoutCoverage.code).not.toEqual(\n      transformedKiwiWithCoverage.code,\n    );\n  });\n\n  it('transforms a file async properly', async () => {\n    const scriptTransformer = await createScriptTransformer(config);\n    const transformedBananaWithCoverage =\n      await scriptTransformer.transformAsync(\n        '/fruits/banana.js',\n        getCoverageOptions({collectCoverage: true}),\n      );\n\n    expect(transformedBananaWithCoverage.code).toMatchSnapshot();\n\n    // no-cache case\n    expect(fs.readFileSync).toHaveBeenCalledTimes(1);\n    expect(fs.readFileSync).toHaveBeenCalledWith('/fruits/banana.js', 'utf8');\n\n    // in-memory cache\n    const transformedBananaWithCoverageAgain =\n      await scriptTransformer.transformAsync(\n        '/fruits/banana.js',\n        getCoverageOptions({collectCoverage: true}),\n      );\n    expect(transformedBananaWithCoverageAgain).toBe(\n      transformedBananaWithCoverage,\n    );\n\n    const transformedKiwiWithCoverage = await scriptTransformer.transformAsync(\n      '/fruits/kiwi.js',\n      getCoverageOptions({collectCoverage: true}),\n    );\n    expect(transformedKiwiWithCoverage.code).toMatchSnapshot();\n\n    expect(transformedBananaWithCoverage.code).not.toEqual(\n      transformedKiwiWithCoverage.code,\n    );\n    expect(transformedBananaWithCoverage.code).not.toMatch(/instrumented kiwi/);\n\n    // If we disable coverage, we get a different result.\n    const transformedKiwiWithoutCoverage =\n      await scriptTransformer.transformAsync(\n        '/fruits/kiwi.js',\n        getCoverageOptions({collectCoverage: false}),\n      );\n\n    expect(transformedKiwiWithoutCoverage.code).not.toEqual(\n      transformedKiwiWithCoverage.code,\n    );\n  });\n\n  it(\"throws an error if `process` doesn't return an object containing `code` key with processed string\", async () => {\n    config = {\n      ...config,\n      transform: [['\\\\.js$', 'passthrough-preprocessor', {}]],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n\n    const incorrectReturnValues = [\n      [undefined, '/fruits/banana.js'],\n      ['code', '/fruits/banana.js'],\n      [{a: 'a'}, '/fruits/kiwi.js'],\n      [[], '/fruits/grapefruit.js'],\n    ];\n\n    for (const [returnValue, filePath] of incorrectReturnValues) {\n      mockInvariant(typeof filePath === 'string');\n      jest\n        .mocked(\n          (require('passthrough-preprocessor') as SyncTransformer).process,\n        )\n        .mockReturnValue(returnValue);\n      expect(() =>\n        scriptTransformer.transform(filePath, getCoverageOptions()),\n      ).toThrowErrorMatchingSnapshot();\n    }\n\n    const correctReturnValues = [[{code: 'code'}, '/fruits/kiwi.js']];\n\n    for (const [returnValue, filePath] of correctReturnValues) {\n      mockInvariant(typeof filePath === 'string');\n      jest\n        .mocked(\n          (require('passthrough-preprocessor') as SyncTransformer).process,\n        )\n        .mockReturnValue(returnValue);\n      expect(() =>\n        scriptTransformer.transform(filePath, getCoverageOptions()),\n      ).not.toThrow();\n    }\n  });\n\n  it(\"throws an error if `processAsync` doesn't return a promise of object containing `code` key with processed string\", async () => {\n    const incorrectReturnValues: Array<[unknown, string]> = [\n      [undefined, '/fruits/banana.js'],\n      ['code', '/fruits/avocado.js'],\n      [{a: 'a'}, '/fruits/kiwi.js'],\n      [[], '/fruits/grapefruit.js'],\n    ];\n\n    const correctReturnValues: Array<[TransformedSource, string]> = [\n      [{code: 'code'}, '/fruits/mango.js'],\n    ];\n\n    const buildPromise = async ([returnValue, filePath]: [\n      TransformedSource,\n      string,\n    ]): Promise<any> => {\n      const processorName = `passthrough-preprocessor${filePath.replaceAll(\n        /\\.|\\//g,\n        '-',\n      )}`;\n\n      jest.doMock(\n        processorName,\n        () => ({\n          processAsync: jest.fn(),\n        }),\n        {virtual: true},\n      );\n      const transformer = require(processorName) as AsyncTransformer;\n      jest.mocked(transformer.processAsync).mockResolvedValue(returnValue);\n\n      config = {\n        ...config,\n        transform: [...incorrectReturnValues, ...correctReturnValues].map(\n          ([_, filePath]) => [filePath, processorName, {}],\n        ),\n      };\n\n      const scriptTransformer = await createScriptTransformer(config);\n\n      return scriptTransformer.transformAsync(filePath, getCoverageOptions());\n    };\n\n    const promisesToReject = incorrectReturnValues\n      .map(buildPromise)\n      .map(promise => expect(promise).rejects.toThrowErrorMatchingSnapshot());\n\n    const promisesToResolve = correctReturnValues\n      .map(buildPromise)\n      .map(promise => expect(promise).resolves.toHaveProperty('code'));\n\n    await Promise.all([...promisesToReject, ...promisesToResolve]);\n  });\n\n  it('throws an error if neither `process` nor `processAsync` is defined', async () => {\n    config = {\n      ...config,\n      transform: [['\\\\.js$', 'skipped-required-props-preprocessor', {}]],\n    };\n    await expect(() =>\n      createScriptTransformer(config),\n    ).rejects.toThrowErrorMatchingSnapshot();\n  });\n\n  it(\"(in sync mode) throws an error if `process` isn't defined\", async () => {\n    config = {\n      ...config,\n      transform: [\n        ['\\\\.js$', 'skipped-required-props-preprocessor-only-async', {}],\n      ],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n    expect(() =>\n      scriptTransformer.transformSource(\n        'sample.js',\n        '',\n        getTransformOptions(false),\n      ),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  it('(in async mode) handles only sync `process`', async () => {\n    config = {\n      ...config,\n      transform: [\n        ['\\\\.js$', 'skipped-required-props-preprocessor-only-sync', {}],\n      ],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n    expect(\n      await scriptTransformer.transformSourceAsync(\n        'sample.js',\n        '',\n        getTransformOptions(false),\n      ),\n    ).toBeDefined();\n  });\n\n  it('handle async createTransformer', async () => {\n    config = {\n      ...config,\n      transform: [['\\\\.js$', 'async-factory', {}]],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n    expect(\n      await scriptTransformer.transformSourceAsync(\n        'sample.js',\n        '',\n        getTransformOptions(false),\n      ),\n    ).toBeDefined();\n  });\n\n  it('throws an error if createTransformer returns object without `process` method', async () => {\n    config = {\n      ...config,\n      transform: [\n        [\n          '\\\\.js$',\n          'skipped-required-create-transformer-props-preprocessor',\n          {},\n        ],\n      ],\n    };\n    await expect(() =>\n      createScriptTransformer(config),\n    ).rejects.toThrowErrorMatchingSnapshot();\n  });\n\n  it(\"shouldn't throw error without process method. But with correct createTransformer method\", async () => {\n    config = {\n      ...config,\n      transform: [['\\\\.js$', 'skipped-process-method-preprocessor', {}]],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n    expect(() =>\n      scriptTransformer.transformSource(\n        'sample.js',\n        '',\n        getTransformOptions(false),\n      ),\n    ).not.toThrow();\n  });\n\n  it(\"in async mode, shouldn't throw if createTransformer returns an preprocessor with `process` or `processAsync`\", async () => {\n    config = {\n      ...config,\n      transform: [\n        ['async-sample.js', 'factory-for-async-preprocessor', {}],\n        ['sync-sample.js', 'skipped-process-method-preprocessor', {}],\n      ],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n    await Promise.all([\n      expect(\n        scriptTransformer.transformSourceAsync(\n          'async-sample.js',\n          '',\n          getTransformOptions(false),\n        ),\n      ).resolves.toBeDefined(),\n      expect(\n        scriptTransformer.transformSourceAsync(\n          'sync-sample.js',\n          '',\n          getTransformOptions(false),\n        ),\n      ).resolves.toBeDefined(),\n    ]);\n  });\n\n  it('uses the supplied preprocessor', async () => {\n    config = {...config, transform: [['\\\\.js$', 'test_preprocessor', {}]]};\n    const scriptTransformer = await createScriptTransformer(config);\n    const res1 = scriptTransformer.transform(\n      '/fruits/banana.js',\n      getCoverageOptions(),\n    );\n\n    expect(\n      (require('test_preprocessor') as SyncTransformer).getCacheKey,\n    ).toHaveBeenCalled();\n\n    expect(res1.code).toMatchSnapshot();\n\n    const res2 = scriptTransformer.transform(\n      '/node_modules/react.js',\n      getCoverageOptions(),\n    );\n    // ignores preprocessor\n    expect(res2.code).toMatchSnapshot();\n  });\n\n  it('in async mode, uses the supplied preprocessor', async () => {\n    config = {...config, transform: [['\\\\.js$', 'test_preprocessor', {}]]};\n    const scriptTransformer = await createScriptTransformer(config);\n    const res1 = await scriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions(),\n    );\n\n    expect(\n      (require('test_preprocessor') as SyncTransformer).getCacheKey,\n    ).toHaveBeenCalled();\n\n    expect(res1.code).toMatchSnapshot();\n\n    const res2 = await scriptTransformer.transformAsync(\n      '/node_modules/react.js',\n      getCoverageOptions(),\n    );\n    // ignores preprocessor\n    expect(res2.code).toMatchSnapshot();\n  });\n\n  it('in async mode, uses the supplied async preprocessor', async () => {\n    config = {\n      ...config,\n      transform: [['\\\\.js$', 'test_async_preprocessor', {}]],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n    const res1 = await scriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions(),\n    );\n\n    expect(\n      (require('test_async_preprocessor') as AsyncTransformer).getCacheKeyAsync,\n    ).toHaveBeenCalled();\n\n    expect(res1.code).toMatchSnapshot();\n\n    const res2 = await scriptTransformer.transformAsync(\n      '/node_modules/react.js',\n      getCoverageOptions(),\n    );\n    // ignores preprocessor\n    expect(res2.code).toMatchSnapshot();\n  });\n\n  it('uses multiple preprocessors', async () => {\n    config = {\n      ...config,\n      transform: [\n        ['\\\\.js$', 'test_preprocessor', {}],\n        ['\\\\.css$', 'css-preprocessor', {}],\n      ],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n\n    const res1 = scriptTransformer.transform(\n      '/fruits/banana.js',\n      getCoverageOptions(),\n    );\n    const res2 = scriptTransformer.transform(\n      '/styles/App.css',\n      getCoverageOptions(),\n    );\n\n    expect(\n      (require('test_preprocessor') as SyncTransformer).getCacheKey,\n    ).toHaveBeenCalled();\n    expect(\n      (require('css-preprocessor') as SyncTransformer).getCacheKey,\n    ).toHaveBeenCalled();\n    expect(res1.code).toMatchSnapshot();\n    expect(res2.code).toMatchSnapshot();\n\n    const res3 = scriptTransformer.transform(\n      '/node_modules/react.js',\n      getCoverageOptions(),\n    );\n    // ignores preprocessor\n    expect(res3.code).toMatchSnapshot();\n  });\n\n  it('uses mixture of sync/async preprocessors', async () => {\n    config = {\n      ...config,\n      transform: [\n        ['\\\\.js$', 'test_async_preprocessor', {}],\n        ['\\\\.css$', 'css-preprocessor', {}],\n      ],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n\n    const res1 = await scriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions(),\n    );\n    const res2 = await scriptTransformer.transformAsync(\n      '/styles/App.css',\n      getCoverageOptions(),\n    );\n\n    expect(\n      (require('test_async_preprocessor') as AsyncTransformer).getCacheKeyAsync,\n    ).toHaveBeenCalled();\n    expect(\n      (require('css-preprocessor') as SyncTransformer).getCacheKey,\n    ).toHaveBeenCalled();\n    expect(res1.code).toMatchSnapshot();\n    expect(res2.code).toMatchSnapshot();\n\n    const res3 = await scriptTransformer.transformAsync(\n      '/node_modules/react.js',\n      getCoverageOptions(),\n    );\n    // ignores preprocessor\n    expect(res3.code).toMatchSnapshot();\n  });\n\n  it('writes source map if preprocessor supplies it', async () => {\n    config = {\n      ...config,\n      transform: [['\\\\.js$', 'preprocessor-with-sourcemaps', {}]],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n\n    const map = {\n      mappings: ';AAAA',\n      version: 3,\n    };\n\n    jest\n      .mocked(\n        (require('preprocessor-with-sourcemaps') as SyncTransformer).process,\n      )\n      .mockReturnValue({\n        code: 'content',\n        map,\n      });\n\n    const result = scriptTransformer.transform(\n      '/fruits/banana.js',\n      getCoverageOptions(),\n    );\n    expect(result.sourceMapPath).toEqual(expect.any(String));\n    const mapStr = JSON.stringify(map);\n    expect(writeFileAtomic.sync).toHaveBeenCalledTimes(2);\n    expect(writeFileAtomic.sync).toHaveBeenCalledWith(\n      result.sourceMapPath,\n      mapStr,\n      {\n        encoding: 'utf8',\n        fsync: false,\n      },\n    );\n  });\n\n  it('in async mode, writes source map if preprocessor supplies it', async () => {\n    config = {\n      ...config,\n      transform: [['\\\\.js$', 'preprocessor-with-sourcemaps', {}]],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n\n    const map = {\n      mappings: ';AAAA',\n      version: 3,\n    };\n\n    jest\n      .mocked(\n        (require('preprocessor-with-sourcemaps') as SyncTransformer).process,\n      )\n      .mockReturnValue({\n        code: 'content',\n        map,\n      });\n\n    const result = await scriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions(),\n    );\n    expect(result.sourceMapPath).toEqual(expect.any(String));\n    const mapStr = JSON.stringify(map);\n    expect(writeFileAtomic.sync).toHaveBeenCalledTimes(2);\n    expect(writeFileAtomic.sync).toHaveBeenCalledWith(\n      result.sourceMapPath,\n      mapStr,\n      {\n        encoding: 'utf8',\n        fsync: false,\n      },\n    );\n  });\n\n  it('in async mode, writes source map if async preprocessor supplies it', async () => {\n    config = {\n      ...config,\n      transform: [['\\\\.js$', 'async-preprocessor-with-sourcemaps', {}]],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n\n    const map = {\n      mappings: ';AAAA',\n      version: 3,\n    };\n\n    jest\n      .mocked(\n        (require('async-preprocessor-with-sourcemaps') as AsyncTransformer)\n          .processAsync,\n      )\n      .mockResolvedValue({\n        code: 'content',\n        map,\n      });\n\n    const result = await scriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions(),\n    );\n    expect(result.sourceMapPath).toEqual(expect.any(String));\n    const mapStr = JSON.stringify(map);\n    expect(writeFileAtomic.sync).toHaveBeenCalledTimes(2);\n    expect(writeFileAtomic.sync).toHaveBeenCalledWith(\n      result.sourceMapPath,\n      mapStr,\n      {\n        encoding: 'utf8',\n        fsync: false,\n      },\n    );\n  });\n\n  it('writes source map if preprocessor inlines it', async () => {\n    config = {\n      ...config,\n      transform: [['\\\\.js$', 'preprocessor-with-sourcemaps', {}]],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n\n    const sourceMap = JSON.stringify({\n      mappings: 'AAAA,IAAM,CAAC,GAAW,CAAC,CAAC',\n      version: 3,\n    });\n\n    const content =\n      'var x = 1;\\n' +\n      `//# sourceMappingURL=data:application/json;base64,${Buffer.from(\n        sourceMap,\n      ).toString('base64')}`;\n\n    jest\n      .mocked(\n        (require('preprocessor-with-sourcemaps') as SyncTransformer).process,\n      )\n      .mockReturnValue({\n        code: content,\n      });\n\n    const result = scriptTransformer.transform(\n      '/fruits/banana.js',\n      getCoverageOptions(),\n    );\n    expect(result.sourceMapPath).toEqual(expect.any(String));\n    expect(writeFileAtomic.sync).toHaveBeenCalledTimes(2);\n    expect(writeFileAtomic.sync).toHaveBeenCalledWith(\n      result.sourceMapPath,\n      sourceMap,\n      {encoding: 'utf8', fsync: false},\n    );\n  });\n\n  it('in async mode, writes source map if preprocessor inlines it', async () => {\n    config = {\n      ...config,\n      transform: [['\\\\.js$', 'preprocessor-with-sourcemaps', {}]],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n\n    const sourceMap = JSON.stringify({\n      mappings: 'AAAA,IAAM,CAAC,GAAW,CAAC,CAAC',\n      version: 3,\n    });\n\n    const content =\n      'var x = 1;\\n' +\n      `//# sourceMappingURL=data:application/json;base64,${Buffer.from(\n        sourceMap,\n      ).toString('base64')}`;\n\n    jest\n      .mocked(\n        (require('preprocessor-with-sourcemaps') as SyncTransformer).process,\n      )\n      .mockReturnValue({\n        code: content,\n      });\n\n    const result = await scriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions(),\n    );\n    expect(result.sourceMapPath).toEqual(expect.any(String));\n    expect(writeFileAtomic.sync).toHaveBeenCalledTimes(2);\n    expect(writeFileAtomic.sync).toHaveBeenCalledWith(\n      result.sourceMapPath,\n      sourceMap,\n      {encoding: 'utf8', fsync: false},\n    );\n  });\n\n  it('writes source map if async preprocessor inlines it', async () => {\n    config = {\n      ...config,\n      transform: [['\\\\.js$', 'async-preprocessor-with-sourcemaps', {}]],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n\n    const sourceMap = JSON.stringify({\n      mappings: 'AAAA,IAAM,CAAC,GAAW,CAAC,CAAC',\n      version: 3,\n    });\n\n    const content =\n      'var x = 1;\\n' +\n      `//# sourceMappingURL=data:application/json;base64,${Buffer.from(\n        sourceMap,\n      ).toString('base64')}`;\n\n    jest\n      .mocked(\n        (require('async-preprocessor-with-sourcemaps') as AsyncTransformer)\n          .processAsync,\n      )\n      .mockResolvedValue({code: content});\n\n    const result = await scriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions(),\n    );\n    expect(result.sourceMapPath).toEqual(expect.any(String));\n    expect(writeFileAtomic.sync).toHaveBeenCalledTimes(2);\n    expect(writeFileAtomic.sync).toHaveBeenCalledWith(\n      result.sourceMapPath,\n      sourceMap,\n      {encoding: 'utf8', fsync: false},\n    );\n  });\n\n  it('warns of unparsable inlined source maps from the preprocessor', async () => {\n    const warn = console.warn;\n    console.warn = jest.fn();\n\n    config = {\n      ...config,\n      transform: [['\\\\.js$', 'preprocessor-with-sourcemaps', {}]],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n\n    const sourceMap = JSON.stringify({\n      mappings: 'AAAA,IAAM,CAAC,GAAW,CAAC,CAAC',\n      version: 3,\n    });\n\n    // Cut off the inlined map prematurely with slice so the JSON ends abruptly\n    const content =\n      'var x = 1;\\n' +\n      `//# sourceMappingURL=data:application/json;base64,${Buffer.from(\n        sourceMap,\n      )\n        .toString('base64')\n        .slice(0, 16)}`;\n\n    jest\n      .mocked(\n        (require('preprocessor-with-sourcemaps') as SyncTransformer).process,\n      )\n      .mockReturnValue({\n        code: content,\n      });\n\n    const result = scriptTransformer.transform(\n      '/fruits/banana.js',\n      getCoverageOptions({collectCoverage: true}),\n    );\n    expect(result.sourceMapPath).toBeNull();\n    expect(writeFileAtomic.sync).toHaveBeenCalledTimes(1);\n\n    expect(console.warn).toHaveBeenCalledTimes(1);\n    expect(jest.mocked(console.warn).mock.calls[0][0]).toMatchSnapshot();\n    console.warn = warn;\n  });\n\n  it('in async mode, warns of unparsable inlined source maps from the preprocessor', async () => {\n    const warn = console.warn;\n    console.warn = jest.fn();\n\n    config = {\n      ...config,\n      transform: [['\\\\.js$', 'preprocessor-with-sourcemaps', {}]],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n\n    const sourceMap = JSON.stringify({\n      mappings: 'AAAA,IAAM,CAAC,GAAW,CAAC,CAAC',\n      version: 3,\n    });\n\n    // Cut off the inlined map prematurely with slice so the JSON ends abruptly\n    const content =\n      'var x = 1;\\n' +\n      `//# sourceMappingURL=data:application/json;base64,${Buffer.from(\n        sourceMap,\n      )\n        .toString('base64')\n        .slice(0, 16)}`;\n\n    jest\n      .mocked(\n        (require('preprocessor-with-sourcemaps') as SyncTransformer).process,\n      )\n      .mockReturnValue({\n        code: content,\n      });\n\n    const result = await scriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions({collectCoverage: true}),\n    );\n    expect(result.sourceMapPath).toBeNull();\n    expect(writeFileAtomic.sync).toHaveBeenCalledTimes(1);\n\n    expect(console.warn).toHaveBeenCalledTimes(1);\n    expect(jest.mocked(console.warn).mock.calls[0][0]).toMatchSnapshot();\n    console.warn = warn;\n  });\n\n  it('warns of unparsable inlined source maps from the async preprocessor', async () => {\n    const warn = console.warn;\n    console.warn = jest.fn();\n\n    config = {\n      ...config,\n      transform: [['\\\\.js$', 'async-preprocessor-with-sourcemaps', {}]],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n\n    const sourceMap = JSON.stringify({\n      mappings: 'AAAA,IAAM,CAAC,GAAW,CAAC,CAAC',\n      version: 3,\n    });\n\n    // Cut off the inlined map prematurely with slice so the JSON ends abruptly\n    const content =\n      'var x = 1;\\n' +\n      `//# sourceMappingURL=data:application/json;base64,${Buffer.from(\n        sourceMap,\n      )\n        .toString('base64')\n        .slice(0, 16)}`;\n\n    jest\n      .mocked(\n        (require('async-preprocessor-with-sourcemaps') as AsyncTransformer)\n          .processAsync,\n      )\n      .mockResolvedValue({code: content});\n\n    const result = await scriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions({collectCoverage: true}),\n    );\n    expect(result.sourceMapPath).toBeNull();\n    expect(writeFileAtomic.sync).toHaveBeenCalledTimes(1);\n\n    expect(console.warn).toHaveBeenCalledTimes(1);\n    expect(jest.mocked(console.warn).mock.calls[0][0]).toMatchSnapshot();\n    console.warn = warn;\n  });\n\n  // this duplicates with 'writes source map if preprocessor supplies it'\n  it('writes source maps if given by the transformer', async () => {\n    config = {\n      ...config,\n      transform: [['\\\\.js$', 'preprocessor-with-sourcemaps', {}]],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n\n    const map = {\n      mappings: ';AAAA',\n      version: 3,\n    };\n\n    jest\n      .mocked(\n        (require('preprocessor-with-sourcemaps') as SyncTransformer).process,\n      )\n      .mockReturnValue({\n        code: 'content',\n        map,\n      });\n\n    const result = scriptTransformer.transform(\n      '/fruits/banana.js',\n      getCoverageOptions(),\n    );\n    expect(result.sourceMapPath).toEqual(expect.any(String));\n    expect(writeFileAtomic.sync).toHaveBeenCalledTimes(2);\n    expect(writeFileAtomic.sync).toHaveBeenCalledWith(\n      result.sourceMapPath,\n      JSON.stringify(map),\n      {\n        encoding: 'utf8',\n        fsync: false,\n      },\n    );\n  });\n\n  it('does not write source map if not given by the transformer', async () => {\n    config = {\n      ...config,\n      transform: [['\\\\.js$', 'preprocessor-with-sourcemaps', {}]],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n\n    jest\n      .mocked(\n        (require('preprocessor-with-sourcemaps') as SyncTransformer).process,\n      )\n      .mockReturnValue({\n        code: 'content',\n        map: null,\n      });\n\n    const result = scriptTransformer.transform(\n      '/fruits/banana.js',\n      getCoverageOptions({collectCoverage: true}),\n    );\n    expect(result.sourceMapPath).toBeFalsy();\n    expect(writeFileAtomic.sync).toHaveBeenCalledTimes(1);\n  });\n\n  it('in async mode, does not write source map if not given by the transformer', async () => {\n    config = {\n      ...config,\n      transform: [['\\\\.js$', 'preprocessor-with-sourcemaps', {}]],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n\n    jest\n      .mocked(\n        (require('preprocessor-with-sourcemaps') as SyncTransformer).process,\n      )\n      .mockReturnValue({\n        code: 'content',\n        map: null,\n      });\n\n    const result = await scriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions({collectCoverage: true}),\n    );\n    expect(result.sourceMapPath).toBeFalsy();\n    expect(writeFileAtomic.sync).toHaveBeenCalledTimes(1);\n  });\n\n  it('does not write source map if not given by the async preprocessor', async () => {\n    config = {\n      ...config,\n      transform: [['\\\\.js$', 'async-preprocessor-with-sourcemaps', {}]],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n\n    jest\n      .mocked(\n        (require('async-preprocessor-with-sourcemaps') as AsyncTransformer)\n          .processAsync,\n      )\n      .mockResolvedValue({\n        code: 'content',\n        map: null,\n      });\n\n    const result = await scriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions({collectCoverage: true}),\n    );\n    expect(result.sourceMapPath).toBeFalsy();\n    expect(writeFileAtomic.sync).toHaveBeenCalledTimes(1);\n  });\n\n  it('should write a source map for the instrumented file when transformed', async () => {\n    const transformerConfig: Config.ProjectConfig = {\n      ...config,\n      transform: [['\\\\.js$', 'preprocessor-with-sourcemaps', {}]],\n    };\n    const scriptTransformer = await createScriptTransformer(transformerConfig);\n\n    const map = {\n      mappings: ';AAAA',\n      version: 3,\n    };\n\n    // A map from the original source to the instrumented output\n    /* eslint-disable sort-keys */\n    const instrumentedCodeMap: FixedRawSourceMap = {\n      version: 3,\n      names: ['cov_25u22311x4', 'actualCoverage', 's', 'content'],\n      sources: ['banana.js'],\n      sourcesContent: ['content'],\n      mappings:\n        ';;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAeY;IAAAA,cAAA,YAAAA,CAAA;MAAA,OAAAC,cAAA;IAAA;EAAA;EAAA,OAAAA,cAAA;AAAA;AAAAD,cAAA;AAAAA,cAAA,GAAAE,CAAA;AAfZC,OAAO',\n      ignoreList: [],\n    };\n    /* eslint-enable */\n\n    jest\n      .mocked(\n        (require('preprocessor-with-sourcemaps') as SyncTransformer).process,\n      )\n      .mockReturnValue({\n        code: 'content',\n        map,\n      });\n\n    const result = scriptTransformer.transform(\n      '/fruits/banana.js',\n      getCoverageOptions({collectCoverage: true}),\n    );\n    expect(result.sourceMapPath).toEqual(expect.any(String));\n    expect(writeFileAtomic.sync).toHaveBeenCalledTimes(2);\n    expect(writeFileAtomic.sync).toHaveBeenCalledWith(\n      result.sourceMapPath,\n      JSON.stringify(instrumentedCodeMap),\n      expect.anything(),\n    );\n\n    // Inline source map allows debugging of original source when running instrumented code\n    expect(result.code).toContain('//# sourceMappingURL');\n  });\n\n  it('in async mode, should write a source map for the instrumented file when transformed', async () => {\n    const transformerConfig: Config.ProjectConfig = {\n      ...config,\n      transform: [['\\\\.js$', 'preprocessor-with-sourcemaps', {}]],\n    };\n    const scriptTransformer = await createScriptTransformer(transformerConfig);\n\n    const map = {\n      mappings: ';AAAA',\n      version: 3,\n    };\n\n    // A map from the original source to the instrumented output\n    /* eslint-disable sort-keys */\n    const instrumentedCodeMap = {\n      version: 3,\n      names: ['cov_25u22311x4', 'actualCoverage', 's', 'content'],\n      sources: ['banana.js'],\n      sourcesContent: ['content'],\n      mappings:\n        ';;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAeY;IAAAA,cAAA,YAAAA,CAAA;MAAA,OAAAC,cAAA;IAAA;EAAA;EAAA,OAAAA,cAAA;AAAA;AAAAD,cAAA;AAAAA,cAAA,GAAAE,CAAA;AAfZC,OAAO',\n      ignoreList: [],\n    };\n    /* eslint-enable */\n\n    jest\n      .mocked(\n        (require('preprocessor-with-sourcemaps') as SyncTransformer).process,\n      )\n      .mockReturnValue({\n        code: 'content',\n        map,\n      });\n\n    const result = await scriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions({collectCoverage: true}),\n    );\n    expect(result.sourceMapPath).toEqual(expect.any(String));\n    expect(writeFileAtomic.sync).toHaveBeenCalledTimes(2);\n    expect(writeFileAtomic.sync).toHaveBeenCalledWith(\n      result.sourceMapPath,\n      JSON.stringify(instrumentedCodeMap),\n      expect.anything(),\n    );\n\n    // Inline source map allows debugging of original source when running instrumented code\n    expect(result.code).toContain('//# sourceMappingURL');\n  });\n\n  it('should write a source map for the instrumented file when async transformed', async () => {\n    const transformerConfig: Config.ProjectConfig = {\n      ...config,\n      transform: [['\\\\.js$', 'async-preprocessor-with-sourcemaps', {}]],\n    };\n    const scriptTransformer = await createScriptTransformer(transformerConfig);\n\n    const map = {\n      mappings: ';AAAA',\n      version: 3,\n    };\n\n    // A map from the original source to the instrumented output\n    /* eslint-disable sort-keys */\n    const instrumentedCodeMap = {\n      version: 3,\n      names: ['cov_25u22311x4', 'actualCoverage', 's', 'content'],\n      sources: ['banana.js'],\n      sourcesContent: ['content'],\n      mappings:\n        ';;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAeY;IAAAA,cAAA,YAAAA,CAAA;MAAA,OAAAC,cAAA;IAAA;EAAA;EAAA,OAAAA,cAAA;AAAA;AAAAD,cAAA;AAAAA,cAAA,GAAAE,CAAA;AAfZC,OAAO',\n      ignoreList: [],\n    };\n    /* eslint-enable */\n\n    jest\n      .mocked(\n        (require('async-preprocessor-with-sourcemaps') as AsyncTransformer)\n          .processAsync,\n      )\n      .mockResolvedValue({\n        code: 'content',\n        map,\n      });\n\n    const result = await scriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions({collectCoverage: true}),\n    );\n    expect(result.sourceMapPath).toEqual(expect.any(String));\n    expect(writeFileAtomic.sync).toHaveBeenCalledTimes(2);\n    expect(writeFileAtomic.sync).toHaveBeenCalledWith(\n      result.sourceMapPath,\n      JSON.stringify(instrumentedCodeMap),\n      expect.anything(),\n    );\n\n    // Inline source map allows debugging of original source when running instrumented code\n    expect(result.code).toContain('//# sourceMappingURL');\n  });\n\n  it('should write a source map for the instrumented file when not transformed', async () => {\n    const scriptTransformer = await createScriptTransformer(config);\n\n    // A map from the original source to the instrumented output\n    /* eslint-disable sort-keys */\n    const instrumentedCodeMap = {\n      version: 3,\n      names: ['cov_25u22311x4', 'actualCoverage', 's', 'module', 'exports'],\n      sources: ['banana.js'],\n      sourcesContent: ['module.exports = \"banana\";'],\n      mappings:\n        ';;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAeY;IAAAA,cAAA,YAAAA,CAAA;MAAA,OAAAC,cAAA;IAAA;EAAA;EAAA,OAAAA,cAAA;AAAA;AAAAD,cAAA;AAAAA,cAAA,GAAAE,CAAA;AAfZC,MAAM,CAACC,OAAO,GAAG,QAAQ',\n      ignoreList: [],\n    };\n    /* eslint-enable */\n\n    jest\n      .mocked(\n        (require('preprocessor-with-sourcemaps') as SyncTransformer).process,\n      )\n      .mockReturnValue({\n        code: 'content',\n        map: null,\n      });\n\n    const result = scriptTransformer.transform(\n      '/fruits/banana.js',\n      getCoverageOptions({collectCoverage: true}),\n    );\n    expect(result.sourceMapPath).toEqual(expect.any(String));\n    expect(writeFileAtomic.sync).toHaveBeenCalledTimes(2);\n    expect(writeFileAtomic.sync).toHaveBeenCalledWith(\n      result.sourceMapPath,\n      JSON.stringify(instrumentedCodeMap),\n      expect.anything(),\n    );\n\n    // Inline source map allows debugging of original source when running instrumented code\n    expect(result.code).toContain('//# sourceMappingURL');\n  });\n\n  it('in async mode, should write a source map for the instrumented file when not transformed', async () => {\n    const scriptTransformer = await createScriptTransformer(config);\n\n    // A map from the original source to the instrumented output\n    /* eslint-disable sort-keys */\n    const instrumentedCodeMap = {\n      version: 3,\n      names: ['cov_25u22311x4', 'actualCoverage', 's', 'module', 'exports'],\n      sources: ['banana.js'],\n      sourcesContent: ['module.exports = \"banana\";'],\n      mappings:\n        ';;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAeY;IAAAA,cAAA,YAAAA,CAAA;MAAA,OAAAC,cAAA;IAAA;EAAA;EAAA,OAAAA,cAAA;AAAA;AAAAD,cAAA;AAAAA,cAAA,GAAAE,CAAA;AAfZC,MAAM,CAACC,OAAO,GAAG,QAAQ',\n      ignoreList: [],\n    };\n    /* eslint-enable */\n\n    jest\n      .mocked(\n        (require('preprocessor-with-sourcemaps') as SyncTransformer).process,\n      )\n      .mockReturnValue({\n        code: 'content',\n        map: null,\n      });\n\n    const result = await scriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions({collectCoverage: true}),\n    );\n    expect(result.sourceMapPath).toEqual(expect.any(String));\n    expect(writeFileAtomic.sync).toHaveBeenCalledTimes(2);\n    expect(writeFileAtomic.sync).toHaveBeenCalledWith(\n      result.sourceMapPath,\n      JSON.stringify(instrumentedCodeMap),\n      expect.anything(),\n    );\n\n    // Inline source map allows debugging of original source when running instrumented code\n    expect(result.code).toContain('//# sourceMappingURL');\n  });\n\n  it('should write a source map for the instrumented file when not transformed by async preprocessor', async () => {\n    const scriptTransformer = await createScriptTransformer(config);\n\n    // A map from the original source to the instrumented output\n    /* eslint-disable sort-keys */\n    const instrumentedCodeMap = {\n      version: 3,\n      names: ['cov_25u22311x4', 'actualCoverage', 's', 'module', 'exports'],\n      sources: ['banana.js'],\n      sourcesContent: ['module.exports = \"banana\";'],\n      mappings:\n        ';;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAeY;IAAAA,cAAA,YAAAA,CAAA;MAAA,OAAAC,cAAA;IAAA;EAAA;EAAA,OAAAA,cAAA;AAAA;AAAAD,cAAA;AAAAA,cAAA,GAAAE,CAAA;AAfZC,MAAM,CAACC,OAAO,GAAG,QAAQ',\n      ignoreList: [],\n    };\n    /* eslint-enable */\n\n    jest\n      .mocked(\n        (require('async-preprocessor-with-sourcemaps') as AsyncTransformer)\n          .processAsync,\n      )\n      .mockResolvedValue({\n        code: 'content',\n        map: null,\n      });\n\n    const result = await scriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions({collectCoverage: true}),\n    );\n    expect(result.sourceMapPath).toEqual(expect.any(String));\n    expect(writeFileAtomic.sync).toHaveBeenCalledTimes(2);\n    expect(writeFileAtomic.sync).toHaveBeenCalledWith(\n      result.sourceMapPath,\n      JSON.stringify(instrumentedCodeMap),\n      expect.anything(),\n    );\n\n    // Inline source map allows debugging of original source when running instrumented code\n    expect(result.code).toContain('//# sourceMappingURL');\n  });\n\n  it('passes expected transform options to getCacheKey', async () => {\n    config = {\n      ...config,\n      transform: [['\\\\.js$', 'test_preprocessor', {configKey: 'configValue'}]],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n\n    scriptTransformer.transform(\n      '/fruits/banana.js',\n      getCoverageOptions({collectCoverage: true}),\n    );\n\n    const {getCacheKey} = require('test_preprocessor') as SyncTransformer;\n    expect(getCacheKey).toMatchSnapshot();\n  });\n\n  it('in async mode, passes expected transform options to getCacheKey', async () => {\n    config = {\n      ...config,\n      transform: [['\\\\.js$', 'test_preprocessor', {configKey: 'configValue'}]],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n\n    await scriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions({collectCoverage: true}),\n    );\n\n    const {getCacheKey} = require('test_preprocessor') as SyncTransformer;\n    expect(getCacheKey).toMatchSnapshot();\n  });\n\n  it('passes expected transform options to getCacheKeyAsync', async () => {\n    config = {\n      ...config,\n      transform: [\n        ['\\\\.js$', 'test_async_preprocessor', {configKey: 'configValue'}],\n      ],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n\n    await scriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions({collectCoverage: true}),\n    );\n\n    const {getCacheKeyAsync} =\n      require('test_async_preprocessor') as AsyncTransformer;\n    expect(getCacheKeyAsync).toMatchSnapshot();\n  });\n\n  it('creates transformer with config', async () => {\n    const transformerConfig = {};\n    config = Object.assign(config, {\n      transform: [['\\\\.js$', 'configureable-preprocessor', transformerConfig]],\n    });\n    const scriptTransformer = await createScriptTransformer(config);\n\n    scriptTransformer.transform('/fruits/banana.js', getCoverageOptions());\n    expect(\n      (\n        require('configureable-preprocessor') as TransformerFactory<SyncTransformer>\n      ).createTransformer,\n    ).toHaveBeenCalledWith(transformerConfig);\n  });\n\n  it('passes correct config to a preprocessor used multiple times', async () => {\n    const transformerConfig1 = {};\n    const transformerConfig2 = {};\n\n    config = Object.assign(config, {\n      transform: [\n        // same preprocessor\n        [\n          // *only* /fruits/banana.js\n          '/fruits/banana\\\\.js$',\n          'configureable-preprocessor',\n          transformerConfig1,\n        ],\n        [\n          // *not* /fruits/banana.js\n          '/fruits/(?!banana)\\\\w+\\\\.js$',\n          'configureable-preprocessor',\n          transformerConfig2,\n        ],\n      ],\n    });\n\n    const scriptTransformer = await createScriptTransformer(config);\n\n    scriptTransformer.transform('/fruits/banana.js', getCoverageOptions());\n    expect(\n      (\n        require('configureable-preprocessor') as TransformerFactory<SyncTransformer>\n      ).createTransformer,\n    ).toHaveBeenLastCalledWith(transformerConfig1);\n\n    scriptTransformer.transform('/fruits/kiwi.js', getCoverageOptions());\n    expect(\n      (\n        require('configureable-preprocessor') as TransformerFactory<SyncTransformer>\n      ).createTransformer,\n    ).toHaveBeenLastCalledWith(transformerConfig2);\n  });\n\n  it('reads values from the cache', async () => {\n    const transformConfig: Config.ProjectConfig = {\n      ...config,\n      transform: [['\\\\.js$', 'test_preprocessor', {}]],\n    };\n    let scriptTransformer = await createScriptTransformer(transformConfig);\n    scriptTransformer.transform('/fruits/banana.js', getCoverageOptions());\n\n    const cachePath = getCachePath(mockFs, config);\n    expect(writeFileAtomic.sync).toHaveBeenCalled();\n    expect(jest.mocked(writeFileAtomic.sync).mock.calls[0][0]).toBe(cachePath);\n\n    // Cache the state in `mockFsCopy`\n    const mockFsCopy = mockFs;\n    jest.resetModules();\n    reset();\n\n    // Restore the cached fs\n    mockFs = mockFsCopy;\n    scriptTransformer = await createScriptTransformer(transformConfig);\n    scriptTransformer.transform('/fruits/banana.js', getCoverageOptions());\n\n    expect(fs.readFileSync).toHaveBeenCalledTimes(2);\n    expect(fs.readFileSync).toHaveBeenCalledWith('/fruits/banana.js', 'utf8');\n    expect(fs.readFileSync).toHaveBeenCalledWith(cachePath, 'utf8');\n    expect(writeFileAtomic.sync).not.toHaveBeenCalled();\n\n    // Don't read from the cache when `config.cache` is false.\n    jest.resetModules();\n    reset();\n    mockFs = mockFsCopy;\n    transformConfig.cache = false;\n    scriptTransformer = await createScriptTransformer(transformConfig);\n    scriptTransformer.transform('/fruits/banana.js', getCoverageOptions());\n\n    expect(fs.readFileSync).toHaveBeenCalledTimes(1);\n    expect(fs.readFileSync).toHaveBeenCalledWith('/fruits/banana.js', 'utf8');\n    expect(fs.readFileSync).not.toHaveBeenCalledWith(cachePath, 'utf8');\n    expect(writeFileAtomic.sync).toHaveBeenCalled();\n  });\n\n  it('in async mode, reads values from the cache', async () => {\n    const transformConfig: Config.ProjectConfig = {\n      ...config,\n      transform: [['\\\\.js$', 'test_preprocessor', {}]],\n    };\n    let scriptTransformer = await createScriptTransformer(transformConfig);\n    await scriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions(),\n    );\n\n    const cachePath = getCachePath(mockFs, config);\n    expect(writeFileAtomic.sync).toHaveBeenCalled();\n    expect(jest.mocked(writeFileAtomic.sync).mock.calls[0][0]).toBe(cachePath);\n\n    // Cache the state in `mockFsCopy`\n    const mockFsCopy = mockFs;\n    jest.resetModules();\n    reset();\n\n    // Restore the cached fs\n    mockFs = mockFsCopy;\n    scriptTransformer = await createScriptTransformer(transformConfig);\n    await scriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions(),\n    );\n\n    expect(fs.readFileSync).toHaveBeenCalledTimes(2);\n    expect(fs.readFileSync).toHaveBeenCalledWith('/fruits/banana.js', 'utf8');\n    expect(fs.readFileSync).toHaveBeenCalledWith(cachePath, 'utf8');\n    expect(writeFileAtomic.sync).not.toHaveBeenCalled();\n\n    // Don't read from the cache when `config.cache` is false.\n    jest.resetModules();\n    reset();\n    mockFs = mockFsCopy;\n    transformConfig.cache = false;\n    scriptTransformer = await createScriptTransformer(transformConfig);\n    await scriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions(),\n    );\n\n    expect(fs.readFileSync).toHaveBeenCalledTimes(1);\n    expect(fs.readFileSync).toHaveBeenCalledWith('/fruits/banana.js', 'utf8');\n    expect(fs.readFileSync).not.toHaveBeenCalledWith(cachePath, 'utf8');\n    expect(writeFileAtomic.sync).toHaveBeenCalled();\n  });\n\n  it('reads values from the cache when using async preprocessor', async () => {\n    const transformConfig: Config.ProjectConfig = {\n      ...config,\n      transform: [['\\\\.js$', 'test_async_preprocessor', {}]],\n    };\n    let scriptTransformer = await createScriptTransformer(transformConfig);\n    await scriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions(),\n    );\n\n    const cachePath = getCachePath(mockFs, config);\n    expect(writeFileAtomic.sync).toHaveBeenCalled();\n    expect(jest.mocked(writeFileAtomic.sync).mock.calls[0][0]).toBe(cachePath);\n\n    // Cache the state in `mockFsCopy`\n    const mockFsCopy = mockFs;\n    jest.resetModules();\n    reset();\n\n    // Restore the cached fs\n    mockFs = mockFsCopy;\n    scriptTransformer = await createScriptTransformer(transformConfig);\n    await scriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions(),\n    );\n\n    expect(fs.readFileSync).toHaveBeenCalledTimes(2);\n    expect(fs.readFileSync).toHaveBeenCalledWith('/fruits/banana.js', 'utf8');\n    expect(fs.readFileSync).toHaveBeenCalledWith(cachePath, 'utf8');\n    expect(writeFileAtomic.sync).not.toHaveBeenCalled();\n\n    // Don't read from the cache when `config.cache` is false.\n    jest.resetModules();\n    reset();\n    mockFs = mockFsCopy;\n    transformConfig.cache = false;\n    scriptTransformer = await createScriptTransformer(transformConfig);\n    await scriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions(),\n    );\n\n    expect(fs.readFileSync).toHaveBeenCalledTimes(1);\n    expect(fs.readFileSync).toHaveBeenCalledWith('/fruits/banana.js', 'utf8');\n    expect(fs.readFileSync).not.toHaveBeenCalledWith(cachePath, 'utf8');\n    expect(writeFileAtomic.sync).toHaveBeenCalled();\n  });\n\n  it('reads values from the cache when the file contains colons', async () => {\n    const transformConfig: Config.ProjectConfig = {\n      ...config,\n      transform: [['\\\\.js$', 'test_preprocessor', {}]],\n    };\n    let scriptTransformer = await createScriptTransformer(transformConfig);\n    scriptTransformer.transform(\n      '/fruits/banana:colon.js',\n      getCoverageOptions(),\n    );\n\n    const cachePath = getCachePath(mockFs, config);\n    expect(writeFileAtomic.sync).toHaveBeenCalled();\n    expect(jest.mocked(writeFileAtomic.sync).mock.calls[0][0]).toBe(cachePath);\n\n    // Cache the state in `mockFsCopy`\n    const mockFsCopy = mockFs;\n    jest.resetModules();\n    reset();\n\n    // Restore the cached fs\n    mockFs = mockFsCopy;\n    scriptTransformer = await createScriptTransformer(transformConfig);\n    scriptTransformer.transform(\n      '/fruits/banana:colon.js',\n      getCoverageOptions(),\n    );\n\n    expect(fs.readFileSync).toHaveBeenCalledTimes(2);\n    expect(fs.readFileSync).toHaveBeenCalledWith(\n      '/fruits/banana:colon.js',\n      'utf8',\n    );\n    expect(fs.readFileSync).toHaveBeenCalledWith(cachePath, 'utf8');\n    expect(writeFileAtomic.sync).not.toHaveBeenCalled();\n  });\n\n  it('in async mode, reads values from the cache when the file contains colons', async () => {\n    const transformConfig: Config.ProjectConfig = {\n      ...config,\n      transform: [['\\\\.js$', 'test_preprocessor', {}]],\n    };\n    let scriptTransformer = await createScriptTransformer(transformConfig);\n    await scriptTransformer.transformAsync(\n      '/fruits/banana:colon.js',\n      getCoverageOptions(),\n    );\n\n    const cachePath = getCachePath(mockFs, config);\n    expect(writeFileAtomic.sync).toHaveBeenCalled();\n    expect(jest.mocked(writeFileAtomic.sync).mock.calls[0][0]).toBe(cachePath);\n\n    // Cache the state in `mockFsCopy`\n    const mockFsCopy = mockFs;\n    jest.resetModules();\n    reset();\n\n    // Restore the cached fs\n    mockFs = mockFsCopy;\n    scriptTransformer = await createScriptTransformer(transformConfig);\n    await scriptTransformer.transformAsync(\n      '/fruits/banana:colon.js',\n      getCoverageOptions(),\n    );\n\n    expect(fs.readFileSync).toHaveBeenCalledTimes(2);\n    expect(fs.readFileSync).toHaveBeenCalledWith(\n      '/fruits/banana:colon.js',\n      'utf8',\n    );\n    expect(fs.readFileSync).toHaveBeenCalledWith(cachePath, 'utf8');\n    expect(writeFileAtomic.sync).not.toHaveBeenCalled();\n  });\n\n  it('with async preprocessor, reads values from the cache when the file contains colons', async () => {\n    const transformConfig: Config.ProjectConfig = {\n      ...config,\n      transform: [['\\\\.js$', 'test_async_preprocessor', {}]],\n    };\n    let scriptTransformer = await createScriptTransformer(transformConfig);\n    await scriptTransformer.transformAsync(\n      '/fruits/banana:colon.js',\n      getCoverageOptions(),\n    );\n\n    const cachePath = getCachePath(mockFs, config);\n    expect(writeFileAtomic.sync).toHaveBeenCalled();\n    expect(jest.mocked(writeFileAtomic.sync).mock.calls[0][0]).toBe(cachePath);\n\n    // Cache the state in `mockFsCopy`\n    const mockFsCopy = mockFs;\n    jest.resetModules();\n    reset();\n\n    // Restore the cached fs\n    mockFs = mockFsCopy;\n    scriptTransformer = await createScriptTransformer(transformConfig);\n    await scriptTransformer.transformAsync(\n      '/fruits/banana:colon.js',\n      getCoverageOptions(),\n    );\n\n    expect(fs.readFileSync).toHaveBeenCalledTimes(2);\n    expect(fs.readFileSync).toHaveBeenCalledWith(\n      '/fruits/banana:colon.js',\n      'utf8',\n    );\n    expect(fs.readFileSync).toHaveBeenCalledWith(cachePath, 'utf8');\n    expect(writeFileAtomic.sync).not.toHaveBeenCalled();\n  });\n\n  it('should reuse the value from in-memory cache which is set by custom transformer', async () => {\n    const cacheFS = new Map<string, string>();\n    const testPreprocessor =\n      require('cache_fs_preprocessor') as SyncTransformer;\n    const scriptTransformer = await createScriptTransformer(\n      {\n        ...config,\n        transform: [['\\\\.js$', 'cache_fs_preprocessor', {}]],\n      },\n      cacheFS,\n    );\n    const fileName1 = '/fruits/banana.js';\n    const fileName2 = '/fruits/kiwi.js';\n\n    scriptTransformer.transform(fileName1, getCoverageOptions());\n\n    cacheFS.set(fileName2, 'foo');\n\n    scriptTransformer.transform(fileName2, getCoverageOptions());\n\n    mockInvariant(testPreprocessor.getCacheKey != null);\n\n    expect(\n      jest.mocked(testPreprocessor.getCacheKey).mock.calls[0][2].cacheFS,\n    ).toBeDefined();\n    expect(\n      jest.mocked(testPreprocessor.process).mock.calls[0][2].cacheFS,\n    ).toBeDefined();\n    expect(fs.readFileSync).toHaveBeenCalledTimes(1);\n    expect(fs.readFileSync).toHaveBeenCalledWith(fileName1, 'utf8');\n  });\n\n  it('in async mode, should reuse the value from in-memory cache which is set by custom preprocessor', async () => {\n    const cacheFS = new Map<string, string>();\n    const testPreprocessor =\n      require('cache_fs_preprocessor') as SyncTransformer;\n    const scriptTransformer = await createScriptTransformer(\n      {\n        ...config,\n        transform: [['\\\\.js$', 'cache_fs_preprocessor', {}]],\n      },\n      cacheFS,\n    );\n    const fileName1 = '/fruits/banana.js';\n    const fileName2 = '/fruits/kiwi.js';\n\n    await scriptTransformer.transformAsync(fileName1, getCoverageOptions());\n\n    cacheFS.set(fileName2, 'foo');\n\n    await scriptTransformer.transformAsync(fileName2, getCoverageOptions());\n\n    mockInvariant(testPreprocessor.getCacheKey != null);\n\n    expect(\n      jest.mocked(testPreprocessor.getCacheKey).mock.calls[0][2].cacheFS,\n    ).toBeDefined();\n    expect(\n      jest.mocked(testPreprocessor.process).mock.calls[0][2].cacheFS,\n    ).toBeDefined();\n    expect(fs.readFileSync).toHaveBeenCalledTimes(1);\n    expect(fs.readFileSync).toHaveBeenCalledWith(fileName1, 'utf8');\n  });\n\n  it('should reuse the value from in-memory cache which is set by custom async preprocessor', async () => {\n    const cacheFS = new Map<string, string>();\n    const testPreprocessor =\n      require('cache_fs_async_preprocessor') as AsyncTransformer;\n    const scriptTransformer = await createScriptTransformer(\n      {\n        ...config,\n        transform: [['\\\\.js$', 'cache_fs_async_preprocessor', {}]],\n      },\n      cacheFS,\n    );\n    const fileName1 = '/fruits/banana.js';\n    const fileName2 = '/fruits/kiwi.js';\n\n    await scriptTransformer.transformAsync(fileName1, getCoverageOptions());\n\n    cacheFS.set(fileName2, 'foo');\n\n    await scriptTransformer.transformAsync(fileName2, getCoverageOptions());\n\n    mockInvariant(testPreprocessor.getCacheKeyAsync != null);\n\n    expect(\n      jest.mocked(testPreprocessor.getCacheKeyAsync).mock.calls[0][2].cacheFS,\n    ).toBeDefined();\n    expect(\n      jest.mocked(testPreprocessor.processAsync).mock.calls[0][2].cacheFS,\n    ).toBeDefined();\n    expect(fs.readFileSync).toHaveBeenCalledTimes(1);\n    expect(fs.readFileSync).toHaveBeenCalledWith(fileName1, 'utf8');\n  });\n\n  it('does not reuse the in-memory cache between different projects', async () => {\n    const scriptTransformer = await createScriptTransformer({\n      ...config,\n      transform: [['\\\\.js$', 'test_preprocessor', {}]],\n    });\n\n    scriptTransformer.transform('/fruits/banana.js', getCoverageOptions());\n\n    const anotherScriptTransformer = await createScriptTransformer({\n      ...config,\n      transform: [['\\\\.js$', 'css-preprocessor', {}]],\n    });\n\n    anotherScriptTransformer.transform(\n      '/fruits/banana.js',\n      getCoverageOptions(),\n    );\n\n    expect(fs.readFileSync).toHaveBeenCalledTimes(2);\n    expect(fs.readFileSync).toHaveBeenCalledWith('/fruits/banana.js', 'utf8');\n  });\n\n  it('async mode does not reuse the in-memory cache between different projects', async () => {\n    const scriptTransformer = await createScriptTransformer({\n      ...config,\n      transform: [['\\\\.js$', 'test_preprocessor', {}]],\n    });\n\n    await scriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions(),\n    );\n\n    const anotherScriptTransformer = await createScriptTransformer({\n      ...config,\n      transform: [['\\\\.js$', 'css-preprocessor', {}]],\n    });\n\n    await anotherScriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions(),\n    );\n\n    expect(fs.readFileSync).toHaveBeenCalledTimes(2);\n    expect(fs.readFileSync).toHaveBeenCalledWith('/fruits/banana.js', 'utf8');\n  });\n\n  it('regardless of sync/async, does not reuse the in-memory cache between different projects', async () => {\n    const scriptTransformer = await createScriptTransformer({\n      ...config,\n      transform: [['\\\\.js$', 'test_preprocessor', {}]],\n    });\n\n    scriptTransformer.transform('/fruits/banana.js', getCoverageOptions());\n\n    const anotherScriptTransformer = await createScriptTransformer({\n      ...config,\n      transform: [['\\\\.js$', 'css-preprocessor', {}]],\n    });\n\n    await anotherScriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions(),\n    );\n\n    const yetAnotherScriptTransformer = await createScriptTransformer({\n      ...config,\n      transform: [['\\\\.js$', 'test_preprocessor', {}]],\n    });\n    yetAnotherScriptTransformer.transform(\n      '/fruits/banana.js',\n      getCoverageOptions(),\n    );\n\n    const fruityScriptTransformer = await createScriptTransformer({\n      ...config,\n      transform: [['\\\\.js$', 'test_async_preprocessor', {}]],\n    });\n    await fruityScriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions(),\n    );\n\n    expect(fs.readFileSync).toHaveBeenCalledTimes(4);\n    expect(fs.readFileSync).toHaveBeenCalledWith('/fruits/banana.js', 'utf8');\n  });\n\n  it('preload transformer when using `createScriptTransformer`', async () => {\n    const scriptTransformer = await createScriptTransformer({\n      ...config,\n      transform: [['\\\\.js$', 'test_preprocessor', {}]],\n    });\n\n    // @ts-expect-error - private property\n    expect([...scriptTransformer._transformCache.entries()]).toEqual([\n      ['\\\\.js$test_preprocessor', expect.any(Object)],\n    ]);\n  });\n});\n\nfunction getTransformOptions(instrument: boolean): ReducedTransformOptions {\n  return {\n    instrument,\n    supportsDynamicImport: false,\n    supportsExportNamespaceFrom: false,\n    supportsStaticESM: false,\n    supportsTopLevelAwait: false,\n  };\n}\n\nfunction getCoverageOptions(\n  overrides: Partial<ShouldInstrumentOptions> = {},\n): Options {\n  const globalConfig = makeGlobalConfig(overrides);\n\n  return {\n    collectCoverage: globalConfig.collectCoverage,\n    collectCoverageFrom: globalConfig.collectCoverageFrom,\n    coverageProvider: globalConfig.coverageProvider,\n    supportsDynamicImport: false,\n    supportsExportNamespaceFrom: false,\n    supportsStaticESM: false,\n    supportsTopLevelAwait: false,\n  };\n}\n\nfunction mockInvariant(subject: boolean): asserts subject {\n  if (subject == null) {\n    throw new Error('Went boom');\n  }\n}\n",
  "packages/jest-transform/src/__tests__/ScriptTransformer.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport {};\n",
  "packages/jest-test-sequencer/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as crypto from 'crypto';\nimport * as path from 'path';\nimport * as fs from 'graceful-fs';\nimport slash from 'slash';\nimport type {AggregatedResult, Test, TestContext} from '@jest/test-result';\nimport type {Config} from '@jest/types';\nimport HasteMap from 'jest-haste-map';\n\nconst FAIL = 0;\nconst SUCCESS = 1;\n\nexport type TestSequencerOptions = {\n  contexts: ReadonlyArray<TestContext>;\n  globalConfig: Config.GlobalConfig;\n};\n\ntype Cache = {\n  [key: string]:\n    | [testStatus: typeof FAIL | typeof SUCCESS, testDuration: number]\n    | undefined;\n};\n\nexport type ShardOptions = {\n  shardIndex: number;\n  shardCount: number;\n};\n\ntype ShardPositionOptions = ShardOptions & {\n  suiteLength: number;\n};\n\n/**\n * The TestSequencer will ultimately decide which tests should run first.\n * It is responsible for storing and reading from a local cache\n * map that stores context information for a given test, such as how long it\n * took to run during the last run and if it has failed or not.\n * Such information is used on:\n * TestSequencer.sort(tests: Array<Test>)\n * to sort the order of the provided tests.\n *\n * After the results are collected,\n * TestSequencer.cacheResults(tests: Array<Test>, results: AggregatedResult)\n * is called to store/update this information on the cache map.\n */\nexport default class TestSequencer {\n  private readonly _cache = new Map<TestContext, Cache>();\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function,@typescript-eslint/no-useless-constructor\n  constructor(_options: TestSequencerOptions) {}\n\n  _getCachePath(testContext: TestContext): string {\n    const {config} = testContext;\n    const HasteMapClass = HasteMap.getStatic(config);\n    return HasteMapClass.getCacheFilePath(\n      config.cacheDirectory,\n      `perf-cache-${config.id}`,\n    );\n  }\n\n  _getCache(test: Test): Cache {\n    const {context} = test;\n    if (!this._cache.has(context) && context.config.cache) {\n      const cachePath = this._getCachePath(context);\n      if (fs.existsSync(cachePath)) {\n        try {\n          this._cache.set(\n            context,\n            JSON.parse(fs.readFileSync(cachePath, 'utf8')) as Cache,\n          );\n        } catch {}\n      }\n    }\n\n    let cache = this._cache.get(context);\n    if (!cache) {\n      cache = {};\n      this._cache.set(context, cache);\n    }\n\n    return cache;\n  }\n\n  private _shardPosition(options: ShardPositionOptions): number {\n    const shardRest = options.suiteLength % options.shardCount;\n    const ratio = options.suiteLength / options.shardCount;\n\n    return Array.from({length: options.shardIndex}).reduce<number>(\n      (acc, _, shardIndex) => {\n        const dangles = shardIndex < shardRest;\n        const shardSize = dangles ? Math.ceil(ratio) : Math.floor(ratio);\n        return acc + shardSize;\n      },\n      0,\n    );\n  }\n\n  /**\n   * Select tests for shard requested via --shard=shardIndex/shardCount\n   * Sharding is applied before sorting\n   *\n   * @param tests All tests\n   * @param options shardIndex and shardIndex to select\n   *\n   * @example\n   * ```typescript\n   * class CustomSequencer extends Sequencer {\n   *  shard(tests, { shardIndex, shardCount }) {\n   *    const shardSize = Math.ceil(tests.length / options.shardCount);\n   *    const shardStart = shardSize * (options.shardIndex - 1);\n   *    const shardEnd = shardSize * options.shardIndex;\n   *    return [...tests]\n   *     .sort((a, b) => (a.path > b.path ? 1 : -1))\n   *     .slice(shardStart, shardEnd);\n   *  }\n   * }\n   * ```\n   */\n  shard(\n    tests: Array<Test>,\n    options: ShardOptions,\n  ): Array<Test> | Promise<Array<Test>> {\n    const shardStart = this._shardPosition({\n      shardCount: options.shardCount,\n      shardIndex: options.shardIndex - 1,\n      suiteLength: tests.length,\n    });\n\n    const shardEnd = this._shardPosition({\n      shardCount: options.shardCount,\n      shardIndex: options.shardIndex,\n      suiteLength: tests.length,\n    });\n\n    return tests\n      .map(test => {\n        const relativeTestPath = path.posix.relative(\n          slash(test.context.config.rootDir),\n          slash(test.path),\n        );\n\n        return {\n          hash: crypto\n            .createHash('sha1')\n            .update(relativeTestPath)\n            .digest('hex'),\n          test,\n        };\n      })\n      .sort((a, b) => (a.hash < b.hash ? -1 : a.hash > b.hash ? 1 : 0))\n      .slice(shardStart, shardEnd)\n      .map(result => result.test);\n  }\n\n  /**\n   * Sort test to determine order of execution\n   * Sorting is applied after sharding\n   * @param tests\n   *\n   * ```typescript\n   * class CustomSequencer extends Sequencer {\n   *   sort(tests) {\n   *     const copyTests = Array.from(tests);\n   *     return [...tests].sort((a, b) => (a.path > b.path ? 1 : -1));\n   *   }\n   * }\n   * ```\n   */\n  sort(tests: Array<Test>): Array<Test> | Promise<Array<Test>> {\n    /**\n     * Sorting tests is very important because it has a great impact on the\n     * user-perceived responsiveness and speed of the test run.\n     *\n     * If such information is on cache, tests are sorted based on:\n     * -> Has it failed during the last run ?\n     * Since it's important to provide the most expected feedback as quickly\n     * as possible.\n     * -> How long it took to run ?\n     * Because running long tests first is an effort to minimize worker idle\n     * time at the end of a long test run.\n     * And if that information is not available they are sorted based on file size\n     * since big test files usually take longer to complete.\n     *\n     * Note that a possible improvement would be to analyse other information\n     * from the file other than its size.\n     *\n     */\n    const stats: {[path: string]: number} = {};\n    const fileSize = ({path, context: {hasteFS}}: Test) =>\n      stats[path] || (stats[path] = hasteFS.getSize(path) ?? 0);\n\n    for (const test of tests) {\n      test.duration = this.time(test);\n    }\n    return tests.sort((testA, testB) => {\n      const failedA = this.hasFailed(testA);\n      const failedB = this.hasFailed(testB);\n      const hasTimeA = testA.duration != null;\n      const hasTimeB = testB.duration != null;\n      if (failedA !== failedB) {\n        return failedA ? -1 : 1;\n      } else if (hasTimeA !== hasTimeB) {\n        // If only one of two tests has timing information, run it last\n        return hasTimeA ? 1 : -1;\n      } else if (testA.duration != null && testB.duration != null) {\n        return testA.duration < testB.duration ? 1 : -1;\n      } else {\n        return fileSize(testA) < fileSize(testB) ? 1 : -1;\n      }\n    });\n  }\n\n  allFailedTests(tests: Array<Test>): Array<Test> | Promise<Array<Test>> {\n    return this.sort(tests.filter(test => this.hasFailed(test)));\n  }\n\n  cacheResults(tests: Array<Test>, results: AggregatedResult): void {\n    const map = Object.create(null) as Record<string, Test | undefined>;\n    for (const test of tests) map[test.path] = test;\n    for (const testResult of results.testResults) {\n      const test = map[testResult.testFilePath];\n      if (test != null && !testResult.skipped) {\n        const cache = this._getCache(test);\n        const perf = testResult.perfStats;\n        const testRuntime =\n          perf.runtime ?? test.duration ?? perf.end - perf.start;\n        cache[testResult.testFilePath] = [\n          testResult.numFailingTests > 0 ? FAIL : SUCCESS,\n          testRuntime || 0,\n        ];\n      }\n    }\n\n    for (const [context, cache] of this._cache.entries())\n      fs.writeFileSync(this._getCachePath(context), JSON.stringify(cache));\n  }\n\n  private hasFailed(test: Test) {\n    const cache = this._getCache(test);\n    return cache[test.path]?.[0] === FAIL;\n  }\n\n  private time(test: Test) {\n    const cache = this._getCache(test);\n    return cache[test.path]?.[1];\n  }\n}\n",
  "packages/jest-test-sequencer/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { AggregatedResult, Test, TestContext } from '@jest/test-result';\nimport type { Config } from '@jest/types';\ndeclare const FAIL = 0;\ndeclare const SUCCESS = 1;\nexport type TestSequencerOptions = {\n    contexts: ReadonlyArray<TestContext>;\n    globalConfig: Config.GlobalConfig;\n};\ntype Cache = {\n    [key: string]: [testStatus: typeof FAIL | typeof SUCCESS, testDuration: number] | undefined;\n};\nexport type ShardOptions = {\n    shardIndex: number;\n    shardCount: number;\n};\n/**\n * The TestSequencer will ultimately decide which tests should run first.\n * It is responsible for storing and reading from a local cache\n * map that stores context information for a given test, such as how long it\n * took to run during the last run and if it has failed or not.\n * Such information is used on:\n * TestSequencer.sort(tests: Array<Test>)\n * to sort the order of the provided tests.\n *\n * After the results are collected,\n * TestSequencer.cacheResults(tests: Array<Test>, results: AggregatedResult)\n * is called to store/update this information on the cache map.\n */\nexport default class TestSequencer {\n    private readonly _cache;\n    constructor(_options: TestSequencerOptions);\n    _getCachePath(testContext: TestContext): string;\n    _getCache(test: Test): Cache;\n    private _shardPosition;\n    /**\n     * Select tests for shard requested via --shard=shardIndex/shardCount\n     * Sharding is applied before sorting\n     *\n     * @param tests All tests\n     * @param options shardIndex and shardIndex to select\n     *\n     * @example\n     * ```typescript\n     * class CustomSequencer extends Sequencer {\n     *  shard(tests, { shardIndex, shardCount }) {\n     *    const shardSize = Math.ceil(tests.length / options.shardCount);\n     *    const shardStart = shardSize * (options.shardIndex - 1);\n     *    const shardEnd = shardSize * options.shardIndex;\n     *    return [...tests]\n     *     .sort((a, b) => (a.path > b.path ? 1 : -1))\n     *     .slice(shardStart, shardEnd);\n     *  }\n     * }\n     * ```\n     */\n    shard(tests: Array<Test>, options: ShardOptions): Array<Test> | Promise<Array<Test>>;\n    /**\n     * Sort test to determine order of execution\n     * Sorting is applied after sharding\n     * @param tests\n     *\n     * ```typescript\n     * class CustomSequencer extends Sequencer {\n     *   sort(tests) {\n     *     const copyTests = Array.from(tests);\n     *     return [...tests].sort((a, b) => (a.path > b.path ? 1 : -1));\n     *   }\n     * }\n     * ```\n     */\n    sort(tests: Array<Test>): Array<Test> | Promise<Array<Test>>;\n    allFailedTests(tests: Array<Test>): Array<Test> | Promise<Array<Test>>;\n    cacheResults(tests: Array<Test>, results: AggregatedResult): void;\n    private hasFailed;\n    private time;\n}\nexport {};\n",
  "packages/jest-test-sequencer/src/__tests__/test_sequencer.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport * as mockedFs from 'graceful-fs';\nimport type {AggregatedResult, Test, TestContext} from '@jest/test-result';\nimport {makeGlobalConfig, makeProjectConfig} from '@jest/test-utils';\nimport TestSequencer from '../index';\n\njest.mock('graceful-fs', () => ({\n  ...jest.createMockFromModule<typeof import('fs')>('fs'),\n  existsSync: jest.fn(() => true),\n  readFileSync: jest.fn(() => '{}'),\n}));\nconst FAIL = 0;\nconst SUCCESS = 1;\n\nlet sequencer: TestSequencer;\n\nconst fs = jest.mocked(mockedFs);\n\nconst context: TestContext = {\n  config: makeProjectConfig({\n    cache: true,\n    cacheDirectory: '/cache',\n    haste: {},\n    id: 'test',\n  }),\n  hasteFS: {\n    getSize: path => path.length,\n  },\n};\n\nconst secondContext: TestContext = {\n  config: makeProjectConfig({\n    cache: true,\n    cacheDirectory: '/cache2',\n    haste: {},\n    id: 'test2',\n  }),\n  hasteFS: {\n    getSize: path => path.length,\n  },\n};\n\nconst toTests = (paths: Array<string>) =>\n  paths.map<Test>(path => ({\n    context,\n    duration: undefined,\n    path,\n  }));\n\nbeforeEach(() => {\n  jest.clearAllMocks();\n  sequencer = new TestSequencer({\n    contexts: [],\n    globalConfig: makeGlobalConfig(),\n  });\n});\n\ntest('sorts by file size if there is no timing information', () => {\n  expect(sequencer.sort(toTests(['/test-a.js', '/test-ab.js']))).toEqual([\n    {context, duration: undefined, path: '/test-ab.js'},\n    {context, duration: undefined, path: '/test-a.js'},\n  ]);\n});\n\ntest('sorts based on timing information', () => {\n  fs.readFileSync.mockImplementationOnce(() =>\n    JSON.stringify({\n      '/test-a.js': [SUCCESS, 5],\n      '/test-ab.js': [SUCCESS, 3],\n    }),\n  );\n  expect(sequencer.sort(toTests(['/test-a.js', '/test-ab.js']))).toEqual([\n    {context, duration: 5, path: '/test-a.js'},\n    {context, duration: 3, path: '/test-ab.js'},\n  ]);\n});\n\ntest('sorts based on failures and timing information', () => {\n  fs.readFileSync.mockImplementationOnce(() =>\n    JSON.stringify({\n      '/test-a.js': [SUCCESS, 5],\n      '/test-ab.js': [FAIL, 0],\n      '/test-c.js': [FAIL, 6],\n      '/test-d.js': [SUCCESS, 2],\n    }),\n  );\n  expect(\n    sequencer.sort(\n      toTests(['/test-a.js', '/test-ab.js', '/test-c.js', '/test-d.js']),\n    ),\n  ).toEqual([\n    {context, duration: 6, path: '/test-c.js'},\n    {context, duration: 0, path: '/test-ab.js'},\n    {context, duration: 5, path: '/test-a.js'},\n    {context, duration: 2, path: '/test-d.js'},\n  ]);\n});\n\ntest('sorts based on failures, timing information and file size', () => {\n  fs.readFileSync.mockImplementationOnce(() =>\n    JSON.stringify({\n      '/test-a.js': [SUCCESS, 5],\n      '/test-ab.js': [FAIL, 1],\n      '/test-c.js': [FAIL],\n      '/test-d.js': [SUCCESS, 2],\n      '/test-efg.js': [FAIL],\n    }),\n  );\n  expect(\n    sequencer.sort(\n      toTests([\n        '/test-a.js',\n        '/test-ab.js',\n        '/test-c.js',\n        '/test-d.js',\n        '/test-efg.js',\n      ]),\n    ),\n  ).toEqual([\n    {context, duration: undefined, path: '/test-efg.js'},\n    {context, duration: undefined, path: '/test-c.js'},\n    {context, duration: 1, path: '/test-ab.js'},\n    {context, duration: 5, path: '/test-a.js'},\n    {context, duration: 2, path: '/test-d.js'},\n  ]);\n});\n\ntest('writes the cache based on results without existing cache', async () => {\n  fs.readFileSync.mockImplementationOnce(() => {\n    throw new Error('File does not exist.');\n  });\n\n  const testPaths = ['/test-a.js', '/test-b.js', '/test-c.js'];\n  const tests = await sequencer.sort(toTests(testPaths));\n  sequencer.cacheResults(tests, {\n    testResults: [\n      {\n        numFailingTests: 0,\n        perfStats: {end: 2, runtime: 1, start: 1},\n        testFilePath: '/test-a.js',\n      },\n      {\n        numFailingTests: 0,\n        perfStats: {end: 0, runtime: 0, start: 0},\n        skipped: true,\n        testFilePath: '/test-b.js',\n      },\n      {\n        numFailingTests: 1,\n        // this is missing `runtime` to test that it is calculated\n        perfStats: {end: 4, start: 1},\n        testFilePath: '/test-c.js',\n      },\n      {\n        numFailingTests: 1,\n        perfStats: {end: 2, runtime: 1, start: 1},\n        testFilePath: '/test-x.js',\n      },\n    ],\n  });\n  const fileData = JSON.parse(\n    fs.writeFileSync.mock.calls[0][1],\n  ) as AggregatedResult;\n  expect(fileData).toEqual({\n    '/test-a.js': [SUCCESS, 1],\n    '/test-c.js': [FAIL, 3],\n  });\n});\n\ntest('returns failed tests in sorted order', () => {\n  fs.readFileSync.mockImplementationOnce(() =>\n    JSON.stringify({\n      '/test-a.js': [SUCCESS, 5],\n      '/test-ab.js': [FAIL, 1],\n      '/test-c.js': [FAIL],\n    }),\n  );\n  const testPaths = ['/test-a.js', '/test-ab.js', '/test-c.js'];\n  expect(sequencer.allFailedTests(toTests(testPaths))).toEqual([\n    {context, duration: undefined, path: '/test-c.js'},\n    {context, duration: 1, path: '/test-ab.js'},\n  ]);\n});\n\ntest('writes the cache based on the results', async () => {\n  fs.readFileSync.mockImplementationOnce(() =>\n    JSON.stringify({\n      '/test-a.js': [SUCCESS, 5],\n      '/test-b.js': [FAIL, 1],\n      '/test-c.js': [FAIL],\n    }),\n  );\n\n  const testPaths = ['/test-a.js', '/test-b.js', '/test-c.js'];\n  const tests = await sequencer.sort(toTests(testPaths));\n  sequencer.cacheResults(tests, {\n    testResults: [\n      {\n        numFailingTests: 0,\n        perfStats: {end: 2, runtime: 1, start: 1},\n        testFilePath: '/test-a.js',\n      },\n      {\n        numFailingTests: 0,\n        perfStats: {end: 0, runtime: 0, start: 0},\n        skipped: true,\n        testFilePath: '/test-b.js',\n      },\n      {\n        numFailingTests: 1,\n        perfStats: {end: 4, runtime: 3, start: 1},\n        testFilePath: '/test-c.js',\n      },\n      {\n        numFailingTests: 1,\n        perfStats: {end: 2, runtime: 1, start: 1},\n        testFilePath: '/test-x.js',\n      },\n    ],\n  });\n  const fileData = JSON.parse(\n    fs.writeFileSync.mock.calls[0][1],\n  ) as AggregatedResult;\n  expect(fileData).toEqual({\n    '/test-a.js': [SUCCESS, 1],\n    '/test-b.js': [FAIL, 1],\n    '/test-c.js': [FAIL, 3],\n  });\n});\n\ntest('works with multiple contexts', async () => {\n  fs.readFileSync.mockImplementationOnce(cacheName => {\n    if (typeof cacheName !== 'string') {\n      throw new TypeError('Must be called with a string');\n    }\n\n    return cacheName.startsWith(`${path.sep}cache${path.sep}`)\n      ? JSON.stringify({\n          '/test-a.js': [SUCCESS, 5],\n          '/test-b.js': [FAIL, 1],\n        })\n      : JSON.stringify({\n          '/test-c.js': [FAIL],\n        });\n  });\n\n  const testPaths = [\n    {context, duration: null, path: '/test-a.js'},\n    {context, duration: null, path: '/test-b.js'},\n    {context: secondContext, duration: null, path: '/test-c.js'},\n  ];\n  const tests = await sequencer.sort(testPaths);\n  sequencer.cacheResults(tests, {\n    testResults: [\n      {\n        numFailingTests: 0,\n        perfStats: {end: 2, runtime: 1, start: 1},\n        testFilePath: '/test-a.js',\n      },\n      {\n        numFailingTests: 0,\n        perfStats: {end: 0, runtime: 1, start: 0},\n        skipped: true,\n        testFilePath: '/test-b.js',\n      },\n      {\n        numFailingTests: 0,\n        perfStats: {end: 4, runtime: 3, start: 1},\n        testFilePath: '/test-c.js',\n      },\n      {\n        numFailingTests: 1,\n        perfStats: {end: 2, runtime: 1, start: 1},\n        testFilePath: '/test-x.js',\n      },\n    ],\n  });\n  const fileDataA = JSON.parse(\n    fs.writeFileSync.mock.calls[0][1],\n  ) as AggregatedResult;\n  expect(fileDataA).toEqual({\n    '/test-a.js': [SUCCESS, 1],\n    '/test-b.js': [FAIL, 1],\n  });\n  const fileDataB = JSON.parse(\n    fs.writeFileSync.mock.calls[1][1],\n  ) as AggregatedResult;\n  expect(fileDataB).toEqual({\n    '/test-c.js': [SUCCESS, 3],\n  });\n});\n\ntest('does not shard by default', async () => {\n  const tests = await sequencer.shard(toTests(['/test-a.js', '/test-ab.js']), {\n    shardCount: 1,\n    shardIndex: 1,\n  });\n\n  expect(tests.map(test => test.path)).toEqual(['/test-ab.js', '/test-a.js']);\n});\n\ntest('return first shard', async () => {\n  const tests = await sequencer.shard(\n    toTests(['/test-a.js', '/test-abc.js', '/test-ab.js']),\n    {\n      shardCount: 3,\n      shardIndex: 1,\n    },\n  );\n\n  expect(tests.map(test => test.path)).toEqual(['/test-ab.js']);\n});\n\ntest('return second shard', async () => {\n  const tests = await sequencer.shard(\n    toTests(['/test-a.js', '/test-abc.js', '/test-ab.js']),\n    {\n      shardCount: 3,\n      shardIndex: 2,\n    },\n  );\n\n  expect(tests.map(test => test.path)).toEqual(['/test-abc.js']);\n});\n\ntest('return third shard', async () => {\n  const tests = await sequencer.shard(\n    toTests(['/test-abc.js', '/test-a.js', '/test-ab.js']),\n    {\n      shardCount: 3,\n      shardIndex: 3,\n    },\n  );\n\n  expect(tests.map(test => test.path)).toEqual(['/test-a.js']);\n});\n\ntest('returns expected 100/10 shards', async () => {\n  const allTests = toTests(Array.from({length: 100}).map((_, i) => `/${i}.js`));\n\n  const shards = await Promise.all(\n    Array.from({length: 10}).map((_, i) =>\n      sequencer.shard(allTests, {\n        shardCount: 10,\n        shardIndex: i + 1,\n      }),\n    ),\n  );\n\n  expect(shards.map(shard => shard.length)).toEqual([\n    10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n  ]);\n});\n\ntest('returns expected 100/8 shards', async () => {\n  const allTests = toTests(Array.from({length: 100}).map((_, i) => `/${i}.js`));\n\n  const shards = await Promise.all(\n    Array.from({length: 8}).map((_, i) =>\n      sequencer.shard(allTests, {\n        shardCount: 8,\n        shardIndex: i + 1,\n      }),\n    ),\n  );\n\n  expect(shards.map(shard => shard.length)).toEqual([\n    13, 13, 13, 13, 12, 12, 12, 12,\n  ]);\n});\n\ntest('returns expected 55/12 shards', async () => {\n  const allTests = toTests(Array.from({length: 55}).map((_, i) => `/${i}.js`));\n\n  const shards = await Promise.all(\n    Array.from({length: 12}).map((_, i) =>\n      sequencer.shard(allTests, {\n        shardCount: 12,\n        shardIndex: i + 1,\n      }),\n    ),\n  );\n\n  expect(shards.map(shard => shard.length)).toEqual([\n    5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4,\n  ]);\n});\n",
  "packages/jest-test-sequencer/src/__tests__/test_sequencer.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-test-result/src/types.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {V8Coverage} from 'collect-v8-coverage';\nimport type {CoverageMap, CoverageMapData} from 'istanbul-lib-coverage';\nimport type {ConsoleBuffer} from '@jest/console';\nimport type {Circus, Config, TestResult, TransformTypes} from '@jest/types';\nimport type {IHasteFS, IModuleMap} from 'jest-haste-map';\nimport type Resolver from 'jest-resolve';\n\nexport type RuntimeTransformResult = TransformTypes.TransformResult;\n\nexport type V8CoverageResult = Array<{\n  codeTransformResult: RuntimeTransformResult | undefined;\n  result: V8Coverage[number];\n}>;\n\nexport type SerializableError = TestResult.SerializableError;\n\nexport type FailedAssertion = {\n  matcherName?: string;\n  message?: string;\n  actual?: unknown;\n  pass?: boolean;\n  passed?: boolean;\n  expected?: unknown;\n  isNot?: boolean;\n  stack?: string;\n  error?: unknown;\n};\n\nexport type AssertionLocation = {\n  fullName: string;\n  path: string;\n};\n\nexport type Status = AssertionResult['status'];\n\nexport type AssertionResult = TestResult.AssertionResult;\n\nexport type FormattedAssertionResult = Pick<\n  AssertionResult,\n  'ancestorTitles' | 'fullName' | 'location' | 'status' | 'title' | 'duration'\n> & {\n  failureMessages: AssertionResult['failureMessages'] | null;\n};\n\nexport type AggregatedResultWithoutCoverage = {\n  numFailedTests: number;\n  numFailedTestSuites: number;\n  numPassedTests: number;\n  numPassedTestSuites: number;\n  numPendingTests: number;\n  numTodoTests: number;\n  numPendingTestSuites: number;\n  numRuntimeErrorTestSuites: number;\n  numTotalTests: number;\n  numTotalTestSuites: number;\n  openHandles: Array<Error>;\n  snapshot: SnapshotSummary;\n  startTime: number;\n  success: boolean;\n  testResults: Array<TestResult>;\n  wasInterrupted: boolean;\n  runExecError?: SerializableError;\n};\n\nexport type AggregatedResult = AggregatedResultWithoutCoverage & {\n  coverageMap?: CoverageMap | null;\n};\n\nexport type TestResultsProcessor = (\n  results: AggregatedResult,\n) => AggregatedResult | Promise<AggregatedResult>;\n\nexport type Suite = {\n  title: string;\n  suites: Array<Suite>;\n  tests: Array<AssertionResult>;\n};\n\nexport type TestCaseResult = AssertionResult & {startedAt?: number | null};\n\nexport type TestResult = {\n  console?: ConsoleBuffer;\n  coverage?: CoverageMapData;\n  displayName?: Config.DisplayName;\n  /**\n   * Whether [`test.failing()`](https://jestjs.io/docs/api#testfailingname-fn-timeout)\n   * was used.\n   */\n  failing?: boolean;\n  failureMessage?: string | null;\n  leaks: boolean;\n  memoryUsage?: number;\n  numFailingTests: number;\n  numPassingTests: number;\n  numPendingTests: number;\n  numTodoTests: number;\n  openHandles: Array<Error>;\n  perfStats: {\n    end: number;\n    loadTestEnvironmentEnd: number;\n    loadTestEnvironmentStart: number;\n    runtime: number;\n    setupAfterEnvEnd: number;\n    setupAfterEnvStart: number;\n    setupFilesEnd: number;\n    setupFilesStart: number;\n    slow: boolean;\n    start: number;\n  };\n  skipped: boolean;\n  snapshot: {\n    added: number;\n    fileDeleted: boolean;\n    matched: number;\n    unchecked: number;\n    uncheckedKeys: Array<string>;\n    unmatched: number;\n    updated: number;\n  };\n  testExecError?: SerializableError;\n  testFilePath: string;\n  testResults: Array<AssertionResult>;\n  v8Coverage?: V8CoverageResult;\n};\n\nexport type FormattedTestResult = {\n  message: string;\n  name: string;\n  summary: string;\n  status: 'failed' | 'passed' | 'skipped' | 'focused';\n  startTime: number;\n  endTime: number;\n  coverage: unknown;\n  assertionResults: Array<FormattedAssertionResult>;\n};\n\nexport type FormattedTestResults = {\n  coverageMap?: CoverageMap | null | undefined;\n  numFailedTests: number;\n  numFailedTestSuites: number;\n  numPassedTests: number;\n  numPassedTestSuites: number;\n  numPendingTests: number;\n  numPendingTestSuites: number;\n  numRuntimeErrorTestSuites: number;\n  numTotalTests: number;\n  numTotalTestSuites: number;\n  snapshot: SnapshotSummary;\n  startTime: number;\n  success: boolean;\n  testResults: Array<FormattedTestResult>;\n  wasInterrupted: boolean;\n};\n\nexport type CodeCoverageReporter = unknown;\n\nexport type CodeCoverageFormatter = (\n  coverage: CoverageMapData | null | undefined,\n  reporter: CodeCoverageReporter,\n) => Record<string, unknown> | null | undefined;\n\nexport type UncheckedSnapshot = {\n  filePath: string;\n  keys: Array<string>;\n};\n\nexport type SnapshotSummary = {\n  added: number;\n  didUpdate: boolean;\n  failure: boolean;\n  filesAdded: number;\n  filesRemoved: number;\n  filesRemovedList: Array<string>;\n  filesUnmatched: number;\n  filesUpdated: number;\n  matched: number;\n  total: number;\n  unchecked: number;\n  uncheckedKeysByFile: Array<UncheckedSnapshot>;\n  unmatched: number;\n  updated: number;\n};\n\nexport type Test = {\n  context: TestContext;\n  duration?: number;\n  path: string;\n};\n\nexport type TestContext = {\n  config: Config.ProjectConfig;\n  hasteFS: IHasteFS;\n  moduleMap: IModuleMap;\n  resolver: Resolver;\n};\n\n// Typings for `sendMessageToJest` events\nexport type TestEvents = {\n  'test-file-start': [Test];\n  'test-file-success': [Test, TestResult];\n  'test-file-failure': [Test, SerializableError];\n  'test-case-start': [string, Circus.TestCaseStartInfo];\n  'test-case-result': [string, TestCaseResult];\n};\n\nexport type TestFileEvent<T extends keyof TestEvents = keyof TestEvents> = (\n  eventName: T,\n  args: TestEvents[T],\n) => unknown;\n",
  "packages/jest-test-result/src/types.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { V8Coverage } from 'collect-v8-coverage';\nimport type { CoverageMap, CoverageMapData } from 'istanbul-lib-coverage';\nimport type { ConsoleBuffer } from '@jest/console';\nimport type { Circus, Config, TestResult, TransformTypes } from '@jest/types';\nimport type { IHasteFS, IModuleMap } from 'jest-haste-map';\nimport type Resolver from 'jest-resolve';\nexport type RuntimeTransformResult = TransformTypes.TransformResult;\nexport type V8CoverageResult = Array<{\n    codeTransformResult: RuntimeTransformResult | undefined;\n    result: V8Coverage[number];\n}>;\nexport type SerializableError = TestResult.SerializableError;\nexport type FailedAssertion = {\n    matcherName?: string;\n    message?: string;\n    actual?: unknown;\n    pass?: boolean;\n    passed?: boolean;\n    expected?: unknown;\n    isNot?: boolean;\n    stack?: string;\n    error?: unknown;\n};\nexport type AssertionLocation = {\n    fullName: string;\n    path: string;\n};\nexport type Status = AssertionResult['status'];\nexport type AssertionResult = TestResult.AssertionResult;\nexport type FormattedAssertionResult = Pick<AssertionResult, 'ancestorTitles' | 'fullName' | 'location' | 'status' | 'title' | 'duration'> & {\n    failureMessages: AssertionResult['failureMessages'] | null;\n};\nexport type AggregatedResultWithoutCoverage = {\n    numFailedTests: number;\n    numFailedTestSuites: number;\n    numPassedTests: number;\n    numPassedTestSuites: number;\n    numPendingTests: number;\n    numTodoTests: number;\n    numPendingTestSuites: number;\n    numRuntimeErrorTestSuites: number;\n    numTotalTests: number;\n    numTotalTestSuites: number;\n    openHandles: Array<Error>;\n    snapshot: SnapshotSummary;\n    startTime: number;\n    success: boolean;\n    testResults: Array<TestResult>;\n    wasInterrupted: boolean;\n    runExecError?: SerializableError;\n};\nexport type AggregatedResult = AggregatedResultWithoutCoverage & {\n    coverageMap?: CoverageMap | null;\n};\nexport type TestResultsProcessor = (results: AggregatedResult) => AggregatedResult | Promise<AggregatedResult>;\nexport type Suite = {\n    title: string;\n    suites: Array<Suite>;\n    tests: Array<AssertionResult>;\n};\nexport type TestCaseResult = AssertionResult & {\n    startedAt?: number | null;\n};\nexport type TestResult = {\n    console?: ConsoleBuffer;\n    coverage?: CoverageMapData;\n    displayName?: Config.DisplayName;\n    /**\n     * Whether [`test.failing()`](https://jestjs.io/docs/api#testfailingname-fn-timeout)\n     * was used.\n     */\n    failing?: boolean;\n    failureMessage?: string | null;\n    leaks: boolean;\n    memoryUsage?: number;\n    numFailingTests: number;\n    numPassingTests: number;\n    numPendingTests: number;\n    numTodoTests: number;\n    openHandles: Array<Error>;\n    perfStats: {\n        end: number;\n        loadTestEnvironmentEnd: number;\n        loadTestEnvironmentStart: number;\n        runtime: number;\n        setupAfterEnvEnd: number;\n        setupAfterEnvStart: number;\n        setupFilesEnd: number;\n        setupFilesStart: number;\n        slow: boolean;\n        start: number;\n    };\n    skipped: boolean;\n    snapshot: {\n        added: number;\n        fileDeleted: boolean;\n        matched: number;\n        unchecked: number;\n        uncheckedKeys: Array<string>;\n        unmatched: number;\n        updated: number;\n    };\n    testExecError?: SerializableError;\n    testFilePath: string;\n    testResults: Array<AssertionResult>;\n    v8Coverage?: V8CoverageResult;\n};\nexport type FormattedTestResult = {\n    message: string;\n    name: string;\n    summary: string;\n    status: 'failed' | 'passed' | 'skipped' | 'focused';\n    startTime: number;\n    endTime: number;\n    coverage: unknown;\n    assertionResults: Array<FormattedAssertionResult>;\n};\nexport type FormattedTestResults = {\n    coverageMap?: CoverageMap | null | undefined;\n    numFailedTests: number;\n    numFailedTestSuites: number;\n    numPassedTests: number;\n    numPassedTestSuites: number;\n    numPendingTests: number;\n    numPendingTestSuites: number;\n    numRuntimeErrorTestSuites: number;\n    numTotalTests: number;\n    numTotalTestSuites: number;\n    snapshot: SnapshotSummary;\n    startTime: number;\n    success: boolean;\n    testResults: Array<FormattedTestResult>;\n    wasInterrupted: boolean;\n};\nexport type CodeCoverageReporter = unknown;\nexport type CodeCoverageFormatter = (coverage: CoverageMapData | null | undefined, reporter: CodeCoverageReporter) => Record<string, unknown> | null | undefined;\nexport type UncheckedSnapshot = {\n    filePath: string;\n    keys: Array<string>;\n};\nexport type SnapshotSummary = {\n    added: number;\n    didUpdate: boolean;\n    failure: boolean;\n    filesAdded: number;\n    filesRemoved: number;\n    filesRemovedList: Array<string>;\n    filesUnmatched: number;\n    filesUpdated: number;\n    matched: number;\n    total: number;\n    unchecked: number;\n    uncheckedKeysByFile: Array<UncheckedSnapshot>;\n    unmatched: number;\n    updated: number;\n};\nexport type Test = {\n    context: TestContext;\n    duration?: number;\n    path: string;\n};\nexport type TestContext = {\n    config: Config.ProjectConfig;\n    hasteFS: IHasteFS;\n    moduleMap: IModuleMap;\n    resolver: Resolver;\n};\nexport type TestEvents = {\n    'test-file-start': [Test];\n    'test-file-success': [Test, TestResult];\n    'test-file-failure': [Test, SerializableError];\n    'test-case-start': [string, Circus.TestCaseStartInfo];\n    'test-case-result': [string, TestCaseResult];\n};\nexport type TestFileEvent<T extends keyof TestEvents = keyof TestEvents> = (eventName: T, args: TestEvents[T]) => unknown;\n",
  "packages/jest-test-result/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nexport {default as formatTestResults} from './formatTestResults';\nexport {\n  addResult,\n  buildFailureTestResult,\n  createEmptyTestResult,\n  makeEmptyAggregatedTestResult,\n} from './helpers';\nexport type {\n  AggregatedResult,\n  AssertionLocation,\n  AssertionResult,\n  FailedAssertion,\n  FormattedTestResults,\n  RuntimeTransformResult,\n  SerializableError,\n  SnapshotSummary,\n  Status,\n  Suite,\n  Test,\n  TestContext,\n  TestEvents,\n  TestFileEvent,\n  TestResult,\n  TestResultsProcessor,\n  TestCaseResult,\n  V8CoverageResult,\n} from './types';\n",
  "packages/jest-test-result/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport { default as formatTestResults } from './formatTestResults';\nexport { addResult, buildFailureTestResult, createEmptyTestResult, makeEmptyAggregatedTestResult, } from './helpers';\nexport type { AggregatedResult, AssertionLocation, AssertionResult, FailedAssertion, FormattedTestResults, RuntimeTransformResult, SerializableError, SnapshotSummary, Status, Suite, Test, TestContext, TestEvents, TestFileEvent, TestResult, TestResultsProcessor, TestCaseResult, V8CoverageResult, } from './types';\n",
  "packages/jest-test-result/src/helpers.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {AggregatedResult, SerializableError, TestResult} from './types';\n\nexport const makeEmptyAggregatedTestResult = (): AggregatedResult => ({\n  numFailedTestSuites: 0,\n  numFailedTests: 0,\n  numPassedTestSuites: 0,\n  numPassedTests: 0,\n  numPendingTestSuites: 0,\n  numPendingTests: 0,\n  numRuntimeErrorTestSuites: 0,\n  numTodoTests: 0,\n  numTotalTestSuites: 0,\n  numTotalTests: 0,\n  openHandles: [],\n  snapshot: {\n    added: 0,\n    didUpdate: false, // is set only after the full run\n    failure: false,\n    filesAdded: 0,\n    // combines individual test results + removed files after the full run\n    filesRemoved: 0,\n    filesRemovedList: [],\n    filesUnmatched: 0,\n    filesUpdated: 0,\n    matched: 0,\n    total: 0,\n    unchecked: 0,\n    uncheckedKeysByFile: [],\n    unmatched: 0,\n    updated: 0,\n  },\n  startTime: 0,\n  success: true,\n  testResults: [],\n  wasInterrupted: false,\n});\n\nexport const buildFailureTestResult = (\n  testPath: string,\n  err: SerializableError,\n): TestResult => ({\n  console: undefined,\n  displayName: undefined,\n  failureMessage: null,\n  leaks: false,\n  numFailingTests: 0,\n  numPassingTests: 0,\n  numPendingTests: 0,\n  numTodoTests: 0,\n  openHandles: [],\n  perfStats: {\n    end: 0,\n    loadTestEnvironmentEnd: 0,\n    loadTestEnvironmentStart: 0,\n    runtime: 0,\n    setupAfterEnvEnd: 0,\n    setupAfterEnvStart: 0,\n    setupFilesEnd: 0,\n    setupFilesStart: 0,\n    slow: false,\n    start: 0,\n  },\n  skipped: false,\n  snapshot: {\n    added: 0,\n    fileDeleted: false,\n    matched: 0,\n    unchecked: 0,\n    uncheckedKeys: [],\n    unmatched: 0,\n    updated: 0,\n  },\n  testExecError: err,\n  testFilePath: testPath,\n  testResults: [],\n});\n\n// Add individual test result to an aggregated test result\nexport const addResult = (\n  aggregatedResults: AggregatedResult,\n  testResult: TestResult,\n): void => {\n  // `todos` are new as of Jest 24, and not all runners return it.\n  // Set it to `0` to avoid `NaN`\n  if (!testResult.numTodoTests) {\n    testResult.numTodoTests = 0;\n  }\n\n  aggregatedResults.testResults.push(testResult);\n  aggregatedResults.numTotalTests +=\n    testResult.numPassingTests +\n    testResult.numFailingTests +\n    testResult.numPendingTests +\n    testResult.numTodoTests;\n  aggregatedResults.numFailedTests += testResult.numFailingTests;\n  aggregatedResults.numPassedTests += testResult.numPassingTests;\n  aggregatedResults.numPendingTests += testResult.numPendingTests;\n  aggregatedResults.numTodoTests += testResult.numTodoTests;\n\n  if (testResult.testExecError) {\n    aggregatedResults.numRuntimeErrorTestSuites++;\n  }\n\n  if (testResult.skipped) {\n    aggregatedResults.numPendingTestSuites++;\n  } else if (testResult.numFailingTests > 0 || testResult.testExecError) {\n    aggregatedResults.numFailedTestSuites++;\n  } else {\n    aggregatedResults.numPassedTestSuites++;\n  }\n\n  // Snapshot data\n  if (testResult.snapshot.added) {\n    aggregatedResults.snapshot.filesAdded++;\n  }\n  if (testResult.snapshot.fileDeleted) {\n    aggregatedResults.snapshot.filesRemoved++;\n  }\n  if (testResult.snapshot.unmatched) {\n    aggregatedResults.snapshot.filesUnmatched++;\n  }\n  if (testResult.snapshot.updated) {\n    aggregatedResults.snapshot.filesUpdated++;\n  }\n\n  aggregatedResults.snapshot.added += testResult.snapshot.added;\n  aggregatedResults.snapshot.matched += testResult.snapshot.matched;\n  aggregatedResults.snapshot.unchecked += testResult.snapshot.unchecked;\n  if (\n    testResult.snapshot.uncheckedKeys != null &&\n    testResult.snapshot.uncheckedKeys.length > 0\n  ) {\n    aggregatedResults.snapshot.uncheckedKeysByFile.push({\n      filePath: testResult.testFilePath,\n      keys: testResult.snapshot.uncheckedKeys,\n    });\n  }\n\n  aggregatedResults.snapshot.unmatched += testResult.snapshot.unmatched;\n  aggregatedResults.snapshot.updated += testResult.snapshot.updated;\n  aggregatedResults.snapshot.total +=\n    testResult.snapshot.added +\n    testResult.snapshot.matched +\n    testResult.snapshot.unmatched +\n    testResult.snapshot.updated;\n};\n\nexport const createEmptyTestResult = (): TestResult => ({\n  leaks: false, // That's legacy code, just adding it as needed for typing\n  numFailingTests: 0,\n  numPassingTests: 0,\n  numPendingTests: 0,\n  numTodoTests: 0,\n  openHandles: [],\n  perfStats: {\n    end: 0,\n    loadTestEnvironmentEnd: 0,\n    loadTestEnvironmentStart: 0,\n    runtime: 0,\n    setupAfterEnvEnd: 0,\n    setupAfterEnvStart: 0,\n    setupFilesEnd: 0,\n    setupFilesStart: 0,\n    slow: false,\n    start: 0,\n  },\n  skipped: false,\n  snapshot: {\n    added: 0,\n    fileDeleted: false,\n    matched: 0,\n    unchecked: 0,\n    uncheckedKeys: [],\n    unmatched: 0,\n    updated: 0,\n  },\n  testFilePath: '',\n  testResults: [],\n});\n",
  "packages/jest-test-result/src/helpers.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { AggregatedResult, SerializableError, TestResult } from './types';\nexport declare const makeEmptyAggregatedTestResult: () => AggregatedResult;\nexport declare const buildFailureTestResult: (testPath: string, err: SerializableError) => TestResult;\nexport declare const addResult: (aggregatedResults: AggregatedResult, testResult: TestResult) => void;\nexport declare const createEmptyTestResult: () => TestResult;\n",
  "packages/jest-test-result/src/formatTestResults.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {\n  AggregatedResult,\n  CodeCoverageFormatter,\n  CodeCoverageReporter,\n  FormattedTestResult,\n  FormattedTestResults,\n  TestResult,\n} from './types';\n\nconst formatTestResult = (\n  testResult: TestResult,\n  codeCoverageFormatter?: CodeCoverageFormatter,\n  reporter?: CodeCoverageReporter,\n): FormattedTestResult => {\n  if (testResult.testExecError) {\n    const now = Date.now();\n    return {\n      assertionResults: testResult.testResults,\n      coverage: {},\n      endTime: now,\n      message: testResult.failureMessage ?? testResult.testExecError.message,\n      name: testResult.testFilePath,\n      startTime: now,\n      status: 'failed',\n      summary: '',\n    };\n  }\n\n  if (testResult.skipped) {\n    const now = Date.now();\n    return {\n      assertionResults: testResult.testResults,\n      coverage: {},\n      endTime: now,\n      message: testResult.failureMessage ?? '',\n      name: testResult.testFilePath,\n      startTime: now,\n      status: 'skipped',\n      summary: '',\n    };\n  }\n\n  const allTestsExecuted = testResult.numPendingTests === 0;\n  const allTestsPassed = testResult.numFailingTests === 0;\n  return {\n    assertionResults: testResult.testResults,\n    coverage:\n      codeCoverageFormatter == null\n        ? testResult.coverage\n        : codeCoverageFormatter(testResult.coverage, reporter),\n    endTime: testResult.perfStats.end,\n    message: testResult.failureMessage ?? '',\n    name: testResult.testFilePath,\n    startTime: testResult.perfStats.start,\n    status: allTestsPassed\n      ? allTestsExecuted\n        ? 'passed'\n        : 'focused'\n      : 'failed',\n    summary: '',\n  };\n};\n\nexport default function formatTestResults(\n  results: AggregatedResult,\n  codeCoverageFormatter?: CodeCoverageFormatter,\n  reporter?: CodeCoverageReporter,\n): FormattedTestResults {\n  const testResults = results.testResults.map(testResult =>\n    formatTestResult(testResult, codeCoverageFormatter, reporter),\n  );\n\n  return {...results, testResults};\n}\n",
  "packages/jest-test-result/src/formatTestResults.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { AggregatedResult, CodeCoverageFormatter, CodeCoverageReporter, FormattedTestResults } from './types';\nexport default function formatTestResults(results: AggregatedResult, codeCoverageFormatter?: CodeCoverageFormatter, reporter?: CodeCoverageReporter): FormattedTestResults;\n",
  "packages/jest-test-result/src/__tests__/formatTestResults.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport formatTestResults from '../formatTestResults';\nimport type {AggregatedResult, AssertionResult} from '../types';\n\ndescribe('formatTestResults', () => {\n  it('includes test full name', () => {\n    const assertion = {\n      fullName: 'TestedModule#aMethod when some condition is met returns true',\n      status: 'passed',\n      title: 'returns true',\n    } as AssertionResult;\n\n    const results = {\n      testResults: [\n        {\n          numFailingTests: 0,\n          perfStats: {end: 2, runtime: 1, slow: false, start: 1},\n          testResults: [assertion],\n        },\n      ],\n    } as AggregatedResult;\n\n    const result = formatTestResults(results, undefined, null);\n    expect(result.testResults[0].assertionResults[0].fullName).toEqual(\n      assertion.fullName,\n    );\n  });\n\n  it('should mark result status to skipped', () => {\n    const skippedAssertion = {\n      fullName: 'Pending test',\n      status: 'pending',\n      title: 'is still pending',\n    } as AssertionResult;\n\n    const skippedResults = {\n      testResults: [\n        {\n          numFailingTests: 0,\n          numPassingTests: 0,\n          numPendingTests: 2,\n          numTodoTests: 2,\n          perfStats: {end: 2, runtime: 1, slow: false, start: 1},\n          testResults: [skippedAssertion],\n        },\n      ],\n    } as AggregatedResult;\n\n    const result = formatTestResults(skippedResults, undefined, null);\n    expect(result.testResults[0].assertionResults[0].status).toEqual(\n      skippedAssertion.status,\n    );\n  });\n\n  it('should mark result status to focused', () => {\n    const focusedAssertion = {\n      fullName: 'Focused test',\n      status: 'focused',\n      title: 'focused test',\n    } as AssertionResult;\n\n    const focusedResults = {\n      testResults: [\n        {\n          numFailingTests: 0,\n          numPassingTests: 1,\n          numPendingTests: 1,\n          numTodoTests: 2,\n          perfStats: {end: 2, runtime: 1, slow: false, start: 1},\n          testResults: [focusedAssertion],\n        },\n      ],\n    } as AggregatedResult;\n\n    const result = formatTestResults(focusedResults, undefined, null);\n    expect(result.testResults[0].assertionResults[0].status).toEqual(\n      focusedAssertion.status,\n    );\n  });\n});\n",
  "packages/jest-test-result/src/__tests__/formatTestResults.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-source-map/src/types.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nexport type SourceMapRegistry = Map<string, string>;\n",
  "packages/jest-source-map/src/types.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport type SourceMapRegistry = Map<string, string>;\n",
  "packages/jest-source-map/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nexport {default as getCallsite} from './getCallsite';\nexport type {SourceMapRegistry} from './types';\n",
  "packages/jest-source-map/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport { default as getCallsite } from './getCallsite';\nexport type { SourceMapRegistry } from './types';\n",
  "packages/jest-source-map/src/getCallsite.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {TraceMap, originalPositionFor} from '@jridgewell/trace-mapping';\nimport callsites from 'callsites';\nimport {readFileSync} from 'graceful-fs';\nimport type {SourceMapRegistry} from './types';\n\n// Copied from https://github.com/rexxars/sourcemap-decorate-callsites/blob/5b9735a156964973a75dc62fd2c7f0c1975458e8/lib/index.js#L113-L158\nconst addSourceMapConsumer = (\n  callsite: callsites.CallSite,\n  tracer: TraceMap,\n) => {\n  const getLineNumber = callsite.getLineNumber.bind(callsite);\n  const getColumnNumber = callsite.getColumnNumber.bind(callsite);\n  let position: ReturnType<typeof originalPositionFor> | null = null;\n\n  function getPosition() {\n    position ??= originalPositionFor(tracer, {\n      column: getColumnNumber() ?? -1,\n      line: getLineNumber() ?? -1,\n    });\n\n    return position;\n  }\n\n  Object.defineProperties(callsite, {\n    getColumnNumber: {\n      value() {\n        const value = getPosition().column;\n        return value == null || value === 0 ? getColumnNumber() : value;\n      },\n      writable: false,\n    },\n    getLineNumber: {\n      value() {\n        const value = getPosition().line;\n\n        return value == null || value === 0 ? getLineNumber() : value;\n      },\n      writable: false,\n    },\n  });\n};\n\nexport default function getCallsite(\n  level: number,\n  sourceMaps?: SourceMapRegistry | null,\n): callsites.CallSite {\n  const levelAfterThisCall = level + 1;\n  const stack = callsites()[levelAfterThisCall];\n  const sourceMapFileName = sourceMaps?.get(stack.getFileName() ?? '');\n\n  if (sourceMapFileName != null && sourceMapFileName !== '') {\n    try {\n      const sourceMap = readFileSync(sourceMapFileName, 'utf8');\n      addSourceMapConsumer(stack, new TraceMap(sourceMap));\n    } catch {\n      // ignore\n    }\n  }\n\n  return stack;\n}\n",
  "packages/jest-source-map/src/getCallsite.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport callsites from 'callsites';\nimport type { SourceMapRegistry } from './types';\nexport default function getCallsite(level: number, sourceMaps?: SourceMapRegistry | null): callsites.CallSite;\n",
  "packages/jest-source-map/src/__tests__/getCallsite.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {originalPositionFor} from '@jridgewell/trace-mapping';\nimport * as fs from 'graceful-fs';\nimport getCallsite from '../getCallsite';\n\njest.mock('graceful-fs');\njest.mock('@jridgewell/trace-mapping', () => {\n  const actual = jest.requireActual<typeof import('@jridgewell/trace-mapping')>(\n    '@jridgewell/trace-mapping',\n  );\n\n  return {\n    ...actual,\n    originalPositionFor: jest.fn(actual.originalPositionFor),\n  };\n});\n\ndescribe('getCallsite', () => {\n  test('without source map', () => {\n    const site = getCallsite(0);\n\n    expect(site.getFileName()).toEqual(__filename);\n    expect(site.getColumnNumber()).toEqual(expect.any(Number));\n    expect(site.getLineNumber()).toEqual(expect.any(Number));\n    expect(fs.readFileSync).not.toHaveBeenCalled();\n  });\n\n  test('ignores errors when fs throws', () => {\n    jest.mocked(fs.readFileSync).mockImplementation(() => {\n      throw new Error('Mock error');\n    });\n\n    const site = getCallsite(0, new Map([[__filename, 'mockedSourceMapFile']]));\n\n    expect(site.getFileName()).toEqual(__filename);\n    expect(site.getColumnNumber()).toEqual(expect.any(Number));\n    expect(site.getLineNumber()).toEqual(expect.any(Number));\n    expect(fs.readFileSync).toHaveBeenCalledWith('mockedSourceMapFile', 'utf8');\n  });\n\n  test('reads source map file to determine line and column', () => {\n    jest.mocked(fs.readFileSync).mockImplementation(() =>\n      JSON.stringify({\n        file: 'file.js',\n        mappings: 'AAAA,OAAO,MAAM,KAAK,GAAG,QAAd',\n        names: [],\n        sources: ['file.js'],\n        sourcesContent: [\"export const hello = 'foobar';\\\\n\"],\n        version: 3,\n      }),\n    );\n\n    const sourceMapColumn = 1;\n    const sourceMapLine = 2;\n\n    jest.mocked(originalPositionFor).mockImplementation(() => ({\n      column: sourceMapColumn,\n      line: sourceMapLine,\n    }));\n\n    const site = getCallsite(0, new Map([[__filename, 'mockedSourceMapFile']]));\n\n    expect(site.getFileName()).toEqual(__filename);\n    expect(site.getColumnNumber()).toEqual(sourceMapColumn);\n    expect(site.getLineNumber()).toEqual(sourceMapLine);\n    expect(originalPositionFor).toHaveBeenCalledTimes(1);\n    expect(originalPositionFor).toHaveBeenCalledWith(expect.anything(), {\n      column: expect.any(Number),\n      line: expect.any(Number),\n    });\n    expect(fs.readFileSync).toHaveBeenCalledWith('mockedSourceMapFile', 'utf8');\n  });\n});\n",
  "packages/jest-source-map/src/__tests__/getCallsite.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-snapshot-utils/src/utils.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport chalk from 'chalk';\nimport * as fs from 'graceful-fs';\nimport naturalCompare from 'natural-compare';\nimport type {Config} from '@jest/types';\nimport type {SnapshotData} from './types';\n\nexport const SNAPSHOT_VERSION = '1';\nconst SNAPSHOT_VERSION_REGEXP = /^\\/\\/ Jest Snapshot v(.+),/;\nexport const SNAPSHOT_GUIDE_LINK = 'https://jestjs.io/docs/snapshot-testing';\nexport const SNAPSHOT_VERSION_WARNING = chalk.yellow(\n  `${chalk.bold('Warning')}: Before you upgrade snapshots, ` +\n    'we recommend that you revert any local changes to tests or other code, ' +\n    'to ensure that you do not store invalid state.',\n);\n\nconst writeSnapshotVersion = () =>\n  `// Jest Snapshot v${SNAPSHOT_VERSION}, ${SNAPSHOT_GUIDE_LINK}`;\n\nconst validateSnapshotVersion = (snapshotContents: string) => {\n  const versionTest = SNAPSHOT_VERSION_REGEXP.exec(snapshotContents);\n  const version = versionTest && versionTest[1];\n\n  if (!version) {\n    return new Error(\n      chalk.red(\n        `${chalk.bold('Outdated snapshot')}: No snapshot header found. ` +\n          'Jest 19 introduced versioned snapshots to ensure all developers ' +\n          'on a project are using the same version of Jest. ' +\n          'Please update all snapshots during this upgrade of Jest.\\n\\n',\n      ) + SNAPSHOT_VERSION_WARNING,\n    );\n  }\n\n  if (version < SNAPSHOT_VERSION) {\n    return new Error(\n      // eslint-disable-next-line prefer-template\n      chalk.red(\n        `${chalk.red.bold('Outdated snapshot')}: The version of the snapshot ` +\n          'file associated with this test is outdated. The snapshot file ' +\n          'version ensures that all developers on a project are using ' +\n          'the same version of Jest. ' +\n          'Please update all snapshots during this upgrade of Jest.',\n      ) +\n        '\\n\\n' +\n        `Expected: v${SNAPSHOT_VERSION}\\n` +\n        `Received: v${version}\\n\\n` +\n        SNAPSHOT_VERSION_WARNING,\n    );\n  }\n\n  if (version > SNAPSHOT_VERSION) {\n    return new Error(\n      // eslint-disable-next-line prefer-template\n      chalk.red(\n        `${chalk.red.bold('Outdated Jest version')}: The version of this ` +\n          'snapshot file indicates that this project is meant to be used ' +\n          'with a newer version of Jest. The snapshot file version ensures ' +\n          'that all developers on a project are using the same version of ' +\n          'Jest. Please update your version of Jest and re-run the tests.',\n      ) +\n        '\\n\\n' +\n        `Expected: v${SNAPSHOT_VERSION}\\n` +\n        `Received: v${version}`,\n    );\n  }\n\n  return null;\n};\n\nconst normalizeTestNameForKey = (testName: string): string =>\n  testName.replaceAll(/\\r\\n|\\r|\\n/g, match => {\n    switch (match) {\n      case '\\r\\n':\n        return '\\\\r\\\\n';\n      case '\\r':\n        return '\\\\r';\n      case '\\n':\n        return '\\\\n';\n      default:\n        return match;\n    }\n  });\n\nconst denormalizeTestNameFromKey = (key: string): string =>\n  key.replaceAll(/\\\\r\\\\n|\\\\r|\\\\n/g, match => {\n    switch (match) {\n      case '\\\\r\\\\n':\n        return '\\r\\n';\n      case '\\\\r':\n        return '\\r';\n      case '\\\\n':\n        return '\\n';\n      default:\n        return match;\n    }\n  });\n\nexport const testNameToKey = (testName: string, count: number): string =>\n  `${normalizeTestNameForKey(testName)} ${count}`;\n\nexport const keyToTestName = (key: string): string => {\n  if (!/ \\d+$/.test(key)) {\n    throw new Error('Snapshot keys must end with a number.');\n  }\n  const testNameWithoutCount = key.replace(/ \\d+$/, '');\n  return denormalizeTestNameFromKey(testNameWithoutCount);\n};\n\nexport const getSnapshotData = (\n  snapshotPath: string,\n  update: Config.SnapshotUpdateState,\n): {\n  data: SnapshotData;\n  dirty: boolean;\n} => {\n  const data = Object.create(null);\n  let snapshotContents = '';\n  let dirty = false;\n\n  if (fs.existsSync(snapshotPath)) {\n    try {\n      snapshotContents = fs.readFileSync(snapshotPath, 'utf8');\n      // eslint-disable-next-line no-new-func\n      const populate = new Function('exports', snapshotContents);\n      populate(data);\n    } catch {}\n  }\n\n  const validationResult = validateSnapshotVersion(snapshotContents);\n  const isInvalid = snapshotContents && validationResult;\n\n  if (update === 'none' && isInvalid) {\n    throw validationResult;\n  }\n\n  if ((update === 'all' || update === 'new') && isInvalid) {\n    dirty = true;\n  }\n\n  return {data, dirty};\n};\n\nexport const escapeBacktickString = (str: string): string =>\n  str.replaceAll(/`|\\\\|\\${/g, '\\\\$&');\n\nconst printBacktickString = (str: string): string =>\n  `\\`${escapeBacktickString(str)}\\``;\n\nexport const ensureDirectoryExists = (filePath: string): void => {\n  try {\n    fs.mkdirSync(path.dirname(filePath), {recursive: true});\n  } catch {}\n};\n\nexport const normalizeNewlines = (string: string): string =>\n  string.replaceAll(/\\r\\n|\\r/g, '\\n');\n\nexport const saveSnapshotFile = (\n  snapshotData: SnapshotData,\n  snapshotPath: string,\n): void => {\n  const snapshots = Object.keys(snapshotData)\n    .sort(naturalCompare)\n    .map(\n      key =>\n        `exports[${printBacktickString(key)}] = ${printBacktickString(\n          normalizeNewlines(snapshotData[key]),\n        )};`,\n    );\n\n  ensureDirectoryExists(snapshotPath);\n  fs.writeFileSync(\n    snapshotPath,\n    `${writeSnapshotVersion()}\\n\\n${snapshots.join('\\n\\n')}\\n`,\n  );\n};\n",
  "packages/jest-snapshot-utils/src/utils.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config } from '@jest/types';\nimport type { SnapshotData } from './types';\nexport declare const SNAPSHOT_VERSION = \"1\";\nexport declare const SNAPSHOT_GUIDE_LINK = \"https://jestjs.io/docs/snapshot-testing\";\nexport declare const SNAPSHOT_VERSION_WARNING: string;\nexport declare const testNameToKey: (testName: string, count: number) => string;\nexport declare const keyToTestName: (key: string) => string;\nexport declare const getSnapshotData: (snapshotPath: string, update: Config.SnapshotUpdateState) => {\n    data: SnapshotData;\n    dirty: boolean;\n};\nexport declare const escapeBacktickString: (str: string) => string;\nexport declare const ensureDirectoryExists: (filePath: string) => void;\nexport declare const normalizeNewlines: (string: string) => string;\nexport declare const saveSnapshotFile: (snapshotData: SnapshotData, snapshotPath: string) => void;\n",
  "packages/jest-snapshot-utils/src/types.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nexport type SnapshotData = Record<string, string>;\n",
  "packages/jest-snapshot-utils/src/types.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport type SnapshotData = Record<string, string>;\n",
  "packages/jest-snapshot-utils/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nexport * from './utils';\nexport * from './types';\n",
  "packages/jest-snapshot-utils/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport * from './utils';\nexport * from './types';\n",
  "packages/jest-snapshot-utils/src/__tests__/utils.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\njest.mock('graceful-fs', () => ({\n  ...jest.createMockFromModule<typeof import('fs')>('fs'),\n  existsSync: jest.fn().mockReturnValue(true),\n}));\n\nimport * as path from 'path';\nimport chalk from 'chalk';\nimport * as fs from 'graceful-fs';\nimport {\n  SNAPSHOT_GUIDE_LINK,\n  SNAPSHOT_VERSION,\n  SNAPSHOT_VERSION_WARNING,\n  getSnapshotData,\n  keyToTestName,\n  saveSnapshotFile,\n  testNameToKey,\n} from '../utils';\n\ntest('keyToTestName()', () => {\n  expect(keyToTestName('abc cde 12')).toBe('abc cde');\n  expect(keyToTestName('abc cde   12')).toBe('abc cde  ');\n  expect(keyToTestName('test with\\\\r\\\\nCRLF 1')).toBe('test with\\r\\nCRLF');\n  expect(keyToTestName('test with\\\\rCR 1')).toBe('test with\\rCR');\n  expect(keyToTestName('test with\\\\nLF 1')).toBe('test with\\nLF');\n  expect(() => keyToTestName('abc cde')).toThrow(\n    'Snapshot keys must end with a number.',\n  );\n});\n\ntest('testNameToKey', () => {\n  expect(testNameToKey('abc cde', 1)).toBe('abc cde 1');\n  expect(testNameToKey('abc cde ', 12)).toBe('abc cde  12');\n});\n\ntest('testNameToKey escapes line endings to prevent collisions', () => {\n  expect(testNameToKey('test with\\r\\nCRLF', 1)).toBe('test with\\\\r\\\\nCRLF 1');\n  expect(testNameToKey('test with\\rCR', 1)).toBe('test with\\\\rCR 1');\n  expect(testNameToKey('test with\\nLF', 1)).toBe('test with\\\\nLF 1');\n\n  expect(testNameToKey('test\\r\\n', 1)).not.toBe(testNameToKey('test\\r', 1));\n  expect(testNameToKey('test\\r\\n', 1)).not.toBe(testNameToKey('test\\n', 1));\n  expect(testNameToKey('test\\r', 1)).not.toBe(testNameToKey('test\\n', 1));\n});\n\ntest('keyToTestName reverses testNameToKey transformation', () => {\n  const testCases = [\n    'simple test',\n    'test with\\r\\nCRLF',\n    'test with\\rCR only',\n    'test with\\nLF only',\n    'mixed\\r\\nline\\rendings\\n',\n    'test\\r',\n    'test\\r\\n',\n    'test\\n',\n  ];\n\n  for (const testName of testCases) {\n    const key = testNameToKey(testName, 1);\n    const recovered = keyToTestName(key);\n    expect(recovered).toBe(testName);\n  }\n});\n\ntest('saveSnapshotFile() works with \\r\\n', () => {\n  const filename = path.join(__dirname, 'remove-newlines.snap');\n  const data = {\n    myKey: '<div>\\r\\n</div>',\n  };\n\n  saveSnapshotFile(data, filename);\n  expect(fs.writeFileSync).toHaveBeenCalledWith(\n    filename,\n    `// Jest Snapshot v1, ${SNAPSHOT_GUIDE_LINK}\\n\\n` +\n      'exports[`myKey`] = `<div>\\n</div>`;\\n',\n  );\n});\n\ntest('saveSnapshotFile() works with \\r', () => {\n  const filename = path.join(__dirname, 'remove-newlines.snap');\n  const data = {\n    myKey: '<div>\\r</div>',\n  };\n\n  saveSnapshotFile(data, filename);\n  expect(fs.writeFileSync).toHaveBeenCalledWith(\n    filename,\n    `// Jest Snapshot v1, ${SNAPSHOT_GUIDE_LINK}\\n\\n` +\n      'exports[`myKey`] = `<div>\\n</div>`;\\n',\n  );\n});\n\ntest('getSnapshotData() throws when no snapshot version', () => {\n  const filename = path.join(__dirname, 'old-snapshot.snap');\n  jest\n    .mocked(fs.readFileSync)\n    .mockReturnValue('exports[`myKey`] = `<div>\\n</div>`;\\n');\n  const update = 'none';\n\n  expect(() => getSnapshotData(filename, update)).toThrow(\n    chalk.red(\n      `${chalk.bold('Outdated snapshot')}: No snapshot header found. ` +\n        'Jest 19 introduced versioned snapshots to ensure all developers on ' +\n        'a project are using the same version of Jest. ' +\n        'Please update all snapshots during this upgrade of Jest.\\n\\n',\n    ) + SNAPSHOT_VERSION_WARNING,\n  );\n});\n\ntest('getSnapshotData() throws for older snapshot version', () => {\n  const filename = path.join(__dirname, 'old-snapshot.snap');\n  jest\n    .mocked(fs.readFileSync)\n    .mockReturnValue(\n      `// Jest Snapshot v0.99, ${SNAPSHOT_GUIDE_LINK}\\n\\n` +\n        'exports[`myKey`] = `<div>\\n</div>`;\\n',\n    );\n  const update = 'none';\n\n  expect(() => getSnapshotData(filename, update)).toThrow(\n    `${chalk.red(\n      `${chalk.red.bold('Outdated snapshot')}: The version of the snapshot ` +\n        'file associated with this test is outdated. The snapshot file ' +\n        'version ensures that all developers on a project are using ' +\n        'the same version of Jest. ' +\n        'Please update all snapshots during this upgrade of Jest.',\n    )}\\n\\nExpected: v${SNAPSHOT_VERSION}\\n` +\n      `Received: v0.99\\n\\n${SNAPSHOT_VERSION_WARNING}`,\n  );\n});\n\ntest('getSnapshotData() throws for newer snapshot version', () => {\n  const filename = path.join(__dirname, 'old-snapshot.snap');\n  jest\n    .mocked(fs.readFileSync)\n    .mockReturnValue(\n      `// Jest Snapshot v2, ${SNAPSHOT_GUIDE_LINK}\\n\\n` +\n        'exports[`myKey`] = `<div>\\n</div>`;\\n',\n    );\n  const update = 'none';\n\n  expect(() => getSnapshotData(filename, update)).toThrow(\n    `${chalk.red(\n      `${chalk.red.bold('Outdated Jest version')}: The version of this ` +\n        'snapshot file indicates that this project is meant to be used ' +\n        'with a newer version of Jest. ' +\n        'The snapshot file version ensures that all developers on a project ' +\n        'are using the same version of Jest. ' +\n        'Please update your version of Jest and re-run the tests.',\n    )}\\n\\nExpected: v${SNAPSHOT_VERSION}\\nReceived: v2`,\n  );\n});\n\ntest('getSnapshotData() does not throw for when updating', () => {\n  const filename = path.join(__dirname, 'old-snapshot.snap');\n  jest\n    .mocked(fs.readFileSync)\n    .mockReturnValue('exports[`myKey`] = `<div>\\n</div>`;\\n');\n  const update = 'all';\n\n  expect(() => getSnapshotData(filename, update)).not.toThrow();\n});\n\ntest('getSnapshotData() marks invalid snapshot dirty when updating', () => {\n  const filename = path.join(__dirname, 'old-snapshot.snap');\n  jest\n    .mocked(fs.readFileSync)\n    .mockReturnValue('exports[`myKey`] = `<div>\\n</div>`;\\n');\n  const update = 'all';\n\n  expect(getSnapshotData(filename, update)).toMatchObject({dirty: true});\n});\n\ntest('getSnapshotData() marks valid snapshot not dirty when updating', () => {\n  const filename = path.join(__dirname, 'old-snapshot.snap');\n  jest\n    .mocked(fs.readFileSync)\n    .mockReturnValue(\n      `// Jest Snapshot v${SNAPSHOT_VERSION}, ${SNAPSHOT_GUIDE_LINK}\\n\\n` +\n        'exports[`myKey`] = `<div>\\n</div>`;\\n',\n    );\n  const update = 'all';\n\n  expect(getSnapshotData(filename, update)).toMatchObject({dirty: false});\n});\n\ntest('escaping', () => {\n  const filename = path.join(__dirname, 'escaping.snap');\n  const data = '\"\\'\\\\';\n  const writeFileSync = jest.mocked(fs.writeFileSync);\n\n  writeFileSync.mockReset();\n  saveSnapshotFile({key: data}, filename);\n  const writtenData = writeFileSync.mock.calls[0][1];\n  expect(writtenData).toBe(\n    `// Jest Snapshot v1, ${SNAPSHOT_GUIDE_LINK}\\n\\n` +\n      'exports[`key`] = `\"\\'\\\\\\\\`;\\n',\n  );\n\n  // eslint-disable-next-line no-eval\n  const readData = eval(`var exports = {}; ${writtenData} exports`);\n  expect(readData).toEqual({key: data});\n  const snapshotData = readData.key;\n  expect(data).toEqual(snapshotData);\n});\n",
  "packages/jest-snapshot-utils/src/__tests__/utils.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-snapshot/src/worker.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {runAsWorker} from 'synckit';\nimport {processPrettierAst} from './utils';\n\nlet prettier: typeof import('prettier');\n\nasync function getInferredParser(filepath: string) {\n  const fileInfo = await prettier.getFileInfo(filepath);\n\n  return fileInfo.inferredParser;\n}\n\nrunAsWorker(\n  async (\n    prettierPath: string,\n    filepath: string,\n    sourceFileWithSnapshots: string,\n    snapshotMatcherNames: Array<string>,\n  ) => {\n    prettier ??= require(\n      /*webpackIgnore: true*/\n      require.resolve(prettierPath, {\n        [Symbol.for('jest-resolve-outside-vm-option')]: true,\n      }),\n    );\n\n    const config = await prettier.resolveConfig(filepath, {\n      editorconfig: true,\n    });\n\n    const inferredParser: string | null =\n      typeof config?.parser === 'string'\n        ? config.parser\n        : await getInferredParser(filepath);\n\n    if (!inferredParser) {\n      throw new Error(`Could not infer Prettier parser for file ${filepath}`);\n    }\n\n    sourceFileWithSnapshots = await prettier.format(sourceFileWithSnapshots, {\n      ...config,\n      filepath,\n      parser: inferredParser,\n    });\n\n    // @ts-expect-error private API\n    const {ast} = await prettier.__debug.parse(sourceFileWithSnapshots, {\n      ...config,\n      filepath,\n      originalText: sourceFileWithSnapshots,\n      parser: inferredParser,\n    });\n    processPrettierAst(ast, config, snapshotMatcherNames, true);\n    // Snapshots have now been inserted. Run prettier to make sure that the code is\n    // formatted, except snapshot indentation. Snapshots cannot be formatted until\n    // after the initial format because we don't know where the call expression\n    // will be placed (specifically its indentation), so we have to do two\n    // prettier.format calls back-to-back.\n    // @ts-expect-error private API\n    const formatAST = await prettier.__debug.formatAST(ast, {\n      ...config,\n      filepath,\n      originalText: sourceFileWithSnapshots,\n      parser: inferredParser,\n    });\n    return formatAST.formatted;\n  },\n);\n",
  "packages/jest-snapshot/src/worker.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-snapshot/src/utils.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {ParseResult, PluginItem} from '@babel/core';\nimport type {\n  File,\n  Node,\n  Program,\n  TemplateLiteral,\n  TraversalAncestors,\n} from '@babel/types';\nimport * as fs from 'graceful-fs';\nimport {escapeBacktickString, normalizeNewlines} from '@jest/snapshot-utils';\nimport {\n  type OptionsReceived as PrettyFormatOptions,\n  format as prettyFormat,\n} from 'pretty-format';\nimport {getSerializers} from './plugins';\nimport type {InlineSnapshot} from './types';\n\nfunction isObject(item: unknown): boolean {\n  return item != null && typeof item === 'object' && !Array.isArray(item);\n}\n\n// Add extra line breaks at beginning and end of multiline snapshot\n// to make the content easier to read.\nexport const addExtraLineBreaks = (string: string): string =>\n  string.includes('\\n') ? `\\n${string}\\n` : string;\n\n// Remove extra line breaks at beginning and end of multiline snapshot.\n// Instead of trim, which can remove additional newlines or spaces\n// at beginning or end of the content from a custom serializer.\nexport const removeExtraLineBreaks = (string: string): string =>\n  string.length > 2 && string.startsWith('\\n') && string.endsWith('\\n')\n    ? string.slice(1, -1)\n    : string;\n\nexport const removeLinesBeforeExternalMatcherTrap = (stack: string): string => {\n  const lines = stack.split('\\n');\n\n  for (let i = 0; i < lines.length; i += 1) {\n    // It's a function name specified in `packages/expect/src/index.ts`\n    // for external custom matchers.\n    if (lines[i].includes('__EXTERNAL_MATCHER_TRAP__')) {\n      return lines.slice(i + 1).join('\\n');\n    }\n  }\n\n  return stack;\n};\n\nconst escapeRegex = true;\nconst printFunctionName = false;\n\nexport const serialize = (\n  val: unknown,\n  indent = 2,\n  formatOverrides: PrettyFormatOptions = {},\n): string =>\n  normalizeNewlines(\n    prettyFormat(val, {\n      escapeRegex,\n      indent,\n      plugins: getSerializers(),\n      printFunctionName,\n      ...formatOverrides,\n    }),\n  );\n\nexport const minify = (val: unknown): string =>\n  prettyFormat(val, {\n    escapeRegex,\n    min: true,\n    plugins: getSerializers(),\n    printFunctionName,\n  });\n\n// Remove double quote marks and unescape double quotes and backslashes.\nexport const deserializeString = (stringified: string): string =>\n  stringified.slice(1, -1).replaceAll(/\\\\(\"|\\\\)/g, '$1');\n\nconst isAnyOrAnything = (input: object) =>\n  '$$typeof' in input &&\n  input.$$typeof === Symbol.for('jest.asymmetricMatcher') &&\n  ['Any', 'Anything'].includes(input.constructor.name);\n\nconst deepMergeArray = (target: Array<any>, source: Array<any>) => {\n  const mergedOutput = [...target];\n\n  for (const [index, sourceElement] of source.entries()) {\n    const targetElement = mergedOutput[index];\n\n    if (Array.isArray(target[index]) && Array.isArray(sourceElement)) {\n      mergedOutput[index] = deepMergeArray(target[index], sourceElement);\n    } else if (isObject(targetElement) && !isAnyOrAnything(sourceElement)) {\n      mergedOutput[index] = deepMerge(target[index], sourceElement);\n    } else {\n      // Source does not exist in target or target is primitive and cannot be deep merged\n      mergedOutput[index] = sourceElement;\n    }\n  }\n\n  return mergedOutput;\n};\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport const deepMerge = (target: any, source: any): any => {\n  if (isObject(target) && isObject(source)) {\n    const mergedOutput = {...target};\n\n    for (const key of Object.keys(source)) {\n      if (isObject(source[key]) && !source[key].$$typeof) {\n        if (key in target) {\n          mergedOutput[key] = deepMerge(target[key], source[key]);\n        } else {\n          Object.assign(mergedOutput, {[key]: source[key]});\n        }\n      } else if (Array.isArray(source[key])) {\n        mergedOutput[key] = deepMergeArray(target[key], source[key]);\n      } else {\n        Object.assign(mergedOutput, {[key]: source[key]});\n      }\n    }\n\n    return mergedOutput;\n  } else if (Array.isArray(target) && Array.isArray(source)) {\n    return deepMergeArray(target, source);\n  }\n\n  return target;\n};\n\nconst indent = (\n  snapshot: string,\n  numIndents: number,\n  indentation: string,\n): string => {\n  const lines = snapshot.split('\\n');\n  // Prevent re-indentation of inline snapshots.\n  if (\n    lines.length >= 2 &&\n    lines[1].startsWith(indentation.repeat(numIndents + 1))\n  ) {\n    return snapshot;\n  }\n\n  return lines\n    .map((line, index) => {\n      if (index === 0) {\n        // First line is either a 1-line snapshot or a blank line.\n        return line;\n      } else if (index === lines.length - 1) {\n        // The last line should be placed on the same level as the expect call.\n        return indentation.repeat(numIndents) + line;\n      } else {\n        // Do not indent empty lines.\n        if (line === '') {\n          return line;\n        }\n\n        // Not last line, indent one level deeper than expect call.\n        return indentation.repeat(numIndents + 1) + line;\n      }\n    })\n    .join('\\n');\n};\n\nconst generate = (\n  require(\n    require.resolve('@babel/generator', {\n      [Symbol.for('jest-resolve-outside-vm-option')]: true,\n    }),\n  ) as typeof import('@babel/generator')\n).default;\n\nconst {parseSync, types} = require(\n  require.resolve('@babel/core', {\n    [Symbol.for('jest-resolve-outside-vm-option')]: true,\n  }),\n) as typeof import('@babel/core');\n\nconst {\n  isAwaitExpression,\n  templateElement,\n  templateLiteral,\n  traverseFast,\n  traverse,\n} = types;\n\nexport const processInlineSnapshotsWithBabel = (\n  snapshots: Array<InlineSnapshot>,\n  sourceFilePath: string,\n  rootDir: string,\n): {\n  snapshotMatcherNames: Array<string>;\n  sourceFile: string;\n  sourceFileWithSnapshots: string;\n} => {\n  const sourceFile = fs.readFileSync(sourceFilePath, 'utf8');\n\n  // TypeScript projects may not have a babel config; make sure they can be parsed anyway.\n  const presets = [require.resolve('babel-preset-current-node-syntax')];\n  const plugins: Array<PluginItem> = [];\n  if (/\\.([cm]?ts|tsx)$/.test(sourceFilePath)) {\n    plugins.push([\n      require.resolve('@babel/plugin-syntax-typescript'),\n      {isTSX: sourceFilePath.endsWith('x')},\n      // unique name to make sure Babel does not complain about a possible duplicate plugin.\n      'TypeScript syntax plugin added by Jest snapshot',\n    ]);\n  }\n\n  // Record the matcher names seen during traversal and pass them down one\n  // by one to formatting parser.\n  const snapshotMatcherNames: Array<string> = [];\n\n  let ast: ParseResult | null = null;\n\n  try {\n    ast = parseSync(sourceFile, {\n      filename: sourceFilePath,\n      plugins,\n      presets,\n      root: rootDir,\n    });\n  } catch (error: any) {\n    // attempt to recover from missing jsx plugin\n    if (error.message.includes('@babel/plugin-syntax-jsx')) {\n      try {\n        const jsxSyntaxPlugin: PluginItem = [\n          require.resolve('@babel/plugin-syntax-jsx'),\n          {},\n          // unique name to make sure Babel does not complain about a possible duplicate plugin.\n          'JSX syntax plugin added by Jest snapshot',\n        ];\n        ast = parseSync(sourceFile, {\n          filename: sourceFilePath,\n          plugins: [...plugins, jsxSyntaxPlugin],\n          presets,\n          root: rootDir,\n        });\n      } catch {\n        throw error;\n      }\n    } else {\n      throw error;\n    }\n  }\n\n  if (!ast) {\n    throw new Error(`jest-snapshot: Failed to parse ${sourceFilePath}`);\n  }\n  traverseAst(snapshots, ast, snapshotMatcherNames);\n\n  return {\n    snapshotMatcherNames,\n    sourceFile,\n    // substitute in the snapshots in reverse order, so slice calculations aren't thrown off.\n    sourceFileWithSnapshots: snapshots.reduceRight(\n      (sourceSoFar, nextSnapshot) => {\n        const {node} = nextSnapshot;\n        if (\n          !node ||\n          typeof node.start !== 'number' ||\n          typeof node.end !== 'number'\n        ) {\n          throw new Error('Jest: no snapshot insert location found');\n        }\n\n        // A hack to prevent unexpected line breaks in the generated code\n        node.loc!.end.line = node.loc!.start.line;\n\n        return (\n          sourceSoFar.slice(0, node.start) +\n          generate(node, {retainLines: true}).code.trim() +\n          sourceSoFar.slice(node.end)\n        );\n      },\n      sourceFile,\n    ),\n  };\n};\n\nexport const processPrettierAst = (\n  ast: File,\n  options: Record<string, any> | null,\n  snapshotMatcherNames: Array<string>,\n  keepNode?: boolean,\n): void => {\n  traverse(ast, (node: Node, ancestors: TraversalAncestors) => {\n    if (node.type !== 'CallExpression') return;\n\n    const {arguments: args, callee} = node;\n    if (\n      callee.type !== 'MemberExpression' ||\n      callee.property.type !== 'Identifier' ||\n      !snapshotMatcherNames.includes(callee.property.name) ||\n      !callee.loc ||\n      callee.computed\n    ) {\n      return;\n    }\n\n    let snapshotIndex: number | undefined;\n    let snapshot: string | undefined;\n    for (const [i, node] of args.entries()) {\n      if (node.type === 'TemplateLiteral') {\n        snapshotIndex = i;\n        snapshot = node.quasis[0].value.raw;\n      }\n    }\n    if (snapshot === undefined) {\n      return;\n    }\n\n    const parent = ancestors.at(-1)!.node;\n    const startColumn =\n      isAwaitExpression(parent) && parent.loc\n        ? parent.loc.start.column\n        : callee.loc.start.column;\n\n    const useSpaces = !options?.useTabs;\n    snapshot = indent(\n      snapshot,\n      Math.ceil(\n        useSpaces\n          ? startColumn / (options?.tabWidth ?? 1)\n          : // Each tab is 2 characters.\n            startColumn / 2,\n      ),\n      useSpaces ? ' '.repeat(options?.tabWidth ?? 1) : '\\t',\n    );\n\n    if (keepNode) {\n      (args[snapshotIndex!] as TemplateLiteral).quasis[0].value.raw = snapshot;\n    } else {\n      const replacementNode = templateLiteral(\n        [\n          templateElement({\n            raw: snapshot,\n          }),\n        ],\n        [],\n      );\n      args[snapshotIndex!] = replacementNode;\n    }\n  });\n};\n\nconst groupSnapshotsBy =\n  (createKey: (inlineSnapshot: InlineSnapshot) => string) =>\n  (snapshots: Array<InlineSnapshot>) =>\n    snapshots.reduce<Record<string, Array<InlineSnapshot>>>(\n      (object, inlineSnapshot) => {\n        const key = createKey(inlineSnapshot);\n        return {\n          ...object,\n          [key]: [...(object[key] || []), inlineSnapshot],\n        };\n      },\n      {},\n    );\n\nconst groupSnapshotsByFrame = groupSnapshotsBy(({frame: {line, column}}) =>\n  typeof line === 'number' && typeof column === 'number'\n    ? `${line}:${column - 1}`\n    : '',\n);\nexport const groupSnapshotsByFile = groupSnapshotsBy(({frame: {file}}) => file);\n\nconst traverseAst = (\n  snapshots: Array<InlineSnapshot>,\n  ast: File | Program,\n  snapshotMatcherNames: Array<string>,\n) => {\n  const groupedSnapshots = groupSnapshotsByFrame(snapshots);\n  const remainingSnapshots = new Set(snapshots.map(({snapshot}) => snapshot));\n\n  traverseFast(ast, (node: Node) => {\n    if (node.type !== 'CallExpression') return;\n\n    const {arguments: args, callee} = node;\n    if (\n      callee.type !== 'MemberExpression' ||\n      callee.property.type !== 'Identifier' ||\n      callee.property.loc == null\n    ) {\n      return;\n    }\n    const {line, column} = callee.property.loc.start;\n    const snapshotsForFrame = groupedSnapshots[`${line}:${column}`];\n    if (!snapshotsForFrame) {\n      return;\n    }\n    if (snapshotsForFrame.length > 1) {\n      throw new Error(\n        'Jest: Multiple inline snapshots for the same call are not supported.',\n      );\n    }\n    const inlineSnapshot = snapshotsForFrame[0];\n    inlineSnapshot.node = node;\n\n    snapshotMatcherNames.push(callee.property.name);\n\n    const snapshotIndex = args.findIndex(\n      ({type}) => type === 'TemplateLiteral' || type === 'StringLiteral',\n    );\n\n    const {snapshot} = inlineSnapshot;\n    remainingSnapshots.delete(snapshot);\n    const replacementNode = templateLiteral(\n      [templateElement({raw: escapeBacktickString(snapshot)})],\n      [],\n    );\n\n    if (snapshotIndex === -1) {\n      args.push(replacementNode);\n    } else {\n      args[snapshotIndex] = replacementNode;\n    }\n  });\n\n  if (remainingSnapshots.size > 0) {\n    throw new Error(\"Jest: Couldn't locate all inline snapshots.\");\n  }\n};\n",
  "packages/jest-snapshot/src/utils.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { File } from '@babel/types';\nimport { type OptionsReceived as PrettyFormatOptions } from 'pretty-format';\nimport type { InlineSnapshot } from './types';\nexport declare const addExtraLineBreaks: (string: string) => string;\nexport declare const removeExtraLineBreaks: (string: string) => string;\nexport declare const removeLinesBeforeExternalMatcherTrap: (stack: string) => string;\nexport declare const serialize: (val: unknown, indent?: number, formatOverrides?: PrettyFormatOptions) => string;\nexport declare const minify: (val: unknown) => string;\nexport declare const deserializeString: (stringified: string) => string;\nexport declare const deepMerge: (target: any, source: any) => any;\nexport declare const processInlineSnapshotsWithBabel: (snapshots: Array<InlineSnapshot>, sourceFilePath: string, rootDir: string) => {\n    snapshotMatcherNames: Array<string>;\n    sourceFile: string;\n    sourceFileWithSnapshots: string;\n};\nexport declare const processPrettierAst: (ast: File, options: Record<string, any> | null, snapshotMatcherNames: Array<string>, keepNode?: boolean) => void;\nexport declare const groupSnapshotsByFile: (snapshots: Array<InlineSnapshot>) => Record<string, InlineSnapshot[]>;\n",
  "packages/jest-snapshot/src/types.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {Expression} from '@babel/types';\nimport type {MatcherContext} from 'expect';\nimport type {Frame} from 'jest-message-util';\nimport type {PrettyFormatOptions} from 'pretty-format';\nimport type SnapshotState from './State';\n\nexport interface Context extends MatcherContext {\n  snapshotState: SnapshotState;\n  testFailing?: boolean;\n}\n\n// This is typically implemented by `jest-haste-map`'s `HasteFS`, but we\n// partially reproduce the interface here to avoid a dependency.\n\nexport interface FileSystem {\n  exists(path: string): boolean;\n  matchFiles(pattern: RegExp | string): Array<string>;\n}\n\nexport type MatchSnapshotConfig = {\n  context: Context;\n  hint?: string;\n  inlineSnapshot?: string;\n  isInline: boolean;\n  matcherName: string;\n  properties?: object;\n  received: any;\n};\n\nexport interface SnapshotMatchers<R extends void | Promise<void>, T> {\n  /**\n   * This ensures that a value matches the most recent snapshot with property matchers.\n   * Check out [the Snapshot Testing guide](https://jestjs.io/docs/snapshot-testing) for more information.\n   */\n  toMatchSnapshot(hint?: string): R;\n  /**\n   * This ensures that a value matches the most recent snapshot.\n   * Check out [the Snapshot Testing guide](https://jestjs.io/docs/snapshot-testing) for more information.\n   */\n  toMatchSnapshot<U extends Record<keyof T, unknown>>(\n    propertyMatchers: Partial<U>,\n    hint?: string,\n  ): R;\n  /**\n   * This ensures that a value matches the most recent snapshot with property matchers.\n   * Instead of writing the snapshot value to a .snap file, it will be written into the source code automatically.\n   * Check out [the Snapshot Testing guide](https://jestjs.io/docs/snapshot-testing) for more information.\n   */\n  toMatchInlineSnapshot(snapshot?: string): R;\n  /**\n   * This ensures that a value matches the most recent snapshot with property matchers.\n   * Instead of writing the snapshot value to a .snap file, it will be written into the source code automatically.\n   * Check out [the Snapshot Testing guide](https://jestjs.io/docs/snapshot-testing) for more information.\n   */\n  toMatchInlineSnapshot<U extends Record<keyof T, unknown>>(\n    propertyMatchers: Partial<U>,\n    snapshot?: string,\n  ): R;\n  /**\n   * Used to test that a function throws a error matching the most recent snapshot when it is called.\n   */\n  toThrowErrorMatchingSnapshot(hint?: string): R;\n  /**\n   * Used to test that a function throws a error matching the most recent snapshot when it is called.\n   * Instead of writing the snapshot value to a .snap file, it will be written into the source code automatically.\n   */\n  toThrowErrorMatchingInlineSnapshot(snapshot?: string): R;\n}\n\nexport type SnapshotFormat = Omit<PrettyFormatOptions, 'compareKeys'>;\n\nexport type InlineSnapshot = {\n  snapshot: string;\n  frame: Frame;\n  node?: Expression;\n};\n",
  "packages/jest-snapshot/src/types.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Expression } from '@babel/types';\nimport type { MatcherContext } from 'expect';\nimport type { Frame } from 'jest-message-util';\nimport type { PrettyFormatOptions } from 'pretty-format';\nimport type SnapshotState from './State';\nexport interface Context extends MatcherContext {\n    snapshotState: SnapshotState;\n    testFailing?: boolean;\n}\nexport interface FileSystem {\n    exists(path: string): boolean;\n    matchFiles(pattern: RegExp | string): Array<string>;\n}\nexport type MatchSnapshotConfig = {\n    context: Context;\n    hint?: string;\n    inlineSnapshot?: string;\n    isInline: boolean;\n    matcherName: string;\n    properties?: object;\n    received: any;\n};\nexport interface SnapshotMatchers<R extends void | Promise<void>, T> {\n    /**\n     * This ensures that a value matches the most recent snapshot with property matchers.\n     * Check out [the Snapshot Testing guide](https://jestjs.io/docs/snapshot-testing) for more information.\n     */\n    toMatchSnapshot(hint?: string): R;\n    /**\n     * This ensures that a value matches the most recent snapshot.\n     * Check out [the Snapshot Testing guide](https://jestjs.io/docs/snapshot-testing) for more information.\n     */\n    toMatchSnapshot<U extends Record<keyof T, unknown>>(propertyMatchers: Partial<U>, hint?: string): R;\n    /**\n     * This ensures that a value matches the most recent snapshot with property matchers.\n     * Instead of writing the snapshot value to a .snap file, it will be written into the source code automatically.\n     * Check out [the Snapshot Testing guide](https://jestjs.io/docs/snapshot-testing) for more information.\n     */\n    toMatchInlineSnapshot(snapshot?: string): R;\n    /**\n     * This ensures that a value matches the most recent snapshot with property matchers.\n     * Instead of writing the snapshot value to a .snap file, it will be written into the source code automatically.\n     * Check out [the Snapshot Testing guide](https://jestjs.io/docs/snapshot-testing) for more information.\n     */\n    toMatchInlineSnapshot<U extends Record<keyof T, unknown>>(propertyMatchers: Partial<U>, snapshot?: string): R;\n    /**\n     * Used to test that a function throws a error matching the most recent snapshot when it is called.\n     */\n    toThrowErrorMatchingSnapshot(hint?: string): R;\n    /**\n     * Used to test that a function throws a error matching the most recent snapshot when it is called.\n     * Instead of writing the snapshot value to a .snap file, it will be written into the source code automatically.\n     */\n    toThrowErrorMatchingInlineSnapshot(snapshot?: string): R;\n}\nexport type SnapshotFormat = Omit<PrettyFormatOptions, 'compareKeys'>;\nexport type InlineSnapshot = {\n    snapshot: string;\n    frame: Frame;\n    node?: Expression;\n};\n",
  "packages/jest-snapshot/src/printSnapshot.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk from 'chalk';\nimport {getObjectSubset} from '@jest/expect-utils';\nimport {getType, isPrimitive} from '@jest/get-type';\nimport {\n  DIFF_DELETE,\n  DIFF_EQUAL,\n  DIFF_INSERT,\n  type Diff,\n  type DiffOptionsColor,\n  diffLinesUnified,\n  diffLinesUnified2,\n  diffStringsRaw,\n  diffStringsUnified,\n} from 'jest-diff';\nimport {\n  BOLD_WEIGHT,\n  EXPECTED_COLOR,\n  INVERTED_COLOR,\n  type MatcherHintOptions,\n  RECEIVED_COLOR,\n  getLabelPrinter,\n  matcherHint,\n  replaceMatchedToAsymmetricMatcher,\n} from 'jest-matcher-utils';\nimport {format as prettyFormat} from 'pretty-format';\nimport {\n  aBackground2,\n  aBackground3,\n  aForeground2,\n  aForeground3,\n  bBackground2,\n  bBackground3,\n  bForeground2,\n  bForeground3,\n} from './colors';\nimport {dedentLines} from './dedentLines';\nimport type {MatchSnapshotConfig, SnapshotFormat} from './types';\nimport {deserializeString, minify, serialize} from './utils';\n\ntype Chalk = chalk.Chalk;\n\nexport const getSnapshotColorForChalkInstance = (\n  chalkInstance: Chalk,\n): DiffOptionsColor => {\n  const level = chalkInstance.level;\n\n  if (level === 3) {\n    return chalkInstance\n      .rgb(aForeground3[0], aForeground3[1], aForeground3[2])\n      .bgRgb(aBackground3[0], aBackground3[1], aBackground3[2]);\n  }\n\n  if (level === 2) {\n    return chalkInstance.ansi256(aForeground2).bgAnsi256(aBackground2);\n  }\n\n  return chalkInstance.magenta.bgYellowBright;\n};\n\nexport const getReceivedColorForChalkInstance = (\n  chalkInstance: Chalk,\n): DiffOptionsColor => {\n  const level = chalkInstance.level;\n\n  if (level === 3) {\n    return chalkInstance\n      .rgb(bForeground3[0], bForeground3[1], bForeground3[2])\n      .bgRgb(bBackground3[0], bBackground3[1], bBackground3[2]);\n  }\n\n  if (level === 2) {\n    return chalkInstance.ansi256(bForeground2).bgAnsi256(bBackground2);\n  }\n\n  return chalkInstance.cyan.bgWhiteBright; // also known as teal\n};\n\nexport const aSnapshotColor = getSnapshotColorForChalkInstance(chalk);\nexport const bReceivedColor = getReceivedColorForChalkInstance(chalk);\n\nexport const noColor = (string: string): string => string;\n\nexport const HINT_ARG = 'hint';\nexport const SNAPSHOT_ARG = 'snapshot';\nexport const PROPERTIES_ARG = 'properties';\n\nexport const matcherHintFromConfig = (\n  {\n    context: {isNot, promise},\n    hint,\n    inlineSnapshot,\n    matcherName,\n    properties,\n  }: MatchSnapshotConfig,\n  isUpdatable: boolean,\n): string => {\n  const options: MatcherHintOptions = {isNot, promise};\n  if (isUpdatable) {\n    options.receivedColor = bReceivedColor;\n  }\n\n  let expectedArgument = '';\n\n  if (typeof properties === 'object') {\n    expectedArgument = PROPERTIES_ARG;\n    if (isUpdatable) {\n      options.expectedColor = noColor;\n    }\n\n    if (typeof hint === 'string' && hint.length > 0) {\n      options.secondArgument = HINT_ARG;\n      options.secondArgumentColor = BOLD_WEIGHT;\n    } else if (typeof inlineSnapshot === 'string') {\n      options.secondArgument = SNAPSHOT_ARG;\n      if (isUpdatable) {\n        options.secondArgumentColor = aSnapshotColor;\n      } else {\n        options.secondArgumentColor = noColor;\n      }\n    }\n  } else {\n    if (typeof hint === 'string' && hint.length > 0) {\n      expectedArgument = HINT_ARG;\n      options.expectedColor = BOLD_WEIGHT;\n    } else if (typeof inlineSnapshot === 'string') {\n      expectedArgument = SNAPSHOT_ARG;\n      if (isUpdatable) {\n        options.expectedColor = aSnapshotColor;\n      }\n    }\n  }\n\n  return matcherHint(matcherName, undefined, expectedArgument, options);\n};\n\n// Given array of diffs, return string:\n// * include common substrings\n// * exclude change substrings which have opposite op\n// * include change substrings which have argument op\n//   with change color only if there is a common substring\nconst joinDiffs = (\n  diffs: Array<Diff>,\n  op: number,\n  hasCommon: boolean,\n): string =>\n  diffs.reduce(\n    (reduced: string, diff: Diff): string =>\n      reduced +\n      (diff[0] === DIFF_EQUAL\n        ? diff[1]\n        : diff[0] === op\n          ? hasCommon\n            ? INVERTED_COLOR(diff[1])\n            : diff[1]\n          : ''),\n    '',\n  );\n\nconst isLineDiffable = (received: unknown): boolean => {\n  const receivedType = getType(received);\n\n  if (isPrimitive(received)) {\n    return typeof received === 'string';\n  }\n\n  if (\n    receivedType === 'date' ||\n    receivedType === 'function' ||\n    receivedType === 'regexp'\n  ) {\n    return false;\n  }\n\n  if (received instanceof Error) {\n    return false;\n  }\n\n  if (\n    receivedType === 'object' &&\n    typeof (received as any).asymmetricMatch === 'function'\n  ) {\n    return false;\n  }\n\n  return true;\n};\n\nexport const printExpected = (val: unknown): string =>\n  EXPECTED_COLOR(minify(val));\nexport const printReceived = (val: unknown): string =>\n  RECEIVED_COLOR(minify(val));\n\nexport const printPropertiesAndReceived = (\n  properties: object,\n  received: object,\n  expand: boolean, // CLI options: true if `--expand` or false if `--no-expand`\n): string => {\n  const aAnnotation = 'Expected properties';\n  const bAnnotation = 'Received value';\n\n  if (isLineDiffable(properties) && isLineDiffable(received)) {\n    const {replacedExpected, replacedReceived} =\n      replaceMatchedToAsymmetricMatcher(properties, received, [], []);\n    return diffLinesUnified(\n      serialize(replacedExpected).split('\\n'),\n      serialize(getObjectSubset(replacedReceived, replacedExpected)).split(\n        '\\n',\n      ),\n      {\n        aAnnotation,\n        aColor: EXPECTED_COLOR,\n        bAnnotation,\n        bColor: RECEIVED_COLOR,\n        changeLineTrailingSpaceColor: chalk.bgYellow,\n        commonLineTrailingSpaceColor: chalk.bgYellow,\n        emptyFirstOrLastLinePlaceholder: '↵', // U+21B5\n        expand,\n        includeChangeCounts: true,\n      },\n    );\n  }\n\n  const printLabel = getLabelPrinter(aAnnotation, bAnnotation);\n  return `${printLabel(aAnnotation) + printExpected(properties)}\\n${printLabel(\n    bAnnotation,\n  )}${printReceived(received)}`;\n};\n\nconst MAX_DIFF_STRING_LENGTH = 20_000;\n\nexport const printSnapshotAndReceived = (\n  a: string, // snapshot without extra line breaks\n  b: string, // received serialized but without extra line breaks\n  received: unknown,\n  expand: boolean, // CLI options: true if `--expand` or false if `--no-expand`\n  snapshotFormat?: SnapshotFormat,\n): string => {\n  const aAnnotation = 'Snapshot';\n  const bAnnotation = 'Received';\n  const aColor = aSnapshotColor;\n  const bColor = bReceivedColor;\n  const options = {\n    aAnnotation,\n    aColor,\n    bAnnotation,\n    bColor,\n    changeLineTrailingSpaceColor: noColor,\n    commonLineTrailingSpaceColor: chalk.bgYellow,\n    emptyFirstOrLastLinePlaceholder: '↵', // U+21B5\n    expand,\n    includeChangeCounts: true,\n  };\n\n  if (typeof received === 'string') {\n    if (\n      a.length >= 2 &&\n      a.startsWith('\"') &&\n      a.endsWith('\"') &&\n      b === prettyFormat(received)\n    ) {\n      // If snapshot looks like default serialization of a string\n      // and received is string which has default serialization.\n\n      if (!a.includes('\\n') && !b.includes('\\n')) {\n        // If neither string is multiline,\n        // display as labels and quoted strings.\n        let aQuoted = a;\n        let bQuoted = b;\n\n        if (\n          a.length - 2 <= MAX_DIFF_STRING_LENGTH &&\n          b.length - 2 <= MAX_DIFF_STRING_LENGTH\n        ) {\n          const diffs = diffStringsRaw(a.slice(1, -1), b.slice(1, -1), true);\n          const hasCommon = diffs.some(diff => diff[0] === DIFF_EQUAL);\n          aQuoted = `\"${joinDiffs(diffs, DIFF_DELETE, hasCommon)}\"`;\n          bQuoted = `\"${joinDiffs(diffs, DIFF_INSERT, hasCommon)}\"`;\n        }\n\n        const printLabel = getLabelPrinter(aAnnotation, bAnnotation);\n        return `${printLabel(aAnnotation) + aColor(aQuoted)}\\n${printLabel(\n          bAnnotation,\n        )}${bColor(bQuoted)}`;\n      }\n\n      // Else either string is multiline, so display as unquoted strings.\n      a = deserializeString(a); //  hypothetical expected string\n      b = received; // not serialized\n    }\n    // Else expected had custom serialization or was not a string\n    // or received has custom serialization.\n\n    return a.length <= MAX_DIFF_STRING_LENGTH &&\n      b.length <= MAX_DIFF_STRING_LENGTH\n      ? diffStringsUnified(a, b, options)\n      : diffLinesUnified(a.split('\\n'), b.split('\\n'), options);\n  }\n\n  if (isLineDiffable(received)) {\n    const aLines2 = a.split('\\n');\n    const bLines2 = b.split('\\n');\n\n    // Fall through to fix a regression for custom serializers\n    // like jest-snapshot-serializer-raw that ignore the indent option.\n    const b0 = serialize(received, 0, snapshotFormat);\n    if (b0 !== b) {\n      const aLines0 = dedentLines(aLines2);\n\n      if (aLines0 !== null) {\n        // Compare lines without indentation.\n        const bLines0 = b0.split('\\n');\n\n        return diffLinesUnified2(aLines2, bLines2, aLines0, bLines0, options);\n      }\n    }\n\n    // Fall back because:\n    // * props include a multiline string\n    // * text has more than one adjacent line\n    // * markup does not close\n    return diffLinesUnified(aLines2, bLines2, options);\n  }\n\n  const printLabel = getLabelPrinter(aAnnotation, bAnnotation);\n  return `${printLabel(aAnnotation) + aColor(a)}\\n${printLabel(\n    bAnnotation,\n  )}${bColor(b)}`;\n};\n",
  "packages/jest-snapshot/src/printSnapshot.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { type DiffOptionsColor } from 'jest-diff';\nimport type { MatchSnapshotConfig, SnapshotFormat } from './types';\ntype Chalk = chalk.Chalk;\nexport declare const getSnapshotColorForChalkInstance: (chalkInstance: Chalk) => DiffOptionsColor;\nexport declare const getReceivedColorForChalkInstance: (chalkInstance: Chalk) => DiffOptionsColor;\nexport declare const aSnapshotColor: DiffOptionsColor;\nexport declare const bReceivedColor: DiffOptionsColor;\nexport declare const noColor: (string: string) => string;\nexport declare const HINT_ARG = \"hint\";\nexport declare const SNAPSHOT_ARG = \"snapshot\";\nexport declare const PROPERTIES_ARG = \"properties\";\nexport declare const matcherHintFromConfig: ({ context: { isNot, promise }, hint, inlineSnapshot, matcherName, properties, }: MatchSnapshotConfig, isUpdatable: boolean) => string;\nexport declare const printExpected: (val: unknown) => string;\nexport declare const printReceived: (val: unknown) => string;\nexport declare const printPropertiesAndReceived: (properties: object, received: object, expand: boolean) => string;\nexport declare const printSnapshotAndReceived: (a: string, // snapshot without extra line breaks\nb: string, // received serialized but without extra line breaks\nreceived: unknown, expand: boolean, // CLI options: true if `--expand` or false if `--no-expand`\nsnapshotFormat?: SnapshotFormat) => string;\nexport {};\n",
  "packages/jest-snapshot/src/plugins.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {\n  type Plugin as PrettyFormatPlugin,\n  type Plugins as PrettyFormatPlugins,\n  plugins as prettyFormatPlugins,\n} from 'pretty-format';\nimport jestMockSerializer from './mockSerializer';\n\nconst {\n  DOMCollection,\n  DOMElement,\n  Immutable,\n  ReactElement,\n  ReactTestComponent,\n  AsymmetricMatcher,\n} = prettyFormatPlugins;\n\nlet PLUGINS: PrettyFormatPlugins = [\n  ReactTestComponent,\n  ReactElement,\n  DOMElement,\n  DOMCollection,\n  Immutable,\n  jestMockSerializer,\n  AsymmetricMatcher,\n];\n\n// Prepend to list so the last added is the first tested.\nexport const addSerializer = (plugin: PrettyFormatPlugin): void => {\n  PLUGINS = [plugin, ...PLUGINS];\n};\n\nexport const getSerializers = (): PrettyFormatPlugins => PLUGINS;\n",
  "packages/jest-snapshot/src/plugins.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { type Plugin as PrettyFormatPlugin, type Plugins as PrettyFormatPlugins } from 'pretty-format';\nexport declare const addSerializer: (plugin: PrettyFormatPlugin) => void;\nexport declare const getSerializers: () => PrettyFormatPlugins;\n",
  "packages/jest-snapshot/src/mockSerializer.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {NewPlugin} from 'pretty-format';\n\nexport const serialize: NewPlugin['serialize'] = (\n  val,\n  config,\n  indentation,\n  depth,\n  refs,\n  printer,\n): string => {\n  // Serialize a non-default name, even if config.printFunctionName is false.\n  const name = val.getMockName();\n  const nameString = name === 'jest.fn()' ? '' : ` ${name}`;\n\n  let callsString = '';\n  if (val.mock.calls.length > 0) {\n    const indentationNext = indentation + config.indent;\n    callsString = ` {${config.spacingOuter}${indentationNext}\"calls\": ${printer(\n      val.mock.calls,\n      config,\n      indentationNext,\n      depth,\n      refs,\n    )}${config.min ? ', ' : ','}${\n      config.spacingOuter\n    }${indentationNext}\"results\": ${printer(\n      val.mock.results,\n      config,\n      indentationNext,\n      depth,\n      refs,\n    )}${config.min ? '' : ','}${config.spacingOuter}${indentation}}`;\n  }\n\n  return `[MockFunction${nameString}]${callsString}`;\n};\n\nexport const test: NewPlugin['test'] = val => val && !!val._isMockFunction;\n\nconst plugin: NewPlugin = {serialize, test};\n\nexport default plugin;\n",
  "packages/jest-snapshot/src/mockSerializer.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { NewPlugin } from 'pretty-format';\nexport declare const serialize: NewPlugin['serialize'];\nexport declare const test: NewPlugin['test'];\ndeclare const plugin: NewPlugin;\nexport default plugin;\n",
  "packages/jest-snapshot/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {types} from 'util';\nimport * as fs from 'graceful-fs';\nimport {escapeBacktickString} from '@jest/snapshot-utils';\nimport type {Config} from '@jest/types';\nimport type {MatcherFunctionWithContext} from 'expect';\nimport {\n  BOLD_WEIGHT,\n  EXPECTED_COLOR,\n  type MatcherHintOptions,\n  RECEIVED_COLOR,\n  matcherErrorMessage,\n  matcherHint,\n  printWithType,\n  stringify,\n} from 'jest-matcher-utils';\nimport {EXTENSION, type SnapshotResolver} from './SnapshotResolver';\nimport {\n  PROPERTIES_ARG,\n  SNAPSHOT_ARG,\n  bReceivedColor,\n  matcherHintFromConfig,\n  noColor,\n  printExpected,\n  printPropertiesAndReceived,\n  printReceived,\n  printSnapshotAndReceived,\n} from './printSnapshot';\nimport type {Context, FileSystem, MatchSnapshotConfig} from './types';\nimport {deepMerge, serialize} from './utils';\n\nexport {addSerializer, getSerializers} from './plugins';\nexport {\n  EXTENSION,\n  buildSnapshotResolver,\n  isSnapshotPath,\n} from './SnapshotResolver';\nexport type {SnapshotResolver} from './SnapshotResolver';\nexport {default as SnapshotState} from './State';\nexport type {Context, SnapshotMatchers} from './types';\n\nconst DID_NOT_THROW = 'Received function did not throw'; // same as toThrow\nconst NOT_SNAPSHOT_MATCHERS = `Snapshot matchers cannot be used with ${BOLD_WEIGHT(\n  'not',\n)}`;\n\nconst INDENTATION_REGEX = /^([^\\S\\n]*)\\S/m;\n\n// Display name in report when matcher fails same as in snapshot file,\n// but with optional hint argument in bold weight.\nconst printSnapshotName = (\n  concatenatedBlockNames = '',\n  hint = '',\n  count: number,\n): string => {\n  const hasNames = concatenatedBlockNames.length > 0;\n  const hasHint = hint.length > 0;\n\n  return `Snapshot name: \\`${\n    hasNames ? escapeBacktickString(concatenatedBlockNames) : ''\n  }${hasNames && hasHint ? ': ' : ''}${\n    hasHint ? BOLD_WEIGHT(escapeBacktickString(hint)) : ''\n  } ${count}\\``;\n};\n\nfunction stripAddedIndentation(inlineSnapshot: string) {\n  // Find indentation if exists.\n  const match = inlineSnapshot.match(INDENTATION_REGEX);\n  if (!match || !match[1]) {\n    // No indentation.\n    return inlineSnapshot;\n  }\n\n  const indentation = match[1];\n  const lines = inlineSnapshot.split('\\n');\n  if (lines.length <= 2) {\n    // Must be at least 3 lines.\n    return inlineSnapshot;\n  }\n\n  if (lines[0].trim() !== '' || lines.at(-1)!.trim() !== '') {\n    // If not blank first and last lines, abort.\n    return inlineSnapshot;\n  }\n\n  for (let i = 1; i < lines.length - 1; i++) {\n    if (lines[i] !== '') {\n      if (lines[i].indexOf(indentation) !== 0) {\n        // All lines except first and last should either be blank or have the same\n        // indent as the first line (or more). If this isn't the case we don't\n        // want to touch the snapshot at all.\n        return inlineSnapshot;\n      }\n\n      lines[i] = lines[i].slice(indentation.length);\n    }\n  }\n\n  // Last line is a special case because it won't have the same indent as others\n  // but may still have been given some indent to line up.\n  lines[lines.length - 1] = '';\n\n  // Return inline snapshot, now at indent 0.\n  inlineSnapshot = lines.join('\\n');\n  return inlineSnapshot;\n}\n\nconst fileExists = (filePath: string, fileSystem: FileSystem): boolean =>\n  fileSystem.exists(filePath) || fs.existsSync(filePath);\n\nexport const cleanup = (\n  fileSystem: FileSystem,\n  update: Config.SnapshotUpdateState,\n  snapshotResolver: SnapshotResolver,\n  testPathIgnorePatterns?: Config.ProjectConfig['testPathIgnorePatterns'],\n): {\n  filesRemoved: number;\n  filesRemovedList: Array<string>;\n} => {\n  const pattern = `\\\\.${EXTENSION}$`;\n  const files = fileSystem.matchFiles(pattern);\n  let testIgnorePatternsRegex: RegExp | null = null;\n  if (testPathIgnorePatterns && testPathIgnorePatterns.length > 0) {\n    testIgnorePatternsRegex = new RegExp(testPathIgnorePatterns.join('|'));\n  }\n\n  const list = files.filter(snapshotFile => {\n    const testPath = snapshotResolver.resolveTestPath(snapshotFile);\n\n    // ignore snapshots of ignored tests\n    if (testIgnorePatternsRegex && testIgnorePatternsRegex.test(testPath)) {\n      return false;\n    }\n\n    if (!fileExists(testPath, fileSystem)) {\n      if (update === 'all') {\n        fs.unlinkSync(snapshotFile);\n      }\n      return true;\n    }\n\n    return false;\n  });\n\n  return {\n    filesRemoved: list.length,\n    filesRemovedList: list,\n  };\n};\n\nexport const toMatchSnapshot: MatcherFunctionWithContext<\n  Context,\n  [propertiesOrHint?: object | string, hint?: string]\n> = function (received, propertiesOrHint, hint) {\n  const matcherName = 'toMatchSnapshot';\n  let properties;\n\n  const length = arguments.length;\n  if (length === 2 && typeof propertiesOrHint === 'string') {\n    hint = propertiesOrHint;\n  } else if (length >= 2) {\n    if (typeof propertiesOrHint !== 'object' || propertiesOrHint === null) {\n      const options: MatcherHintOptions = {\n        isNot: this.isNot,\n        promise: this.promise,\n      };\n      let printedWithType = printWithType(\n        'Expected properties',\n        propertiesOrHint,\n        printExpected,\n      );\n\n      if (length === 3) {\n        options.secondArgument = 'hint';\n        options.secondArgumentColor = BOLD_WEIGHT;\n\n        if (propertiesOrHint == null) {\n          printedWithType +=\n            \"\\n\\nTo provide a hint without properties: toMatchSnapshot('hint')\";\n        }\n      }\n\n      throw new Error(\n        matcherErrorMessage(\n          matcherHint(matcherName, undefined, PROPERTIES_ARG, options),\n          `Expected ${EXPECTED_COLOR('properties')} must be an object`,\n          printedWithType,\n        ),\n      );\n    }\n\n    // Future breaking change: Snapshot hint must be a string\n    // if (arguments.length === 3 && typeof hint !== 'string') {}\n\n    properties = propertiesOrHint;\n  }\n\n  return _toMatchSnapshot({\n    context: this,\n    hint,\n    isInline: false,\n    matcherName,\n    properties,\n    received,\n  });\n};\n\nexport const toMatchInlineSnapshot: MatcherFunctionWithContext<\n  Context,\n  [propertiesOrSnapshot?: object | string, inlineSnapshot?: string]\n> = function (received, propertiesOrSnapshot, inlineSnapshot) {\n  const matcherName = 'toMatchInlineSnapshot';\n  let properties;\n\n  const length = arguments.length;\n  if (length === 2 && typeof propertiesOrSnapshot === 'string') {\n    inlineSnapshot = propertiesOrSnapshot;\n  } else if (length >= 2) {\n    const options: MatcherHintOptions = {\n      isNot: this.isNot,\n      promise: this.promise,\n    };\n    if (length === 3) {\n      options.secondArgument = SNAPSHOT_ARG;\n      options.secondArgumentColor = noColor;\n    }\n\n    if (\n      typeof propertiesOrSnapshot !== 'object' ||\n      propertiesOrSnapshot === null\n    ) {\n      throw new Error(\n        matcherErrorMessage(\n          matcherHint(matcherName, undefined, PROPERTIES_ARG, options),\n          `Expected ${EXPECTED_COLOR('properties')} must be an object`,\n          printWithType(\n            'Expected properties',\n            propertiesOrSnapshot,\n            printExpected,\n          ),\n        ),\n      );\n    }\n\n    if (length === 3 && typeof inlineSnapshot !== 'string') {\n      throw new Error(\n        matcherErrorMessage(\n          matcherHint(matcherName, undefined, PROPERTIES_ARG, options),\n          'Inline snapshot must be a string',\n          printWithType('Inline snapshot', inlineSnapshot, serialize),\n        ),\n      );\n    }\n\n    properties = propertiesOrSnapshot;\n  }\n\n  return _toMatchSnapshot({\n    context: this,\n    inlineSnapshot:\n      inlineSnapshot === undefined\n        ? undefined\n        : stripAddedIndentation(inlineSnapshot),\n    isInline: true,\n    matcherName,\n    properties,\n    received,\n  });\n};\n\nconst _toMatchSnapshot = (config: MatchSnapshotConfig) => {\n  const {context, hint, inlineSnapshot, isInline, matcherName, properties} =\n    config;\n  let {received} = config;\n\n  /** If a test was ran with `test.failing`. Passed by Jest Circus. */\n  const {testFailing = false} = context;\n\n  if (!testFailing && context.dontThrow) {\n    // Suppress errors while running tests\n    context.dontThrow();\n  }\n\n  const {currentConcurrentTestName, isNot, snapshotState} = context;\n  const currentTestName =\n    currentConcurrentTestName?.() ?? context.currentTestName;\n\n  if (isNot) {\n    throw new Error(\n      matcherErrorMessage(\n        matcherHintFromConfig(config, false),\n        NOT_SNAPSHOT_MATCHERS,\n      ),\n    );\n  }\n\n  if (snapshotState == null) {\n    // Because the state is the problem, this is not a matcher error.\n    // Call generic stringify from jest-matcher-utils package\n    // because uninitialized snapshot state does not need snapshot serializers.\n    throw new Error(\n      `${matcherHintFromConfig(config, false)}\\n\\n` +\n        'Snapshot state must be initialized' +\n        `\\n\\n${printWithType('Snapshot state', snapshotState, stringify)}`,\n    );\n  }\n\n  const fullTestName =\n    currentTestName && hint\n      ? `${currentTestName}: ${hint}`\n      : currentTestName || ''; // future BREAKING change: || hint\n\n  if (typeof properties === 'object') {\n    if (typeof received !== 'object' || received === null) {\n      throw new Error(\n        matcherErrorMessage(\n          matcherHintFromConfig(config, false),\n          `${RECEIVED_COLOR(\n            'received',\n          )} value must be an object when the matcher has ${EXPECTED_COLOR(\n            'properties',\n          )}`,\n          printWithType('Received', received, printReceived),\n        ),\n      );\n    }\n\n    const propertyPass = context.equals(received, properties, [\n      context.utils.iterableEquality,\n      context.utils.subsetEquality,\n    ]);\n\n    if (propertyPass) {\n      received = deepMerge(received, properties);\n    } else {\n      const key = snapshotState.fail(fullTestName, received);\n      const matched = /(\\d+)$/.exec(key);\n      const count = matched === null ? 1 : Number(matched[1]);\n\n      const message = () =>\n        `${matcherHintFromConfig(config, false)}\\n\\n${printSnapshotName(\n          currentTestName,\n          hint,\n          count,\n        )}\\n\\n${printPropertiesAndReceived(\n          properties,\n          received,\n          snapshotState.expand,\n        )}`;\n\n      return {\n        message,\n        name: matcherName,\n        pass: false,\n      };\n    }\n  }\n\n  const result = snapshotState.match({\n    error: context.error,\n    inlineSnapshot,\n    isInline,\n    received,\n    testFailing,\n    testName: fullTestName,\n  });\n  const {actual, count, expected, pass} = result;\n\n  if (pass) {\n    return {message: () => '', pass: true};\n  }\n\n  const message =\n    expected === undefined\n      ? () =>\n          `${matcherHintFromConfig(config, true)}\\n\\n${printSnapshotName(\n            currentTestName,\n            hint,\n            count,\n          )}\\n\\n` +\n          `New snapshot was ${BOLD_WEIGHT('not written')}. The update flag ` +\n          'must be explicitly passed to write a new snapshot.\\n\\n' +\n          'This is likely because this test is run in a continuous integration ' +\n          '(CI) environment in which snapshots are not written by default.\\n\\n' +\n          `Received:${actual.includes('\\n') ? '\\n' : ' '}${bReceivedColor(\n            actual,\n          )}`\n      : () =>\n          `${matcherHintFromConfig(config, true)}\\n\\n${printSnapshotName(\n            currentTestName,\n            hint,\n            count,\n          )}\\n\\n${printSnapshotAndReceived(\n            expected,\n            actual,\n            received,\n            snapshotState.expand,\n            snapshotState.snapshotFormat,\n          )}`;\n\n  // Passing the actual and expected objects so that a custom reporter\n  // could access them, for example in order to display a custom visual diff,\n  // or create a different error message\n  return {\n    actual,\n    expected,\n    message,\n    name: matcherName,\n    pass: false,\n  };\n};\n\nexport const toThrowErrorMatchingSnapshot: MatcherFunctionWithContext<\n  Context,\n  [hint?: string, fromPromise?: boolean]\n> = function (received, hint, fromPromise) {\n  const matcherName = 'toThrowErrorMatchingSnapshot';\n\n  // Future breaking change: Snapshot hint must be a string\n  // if (hint !== undefined && typeof hint !== string) {}\n\n  return _toThrowErrorMatchingSnapshot(\n    {\n      context: this,\n      hint,\n      isInline: false,\n      matcherName,\n      received,\n    },\n    fromPromise,\n  );\n};\n\nexport const toThrowErrorMatchingInlineSnapshot: MatcherFunctionWithContext<\n  Context,\n  [inlineSnapshot?: string, fromPromise?: boolean]\n> = function (received, inlineSnapshot, fromPromise) {\n  const matcherName = 'toThrowErrorMatchingInlineSnapshot';\n\n  if (inlineSnapshot !== undefined && typeof inlineSnapshot !== 'string') {\n    const options: MatcherHintOptions = {\n      expectedColor: noColor,\n      isNot: this.isNot,\n      promise: this.promise,\n    };\n\n    throw new Error(\n      matcherErrorMessage(\n        matcherHint(matcherName, undefined, SNAPSHOT_ARG, options),\n        'Inline snapshot must be a string',\n        printWithType('Inline snapshot', inlineSnapshot, serialize),\n      ),\n    );\n  }\n\n  return _toThrowErrorMatchingSnapshot(\n    {\n      context: this,\n      inlineSnapshot:\n        inlineSnapshot === undefined\n          ? undefined\n          : stripAddedIndentation(inlineSnapshot),\n      isInline: true,\n      matcherName,\n      received,\n    },\n    fromPromise,\n  );\n};\n\nconst _toThrowErrorMatchingSnapshot = (\n  config: MatchSnapshotConfig,\n  fromPromise?: boolean,\n) => {\n  const {context, hint, inlineSnapshot, isInline, matcherName, received} =\n    config;\n\n  context.dontThrow?.();\n\n  const {isNot, promise} = context;\n\n  if (!fromPromise) {\n    if (typeof received !== 'function') {\n      const options: MatcherHintOptions = {isNot, promise};\n\n      throw new Error(\n        matcherErrorMessage(\n          matcherHint(matcherName, undefined, '', options),\n          `${RECEIVED_COLOR('received')} value must be a function`,\n          printWithType('Received', received, printReceived),\n        ),\n      );\n    }\n  }\n\n  if (isNot) {\n    throw new Error(\n      matcherErrorMessage(\n        matcherHintFromConfig(config, false),\n        NOT_SNAPSHOT_MATCHERS,\n      ),\n    );\n  }\n\n  let error;\n\n  if (fromPromise) {\n    error = received;\n  } else {\n    try {\n      received();\n    } catch (receivedError) {\n      error = receivedError;\n    }\n  }\n\n  if (error === undefined) {\n    // Because the received value is a function, this is not a matcher error.\n    throw new Error(\n      `${matcherHintFromConfig(config, false)}\\n\\n${DID_NOT_THROW}`,\n    );\n  }\n\n  let message = error.message;\n  while ('cause' in error) {\n    error = error.cause;\n    if (types.isNativeError(error) || error instanceof Error) {\n      message += `\\nCause: ${error.message}`;\n    } else {\n      if (typeof error === 'string') {\n        message += `\\nCause: ${error}`;\n      }\n      break;\n    }\n  }\n\n  return _toMatchSnapshot({\n    context,\n    hint,\n    inlineSnapshot,\n    isInline,\n    matcherName,\n    received: message,\n  });\n};\n",
  "packages/jest-snapshot/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config } from '@jest/types';\nimport type { MatcherFunctionWithContext } from 'expect';\nimport { type SnapshotResolver } from './SnapshotResolver';\nimport type { Context, FileSystem } from './types';\nexport { addSerializer, getSerializers } from './plugins';\nexport { EXTENSION, buildSnapshotResolver, isSnapshotPath, } from './SnapshotResolver';\nexport type { SnapshotResolver } from './SnapshotResolver';\nexport { default as SnapshotState } from './State';\nexport type { Context, SnapshotMatchers } from './types';\nexport declare const cleanup: (fileSystem: FileSystem, update: Config.SnapshotUpdateState, snapshotResolver: SnapshotResolver, testPathIgnorePatterns?: Config.ProjectConfig[\"testPathIgnorePatterns\"]) => {\n    filesRemoved: number;\n    filesRemovedList: Array<string>;\n};\nexport declare const toMatchSnapshot: MatcherFunctionWithContext<Context, [\n    propertiesOrHint?: object | string,\n    hint?: string\n]>;\nexport declare const toMatchInlineSnapshot: MatcherFunctionWithContext<Context, [\n    propertiesOrSnapshot?: object | string,\n    inlineSnapshot?: string\n]>;\nexport declare const toThrowErrorMatchingSnapshot: MatcherFunctionWithContext<Context, [\n    hint?: string,\n    fromPromise?: boolean\n]>;\nexport declare const toThrowErrorMatchingInlineSnapshot: MatcherFunctionWithContext<Context, [\n    inlineSnapshot?: string,\n    fromPromise?: boolean\n]>;\n",
  "packages/jest-snapshot/src/dedentLines.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst getIndentationLength = (line: string): number => {\n  const result = /^( {2})+/.exec(line);\n  return result === null ? 0 : result[0].length;\n};\n\nconst dedentLine = (line: string): string =>\n  line.slice(getIndentationLength(line));\n\n// Return true if:\n// \"key\": \"value has multiple lines\\n…\n// \"key has multiple lines\\n…\nconst hasUnmatchedDoubleQuoteMarks = (string: string): boolean => {\n  let n = 0;\n\n  let i = string.indexOf('\"', 0);\n  while (i !== -1) {\n    if (i === 0 || string[i - 1] !== '\\\\') {\n      n += 1;\n    }\n\n    i = string.indexOf('\"', i + 1);\n  }\n\n  return n % 2 !== 0;\n};\n\nconst isFirstLineOfTag = (line: string) => /^( {2})*</.test(line);\n\n// The length of the output array is the index of the next input line.\n\n// Push dedented lines of start tag onto output and return true;\n// otherwise return false because:\n// * props include a multiline string (or text node, if props have markup)\n// * start tag does not close\nconst dedentStartTag = (\n  input: Array<string>,\n  output: Array<string>,\n): boolean => {\n  let line = input[output.length];\n  output.push(dedentLine(line));\n\n  if (line.includes('>')) {\n    return true;\n  }\n\n  while (output.length < input.length) {\n    line = input[output.length];\n\n    if (hasUnmatchedDoubleQuoteMarks(line)) {\n      return false; // because props include a multiline string\n    } else if (isFirstLineOfTag(line)) {\n      // Recursion only if props have markup.\n      if (!dedentMarkup(input, output)) {\n        return false;\n      }\n    } else {\n      output.push(dedentLine(line));\n\n      if (line.includes('>')) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\n// Push dedented lines of markup onto output and return true;\n// otherwise return false because:\n// * props include a multiline string\n// * text has more than one adjacent line\n// * markup does not close\nconst dedentMarkup = (input: Array<string>, output: Array<string>): boolean => {\n  let line = input[output.length];\n\n  if (!dedentStartTag(input, output)) {\n    return false;\n  }\n\n  if (input[output.length - 1].includes('/>')) {\n    return true;\n  }\n\n  let isText = false;\n  const stack: Array<number> = [];\n  stack.push(getIndentationLength(line));\n\n  while (stack.length > 0 && output.length < input.length) {\n    line = input[output.length];\n\n    if (isFirstLineOfTag(line)) {\n      if (line.includes('</')) {\n        output.push(dedentLine(line));\n        stack.pop();\n      } else {\n        if (!dedentStartTag(input, output)) {\n          return false;\n        }\n\n        if (!input[output.length - 1].includes('/>')) {\n          stack.push(getIndentationLength(line));\n        }\n      }\n      isText = false;\n    } else {\n      if (isText) {\n        return false; // because text has more than one adjacent line\n      }\n\n      const indentationLengthOfTag = stack.at(-1)!;\n      output.push(line.slice(indentationLengthOfTag + 2));\n      isText = true;\n    }\n  }\n\n  return stack.length === 0;\n};\n\n// Return lines unindented by heuristic;\n// otherwise return null because:\n// * props include a multiline string\n// * text has more than one adjacent line\n// * markup does not close\nexport const dedentLines = (input: Array<string>): Array<string> | null => {\n  const output: Array<string> = [];\n\n  while (output.length < input.length) {\n    const line = input[output.length];\n\n    if (hasUnmatchedDoubleQuoteMarks(line)) {\n      return null;\n    } else if (isFirstLineOfTag(line)) {\n      if (!dedentMarkup(input, output)) {\n        return null;\n      }\n    } else {\n      output.push(dedentLine(line));\n    }\n  }\n\n  return output;\n};\n",
  "packages/jest-snapshot/src/dedentLines.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport declare const dedentLines: (input: Array<string>) => Array<string> | null;\n",
  "packages/jest-snapshot/src/colors.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// https://jonasjacek.github.io/colors/\n\nexport const aForeground2 = 90;\nexport const aBackground2 = 225;\n\nexport const bForeground2 = 23;\nexport const bBackground2 = 195;\n\nexport type RGB = [number, number, number];\n\nexport const aForeground3: RGB = [0x80, 0, 0x80];\nexport const aBackground3: RGB = [0xff, 0xd7, 0xff];\n\nexport const bForeground3: RGB = [0, 0x5f, 0x5f];\nexport const bBackground3: RGB = [0xd7, 0xff, 0xff];\n",
  "packages/jest-snapshot/src/colors.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport declare const aForeground2 = 90;\nexport declare const aBackground2 = 225;\nexport declare const bForeground2 = 23;\nexport declare const bBackground2 = 195;\nexport type RGB = [number, number, number];\nexport declare const aForeground3: RGB;\nexport declare const aBackground3: RGB;\nexport declare const bForeground3: RGB;\nexport declare const bBackground3: RGB;\n",
  "packages/jest-snapshot/src/State.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as fs from 'graceful-fs';\nimport {\n  type SnapshotData,\n  getSnapshotData,\n  keyToTestName,\n  saveSnapshotFile,\n  testNameToKey,\n} from '@jest/snapshot-utils';\nimport type {Config} from '@jest/types';\nimport {getStackTraceLines, getTopFrame} from 'jest-message-util';\nimport {saveInlineSnapshots} from './InlineSnapshots';\nimport type {InlineSnapshot, SnapshotFormat} from './types';\nimport {\n  addExtraLineBreaks,\n  removeExtraLineBreaks,\n  removeLinesBeforeExternalMatcherTrap,\n  serialize,\n} from './utils';\nexport type SnapshotStateOptions = {\n  readonly updateSnapshot: Config.SnapshotUpdateState;\n  readonly prettierPath?: string | null;\n  readonly expand?: boolean;\n  readonly snapshotFormat: SnapshotFormat;\n  readonly rootDir: string;\n};\n\nexport type SnapshotMatchOptions = {\n  readonly testName: string;\n  readonly received: unknown;\n  readonly key?: string;\n  readonly inlineSnapshot?: string;\n  readonly isInline: boolean;\n  readonly error?: Error;\n  readonly testFailing?: boolean;\n};\n\ntype SnapshotReturnOptions = {\n  readonly actual: string;\n  readonly count: number;\n  readonly expected?: string;\n  readonly key: string;\n  readonly pass: boolean;\n};\n\ntype SaveStatus = {\n  deleted: boolean;\n  saved: boolean;\n};\n\nexport default class SnapshotState {\n  private _counters: Map<string, number>;\n  private _dirty: boolean;\n  // @ts-expect-error - seemingly unused?\n  private _index: number;\n  private readonly _updateSnapshot: Config.SnapshotUpdateState;\n  private _snapshotData: SnapshotData;\n  private readonly _initialData: SnapshotData;\n  private readonly _snapshotPath: string;\n  private _inlineSnapshots: Array<InlineSnapshot>;\n  private readonly _uncheckedKeys: Set<string>;\n  private readonly _prettierPath: string | null;\n  private readonly _rootDir: string;\n\n  readonly snapshotFormat: SnapshotFormat;\n\n  added: number;\n  expand: boolean;\n  matched: number;\n  unmatched: number;\n  updated: number;\n\n  constructor(snapshotPath: string, options: SnapshotStateOptions) {\n    this._snapshotPath = snapshotPath;\n    const {data, dirty} = getSnapshotData(\n      this._snapshotPath,\n      options.updateSnapshot,\n    );\n    this._initialData = data;\n    this._snapshotData = data;\n    this._dirty = dirty;\n    this._prettierPath = options.prettierPath ?? null;\n    this._inlineSnapshots = [];\n    this._uncheckedKeys = new Set(Object.keys(this._snapshotData));\n    this._counters = new Map();\n    this._index = 0;\n    this.expand = options.expand || false;\n    this.added = 0;\n    this.matched = 0;\n    this.unmatched = 0;\n    this._updateSnapshot = options.updateSnapshot;\n    this.updated = 0;\n    this.snapshotFormat = options.snapshotFormat;\n    this._rootDir = options.rootDir;\n  }\n\n  markSnapshotsAsCheckedForTest(testName: string): void {\n    for (const uncheckedKey of this._uncheckedKeys) {\n      if (keyToTestName(uncheckedKey) === testName) {\n        this._uncheckedKeys.delete(uncheckedKey);\n      }\n    }\n  }\n\n  private _addSnapshot(\n    key: string,\n    receivedSerialized: string,\n    options: {isInline: boolean; error?: Error},\n  ): void {\n    this._dirty = true;\n    if (options.isInline) {\n      // eslint-disable-next-line unicorn/error-message\n      const error = options.error || new Error();\n      const lines = getStackTraceLines(\n        removeLinesBeforeExternalMatcherTrap(error.stack || ''),\n      );\n      const frame = getTopFrame(lines);\n      if (!frame) {\n        throw new Error(\n          \"Jest: Couldn't infer stack frame for inline snapshot.\",\n        );\n      }\n      this._inlineSnapshots.push({\n        frame,\n        snapshot: receivedSerialized,\n      });\n    } else {\n      this._snapshotData[key] = receivedSerialized;\n    }\n  }\n\n  clear(): void {\n    this._snapshotData = this._initialData;\n    this._inlineSnapshots = [];\n    this._counters = new Map();\n    this._index = 0;\n    this.added = 0;\n    this.matched = 0;\n    this.unmatched = 0;\n    this.updated = 0;\n  }\n\n  save(): SaveStatus {\n    const hasExternalSnapshots = Object.keys(this._snapshotData).length;\n    const hasInlineSnapshots = this._inlineSnapshots.length;\n    const isEmpty = !hasExternalSnapshots && !hasInlineSnapshots;\n\n    const status: SaveStatus = {\n      deleted: false,\n      saved: false,\n    };\n\n    if ((this._dirty || this._uncheckedKeys.size > 0) && !isEmpty) {\n      if (hasExternalSnapshots) {\n        saveSnapshotFile(this._snapshotData, this._snapshotPath);\n      }\n      if (hasInlineSnapshots) {\n        saveInlineSnapshots(\n          this._inlineSnapshots,\n          this._rootDir,\n          this._prettierPath,\n        );\n      }\n      status.saved = true;\n    } else if (!hasExternalSnapshots && fs.existsSync(this._snapshotPath)) {\n      if (this._updateSnapshot === 'all') {\n        fs.unlinkSync(this._snapshotPath);\n      }\n      status.deleted = true;\n    }\n\n    return status;\n  }\n\n  getUncheckedCount(): number {\n    return this._uncheckedKeys.size || 0;\n  }\n\n  getUncheckedKeys(): Array<string> {\n    return [...this._uncheckedKeys];\n  }\n\n  removeUncheckedKeys(): void {\n    if (this._updateSnapshot === 'all' && this._uncheckedKeys.size > 0) {\n      this._dirty = true;\n      for (const key of this._uncheckedKeys) delete this._snapshotData[key];\n      this._uncheckedKeys.clear();\n    }\n  }\n\n  match({\n    testName,\n    received,\n    key,\n    inlineSnapshot,\n    isInline,\n    error,\n    testFailing = false,\n  }: SnapshotMatchOptions): SnapshotReturnOptions {\n    this._counters.set(testName, (this._counters.get(testName) || 0) + 1);\n    const count = Number(this._counters.get(testName));\n\n    if (!key) {\n      key = testNameToKey(testName, count);\n    }\n\n    // Do not mark the snapshot as \"checked\" if the snapshot is inline and\n    // there's an external snapshot. This way the external snapshot can be\n    // removed with `--updateSnapshot`.\n    if (!(isInline && this._snapshotData[key] !== undefined)) {\n      this._uncheckedKeys.delete(key);\n    }\n\n    const receivedSerialized = addExtraLineBreaks(\n      serialize(received, undefined, this.snapshotFormat),\n    );\n    const expected = isInline ? inlineSnapshot : this._snapshotData[key];\n    const pass = expected === receivedSerialized;\n    const hasSnapshot = expected !== undefined;\n    const snapshotIsPersisted = isInline || fs.existsSync(this._snapshotPath);\n\n    if (pass && !isInline) {\n      // Executing a snapshot file as JavaScript and writing the strings back\n      // when other snapshots have changed loses the proper escaping for some\n      // characters. Since we check every snapshot in every test, use the newly\n      // generated formatted string.\n      // Note that this is only relevant when a snapshot is added and the dirty\n      // flag is set.\n      this._snapshotData[key] = receivedSerialized;\n    }\n\n    // In pure matching only runs, return the match result while skipping any updates\n    // reports.\n    if (testFailing) {\n      if (hasSnapshot && !isInline) {\n        // Retain current snapshot values.\n        this._addSnapshot(key, expected, {error, isInline});\n      }\n      return {\n        actual: removeExtraLineBreaks(receivedSerialized),\n        count,\n        expected:\n          expected === undefined ? undefined : removeExtraLineBreaks(expected),\n        key,\n        pass,\n      };\n    }\n\n    // These are the conditions on when to write snapshots:\n    //  * There's no snapshot file in a non-CI environment.\n    //  * There is a snapshot file and we decided to update the snapshot.\n    //  * There is a snapshot file, but it doesn't have this snapshot.\n    // These are the conditions on when not to write snapshots:\n    //  * The update flag is set to 'none'.\n    //  * There's no snapshot file or a file without this snapshot on a CI environment.\n    if (\n      (hasSnapshot && this._updateSnapshot === 'all') ||\n      ((!hasSnapshot || !snapshotIsPersisted) &&\n        (this._updateSnapshot === 'new' || this._updateSnapshot === 'all'))\n    ) {\n      if (this._updateSnapshot === 'all') {\n        if (pass) {\n          this.matched++;\n        } else {\n          if (hasSnapshot) {\n            this.updated++;\n          } else {\n            this.added++;\n          }\n          this._addSnapshot(key, receivedSerialized, {error, isInline});\n        }\n      } else {\n        this._addSnapshot(key, receivedSerialized, {error, isInline});\n        this.added++;\n      }\n\n      return {\n        actual: '',\n        count,\n        expected: '',\n        key,\n        pass: true,\n      };\n    } else {\n      if (pass) {\n        this.matched++;\n        return {\n          actual: '',\n          count,\n          expected: '',\n          key,\n          pass: true,\n        };\n      } else {\n        this.unmatched++;\n        return {\n          actual: removeExtraLineBreaks(receivedSerialized),\n          count,\n          expected:\n            expected === undefined\n              ? undefined\n              : removeExtraLineBreaks(expected),\n          key,\n          pass: false,\n        };\n      }\n    }\n  }\n\n  fail(testName: string, _received: unknown, key?: string): string {\n    this._counters.set(testName, (this._counters.get(testName) || 0) + 1);\n    const count = Number(this._counters.get(testName));\n\n    if (!key) {\n      key = testNameToKey(testName, count);\n    }\n\n    this._uncheckedKeys.delete(key);\n    this.unmatched++;\n    return key;\n  }\n}\n",
  "packages/jest-snapshot/src/State.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config } from '@jest/types';\nimport type { SnapshotFormat } from './types';\nexport type SnapshotStateOptions = {\n    readonly updateSnapshot: Config.SnapshotUpdateState;\n    readonly prettierPath?: string | null;\n    readonly expand?: boolean;\n    readonly snapshotFormat: SnapshotFormat;\n    readonly rootDir: string;\n};\nexport type SnapshotMatchOptions = {\n    readonly testName: string;\n    readonly received: unknown;\n    readonly key?: string;\n    readonly inlineSnapshot?: string;\n    readonly isInline: boolean;\n    readonly error?: Error;\n    readonly testFailing?: boolean;\n};\ntype SnapshotReturnOptions = {\n    readonly actual: string;\n    readonly count: number;\n    readonly expected?: string;\n    readonly key: string;\n    readonly pass: boolean;\n};\ntype SaveStatus = {\n    deleted: boolean;\n    saved: boolean;\n};\nexport default class SnapshotState {\n    private _counters;\n    private _dirty;\n    private _index;\n    private readonly _updateSnapshot;\n    private _snapshotData;\n    private readonly _initialData;\n    private readonly _snapshotPath;\n    private _inlineSnapshots;\n    private readonly _uncheckedKeys;\n    private readonly _prettierPath;\n    private readonly _rootDir;\n    readonly snapshotFormat: SnapshotFormat;\n    added: number;\n    expand: boolean;\n    matched: number;\n    unmatched: number;\n    updated: number;\n    constructor(snapshotPath: string, options: SnapshotStateOptions);\n    markSnapshotsAsCheckedForTest(testName: string): void;\n    private _addSnapshot;\n    clear(): void;\n    save(): SaveStatus;\n    getUncheckedCount(): number;\n    getUncheckedKeys(): Array<string>;\n    removeUncheckedKeys(): void;\n    match({ testName, received, key, inlineSnapshot, isInline, error, testFailing, }: SnapshotMatchOptions): SnapshotReturnOptions;\n    fail(testName: string, _received: unknown, key?: string): string;\n}\nexport {};\n",
  "packages/jest-snapshot/src/SnapshotResolver.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport chalk from 'chalk';\nimport {createTranspilingRequire} from '@jest/transform';\nimport type {Config} from '@jest/types';\nimport {interopRequireDefault} from 'jest-util';\n\nexport type SnapshotResolver = {\n  /** Resolves from `testPath` to snapshot path. */\n  resolveSnapshotPath(testPath: string, snapshotExtension?: string): string;\n  /** Resolves from `snapshotPath` to test path. */\n  resolveTestPath(snapshotPath: string, snapshotExtension?: string): string;\n  /** Example test path, used for preflight consistency check of the implementation above. */\n  testPathForConsistencyCheck: string;\n};\n\nexport const EXTENSION = 'snap';\nexport const DOT_EXTENSION = `.${EXTENSION}`;\n\nexport const isSnapshotPath = (path: string): boolean =>\n  path.endsWith(DOT_EXTENSION);\n\nconst cache = new Map<string, SnapshotResolver>();\n\ntype LocalRequire = (module: string) => unknown;\n\nexport const buildSnapshotResolver = async (\n  config: Config.ProjectConfig,\n  localRequire: Promise<LocalRequire> | LocalRequire = createTranspilingRequire(\n    config,\n  ),\n): Promise<SnapshotResolver> => {\n  const key = config.rootDir;\n\n  const resolver =\n    cache.get(key) ??\n    (await createSnapshotResolver(await localRequire, config.snapshotResolver));\n\n  cache.set(key, resolver);\n\n  return resolver;\n};\n\nasync function createSnapshotResolver(\n  localRequire: LocalRequire,\n  snapshotResolverPath?: string | null,\n): Promise<SnapshotResolver> {\n  return typeof snapshotResolverPath === 'string'\n    ? createCustomSnapshotResolver(snapshotResolverPath, localRequire)\n    : createDefaultSnapshotResolver();\n}\n\nfunction createDefaultSnapshotResolver(): SnapshotResolver {\n  return {\n    resolveSnapshotPath: (testPath: string) =>\n      path.join(\n        path.join(path.dirname(testPath), '__snapshots__'),\n        path.basename(testPath) + DOT_EXTENSION,\n      ),\n\n    resolveTestPath: (snapshotPath: string) =>\n      path.resolve(\n        path.dirname(snapshotPath),\n        '..',\n        path.basename(snapshotPath, DOT_EXTENSION),\n      ),\n\n    testPathForConsistencyCheck: path.posix.join(\n      'consistency_check',\n      '__tests__',\n      'example.test.js',\n    ),\n  };\n}\n\nasync function createCustomSnapshotResolver(\n  snapshotResolverPath: string,\n  localRequire: LocalRequire,\n): Promise<SnapshotResolver> {\n  const custom: SnapshotResolver = interopRequireDefault(\n    await localRequire(snapshotResolverPath),\n  ).default;\n\n  const keys: Array<[keyof SnapshotResolver, string]> = [\n    ['resolveSnapshotPath', 'function'],\n    ['resolveTestPath', 'function'],\n    ['testPathForConsistencyCheck', 'string'],\n  ];\n  for (const [propName, requiredType] of keys) {\n    if (typeof custom[propName] !== requiredType) {\n      throw new TypeError(mustImplement(propName, requiredType));\n    }\n  }\n\n  const customResolver: SnapshotResolver = {\n    resolveSnapshotPath: (testPath: string) =>\n      custom.resolveSnapshotPath(testPath, DOT_EXTENSION),\n    resolveTestPath: (snapshotPath: string) =>\n      custom.resolveTestPath(snapshotPath, DOT_EXTENSION),\n    testPathForConsistencyCheck: custom.testPathForConsistencyCheck,\n  };\n\n  verifyConsistentTransformations(customResolver);\n\n  return customResolver;\n}\n\nfunction mustImplement(propName: string, requiredType: string) {\n  return `${chalk.bold(\n    `Custom snapshot resolver must implement a \\`${propName}\\` as a ${requiredType}.`,\n  )}\\nDocumentation: https://jestjs.io/docs/configuration#snapshotresolver-string`;\n}\n\nfunction verifyConsistentTransformations(custom: SnapshotResolver) {\n  const resolvedSnapshotPath = custom.resolveSnapshotPath(\n    custom.testPathForConsistencyCheck,\n  );\n  const resolvedTestPath = custom.resolveTestPath(resolvedSnapshotPath);\n  if (resolvedTestPath !== custom.testPathForConsistencyCheck) {\n    throw new Error(\n      chalk.bold(\n        `Custom snapshot resolver functions must transform paths consistently, i.e. expects resolveTestPath(resolveSnapshotPath('${custom.testPathForConsistencyCheck}')) === ${resolvedTestPath}`,\n      ),\n    );\n  }\n}\n",
  "packages/jest-snapshot/src/SnapshotResolver.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config } from '@jest/types';\nexport type SnapshotResolver = {\n    /** Resolves from `testPath` to snapshot path. */\n    resolveSnapshotPath(testPath: string, snapshotExtension?: string): string;\n    /** Resolves from `snapshotPath` to test path. */\n    resolveTestPath(snapshotPath: string, snapshotExtension?: string): string;\n    /** Example test path, used for preflight consistency check of the implementation above. */\n    testPathForConsistencyCheck: string;\n};\nexport declare const EXTENSION = \"snap\";\nexport declare const DOT_EXTENSION = \".snap\";\nexport declare const isSnapshotPath: (path: string) => boolean;\ntype LocalRequire = (module: string) => unknown;\nexport declare const buildSnapshotResolver: (config: Config.ProjectConfig, localRequire?: Promise<LocalRequire> | LocalRequire) => Promise<SnapshotResolver>;\nexport {};\n",
  "packages/jest-snapshot/src/InlineSnapshots.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {types} from 'util';\nimport * as fs from 'graceful-fs';\nimport type {\n  CustomParser as PrettierCustomParser,\n  BuiltInParserName as PrettierParserName,\n} from 'prettier-v2';\nimport * as semver from 'semver';\nimport {createSyncFn} from 'synckit';\nimport type {InlineSnapshot} from './types';\nimport {\n  groupSnapshotsByFile,\n  processInlineSnapshotsWithBabel,\n  processPrettierAst,\n} from './utils';\n\ntype Prettier = typeof import('prettier-v2');\ntype WorkerFn = (\n  prettierPath: string,\n  filepath: string,\n  sourceFileWithSnapshots: string,\n  snapshotMatcherNames: Array<string>,\n) => string;\n\nconst cachedPrettier = new Map<string, Prettier | WorkerFn>();\n\nexport function saveInlineSnapshots(\n  snapshots: Array<InlineSnapshot>,\n  rootDir: string,\n  prettierPath: string | null,\n): void {\n  let prettier: Prettier | undefined = prettierPath\n    ? (cachedPrettier.get(`module|${prettierPath}`) as Prettier)\n    : undefined;\n  let workerFn: WorkerFn | undefined = prettierPath\n    ? (cachedPrettier.get(`worker|${prettierPath}`) as WorkerFn)\n    : undefined;\n  if (prettierPath && !prettier) {\n    try {\n      prettier = require(\n        require.resolve(prettierPath, {\n          [Symbol.for('jest-resolve-outside-vm-option')]: true,\n        }),\n      ) as Prettier;\n\n      cachedPrettier.set(`module|${prettierPath}`, prettier);\n\n      if (semver.gte(prettier.version, '3.0.0')) {\n        workerFn = createSyncFn(\n          require.resolve(/*webpackIgnore: true*/ './worker'),\n        ) as WorkerFn;\n        cachedPrettier.set(`worker|${prettierPath}`, workerFn);\n      }\n    } catch (error) {\n      if (!types.isNativeError(error)) {\n        throw error;\n      }\n\n      if ((error as NodeJS.ErrnoException).code !== 'MODULE_NOT_FOUND') {\n        throw error;\n      }\n    }\n  }\n\n  const snapshotsByFile = groupSnapshotsByFile(snapshots);\n\n  for (const sourceFilePath of Object.keys(snapshotsByFile)) {\n    const {sourceFileWithSnapshots, snapshotMatcherNames, sourceFile} =\n      processInlineSnapshotsWithBabel(\n        snapshotsByFile[sourceFilePath],\n        sourceFilePath,\n        rootDir,\n      );\n\n    let newSourceFile = sourceFileWithSnapshots;\n\n    if (workerFn) {\n      newSourceFile = workerFn(\n        prettierPath!,\n        sourceFilePath,\n        sourceFileWithSnapshots,\n        snapshotMatcherNames,\n      );\n    } else if (prettier && semver.gte(prettier.version, '1.5.0')) {\n      newSourceFile = runPrettier(\n        prettier,\n        sourceFilePath,\n        sourceFileWithSnapshots,\n        snapshotMatcherNames,\n      );\n    }\n\n    if (newSourceFile !== sourceFile) {\n      fs.writeFileSync(sourceFilePath, newSourceFile);\n    }\n  }\n}\n\nconst runPrettier = (\n  prettier: Prettier,\n  sourceFilePath: string,\n  sourceFileWithSnapshots: string,\n  snapshotMatcherNames: Array<string>,\n) => {\n  // Resolve project configuration.\n  // For older versions of Prettier, do not load configuration.\n  const config = prettier.resolveConfig\n    ? prettier.resolveConfig.sync(sourceFilePath, {editorconfig: true})\n    : null;\n\n  // Prioritize parser found in the project config.\n  // If not found detect the parser for the test file.\n  // For older versions of Prettier, fallback to a simple parser detection.\n  // @ts-expect-error - `inferredParser` is `string`\n  const inferredParser: PrettierParserName | null | undefined =\n    (typeof config?.parser === 'string' && config.parser) ||\n    (prettier.getFileInfo\n      ? prettier.getFileInfo.sync(sourceFilePath).inferredParser\n      : simpleDetectParser(sourceFilePath));\n\n  if (!inferredParser) {\n    throw new Error(\n      `Could not infer Prettier parser for file ${sourceFilePath}`,\n    );\n  }\n\n  // Snapshots have now been inserted. Run prettier to make sure that the code is\n  // formatted, except snapshot indentation. Snapshots cannot be formatted until\n  // after the initial format because we don't know where the call expression\n  // will be placed (specifically its indentation), so we have to do two\n  // prettier.format calls back-to-back.\n  return prettier.format(\n    prettier.format(sourceFileWithSnapshots, {\n      ...config,\n      filepath: sourceFilePath,\n    }),\n    {\n      ...config,\n      filepath: sourceFilePath,\n      parser: createFormattingParser(snapshotMatcherNames, inferredParser),\n    },\n  );\n};\n\n// This parser formats snapshots to the correct indentation.\nconst createFormattingParser =\n  (\n    snapshotMatcherNames: Array<string>,\n    inferredParser: PrettierParserName,\n  ): PrettierCustomParser =>\n  (text, parsers, options) => {\n    // Workaround for https://github.com/prettier/prettier/issues/3150\n    options.parser = inferredParser;\n\n    const ast = parsers[inferredParser](text, options);\n    processPrettierAst(ast, options, snapshotMatcherNames);\n\n    return ast;\n  };\n\nconst simpleDetectParser = (filePath: string): PrettierParserName => {\n  const extname = path.extname(filePath);\n  if (/\\.tsx?$/.test(extname)) {\n    return 'typescript';\n  }\n  return 'babel';\n};\n",
  "packages/jest-snapshot/src/InlineSnapshots.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { InlineSnapshot } from './types';\nexport declare function saveInlineSnapshots(snapshots: Array<InlineSnapshot>, rootDir: string, prettierPath: string | null): void;\n",
  "packages/jest-snapshot/src/__tests__/utils.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\njest.mock('graceful-fs', () => ({\n  ...jest.createMockFromModule<typeof import('fs')>('fs'),\n  existsSync: jest.fn().mockReturnValue(true),\n}));\n\nimport {strict as assert} from 'assert';\nimport {\n  addExtraLineBreaks,\n  deepMerge,\n  removeExtraLineBreaks,\n  removeLinesBeforeExternalMatcherTrap,\n  serialize,\n} from '../utils';\n\ntest('serialize handles \\\\r\\\\n', () => {\n  const data = '<div>\\r\\n</div>';\n  const serializedData = serialize(data);\n\n  expect(serializedData).toBe('\"<div>\\n</div>\"');\n});\n\ndescribe('ExtraLineBreaks', () => {\n  test('0 empty string', () => {\n    const expected = '';\n\n    const added = addExtraLineBreaks(expected);\n    const removed = removeExtraLineBreaks(added);\n\n    expect(added).toBe(expected);\n    expect(removed).toBe(expected);\n  });\n\n  test('1 line has double quote marks at edges', () => {\n    const expected = '\" one line \"';\n\n    const added = addExtraLineBreaks(expected);\n    const removed = removeExtraLineBreaks(added);\n\n    expect(added).toBe(expected);\n    expect(removed).toBe(expected);\n  });\n\n  test('1 line has spaces at edges', () => {\n    const expected = ' one line ';\n\n    const added = addExtraLineBreaks(expected);\n    const removed = removeExtraLineBreaks(added);\n\n    expect(added).toBe(expected);\n    expect(removed).toBe(expected);\n  });\n\n  test('2 lines both are blank', () => {\n    const expected = '\\n';\n\n    const added = addExtraLineBreaks(expected);\n    const removed = removeExtraLineBreaks(added);\n\n    expect(added).toBe(`\\n${expected}\\n`);\n    expect(removed).toBe(expected);\n  });\n\n  test('2 lines have double quote marks at edges', () => {\n    const expected = '\"\\n\"';\n\n    const added = addExtraLineBreaks(expected);\n    const removed = removeExtraLineBreaks(added);\n\n    expect(added).toBe(`\\n${expected}\\n`);\n    expect(removed).toBe(expected);\n  });\n\n  test('2 lines first is blank', () => {\n    const expected = '\\nsecond line ';\n\n    const added = addExtraLineBreaks(expected);\n    const removed = removeExtraLineBreaks(added);\n\n    expect(added).toBe(`\\n${expected}\\n`);\n    expect(removed).toBe(expected);\n  });\n\n  test('2 lines last is blank', () => {\n    const expected = ' first line\\n';\n\n    const added = addExtraLineBreaks(expected);\n    const removed = removeExtraLineBreaks(added);\n\n    expect(added).toBe(`\\n${expected}\\n`);\n    expect(removed).toBe(expected);\n  });\n});\n\ndescribe('removeLinesBeforeExternalMatcherTrap', () => {\n  test('contains external matcher trap', () => {\n    const stack = `Error:\n    at SnapshotState._addSnapshot (/jest/packages/jest-snapshot/build/State.js:150:9)\n    at SnapshotState.match (/jest/packages/jest-snapshot/build/State.js:303:14)\n    at _toMatchSnapshot (/jest/packages/jest-snapshot/build/index.js:399:32)\n    at _toThrowErrorMatchingSnapshot (/jest/packages/jest-snapshot/build/index.js:585:10)\n    at Object.toThrowErrorMatchingInlineSnapshot (/jest/packages/jest-snapshot/build/index.js:504:10)\n    at Object.<anonymous> (/jest/packages/expect/build/index.js:138:20)\n    at __EXTERNAL_MATCHER_TRAP__ (/jest/packages/expect/build/index.js:378:30)\n    at throwingMatcher (/jest/packages/expect/build/index.js:379:15)\n    at /jest/packages/expect/build/index.js:285:72\n    at Object.<anonymous> (/jest/e2e/to-throw-error-matching-inline-snapshot/__tests__/should-support-rejecting-promises.test.js:3:7)`;\n\n    const expected = `    at throwingMatcher (/jest/packages/expect/build/index.js:379:15)\n    at /jest/packages/expect/build/index.js:285:72\n    at Object.<anonymous> (/jest/e2e/to-throw-error-matching-inline-snapshot/__tests__/should-support-rejecting-promises.test.js:3:7)`;\n\n    expect(removeLinesBeforeExternalMatcherTrap(stack)).toBe(expected);\n  });\n\n  test(\"doesn't contain external matcher trap\", () => {\n    const stack = `Error:\n    at SnapshotState._addSnapshot (/jest/packages/jest-snapshot/build/State.js:150:9)\n    at SnapshotState.match (/jest/packages/jest-snapshot/build/State.js:303:14)\n    at _toMatchSnapshot (/jest/packages/jest-snapshot/build/index.js:399:32)\n    at _toThrowErrorMatchingSnapshot (/jest/packages/jest-snapshot/build/index.js:585:10)\n    at Object.toThrowErrorMatchingInlineSnapshot (/jest/packages/jest-snapshot/build/index.js:504:10)\n    at Object.<anonymous> (/jest/packages/expect/build/index.js:138:20)\n    at throwingMatcher (/jest/packages/expect/build/index.js:379:15)\n    at /jest/packages/expect/build/index.js:285:72\n    at Object.<anonymous> (/jest/e2e/to-throw-error-matching-inline-snapshot/__tests__/should-support-rejecting-promises.test.js:3:7)`;\n\n    expect(removeLinesBeforeExternalMatcherTrap(stack)).toBe(stack);\n  });\n});\n\ndescribe('DeepMerge with property matchers', () => {\n  const matcherString = expect.any(String);\n  const matcherNumber = expect.any(Number);\n  const matcherObject = expect.any(Object);\n  const matcherArray = expect.any(Array);\n  const matcherBoolean = expect.any(Boolean);\n  const matcherAnything = expect.anything();\n\n  it.each(\n    /* eslint-disable sort-keys */\n    // to keep keys in numerical order rather than alphabetical\n    [\n      [\n        'a nested object',\n        // Target\n        {\n          data: {\n            one: 'one',\n            two: 'two',\n          },\n        },\n        // Matchers\n        {\n          data: {\n            two: matcherString,\n          },\n        },\n        // Expected\n        {\n          data: {\n            one: 'one',\n            two: matcherString,\n          },\n        },\n      ],\n\n      [\n        'an object with an array of objects',\n        // Target\n        {\n          data: {\n            one: [\n              {\n                two: 'two',\n                three: 'three',\n              },\n              // Include an array element not present in the propertyMatchers\n              {\n                four: 'four',\n                five: 'five',\n              },\n            ],\n            six: [{seven: 'seven'}],\n            nine: [[{ten: 'ten'}]],\n          },\n        },\n        // Matchers\n        {\n          data: {\n            one: [\n              {\n                two: matcherString,\n              },\n            ],\n            six: [\n              {seven: matcherString},\n              // Include an array element not present in the target\n              {eight: matcherString},\n            ],\n            nine: [[{ten: matcherString}]],\n          },\n        },\n        // Expected\n        {\n          data: {\n            one: [\n              {\n                two: matcherString,\n                three: 'three',\n              },\n              {\n                four: 'four',\n                five: 'five',\n              },\n            ],\n            six: [{seven: matcherString}, {eight: matcherString}],\n            nine: [[{ten: matcherString}]],\n          },\n        },\n      ],\n\n      [\n        'an object with an array of strings',\n        // Target\n        {\n          data: {\n            one: ['one'],\n            two: ['two'],\n            three: ['three', 'four'],\n            five: ['five'],\n          },\n        },\n        // Matchers\n        {\n          data: {\n            one: [matcherString],\n            two: ['two'],\n            three: [matcherString],\n            five: 'five',\n          },\n        },\n        // Expected\n        {\n          data: {\n            one: [matcherString],\n            two: ['two'],\n            three: [matcherString, 'four'],\n            five: 'five',\n          },\n        },\n      ],\n\n      [\n        'an array of objects',\n        // Target\n        [{name: 'one'}, {name: 'two'}, {name: 'three'}],\n        // Matchers\n        [{name: 'one'}, {name: matcherString}, {name: matcherString}],\n        // Expected\n        [{name: 'one'}, {name: matcherString}, {name: matcherString}],\n      ],\n\n      [\n        'an array of different types',\n        // Target\n        [\n          5,\n          'some words',\n          [],\n          {},\n          true,\n          false,\n          5,\n          'some words',\n          [],\n          {},\n          true,\n          false,\n        ],\n        // Matchers\n        [\n          matcherNumber,\n          matcherString,\n          matcherArray,\n          matcherObject,\n          matcherBoolean,\n          matcherBoolean,\n          matcherAnything,\n          matcherAnything,\n          matcherAnything,\n          matcherAnything,\n          matcherAnything,\n          matcherAnything,\n        ],\n        // Expected\n        [\n          matcherNumber,\n          matcherString,\n          matcherArray,\n          matcherObject,\n          matcherBoolean,\n          matcherBoolean,\n          matcherAnything,\n          matcherAnything,\n          matcherAnything,\n          matcherAnything,\n          matcherAnything,\n          matcherAnything,\n        ],\n      ],\n\n      [\n        'an array of arrays',\n        // Target\n        [['one'], ['two'], ['three']],\n        // Matchers\n        [['one'], [matcherString], [matcherString]],\n        // Expected\n        [['one'], [matcherString], [matcherString]],\n      ],\n    ],\n    /* eslint-enable sort-keys */\n  )('Correctly merges %s', (_case, target, propertyMatchers, expected) => {\n    const originalTarget = JSON.parse(JSON.stringify(target));\n    const mergedOutput = deepMerge(target, propertyMatchers);\n\n    // Use assert.deepStrictEqual() instead of expect().toStrictEqual()\n    // since we want to actually validate that we got the matcher\n    // rather than treat it specially the way that expect() does\n    assert.deepStrictEqual(mergedOutput, expected);\n\n    // Ensure original target is not modified\n    expect(target).toStrictEqual(originalTarget);\n  });\n});\n",
  "packages/jest-snapshot/src/__tests__/utils.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-snapshot/src/__tests__/throwMatcher.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {type Context, toThrowErrorMatchingSnapshot} from '../';\n\nconst mockedMatch = jest.fn<\n  (args: {received: string; testName: string}) => unknown\n>(() => ({\n  actual: 'coconut',\n  expected: 'coconut',\n}));\n\nconst mockedContext = {\n  snapshotState: {match: mockedMatch},\n} as unknown as Context;\n\nafterEach(() => {\n  jest.clearAllMocks();\n});\n\nit('throw matcher can take func', () => {\n  toThrowErrorMatchingSnapshot.call(\n    mockedContext,\n    () => {\n      throw new Error('coconut');\n    },\n    undefined,\n    false,\n  );\n\n  expect(mockedMatch).toHaveBeenCalledTimes(1);\n  expect(mockedMatch).toHaveBeenCalledWith(\n    expect.objectContaining({received: 'coconut', testName: ''}),\n  );\n});\n\ndescribe('throw matcher from promise', () => {\n  it('can take error', () => {\n    toThrowErrorMatchingSnapshot.call(\n      mockedContext,\n      new Error('coco'),\n      'testName',\n      true,\n    );\n\n    expect(mockedMatch).toHaveBeenCalledTimes(1);\n    expect(mockedMatch).toHaveBeenCalledWith(\n      expect.objectContaining({received: 'coco', testName: ''}),\n    );\n  });\n\n  it('can take custom error', () => {\n    class CustomError extends Error {}\n\n    toThrowErrorMatchingSnapshot.call(\n      mockedContext,\n      new CustomError('nut'),\n      'testName',\n      true,\n    );\n\n    expect(mockedMatch).toHaveBeenCalledTimes(1);\n    expect(mockedMatch).toHaveBeenCalledWith(\n      expect.objectContaining({received: 'nut', testName: ''}),\n    );\n  });\n});\n",
  "packages/jest-snapshot/src/__tests__/throwMatcher.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-snapshot/src/__tests__/printSnapshot.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport ansiRegex from 'ansi-regex';\nimport styles from 'ansi-styles';\nimport chalk from 'chalk';\nimport type {SyncExpectationResult} from 'expect';\nimport format from 'pretty-format';\nimport {\n  type Context,\n  toMatchInlineSnapshot,\n  toMatchSnapshot,\n  toThrowErrorMatchingInlineSnapshot,\n  toThrowErrorMatchingSnapshot,\n} from '../';\nimport type SnapshotState from '../State';\nimport {\n  aBackground2,\n  aBackground3,\n  aForeground2,\n  aForeground3,\n  bBackground2,\n  bBackground3,\n  bForeground2,\n  bForeground3,\n} from '../colors';\nimport {\n  getReceivedColorForChalkInstance,\n  getSnapshotColorForChalkInstance,\n  noColor,\n  printPropertiesAndReceived,\n  printSnapshotAndReceived,\n} from '../printSnapshot';\nimport {serialize} from '../utils';\n\nconst aOpenForeground1 = styles.magenta.open;\nconst aOpenBackground1 = styles.bgYellowBright.open;\nconst bOpenForeground1 = styles.cyan.open;\nconst bOpenBackground1 = styles.bgWhiteBright.open;\n\nconst aOpenForeground2 = styles.color.ansi256(aForeground2);\nconst bOpenForeground2 = styles.color.ansi256(bForeground2);\nconst aOpenBackground2 = styles.bgColor.ansi256(aBackground2);\nconst bOpenBackground2 = styles.bgColor.ansi256(bBackground2);\n\nconst aOpenForeground3 = styles.color.ansi16m(\n  aForeground3[0],\n  aForeground3[1],\n  aForeground3[2],\n);\nconst bOpenForeground3 = styles.color.ansi16m(\n  bForeground3[0],\n  bForeground3[1],\n  bForeground3[2],\n);\nconst aOpenBackground3 = styles.bgColor.ansi16m(\n  aBackground3[0],\n  aBackground3[1],\n  aBackground3[2],\n);\nconst bOpenBackground3 = styles.bgColor.ansi16m(\n  bBackground3[0],\n  bBackground3[1],\n  bBackground3[2],\n);\n\nconst convertAnsi = (val: string): string => {\n  // Trailing spaces in common lines have yellow background color.\n  let isYellowBackground = false;\n\n  return val.replace(ansiRegex(), match => {\n    switch (match) {\n      case styles.inverse.open:\n        return '<i>';\n      case styles.inverse.close:\n        return '</i>';\n\n      case styles.bold.open:\n        return '<b>';\n      case styles.dim.open:\n        return '<d>';\n      case styles.bold.close:\n      case styles.dim.close:\n        return '</>';\n\n      case styles.green.open:\n        return '<g>';\n      case aOpenForeground1:\n      case aOpenForeground2:\n      case aOpenForeground3:\n        return '<m>';\n      case styles.red.open:\n        return '<r>';\n      case bOpenForeground1:\n      case bOpenForeground2:\n      case bOpenForeground3:\n        return '<t>'; // teal/cyan/aqua\n      case styles.yellow.open:\n        return '<y>';\n      case styles.cyan.close:\n      case styles.green.close:\n      case styles.magenta.close:\n      case styles.red.close:\n      case styles.yellow.close:\n        return '</>';\n\n      case styles.bgYellow.open:\n        isYellowBackground = true;\n        return '<Y>';\n\n      case aOpenBackground1:\n      case bOpenBackground1:\n      case aOpenBackground2:\n      case bOpenBackground2:\n      case aOpenBackground3:\n      case bOpenBackground3:\n        isYellowBackground = false;\n        return '';\n\n      case styles.bgYellow.close:\n        // The same code closes any background color.\n        return isYellowBackground ? '</Y>' : '';\n\n      default:\n        return match;\n    }\n  });\n};\n\nexpect.addSnapshotSerializer({\n  serialize(val: string): string {\n    return convertAnsi(val);\n  },\n  test(val: unknown): val is string {\n    return typeof val === 'string';\n  },\n});\n\ndescribe('chalk', () => {\n  // Because these tests give code coverage of get functions\n  // and give confidence that the escape sequences are correct,\n  // convertAnsi can return same serialization for any chalk level\n  // so snapshot tests pass in any environment with chalk level >= 1.\n\n  // Simulate comparison lines from printSnapshotAndReceived.\n  const formatLines = (chalkInstance: chalk.Chalk) => {\n    const aColor = getSnapshotColorForChalkInstance(chalkInstance);\n    const bColor = getReceivedColorForChalkInstance(chalkInstance);\n    const cColor = chalkInstance.dim;\n    const changeLineTrailingSpaceColor = noColor;\n    const commonLineTrailingSpaceColor = chalkInstance.bgYellow;\n\n    return [\n      aColor(`- delete 1${changeLineTrailingSpaceColor(' ')}`),\n      cColor(`  common 2${commonLineTrailingSpaceColor('  ')}`),\n      bColor('+ insert 0'),\n    ].join('\\n');\n  };\n\n  const expected0 = '- delete 1 \\n  common 2  \\n+ insert 0';\n  const expected1 =\n    '<m>- delete 1 </>\\n<d>  common 2<Y>  </Y></>\\n<t>+ insert 0</>';\n\n  test('level 0', () => {\n    const chalkInstance = new chalk.Instance({level: 0});\n    const formatted = formatLines(chalkInstance);\n    const converted = convertAnsi(formatted);\n\n    expect(converted).toBe(expected0);\n    expect(formatted).toBe(expected0);\n  });\n\n  test('level 1', () => {\n    const chalkInstance = new chalk.Instance({level: 1});\n    const formatted = formatLines(chalkInstance);\n    const converted = convertAnsi(formatted);\n\n    expect(converted).toBe(expected1);\n    expect(formatted).toMatch(`${aOpenForeground1 + aOpenBackground1}-`);\n    expect(formatted).toMatch(`${bOpenForeground1 + bOpenBackground1}+`);\n    expect(formatted).not.toMatch(chalkInstance.bgYellow(' ')); // noColor\n    expect(formatted).toMatch(chalkInstance.bgYellow('  '));\n  });\n\n  test('level 2', () => {\n    const chalkInstance = new chalk.Instance({level: 2});\n    const formatted = formatLines(chalkInstance);\n    const converted = convertAnsi(formatted);\n\n    expect(converted).toBe(expected1);\n    expect(formatted).toMatch(`${aOpenForeground2 + aOpenBackground2}-`);\n    expect(formatted).toMatch(`${bOpenForeground2 + bOpenBackground2}+`);\n    expect(formatted).not.toMatch(chalkInstance.bgYellow(' ')); // noColor\n    expect(formatted).toMatch(chalkInstance.bgYellow('  '));\n  });\n\n  test('level 3', () => {\n    const chalkInstance = new chalk.Instance({level: 3});\n    const formatted = formatLines(chalkInstance);\n    const converted = convertAnsi(formatted);\n\n    expect(converted).toBe(expected1);\n    expect(formatted).toMatch(`${aOpenForeground3 + aOpenBackground3}-`);\n    expect(formatted).toMatch(`${bOpenForeground3 + bOpenBackground3}+`);\n    expect(formatted).not.toMatch(chalkInstance.bgYellow(' ')); // noColor\n    expect(formatted).toMatch(chalkInstance.bgYellow('  '));\n  });\n});\n\ndescribe('matcher error', () => {\n  describe('toMatchInlineSnapshot', () => {\n    const received = {\n      id: 'abcdef',\n      text: 'Throw matcher error',\n      type: 'ADD_ITEM',\n    };\n\n    test('Expected properties must be an object (non-null) without snapshot', () => {\n      const context = {\n        isNot: false,\n        promise: '',\n      } as Context;\n      const properties = false;\n\n      expect(() => {\n        // @ts-expect-error: Testing runtime error\n        toMatchInlineSnapshot.call(context, received, properties);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('Expected properties must be an object (null) with snapshot', () => {\n      const context = {\n        isNot: false,\n        promise: '',\n      } as Context;\n      const properties = null;\n      const snapshot = '';\n\n      expect(() => {\n        // @ts-expect-error: Testing runtime error\n        toMatchInlineSnapshot.call(context, received, properties, snapshot);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('Inline snapshot must be a string', () => {\n      const context = {\n        isNot: false,\n        promise: 'resolves',\n      } as Context;\n      const properties = {};\n      const snapshot = Symbol('is not a string');\n\n      expect(() => {\n        // @ts-expect-error: Testing runtime error\n        toMatchInlineSnapshot.call(context, received, properties, snapshot);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('Snapshot matchers cannot be used with not', () => {\n      const context = {\n        isNot: true,\n        promise: '',\n      } as Context;\n      const received = -13;\n      const snapshot = '13';\n\n      expect(() => {\n        toMatchInlineSnapshot.call(context, received, snapshot);\n      }).toThrowErrorMatchingSnapshot();\n    });\n  });\n\n  describe('toMatchSnapshot', () => {\n    const received = {\n      id: 'abcdef',\n      text: 'Throw matcher error',\n      type: 'ADD_ITEM',\n    };\n\n    test('Expected properties must be an object (non-null)', () => {\n      const context = {\n        isNot: false,\n        promise: '',\n      } as Context;\n      const properties = () => {};\n\n      expect(() => {\n        toMatchSnapshot.call(context, received, properties);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('Expected properties must be an object (null) with hint', () => {\n      const context = {\n        isNot: false,\n        promise: '',\n      } as Context;\n      const properties = null;\n      const hint = 'reminder';\n\n      expect(() => {\n        // @ts-expect-error: Testing runtime error\n        toMatchSnapshot.call(context, received, properties, hint);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('Expected properties must be an object (null) without hint', () => {\n      const context = {\n        isNot: false,\n        promise: '',\n      } as Context;\n      const properties = null;\n\n      expect(() => {\n        // @ts-expect-error: Testing runtime error\n        toMatchSnapshot.call(context, received, properties);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    describe('received value must be an object', () => {\n      const context = {\n        currentTestName: '',\n        isNot: false,\n        promise: '',\n        snapshotState: {},\n      } as Context;\n      const properties = {};\n\n      test('(non-null)', () => {\n        expect(() => {\n          toMatchSnapshot.call(context, 'string', properties);\n        }).toThrowErrorMatchingSnapshot();\n      });\n\n      test('(null)', () => {\n        expect(() => {\n          toMatchSnapshot.call(context, null, properties);\n        }).toThrowErrorMatchingSnapshot();\n      });\n    });\n\n    // Future test: Snapshot hint must be a string\n\n    test('Snapshot state must be initialized', () => {\n      const context = {\n        isNot: false,\n        promise: 'resolves',\n      } as Context;\n      const hint = 'initialize me';\n\n      expect(() => {\n        toMatchSnapshot.call(context, received, hint);\n      }).toThrowErrorMatchingSnapshot();\n    });\n  });\n\n  describe('toThrowErrorMatchingInlineSnapshot', () => {\n    test('Inline snapshot must be a string', () => {\n      const context = {\n        isNot: false,\n        promise: '',\n      } as Context;\n      const received = () => {\n        throw new Error('Not found');\n      };\n      const snapshot = 404;\n      const fromPromise = false;\n\n      expect(() => {\n        toThrowErrorMatchingInlineSnapshot.call(\n          context,\n          received,\n          // @ts-expect-error: Testing runtime error\n          snapshot,\n          fromPromise,\n        );\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('Snapshot state must be initialized', () => {\n      const context = {\n        isNot: false,\n        promise: 'rejects',\n      } as Context;\n      const received = new Error('404');\n      const snapshot = '\"Not found\"';\n      const fromPromise = true;\n\n      expect(() => {\n        toThrowErrorMatchingInlineSnapshot.call(\n          context,\n          received,\n          snapshot,\n          fromPromise,\n        );\n      }).toThrowErrorMatchingSnapshot();\n    });\n  });\n\n  describe('toThrowErrorMatchingSnapshot', () => {\n    test('Received value must be a function', () => {\n      const context = {\n        isNot: false,\n        promise: '',\n      } as Context;\n      const received = 13;\n      const fromPromise = false;\n\n      expect(() => {\n        toThrowErrorMatchingSnapshot.call(\n          context,\n          received,\n          undefined,\n          fromPromise,\n        );\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('Snapshot matchers cannot be used with not', () => {\n      const context = {\n        isNot: true,\n        promise: '',\n      } as Context;\n      const received = new Error('received');\n      const hint = 'reminder';\n      const fromPromise = true;\n\n      expect(() => {\n        toThrowErrorMatchingSnapshot.call(context, received, hint, fromPromise);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    // Future test: Snapshot hint must be a string\n  });\n});\n\ndescribe('other error', () => {\n  describe('toThrowErrorMatchingSnapshot', () => {\n    test('Received function did not throw', () => {\n      const context = {\n        isNot: false,\n        promise: '',\n      } as Context;\n      const received = () => {};\n      const fromPromise = false;\n\n      expect(() => {\n        toThrowErrorMatchingSnapshot.call(\n          context,\n          received,\n          undefined,\n          fromPromise,\n        );\n      }).toThrowErrorMatchingSnapshot();\n    });\n  });\n});\n\ndescribe('pass false', () => {\n  describe('toMatchInlineSnapshot', () => {\n    describe('with properties', () => {\n      const id = 'abcdef';\n      const properties = {id};\n      const type = 'ADD_ITEM';\n\n      describe('equals false', () => {\n        const context = {\n          currentTestName: 'with properties',\n          equals: () => false,\n          isNot: false,\n          promise: '',\n          snapshotState: {\n            fail: (fullTestName: string) => `${fullTestName} 1`,\n          },\n          utils: {\n            iterableEquality: () => {},\n            subsetEquality: () => {},\n          },\n        } as unknown as Context;\n        const received = {\n          id: 'abcdefg',\n          text: 'Increase code coverage',\n          type,\n        };\n\n        test('with snapshot', () => {\n          const snapshot = '';\n          const {message, pass} = toMatchInlineSnapshot.call(\n            context,\n            received,\n            properties,\n            snapshot,\n          ) as SyncExpectationResult;\n          expect(pass).toBe(false);\n          expect(message()).toMatchSnapshot();\n        });\n\n        test('without snapshot', () => {\n          const {message, pass} = toMatchInlineSnapshot.call(\n            context,\n            received,\n            properties,\n          ) as SyncExpectationResult;\n          expect(pass).toBe(false);\n          expect(message()).toMatchSnapshot();\n        });\n      });\n\n      test('equals true', () => {\n        const context = {\n          currentTestName: 'with properties',\n          equals: () => true,\n          isNot: false,\n          promise: '',\n          snapshotState: {\n            expand: false,\n            match({inlineSnapshot, received}) {\n              return {\n                actual: format(received),\n                count: 1,\n                expected: inlineSnapshot,\n                pass: false,\n              };\n            },\n          } as SnapshotState,\n          utils: {\n            iterableEquality: () => {},\n            subsetEquality: () => {},\n          },\n        } as unknown as Context;\n        const received = {\n          id,\n          text: 'received',\n          type,\n        };\n        const snapshot = format({\n          id,\n          text: 'inline snapshot',\n          type,\n        });\n\n        const {message, pass} = toMatchInlineSnapshot.call(\n          context,\n          received,\n          properties,\n          snapshot,\n        ) as SyncExpectationResult;\n        expect(pass).toBe(false);\n        expect(message()).toMatchSnapshot();\n      });\n    });\n  });\n\n  describe('toMatchSnapshot', () => {\n    test('New snapshot was not written (multi line)', () => {\n      const context = {\n        currentTestName: 'New snapshot was not written',\n        isNot: false,\n        promise: '',\n        snapshotState: {\n          match({received}) {\n            return {\n              actual: format(received),\n              count: 1,\n              expected: undefined,\n              pass: false,\n            };\n          },\n        },\n      } as Context;\n      const received = 'To write or not to write,\\nthat is the question.';\n      const hint = '(CI)';\n\n      const {message, pass} = toMatchSnapshot.call(\n        context,\n        received,\n        hint,\n      ) as SyncExpectationResult;\n      expect(pass).toBe(false);\n      expect(message()).toMatchSnapshot();\n    });\n\n    test('New snapshot was not written (single line)', () => {\n      const context = {\n        currentTestName: 'New snapshot was not written',\n        isNot: false,\n        promise: '',\n        snapshotState: {\n          match({received}) {\n            return {\n              actual: format(received),\n              count: 2,\n              expected: undefined,\n              pass: false,\n            };\n          },\n        },\n      } as Context;\n      const received = 'Write me if you can!';\n      const hint = '(CI)';\n\n      const {message, pass} = toMatchSnapshot.call(\n        context,\n        received,\n        hint,\n      ) as SyncExpectationResult;\n      expect(pass).toBe(false);\n      expect(message()).toMatchSnapshot();\n    });\n\n    describe('with properties', () => {\n      const id = 'abcdef';\n      const properties = {id};\n      const type = 'ADD_ITEM';\n\n      describe('equals false', () => {\n        const context = {\n          currentTestName: 'with properties',\n          equals: () => false,\n          isNot: false,\n          promise: '',\n          snapshotState: {\n            fail: (fullTestName: string) => `${fullTestName} 1`,\n          },\n          utils: {\n            iterableEquality: () => {},\n            subsetEquality: () => {},\n          },\n        } as unknown as Context;\n\n        test('isLineDiffable false', () => {\n          const {message, pass} = toMatchSnapshot.call(\n            context,\n            new RangeError('Invalid array length'),\n            {name: 'Error'},\n          ) as SyncExpectationResult;\n          expect(pass).toBe(false);\n          expect(message()).toMatchSnapshot();\n        });\n\n        test('isLineDiffable true', () => {\n          const received = {\n            id: 'abcdefg',\n            text: 'Increase code coverage',\n            type,\n          };\n\n          const {message, pass} = toMatchSnapshot.call(\n            context,\n            received,\n            properties,\n          ) as SyncExpectationResult;\n          expect(pass).toBe(false);\n          expect(message()).toMatchSnapshot();\n        });\n      });\n\n      test('equals true', () => {\n        const context = {\n          currentTestName: 'with properties',\n          equals: () => true,\n          isNot: false,\n          promise: '',\n          snapshotState: {\n            expand: false,\n            match({received}) {\n              return {\n                actual: format(received),\n                count: 1,\n                expected: format({\n                  id,\n                  text: 'snapshot',\n                  type,\n                }),\n                pass: false,\n              };\n            },\n          } as SnapshotState,\n          utils: {\n            iterableEquality: () => {},\n            subsetEquality: () => {},\n          },\n        } as unknown as Context;\n        const received = {\n          id,\n          text: 'received',\n          type,\n        };\n        const hint = 'change text value';\n\n        const {message, pass} = toMatchSnapshot.call(\n          context,\n          received,\n          properties,\n          hint,\n        ) as SyncExpectationResult;\n        expect(pass).toBe(false);\n        expect(message()).toMatchSnapshot();\n      });\n    });\n  });\n\n  describe('toThrowErrorMatchingInlineSnapshot', () => {\n    test('with snapshot', () => {\n      const context = {\n        currentTestName: 'with snapshot',\n        isNot: false,\n        promise: '',\n        snapshotState: {\n          expand: false,\n          match({inlineSnapshot, received}) {\n            return {\n              actual: format(received),\n              count: 1,\n              expected: inlineSnapshot,\n              pass: false,\n            };\n          },\n        },\n      } as Context;\n      const received = new Error('received');\n      const snapshot = '\"inline snapshot\"';\n      const fromPromise = true;\n\n      const {message, pass} = toThrowErrorMatchingInlineSnapshot.call(\n        context,\n        received,\n        snapshot,\n        fromPromise,\n      ) as SyncExpectationResult;\n      expect(pass).toBe(false);\n      expect(message()).toMatchSnapshot();\n    });\n  });\n});\n\ndescribe('pass true', () => {\n  describe('toMatchSnapshot', () => {\n    test('without properties', () => {\n      const context = {\n        isNot: false,\n        promise: '',\n        snapshotState: {\n          match() {\n            return {\n              expected: '',\n              pass: true,\n            };\n          },\n        },\n      } as unknown as Context;\n      const received = 7;\n\n      const {pass} = toMatchSnapshot.call(\n        context,\n        received,\n      ) as SyncExpectationResult;\n      expect(pass).toBe(true);\n    });\n\n    test('array', () => {\n      const context = {\n        equals: () => true,\n        isNot: false,\n        promise: '',\n        snapshotState: {\n          match() {\n            return {\n              expected: [],\n              pass: true,\n            };\n          },\n        },\n        utils: {\n          iterableEquality: () => [],\n          subsetEquality: () => [],\n        },\n      } as unknown as Context;\n      const received: Array<unknown> = [];\n      const properties: Array<unknown> = [];\n\n      const {pass} = toMatchSnapshot.call(\n        context,\n        received,\n        properties,\n      ) as SyncExpectationResult;\n      expect(pass).toBe(true);\n    });\n  });\n\n  describe('toMatchInlineSnapshot', () => {\n    test('array', () => {\n      const context = {\n        equals: () => true,\n        isNot: false,\n        promise: '',\n        snapshotState: {\n          match() {\n            return {\n              expected: [],\n              pass: true,\n            };\n          },\n        },\n        utils: {\n          iterableEquality: () => [],\n          subsetEquality: () => [],\n        },\n      } as unknown as Context;\n      const received: Array<unknown> = [];\n      const properties: Array<unknown> = [];\n\n      const {pass} = toMatchInlineSnapshot.call(\n        context,\n        received,\n        properties,\n      ) as SyncExpectationResult;\n      expect(pass).toBe(true);\n    });\n  });\n});\n\ndescribe('printPropertiesAndReceived', () => {\n  test('omit missing properties', () => {\n    const received = {\n      b: {},\n      branchMap: {},\n      f: {},\n      fnMap: {},\n      // hash is missing\n      path: '…',\n      s: {},\n      statementMap: {},\n    };\n    const properties = {\n      hash: expect.any(String),\n      path: expect.any(String),\n    };\n\n    expect(\n      printPropertiesAndReceived(properties, received, false),\n    ).toMatchSnapshot();\n  });\n\n  test('only highlight non passing properties', () => {\n    const received = {\n      a: 1,\n      b: 'some string',\n      c: 'another string',\n    };\n    const properties = {\n      a: expect.any(Number),\n      b: expect.any(Number),\n    };\n    expect(\n      printPropertiesAndReceived(properties, received, false),\n    ).toMatchSnapshot();\n  });\n});\n\ndescribe('printSnapshotAndReceived', () => {\n  // Simulate default serialization.\n  const testWithStringify = (\n    expected: unknown,\n    received: unknown,\n    expand: boolean,\n  ): string =>\n    printSnapshotAndReceived(\n      serialize(expected),\n      serialize(received),\n      received,\n      expand,\n    );\n\n  // Simulate custom raw string serialization.\n  const testWithoutStringify = (\n    expected: string,\n    received: string,\n    expand: boolean,\n  ): string => printSnapshotAndReceived(expected, received, received, expand);\n\n  describe('backtick', () => {\n    test('single line expected and received', () => {\n      const expected = 'var foo = `backtick`;';\n      const received = 'var foo = tag`backtick`;';\n\n      expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n    });\n  });\n\n  describe('empty string', () => {\n    test('expected and received single line', () => {\n      const expected = '';\n      const received = 'single line string';\n\n      expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n    });\n\n    test('received and expected multi line', () => {\n      const expected = 'multi\\nline\\nstring';\n      const received = '';\n\n      expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n    });\n  });\n\n  describe('escape', () => {\n    test('double quote marks in string', () => {\n      const expected = 'What does \"oobleck\" mean?';\n      const received = 'What does \"ewbleck\" mean?';\n\n      expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n    });\n\n    test('backslash in multi line string', () => {\n      const expected = 'Forward / slash and back \\\\ slash';\n      const received = 'Forward / slash\\nBack \\\\ slash';\n\n      expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n    });\n\n    test('backslash in single line string', () => {\n      const expected = 'forward / slash and back \\\\ slash';\n      const received = 'Forward / slash and back \\\\ slash';\n\n      expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n    });\n\n    test('regexp', () => {\n      const expected = /\\\\(\")/g;\n      const received = /\\\\(\")/;\n\n      expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n    });\n  });\n\n  describe('expand', () => {\n    // prettier/pull/5272\n    const expected = [\n      'type TypeName<T> =',\n      'T extends string ? \"string\" :',\n      'T extends number ? \"number\" :',\n      'T extends boolean ? \"boolean\" :',\n      'T extends undefined ? \"undefined\" :',\n      'T extends Function ? \"function\" :',\n      '\"object\";',\n      '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~',\n      'type TypeName<T> = T extends string',\n      '? \"string\"',\n      ': T extends number',\n      '? \"number\"',\n      ': T extends boolean',\n      '? \"boolean\"',\n      ': T extends undefined',\n      '? \"undefined\"',\n      ': T extends Function ? \"function\" : \"object\";',\n      '',\n    ].join('\\n');\n    const received = [\n      'type TypeName<T> =',\n      'T extends string ? \"string\" :',\n      'T extends number ? \"number\" :',\n      'T extends boolean ? \"boolean\" :',\n      'T extends undefined ? \"undefined\" :',\n      'T extends Function ? \"function\" :',\n      '\"object\";',\n      '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~',\n      'type TypeName<T> = T extends string',\n      '? \"string\"',\n      ': T extends number',\n      '? \"number\"',\n      ': T extends boolean',\n      '? \"boolean\"',\n      ': T extends undefined',\n      '? \"undefined\"',\n      ': T extends Function',\n      '? \"function\"',\n      ': \"object\";',\n      '',\n    ].join('\\n');\n\n    test('false', () => {\n      expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n    });\n\n    test('true', () => {\n      expect(testWithStringify(expected, received, true)).toMatchSnapshot();\n    });\n  });\n\n  test('fallback to line diff', () => {\n    const expected = [\n      '[...a, ...b,];',\n      '[...a, ...b];',\n      '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~',\n      '[...a, ...b];',\n      '[...a, ...b];',\n      '',\n    ].join('\\n');\n    const received = [\n      '====================================options=====================================',\n      'parsers: [\"flow\", \"typescript\"]',\n      'printWidth: 80',\n      '                                                                                | printWidth',\n      '=====================================input======================================',\n      '[...a, ...b,];',\n      '[...a, ...b];',\n      '',\n      '=====================================output=====================================',\n      '[...a, ...b];',\n      '[...a, ...b];',\n      '',\n      '================================================================================',\n    ].join('\\n');\n\n    expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n  });\n\n  describe('has no common after clean up chaff', () => {\n    test('array', () => {\n      const expected = ['delete', 'two'];\n      const received = ['insert', '2'];\n\n      expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n    });\n\n    test('string single line', () => {\n      const expected = 'delete';\n      const received = 'insert';\n\n      expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n    });\n  });\n\n  describe('MAX_DIFF_STRING_LENGTH', () => {\n    describe('unquoted', () => {\n      // Do not call diffStringsUnified if either string is longer than max.\n      const lessChange = chalk.inverse('single ');\n      const less = 'single line';\n      const more = `multi line${'\\n123456789'.repeat(2000)}`; // 10 + 20K chars\n\n      test('both are less', () => {\n        const less2 = 'multi\\nline';\n        const difference = printSnapshotAndReceived(less2, less, less, true);\n\n        expect(difference).toMatch('- multi');\n        expect(difference).toMatch('- line');\n        expect(difference).toMatch(lessChange);\n        expect(difference).not.toMatch('+ single line');\n      });\n\n      test('expected is more', () => {\n        const difference = printSnapshotAndReceived(more, less, less, true);\n\n        expect(difference).toMatch('- multi line');\n        expect(difference).toMatch('+ single line');\n        expect(difference).not.toMatch(lessChange);\n      });\n\n      test('received is more', () => {\n        const difference = printSnapshotAndReceived(less, more, more, true);\n\n        expect(difference).toMatch('- single line');\n        expect(difference).toMatch('+ multi line');\n        expect(difference).not.toMatch(lessChange);\n      });\n    });\n\n    describe('quoted', () => {\n      // Do not call diffStringsRaw if either string is longer than max.\n      const lessChange = chalk.inverse('no');\n      const less = 'no numbers';\n      const more = `many numbers${' 123456789'.repeat(2000)}`; // 12 + 20K chars\n      const lessQuoted = `\"${less}\"`;\n      const moreQuoted = `\"${more}\"`;\n\n      test('both are less', () => {\n        const lessQuoted2 = '\"0 numbers\"';\n        const stringified = printSnapshotAndReceived(\n          lessQuoted2,\n          lessQuoted,\n          less,\n          true,\n        );\n\n        expect(stringified).toMatch('Received:');\n        expect(stringified).toMatch(lessChange);\n        expect(stringified).not.toMatch('+ Received');\n      });\n\n      test('expected is more', () => {\n        const stringified = printSnapshotAndReceived(\n          moreQuoted,\n          lessQuoted,\n          less,\n          true,\n        );\n\n        expect(stringified).toMatch('Received:');\n        expect(stringified).toMatch(less);\n        expect(stringified).not.toMatch('+ Received');\n        expect(stringified).not.toMatch(lessChange);\n      });\n\n      test('received is more', () => {\n        const stringified = printSnapshotAndReceived(\n          lessQuoted,\n          moreQuoted,\n          more,\n          true,\n        );\n\n        expect(stringified).toMatch('Snapshot:');\n        expect(stringified).toMatch(less);\n        expect(stringified).not.toMatch('- Snapshot');\n        expect(stringified).not.toMatch(lessChange);\n      });\n    });\n  });\n\n  describe('isLineDiffable', () => {\n    describe('false', () => {\n      test('asymmetric matcher', () => {\n        const expected = null;\n        const received = {asymmetricMatch: () => {}};\n\n        expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n      });\n\n      test('boolean', () => {\n        const expected = true;\n        const received = false;\n\n        expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n      });\n\n      test('date', () => {\n        const expected = new Date('2019-09-19');\n        const received = new Date('2019-09-20');\n\n        expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n      });\n\n      test('error', () => {\n        const expected = new Error(\n          'Cannot spread fragment \"NameAndAppearances\" within itself.',\n        );\n        const received = new Error(\n          'Cannot spread fragment \"NameAndAppearancesAndFriends\" within itself.',\n        );\n\n        expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n      });\n\n      test('function', () => {\n        const expected = undefined;\n        const received = () => {};\n\n        expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n      });\n\n      test('number', () => {\n        const expected = -0;\n        const received = Number.NaN;\n\n        expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n      });\n    });\n\n    describe('true', () => {\n      test('array', () => {\n        const expected0 = {\n          code: 4011,\n          weight: 2.13,\n        };\n        const expected1 = {\n          code: 4019,\n          count: 4,\n        };\n\n        const expected = [expected0, expected1];\n        const received = [\n          {_id: 'b14680dec683e744ada1f2fe08614086', ...expected0},\n          {_id: '7fc63ff01769c4fa7d9279e97e307829', ...expected1},\n        ];\n\n        expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n      });\n\n      test('object', () => {\n        const type = 'img';\n        const expected = {\n          props: {\n            className: 'logo',\n            src: '/img/jest.png',\n          },\n          type,\n        };\n        const received = {\n          props: {\n            alt: 'Jest logo',\n            class: 'logo',\n            src: '/img/jest.svg',\n          },\n          type,\n        };\n\n        expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n      });\n\n      test('single line expected and received', () => {\n        const expected: Array<unknown> = [];\n        const received = {};\n\n        expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n      });\n\n      test('single line expected and multi line received', () => {\n        const expected: Array<unknown> = [];\n        const received = [0];\n\n        expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n      });\n    });\n  });\n\n  test('multi line small change in one line and other is unchanged', () => {\n    const expected =\n      \"There is no route defined for key 'Settings'.\\nMust be one of: 'Home'\";\n    const received =\n      \"There is no route defined for key Settings.\\nMust be one of: 'Home'\";\n\n    expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n  });\n\n  test('multi line small changes', () => {\n    const expected = [\n      '    69 | ',\n      \"    70 | test('assert.doesNotThrow', () => {\",\n      '  > 71 |   assert.doesNotThrow(() => {',\n      '       |          ^',\n      \"    72 |     throw Error('err!');\",\n      '    73 |   });',\n      '    74 | });',\n      '    at Object.doesNotThrow (__tests__/assertionError.test.js:71:10)',\n    ].join('\\n');\n    const received = [\n      '    68 | ',\n      \"    69 | test('assert.doesNotThrow', () => {\",\n      '  > 70 |   assert.doesNotThrow(() => {',\n      '       |          ^',\n      \"    71 |     throw Error('err!');\",\n      '    72 |   });',\n      '    73 | });',\n      '    at Object.doesNotThrow (__tests__/assertionError.test.js:70:10)',\n    ].join('\\n');\n\n    expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n  });\n\n  test('single line large changes', () => {\n    const expected = 'Array length must be a finite positive integer';\n    const received = 'Invalid array length';\n\n    expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n  });\n\n  describe('ignore indentation', () => {\n    const $$typeof = Symbol.for('react.test.json');\n\n    test('markup delete', () => {\n      const received = {\n        $$typeof,\n        children: [\n          {\n            $$typeof,\n            children: ['Ignore indentation for most serialized objects'],\n            type: 'h3',\n          },\n          {\n            $$typeof,\n            children: [\n              'Call ',\n              {\n                $$typeof,\n                children: ['diffLinesUnified2'],\n                type: 'code',\n              },\n              ' to compare without indentation',\n            ],\n            type: 'p',\n          },\n        ],\n        type: 'div',\n      };\n      const expected = {\n        $$typeof,\n        children: [received],\n        type: 'div',\n      };\n\n      expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n    });\n\n    test('markup fall back', () => {\n      // Because text has more than one adjacent line.\n      const text = [\n        'for (key in foo) {',\n        '  if (Object.prototype.hasOwnProperty.call(foo, key)) {',\n        '    doSomething(key);',\n        '  }',\n        '}',\n      ].join('\\n');\n\n      const expected = {\n        $$typeof,\n        children: [text],\n        props: {\n          className: 'language-js',\n        },\n        type: 'pre',\n      };\n      const received = {\n        $$typeof,\n        children: [expected],\n        type: 'div',\n      };\n\n      expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n    });\n\n    test('markup insert', () => {\n      const text = 'when';\n      const expected = {\n        $$typeof,\n        children: [text],\n        type: 'th',\n      };\n      const received = {\n        $$typeof,\n        children: [\n          {\n            $$typeof,\n            children: [text],\n            type: 'span',\n          },\n          {\n            $$typeof,\n            children: ['↓'],\n            props: {\n              title: 'ascending from older to newer',\n            },\n            type: 'abbr',\n          },\n        ],\n        type: 'th',\n      };\n\n      expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n    });\n\n    describe('object', () => {\n      const text = 'Ignore indentation in snapshot';\n      const time = '2019-11-11';\n      const type = 'CREATE_ITEM';\n      const less = {\n        text,\n        time,\n        type,\n      };\n      const more = {\n        payload: {\n          text,\n          time,\n        },\n        type,\n      };\n\n      test('delete', () => {\n        expect(testWithStringify(more, less, false)).toMatchSnapshot();\n      });\n\n      test('insert', () => {\n        expect(testWithStringify(less, more, false)).toMatchSnapshot();\n      });\n    });\n  });\n\n  describe('without serialize', () => {\n    test('backtick single line expected and received', () => {\n      const expected = 'var foo = `backtick`;';\n      const received = 'var foo = `back${x}tick`;';\n\n      expect(testWithoutStringify(expected, received, false)).toMatchSnapshot();\n    });\n\n    test('backtick single line expected and multi line received', () => {\n      const expected = 'var foo = `backtick`;';\n      const received = 'var foo = `back\\ntick`;';\n\n      expect(testWithoutStringify(expected, received, false)).toMatchSnapshot();\n    });\n\n    test('has no common after clean up chaff multi line', () => {\n      const expected = 'delete\\ntwo';\n      const received = 'insert\\n2';\n\n      expect(testWithoutStringify(expected, received, false)).toMatchSnapshot();\n    });\n\n    test('has no common after clean up chaff single line', () => {\n      const expected = 'delete';\n      const received = 'insert';\n\n      expect(testWithoutStringify(expected, received, false)).toMatchSnapshot();\n    });\n\n    test('prettier/pull/5590', () => {\n      const expected = [\n        '====================================options=====================================',\n        'parsers: [\"html\"]',\n        'printWidth: 80',\n        '                                                                                | printWidth',\n        '=====================================input======================================',\n        '<img src=\"test.png\" alt=\\'John \"ShotGun\" Nelson\\'>',\n        '',\n        '=====================================output=====================================',\n        '<img src=\"test.png\" alt=\"John &quot;ShotGun&quot; Nelson\" />',\n        '',\n        '================================================================================',\n      ].join('\\n');\n      const received = [\n        '====================================options=====================================',\n        'parsers: [\"html\"]',\n        'printWidth: 80',\n        '                                                                                | printWidth',\n        '=====================================input======================================',\n        '<img src=\"test.png\" alt=\\'John \"ShotGun\" Nelson\\'>',\n        '',\n        '=====================================output=====================================',\n        '<img src=\"test.png\" alt=\\'John \"ShotGun\" Nelson\\' />',\n        '',\n        '================================================================================',\n      ].join('\\n');\n\n      expect(testWithoutStringify(expected, received, false)).toMatchSnapshot();\n    });\n  });\n});\n",
  "packages/jest-snapshot/src/__tests__/printSnapshot.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-snapshot/src/__tests__/plugins.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {Plugin} from 'pretty-format';\n\nbeforeEach(() => {\n  jest.resetModules();\n});\n\nconst testPath = (names: Array<string>) => {\n  const {addSerializer, getSerializers} =\n    require('../plugins') as typeof import('../plugins');\n  const prev = getSerializers();\n  const added = names.map(\n    name => require(require.resolve(`./plugins/${name}`)) as Plugin,\n  );\n\n  // Jest tests snapshotSerializers in order preceding built-in serializers.\n  // Therefore, add in reverse because the last added is the first tested.\n  for (const serializer of [...added].reverse()) addSerializer(serializer);\n\n  const next = getSerializers();\n  expect(next).toHaveLength(added.length + prev.length);\n  expect(next).toEqual([...added, ...prev]);\n};\n\nit('gets plugins', () => {\n  const {getSerializers} = require('../plugins') as typeof import('../plugins');\n  const plugins = getSerializers();\n  expect(plugins).toHaveLength(5);\n});\n\nit('adds plugins from an empty array', () => testPath([]));\nit('adds a single plugin path', () => testPath(['foo']));\nit('adds multiple plugin paths', () => testPath(['foo', 'bar']));\n",
  "packages/jest-snapshot/src/__tests__/plugins.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-snapshot/src/__tests__/mockSerializer.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {format as prettyFormat} from 'pretty-format';\nimport plugin from '../mockSerializer';\n\ntest('mock with 0 calls and default name', () => {\n  const fn = jest.fn();\n  expect(fn).toMatchSnapshot();\n});\n\ntest('mock with 2 calls, 1 return, 1 throw', () => {\n  const fn = jest.fn((value: number) => {\n    if (value % 2 === 0) {\n      return value * 2;\n    } else {\n      throw new Error('Error Message!');\n    }\n  });\n\n  fn(2);\n\n  try {\n    fn(3);\n  } catch {\n    // ignore error\n  }\n\n  expect(fn).toMatchSnapshot();\n});\n\ntest('mock with 0 calls and default name in React element', () => {\n  const fn = jest.fn();\n  const val = {\n    $$typeof: Symbol.for('react.test.json'),\n    children: ['Mock me!'],\n    props: {\n      onClick: fn,\n    },\n    type: 'button',\n  };\n  expect(val).toMatchSnapshot();\n});\n\ntest('mock with 0 calls and non-default name', () => {\n  const fn = jest.fn();\n  fn.mockName('MyConstructor');\n  expect(fn).toMatchSnapshot();\n});\n\ntest('mock with 1 calls and non-default name via new in object', () => {\n  const fn = jest.fn();\n  fn.mockName('MyConstructor');\n  // eslint-disable-next-line no-new\n  new fn({name: 'some fine name'});\n  const val = {\n    fn,\n  };\n  expect(val).toMatchSnapshot();\n});\n\ntest('mock with 1 calls in React element', () => {\n  const fn = jest.fn();\n  fn('Mocking you!');\n  const val = {\n    $$typeof: Symbol.for('react.test.json'),\n    children: ['Mock me!'],\n    props: {\n      onClick: fn,\n    },\n    type: 'button',\n  };\n  expect(val).toMatchSnapshot();\n});\n\ntest('mock with 2 calls', () => {\n  const fn = jest.fn();\n  fn();\n  fn({foo: 'bar'}, 42);\n  expect(fn).toMatchSnapshot();\n});\n\ntest('indent option', () => {\n  const fn = jest.fn((val: {key: string}) => val);\n  fn({key: 'value'});\n  const expected = [\n    '[MockFunction] {',\n    '\"calls\": Array [',\n    'Array [',\n    'Object {',\n    '\"key\": \"value\",',\n    '},',\n    '],',\n    '],',\n    '\"results\": Array [',\n    'Object {',\n    '\"type\": \"return\",',\n    '\"value\": Object {',\n    '\"key\": \"value\",',\n    '},',\n    '},',\n    '],',\n    '}',\n  ].join('\\n');\n  expect(prettyFormat(fn, {indent: 0, plugins: [plugin]})).toBe(expected);\n});\n\ntest('min option', () => {\n  const fn = jest.fn((val: {key: string}) => val);\n  fn({key: 'value'});\n  const expected =\n    '[MockFunction] {\"calls\": [[{\"key\": \"value\"}]], \"results\": [{\"type\": \"return\", \"value\": {\"key\": \"value\"}}]}';\n  expect(prettyFormat(fn, {min: true, plugins: [plugin]})).toBe(expected);\n});\n\ntest('maxDepth option', () => {\n  const fn1 = jest.fn();\n  fn1.mockName('atDepth1');\n  fn1('primitive', {key: 'value'});\n  const fn2 = jest.fn();\n  fn2.mockName('atDepth2');\n  fn2('primitive', {key: 'value'});\n  const fn3 = jest.fn();\n  fn3.mockName('atDepth3');\n  fn3('primitive', {key: 'value'});\n  const val = {\n    fn1,\n    greaterThan1: {\n      fn2,\n      greaterThan2: {\n        fn3,\n      },\n    },\n  };\n  const expected = [\n    'Object {', // ++depth === 1\n    '  \"fn1\": [MockFunction atDepth1] {',\n    '    \"calls\": Array [', // ++depth === 2\n    '      Array [', // ++depth === 3\n    '        \"primitive\",',\n    '        [Object],', // ++depth === 4\n    '      ],',\n    '    ],',\n    '    \"results\": Array [', // ++depth === 2\n    '      Object {', // ++depth === 3\n    '        \"type\": \"return\",',\n    '        \"value\": undefined,',\n    '      },',\n    '    ],',\n    '  },',\n    '  \"greaterThan1\": Object {', // ++depth === 2\n    '    \"fn2\": [MockFunction atDepth2] {',\n    '      \"calls\": Array [', // ++depth === 3\n    '        [Array],', // ++depth === 4\n    '      ],',\n    '      \"results\": Array [', // ++depth === 3\n    '        [Object],', // ++depth === 4\n    '      ],',\n    '    },',\n    '    \"greaterThan2\": Object {', // ++depth === 3\n    '      \"fn3\": [MockFunction atDepth3] {',\n    '        \"calls\": [Array],', // ++depth === 4\n    '        \"results\": [Array],', // ++depth === 4\n    '      },',\n    '    },',\n    '  },',\n    '}',\n  ].join('\\n');\n  expect(prettyFormat(val, {maxDepth: 3, plugins: [plugin]})).toBe(expected);\n});\n",
  "packages/jest-snapshot/src/__tests__/mockSerializer.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-snapshot/src/__tests__/matcher.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {type Context, toMatchSnapshot} from '../';\n\ntest('returns matcher name, expected and actual values', () => {\n  const mockedContext = {\n    snapshotState: {\n      match: () => ({actual: 'a', expected: 'b'}),\n    },\n  } as unknown as Context;\n\n  const matcherResult = toMatchSnapshot.call(mockedContext, {\n    a: 1,\n  });\n\n  expect(matcherResult).toEqual(\n    expect.objectContaining({\n      actual: 'a',\n      expected: 'b',\n      name: 'toMatchSnapshot',\n    }),\n  );\n});\n",
  "packages/jest-snapshot/src/__tests__/matcher.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-snapshot/src/__tests__/dedentLines.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {plugins as builtinPlugins, format} from 'pretty-format';\nimport {dedentLines} from '../dedentLines';\n\nconst $$typeof = Symbol.for('react.test.json');\nconst plugins = [builtinPlugins.ReactTestComponent];\n\nconst formatLines2 = (val: unknown) =>\n  format(val, {indent: 2, plugins}).split('\\n');\nconst formatLines0 = (val: unknown) =>\n  format(val, {indent: 0, plugins}).split('\\n');\n\ndescribe('dedentLines non-null', () => {\n  test('no lines', () => {\n    const indented: Array<string> = [];\n    const dedented = indented;\n\n    expect(dedentLines(indented)).toEqual(dedented);\n  });\n\n  test('one line empty string', () => {\n    const indented = [''];\n    const dedented = indented;\n\n    expect(dedentLines(indented)).toEqual(dedented);\n  });\n\n  test('one line empty object', () => {\n    const val = {};\n    const indented = formatLines2(val);\n    const dedented = formatLines0(val);\n\n    expect(dedentLines(indented)).toEqual(dedented);\n  });\n\n  test('one line self-closing element', () => {\n    const val = {\n      $$typeof,\n      children: null,\n      type: 'br',\n    };\n    const indented = formatLines2(val);\n    const dedented = formatLines0(val);\n\n    expect(dedentLines(indented)).toEqual(dedented);\n  });\n\n  test('object value empty string', () => {\n    const val = {\n      key: '',\n    };\n    const indented = formatLines2(val);\n    const dedented = formatLines0(val);\n\n    expect(dedentLines(indented)).toEqual(dedented);\n  });\n\n  test('object value string includes double-quote marks', () => {\n    const val = {\n      key: '\"Always bet on JavaScript\",',\n    };\n    const indented = formatLines2(val);\n    const dedented = formatLines0(val);\n\n    expect(dedentLines(indented)).toEqual(dedented);\n  });\n\n  test('markup with props and text', () => {\n    const val = {\n      $$typeof,\n      children: [\n        {\n          $$typeof,\n          props: {\n            alt: 'Jest logo',\n            src: 'jest.svg',\n          },\n          type: 'img',\n        },\n        {\n          $$typeof,\n          children: ['Delightful JavaScript testing'],\n          type: 'h2',\n        },\n      ],\n      type: 'header',\n    };\n    const indented = formatLines2(val);\n    const dedented = formatLines0(val);\n\n    expect(dedentLines(indented)).toEqual(dedented);\n  });\n\n  test('markup with components as props', () => {\n    // https://daveceddia.com/pluggable-slots-in-react-components/\n    const val = {\n      $$typeof,\n      children: null,\n      props: {\n        content: {\n          $$typeof,\n          children: ['main content here'],\n          type: 'Content',\n        },\n        sidebar: {\n          $$typeof,\n          children: null,\n          props: {\n            user: '0123456789abcdef',\n          },\n          type: 'UserStats',\n        },\n      },\n      type: 'Body',\n    };\n    const indented = formatLines2(val);\n    const dedented = formatLines0(val);\n\n    expect(dedentLines(indented)).toEqual(dedented);\n  });\n});\n\ndescribe('dedentLines null', () => {\n  test.each([\n    ['object key multi-line', {'multi\\nline\\nkey': false}],\n    ['object value multi-line', {key: 'multi\\nline\\nvalue'}],\n    ['object key and value multi-line', {'multi\\nline': '\\nleading nl'}],\n  ])('%s', (_name, val) => {\n    expect(dedentLines(formatLines2(val))).toBeNull();\n  });\n\n  test('markup prop multi-line', () => {\n    const val = {\n      $$typeof,\n      children: null,\n      props: {\n        alt: 'trailing newline\\n',\n        src: 'jest.svg',\n      },\n      type: 'img',\n    };\n    const indented = formatLines2(val);\n\n    expect(dedentLines(indented)).toBeNull();\n  });\n\n  test('markup prop component with multi-line text', () => {\n    // https://daveceddia.com/pluggable-slots-in-react-components/\n    const val = {\n      $$typeof,\n      children: [\n        {\n          $$typeof,\n          children: null,\n          props: {\n            content: {\n              $$typeof,\n              children: ['\\n'],\n              type: 'Content',\n            },\n            sidebar: {\n              $$typeof,\n              children: null,\n              props: {\n                user: '0123456789abcdef',\n              },\n              type: 'UserStats',\n            },\n          },\n          type: 'Body',\n        },\n      ],\n      type: 'main',\n    };\n    const indented = formatLines2(val);\n\n    expect(dedentLines(indented)).toBeNull();\n  });\n\n  test('markup text multi-line', () => {\n    const text = [\n      'for (key in foo) {',\n      '  if (Object.prototype.hasOwnProperty.call(foo, key)) {',\n      '    doSomething(key);',\n      '  }',\n      '}',\n    ].join('\\n');\n    const val = {\n      $$typeof,\n      children: [\n        {\n          $$typeof,\n          children: [text],\n          props: {\n            className: 'language-js',\n          },\n          type: 'pre',\n        },\n      ],\n      type: 'div',\n    };\n    const indented = formatLines2(val);\n\n    expect(dedentLines(indented)).toBeNull();\n  });\n\n  test('markup text multiple lines', () => {\n    const lines = [\n      'for (key in foo) {',\n      '  if (Object.prototype.hasOwnProperty.call(foo, key)) {',\n      '    doSomething(key);',\n      '  }',\n      '}',\n    ];\n    const val = {\n      $$typeof,\n      children: [\n        {\n          $$typeof,\n          children: lines,\n          props: {\n            className: 'language-js',\n          },\n          type: 'pre',\n        },\n      ],\n      type: 'div',\n    };\n    const indented = formatLines2(val);\n\n    expect(dedentLines(indented)).toBeNull();\n  });\n\n  test('markup unclosed self-closing start tag', () => {\n    const indented = ['<img', '  alt=\"Jest logo\"', '  src=\"jest.svg\"'];\n\n    expect(dedentLines(indented)).toBeNull();\n  });\n\n  test('markup unclosed because no end tag', () => {\n    const indented = ['<p>', '  Delightful JavaScript testing'];\n\n    expect(dedentLines(indented)).toBeNull();\n  });\n});\n",
  "packages/jest-snapshot/src/__tests__/dedentLines.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-snapshot/src/__tests__/SnapshotResolver.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {makeProjectConfig} from '@jest/test-utils';\nimport {\n  type SnapshotResolver,\n  buildSnapshotResolver,\n} from '../SnapshotResolver';\n\ndescribe('defaults', () => {\n  let snapshotResolver: SnapshotResolver;\n  const projectConfig = makeProjectConfig({\n    rootDir: 'default',\n    // snapshotResolver: null,\n  });\n\n  beforeEach(async () => {\n    snapshotResolver = await buildSnapshotResolver(projectConfig);\n  });\n\n  it('returns cached object if called multiple times', async () => {\n    await expect(buildSnapshotResolver(projectConfig)).resolves.toBe(\n      snapshotResolver,\n    );\n  });\n\n  it('resolveSnapshotPath()', () => {\n    expect(snapshotResolver.resolveSnapshotPath('/abc/cde/a.test.js')).toBe(\n      path.join('/abc', 'cde', '__snapshots__', 'a.test.js.snap'),\n    );\n  });\n\n  it('resolveTestPath()', () => {\n    expect(\n      snapshotResolver.resolveTestPath('/abc/cde/__snapshots__/a.test.js.snap'),\n    ).toBe(path.resolve('/abc/cde/a.test.js'));\n  });\n});\n\ndescribe('custom resolver in project config', () => {\n  let snapshotResolver: SnapshotResolver;\n  const customSnapshotResolverFile = path.join(\n    __dirname,\n    'fixtures',\n    'customSnapshotResolver.js',\n  );\n  const projectConfig = makeProjectConfig({\n    rootDir: 'custom1',\n    snapshotResolver: customSnapshotResolverFile,\n  });\n\n  beforeEach(async () => {\n    snapshotResolver = await buildSnapshotResolver(projectConfig);\n  });\n\n  it('returns cached object if called multiple times', async () => {\n    await expect(buildSnapshotResolver(projectConfig)).resolves.toBe(\n      snapshotResolver,\n    );\n  });\n\n  it('resolveSnapshotPath()', () => {\n    expect(\n      snapshotResolver.resolveSnapshotPath(\n        path.resolve('/abc/cde/__tests__/a.test.js'),\n      ),\n    ).toBe(path.resolve('/abc/cde/__snapshots__/a.test.js.snap'));\n  });\n\n  it('resolveTestPath()', () => {\n    expect(\n      snapshotResolver.resolveTestPath(\n        path.resolve('/abc', 'cde', '__snapshots__', 'a.test.js.snap'),\n      ),\n    ).toBe(path.resolve('/abc/cde/__tests__/a.test.js'));\n  });\n});\n\ndescribe('malformed custom resolver in project config', () => {\n  const newProjectConfig = (filename: string) => {\n    const customSnapshotResolverFile = path.join(\n      __dirname,\n      'fixtures',\n      filename,\n    );\n    return makeProjectConfig({\n      rootDir: 'missing-resolveSnapshotPath',\n      snapshotResolver: customSnapshotResolverFile,\n    });\n  };\n\n  it('missing resolveSnapshotPath throws ', async () => {\n    const projectConfig = newProjectConfig(\n      'customSnapshotResolver-missing-resolveSnapshotPath.js',\n    );\n    await expect(\n      buildSnapshotResolver(projectConfig),\n    ).rejects.toThrowErrorMatchingSnapshot();\n  });\n\n  it('missing resolveTestPath throws ', async () => {\n    const projectConfig = newProjectConfig(\n      'customSnapshotResolver-missing-resolveTestPath.js',\n    );\n    await expect(\n      buildSnapshotResolver(projectConfig),\n    ).rejects.toThrowErrorMatchingSnapshot();\n  });\n\n  it('missing testPathForConsistencyCheck throws ', async () => {\n    const projectConfig = newProjectConfig(\n      'customSnapshotResolver-missing-test-path-for-consistency-check.js',\n    );\n    await expect(\n      buildSnapshotResolver(projectConfig),\n    ).rejects.toThrowErrorMatchingSnapshot();\n  });\n\n  it('inconsistent functions throws ', async () => {\n    const projectConfig = newProjectConfig(\n      'customSnapshotResolver-inconsistent-fns.js',\n    );\n    await expect(\n      buildSnapshotResolver(projectConfig),\n    ).rejects.toThrowErrorMatchingSnapshot();\n  });\n});\n",
  "packages/jest-snapshot/src/__tests__/SnapshotResolver.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-snapshot/src/__tests__/InlineSnapshots.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport * as fs from 'graceful-fs';\nimport type {Frame} from 'jest-message-util';\nimport {saveInlineSnapshots} from '../InlineSnapshots';\n\nconst prettier = require('prettier') as typeof import('prettier-v2');\n\njest.mock('prettier', () => {\n  const realPrettier =\n    jest.requireActual<typeof import('prettier-v2')>('prettier-v2');\n  const mockPrettier = {\n    format: realPrettier.format,\n    getFileInfo: {\n      sync: () => ({ignored: false, inferredParser: 'babel'}),\n    } as unknown as typeof prettier.getFileInfo,\n    resolveConfig: {\n      sync: jest.fn(),\n    } as unknown as typeof prettier.resolveConfig,\n    version: realPrettier.version,\n  } as typeof prettier;\n  return mockPrettier;\n});\n\nbeforeEach(() => {\n  jest.mocked(prettier.resolveConfig.sync).mockReset();\n});\n\nlet dir: string;\nbeforeEach(() => {\n  dir = path.join(tmpdir(), `jest-inline-snapshot-test-${Date.now()}`);\n  fs.mkdirSync(dir);\n});\n\nafterEach(() => {\n  fs.rmSync(dir, {recursive: true});\n});\n\ntest('saveInlineSnapshots() replaces empty function call with a template literal', () => {\n  const filename = path.join(dir, 'my.test.js');\n  fs.writeFileSync(filename, 'expect(1).toMatchInlineSnapshot();\\n');\n\n  saveInlineSnapshots(\n    [\n      {\n        frame: {column: 11, file: filename, line: 1} as Frame,\n        snapshot: '1',\n      },\n    ],\n    dir,\n    'prettier',\n  );\n\n  expect(fs.readFileSync(filename, 'utf8')).toBe(\n    'expect(1).toMatchInlineSnapshot(`1`);\\n',\n  );\n});\n\ntest('saveInlineSnapshots() without prettier leaves formatting outside of snapshots alone', () => {\n  const filename = path.join(dir, 'my.test.js');\n  fs.writeFileSync(\n    filename,\n    `${`\nconst a = [1,            2];\nexpect(a).toMatchInlineSnapshot(\\`an out-of-date and also multi-line\nsnapshot\\`);\nexpect(a).toMatchInlineSnapshot();\nexpect(a).toMatchInlineSnapshot(\\`[1, 2]\\`);\n`.trim()}\\n`,\n  );\n\n  saveInlineSnapshots(\n    [2, 4, 5].map(line => ({\n      frame: {column: 11, file: filename, line} as Frame,\n      snapshot: '[1, 2]',\n    })),\n    dir,\n    null,\n  );\n\n  expect(fs.readFileSync(filename, 'utf8')).toBe(\n    `const a = [1,            2];\nexpect(a).toMatchInlineSnapshot(\\`[1, 2]\\`);\nexpect(a).toMatchInlineSnapshot(\\`[1, 2]\\`);\nexpect(a).toMatchInlineSnapshot(\\`[1, 2]\\`);\n`,\n  );\n});\n\ntest('saveInlineSnapshots() with bad prettier path leaves formatting outside of snapshots alone', () => {\n  const filename = path.join(dir, 'my.test.js');\n  fs.writeFileSync(\n    filename,\n    `${`\nconst a = [1,            2];\nexpect(a).toMatchInlineSnapshot(\\`an out-of-date and also multi-line\nsnapshot\\`);\nexpect(a).toMatchInlineSnapshot();\nexpect(a).toMatchInlineSnapshot(\\`[1, 2]\\`);\n`.trim()}\\n`,\n  );\n\n  saveInlineSnapshots(\n    [2, 4, 5].map(line => ({\n      frame: {column: 11, file: filename, line} as Frame,\n      snapshot: '[1, 2]',\n    })),\n    dir,\n    'bad-prettier',\n  );\n\n  expect(fs.readFileSync(filename, 'utf8')).toBe(\n    `const a = [1,            2];\nexpect(a).toMatchInlineSnapshot(\\`[1, 2]\\`);\nexpect(a).toMatchInlineSnapshot(\\`[1, 2]\\`);\nexpect(a).toMatchInlineSnapshot(\\`[1, 2]\\`);\n`,\n  );\n});\n\ntest.each([['ts'], ['cts'], ['mts']])(\n  'saveInlineSnapshots() can handle typescript without prettier - %s extension',\n  extension => {\n    const filename = path.join(dir, `my.test.${extension}`);\n    fs.writeFileSync(\n      filename,\n      `${`\ninterface Foo {\n  foo: string\n}\nconst a: [Foo, Foo] = [{ foo: 'one' },            { foo: 'two' }];\nexpect(a).toMatchInlineSnapshot();\n`.trim()}\\n`,\n    );\n\n    saveInlineSnapshots(\n      [\n        {\n          frame: {column: 11, file: filename, line: 5} as Frame,\n          snapshot: \"[{ foo: 'one' }, { foo: 'two' }]\",\n        },\n      ],\n      dir,\n      null,\n    );\n\n    expect(fs.readFileSync(filename, 'utf8')).toBe(\n      `${`\ninterface Foo {\n  foo: string\n}\nconst a: [Foo, Foo] = [{ foo: 'one' },            { foo: 'two' }];\nexpect(a).toMatchInlineSnapshot(\\`[{ foo: 'one' }, { foo: 'two' }]\\`);\n`.trim()}\\n`,\n    );\n  },\n);\n\ntest('saveInlineSnapshots() can handle tsx without prettier', () => {\n  const filename = path.join(dir, 'my.test.tsx');\n  fs.writeFileSync(\n    filename,\n    `${`\nit('foos', async () => {\n  const Foo = (props: { foo: string }) => <div>{props.foo}</div>;\n  const a = await Foo({ foo: \"hello\" });\n  expect(a).toMatchInlineSnapshot();\n})\n`.trim()}\\n`,\n  );\n\n  saveInlineSnapshots(\n    [\n      {\n        frame: {column: 13, file: filename, line: 4} as Frame,\n        snapshot: '<div>hello</div>',\n      },\n    ],\n    dir,\n    null,\n  );\n\n  expect(fs.readFileSync(filename, 'utf8')).toBe(\n    `${`\nit('foos', async () => {\n  const Foo = (props: { foo: string }) => <div>{props.foo}</div>;\n  const a = await Foo({ foo: \"hello\" });\n  expect(a).toMatchInlineSnapshot(\\`<div>hello</div>\\`);\n})\n`.trim()}\\n`,\n  );\n});\n\ntest('saveInlineSnapshots() can handle flow and jsx without prettier', () => {\n  const filename = path.join(dir, 'my.test.js');\n  fs.writeFileSync(\n    filename,\n    `${`\nconst Foo = (props: { foo: string }) => <div>{props.foo}</div>;\nconst a = Foo({ foo: \"hello\" });\nexpect(a).toMatchInlineSnapshot();\n`.trim()}\\n`,\n  );\n  fs.writeFileSync(\n    path.join(dir, '.babelrc'),\n    JSON.stringify({\n      presets: [\n        require.resolve('@babel/preset-flow'),\n        require.resolve('@babel/preset-react'),\n      ],\n    }),\n  );\n\n  saveInlineSnapshots(\n    [\n      {\n        frame: {column: 11, file: filename, line: 3} as Frame,\n        snapshot: '<div>hello</div>',\n      },\n    ],\n    dir,\n    null,\n  );\n\n  expect(fs.readFileSync(filename, 'utf8')).toBe(\n    `${`\nconst Foo = (props: { foo: string }) => <div>{props.foo}</div>;\nconst a = Foo({ foo: \"hello\" });\nexpect(a).toMatchInlineSnapshot(\\`<div>hello</div>\\`);\n`.trim()}\\n`,\n  );\n});\n\ntest('saveInlineSnapshots() can use prettier to fix formatting for whole file', () => {\n  const filename = path.join(dir, 'my.test.js');\n  fs.writeFileSync(\n    filename,\n    `${`\nconst a = [1,            2];\nexpect(a).toMatchInlineSnapshot(\\`an out-of-date and also multi-line\nsnapshot\\`);\nexpect(a).toMatchInlineSnapshot();\nexpect(a).toMatchInlineSnapshot(\\`[1, 2]\\`);\n`.trim()}\\n`,\n  );\n\n  saveInlineSnapshots(\n    [2, 4, 5].map(line => ({\n      frame: {column: 11, file: filename, line} as Frame,\n      snapshot: '[1, 2]',\n    })),\n    dir,\n    'prettier',\n  );\n\n  expect(fs.readFileSync(filename, 'utf8')).toBe(\n    `const a = [1, 2];\nexpect(a).toMatchInlineSnapshot(\\`[1, 2]\\`);\nexpect(a).toMatchInlineSnapshot(\\`[1, 2]\\`);\nexpect(a).toMatchInlineSnapshot(\\`[1, 2]\\`);\n`,\n  );\n});\n\ntest.each([['babel'], ['flow'], ['typescript']])(\n  'saveInlineSnapshots() replaces existing template literal - %s parser',\n  parser => {\n    const filename = path.join(dir, 'my.test.js');\n    fs.writeFileSync(filename, 'expect(1).toMatchInlineSnapshot(`2`);\\n');\n\n    jest.mocked(prettier.resolveConfig.sync).mockReturnValue({parser});\n\n    saveInlineSnapshots(\n      [\n        {\n          frame: {column: 11, file: filename, line: 1} as Frame,\n          snapshot: '1',\n        },\n      ],\n      dir,\n      'prettier',\n    );\n\n    expect(\n      jest.mocked(prettier.resolveConfig.sync).mock.results[0].value,\n    ).toEqual({parser});\n\n    expect(fs.readFileSync(filename, 'utf8')).toBe(\n      'expect(1).toMatchInlineSnapshot(`1`);\\n',\n    );\n  },\n);\n\ntest('saveInlineSnapshots() replaces existing template literal with property matchers', () => {\n  const filename = path.join(dir, 'my.test.js');\n  fs.writeFileSync(filename, 'expect(1).toMatchInlineSnapshot({}, `2`);\\n');\n\n  saveInlineSnapshots(\n    [\n      {\n        frame: {column: 11, file: filename, line: 1} as Frame,\n        snapshot: '1',\n      },\n    ],\n    dir,\n    'prettier',\n  );\n\n  expect(fs.readFileSync(filename, 'utf8')).toBe(\n    'expect(1).toMatchInlineSnapshot({}, `1`);\\n',\n  );\n});\n\ntest.each(['prettier', null])(\n  'saveInlineSnapshots() creates template literal with property matchers',\n  prettierModule => {\n    const filename = path.join(dir, 'my.test.js');\n    fs.writeFileSync(filename, 'expect(1).toMatchInlineSnapshot({});\\n');\n\n    saveInlineSnapshots(\n      [\n        {\n          frame: {column: 11, file: filename, line: 1} as Frame,\n          snapshot: '1',\n        },\n      ],\n      dir,\n      prettierModule,\n    );\n\n    expect(fs.readFileSync(filename, 'utf8')).toBe(\n      'expect(1).toMatchInlineSnapshot({}, `1`);\\n',\n    );\n  },\n);\n\ntest('saveInlineSnapshots() throws if frame does not match', () => {\n  const filename = path.join(dir, 'my.test.js');\n  fs.writeFileSync(filename, 'expect(1).toMatchInlineSnapshot();\\n');\n\n  const save = () =>\n    saveInlineSnapshots(\n      [\n        {\n          frame: {\n            column: 2 /* incorrect */,\n            file: filename,\n            line: 1,\n          } as Frame,\n          snapshot: '1',\n        },\n      ],\n      dir,\n      'prettier',\n    );\n\n  expect(save).toThrow(/Couldn't locate all inline snapshots./);\n});\n\ntest('saveInlineSnapshots() throws if multiple calls to to the same location', () => {\n  const filename = path.join(dir, 'my.test.js');\n  fs.writeFileSync(filename, 'expect(1).toMatchInlineSnapshot();\\n');\n\n  const frame = {column: 11, file: filename, line: 1} as Frame;\n  const save = () =>\n    saveInlineSnapshots(\n      [\n        {frame, snapshot: '1'},\n        {frame, snapshot: '2'},\n      ],\n      dir,\n      'prettier',\n    );\n\n  expect(save).toThrow(\n    /Multiple inline snapshots for the same call are not supported./,\n  );\n});\n\ntest('saveInlineSnapshots() uses escaped backticks', () => {\n  const filename = path.join(dir, 'my.test.js');\n  fs.writeFileSync(filename, 'expect(\"`\").toMatchInlineSnapshot();\\n');\n\n  const frame = {column: 13, file: filename, line: 1} as Frame;\n  saveInlineSnapshots([{frame, snapshot: '`'}], dir, 'prettier');\n\n  expect(fs.readFileSync(filename, 'utf8')).toBe(\n    'expect(\"`\").toMatchInlineSnapshot(`\\\\``);\\n',\n  );\n});\n\ntest('saveInlineSnapshots() works with non-literals in expect call', () => {\n  const filename = path.join(dir, 'my.test.js');\n  fs.writeFileSync(filename, \"expect({a: 'a'}).toMatchInlineSnapshot();\\n\");\n  jest.mocked(prettier.resolveConfig.sync).mockReturnValue({\n    bracketSpacing: false,\n    singleQuote: true,\n  });\n\n  saveInlineSnapshots(\n    [\n      {\n        frame: {column: 18, file: filename, line: 1} as Frame,\n        snapshot: \"{a: 'a'}\",\n      },\n    ],\n    dir,\n    'prettier',\n  );\n\n  expect(fs.readFileSync(filename, 'utf8')).toBe(\n    \"expect({a: 'a'}).toMatchInlineSnapshot(`{a: 'a'}`);\\n\",\n  );\n});\n\ntest('saveInlineSnapshots() indents multi-line snapshots with spaces', () => {\n  const filename = path.join(dir, 'my.test.js');\n  fs.writeFileSync(\n    filename,\n    \"it('is a test', () => {\\n\" +\n      \"  expect({a: 'a'}).toMatchInlineSnapshot();\\n\" +\n      '});\\n',\n  );\n  jest.mocked(prettier.resolveConfig.sync).mockReturnValue({\n    bracketSpacing: false,\n    singleQuote: true,\n  });\n\n  saveInlineSnapshots(\n    [\n      {\n        frame: {column: 20, file: filename, line: 2} as Frame,\n        snapshot: \"\\nObject {\\n  a: 'a'\\n}\\n\",\n      },\n    ],\n    dir,\n    'prettier',\n  );\n\n  expect(fs.readFileSync(filename, 'utf8')).toBe(\n    \"it('is a test', () => {\\n\" +\n      \"  expect({a: 'a'}).toMatchInlineSnapshot(`\\n\" +\n      '    Object {\\n' +\n      \"      a: 'a'\\n\" +\n      '    }\\n' +\n      '  `);\\n' +\n      '});\\n',\n  );\n});\n\ntest('saveInlineSnapshots() does not re-indent error snapshots', () => {\n  const filename = path.join(dir, 'my.test.js');\n  fs.writeFileSync(\n    filename,\n    \"it('is an error test', () => {\\n\" +\n      '  expect(() => {\\n' +\n      \"    throw new Error(['a', 'b'].join('\\\\n'));\\n\" +\n      '  }).toThrowErrorMatchingInlineSnapshot(`\\n' +\n      '    \"a\\n' +\n      '    b\"\\n' +\n      '  `);\\n' +\n      '});\\n' +\n      \"it('is another test', () => {\\n\" +\n      \"  expect({a: 'a'}).toMatchInlineSnapshot();\\n\" +\n      '});\\n',\n  );\n  jest.mocked(prettier.resolveConfig.sync).mockReturnValue({\n    bracketSpacing: false,\n    singleQuote: true,\n  });\n\n  saveInlineSnapshots(\n    [\n      {\n        frame: {column: 20, file: filename, line: 10} as Frame,\n        snapshot: \"\\nObject {\\n  a: 'a'\\n}\\n\",\n      },\n    ],\n    dir,\n    'prettier',\n  );\n\n  expect(fs.readFileSync(filename, 'utf8')).toBe(\n    \"it('is an error test', () => {\\n\" +\n      '  expect(() => {\\n' +\n      \"    throw new Error(['a', 'b'].join('\\\\n'));\\n\" +\n      '  }).toThrowErrorMatchingInlineSnapshot(`\\n' +\n      '    \"a\\n' +\n      '    b\"\\n' +\n      '  `);\\n' +\n      '});\\n' +\n      \"it('is another test', () => {\\n\" +\n      \"  expect({a: 'a'}).toMatchInlineSnapshot(`\\n\" +\n      '    Object {\\n' +\n      \"      a: 'a'\\n\" +\n      '    }\\n' +\n      '  `);\\n' +\n      '});\\n',\n  );\n});\n\ntest('saveInlineSnapshots() does not re-indent already indented snapshots', () => {\n  const filename = path.join(dir, 'my.test.js');\n  fs.writeFileSync(\n    filename,\n    \"it('is a test', () => {\\n\" +\n      \"  expect({a: 'a'}).toMatchInlineSnapshot();\\n\" +\n      '});\\n' +\n      \"it('is a another test', () => {\\n\" +\n      \"  expect({b: 'b'}).toMatchInlineSnapshot(`\\n\" +\n      '    Object {\\n' +\n      \"      b: 'b'\\n\" +\n      '    }\\n' +\n      '  `);\\n' +\n      '});\\n',\n  );\n  jest.mocked(prettier.resolveConfig.sync).mockReturnValue({\n    bracketSpacing: false,\n    singleQuote: true,\n  });\n\n  saveInlineSnapshots(\n    [\n      {\n        frame: {column: 20, file: filename, line: 2} as Frame,\n        snapshot: \"\\nObject {\\n  a: 'a'\\n}\\n\",\n      },\n    ],\n    dir,\n    'prettier',\n  );\n\n  expect(fs.readFileSync(filename, 'utf8')).toBe(\n    \"it('is a test', () => {\\n\" +\n      \"  expect({a: 'a'}).toMatchInlineSnapshot(`\\n\" +\n      '    Object {\\n' +\n      \"      a: 'a'\\n\" +\n      '    }\\n' +\n      '  `);\\n' +\n      '});\\n' +\n      \"it('is a another test', () => {\\n\" +\n      \"  expect({b: 'b'}).toMatchInlineSnapshot(`\\n\" +\n      '    Object {\\n' +\n      \"      b: 'b'\\n\" +\n      '    }\\n' +\n      '  `);\\n' +\n      '});\\n',\n  );\n});\n\ntest('saveInlineSnapshots() indents multi-line snapshots with tabs', () => {\n  const filename = path.join(dir, 'my.test.js');\n  fs.writeFileSync(\n    filename,\n    \"it('is a test', () => {\\n\" +\n      \"  expect({a: 'a'}).toMatchInlineSnapshot();\\n\" +\n      '});\\n',\n  );\n  jest.mocked(prettier.resolveConfig.sync).mockReturnValue({\n    bracketSpacing: false,\n    singleQuote: true,\n    useTabs: true,\n  });\n\n  saveInlineSnapshots(\n    [\n      {\n        frame: {column: 20, file: filename, line: 2} as Frame,\n        snapshot: \"\\nObject {\\n  a: 'a'\\n}\\n\",\n      },\n    ],\n    dir,\n    'prettier',\n  );\n\n  expect(fs.readFileSync(filename, 'utf8')).toBe(\n    \"it('is a test', () => {\\n\" +\n      \"\\texpect({a: 'a'}).toMatchInlineSnapshot(`\\n\" +\n      '\\t\\tObject {\\n' +\n      \"\\t\\t  a: 'a'\\n\" +\n      '\\t\\t}\\n' +\n      '\\t`);\\n' +\n      '});\\n',\n  );\n});\n\ntest('saveInlineSnapshots() indents snapshots after prettier reformats', () => {\n  const filename = path.join(dir, 'my.test.js');\n  fs.writeFileSync(\n    filename,\n    \"it('is a test', () => expect({a: 'a'}).toMatchInlineSnapshot());\\n\",\n  );\n  jest.mocked(prettier.resolveConfig.sync).mockReturnValue({\n    bracketSpacing: false,\n    singleQuote: true,\n  });\n\n  saveInlineSnapshots(\n    [\n      {\n        frame: {column: 40, file: filename, line: 1} as Frame,\n        snapshot: \"\\nObject {\\n  a: 'a'\\n}\\n\",\n      },\n    ],\n    dir,\n    'prettier',\n  );\n\n  expect(fs.readFileSync(filename, 'utf8')).toBe(\n    \"it('is a test', () =>\\n\" +\n      \"  expect({a: 'a'}).toMatchInlineSnapshot(`\\n\" +\n      '    Object {\\n' +\n      \"      a: 'a'\\n\" +\n      '    }\\n' +\n      '  `));\\n',\n  );\n});\n\ntest('saveInlineSnapshots() does not indent empty lines', () => {\n  const filename = path.join(dir, 'my.test.js');\n  fs.writeFileSync(\n    filename,\n    \"it('is a test', () => expect(`hello\\n\\nworld`).toMatchInlineSnapshot());\\n\",\n  );\n  jest.mocked(prettier.resolveConfig.sync).mockReturnValue({\n    bracketSpacing: false,\n    singleQuote: true,\n  });\n\n  saveInlineSnapshots(\n    [\n      {\n        frame: {column: 9, file: filename, line: 3} as Frame,\n        snapshot: '\\nhello\\n\\nworld\\n',\n      },\n    ],\n    dir,\n    'prettier',\n  );\n\n  expect(fs.readFileSync(filename, 'utf8')).toBe(\n    \"it('is a test', () =>\\n\" +\n      '  expect(`hello\\n\\nworld`).toMatchInlineSnapshot(`\\n' +\n      '    hello\\n' +\n      '\\n' +\n      '    world\\n' +\n      '  `));\\n',\n  );\n});\n\ntest('saveInlineSnapshots() indents awaited snapshots with spaces', () => {\n  const filename = path.join(dir, 'my.test.js');\n  fs.writeFileSync(\n    filename,\n    \"it('is a test', async () => {\\n\" +\n      \"  const a = Promise.resolve({a: 'a'});\\n\" +\n      '  await expect(a).resolves.toMatchInlineSnapshot();\\n' +\n      '});\\n',\n  );\n  jest.mocked(prettier.resolveConfig.sync).mockReturnValue({\n    bracketSpacing: false,\n    singleQuote: true,\n  });\n\n  saveInlineSnapshots(\n    [\n      {\n        frame: {column: 28, file: filename, line: 3} as Frame,\n        snapshot: \"\\nObject {\\n  a: 'a'\\n}\\n\",\n      },\n    ],\n    dir,\n    'prettier',\n  );\n\n  expect(fs.readFileSync(filename, 'utf8')).toBe(\n    \"it('is a test', async () => {\\n\" +\n      \"  const a = Promise.resolve({a: 'a'});\\n\" +\n      '  await expect(a).resolves.toMatchInlineSnapshot(`\\n' +\n      '    Object {\\n' +\n      \"      a: 'a'\\n\" +\n      '    }\\n' +\n      '  `);\\n' +\n      '});\\n',\n  );\n});\n\ntest('saveInlineSnapshots() prioritize parser from project/editor configuration', () => {\n  const filename = path.join(dir, 'my.test.js');\n  fs.writeFileSync(\n    filename,\n    'const foo = {\\n' +\n      '  \"1\": \"Some value\",\\n' +\n      '};\\n' +\n      'test(\"something\", () => {\\n' +\n      '  expect(\"a\").toMatchInlineSnapshot();\\n' +\n      '});\\n',\n  );\n\n  jest.mocked(prettier.resolveConfig.sync).mockReturnValue({\n    parser: 'flow',\n  });\n\n  const prettierSpy = jest.spyOn(prettier.getFileInfo, 'sync');\n\n  saveInlineSnapshots(\n    [\n      {\n        frame: {column: 15, file: filename, line: 5} as Frame,\n        snapshot: 'a',\n      },\n    ],\n    dir,\n    'prettier',\n  );\n\n  expect(prettierSpy).not.toHaveBeenCalled();\n  expect(fs.readFileSync(filename, 'utf8')).toBe(\n    'const foo = {\\n' +\n      '  \"1\": \"Some value\",\\n' +\n      '};\\n' +\n      'test(\"something\", () => {\\n' +\n      '  expect(\"a\").toMatchInlineSnapshot(`a`);\\n' +\n      '});\\n',\n  );\n});\n\ntest('saveInlineSnapshots() replaces string literal, not just template literal', () => {\n  const filename = path.join(dir, 'my.test.js');\n  fs.writeFileSync(filename, 'expect(\"a\").toMatchInlineSnapshot(\"b\");\\n');\n\n  saveInlineSnapshots(\n    [\n      {\n        frame: {column: 13, file: filename, line: 1} as Frame,\n        snapshot: 'a',\n      },\n    ],\n    dir,\n    'prettier',\n  );\n\n  expect(fs.readFileSync(filename, 'utf8')).toBe(\n    'expect(\"a\").toMatchInlineSnapshot(`a`);\\n',\n  );\n});\n",
  "packages/jest-snapshot/src/__tests__/InlineSnapshots.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-snapshot/__typetests__/matchers.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {expect} from 'tstyche';\nimport type {ExpectationResult} from 'expect';\nimport {\n  type Context,\n  type SnapshotState,\n  toMatchInlineSnapshot,\n  toMatchSnapshot,\n  toThrowErrorMatchingInlineSnapshot,\n  toThrowErrorMatchingSnapshot,\n} from 'jest-snapshot';\n\n// Context\n\nexpect(({} as Context).snapshotState).type.toBe<SnapshotState>();\n\n// toMatchSnapshot\n\nexpect(\n  toMatchSnapshot.call({} as Context, {received: 'value'}),\n).type.toBe<ExpectationResult>();\n\nexpect(\n  toMatchSnapshot.call({} as Context, {received: 'value'}, 'someHint'),\n).type.toBe<ExpectationResult>();\n\nexpect(\n  toMatchSnapshot.call({} as Context, {received: 'value'}, {property: 'match'}),\n).type.toBe<ExpectationResult>();\n\nexpect(\n  toMatchSnapshot.call(\n    {} as Context,\n    {received: 'value'},\n    {property: 'match'},\n    'someHint',\n  ),\n).type.toBe<ExpectationResult>();\n\nexpect(toMatchSnapshot).type.not.toBeCallableWith({received: 'value'});\n\n// toMatchInlineSnapshot\n\nexpect(\n  toMatchInlineSnapshot.call({} as Context, {received: 'value'}),\n).type.toBe<ExpectationResult>();\n\nexpect(\n  toMatchInlineSnapshot.call(\n    {} as Context,\n    {received: 'value'},\n    'inlineSnapshot',\n  ),\n).type.toBe<ExpectationResult>();\n\nexpect(\n  toMatchInlineSnapshot.call(\n    {} as Context,\n    {received: 'value'},\n    {property: 'match'},\n  ),\n).type.toBe<ExpectationResult>();\n\nexpect(\n  toMatchInlineSnapshot.call(\n    {} as Context,\n    {received: 'value'},\n    {property: 'match'},\n    'inlineSnapshot',\n  ),\n).type.toBe<ExpectationResult>();\n\nexpect(toMatchInlineSnapshot).type.not.toBeCallableWith({received: 'value'});\n\n// toThrowErrorMatchingSnapshot\n\nexpect(\n  toThrowErrorMatchingSnapshot.call({} as Context, new Error('received')),\n).type.toBe<ExpectationResult>();\n\nexpect(\n  toThrowErrorMatchingSnapshot.call(\n    {} as Context,\n    new Error('received'),\n    'someHint',\n  ),\n).type.toBe<ExpectationResult>();\n\nexpect(\n  toThrowErrorMatchingSnapshot.call(\n    {} as Context,\n    new Error('received'),\n    'someHint',\n    true, // fromPromise\n  ),\n).type.toBe<ExpectationResult>();\n\nexpect(\n  toThrowErrorMatchingSnapshot.call(\n    {} as Context,\n    new Error('received'),\n    undefined,\n    false, // fromPromise\n  ),\n).type.toBe<ExpectationResult>();\n\nexpect(toThrowErrorMatchingSnapshot).type.not.toBeCallableWith({\n  received: 'value',\n});\n\n// toThrowErrorMatchingInlineSnapshot\n\nexpect(\n  toThrowErrorMatchingInlineSnapshot.call({} as Context, new Error('received')),\n).type.toBe<ExpectationResult>();\n\nexpect(\n  toThrowErrorMatchingInlineSnapshot.call(\n    {} as Context,\n    new Error('received'),\n    'inlineSnapshot',\n  ),\n).type.toBe<ExpectationResult>();\n\nexpect(\n  toThrowErrorMatchingInlineSnapshot.call(\n    {} as Context,\n    new Error('received'),\n    'inlineSnapshot',\n    true, // fromPromise\n  ),\n).type.toBe<ExpectationResult>();\n\nexpect(\n  toThrowErrorMatchingInlineSnapshot.call(\n    {} as Context,\n    new Error('received'),\n    undefined,\n    false, // fromPromise\n  ),\n).type.toBe<ExpectationResult>();\n\nexpect(toThrowErrorMatchingInlineSnapshot).type.not.toBeCallableWith({\n  received: 'value',\n});\n",
  "packages/jest-snapshot/__typetests__/matchers.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-snapshot/__typetests__/SnapshotResolver.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {expect} from 'tstyche';\nimport type {SnapshotResolver} from 'jest-snapshot';\n\n// SnapshotResolver\n\nconst snapshotResolver: SnapshotResolver = {\n  resolveSnapshotPath: (testPath, snapshotExtension) => {\n    expect(testPath).type.toBe<string>();\n    expect(snapshotExtension).type.toBe<string | undefined>();\n    return 'snapshot/path';\n  },\n\n  resolveTestPath: (snapshotPath, snapshotExtension) => {\n    expect(snapshotPath).type.toBe<string>();\n    expect(snapshotExtension).type.toBe<string | undefined>();\n    return 'test/path';\n  },\n\n  testPathForConsistencyCheck: 'test/path/example',\n};\n\n// resolveSnapshotPath\n\nexpect<SnapshotResolver>().type.not.toBeAssignableWith({\n  resolveSnapshotPath: (testPath: string, snapshotExtension: boolean) =>\n    'snapshot/path',\n  resolveTestPath: () => 'test/path',\n  testPathForConsistencyCheck: 'test/path/example',\n});\n\nexpect<SnapshotResolver>().type.not.toBeAssignableWith({\n  resolveSnapshotPath: (testPath: boolean) => 'snapshot/path',\n  resolveTestPath: () => 'test/path',\n  testPathForConsistencyCheck: 'test/path/example',\n});\n\nexpect<SnapshotResolver>().type.not.toBeAssignableWith({\n  resolveSnapshotPath: () => true,\n  resolveTestPath: () => 'test/path',\n  testPathForConsistencyCheck: 'test/path/example',\n});\n\nexpect<SnapshotResolver>().type.not.toBeAssignableWith({\n  resolveTestPath: () => 'test/path',\n  testPathForConsistencyCheck: 'test/path/example',\n});\n\n// resolveTestPath\n\nexpect<SnapshotResolver>().type.not.toBeAssignableWith({\n  resolveSnapshotPath: () => 'snapshot/path',\n  resolveTestPath: (snapshotPath: string, snapshotExtension: boolean) =>\n    'test/path',\n  testPathForConsistencyCheck: 'test/path/example',\n});\n\nexpect<SnapshotResolver>().type.not.toBeAssignableWith({\n  resolveSnapshotPath: () => 'snapshot/path',\n  resolveTestPath: (snapshotPath: boolean) => 'test/path',\n  testPathForConsistencyCheck: 'test/path/example',\n});\n\nexpect<SnapshotResolver>().type.not.toBeAssignableWith({\n  resolveSnapshotPath: () => 'snapshot/path',\n  resolveTestPath: () => true,\n  testPathForConsistencyCheck: 'test/path/example',\n});\n\nexpect<SnapshotResolver>().type.not.toBeAssignableWith({\n  resolveSnapshotPath: () => 'snapshot/path',\n  testPathForConsistencyCheck: 'test/path/example',\n});\n\n// testPathForConsistencyCheck\n\nexpect<SnapshotResolver>().type.not.toBeAssignableWith({\n  resolveSnapshotPath: () => 'snapshot/path',\n  resolveTestPath: () => 'test/path',\n  testPathForConsistencyCheck: true,\n});\n\nexpect<SnapshotResolver>().type.not.toBeAssignableWith({\n  resolveSnapshotPath: () => 'snapshot/path',\n  resolveTestPath: () => 'test/path',\n});\n",
  "packages/jest-snapshot/__typetests__/SnapshotResolver.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-schemas/src/raw-types.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/* eslint-disable sort-keys */\n\nimport {type Static, Type} from '@sinclair/typebox';\n\nexport const SnapshotFormat = Type.Partial(\n  Type.Object({\n    callToJSON: Type.Boolean(),\n    compareKeys: Type.Null(),\n    escapeRegex: Type.Boolean(),\n    escapeString: Type.Boolean(),\n    highlight: Type.Boolean(),\n    indent: Type.Integer({minimum: 0}),\n    maxDepth: Type.Integer({minimum: 0}),\n    maxWidth: Type.Integer({minimum: 0}),\n    min: Type.Boolean(),\n    printBasicPrototype: Type.Boolean(),\n    printFunctionName: Type.Boolean(),\n    theme: Type.Partial(\n      Type.Object({\n        comment: Type.String(),\n        content: Type.String(),\n        prop: Type.String(),\n        tag: Type.String(),\n        value: Type.String(),\n      }),\n    ),\n  }),\n);\n\nconst CoverageProvider = Type.Union([\n  Type.Literal('babel'),\n  Type.Literal('v8'),\n]);\n\nconst CoverageThresholdValue = Type.Partial(\n  Type.Object({\n    branches: Type.Number({minimum: 0, maximum: 100}),\n    functions: Type.Number({minimum: 0, maximum: 100}),\n    lines: Type.Number({minimum: 0, maximum: 100}),\n    statements: Type.Number({minimum: 0, maximum: 100}),\n  }),\n);\n\nconst CoverageThresholdBase = Type.Object(\n  {global: CoverageThresholdValue},\n  {additionalProperties: CoverageThresholdValue},\n);\n\nconst CoverageThreshold = Type.Unsafe<{\n  global: Static<typeof CoverageThresholdValue>;\n  [path: string]: Static<typeof CoverageThresholdValue>;\n}>(CoverageThresholdBase);\n\n// TODO: add type test that these are all the colors available in chalk.ForegroundColor\nexport const ChalkForegroundColors = Type.Union([\n  Type.Literal('black'),\n  Type.Literal('red'),\n  Type.Literal('green'),\n  Type.Literal('yellow'),\n  Type.Literal('blue'),\n  Type.Literal('magenta'),\n  Type.Literal('cyan'),\n  Type.Literal('white'),\n  Type.Literal('gray'),\n  Type.Literal('grey'),\n  Type.Literal('blackBright'),\n  Type.Literal('redBright'),\n  Type.Literal('greenBright'),\n  Type.Literal('yellowBright'),\n  Type.Literal('blueBright'),\n  Type.Literal('magentaBright'),\n  Type.Literal('cyanBright'),\n  Type.Literal('whiteBright'),\n]);\n\nconst DisplayName = Type.Object({\n  name: Type.String(),\n  color: ChalkForegroundColors,\n});\n\n// TODO: verify these are the names of istanbulReport.ReportOptions\nexport const CoverageReporterNames = Type.Union([\n  Type.Literal('clover'),\n  Type.Literal('cobertura'),\n  Type.Literal('html-spa'),\n  Type.Literal('html'),\n  Type.Literal('json'),\n  Type.Literal('json-summary'),\n  Type.Literal('lcov'),\n  Type.Literal('lcovonly'),\n  Type.Literal('none'),\n  Type.Literal('teamcity'),\n  Type.Literal('text'),\n  Type.Literal('text-lcov'),\n  Type.Literal('text-summary'),\n]);\n\nconst CoverageReporters = Type.Array(\n  Type.Union([\n    CoverageReporterNames,\n    Type.Tuple([\n      CoverageReporterNames,\n      Type.Record(Type.String(), Type.Unknown()),\n    ]),\n  ]),\n);\n\nconst GlobalFakeTimersConfig = Type.Partial(\n  Type.Object({\n    enableGlobally: Type.Boolean({\n      description:\n        'Whether fake timers should be enabled globally for all test files.',\n      default: false,\n    }),\n  }),\n);\n\nconst FakeableAPI = Type.Union([\n  Type.Literal('Date'),\n  Type.Literal('hrtime'),\n  Type.Literal('nextTick'),\n  Type.Literal('performance'),\n  Type.Literal('queueMicrotask'),\n  Type.Literal('requestAnimationFrame'),\n  Type.Literal('cancelAnimationFrame'),\n  Type.Literal('requestIdleCallback'),\n  Type.Literal('cancelIdleCallback'),\n  Type.Literal('setImmediate'),\n  Type.Literal('clearImmediate'),\n  Type.Literal('setInterval'),\n  Type.Literal('clearInterval'),\n  Type.Literal('setTimeout'),\n  Type.Literal('clearTimeout'),\n]);\n\nconst FakeTimersConfig = Type.Partial(\n  Type.Object({\n    advanceTimers: Type.Union([Type.Boolean(), Type.Number({minimum: 0})], {\n      description:\n        'If set to `true` all timers will be advanced automatically by 20 milliseconds every 20 milliseconds. A custom ' +\n        'time delta may be provided by passing a number.',\n      default: false,\n    }),\n    doNotFake: Type.Array(FakeableAPI, {\n      description:\n        'List of names of APIs (e.g. `Date`, `nextTick()`, `setImmediate()`, `setTimeout()`) that should not be faked.' +\n        '\\n\\nThe default is `[]`, meaning all APIs are faked.',\n      default: [],\n    }),\n    now: Type.Integer({\n      minimum: 0,\n      description:\n        'Sets current system time to be used by fake timers.\\n\\nThe default is `Date.now()`.',\n    }),\n    timerLimit: Type.Number({\n      description:\n        'The maximum number of recursive timers that will be run when calling `jest.runAllTimers()`.',\n      default: 100_000,\n      minimum: 0,\n    }),\n    legacyFakeTimers: Type.Literal(false, {\n      description:\n        'Use the old fake timers implementation instead of one backed by `@sinonjs/fake-timers`.',\n      default: false,\n    }),\n  }),\n);\n\nconst LegacyFakeTimersConfig = Type.Partial(\n  Type.Object({\n    legacyFakeTimers: Type.Literal(true, {\n      description:\n        'Use the old fake timers implementation instead of one backed by `@sinonjs/fake-timers`.',\n      default: true,\n    }),\n  }),\n);\n\nexport const FakeTimers = Type.Intersect([\n  GlobalFakeTimersConfig,\n  Type.Union([FakeTimersConfig, LegacyFakeTimersConfig]),\n]);\n\nconst HasteConfig = Type.Partial(\n  Type.Object({\n    computeSha1: Type.Boolean({\n      description: 'Whether to hash files using SHA-1.',\n    }),\n    defaultPlatform: Type.Union([Type.String(), Type.Null()], {\n      description: 'The platform to use as the default, e.g. `ios`.',\n    }),\n    forceNodeFilesystemAPI: Type.Boolean({\n      description:\n        \"Whether to force the use of Node's `fs` API when reading files rather than shelling out to `find`.\",\n    }),\n    enableSymlinks: Type.Boolean({\n      description:\n        'Whether to follow symlinks when crawling for files.' +\n        '\\n\\tThis options cannot be used in projects which use watchman.' +\n        '\\n\\tProjects with `watchman` set to true will error if this option is set to true.',\n    }),\n    hasteImplModulePath: Type.String({\n      description: 'Path to a custom implementation of Haste.',\n    }),\n    platforms: Type.Array(Type.String(), {\n      description: \"All platforms to target, e.g ['ios', 'android'].\",\n    }),\n    throwOnModuleCollision: Type.Boolean({\n      description: 'Whether to throw an error on module collision.',\n    }),\n    hasteMapModulePath: Type.String({\n      description: 'Custom HasteMap module',\n    }),\n    retainAllFiles: Type.Boolean({\n      description:\n        'Whether to retain all files, allowing e.g. search for tests in `node_modules`.',\n    }),\n  }),\n);\n\nexport const InitialOptions = Type.Partial(\n  Type.Object({\n    automock: Type.Boolean(),\n    bail: Type.Union([Type.Boolean(), Type.Number()]),\n    cache: Type.Boolean(),\n    cacheDirectory: Type.String(),\n    ci: Type.Boolean(),\n    clearMocks: Type.Boolean(),\n    changedFilesWithAncestor: Type.Boolean(),\n    changedSince: Type.String(),\n    collectCoverage: Type.Boolean(),\n    collectCoverageFrom: Type.Array(Type.String()),\n    coverageDirectory: Type.String(),\n    coveragePathIgnorePatterns: Type.Array(Type.String()),\n    coverageProvider: CoverageProvider,\n    coverageReporters: CoverageReporters,\n    coverageThreshold: CoverageThreshold,\n    dependencyExtractor: Type.String(),\n    detectLeaks: Type.Boolean(),\n    detectOpenHandles: Type.Boolean(),\n    displayName: Type.Union([Type.String(), DisplayName]),\n    expand: Type.Boolean(),\n    extensionsToTreatAsEsm: Type.Array(Type.String()),\n    fakeTimers: FakeTimers,\n    filter: Type.String(),\n    findRelatedTests: Type.Boolean(),\n    forceCoverageMatch: Type.Array(Type.String()),\n    forceExit: Type.Boolean(),\n    json: Type.Boolean(),\n    globals: Type.Record(Type.String(), Type.Unknown()),\n    globalSetup: Type.Union([Type.String(), Type.Null()]),\n    globalTeardown: Type.Union([Type.String(), Type.Null()]),\n    haste: HasteConfig,\n    id: Type.String(),\n    injectGlobals: Type.Boolean(),\n    reporters: Type.Array(\n      Type.Union([\n        Type.String(),\n        Type.Tuple([Type.String(), Type.Record(Type.String(), Type.Unknown())]),\n      ]),\n    ),\n    logHeapUsage: Type.Boolean(),\n    lastCommit: Type.Boolean(),\n    listTests: Type.Boolean(),\n    maxConcurrency: Type.Integer(),\n    maxWorkers: Type.Union([Type.String(), Type.Integer()]),\n    moduleDirectories: Type.Array(Type.String()),\n    moduleFileExtensions: Type.Array(Type.String()),\n    moduleNameMapper: Type.Record(\n      Type.String(),\n      Type.Union([Type.String(), Type.Array(Type.String())]),\n    ),\n    modulePathIgnorePatterns: Type.Array(Type.String()),\n    modulePaths: Type.Array(Type.String()),\n    noStackTrace: Type.Boolean(),\n    notify: Type.Boolean(),\n    notifyMode: Type.String(),\n    onlyChanged: Type.Boolean(),\n    onlyFailures: Type.Boolean(),\n    openHandlesTimeout: Type.Number(),\n    outputFile: Type.String(),\n    passWithNoTests: Type.Boolean(),\n    preset: Type.Union([Type.String(), Type.Null()]),\n    prettierPath: Type.Union([Type.String(), Type.Null()]),\n    projects: Type.Array(\n      Type.Union([\n        Type.String(),\n        // TODO: Make sure to type these correctly\n        Type.Record(Type.String(), Type.Unknown()),\n      ]),\n    ),\n    randomize: Type.Boolean(),\n    replname: Type.Union([Type.String(), Type.Null()]),\n    resetMocks: Type.Boolean(),\n    resetModules: Type.Boolean(),\n    resolver: Type.Union([Type.String(), Type.Null()]),\n    restoreMocks: Type.Boolean(),\n    rootDir: Type.String(),\n    roots: Type.Array(Type.String()),\n    runner: Type.String(),\n    runTestsByPath: Type.Boolean(),\n    runtime: Type.String(),\n    sandboxInjectedGlobals: Type.Array(Type.String()),\n    setupFiles: Type.Array(Type.String()),\n    setupFilesAfterEnv: Type.Array(Type.String()),\n    showSeed: Type.Boolean(),\n    silent: Type.Boolean(),\n    skipFilter: Type.Boolean(),\n    skipNodeResolution: Type.Boolean(),\n    slowTestThreshold: Type.Number(),\n    snapshotResolver: Type.String(),\n    snapshotSerializers: Type.Array(Type.String()),\n    snapshotFormat: SnapshotFormat,\n    errorOnDeprecated: Type.Boolean(),\n    testEnvironment: Type.String(),\n    testEnvironmentOptions: Type.Record(Type.String(), Type.Unknown()),\n    testFailureExitCode: Type.Integer(),\n    testLocationInResults: Type.Boolean(),\n    testMatch: Type.Union([Type.String(), Type.Array(Type.String())]),\n    testNamePattern: Type.String(),\n    testPathIgnorePatterns: Type.Array(Type.String()),\n    testRegex: Type.Union([Type.String(), Type.Array(Type.String())]),\n    testResultsProcessor: Type.String(),\n    testRunner: Type.String(),\n    testSequencer: Type.String(),\n    testTimeout: Type.Number(),\n    transform: Type.Record(\n      Type.String(),\n      Type.Union([Type.String(), Type.Tuple([Type.String(), Type.Unknown()])]),\n    ),\n    transformIgnorePatterns: Type.Array(Type.String()),\n    watchPathIgnorePatterns: Type.Array(Type.String()),\n    unmockedModulePathPatterns: Type.Array(Type.String()),\n    updateSnapshot: Type.Boolean(),\n    useStderr: Type.Boolean(),\n    verbose: Type.Boolean(),\n    waitForUnhandledRejections: Type.Boolean(),\n    watch: Type.Boolean(),\n    watchAll: Type.Boolean(),\n    watchman: Type.Boolean(),\n    watchPlugins: Type.Array(\n      Type.Union([Type.String(), Type.Tuple([Type.String(), Type.Unknown()])]),\n    ),\n    workerIdleMemoryLimit: Type.Union([Type.Number(), Type.String()]),\n    workerThreads: Type.Boolean(),\n  }),\n);\n",
  "packages/jest-schemas/src/raw-types.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport declare const SnapshotFormat: any;\nexport declare const ChalkForegroundColors: any;\nexport declare const CoverageReporterNames: any;\nexport declare const FakeTimers: any;\nexport declare const InitialOptions: any;\n",
  "packages/jest-schemas/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {Static} from '@sinclair/typebox';\nimport * as types from './raw-types';\n\nexport const SnapshotFormat = types.SnapshotFormat;\nexport type SnapshotFormat = Static<typeof SnapshotFormat>;\n\nexport const InitialOptions = types.InitialOptions;\nexport type InitialOptions = Static<typeof InitialOptions>;\n\nexport const FakeTimers = types.FakeTimers;\nexport type FakeTimers = Static<typeof FakeTimers>;\n",
  "packages/jest-schemas/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Static } from '@sinclair/typebox';\nexport declare const SnapshotFormat: any;\nexport type SnapshotFormat = Static<typeof SnapshotFormat>;\nexport declare const InitialOptions: any;\nexport type InitialOptions = Static<typeof InitialOptions>;\nexport declare const FakeTimers: any;\nexport type FakeTimers = Static<typeof FakeTimers>;\n",
  "packages/jest-runtime/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport nativeModule from 'module';\nimport * as path from 'path';\nimport {URL, fileURLToPath, pathToFileURL} from 'url';\nimport {\n  // @ts-expect-error: experimental, not added to the types\n  SourceTextModule,\n  // @ts-expect-error: experimental, not added to the types\n  SyntheticModule,\n  type Context as VMContext,\n  // @ts-expect-error: experimental, not added to the types\n  type Module as VMModule,\n  compileFunction,\n} from 'vm';\nimport {parse as parseCjs} from 'cjs-module-lexer';\nimport {CoverageInstrumenter, type V8Coverage} from 'collect-v8-coverage';\nimport * as fs from 'graceful-fs';\nimport slash from 'slash';\nimport stripBOM from 'strip-bom';\nimport type {\n  Jest,\n  JestEnvironment,\n  JestImportMeta,\n  Module,\n  ModuleWrapper,\n} from '@jest/environment';\nimport type {LegacyFakeTimers, ModernFakeTimers} from '@jest/fake-timers';\nimport type {expect, jest} from '@jest/globals';\nimport type {SourceMapRegistry} from '@jest/source-map';\nimport type {TestContext, V8CoverageResult} from '@jest/test-result';\nimport {\n  type CallerTransformOptions,\n  type ScriptTransformer,\n  type ShouldInstrumentOptions,\n  type TransformResult,\n  type TransformationOptions,\n  handlePotentialSyntaxError,\n  shouldInstrument,\n} from '@jest/transform';\nimport type {Config, Global} from '@jest/types';\nimport HasteMap, {type IHasteMap, type IModuleMap} from 'jest-haste-map';\nimport {formatStackTrace, separateMessageFromStack} from 'jest-message-util';\nimport type {MockMetadata, ModuleMocker} from 'jest-mock';\nimport {escapePathForRegex} from 'jest-regex-util';\nimport Resolver, {type ResolveModuleConfig} from 'jest-resolve';\nimport {EXTENSION as SnapshotExtension} from 'jest-snapshot';\nimport {\n  createDirectory,\n  deepCyclicCopy,\n  invariant,\n  isNonNullable,\n  protectProperties,\n} from 'jest-util';\nimport {\n  createOutsideJestVmPath,\n  decodePossibleOutsideJestVmPath,\n  findSiblingsWithFileExtension,\n} from './helpers';\n\nconst esmIsAvailable = typeof SourceTextModule === 'function';\n\nconst dataURIRegex =\n  /^data:(?<mime>text\\/javascript|application\\/json|application\\/wasm)(?:;(?<encoding>charset=utf-8|base64))?,(?<code>.*)$/;\n\ninterface JestGlobals extends Global.TestFrameworkGlobals {\n  expect: typeof expect;\n}\n\ninterface JestGlobalsWithJest extends JestGlobals {\n  jest: typeof jest;\n}\n\ntype HasteMapOptions = {\n  console?: Console;\n  maxWorkers: number;\n  resetCache: boolean;\n  watch?: boolean;\n  watchman: boolean;\n  workerThreads?: boolean;\n};\n\ninterface InternalModuleOptions extends Required<CallerTransformOptions> {\n  isInternalModule: boolean;\n}\n\nconst defaultTransformOptions: InternalModuleOptions = {\n  isInternalModule: false,\n  supportsDynamicImport: esmIsAvailable,\n  supportsExportNamespaceFrom: false,\n  supportsStaticESM: false,\n  supportsTopLevelAwait: false,\n};\n\ntype InitialModule = Omit<Module, 'require' | 'parent' | 'paths'>;\ntype ModuleRegistry = Map<string, InitialModule | Module>;\n\n// These are modules that we know\n// * are safe to require from the outside (not stateful, not prone to errors passing in instances from different realms), and\n// * take sufficiently long to require to warrant an optimization.\n// When required from the outside, they use the worker's require cache and are thus\n// only loaded once per worker, not once per test file.\n// Use /benchmarks/test-file-overhead to measure the impact.\n// Note that this only applies when they are required in an internal context;\n// users who require one of these modules in their tests will still get the module from inside the VM.\n// Prefer listing a module here only if it is impractical to use the jest-resolve-outside-vm-option where it is required,\n// e.g. because there are many require sites spread across the dependency graph.\nconst INTERNAL_MODULE_REQUIRE_OUTSIDE_OPTIMIZED_MODULES = new Set(['chalk']);\nconst JEST_RESOLVE_OUTSIDE_VM_OPTION = Symbol.for(\n  'jest-resolve-outside-vm-option',\n);\ntype ResolveOptions = Parameters<typeof require.resolve>[1] & {\n  [JEST_RESOLVE_OUTSIDE_VM_OPTION]?: true;\n};\n\nconst testTimeoutSymbol = Symbol.for('TEST_TIMEOUT_SYMBOL');\nconst retryTimesSymbol = Symbol.for('RETRY_TIMES');\nconst waitBeforeRetrySymbol = Symbol.for('WAIT_BEFORE_RETRY');\nconst retryImmediatelySybmbol = Symbol.for('RETRY_IMMEDIATELY');\nconst logErrorsBeforeRetrySymbol = Symbol.for('LOG_ERRORS_BEFORE_RETRY');\n\nconst NODE_MODULES = `${path.sep}node_modules${path.sep}`;\n\nconst getModuleNameMapper = (config: Config.ProjectConfig) => {\n  if (\n    Array.isArray(config.moduleNameMapper) &&\n    config.moduleNameMapper.length > 0\n  ) {\n    return config.moduleNameMapper.map(([regex, moduleName]) => ({\n      moduleName,\n      regex: new RegExp(regex),\n    }));\n  }\n  return null;\n};\n\nconst isWasm = (modulePath: string): boolean => modulePath.endsWith('.wasm');\n\nconst unmockRegExpCache = new WeakMap();\n\nconst runtimeSupportsVmModules = typeof SyntheticModule === 'function';\n\nconst supportsNodeColonModulePrefixInRequire = (() => {\n  try {\n    require('node:fs');\n\n    return true;\n  } catch {\n    return false;\n  }\n})();\n\nexport default class Runtime {\n  private readonly _cacheFS: Map<string, string>;\n  private readonly _cacheFSBuffer = new Map<string, Buffer>();\n  private readonly _config: Config.ProjectConfig;\n  private readonly _globalConfig: Config.GlobalConfig;\n  private readonly _coverageOptions: ShouldInstrumentOptions;\n  private _currentlyExecutingModulePath: string;\n  private readonly _environment: JestEnvironment;\n  private readonly _explicitShouldMock: Map<string, boolean>;\n  private readonly _explicitShouldMockModule: Map<string, boolean>;\n  private readonly _onGenerateMock: Set<\n    (moduleName: string, moduleMock: any) => any\n  >;\n  private _fakeTimersImplementation:\n    | LegacyFakeTimers<unknown>\n    | ModernFakeTimers\n    | null;\n  private readonly _internalModuleRegistry: ModuleRegistry;\n  private _isCurrentlyExecutingManualMock: string | null;\n  private _mainModule: Module | null;\n  private readonly _mockFactories: Map<string, () => unknown>;\n  private readonly _mockMetaDataCache: Map<string, MockMetadata<any>>;\n  private _mockRegistry: Map<string, any>;\n  private _isolatedMockRegistry: Map<string, any> | null;\n  private readonly _moduleMockRegistry: Map<string, VMModule>;\n  private readonly _moduleMockFactories: Map<string, () => unknown>;\n  private readonly _moduleMocker: ModuleMocker;\n  private _isolatedModuleRegistry: ModuleRegistry | null;\n  private _moduleRegistry: ModuleRegistry;\n  private readonly _esmoduleRegistry: Map<string, VMModule>;\n  private readonly _cjsNamedExports: Map<string, Set<string>>;\n  private readonly _esmModuleLinkingMap: WeakMap<VMModule, Promise<unknown>>;\n  private readonly _testPath: string;\n  private readonly _resolver: Resolver;\n  private _shouldAutoMock: boolean;\n  private readonly _shouldMockModuleCache: Map<string, boolean>;\n  private readonly _shouldUnmockTransitiveDependenciesCache: Map<\n    string,\n    boolean\n  >;\n  private readonly _sourceMapRegistry: SourceMapRegistry;\n  private readonly _scriptTransformer: ScriptTransformer;\n  private readonly _fileTransforms: Map<string, TransformResult>;\n  private readonly _fileTransformsMutex: Map<string, Promise<void>>;\n  private _v8CoverageInstrumenter: CoverageInstrumenter | undefined;\n  private _v8CoverageResult: V8Coverage | undefined;\n  private _v8CoverageSources: Map<string, TransformResult> | undefined;\n  private readonly _transitiveShouldMock: Map<string, boolean>;\n  private _unmockList: RegExp | undefined;\n  private readonly _virtualMocks: Map<string, boolean>;\n  private readonly _virtualModuleMocks: Map<string, boolean>;\n  private _moduleImplementation?: typeof nativeModule.Module;\n  private readonly jestObjectCaches: Map<string, Jest>;\n  private jestGlobals?: JestGlobals;\n  private readonly esmConditions: Array<string>;\n  private readonly cjsConditions: Array<string>;\n  private isTornDown = false;\n  private isInsideTestCode: boolean | undefined;\n\n  constructor(\n    config: Config.ProjectConfig,\n    environment: JestEnvironment,\n    resolver: Resolver,\n    transformer: ScriptTransformer,\n    cacheFS: Map<string, string>,\n    coverageOptions: ShouldInstrumentOptions,\n    testPath: string,\n    globalConfig: Config.GlobalConfig,\n  ) {\n    this._cacheFS = cacheFS;\n    this._config = config;\n    this._coverageOptions = coverageOptions;\n    this._currentlyExecutingModulePath = '';\n    this._environment = environment;\n    this._globalConfig = globalConfig;\n    this._explicitShouldMock = new Map();\n    this._explicitShouldMockModule = new Map();\n    this._onGenerateMock = new Set();\n    this._internalModuleRegistry = new Map();\n    this._isCurrentlyExecutingManualMock = null;\n    this._mainModule = null;\n    this._mockFactories = new Map();\n    this._mockRegistry = new Map();\n    this._moduleMockRegistry = new Map();\n    this._moduleMockFactories = new Map();\n    invariant(\n      this._environment.moduleMocker,\n      '`moduleMocker` must be set on an environment when created',\n    );\n    this._moduleMocker = this._environment.moduleMocker;\n    this._isolatedModuleRegistry = null;\n    this._isolatedMockRegistry = null;\n    this._moduleRegistry = new Map();\n    this._esmoduleRegistry = new Map();\n    this._cjsNamedExports = new Map();\n    this._esmModuleLinkingMap = new WeakMap();\n    this._testPath = testPath;\n    this._resolver = resolver;\n    this._scriptTransformer = transformer;\n    this._shouldAutoMock = config.automock;\n    this._sourceMapRegistry = new Map();\n    this._fileTransforms = new Map();\n    this._fileTransformsMutex = new Map();\n    this._virtualMocks = new Map();\n    this._virtualModuleMocks = new Map();\n    this.jestObjectCaches = new Map();\n\n    this._mockMetaDataCache = new Map();\n    this._shouldMockModuleCache = new Map();\n    this._shouldUnmockTransitiveDependenciesCache = new Map();\n    this._transitiveShouldMock = new Map();\n\n    this._fakeTimersImplementation = config.fakeTimers.legacyFakeTimers\n      ? this._environment.fakeTimers\n      : this._environment.fakeTimersModern;\n\n    this._unmockList = unmockRegExpCache.get(config);\n    if (!this._unmockList && config.unmockedModulePathPatterns) {\n      this._unmockList = new RegExp(\n        config.unmockedModulePathPatterns.join('|'),\n      );\n      unmockRegExpCache.set(config, this._unmockList);\n    }\n\n    const envExportConditions = this._environment.exportConditions?.() ?? [];\n\n    this.esmConditions = [\n      ...new Set(['import', 'default', ...envExportConditions]),\n    ];\n    this.cjsConditions = [\n      ...new Set(['require', 'node', 'default', ...envExportConditions]),\n    ];\n\n    if (config.automock) {\n      for (const filePath of config.setupFiles) {\n        if (filePath.includes(NODE_MODULES)) {\n          const moduleID = this._resolver.getModuleID(\n            this._virtualMocks,\n            filePath,\n            undefined,\n            // shouldn't really matter, but in theory this will make sure the caching is correct\n            {\n              conditions: this.unstable_shouldLoadAsEsm(filePath)\n                ? this.esmConditions\n                : this.cjsConditions,\n            },\n          );\n          this._transitiveShouldMock.set(moduleID, false);\n        }\n      }\n    }\n\n    this.resetModules();\n  }\n\n  static shouldInstrument = shouldInstrument;\n\n  static async createContext(\n    config: Config.ProjectConfig,\n    options: {\n      console?: Console;\n      maxWorkers: number;\n      watch?: boolean;\n      watchman: boolean;\n    },\n  ): Promise<TestContext> {\n    createDirectory(config.cacheDirectory);\n    const instance = await Runtime.createHasteMap(config, {\n      console: options.console,\n      maxWorkers: options.maxWorkers,\n      resetCache: !config.cache,\n      watch: options.watch,\n      watchman: options.watchman,\n    });\n    const hasteMap = await instance.build();\n\n    return {\n      config,\n      hasteFS: hasteMap.hasteFS,\n      moduleMap: hasteMap.moduleMap,\n      resolver: Runtime.createResolver(config, hasteMap.moduleMap),\n    };\n  }\n\n  static createHasteMap(\n    config: Config.ProjectConfig,\n    options?: HasteMapOptions,\n  ): Promise<IHasteMap> {\n    const ignorePatternParts = [\n      ...config.modulePathIgnorePatterns,\n      ...(options && options.watch ? config.watchPathIgnorePatterns : []),\n      config.cacheDirectory.startsWith(config.rootDir + path.sep) &&\n        config.cacheDirectory,\n    ].filter(Boolean);\n    const ignorePattern =\n      ignorePatternParts.length > 0\n        ? new RegExp(ignorePatternParts.join('|'))\n        : undefined;\n\n    return HasteMap.create({\n      cacheDirectory: config.cacheDirectory,\n      computeSha1: config.haste.computeSha1,\n      console: options?.console,\n      dependencyExtractor: config.dependencyExtractor,\n      enableSymlinks: config.haste.enableSymlinks,\n      extensions: [SnapshotExtension, ...config.moduleFileExtensions],\n      forceNodeFilesystemAPI: config.haste.forceNodeFilesystemAPI,\n      hasteImplModulePath: config.haste.hasteImplModulePath,\n      hasteMapModulePath: config.haste.hasteMapModulePath,\n      id: config.id,\n      ignorePattern,\n      maxWorkers: options?.maxWorkers || 1,\n      mocksPattern: escapePathForRegex(`${path.sep}__mocks__${path.sep}`),\n      platforms: config.haste.platforms || ['ios', 'android'],\n      resetCache: options?.resetCache,\n      retainAllFiles: config.haste.retainAllFiles || false,\n      rootDir: config.rootDir,\n      roots: config.roots,\n      throwOnModuleCollision: config.haste.throwOnModuleCollision,\n      useWatchman: options?.watchman,\n      watch: options?.watch,\n      workerThreads: options?.workerThreads,\n    });\n  }\n\n  static createResolver(\n    config: Config.ProjectConfig,\n    moduleMap: IModuleMap,\n  ): Resolver {\n    return new Resolver(moduleMap, {\n      defaultPlatform: config.haste.defaultPlatform,\n      extensions: config.moduleFileExtensions.map(extension => `.${extension}`),\n      hasCoreModules: true,\n      moduleDirectories: config.moduleDirectories,\n      moduleNameMapper: getModuleNameMapper(config),\n      modulePaths: config.modulePaths,\n      platforms: config.haste.platforms,\n      resolver: config.resolver,\n      rootDir: config.rootDir,\n    });\n  }\n\n  // unstable as it should be replaced by https://github.com/nodejs/modules/issues/393, and we don't want people to use it\n  unstable_shouldLoadAsEsm(modulePath: string): boolean {\n    return (\n      isWasm(modulePath) ||\n      Resolver.unstable_shouldLoadAsEsm(\n        modulePath,\n        this._config.extensionsToTreatAsEsm,\n      )\n    );\n  }\n\n  private async loadEsmModule(\n    modulePath: string,\n    query = '',\n  ): Promise<VMModule> {\n    const cacheKey = modulePath + query;\n    const registry = this._isolatedModuleRegistry ?? this._esmoduleRegistry;\n\n    if (this._fileTransformsMutex.has(cacheKey)) {\n      await this._fileTransformsMutex.get(cacheKey);\n    }\n\n    if (!registry.has(cacheKey)) {\n      invariant(\n        typeof this._environment.getVmContext === 'function',\n        'ES Modules are only supported if your test environment has the `getVmContext` function',\n      );\n\n      const context = this._environment.getVmContext();\n\n      invariant(context, 'Test environment has been torn down');\n\n      let transformResolve: () => void;\n      let transformReject: (error?: unknown) => void;\n\n      this._fileTransformsMutex.set(\n        cacheKey,\n        new Promise((resolve, reject) => {\n          transformResolve = resolve;\n          transformReject = reject;\n        }),\n      );\n\n      invariant(\n        transformResolve! && transformReject!,\n        'Promise initialization should be sync - please report this bug to Jest!',\n      );\n\n      if (isWasm(modulePath)) {\n        const wasm = this._importWasmModule(\n          this.readFileBuffer(modulePath),\n          modulePath,\n          context,\n        );\n\n        registry.set(cacheKey, wasm);\n\n        transformResolve();\n        return wasm;\n      }\n\n      if (this._resolver.isCoreModule(modulePath)) {\n        const core = this._importCoreModule(modulePath, context);\n        registry.set(cacheKey, core);\n\n        transformResolve();\n\n        return core;\n      }\n\n      const transformedCode = await this.transformFileAsync(modulePath, {\n        isInternalModule: false,\n        supportsDynamicImport: true,\n        supportsExportNamespaceFrom: true,\n        supportsStaticESM: true,\n        supportsTopLevelAwait: true,\n      });\n\n      try {\n        let module;\n        if (modulePath.endsWith('.json')) {\n          module = new SyntheticModule(\n            ['default'],\n            function () {\n              const obj = JSON.parse(transformedCode);\n              // @ts-expect-error: TS doesn't know what `this` is\n              this.setExport('default', obj);\n            },\n            {context, identifier: modulePath},\n          );\n        } else {\n          module = new SourceTextModule(transformedCode, {\n            context,\n            identifier: modulePath,\n            importModuleDynamically: async (\n              specifier: string,\n              referencingModule: VMModule,\n            ) => {\n              invariant(\n                runtimeSupportsVmModules,\n                'You need to run with a version of node that supports ES Modules in the VM API. See https://jestjs.io/docs/ecmascript-modules',\n              );\n              const module = await this.resolveModule(\n                specifier,\n                referencingModule.identifier,\n                referencingModule.context,\n              );\n\n              return this.linkAndEvaluateModule(module);\n            },\n            initializeImportMeta: (meta: JestImportMeta) => {\n              const metaUrl = pathToFileURL(modulePath).href;\n              meta.url = metaUrl;\n\n              // @ts-expect-error Jest uses @types/node@16. Will be fixed when updated to @types/node@20.11.0\n              meta.filename = modulePath;\n              // @ts-expect-error Jest uses @types/node@16. Will be fixed when updated to @types/node@20.11.0\n              meta.dirname = path.dirname(modulePath);\n\n              // @ts-expect-error: todo fixme\n              meta.resolve = (specifier, parent = metaUrl) => {\n                const parentPath = fileURLToPath(parent);\n\n                const resolvedPath = this._resolver.resolveModule(\n                  parentPath,\n                  specifier,\n                  {conditions: this.esmConditions},\n                );\n\n                return pathToFileURL(resolvedPath).href;\n              };\n\n              let jest = this.jestObjectCaches.get(modulePath);\n\n              if (!jest) {\n                jest = this._createJestObjectFor(modulePath);\n\n                this.jestObjectCaches.set(modulePath, jest);\n              }\n\n              meta.jest = jest;\n            },\n          });\n        }\n\n        invariant(\n          !registry.has(cacheKey),\n          `Module cache already has entry ${cacheKey}. This is a bug in Jest, please report it!`,\n        );\n\n        registry.set(cacheKey, module);\n\n        transformResolve();\n      } catch (error) {\n        transformReject(error);\n        throw error;\n      }\n    }\n\n    const module = registry.get(cacheKey);\n\n    invariant(\n      module,\n      'Module cache does not contain module. This is a bug in Jest, please open up an issue',\n    );\n\n    return module;\n  }\n\n  private async resolveModule<T = unknown>(\n    specifier: string,\n    referencingIdentifier: string,\n    context: VMContext,\n  ): Promise<T> {\n    if (this.isTornDown) {\n      this._logFormattedReferenceError(\n        'You are trying to `import` a file after the Jest environment has been torn down.',\n      );\n      process.exitCode = 1;\n      // @ts-expect-error -- exiting\n      return;\n    }\n    if (this.isInsideTestCode === false) {\n      throw new ReferenceError(\n        'You are trying to `import` a file outside of the scope of the test code.',\n      );\n    }\n\n    const registry = this._isolatedModuleRegistry ?? this._esmoduleRegistry;\n\n    if (specifier === '@jest/globals') {\n      const fromCache = registry.get('@jest/globals');\n\n      if (fromCache) {\n        return fromCache;\n      }\n      const globals = this.getGlobalsForEsm(referencingIdentifier, context);\n      registry.set('@jest/globals', globals);\n\n      return globals;\n    }\n\n    if (specifier.startsWith('data:')) {\n      if (\n        await this._shouldMockModule(\n          referencingIdentifier,\n          specifier,\n          this._explicitShouldMockModule,\n        )\n      ) {\n        return this.importMock(referencingIdentifier, specifier, context);\n      }\n\n      const fromCache = registry.get(specifier);\n\n      if (fromCache) {\n        return fromCache;\n      }\n\n      const match = specifier.match(dataURIRegex);\n\n      if (!match || !match.groups) {\n        throw new Error('Invalid data URI');\n      }\n\n      const mime = match.groups.mime;\n      const encoding = match.groups.encoding;\n      let module;\n\n      if (mime === 'application/wasm') {\n        if (!encoding) {\n          throw new Error('Missing data URI encoding');\n        }\n        if (encoding !== 'base64') {\n          throw new Error(`Invalid data URI encoding: ${encoding}`);\n        }\n        module = await this._importWasmModule(\n          Buffer.from(match.groups.code, 'base64'),\n          specifier,\n          context,\n        );\n      } else {\n        let code = match.groups.code;\n        if (!encoding || encoding === 'charset=utf-8') {\n          code = decodeURIComponent(code);\n        } else if (encoding === 'base64') {\n          code = Buffer.from(code, 'base64').toString();\n        } else {\n          throw new Error(`Invalid data URI encoding: ${encoding}`);\n        }\n\n        if (mime === 'application/json') {\n          module = new SyntheticModule(\n            ['default'],\n            function () {\n              const obj = JSON.parse(code);\n              // @ts-expect-error: TS doesn't know what `this` is\n              this.setExport('default', obj);\n            },\n            {context, identifier: specifier},\n          );\n        } else {\n          module = new SourceTextModule(code, {\n            context,\n            identifier: specifier,\n            importModuleDynamically: async (\n              specifier: string,\n              referencingModule: VMModule,\n            ) => {\n              invariant(\n                runtimeSupportsVmModules,\n                'You need to run with a version of node that supports ES Modules in the VM API. See https://jestjs.io/docs/ecmascript-modules',\n              );\n              const module = await this.resolveModule(\n                specifier,\n                referencingModule.identifier,\n                referencingModule.context,\n              );\n\n              return this.linkAndEvaluateModule(module);\n            },\n            initializeImportMeta(meta: ImportMeta) {\n              // no `jest` here as it's not loaded in a file\n              meta.url = specifier;\n\n              if (meta.url.startsWith('file://')) {\n                // @ts-expect-error Jest uses @types/node@16. Will be fixed when updated to @types/node@20.11.0\n                meta.filename = fileURLToPath(meta.url);\n                // @ts-expect-error Jest uses @types/node@16. Will be fixed when updated to @types/node@20.11.0\n                meta.dirname = path.dirname(meta.filename);\n              }\n            },\n          });\n        }\n      }\n\n      registry.set(specifier, module);\n      return module;\n    }\n\n    if (specifier.startsWith('file://')) {\n      specifier = fileURLToPath(specifier);\n    }\n\n    const [specifierPath, query] = specifier.split('?');\n\n    if (\n      await this._shouldMockModule(\n        referencingIdentifier,\n        specifierPath,\n        this._explicitShouldMockModule,\n      )\n    ) {\n      return this.importMock(referencingIdentifier, specifierPath, context);\n    }\n\n    const resolved = await this._resolveModule(\n      referencingIdentifier,\n      specifierPath,\n    );\n\n    if (\n      // json files are modules when imported in modules\n      resolved.endsWith('.json') ||\n      this._resolver.isCoreModule(resolved) ||\n      this.unstable_shouldLoadAsEsm(resolved)\n    ) {\n      return this.loadEsmModule(resolved, query);\n    }\n\n    return this.loadCjsAsEsm(referencingIdentifier, resolved, context);\n  }\n\n  private async linkAndEvaluateModule(\n    module: VMModule,\n  ): Promise<VMModule | void> {\n    if (this.isTornDown) {\n      this._logFormattedReferenceError(\n        'You are trying to `import` a file after the Jest environment has been torn down.',\n      );\n      process.exitCode = 1;\n      return;\n    }\n    if (this.isInsideTestCode === false) {\n      throw new ReferenceError(\n        'You are trying to `import` a file outside of the scope of the test code.',\n      );\n    }\n\n    if (module.status === 'unlinked') {\n      // since we might attempt to link the same module in parallel, stick the promise in a weak map so every call to\n      // this method can await it\n      this._esmModuleLinkingMap.set(\n        module,\n        module.link((specifier: string, referencingModule: VMModule) =>\n          this.resolveModule(\n            specifier,\n            referencingModule.identifier,\n            referencingModule.context,\n          ),\n        ),\n      );\n    }\n\n    await this._esmModuleLinkingMap.get(module);\n\n    if (module.status === 'linked') {\n      await module.evaluate();\n    }\n\n    return module;\n  }\n\n  async unstable_importModule(\n    from: string,\n    moduleName?: string,\n  ): Promise<unknown | void> {\n    invariant(\n      runtimeSupportsVmModules,\n      'You need to run with a version of node that supports ES Modules in the VM API. See https://jestjs.io/docs/ecmascript-modules',\n    );\n\n    const [path, query] = (moduleName ?? '').split('?');\n\n    const modulePath = await this._resolveModule(from, path);\n\n    const module = await this.loadEsmModule(modulePath, query);\n\n    return this.linkAndEvaluateModule(module);\n  }\n\n  private loadCjsAsEsm(from: string, modulePath: string, context: VMContext) {\n    // CJS loaded via `import` should share cache with other CJS: https://github.com/nodejs/modules/issues/503\n    const cjs = this.requireModuleOrMock(from, modulePath);\n\n    const parsedExports = this.getExportsOfCjs(modulePath);\n\n    const cjsExports = [...parsedExports].filter(exportName => {\n      // we don't wanna respect any exports _named_ default as a named export\n      if (exportName === 'default') {\n        return false;\n      }\n      return Object.hasOwnProperty.call(cjs, exportName);\n    });\n\n    const module = new SyntheticModule(\n      [...cjsExports, 'default'],\n      function () {\n        for (const exportName of cjsExports) {\n          // @ts-expect-error: TS doesn't know what `this` is\n          this.setExport(exportName, cjs[exportName]);\n        }\n        // @ts-expect-error: TS doesn't know what `this` is\n        this.setExport('default', cjs);\n      },\n      {context, identifier: modulePath},\n    );\n\n    return evaluateSyntheticModule(module);\n  }\n\n  private async importMock<T = unknown>(\n    from: string,\n    moduleName: string,\n    context: VMContext,\n  ): Promise<T> {\n    const moduleID = await this._resolver.getModuleIDAsync(\n      this._virtualModuleMocks,\n      from,\n      moduleName,\n      {conditions: this.esmConditions},\n    );\n\n    if (this._moduleMockRegistry.has(moduleID)) {\n      return this._moduleMockRegistry.get(moduleID);\n    }\n\n    if (this._moduleMockFactories.has(moduleID)) {\n      const invokedFactory: any = await this._moduleMockFactories.get(\n        moduleID,\n        // has check above makes this ok\n      )!();\n\n      const module = new SyntheticModule(\n        Object.keys(invokedFactory),\n        function () {\n          for (const [key, value] of Object.entries(invokedFactory)) {\n            // @ts-expect-error: TS doesn't know what `this` is\n            this.setExport(key, value);\n          }\n        },\n        {context, identifier: moduleName},\n      );\n\n      this._moduleMockRegistry.set(moduleID, module);\n\n      return evaluateSyntheticModule(module);\n    }\n\n    throw new Error('Attempting to import a mock without a factory');\n  }\n\n  private getExportsOfCjs(modulePath: string) {\n    const cachedNamedExports = this._cjsNamedExports.get(modulePath);\n\n    if (cachedNamedExports) {\n      return cachedNamedExports;\n    }\n\n    if (path.extname(modulePath) === '.node') {\n      const nativeModule = this.requireModuleOrMock('', modulePath);\n\n      const namedExports = new Set(\n        Object.keys(nativeModule as Record<string, unknown>),\n      );\n\n      this._cjsNamedExports.set(modulePath, namedExports);\n\n      return namedExports;\n    }\n\n    const transformedCode =\n      this._fileTransforms.get(modulePath)?.code ?? this.readFile(modulePath);\n\n    const {exports, reexports} = parseCjs(transformedCode);\n\n    const namedExports = new Set(exports);\n\n    for (const reexport of reexports) {\n      if (this._resolver.isCoreModule(reexport)) {\n        const exports = this.requireModule(modulePath, reexport);\n        if (exports !== null && typeof exports === 'object') {\n          for (const e of Object.keys(exports)) namedExports.add(e);\n        }\n      } else {\n        const resolved = this._resolveCjsModule(modulePath, reexport);\n\n        const exports = this.getExportsOfCjs(resolved);\n\n        for (const e of exports) namedExports.add(e);\n      }\n    }\n\n    this._cjsNamedExports.set(modulePath, namedExports);\n\n    return namedExports;\n  }\n\n  requireModule<T = unknown>(\n    from: string,\n    moduleName?: string,\n    options?: InternalModuleOptions,\n    isRequireActual = false,\n  ): T {\n    const isInternal = options?.isInternalModule ?? false;\n    const resolveModuleOptions = {conditions: this.cjsConditions};\n    const moduleID = this._resolver.getModuleID(\n      this._virtualMocks,\n      from,\n      moduleName,\n      resolveModuleOptions,\n    );\n    let modulePath: string | undefined;\n\n    // Some old tests rely on this mocking behavior. Ideally we'll change this\n    // to be more explicit.\n    const moduleResource = moduleName && this._resolver.getModule(moduleName);\n    const manualMock =\n      moduleName &&\n      this._resolver.getMockModule(from, moduleName, resolveModuleOptions);\n    if (\n      !options?.isInternalModule &&\n      !isRequireActual &&\n      !moduleResource &&\n      manualMock &&\n      manualMock !== this._isCurrentlyExecutingManualMock &&\n      this._explicitShouldMock.get(moduleID) !== false\n    ) {\n      modulePath = manualMock;\n    }\n\n    if (moduleName && this._resolver.isCoreModule(moduleName)) {\n      return this._requireCoreModule(\n        moduleName,\n        supportsNodeColonModulePrefixInRequire,\n      );\n    }\n\n    if (!modulePath) {\n      modulePath = this._resolveCjsModule(from, moduleName);\n    }\n\n    if (this.unstable_shouldLoadAsEsm(modulePath)) {\n      // Node includes more info in the message\n      const error: NodeJS.ErrnoException = new Error(\n        `Must use import to load ES Module: ${modulePath}`,\n      );\n\n      error.code = 'ERR_REQUIRE_ESM';\n\n      throw error;\n    }\n\n    let moduleRegistry;\n\n    if (isInternal) {\n      moduleRegistry = this._internalModuleRegistry;\n    } else if (this._isolatedModuleRegistry) {\n      moduleRegistry = this._isolatedModuleRegistry;\n    } else {\n      moduleRegistry = this._moduleRegistry;\n    }\n\n    const module = moduleRegistry.get(modulePath);\n    if (module) {\n      return module.exports;\n    }\n\n    // We must register the pre-allocated module object first so that any\n    // circular dependencies that may arise while evaluating the module can\n    // be satisfied.\n    const localModule: InitialModule = {\n      children: [],\n      exports: {},\n      filename: modulePath,\n      id: modulePath,\n      isPreloading: false,\n      loaded: false,\n      path: path.dirname(modulePath),\n    };\n    moduleRegistry.set(modulePath, localModule);\n\n    try {\n      this._loadModule(\n        localModule,\n        from,\n        moduleName,\n        modulePath,\n        options,\n        moduleRegistry,\n      );\n    } catch (error) {\n      moduleRegistry.delete(modulePath);\n      throw error;\n    }\n\n    return localModule.exports;\n  }\n\n  requireInternalModule<T = unknown>(from: string, to?: string): T {\n    if (to) {\n      const require = nativeModule.createRequire(from);\n      if (INTERNAL_MODULE_REQUIRE_OUTSIDE_OPTIMIZED_MODULES.has(to)) {\n        return require(to);\n      }\n      const outsideJestVmPath = decodePossibleOutsideJestVmPath(to);\n      if (outsideJestVmPath) {\n        return require(outsideJestVmPath);\n      }\n    }\n\n    return this.requireModule<T>(from, to, {\n      isInternalModule: true,\n      supportsDynamicImport: esmIsAvailable,\n      supportsExportNamespaceFrom: false,\n      supportsStaticESM: false,\n      supportsTopLevelAwait: false,\n    });\n  }\n\n  requireActual<T = unknown>(from: string, moduleName: string): T {\n    return this.requireModule<T>(from, moduleName, undefined, true);\n  }\n\n  requireMock<T = unknown>(from: string, moduleName: string): T {\n    const options = {conditions: this.cjsConditions};\n    const moduleID = this._resolver.getModuleID(\n      this._virtualMocks,\n      from,\n      moduleName,\n      options,\n    );\n\n    if (this._isolatedMockRegistry?.has(moduleID)) {\n      return this._isolatedMockRegistry.get(moduleID);\n    } else if (this._mockRegistry.has(moduleID)) {\n      return this._mockRegistry.get(moduleID);\n    }\n\n    const mockRegistry = this._isolatedMockRegistry || this._mockRegistry;\n\n    if (this._mockFactories.has(moduleID)) {\n      // has check above makes this ok\n      const module = this._mockFactories.get(moduleID)!();\n      mockRegistry.set(moduleID, module);\n      return module as T;\n    }\n\n    /** Resolved mock module path from (potentially aliased) module name. */\n    const manualMockPath: string | null = (() => {\n      // Attempt to get manual mock path when moduleName is a:\n\n      // A. Core module specifier i.e. ['fs', 'node:fs']:\n      // Normalize then check for a root manual mock '<rootDir>/__mocks__/'\n      if (this._resolver.isCoreModule(moduleName)) {\n        const moduleWithoutNodePrefix =\n          this._resolver.normalizeCoreModuleSpecifier(moduleName);\n        return this._resolver.getMockModule(\n          from,\n          moduleWithoutNodePrefix,\n          options,\n        );\n      }\n\n      // B. Node module specifier i.e. ['jest', 'react']:\n      // Look for root manual mock\n      const rootMock = this._resolver.getMockModule(from, moduleName, options);\n      if (rootMock) return rootMock;\n\n      // C. Relative/Absolute path:\n      // If the actual module file has a __mocks__ dir sitting immediately next\n      // to it, look to see if there is a manual mock for this file.\n      //\n      // subDir1/my_module.js\n      // subDir1/__mocks__/my_module.js\n      // subDir2/my_module.js\n      // subDir2/__mocks__/my_module.js\n      //\n      // Where some other module does a relative require into each of the\n      // respective subDir{1,2} directories and expects a manual mock\n      // corresponding to that particular my_module.js file.\n      const modulePath = this._resolveCjsModule(from, moduleName);\n      const moduleDir = path.dirname(modulePath);\n      const moduleFileName = path.basename(modulePath);\n      const potentialManualMock = path.join(\n        moduleDir,\n        '__mocks__',\n        moduleFileName,\n      );\n      if (fs.existsSync(potentialManualMock)) {\n        return potentialManualMock;\n      }\n\n      return null;\n    })();\n\n    if (manualMockPath) {\n      const localModule: InitialModule = {\n        children: [],\n        exports: {},\n        filename: manualMockPath,\n        id: manualMockPath,\n        isPreloading: false,\n        loaded: false,\n        path: path.dirname(manualMockPath),\n      };\n\n      this._loadModule(\n        localModule,\n        from,\n        moduleName,\n        manualMockPath,\n        undefined,\n        mockRegistry,\n      );\n\n      mockRegistry.set(moduleID, localModule.exports);\n    } else {\n      // Look for a real module to generate an automock from\n      mockRegistry.set(moduleID, this._generateMock(from, moduleName));\n    }\n\n    return mockRegistry.get(moduleID);\n  }\n\n  private _loadModule(\n    localModule: InitialModule,\n    from: string,\n    moduleName: string | undefined,\n    modulePath: string,\n    options: InternalModuleOptions | undefined,\n    moduleRegistry: ModuleRegistry,\n  ) {\n    if (path.extname(modulePath) === '.json') {\n      const text = stripBOM(this.readFile(modulePath));\n\n      const transformedFile = this._scriptTransformer.transformJson(\n        modulePath,\n        this._getFullTransformationOptions(options),\n        text,\n      );\n\n      localModule.exports =\n        this._environment.global.JSON.parse(transformedFile);\n    } else if (path.extname(modulePath) === '.node') {\n      localModule.exports = require(modulePath);\n    } else {\n      // Only include the fromPath if a moduleName is given. Else treat as root.\n      const fromPath = moduleName ? from : null;\n      this._execModule(\n        localModule,\n        options,\n        moduleRegistry,\n        fromPath,\n        moduleName,\n      );\n    }\n    localModule.loaded = true;\n  }\n\n  private _getFullTransformationOptions(\n    options: InternalModuleOptions = defaultTransformOptions,\n  ): TransformationOptions {\n    return {\n      ...options,\n      ...this._coverageOptions,\n    };\n  }\n\n  requireModuleOrMock<T = unknown>(from: string, moduleName: string): T {\n    // this module is unmockable\n    if (moduleName === '@jest/globals') {\n      // @ts-expect-error: we don't care that it's not assignable to T\n      return this.getGlobalsForCjs(from);\n    }\n\n    try {\n      if (this._shouldMockCjs(from, moduleName, this._explicitShouldMock)) {\n        return this.requireMock<T>(from, moduleName);\n      } else {\n        return this.requireModule<T>(from, moduleName);\n      }\n    } catch (error) {\n      const moduleNotFound = Resolver.tryCastModuleNotFoundError(error);\n      if (moduleNotFound) {\n        if (\n          moduleNotFound.siblingWithSimilarExtensionFound === null ||\n          moduleNotFound.siblingWithSimilarExtensionFound === undefined\n        ) {\n          moduleNotFound.hint = findSiblingsWithFileExtension(\n            this._config.moduleFileExtensions,\n            from,\n            moduleNotFound.moduleName || moduleName,\n          );\n          moduleNotFound.siblingWithSimilarExtensionFound = Boolean(\n            moduleNotFound.hint,\n          );\n        }\n        moduleNotFound.buildMessage(this._config.rootDir);\n        throw moduleNotFound;\n      }\n      throw error;\n    }\n  }\n\n  isolateModules(fn: () => void): void {\n    if (this._isolatedModuleRegistry || this._isolatedMockRegistry) {\n      throw new Error(\n        'isolateModules cannot be nested inside another isolateModules or isolateModulesAsync.',\n      );\n    }\n    this._isolatedModuleRegistry = new Map();\n    this._isolatedMockRegistry = new Map();\n    try {\n      fn();\n    } finally {\n      // might be cleared within the callback\n      this._isolatedModuleRegistry?.clear();\n      this._isolatedMockRegistry?.clear();\n      this._isolatedModuleRegistry = null;\n      this._isolatedMockRegistry = null;\n    }\n  }\n\n  async isolateModulesAsync(fn: () => Promise<void>): Promise<void> {\n    if (this._isolatedModuleRegistry || this._isolatedMockRegistry) {\n      throw new Error(\n        'isolateModulesAsync cannot be nested inside another isolateModulesAsync or isolateModules.',\n      );\n    }\n    this._isolatedModuleRegistry = new Map();\n    this._isolatedMockRegistry = new Map();\n    try {\n      await fn();\n    } finally {\n      // might be cleared within the callback\n      this._isolatedModuleRegistry?.clear();\n      this._isolatedMockRegistry?.clear();\n      this._isolatedModuleRegistry = null;\n      this._isolatedMockRegistry = null;\n    }\n  }\n\n  resetModules(): void {\n    this._isolatedModuleRegistry?.clear();\n    this._isolatedMockRegistry?.clear();\n    this._isolatedModuleRegistry = null;\n    this._isolatedMockRegistry = null;\n    this._mockRegistry.clear();\n    this._moduleRegistry.clear();\n    this._esmoduleRegistry.clear();\n    this._fileTransformsMutex.clear();\n    this._cjsNamedExports.clear();\n    this._moduleMockRegistry.clear();\n    this._cacheFS.clear();\n    this._cacheFSBuffer.clear();\n\n    if (\n      this._coverageOptions.collectCoverage &&\n      this._coverageOptions.coverageProvider === 'v8' &&\n      this._v8CoverageSources\n    ) {\n      this._v8CoverageSources = new Map([\n        ...this._v8CoverageSources,\n        ...this._fileTransforms,\n      ]);\n    }\n\n    this._fileTransforms.clear();\n\n    if (this._environment) {\n      if (this._environment.global) {\n        const envGlobal = this._environment.global;\n        for (const key of Object.keys(envGlobal) as Array<\n          keyof typeof globalThis\n        >) {\n          const globalMock = envGlobal[key];\n          if (\n            ((typeof globalMock === 'object' && globalMock !== null) ||\n              typeof globalMock === 'function') &&\n            '_isMockFunction' in globalMock &&\n            globalMock._isMockFunction === true\n          ) {\n            globalMock.mockClear();\n          }\n        }\n      }\n\n      if (this._environment.fakeTimers) {\n        this._environment.fakeTimers.clearAllTimers();\n      }\n    }\n  }\n\n  async collectV8Coverage(): Promise<void> {\n    this._v8CoverageInstrumenter = new CoverageInstrumenter();\n    this._v8CoverageSources = new Map();\n\n    await this._v8CoverageInstrumenter.startInstrumenting();\n  }\n\n  async stopCollectingV8Coverage(): Promise<void> {\n    if (!this._v8CoverageInstrumenter || !this._v8CoverageSources) {\n      throw new Error('You need to call `collectV8Coverage` first.');\n    }\n    this._v8CoverageResult =\n      await this._v8CoverageInstrumenter.stopInstrumenting();\n    this._v8CoverageSources = new Map([\n      ...this._v8CoverageSources,\n      ...this._fileTransforms,\n    ]);\n  }\n\n  getAllCoverageInfoCopy(): JestEnvironment['global']['__coverage__'] {\n    return deepCyclicCopy(this._environment.global.__coverage__);\n  }\n\n  getAllV8CoverageInfoCopy(): V8CoverageResult {\n    if (!this._v8CoverageResult || !this._v8CoverageSources) {\n      throw new Error('You need to call `stopCollectingV8Coverage` first.');\n    }\n\n    return this._v8CoverageResult\n      .filter(res => res.url.startsWith('file://'))\n      .map(res => ({...res, url: fileURLToPath(res.url)}))\n      .filter(\n        res =>\n          // TODO: will this work on windows? It might be better if `shouldInstrument` deals with it anyways\n          res.url.startsWith(this._config.rootDir) &&\n          shouldInstrument(\n            res.url,\n            this._coverageOptions,\n            this._config,\n            /* loadedFilenames */ [...this._v8CoverageSources!.keys()],\n          ),\n      )\n      .map(result => {\n        const transformedFile = this._v8CoverageSources!.get(result.url);\n\n        return {\n          codeTransformResult: transformedFile,\n          result,\n        };\n      });\n  }\n\n  getSourceMaps(): SourceMapRegistry {\n    return this._sourceMapRegistry;\n  }\n\n  setMock(\n    from: string,\n    moduleName: string,\n    mockFactory: () => unknown,\n    options?: {virtual?: boolean},\n  ): void {\n    if (options?.virtual) {\n      const mockPath = this._resolver.getModulePath(from, moduleName);\n\n      this._virtualMocks.set(mockPath, true);\n    }\n    const moduleID = this._resolver.getModuleID(\n      this._virtualMocks,\n      from,\n      moduleName,\n      {conditions: this.cjsConditions},\n    );\n    this._explicitShouldMock.set(moduleID, true);\n    this._mockFactories.set(moduleID, mockFactory);\n  }\n\n  private setModuleMock(\n    from: string,\n    moduleName: string,\n    mockFactory: () => Promise<unknown> | unknown,\n    options?: {virtual?: boolean},\n  ): void {\n    if (options?.virtual) {\n      const mockPath = this._resolver.getModulePath(from, moduleName);\n\n      this._virtualModuleMocks.set(mockPath, true);\n    }\n    const moduleID = this._resolver.getModuleID(\n      this._virtualModuleMocks,\n      from,\n      moduleName,\n      {conditions: this.esmConditions},\n    );\n    this._explicitShouldMockModule.set(moduleID, true);\n    this._moduleMockFactories.set(moduleID, mockFactory);\n  }\n\n  restoreAllMocks(): void {\n    this._moduleMocker.restoreAllMocks();\n  }\n\n  resetAllMocks(): void {\n    this._moduleMocker.resetAllMocks();\n  }\n\n  clearAllMocks(): void {\n    this._moduleMocker.clearAllMocks();\n  }\n\n  enterTestCode(): void {\n    this.isInsideTestCode = true;\n  }\n\n  leaveTestCode(): void {\n    this.isInsideTestCode = false;\n  }\n\n  teardown(): void {\n    this.restoreAllMocks();\n    this.resetModules();\n\n    this._internalModuleRegistry.clear();\n    this._mainModule = null;\n    this._mockFactories.clear();\n    this._moduleMockFactories.clear();\n    this._mockMetaDataCache.clear();\n    this._shouldMockModuleCache.clear();\n    this._shouldUnmockTransitiveDependenciesCache.clear();\n    this._explicitShouldMock.clear();\n    this._explicitShouldMockModule.clear();\n    this._transitiveShouldMock.clear();\n    this._virtualMocks.clear();\n    this._virtualModuleMocks.clear();\n    this._cacheFS.clear();\n    this._unmockList = undefined;\n\n    this._sourceMapRegistry.clear();\n\n    this._fileTransforms.clear();\n    this.jestObjectCaches.clear();\n\n    this._v8CoverageSources?.clear();\n    this._v8CoverageResult = [];\n    this._v8CoverageInstrumenter = undefined;\n    this._moduleImplementation = undefined;\n\n    this.isTornDown = true;\n  }\n\n  private _resolveCjsModule(from: string, to: string | undefined) {\n    return to\n      ? this._resolver.resolveModule(from, to, {\n          conditions: this.cjsConditions,\n        })\n      : from;\n  }\n\n  private _resolveModule(from: string, to: string | undefined) {\n    return to\n      ? this._resolver.resolveModuleAsync(from, to, {\n          conditions: this.esmConditions,\n        })\n      : from;\n  }\n\n  private _requireResolve(\n    from: string,\n    moduleName?: string,\n    options: ResolveOptions = {},\n  ) {\n    if (moduleName == null) {\n      throw new Error(\n        'The first argument to require.resolve must be a string. Received null or undefined.',\n      );\n    }\n\n    if (path.isAbsolute(moduleName)) {\n      const module = this._resolver.resolveModuleFromDirIfExists(\n        moduleName,\n        moduleName,\n        {conditions: this.cjsConditions, paths: []},\n      );\n      if (module) {\n        return module;\n      }\n    } else if (options.paths) {\n      for (const p of options.paths) {\n        const absolutePath = path.resolve(from, '..', p);\n        const module = this._resolver.resolveModuleFromDirIfExists(\n          absolutePath,\n          moduleName,\n          // required to also resolve files without leading './' directly in the path\n          {conditions: this.cjsConditions, paths: [absolutePath]},\n        );\n        if (module) {\n          return module;\n        }\n      }\n\n      throw new Resolver.ModuleNotFoundError(\n        `Cannot resolve module '${moduleName}' from paths ['${options.paths.join(\n          \"', '\",\n        )}'] from ${from}`,\n      );\n    }\n\n    try {\n      return this._resolveCjsModule(from, moduleName);\n    } catch (error) {\n      const module = this._resolver.getMockModule(from, moduleName, {\n        conditions: this.cjsConditions,\n      });\n\n      if (module) {\n        return module;\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  private _requireResolvePaths(from: string, moduleName?: string) {\n    const fromDir = path.resolve(from, '..');\n    if (moduleName == null) {\n      throw new Error(\n        'The first argument to require.resolve.paths must be a string. Received null or undefined.',\n      );\n    }\n    if (moduleName.length === 0) {\n      throw new Error(\n        'The first argument to require.resolve.paths must not be the empty string.',\n      );\n    }\n\n    if (moduleName[0] === '.') {\n      return [fromDir];\n    }\n    if (this._resolver.isCoreModule(moduleName)) {\n      return null;\n    }\n    const modulePaths = this._resolver.getModulePaths(fromDir);\n    const globalPaths = this._resolver.getGlobalPaths(moduleName);\n    return [...modulePaths, ...globalPaths];\n  }\n\n  private _execModule(\n    localModule: InitialModule,\n    options: InternalModuleOptions | undefined,\n    moduleRegistry: ModuleRegistry,\n    from: string | null,\n    moduleName?: string,\n  ) {\n    if (this.isTornDown) {\n      this._logFormattedReferenceError(\n        'You are trying to `import` a file after the Jest environment has been torn down.',\n      );\n      process.exitCode = 1;\n      return;\n    }\n    if (this.isInsideTestCode === false) {\n      throw new ReferenceError(\n        'You are trying to `import` a file outside of the scope of the test code.',\n      );\n    }\n\n    // If the environment was disposed, prevent this module from being executed.\n    if (!this._environment.global) {\n      return;\n    }\n\n    const module = localModule as Module;\n\n    const filename = module.filename;\n    const lastExecutingModulePath = this._currentlyExecutingModulePath;\n    this._currentlyExecutingModulePath = filename;\n    const origCurrExecutingManualMock = this._isCurrentlyExecutingManualMock;\n    this._isCurrentlyExecutingManualMock = filename;\n\n    module.children = [];\n\n    Object.defineProperty(module, 'parent', {\n      enumerable: true,\n      get() {\n        const key = from || '';\n        return moduleRegistry.get(key) || null;\n      },\n    });\n    const modulePaths = this._resolver.getModulePaths(module.path);\n    const globalPaths = this._resolver.getGlobalPaths(moduleName);\n    module.paths = [...modulePaths, ...globalPaths];\n\n    Object.defineProperty(module, 'require', {\n      value: this._createRequireImplementation(module, options),\n    });\n\n    const transformedCode = this.transformFile(filename, options);\n\n    const compiledFunction = this.createScriptFromCode(\n      transformedCode,\n      filename,\n    );\n\n    if (compiledFunction === null) {\n      this._logFormattedReferenceError(\n        'You are trying to `import` a file after the Jest environment has been torn down.',\n      );\n      process.exitCode = 1;\n      return;\n    }\n\n    const jestObject = this._createJestObjectFor(filename);\n\n    this.jestObjectCaches.set(filename, jestObject);\n\n    const lastArgs: [Jest | undefined, ...Array<Global.Global>] = [\n      this._config.injectGlobals ? jestObject : undefined, // jest object\n      ...this._config.sandboxInjectedGlobals.map<Global.Global>(\n        globalVariable => {\n          if (this._environment.global[globalVariable]) {\n            return this._environment.global[globalVariable];\n          }\n\n          throw new Error(\n            `You have requested '${globalVariable}' as a global variable, but it was not present. Please check your config or your global environment.`,\n          );\n        },\n      ),\n    ];\n\n    if (!this._mainModule && filename === this._testPath) {\n      this._mainModule = module;\n    }\n\n    Object.defineProperty(module, 'main', {\n      enumerable: true,\n      value: this._mainModule,\n    });\n\n    try {\n      compiledFunction.call(\n        module.exports,\n        module, // module object\n        module.exports, // module exports\n        module.require, // require implementation\n        module.path, // __dirname\n        module.filename, // __filename\n        lastArgs[0],\n        ...lastArgs.slice(1).filter(isNonNullable),\n      );\n    } catch (error: any) {\n      this.handleExecutionError(error, module);\n    }\n\n    this._isCurrentlyExecutingManualMock = origCurrExecutingManualMock;\n    this._currentlyExecutingModulePath = lastExecutingModulePath;\n  }\n\n  private transformFile(\n    filename: string,\n    options?: InternalModuleOptions,\n  ): string {\n    const source = this.readFile(filename);\n\n    if (options?.isInternalModule) {\n      return source;\n    }\n\n    const transformedFile = this._scriptTransformer.transform(\n      filename,\n      this._getFullTransformationOptions(options),\n      source,\n    );\n\n    this._fileTransforms.set(filename, transformedFile);\n\n    if (transformedFile.sourceMapPath) {\n      this._sourceMapRegistry.set(filename, transformedFile.sourceMapPath);\n    }\n    return transformedFile.code;\n  }\n\n  private async transformFileAsync(\n    filename: string,\n    options?: InternalModuleOptions,\n  ): Promise<string> {\n    const source = this.readFile(filename);\n\n    if (options?.isInternalModule) {\n      return source;\n    }\n\n    const transformedFile = await this._scriptTransformer.transformAsync(\n      filename,\n      this._getFullTransformationOptions(options),\n      source,\n    );\n\n    if (this._fileTransforms.get(filename)?.code !== transformedFile.code) {\n      this._fileTransforms.set(filename, transformedFile);\n    }\n\n    if (transformedFile.sourceMapPath) {\n      this._sourceMapRegistry.set(filename, transformedFile.sourceMapPath);\n    }\n    return transformedFile.code;\n  }\n\n  private createScriptFromCode(scriptSource: string, filename: string) {\n    const vmContext = this._environment.getVmContext();\n\n    if (vmContext == null) {\n      return null;\n    }\n\n    try {\n      const scriptFilename = this._resolver.isCoreModule(filename)\n        ? `jest-nodejs-core-${filename}`\n        : filename;\n      return compileFunction(\n        scriptSource,\n        this.constructInjectedModuleParameters(),\n        {\n          filename: scriptFilename,\n          // @ts-expect-error: Experimental ESM API\n          importModuleDynamically: async (specifier: string) => {\n            invariant(\n              runtimeSupportsVmModules,\n              'You need to run with a version of node that supports ES Modules in the VM API. See https://jestjs.io/docs/ecmascript-modules',\n            );\n\n            const module = await this.resolveModule(\n              specifier,\n              scriptFilename,\n              vmContext,\n            );\n\n            return this.linkAndEvaluateModule(module);\n          },\n          parsingContext: vmContext,\n        },\n      ) as ModuleWrapper;\n    } catch (error: any) {\n      throw handlePotentialSyntaxError(error);\n    }\n  }\n\n  private _requireCoreModule(moduleName: string, supportPrefix: boolean) {\n    const moduleWithoutNodePrefix =\n      supportPrefix && this._resolver.normalizeCoreModuleSpecifier(moduleName);\n\n    if (moduleWithoutNodePrefix === 'process') {\n      return this._environment.global.process;\n    }\n\n    if (moduleWithoutNodePrefix === 'module') {\n      return this._getMockedNativeModule();\n    }\n\n    const coreModule = require(moduleName);\n    protectProperties(coreModule);\n    return coreModule;\n  }\n\n  private _importCoreModule(moduleName: string, context: VMContext) {\n    const required = this._requireCoreModule(moduleName, true);\n    const allExports = Object.entries(required);\n    const exportNames = allExports.map(([key]) => key);\n\n    const module = new SyntheticModule(\n      ['default', ...exportNames],\n      function () {\n        // @ts-expect-error: TS doesn't know what `this` is\n        this.setExport('default', required);\n        for (const [key, value] of allExports) {\n          // @ts-expect-error: TS doesn't know what `this` is\n          this.setExport(key, value);\n        }\n      },\n      // should identifier be `node://${moduleName}`?\n      {context, identifier: moduleName},\n    );\n\n    return evaluateSyntheticModule(module);\n  }\n\n  private async _importWasmModule(\n    source: Buffer,\n    identifier: string,\n    context: VMContext,\n  ) {\n    const wasmModule = await WebAssembly.compile(source);\n\n    const exports = WebAssembly.Module.exports(wasmModule);\n    const imports = WebAssembly.Module.imports(wasmModule);\n\n    const moduleLookup: Record<string, VMModule> = {};\n    for (const {module} of imports) {\n      if (moduleLookup[module] === undefined) {\n        const resolvedModule = await this.resolveModule(\n          module,\n          identifier,\n          context,\n        );\n\n        moduleLookup[module] = await this.linkAndEvaluateModule(resolvedModule);\n      }\n    }\n\n    const syntheticModule = new SyntheticModule(\n      exports.map(({name}) => name),\n      function () {\n        const importsObject: WebAssembly.Imports = {};\n        for (const {module, name} of imports) {\n          if (!importsObject[module]) {\n            importsObject[module] = {};\n          }\n          importsObject[module][name] = moduleLookup[module].namespace[name];\n        }\n        const wasmInstance = new WebAssembly.Instance(\n          wasmModule,\n          importsObject,\n        );\n        for (const {name} of exports) {\n          // @ts-expect-error: TS doesn't know what `this` is\n          this.setExport(name, wasmInstance.exports[name]);\n        }\n      },\n      {context, identifier},\n    );\n\n    return syntheticModule;\n  }\n\n  private _getMockedNativeModule(): typeof nativeModule.Module {\n    if (this._moduleImplementation) {\n      return this._moduleImplementation;\n    }\n\n    // eslint-disable-next-line unicorn/consistent-function-scoping\n    const createRequire = (modulePath: string | URL) => {\n      const filename =\n        typeof modulePath === 'string'\n          ? modulePath.startsWith('file:///')\n            ? fileURLToPath(new URL(modulePath))\n            : modulePath\n          : fileURLToPath(modulePath);\n\n      if (!path.isAbsolute(filename)) {\n        const error: NodeJS.ErrnoException = new TypeError(\n          `The argument 'filename' must be a file URL object, file URL string, or absolute path string. Received '${filename}'`,\n        );\n        error.code = 'ERR_INVALID_ARG_TYPE';\n        throw error;\n      }\n\n      return this._createRequireImplementation({\n        children: [],\n        exports: {},\n        filename,\n        id: filename,\n        isPreloading: false,\n        loaded: false,\n        path: path.dirname(filename),\n      });\n    };\n\n    // should we implement the class ourselves?\n    class Module extends nativeModule.Module {}\n\n    for (const [key, value] of Object.entries(nativeModule.Module)) {\n      // @ts-expect-error: no index signature\n      Module[key] = value;\n    }\n\n    Module.Module = Module;\n\n    if ('createRequire' in nativeModule) {\n      Module.createRequire = createRequire;\n    }\n    if ('syncBuiltinESMExports' in nativeModule) {\n      // cast since TS seems very confused about whether it exists or not\n      (Module as any).syncBuiltinESMExports =\n        // eslint-disable-next-line @typescript-eslint/no-empty-function\n        function syncBuiltinESMExports() {};\n    }\n\n    this._moduleImplementation = Module;\n\n    return Module;\n  }\n\n  private _generateMock<T>(from: string, moduleName: string) {\n    const modulePath =\n      this._resolver.resolveStubModuleName(from, moduleName, {\n        conditions: this.cjsConditions,\n      }) || this._resolveCjsModule(from, moduleName);\n    if (!this._mockMetaDataCache.has(modulePath)) {\n      // This allows us to handle circular dependencies while generating an\n      // automock\n\n      this._mockMetaDataCache.set(\n        modulePath,\n        this._moduleMocker.getMetadata({}) || {},\n      );\n\n      // In order to avoid it being possible for automocking to potentially\n      // cause side-effects within the module environment, we need to execute\n      // the module in isolation. This could cause issues if the module being\n      // mocked has calls into side-effectful APIs on another module.\n      const origMockRegistry = this._mockRegistry;\n      const origModuleRegistry = this._moduleRegistry;\n      this._mockRegistry = new Map();\n      this._moduleRegistry = new Map();\n\n      const moduleExports = this.requireModule(from, moduleName);\n\n      // Restore the \"real\" module/mock registries\n      this._mockRegistry = origMockRegistry;\n      this._moduleRegistry = origModuleRegistry;\n\n      const mockMetadata = this._moduleMocker.getMetadata(moduleExports);\n      if (mockMetadata == null) {\n        throw new Error(\n          `Failed to get mock metadata: ${modulePath}\\n\\n` +\n            'See: https://jestjs.io/docs/manual-mocks#content',\n        );\n      }\n      this._mockMetaDataCache.set(modulePath, mockMetadata);\n    }\n    let moduleMock = this._moduleMocker.generateFromMetadata<T>(\n      // added above if missing\n      this._mockMetaDataCache.get(modulePath)!,\n    );\n\n    for (const onGenerateMock of this._onGenerateMock) {\n      moduleMock = onGenerateMock(modulePath, moduleMock);\n    }\n\n    return moduleMock;\n  }\n\n  private _shouldMockCjs(\n    from: string,\n    moduleName: string,\n    explicitShouldMock: Map<string, boolean>,\n  ): boolean {\n    const options: ResolveModuleConfig = {conditions: this.cjsConditions};\n    const moduleID = this._resolver.getModuleID(\n      this._virtualMocks,\n      from,\n      moduleName,\n      options,\n    );\n    const key = from + path.delimiter + moduleID;\n\n    if (explicitShouldMock.has(moduleID)) {\n      // guaranteed by `has` above\n      return explicitShouldMock.get(moduleID)!;\n    }\n\n    if (\n      !this._shouldAutoMock ||\n      this._resolver.isCoreModule(moduleName) ||\n      this._shouldUnmockTransitiveDependenciesCache.get(key)\n    ) {\n      return false;\n    }\n\n    if (this._shouldMockModuleCache.has(moduleID)) {\n      // guaranteed by `has` above\n      return this._shouldMockModuleCache.get(moduleID)!;\n    }\n\n    let modulePath;\n    try {\n      modulePath = this._resolveCjsModule(from, moduleName);\n    } catch (error) {\n      const manualMock = this._resolver.getMockModule(\n        from,\n        moduleName,\n        options,\n      );\n      if (manualMock) {\n        this._shouldMockModuleCache.set(moduleID, true);\n        return true;\n      }\n      throw error;\n    }\n\n    if (this._unmockList && this._unmockList.test(modulePath)) {\n      this._shouldMockModuleCache.set(moduleID, false);\n      return false;\n    }\n\n    // transitive unmocking for package managers that store flat packages (npm3)\n    const currentModuleID = this._resolver.getModuleID(\n      this._virtualMocks,\n      from,\n      undefined,\n      options,\n    );\n    if (\n      this._transitiveShouldMock.get(currentModuleID) === false ||\n      (from.includes(NODE_MODULES) &&\n        modulePath.includes(NODE_MODULES) &&\n        ((this._unmockList && this._unmockList.test(from)) ||\n          explicitShouldMock.get(currentModuleID) === false))\n    ) {\n      this._transitiveShouldMock.set(moduleID, false);\n      this._shouldUnmockTransitiveDependenciesCache.set(key, true);\n      return false;\n    }\n    this._shouldMockModuleCache.set(moduleID, true);\n    return true;\n  }\n\n  private async _shouldMockModule(\n    from: string,\n    moduleName: string,\n    explicitShouldMock: Map<string, boolean>,\n  ): Promise<boolean> {\n    const options: ResolveModuleConfig = {conditions: this.esmConditions};\n    const moduleID = await this._resolver.getModuleIDAsync(\n      this._virtualMocks,\n      from,\n      moduleName,\n      options,\n    );\n    const key = from + path.delimiter + moduleID;\n\n    if (explicitShouldMock.has(moduleID)) {\n      // guaranteed by `has` above\n      return explicitShouldMock.get(moduleID)!;\n    }\n\n    if (\n      !this._shouldAutoMock ||\n      this._resolver.isCoreModule(moduleName) ||\n      this._shouldUnmockTransitiveDependenciesCache.get(key)\n    ) {\n      return false;\n    }\n\n    if (this._shouldMockModuleCache.has(moduleID)) {\n      // guaranteed by `has` above\n      return this._shouldMockModuleCache.get(moduleID)!;\n    }\n\n    let modulePath;\n    try {\n      modulePath = await this._resolveModule(from, moduleName);\n    } catch (error) {\n      const manualMock = await this._resolver.getMockModuleAsync(\n        from,\n        moduleName,\n        options,\n      );\n      if (manualMock) {\n        this._shouldMockModuleCache.set(moduleID, true);\n        return true;\n      }\n      throw error;\n    }\n\n    if (this._unmockList && this._unmockList.test(modulePath)) {\n      this._shouldMockModuleCache.set(moduleID, false);\n      return false;\n    }\n\n    // transitive unmocking for package managers that store flat packages (npm3)\n    const currentModuleID = await this._resolver.getModuleIDAsync(\n      this._virtualMocks,\n      from,\n      undefined,\n      options,\n    );\n    if (\n      this._transitiveShouldMock.get(currentModuleID) === false ||\n      (from.includes(NODE_MODULES) &&\n        modulePath.includes(NODE_MODULES) &&\n        ((this._unmockList && this._unmockList.test(from)) ||\n          explicitShouldMock.get(currentModuleID) === false))\n    ) {\n      this._transitiveShouldMock.set(moduleID, false);\n      this._shouldUnmockTransitiveDependenciesCache.set(key, true);\n      return false;\n    }\n    this._shouldMockModuleCache.set(moduleID, true);\n    return true;\n  }\n\n  private _createRequireImplementation(\n    from: InitialModule,\n    options?: InternalModuleOptions,\n  ): NodeRequire {\n    const resolve = (moduleName: string, resolveOptions?: ResolveOptions) => {\n      const resolved = this._requireResolve(\n        from.filename,\n        moduleName,\n        resolveOptions,\n      );\n      if (\n        resolveOptions?.[JEST_RESOLVE_OUTSIDE_VM_OPTION] &&\n        options?.isInternalModule\n      ) {\n        return createOutsideJestVmPath(resolved);\n      }\n      return resolved;\n    };\n    resolve.paths = (moduleName: string) =>\n      this._requireResolvePaths(from.filename, moduleName);\n\n    const moduleRequire = (\n      options?.isInternalModule\n        ? (moduleName: string) =>\n            this.requireInternalModule(from.filename, moduleName)\n        : this.requireModuleOrMock.bind(this, from.filename)\n    ) as NodeRequire;\n    moduleRequire.extensions = Object.create(null);\n    moduleRequire.resolve = resolve;\n    moduleRequire.cache = (() => {\n      // TODO: consider warning somehow that this does nothing. We should support deletions, anyways\n      const notPermittedMethod = () => true;\n      return new Proxy<(typeof moduleRequire)['cache']>(Object.create(null), {\n        defineProperty: notPermittedMethod,\n        deleteProperty: notPermittedMethod,\n        get: (_target, key) =>\n          typeof key === 'string' ? this._moduleRegistry.get(key) : undefined,\n        getOwnPropertyDescriptor() {\n          return {\n            configurable: true,\n            enumerable: true,\n          };\n        },\n        has: (_target, key) =>\n          typeof key === 'string' && this._moduleRegistry.has(key),\n        ownKeys: () => [...this._moduleRegistry.keys()],\n        set: notPermittedMethod,\n      });\n    })();\n\n    Object.defineProperty(moduleRequire, 'main', {\n      enumerable: true,\n      value: this._mainModule,\n    });\n\n    return moduleRequire;\n  }\n\n  private _createJestObjectFor(from: string): Jest {\n    const disableAutomock = () => {\n      this._shouldAutoMock = false;\n      return jestObject;\n    };\n    const enableAutomock = () => {\n      this._shouldAutoMock = true;\n      return jestObject;\n    };\n    const unmock = (moduleName: string) => {\n      const moduleID = this._resolver.getModuleID(\n        this._virtualMocks,\n        from,\n        moduleName,\n        {conditions: this.cjsConditions},\n      );\n      this._explicitShouldMock.set(moduleID, false);\n      return jestObject;\n    };\n    const unmockModule = (moduleName: string) => {\n      const moduleID = this._resolver.getModuleID(\n        this._virtualModuleMocks,\n        from,\n        moduleName,\n        {conditions: this.esmConditions},\n      );\n      this._explicitShouldMockModule.set(moduleID, false);\n      return jestObject;\n    };\n    const deepUnmock = (moduleName: string) => {\n      const moduleID = this._resolver.getModuleID(\n        this._virtualMocks,\n        from,\n        moduleName,\n        {conditions: this.cjsConditions},\n      );\n      this._explicitShouldMock.set(moduleID, false);\n      this._transitiveShouldMock.set(moduleID, false);\n      return jestObject;\n    };\n    const mock: Jest['mock'] = (moduleName, mockFactory, options) => {\n      if (mockFactory !== undefined) {\n        return setMockFactory(moduleName, mockFactory, options);\n      }\n\n      const moduleID = this._resolver.getModuleID(\n        this._virtualMocks,\n        from,\n        moduleName,\n        {conditions: this.cjsConditions},\n      );\n      this._explicitShouldMock.set(moduleID, true);\n      return jestObject;\n    };\n    const onGenerateMock: Jest['onGenerateMock'] = <T>(\n      cb: (moduleName: string, moduleMock: T) => T,\n    ) => {\n      this._onGenerateMock.add(cb);\n      return jestObject;\n    };\n    const setMockFactory = (\n      moduleName: string,\n      mockFactory: () => unknown,\n      options?: {virtual?: boolean},\n    ) => {\n      this.setMock(from, moduleName, mockFactory, options);\n      return jestObject;\n    };\n    const mockModule: Jest['unstable_mockModule'] = (\n      moduleName,\n      mockFactory,\n      options,\n    ) => {\n      if (typeof mockFactory !== 'function') {\n        throw new TypeError(\n          '`unstable_mockModule` must be passed a mock factory',\n        );\n      }\n\n      this.setModuleMock(from, moduleName, mockFactory, options);\n      return jestObject;\n    };\n    const clearAllMocks = () => {\n      this.clearAllMocks();\n      return jestObject;\n    };\n    const resetAllMocks = () => {\n      this.resetAllMocks();\n      return jestObject;\n    };\n    const restoreAllMocks = () => {\n      this.restoreAllMocks();\n      return jestObject;\n    };\n    // eslint-disable-next-line unicorn/consistent-function-scoping\n    const _getFakeTimers = () => {\n      if (\n        this.isTornDown ||\n        !(this._environment.fakeTimers || this._environment.fakeTimersModern)\n      ) {\n        this._logFormattedReferenceError(\n          'You are trying to access a property or method of the Jest environment after it has been torn down.',\n        );\n        process.exitCode = 1;\n      }\n      if (this.isInsideTestCode === false) {\n        throw new ReferenceError(\n          'You are trying to access a property or method of the Jest environment outside of the scope of the test code.',\n        );\n      }\n\n      return this._fakeTimersImplementation!;\n    };\n    const useFakeTimers: Jest['useFakeTimers'] = fakeTimersConfig => {\n      fakeTimersConfig = {\n        ...this._config.fakeTimers,\n        ...fakeTimersConfig,\n      } as Config.FakeTimersConfig;\n      if (fakeTimersConfig?.legacyFakeTimers) {\n        this._fakeTimersImplementation = this._environment.fakeTimers;\n      } else {\n        this._fakeTimersImplementation = this._environment.fakeTimersModern;\n      }\n      this._fakeTimersImplementation!.useFakeTimers(fakeTimersConfig);\n      return jestObject;\n    };\n    const useRealTimers = () => {\n      _getFakeTimers().useRealTimers();\n      return jestObject;\n    };\n    const resetModules = () => {\n      this.resetModules();\n      return jestObject;\n    };\n    const isolateModules = (fn: () => void) => {\n      this.isolateModules(fn);\n      return jestObject;\n    };\n    const isolateModulesAsync = this.isolateModulesAsync.bind(this);\n    const fn = this._moduleMocker.fn.bind(this._moduleMocker);\n    const spyOn = this._moduleMocker.spyOn.bind(this._moduleMocker);\n    const mocked = this._moduleMocker.mocked.bind(this._moduleMocker);\n    const replaceProperty = this._moduleMocker.replaceProperty.bind(\n      this._moduleMocker,\n    );\n\n    const setTimeout: Jest['setTimeout'] = timeout => {\n      this._environment.global[testTimeoutSymbol] = timeout;\n      return jestObject;\n    };\n\n    const retryTimes: Jest['retryTimes'] = (numTestRetries, options) => {\n      this._environment.global[retryTimesSymbol] = numTestRetries;\n      this._environment.global[logErrorsBeforeRetrySymbol] =\n        options?.logErrorsBeforeRetry;\n      this._environment.global[waitBeforeRetrySymbol] =\n        options?.waitBeforeRetry;\n      this._environment.global[retryImmediatelySybmbol] =\n        options?.retryImmediately;\n\n      return jestObject;\n    };\n\n    const jestObject: Jest = {\n      advanceTimersByTime: msToRun =>\n        _getFakeTimers().advanceTimersByTime(msToRun),\n      advanceTimersByTimeAsync: async msToRun => {\n        const fakeTimers = _getFakeTimers();\n\n        if (fakeTimers === this._environment.fakeTimersModern) {\n          await fakeTimers.advanceTimersByTimeAsync(msToRun);\n        } else {\n          throw new TypeError(\n            '`jest.advanceTimersByTimeAsync()` is not available when using legacy fake timers.',\n          );\n        }\n      },\n      advanceTimersToNextFrame: () => {\n        const fakeTimers = _getFakeTimers();\n\n        if (fakeTimers === this._environment.fakeTimersModern) {\n          return fakeTimers.advanceTimersToNextFrame();\n        }\n        throw new TypeError(\n          '`jest.advanceTimersToNextFrame()` is not available when using legacy fake timers.',\n        );\n      },\n      advanceTimersToNextTimer: steps =>\n        _getFakeTimers().advanceTimersToNextTimer(steps),\n      advanceTimersToNextTimerAsync: async steps => {\n        const fakeTimers = _getFakeTimers();\n\n        if (fakeTimers === this._environment.fakeTimersModern) {\n          await fakeTimers.advanceTimersToNextTimerAsync(steps);\n        } else {\n          throw new TypeError(\n            '`jest.advanceTimersToNextTimerAsync()` is not available when using legacy fake timers.',\n          );\n        }\n      },\n      autoMockOff: disableAutomock,\n      autoMockOn: enableAutomock,\n      clearAllMocks,\n      clearAllTimers: () => _getFakeTimers().clearAllTimers(),\n      createMockFromModule: moduleName => this._generateMock(from, moduleName),\n      deepUnmock,\n      disableAutomock,\n      doMock: mock,\n      dontMock: unmock,\n      enableAutomock,\n      fn,\n      getRealSystemTime: () => {\n        const fakeTimers = _getFakeTimers();\n\n        if (fakeTimers === this._environment.fakeTimersModern) {\n          return fakeTimers.getRealSystemTime();\n        } else {\n          throw new TypeError(\n            '`jest.getRealSystemTime()` is not available when using legacy fake timers.',\n          );\n        }\n      },\n      getSeed: () => this._globalConfig.seed,\n      getTimerCount: () => _getFakeTimers().getTimerCount(),\n      isEnvironmentTornDown: () => this.isTornDown,\n      isMockFunction: this._moduleMocker.isMockFunction,\n      isolateModules,\n      isolateModulesAsync,\n      mock,\n      mocked,\n      now: () => _getFakeTimers().now(),\n      onGenerateMock,\n      replaceProperty,\n      requireActual: moduleName => this.requireActual(from, moduleName),\n      requireMock: moduleName => this.requireMock(from, moduleName),\n      resetAllMocks,\n      resetModules,\n      restoreAllMocks,\n      retryTimes,\n      runAllImmediates: () => {\n        const fakeTimers = _getFakeTimers();\n\n        if (fakeTimers === this._environment.fakeTimers) {\n          fakeTimers.runAllImmediates();\n        } else {\n          throw new TypeError(\n            '`jest.runAllImmediates()` is only available when using legacy fake timers.',\n          );\n        }\n      },\n      runAllTicks: () => _getFakeTimers().runAllTicks(),\n      runAllTimers: () => _getFakeTimers().runAllTimers(),\n      runAllTimersAsync: async () => {\n        const fakeTimers = _getFakeTimers();\n\n        if (fakeTimers === this._environment.fakeTimersModern) {\n          await fakeTimers.runAllTimersAsync();\n        } else {\n          throw new TypeError(\n            '`jest.runAllTimersAsync()` is not available when using legacy fake timers.',\n          );\n        }\n      },\n      runOnlyPendingTimers: () => _getFakeTimers().runOnlyPendingTimers(),\n      runOnlyPendingTimersAsync: async () => {\n        const fakeTimers = _getFakeTimers();\n\n        if (fakeTimers === this._environment.fakeTimersModern) {\n          await fakeTimers.runOnlyPendingTimersAsync();\n        } else {\n          throw new TypeError(\n            '`jest.runOnlyPendingTimersAsync()` is not available when using legacy fake timers.',\n          );\n        }\n      },\n      setMock: (moduleName, mock) => setMockFactory(moduleName, () => mock),\n      setSystemTime: now => {\n        const fakeTimers = _getFakeTimers();\n\n        if (fakeTimers === this._environment.fakeTimersModern) {\n          fakeTimers.setSystemTime(now);\n        } else {\n          throw new TypeError(\n            '`jest.setSystemTime()` is not available when using legacy fake timers.',\n          );\n        }\n      },\n      setTimeout,\n      spyOn,\n      unmock,\n      unstable_mockModule: mockModule,\n      unstable_unmockModule: unmockModule,\n      useFakeTimers,\n      useRealTimers,\n    };\n    return jestObject;\n  }\n\n  private _logFormattedReferenceError(errorMessage: string) {\n    const testPath = this._testPath\n      ? ` From ${slash(path.relative(this._config.rootDir, this._testPath))}.`\n      : '';\n    const originalStack = new ReferenceError(`${errorMessage}${testPath}`)\n      .stack!.split('\\n')\n      // Remove this file from the stack (jest-message-utils will keep one line)\n      .filter(line => !line.includes(__filename))\n      .join('\\n');\n\n    const {message, stack} = separateMessageFromStack(originalStack);\n\n    console.error(\n      `\\n${message}\\n${formatStackTrace(stack, this._config, {\n        noStackTrace: false,\n      })}`,\n    );\n  }\n\n  private constructInjectedModuleParameters(): Array<string> {\n    return [\n      'module',\n      'exports',\n      'require',\n      '__dirname',\n      '__filename',\n      this._config.injectGlobals ? 'jest' : undefined,\n      ...this._config.sandboxInjectedGlobals,\n    ].filter(isNonNullable);\n  }\n\n  private handleExecutionError(e: Error, module: Module): never {\n    const moduleNotFoundError = Resolver.tryCastModuleNotFoundError(e);\n    if (moduleNotFoundError) {\n      if (!moduleNotFoundError.requireStack) {\n        moduleNotFoundError.requireStack = [module.filename || module.id];\n\n        for (let cursor = module.parent; cursor; cursor = cursor.parent) {\n          moduleNotFoundError.requireStack.push(cursor.filename || cursor.id);\n        }\n\n        moduleNotFoundError.buildMessage(this._config.rootDir);\n      }\n      throw moduleNotFoundError;\n    }\n\n    throw e;\n  }\n\n  private getGlobalsForCjs(from: string): JestGlobalsWithJest {\n    const jest = this.jestObjectCaches.get(from);\n\n    invariant(jest, 'There should always be a Jest object already');\n\n    return {...this.getGlobalsFromEnvironment(), jest};\n  }\n\n  private getGlobalsForEsm(\n    from: string,\n    context: VMContext,\n  ): Promise<VMModule> {\n    let jest = this.jestObjectCaches.get(from);\n\n    if (!jest) {\n      jest = this._createJestObjectFor(from);\n\n      this.jestObjectCaches.set(from, jest);\n    }\n\n    const globals: JestGlobalsWithJest = {\n      ...this.getGlobalsFromEnvironment(),\n      jest,\n    };\n\n    const module = new SyntheticModule(\n      Object.keys(globals),\n      function () {\n        for (const [key, value] of Object.entries(globals)) {\n          // @ts-expect-error: TS doesn't know what `this` is\n          this.setExport(key, value);\n        }\n      },\n      {context, identifier: '@jest/globals'},\n    );\n\n    return evaluateSyntheticModule(module);\n  }\n\n  private getGlobalsFromEnvironment(): JestGlobals {\n    if (this.jestGlobals) {\n      return {...this.jestGlobals};\n    }\n\n    return {\n      afterAll: this._environment.global.afterAll,\n      afterEach: this._environment.global.afterEach,\n      beforeAll: this._environment.global.beforeAll,\n      beforeEach: this._environment.global.beforeEach,\n      describe: this._environment.global.describe,\n      expect: this._environment.global.expect as typeof expect,\n      fdescribe: this._environment.global.fdescribe,\n      fit: this._environment.global.fit,\n      it: this._environment.global.it,\n      test: this._environment.global.test,\n      xdescribe: this._environment.global.xdescribe,\n      xit: this._environment.global.xit,\n      xtest: this._environment.global.xtest,\n    };\n  }\n\n  private readFileBuffer(filename: string): Buffer {\n    let source = this._cacheFSBuffer.get(filename);\n\n    if (!source) {\n      source = fs.readFileSync(filename);\n\n      this._cacheFSBuffer.set(filename, source);\n    }\n\n    return source;\n  }\n\n  private readFile(filename: string): string {\n    let source = this._cacheFS.get(filename);\n\n    if (!source) {\n      const buffer = this.readFileBuffer(filename);\n      source = buffer.toString('utf8');\n\n      this._cacheFS.set(filename, source);\n    }\n\n    return source;\n  }\n\n  setGlobalsForRuntime(globals: JestGlobals): void {\n    this.jestGlobals = globals;\n  }\n}\n\nasync function evaluateSyntheticModule(module: SyntheticModule) {\n  await module.link(() => {\n    throw new Error('This should never happen');\n  });\n\n  await module.evaluate();\n\n  return module;\n}\n",
  "packages/jest-runtime/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { JestEnvironment } from '@jest/environment';\nimport type { expect } from '@jest/globals';\nimport type { SourceMapRegistry } from '@jest/source-map';\nimport type { TestContext, V8CoverageResult } from '@jest/test-result';\nimport { type CallerTransformOptions, type ScriptTransformer, type ShouldInstrumentOptions } from '@jest/transform';\nimport type { Config, Global } from '@jest/types';\nimport { type IHasteMap, type IModuleMap } from 'jest-haste-map';\nimport Resolver from 'jest-resolve';\ninterface JestGlobals extends Global.TestFrameworkGlobals {\n    expect: typeof expect;\n}\ntype HasteMapOptions = {\n    console?: Console;\n    maxWorkers: number;\n    resetCache: boolean;\n    watch?: boolean;\n    watchman: boolean;\n    workerThreads?: boolean;\n};\ninterface InternalModuleOptions extends Required<CallerTransformOptions> {\n    isInternalModule: boolean;\n}\nexport default class Runtime {\n    private readonly _cacheFS;\n    private readonly _cacheFSBuffer;\n    private readonly _config;\n    private readonly _globalConfig;\n    private readonly _coverageOptions;\n    private _currentlyExecutingModulePath;\n    private readonly _environment;\n    private readonly _explicitShouldMock;\n    private readonly _explicitShouldMockModule;\n    private readonly _onGenerateMock;\n    private _fakeTimersImplementation;\n    private readonly _internalModuleRegistry;\n    private _isCurrentlyExecutingManualMock;\n    private _mainModule;\n    private readonly _mockFactories;\n    private readonly _mockMetaDataCache;\n    private _mockRegistry;\n    private _isolatedMockRegistry;\n    private readonly _moduleMockRegistry;\n    private readonly _moduleMockFactories;\n    private readonly _moduleMocker;\n    private _isolatedModuleRegistry;\n    private _moduleRegistry;\n    private readonly _esmoduleRegistry;\n    private readonly _cjsNamedExports;\n    private readonly _esmModuleLinkingMap;\n    private readonly _testPath;\n    private readonly _resolver;\n    private _shouldAutoMock;\n    private readonly _shouldMockModuleCache;\n    private readonly _shouldUnmockTransitiveDependenciesCache;\n    private readonly _sourceMapRegistry;\n    private readonly _scriptTransformer;\n    private readonly _fileTransforms;\n    private readonly _fileTransformsMutex;\n    private _v8CoverageInstrumenter;\n    private _v8CoverageResult;\n    private _v8CoverageSources;\n    private readonly _transitiveShouldMock;\n    private _unmockList;\n    private readonly _virtualMocks;\n    private readonly _virtualModuleMocks;\n    private _moduleImplementation?;\n    private readonly jestObjectCaches;\n    private jestGlobals?;\n    private readonly esmConditions;\n    private readonly cjsConditions;\n    private isTornDown;\n    private isInsideTestCode;\n    constructor(config: Config.ProjectConfig, environment: JestEnvironment, resolver: Resolver, transformer: ScriptTransformer, cacheFS: Map<string, string>, coverageOptions: ShouldInstrumentOptions, testPath: string, globalConfig: Config.GlobalConfig);\n    static shouldInstrument: any;\n    static createContext(config: Config.ProjectConfig, options: {\n        console?: Console;\n        maxWorkers: number;\n        watch?: boolean;\n        watchman: boolean;\n    }): Promise<TestContext>;\n    static createHasteMap(config: Config.ProjectConfig, options?: HasteMapOptions): Promise<IHasteMap>;\n    static createResolver(config: Config.ProjectConfig, moduleMap: IModuleMap): Resolver;\n    unstable_shouldLoadAsEsm(modulePath: string): boolean;\n    private loadEsmModule;\n    private resolveModule;\n    private linkAndEvaluateModule;\n    unstable_importModule(from: string, moduleName?: string): Promise<unknown | void>;\n    private loadCjsAsEsm;\n    private importMock;\n    private getExportsOfCjs;\n    requireModule<T = unknown>(from: string, moduleName?: string, options?: InternalModuleOptions, isRequireActual?: boolean): T;\n    requireInternalModule<T = unknown>(from: string, to?: string): T;\n    requireActual<T = unknown>(from: string, moduleName: string): T;\n    requireMock<T = unknown>(from: string, moduleName: string): T;\n    private _loadModule;\n    private _getFullTransformationOptions;\n    requireModuleOrMock<T = unknown>(from: string, moduleName: string): T;\n    isolateModules(fn: () => void): void;\n    isolateModulesAsync(fn: () => Promise<void>): Promise<void>;\n    resetModules(): void;\n    collectV8Coverage(): Promise<void>;\n    stopCollectingV8Coverage(): Promise<void>;\n    getAllCoverageInfoCopy(): JestEnvironment['global']['__coverage__'];\n    getAllV8CoverageInfoCopy(): V8CoverageResult;\n    getSourceMaps(): SourceMapRegistry;\n    setMock(from: string, moduleName: string, mockFactory: () => unknown, options?: {\n        virtual?: boolean;\n    }): void;\n    private setModuleMock;\n    restoreAllMocks(): void;\n    resetAllMocks(): void;\n    clearAllMocks(): void;\n    enterTestCode(): void;\n    leaveTestCode(): void;\n    teardown(): void;\n    private _resolveCjsModule;\n    private _resolveModule;\n    private _requireResolve;\n    private _requireResolvePaths;\n    private _execModule;\n    private transformFile;\n    private transformFileAsync;\n    private createScriptFromCode;\n    private _requireCoreModule;\n    private _importCoreModule;\n    private _importWasmModule;\n    private _getMockedNativeModule;\n    private _generateMock;\n    private _shouldMockCjs;\n    private _shouldMockModule;\n    private _createRequireImplementation;\n    private _createJestObjectFor;\n    private _logFormattedReferenceError;\n    private constructInjectedModuleParameters;\n    private handleExecutionError;\n    private getGlobalsForCjs;\n    private getGlobalsForEsm;\n    private getGlobalsFromEnvironment;\n    private readFileBuffer;\n    private readFile;\n    setGlobalsForRuntime(globals: JestGlobals): void;\n}\nexport {};\n",
  "packages/jest-runtime/src/helpers.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {glob} from 'glob';\nimport slash from 'slash';\nimport type {Config} from '@jest/types';\n\nconst OUTSIDE_JEST_VM_PROTOCOL = 'jest-main:';\n// String manipulation is easier here, fileURLToPath is only in newer Nodes,\n// plus setting non-standard protocols on URL objects is difficult.\nexport const createOutsideJestVmPath = (path: string): string =>\n  `${OUTSIDE_JEST_VM_PROTOCOL}//${encodeURIComponent(path)}`;\nexport const decodePossibleOutsideJestVmPath = (\n  outsideJestVmPath: string,\n): string | undefined => {\n  if (outsideJestVmPath.startsWith(OUTSIDE_JEST_VM_PROTOCOL)) {\n    return decodeURIComponent(\n      outsideJestVmPath.replace(\n        new RegExp(`^${OUTSIDE_JEST_VM_PROTOCOL}//`),\n        '',\n      ),\n    );\n  }\n  return undefined;\n};\n\nexport const findSiblingsWithFileExtension = (\n  moduleFileExtensions: Config.ProjectConfig['moduleFileExtensions'],\n  from: string,\n  moduleName: string,\n): string => {\n  if (!path.isAbsolute(moduleName) && path.extname(moduleName) === '') {\n    const dirname = path.dirname(from);\n    const pathToModule = path.resolve(dirname, moduleName);\n\n    try {\n      const slashedDirname = slash(dirname);\n\n      const matches = glob\n        .sync(`${pathToModule}.*`, {windowsPathsNoEscape: true})\n        .map(match => {\n          const slashedMap = slash(match);\n          const relativePath = path.posix.relative(slashedDirname, slashedMap);\n\n          const slashedPath =\n            path.posix.dirname(slashedMap) === slashedDirname\n              ? `./${relativePath}`\n              : relativePath;\n\n          return `\\t'${slashedPath}'`;\n        })\n        .join('\\n');\n\n      if (matches) {\n        const foundMessage = `\\n\\nHowever, Jest was able to find:\\n${matches}`;\n\n        const mappedModuleFileExtensions = moduleFileExtensions\n          .map(ext => `'${ext}'`)\n          .join(', ');\n\n        return (\n          `${foundMessage}\\n\\nYou might want to include a file extension in your import, or update your 'moduleFileExtensions', which is currently ` +\n          `[${mappedModuleFileExtensions}].\\n\\nSee https://jestjs.io/docs/configuration#modulefileextensions-arraystring`\n        );\n      }\n    } catch {}\n  }\n\n  return '';\n};\n",
  "packages/jest-runtime/src/helpers.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config } from '@jest/types';\nexport declare const createOutsideJestVmPath: (path: string) => string;\nexport declare const decodePossibleOutsideJestVmPath: (outsideJestVmPath: string) => string | undefined;\nexport declare const findSiblingsWithFileExtension: (moduleFileExtensions: Config.ProjectConfig[\"moduleFileExtensions\"], from: string, moduleName: string) => string;\n",
  "packages/jest-runtime/src/__tests__/runtime_require_resolve.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport * as os from 'os';\nimport * as path from 'path';\nimport {promises as fs} from 'graceful-fs';\nimport type {Config} from '@jest/types';\nimport type Runtime from '..';\nimport {createOutsideJestVmPath} from '../helpers';\n\nlet createRuntime: (\n  path: string,\n  config?: Config.InitialOptions,\n) => Promise<Runtime & {__mockRootPath: string}>;\n\nconst getTmpDir = async () =>\n  fs.mkdtemp(path.join(os.tmpdir(), 'jest-resolve-test-'));\n\ndescribe('Runtime require.resolve', () => {\n  beforeEach(() => {\n    createRuntime = require('createRuntime');\n  });\n\n  it('resolves a module path', async () => {\n    const runtime = await createRuntime(__filename);\n    const resolved = runtime.requireModule(\n      runtime.__mockRootPath,\n      './resolve_self.js',\n    );\n    expect(resolved).toEqual(require.resolve('./test_root/resolve_self.js'));\n  });\n\n  it('resolves an absolute module path', async () => {\n    const absoluteFilePath = path.join(await getTmpDir(), 'test.js');\n    await fs.writeFile(\n      absoluteFilePath,\n      'module.exports = require.resolve(__filename);',\n      'utf8',\n    );\n\n    const runtime = await createRuntime(__filename);\n    const resolved = runtime.requireModule(\n      runtime.__mockRootPath,\n      absoluteFilePath,\n    );\n\n    expect(resolved).toEqual(require.resolve(absoluteFilePath));\n  });\n\n  it('required modules can resolve absolute module paths with no paths entries passed', async () => {\n    const tmpdir = await getTmpDir();\n    const entrypoint = path.join(tmpdir, 'test.js');\n    const target = path.join(tmpdir, 'target.js');\n\n    // we want to test the require.resolve implementation within a\n    // runtime-required module, so we need to create a module that then resolves\n    // an absolute path, so we need two files: the entrypoint, and an absolute\n    // target to require.\n    await fs.writeFile(\n      entrypoint,\n      `module.exports = require.resolve(${JSON.stringify(\n        target,\n      )}, {paths: []});`,\n      'utf8',\n    );\n\n    await fs.writeFile(target, 'module.exports = {}', 'utf8');\n\n    const runtime = await createRuntime(__filename);\n    const resolved = runtime.requireModule(runtime.__mockRootPath, entrypoint);\n    expect(resolved).toEqual(require.resolve(target, {paths: []}));\n  });\n\n  it('resolves a module path with moduleNameMapper', async () => {\n    const runtime = await createRuntime(__filename, {\n      moduleNameMapper: {\n        '^testMapped/(.*)': '<rootDir>/mapped_dir/$1',\n      },\n    });\n    const resolved = runtime.requireModule(\n      runtime.__mockRootPath,\n      './resolve_mapped.js',\n    );\n    expect(resolved).toEqual(\n      require.resolve('./test_root/mapped_dir/moduleInMapped.js'),\n    );\n  });\n\n  describe('with the jest-resolve-outside-vm-option', () => {\n    it('forwards to the real Node require in an internal context', async () => {\n      const runtime = await createRuntime(__filename);\n      const module = runtime.requireInternalModule(\n        runtime.__mockRootPath,\n        './resolve_and_require_outside.js',\n      );\n      expect(module.required).toBe(\n        require('./test_root/create_require_module'),\n      );\n    });\n\n    it('ignores the option in an external context', async () => {\n      const runtime = await createRuntime(__filename);\n      const module = runtime.requireModule(\n        runtime.__mockRootPath,\n        './resolve_and_require_outside.js',\n      );\n      expect(module.required.foo).toBe('foo');\n      expect(module.required).not.toBe(\n        require('./test_root/create_require_module'),\n      );\n    });\n\n    // make sure we also check isInternal during require, not just during resolve\n    it('does not understand a self-constructed outsideJestVmPath in an external context', async () => {\n      const runtime = await createRuntime(__filename);\n      expect(() =>\n        runtime.requireModule(\n          runtime.__mockRootPath,\n          createOutsideJestVmPath(\n            require.resolve('./test_root/create_require_module.js'),\n          ),\n        ),\n      ).toThrow(/cannot find.+create_require_module/i);\n    });\n  });\n});\n",
  "packages/jest-runtime/src/__tests__/runtime_require_resolve.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport {};\n",
  "packages/jest-runtime/src/__tests__/instrumentation.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport * as os from 'os';\nimport * as path from 'path';\nimport {makeGlobalConfig, makeProjectConfig} from '@jest/test-utils';\nimport {createScriptTransformer} from '@jest/transform';\n\njest.mock('vm');\n\nconst FILE_PATH_TO_INSTRUMENT = path.resolve(\n  __dirname,\n  './module_dir/to_be_instrumented.js',\n);\n\nit('instruments files', async () => {\n  const config = makeProjectConfig({\n    cache: false,\n    cacheDirectory: os.tmpdir(),\n    cwd: __dirname,\n    rootDir: __dirname,\n  });\n  const scriptTransformer = await createScriptTransformer(config);\n\n  const instrumented = scriptTransformer.transform(FILE_PATH_TO_INSTRUMENT, {\n    ...makeGlobalConfig({collectCoverage: true}),\n    changedFiles: undefined,\n  });\n  // We can't really snapshot the resulting coverage, because it depends on\n  // absolute path of the file, which will be different on different\n  // machines\n  expect(instrumented.code).toMatch('gcv = \"__coverage__\"');\n});\n",
  "packages/jest-runtime/src/__tests__/instrumentation.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport {};\n",
  "packages/jest-runner/src/types.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {JestEnvironment} from '@jest/environment';\nimport type {\n  SerializableError,\n  Test,\n  TestEvents,\n  TestFileEvent,\n  TestResult,\n} from '@jest/test-result';\nimport type {Config} from '@jest/types';\nimport type RuntimeType from 'jest-runtime';\nimport type {TestWatcher} from 'jest-watcher';\n\nexport type ErrorWithCode = Error & {code?: string};\n\nexport type OnTestStart = (test: Test) => Promise<void>;\n\nexport type OnTestFailure = (\n  test: Test,\n  serializableError: SerializableError,\n) => Promise<void>;\n\nexport type OnTestSuccess = (\n  test: Test,\n  testResult: TestResult,\n) => Promise<void>;\n\nexport type TestFramework = (\n  globalConfig: Config.GlobalConfig,\n  config: Config.ProjectConfig,\n  environment: JestEnvironment,\n  runtime: RuntimeType,\n  testPath: string,\n  sendMessageToJest?: TestFileEvent,\n) => Promise<TestResult>;\n\nexport type TestRunnerOptions = {\n  serial: boolean;\n};\n\nexport type TestRunnerContext = {\n  changedFiles?: Set<string>;\n  sourcesRelatedToTestsInChangedFiles?: Set<string>;\n};\n\ntype SerializeSet<T> = T extends Set<infer U> ? Array<U> : T;\n\nexport type TestRunnerSerializedContext = {\n  [K in keyof TestRunnerContext]: SerializeSet<TestRunnerContext[K]>;\n};\n\nexport type UnsubscribeFn = () => void;\n\nexport interface CallbackTestRunnerInterface {\n  readonly isSerial?: boolean;\n  readonly supportsEventEmitters?: boolean;\n\n  runTests(\n    tests: Array<Test>,\n    watcher: TestWatcher,\n    onStart: OnTestStart,\n    onResult: OnTestSuccess,\n    onFailure: OnTestFailure,\n    options: TestRunnerOptions,\n  ): Promise<void>;\n}\n\nexport interface EmittingTestRunnerInterface {\n  readonly isSerial?: boolean;\n  readonly supportsEventEmitters: true;\n\n  runTests(\n    tests: Array<Test>,\n    watcher: TestWatcher,\n    options: TestRunnerOptions,\n  ): Promise<void>;\n\n  on<Name extends keyof TestEvents>(\n    eventName: Name,\n    listener: (eventData: TestEvents[Name]) => void | Promise<void>,\n  ): UnsubscribeFn;\n}\n\nabstract class BaseTestRunner {\n  readonly isSerial?: boolean;\n  abstract readonly supportsEventEmitters: boolean;\n\n  constructor(\n    protected readonly _globalConfig: Config.GlobalConfig,\n    protected readonly _context: TestRunnerContext,\n  ) {}\n}\n\nexport abstract class CallbackTestRunner\n  extends BaseTestRunner\n  implements CallbackTestRunnerInterface\n{\n  readonly supportsEventEmitters = false;\n\n  abstract runTests(\n    tests: Array<Test>,\n    watcher: TestWatcher,\n    onStart: OnTestStart,\n    onResult: OnTestSuccess,\n    onFailure: OnTestFailure,\n    options: TestRunnerOptions,\n  ): Promise<void>;\n}\n\nexport abstract class EmittingTestRunner\n  extends BaseTestRunner\n  implements EmittingTestRunnerInterface\n{\n  readonly supportsEventEmitters = true;\n\n  abstract runTests(\n    tests: Array<Test>,\n    watcher: TestWatcher,\n    options: TestRunnerOptions,\n  ): Promise<void>;\n\n  abstract on<Name extends keyof TestEvents>(\n    eventName: Name,\n    listener: (eventData: TestEvents[Name]) => void | Promise<void>,\n  ): UnsubscribeFn;\n}\n\nexport type JestTestRunner = CallbackTestRunner | EmittingTestRunner;\n",
  "packages/jest-runner/src/types.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { JestEnvironment } from '@jest/environment';\nimport type { SerializableError, Test, TestEvents, TestFileEvent, TestResult } from '@jest/test-result';\nimport type { Config } from '@jest/types';\nimport type RuntimeType from 'jest-runtime';\nimport type { TestWatcher } from 'jest-watcher';\nexport type ErrorWithCode = Error & {\n    code?: string;\n};\nexport type OnTestStart = (test: Test) => Promise<void>;\nexport type OnTestFailure = (test: Test, serializableError: SerializableError) => Promise<void>;\nexport type OnTestSuccess = (test: Test, testResult: TestResult) => Promise<void>;\nexport type TestFramework = (globalConfig: Config.GlobalConfig, config: Config.ProjectConfig, environment: JestEnvironment, runtime: RuntimeType, testPath: string, sendMessageToJest?: TestFileEvent) => Promise<TestResult>;\nexport type TestRunnerOptions = {\n    serial: boolean;\n};\nexport type TestRunnerContext = {\n    changedFiles?: Set<string>;\n    sourcesRelatedToTestsInChangedFiles?: Set<string>;\n};\ntype SerializeSet<T> = T extends Set<infer U> ? Array<U> : T;\nexport type TestRunnerSerializedContext = {\n    [K in keyof TestRunnerContext]: SerializeSet<TestRunnerContext[K]>;\n};\nexport type UnsubscribeFn = () => void;\nexport interface CallbackTestRunnerInterface {\n    readonly isSerial?: boolean;\n    readonly supportsEventEmitters?: boolean;\n    runTests(tests: Array<Test>, watcher: TestWatcher, onStart: OnTestStart, onResult: OnTestSuccess, onFailure: OnTestFailure, options: TestRunnerOptions): Promise<void>;\n}\nexport interface EmittingTestRunnerInterface {\n    readonly isSerial?: boolean;\n    readonly supportsEventEmitters: true;\n    runTests(tests: Array<Test>, watcher: TestWatcher, options: TestRunnerOptions): Promise<void>;\n    on<Name extends keyof TestEvents>(eventName: Name, listener: (eventData: TestEvents[Name]) => void | Promise<void>): UnsubscribeFn;\n}\ndeclare abstract class BaseTestRunner {\n    protected readonly _globalConfig: Config.GlobalConfig;\n    protected readonly _context: TestRunnerContext;\n    readonly isSerial?: boolean;\n    abstract readonly supportsEventEmitters: boolean;\n    constructor(_globalConfig: Config.GlobalConfig, _context: TestRunnerContext);\n}\nexport declare abstract class CallbackTestRunner extends BaseTestRunner implements CallbackTestRunnerInterface {\n    readonly supportsEventEmitters = false;\n    abstract runTests(tests: Array<Test>, watcher: TestWatcher, onStart: OnTestStart, onResult: OnTestSuccess, onFailure: OnTestFailure, options: TestRunnerOptions): Promise<void>;\n}\nexport declare abstract class EmittingTestRunner extends BaseTestRunner implements EmittingTestRunnerInterface {\n    readonly supportsEventEmitters = true;\n    abstract runTests(tests: Array<Test>, watcher: TestWatcher, options: TestRunnerOptions): Promise<void>;\n    abstract on<Name extends keyof TestEvents>(eventName: Name, listener: (eventData: TestEvents[Name]) => void | Promise<void>): UnsubscribeFn;\n}\nexport type JestTestRunner = CallbackTestRunner | EmittingTestRunner;\nexport {};\n",
  "packages/jest-runner/src/testWorker.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport exit from 'exit-x';\nimport type {\n  SerializableError,\n  TestFileEvent,\n  TestResult,\n} from '@jest/test-result';\nimport type {Config} from '@jest/types';\nimport HasteMap, {type SerializableModuleMap} from 'jest-haste-map';\nimport {separateMessageFromStack} from 'jest-message-util';\nimport type Resolver from 'jest-resolve';\nimport Runtime from 'jest-runtime';\nimport {messageParent} from 'jest-worker';\nimport runTest from './runTest';\nimport type {ErrorWithCode, TestRunnerSerializedContext} from './types';\n\nexport type SerializableResolver = {\n  config: Config.ProjectConfig;\n  serializableModuleMap: SerializableModuleMap;\n};\n\ntype WorkerData = {\n  config: Config.ProjectConfig;\n  globalConfig: Config.GlobalConfig;\n  path: string;\n  context: TestRunnerSerializedContext;\n};\n\n// Make sure uncaught errors are logged before we exit.\nprocess.on('uncaughtException', err => {\n  if (err.stack) {\n    console.error(err.stack);\n  } else {\n    console.error(err);\n  }\n  exit(1);\n});\n\nconst formatError = (error: string | ErrorWithCode): SerializableError => {\n  if (typeof error === 'string') {\n    const {message, stack} = separateMessageFromStack(error);\n    return {\n      message,\n      stack,\n      type: 'Error',\n    };\n  }\n\n  return {\n    code: error.code || undefined,\n    message: error.message,\n    stack: error.stack,\n    type: 'Error',\n  };\n};\n\nconst resolvers = new Map<string, Resolver>();\nconst getResolver = (config: Config.ProjectConfig) => {\n  const resolver = resolvers.get(config.id);\n  if (!resolver) {\n    throw new Error(`Cannot find resolver for: ${config.id}`);\n  }\n  return resolver;\n};\n\nexport function setup(setupData: {\n  serializableResolvers: Array<SerializableResolver>;\n}): void {\n  // Module maps that will be needed for the test runs are passed.\n  for (const {\n    config,\n    serializableModuleMap,\n  } of setupData.serializableResolvers) {\n    const moduleMap = HasteMap.getStatic(config).getModuleMapFromJSON(\n      serializableModuleMap,\n    );\n    resolvers.set(config.id, Runtime.createResolver(config, moduleMap));\n  }\n}\n\nconst sendMessageToJest: TestFileEvent = (eventName, args) => {\n  messageParent([eventName, args]);\n};\n\nexport async function worker({\n  config,\n  globalConfig,\n  path,\n  context,\n}: WorkerData): Promise<TestResult> {\n  try {\n    return await runTest(\n      path,\n      globalConfig,\n      config,\n      getResolver(config),\n      {\n        ...context,\n        changedFiles: context.changedFiles && new Set(context.changedFiles),\n        sourcesRelatedToTestsInChangedFiles:\n          context.sourcesRelatedToTestsInChangedFiles &&\n          new Set(context.sourcesRelatedToTestsInChangedFiles),\n      },\n      sendMessageToJest,\n    );\n  } catch (error: any) {\n    throw formatError(error);\n  }\n}\n",
  "packages/jest-runner/src/testWorker.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport type { TestResult } from '@jest/test-result';\nimport type { Config } from '@jest/types';\nimport { type SerializableModuleMap } from 'jest-haste-map';\nimport type { TestRunnerSerializedContext } from './types';\nexport type SerializableResolver = {\n    config: Config.ProjectConfig;\n    serializableModuleMap: SerializableModuleMap;\n};\ntype WorkerData = {\n    config: Config.ProjectConfig;\n    globalConfig: Config.GlobalConfig;\n    path: string;\n    context: TestRunnerSerializedContext;\n};\nexport declare function setup(setupData: {\n    serializableResolvers: Array<SerializableResolver>;\n}): void;\nexport declare function worker({ config, globalConfig, path, context, }: WorkerData): Promise<TestResult>;\nexport {};\n",
  "packages/jest-runner/src/runTest.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {runInContext} from 'node:vm';\nimport chalk from 'chalk';\nimport * as fs from 'graceful-fs';\nimport * as sourcemapSupport from 'source-map-support';\nimport {\n  BufferedConsole,\n  CustomConsole,\n  type LogMessage,\n  type LogType,\n  NullConsole,\n  getConsoleOutput,\n} from '@jest/console';\nimport type {JestEnvironment} from '@jest/environment';\nimport type {TestFileEvent, TestResult} from '@jest/test-result';\nimport {createScriptTransformer} from '@jest/transform';\nimport type {Config} from '@jest/types';\nimport * as docblock from 'jest-docblock';\nimport LeakDetector from 'jest-leak-detector';\nimport {formatExecError} from 'jest-message-util';\n// eslint-disable-next-line @typescript-eslint/consistent-type-imports\nimport Resolver, {resolveTestEnvironment} from 'jest-resolve';\nimport type RuntimeClass from 'jest-runtime';\nimport {ErrorWithStack, interopRequireDefault, setGlobal} from 'jest-util';\nimport type {TestFramework, TestRunnerContext} from './types';\n\ntype RunTestInternalResult = {\n  leakDetector: LeakDetector | null;\n  result: TestResult;\n};\n\nfunction freezeConsole(\n  testConsole: BufferedConsole | CustomConsole | NullConsole,\n  config: Config.ProjectConfig,\n) {\n  // @ts-expect-error: `_log` is `private` - we should figure out some proper API here\n  testConsole._log = function fakeConsolePush(\n    _type: LogType,\n    message: LogMessage,\n  ) {\n    const error = new ErrorWithStack(\n      `${chalk.red(\n        `${chalk.bold(\n          'Cannot log after tests are done.',\n        )} Did you forget to wait for something async in your test?`,\n      )}\\nAttempted to log \"${message}\".`,\n      fakeConsolePush,\n    );\n\n    const formattedError = formatExecError(\n      error,\n      config,\n      {noStackTrace: false},\n      undefined,\n      true,\n    );\n\n    process.stderr.write(`\\n${formattedError}\\n`);\n    process.exitCode = 1;\n  };\n}\n\n// Keeping the core of \"runTest\" as a separate function (as \"runTestInternal\")\n// is key to be able to detect memory leaks. Since all variables are local to\n// the function, when \"runTestInternal\" finishes its execution, they can all be\n// freed, UNLESS something else is leaking them (and that's why we can detect\n// the leak!).\n//\n// If we had all the code in a single function, we should manually nullify all\n// references to verify if there is a leak, which is not maintainable and error\n// prone. That's why \"runTestInternal\" CANNOT be inlined inside \"runTest\".\nasync function runTestInternal(\n  path: string,\n  globalConfig: Config.GlobalConfig,\n  projectConfig: Config.ProjectConfig,\n  resolver: Resolver,\n  context: TestRunnerContext,\n  sendMessageToJest?: TestFileEvent,\n): Promise<RunTestInternalResult> {\n  const testSource = fs.readFileSync(path, 'utf8');\n  const docblockPragmas = docblock.parse(docblock.extract(testSource));\n  const customEnvironment = docblockPragmas['jest-environment'];\n\n  const loadTestEnvironmentStart = Date.now();\n  let testEnvironment = projectConfig.testEnvironment;\n\n  if (customEnvironment) {\n    if (Array.isArray(customEnvironment)) {\n      throw new TypeError(\n        `You can only define a single test environment through docblocks, got \"${customEnvironment.join(\n          ', ',\n        )}\"`,\n      );\n    }\n    testEnvironment = resolveTestEnvironment({\n      ...projectConfig,\n      // we wanna avoid webpack trying to be clever\n      requireResolveFunction: module => require.resolve(module),\n      testEnvironment: customEnvironment,\n    });\n  }\n\n  const cacheFS = new Map([[path, testSource]]);\n  const transformer = await createScriptTransformer(projectConfig, cacheFS);\n\n  const TestEnvironment: typeof JestEnvironment =\n    await transformer.requireAndTranspileModule(testEnvironment);\n  const testFramework: TestFramework =\n    await transformer.requireAndTranspileModule(\n      process.env.JEST_JASMINE === '1'\n        ? require.resolve('jest-jasmine2')\n        : projectConfig.testRunner,\n    );\n  const Runtime: typeof RuntimeClass = interopRequireDefault(\n    projectConfig.runtime\n      ? require(projectConfig.runtime)\n      : require('jest-runtime'),\n  ).default;\n\n  const consoleOut = globalConfig.useStderr ? process.stderr : process.stdout;\n  const consoleFormatter = (type: LogType, message: LogMessage) =>\n    getConsoleOutput(\n      // 4 = the console call is buried 4 stack frames deep\n      BufferedConsole.write([], type, message, 4),\n      projectConfig,\n      globalConfig,\n    );\n\n  let testConsole;\n\n  if (globalConfig.silent) {\n    testConsole = new NullConsole(consoleOut, consoleOut, consoleFormatter);\n  } else if (globalConfig.verbose) {\n    testConsole = new CustomConsole(consoleOut, consoleOut, consoleFormatter);\n  } else {\n    testConsole = new BufferedConsole();\n  }\n\n  let extraTestEnvironmentOptions;\n\n  const docblockEnvironmentOptions =\n    docblockPragmas['jest-environment-options'];\n\n  if (typeof docblockEnvironmentOptions === 'string') {\n    extraTestEnvironmentOptions = JSON.parse(docblockEnvironmentOptions);\n  }\n\n  const environment = new TestEnvironment(\n    {\n      globalConfig,\n      projectConfig: extraTestEnvironmentOptions\n        ? {\n            ...projectConfig,\n            testEnvironmentOptions: {\n              ...projectConfig.testEnvironmentOptions,\n              ...extraTestEnvironmentOptions,\n            },\n          }\n        : projectConfig,\n    },\n    {\n      console: testConsole,\n      docblockPragmas,\n      testPath: path,\n    },\n  );\n  const loadTestEnvironmentEnd = Date.now();\n\n  if (typeof environment.getVmContext !== 'function') {\n    console.error(\n      `Test environment found at \"${testEnvironment}\" does not export a \"getVmContext\" method, which is mandatory from Jest 27. This method is a replacement for \"runScript\".`,\n    );\n    process.exit(1);\n  }\n\n  const leakDetector = projectConfig.detectLeaks\n    ? new LeakDetector(environment)\n    : null;\n\n  setGlobal(environment.global, 'console', testConsole, 'retain');\n\n  const runtime = new Runtime(\n    projectConfig,\n    environment,\n    resolver,\n    transformer,\n    cacheFS,\n    {\n      changedFiles: context.changedFiles,\n      collectCoverage: globalConfig.collectCoverage,\n      collectCoverageFrom: globalConfig.collectCoverageFrom,\n      coverageProvider: globalConfig.coverageProvider,\n      sourcesRelatedToTestsInChangedFiles:\n        context.sourcesRelatedToTestsInChangedFiles,\n    },\n    path,\n    globalConfig,\n  );\n\n  let isTornDown = false;\n\n  const tearDownEnv = async () => {\n    if (!isTornDown) {\n      runtime.teardown();\n\n      // source-map-support keeps memory leftovers in `Error.prepareStackTrace`\n      runInContext(\n        \"Error.prepareStackTrace = () => '';\",\n        environment.getVmContext()!,\n      );\n      sourcemapSupport.resetRetrieveHandlers();\n\n      try {\n        await environment.teardown();\n      } finally {\n        isTornDown = true;\n      }\n    }\n  };\n\n  const start = Date.now();\n\n  const setupFilesStart = Date.now();\n  for (const path of projectConfig.setupFiles) {\n    const esm = runtime.unstable_shouldLoadAsEsm(path);\n\n    if (esm) {\n      await runtime.unstable_importModule(path);\n    } else {\n      const setupFile = runtime.requireModule(path);\n      if (typeof setupFile === 'function') {\n        await setupFile();\n      }\n    }\n  }\n  const setupFilesEnd = Date.now();\n\n  const sourcemapOptions: sourcemapSupport.Options = {\n    environment: 'node',\n    handleUncaughtExceptions: false,\n    retrieveSourceMap: source => {\n      const sourceMapSource = runtime.getSourceMaps()?.get(source);\n\n      if (sourceMapSource) {\n        try {\n          return {\n            map: JSON.parse(fs.readFileSync(sourceMapSource, 'utf8')),\n            url: source,\n          };\n        } catch {}\n      }\n      return null;\n    },\n  };\n\n  // For tests\n  runtime\n    .requireInternalModule<\n      typeof import('source-map-support')\n    >(require.resolve('source-map-support'))\n    .install(sourcemapOptions);\n\n  // For runtime errors\n  sourcemapSupport.install(sourcemapOptions);\n\n  if (\n    environment.global &&\n    environment.global.process &&\n    environment.global.process.exit\n  ) {\n    const realExit = environment.global.process.exit;\n\n    environment.global.process.exit = function exit(...args: Array<any>) {\n      const error = new ErrorWithStack(\n        `process.exit called with \"${args.join(', ')}\"`,\n        exit,\n      );\n\n      const formattedError = formatExecError(\n        error,\n        projectConfig,\n        {noStackTrace: false},\n        undefined,\n        true,\n      );\n\n      process.stderr.write(formattedError);\n\n      return realExit(...args);\n    };\n  }\n\n  // if we don't have `getVmContext` on the env skip coverage\n  const collectV8Coverage =\n    globalConfig.collectCoverage &&\n    globalConfig.coverageProvider === 'v8' &&\n    typeof environment.getVmContext === 'function';\n\n  // Node's error-message stack size is limited at 10, but it's pretty useful\n  // to see more than that when a test fails.\n  Error.stackTraceLimit = 100;\n  try {\n    await environment.setup();\n\n    let result: TestResult;\n\n    try {\n      if (collectV8Coverage) {\n        await runtime.collectV8Coverage();\n      }\n      result = await testFramework(\n        globalConfig,\n        projectConfig,\n        environment,\n        runtime,\n        path,\n        sendMessageToJest,\n      );\n    } catch (error: any) {\n      // Access all stacks before uninstalling sourcemaps\n      let e = error;\n      while (typeof e === 'object' && e !== null && 'stack' in e) {\n        // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n        e.stack;\n        e = e?.cause;\n      }\n\n      throw error;\n    } finally {\n      if (collectV8Coverage) {\n        await runtime.stopCollectingV8Coverage();\n      }\n    }\n\n    freezeConsole(testConsole, projectConfig);\n\n    const testCount =\n      result.numPassingTests +\n      result.numFailingTests +\n      result.numPendingTests +\n      result.numTodoTests;\n\n    const end = Date.now();\n    const testRuntime = end - start;\n    result.perfStats = {\n      ...result.perfStats,\n      end,\n      loadTestEnvironmentEnd,\n      loadTestEnvironmentStart,\n      runtime: testRuntime,\n      setupFilesEnd,\n      setupFilesStart,\n      slow: testRuntime / 1000 > projectConfig.slowTestThreshold,\n      start,\n    };\n    result.testFilePath = path;\n    result.console = testConsole.getBuffer();\n    result.skipped = testCount === result.numPendingTests;\n    result.displayName = projectConfig.displayName;\n\n    const coverage = runtime.getAllCoverageInfoCopy();\n    if (coverage) {\n      const coverageKeys = Object.keys(coverage);\n      if (coverageKeys.length > 0) {\n        result.coverage = coverage;\n      }\n    }\n\n    if (collectV8Coverage) {\n      const v8Coverage = runtime.getAllV8CoverageInfoCopy();\n      if (v8Coverage && v8Coverage.length > 0) {\n        result.v8Coverage = v8Coverage;\n      }\n    }\n\n    if (globalConfig.logHeapUsage) {\n      globalThis.gc?.();\n\n      result.memoryUsage = process.memoryUsage().heapUsed;\n    }\n\n    await tearDownEnv();\n\n    // Delay the resolution to allow log messages to be output.\n    return await new Promise(resolve => {\n      setImmediate(() => resolve({leakDetector, result}));\n    });\n  } finally {\n    await tearDownEnv();\n  }\n}\n\nexport default async function runTest(\n  path: string,\n  globalConfig: Config.GlobalConfig,\n  config: Config.ProjectConfig,\n  resolver: Resolver,\n  context: TestRunnerContext,\n  sendMessageToJest?: TestFileEvent,\n): Promise<TestResult> {\n  const {leakDetector, result} = await runTestInternal(\n    path,\n    globalConfig,\n    config,\n    resolver,\n    context,\n    sendMessageToJest,\n  );\n\n  if (leakDetector) {\n    // We wanna allow a tiny but time to pass to allow last-minute cleanup\n    await new Promise(resolve => setTimeout(resolve, 100));\n\n    // Resolve leak detector, outside the \"runTestInternal\" closure.\n    result.leaks = await leakDetector.isLeaking();\n  } else {\n    result.leaks = false;\n  }\n\n  return result;\n}\n",
  "packages/jest-runner/src/runTest.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport type { TestFileEvent, TestResult } from '@jest/test-result';\nimport type { Config } from '@jest/types';\nimport Resolver from 'jest-resolve';\nimport type { TestRunnerContext } from './types';\nexport default function runTest(path: string, globalConfig: Config.GlobalConfig, config: Config.ProjectConfig, resolver: Resolver, context: TestRunnerContext, sendMessageToJest?: TestFileEvent): Promise<TestResult>;\n",
  "packages/jest-runner/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk from 'chalk';\nimport Emittery from 'emittery';\nimport pLimit from 'p-limit';\nimport type {\n  Test,\n  TestEvents,\n  TestFileEvent,\n  TestResult,\n} from '@jest/test-result';\nimport {deepCyclicCopy} from 'jest-util';\nimport type {TestWatcher} from 'jest-watcher';\nimport {\n  type JestWorkerFarm,\n  type PromiseWithCustomMessage,\n  Worker,\n} from 'jest-worker';\nimport runTest from './runTest';\nimport type {SerializableResolver} from './testWorker';\nimport {\n  EmittingTestRunner,\n  type TestRunnerOptions,\n  type UnsubscribeFn,\n} from './types';\n\nexport type {Test, TestEvents} from '@jest/test-result';\nexport type {Config} from '@jest/types';\nexport type {TestWatcher} from 'jest-watcher';\nexport {CallbackTestRunner, EmittingTestRunner} from './types';\nexport type {\n  CallbackTestRunnerInterface,\n  EmittingTestRunnerInterface,\n  OnTestFailure,\n  OnTestStart,\n  OnTestSuccess,\n  TestRunnerContext,\n  TestRunnerOptions,\n  JestTestRunner,\n  UnsubscribeFn,\n} from './types';\n\ntype TestWorker = typeof import('./testWorker');\n\nexport default class TestRunner extends EmittingTestRunner {\n  readonly #eventEmitter = new Emittery<TestEvents>();\n\n  async runTests(\n    tests: Array<Test>,\n    watcher: TestWatcher,\n    options: TestRunnerOptions,\n  ): Promise<void> {\n    return options.serial\n      ? this.#createInBandTestRun(tests, watcher)\n      : this.#createParallelTestRun(tests, watcher);\n  }\n\n  async #createInBandTestRun(tests: Array<Test>, watcher: TestWatcher) {\n    process.env.JEST_WORKER_ID = '1';\n    const mutex = pLimit(1);\n    return tests.reduce(\n      (promise, test) =>\n        mutex(() =>\n          promise\n            .then(async () => {\n              if (watcher.isInterrupted()) {\n                throw new CancelRun();\n              }\n\n              await this.#eventEmitter.emit('test-file-start', [test]);\n\n              return runTest(\n                test.path,\n                this._globalConfig,\n                test.context.config,\n                test.context.resolver,\n                this._context,\n                this.#sendMessageToJest,\n              );\n            })\n            .then(\n              result =>\n                this.#eventEmitter.emit('test-file-success', [test, result]),\n              error =>\n                this.#eventEmitter.emit('test-file-failure', [test, error]),\n            ),\n        ),\n      Promise.resolve(),\n    );\n  }\n\n  async #createParallelTestRun(tests: Array<Test>, watcher: TestWatcher) {\n    const resolvers = new Map<string, SerializableResolver>();\n    for (const test of tests) {\n      if (!resolvers.has(test.context.config.id)) {\n        resolvers.set(test.context.config.id, {\n          config: test.context.config,\n          serializableModuleMap: test.context.moduleMap.toJSON(),\n        });\n      }\n    }\n\n    const worker = new Worker(require.resolve('./testWorker'), {\n      enableWorkerThreads: this._globalConfig.workerThreads,\n      exposedMethods: ['worker'],\n      forkOptions: {serialization: 'json', stdio: 'pipe'},\n      // The workerIdleMemoryLimit should've been converted to a number during\n      // the normalization phase.\n      idleMemoryLimit:\n        typeof this._globalConfig.workerIdleMemoryLimit === 'number'\n          ? this._globalConfig.workerIdleMemoryLimit\n          : undefined,\n      maxRetries: 3,\n      numWorkers: this._globalConfig.maxWorkers,\n      setupArgs: [{serializableResolvers: [...resolvers.values()]}],\n    }) as JestWorkerFarm<TestWorker>;\n\n    if (worker.getStdout()) worker.getStdout().pipe(process.stdout);\n    if (worker.getStderr()) worker.getStderr().pipe(process.stderr);\n\n    const mutex = pLimit(this._globalConfig.maxWorkers);\n\n    // Send test suites to workers continuously instead of all at once to track\n    // the start time of individual tests.\n    const runTestInWorker = (test: Test) =>\n      mutex(async () => {\n        if (watcher.isInterrupted()) {\n          // eslint-disable-next-line unicorn/error-message\n          throw new Error();\n        }\n\n        await this.#eventEmitter.emit('test-file-start', [test]);\n\n        const promise = worker.worker({\n          config: test.context.config,\n          context: {\n            ...this._context,\n            changedFiles: this._context.changedFiles && [\n              ...this._context.changedFiles,\n            ],\n            sourcesRelatedToTestsInChangedFiles: this._context\n              .sourcesRelatedToTestsInChangedFiles && [\n              ...this._context.sourcesRelatedToTestsInChangedFiles,\n            ],\n          },\n          globalConfig: this._globalConfig,\n          path: test.path,\n        }) as PromiseWithCustomMessage<TestResult>;\n\n        if (promise.UNSTABLE_onCustomMessage) {\n          // TODO: Get appropriate type for `onCustomMessage`\n          promise.UNSTABLE_onCustomMessage(([event, payload]: any) =>\n            this.#eventEmitter.emit(event, payload),\n          );\n        }\n\n        return promise;\n      });\n\n    const onInterrupt = new Promise((_resolve, reject) => {\n      watcher.on('change', state => {\n        if (state.interrupted) {\n          reject(new CancelRun());\n        }\n      });\n    });\n\n    const runAllTests = Promise.all(\n      tests.map(test =>\n        runTestInWorker(test).then(\n          result =>\n            this.#eventEmitter.emit('test-file-success', [test, result]),\n          error => this.#eventEmitter.emit('test-file-failure', [test, error]),\n        ),\n      ),\n    );\n\n    const cleanup = async () => {\n      const {forceExited} = await worker.end();\n      if (forceExited) {\n        console.error(\n          chalk.yellow(\n            'A worker process has failed to exit gracefully and has been force exited. ' +\n              'This is likely caused by tests leaking due to improper teardown. ' +\n              'Try running with --detectOpenHandles to find leaks. ' +\n              'Active timers can also cause this, ensure that .unref() was called on them.',\n          ),\n        );\n      }\n    };\n\n    return Promise.race([runAllTests, onInterrupt]).then(cleanup, cleanup);\n  }\n\n  on<Name extends keyof TestEvents>(\n    eventName: Name,\n    listener: (eventData: TestEvents[Name]) => void | Promise<void>,\n  ): UnsubscribeFn {\n    return this.#eventEmitter.on(eventName, listener);\n  }\n\n  #sendMessageToJest: TestFileEvent = async (eventName, args) => {\n    await this.#eventEmitter.emit(\n      eventName,\n      // `deepCyclicCopy` used here to avoid mem-leak\n      deepCyclicCopy(args, {keepPrototype: false}),\n    );\n  };\n}\n\nclass CancelRun extends Error {\n  constructor(message?: string) {\n    super(message);\n    this.name = 'CancelRun';\n  }\n}\n",
  "packages/jest-runner/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Test, TestEvents } from '@jest/test-result';\nimport type { TestWatcher } from 'jest-watcher';\nimport { EmittingTestRunner, type TestRunnerOptions, type UnsubscribeFn } from './types';\nexport type { Test, TestEvents } from '@jest/test-result';\nexport type { Config } from '@jest/types';\nexport type { TestWatcher } from 'jest-watcher';\nexport { CallbackTestRunner, EmittingTestRunner } from './types';\nexport type { CallbackTestRunnerInterface, EmittingTestRunnerInterface, OnTestFailure, OnTestStart, OnTestSuccess, TestRunnerContext, TestRunnerOptions, JestTestRunner, UnsubscribeFn, } from './types';\nexport default class TestRunner extends EmittingTestRunner {\n    #private;\n    runTests(tests: Array<Test>, watcher: TestWatcher, options: TestRunnerOptions): Promise<void>;\n    on<Name extends keyof TestEvents>(eventName: Name, listener: (eventData: TestEvents[Name]) => void | Promise<void>): UnsubscribeFn;\n}\n",
  "packages/jest-runner/src/__tests__/testRunner.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {TestContext} from '@jest/test-result';\nimport {makeGlobalConfig, makeProjectConfig} from '@jest/test-utils';\nimport {TestWatcher} from 'jest-watcher';\nimport TestRunner from '../index';\n\nlet mockWorkerFarm;\n\njest.mock('jest-worker', () => ({\n  Worker: jest.fn(\n    worker =>\n      (mockWorkerFarm = {\n        end: jest.fn().mockResolvedValue({forceExited: false}),\n        getStderr: jest.fn(),\n        getStdout: jest.fn(),\n        worker: jest.fn((data, callback) => require(worker)(data, callback)),\n      }),\n  ),\n}));\n\njest.mock('../testWorker', () => {});\n\ntest('injects the serializable module map into each worker in watch mode', async () => {\n  const globalConfig = makeGlobalConfig({maxWorkers: 2, watch: true});\n  const config = makeProjectConfig({rootDir: '/path/'});\n  const runContext = {};\n  const mockTestContext = {\n    config,\n    moduleMap: {toJSON: jest.fn()},\n  } as unknown as TestContext;\n\n  await new TestRunner(globalConfig, runContext).runTests(\n    [\n      {context: mockTestContext, path: './file.test.js'},\n      {context: mockTestContext, path: './file2.test.js'},\n    ],\n    new TestWatcher({isWatchMode: globalConfig.watch}),\n    {serial: false},\n  );\n\n  expect(mockWorkerFarm.worker).toHaveBeenCalledTimes(2);\n\n  expect(mockWorkerFarm.worker).toHaveBeenNthCalledWith(1, {\n    config,\n    context: runContext,\n    globalConfig,\n    path: './file.test.js',\n  });\n\n  expect(mockWorkerFarm.worker).toHaveBeenNthCalledWith(2, {\n    config,\n    context: runContext,\n    globalConfig,\n    path: './file2.test.js',\n  });\n});\n\ntest('assign process.env.JEST_WORKER_ID = 1 when in runInBand mode', async () => {\n  const globalConfig = makeGlobalConfig({maxWorkers: 1, watch: false});\n  const config = makeProjectConfig({rootDir: '/path/'});\n  const context = {config} as TestContext;\n\n  await new TestRunner(globalConfig, {}).runTests(\n    [{context, path: './file.test.js'}],\n    new TestWatcher({isWatchMode: globalConfig.watch}),\n    {serial: true},\n  );\n\n  expect(process.env.JEST_WORKER_ID).toBe('1');\n});\n",
  "packages/jest-runner/src/__tests__/testRunner.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport {};\n",
  "packages/jest-runner/__typetests__/jest-runner.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {expect} from 'tstyche';\nimport {\n  CallbackTestRunner,\n  type CallbackTestRunnerInterface,\n  type Config,\n  EmittingTestRunner,\n  type EmittingTestRunnerInterface,\n  type OnTestFailure,\n  type OnTestStart,\n  type OnTestSuccess,\n  type Test,\n  type TestEvents,\n  type TestRunnerContext,\n  type TestRunnerOptions,\n  type TestWatcher,\n  type UnsubscribeFn,\n} from 'jest-runner';\n\nconst globalConfig = {} as Config.GlobalConfig;\nconst runnerContext = {} as TestRunnerContext;\n\n// CallbackRunner\n\nclass CallbackRunner extends CallbackTestRunner {\n  async runTests(\n    tests: Array<Test>,\n    watcher: TestWatcher,\n    onStart: OnTestStart,\n    onResult: OnTestSuccess,\n    onFailure: OnTestFailure,\n    options: TestRunnerOptions,\n  ): Promise<void> {\n    expect(this._globalConfig).type.toBe<Config.GlobalConfig>();\n    expect(this._context).type.toBe<TestRunnerContext>();\n\n    return;\n  }\n}\n\nconst callbackRunner = new CallbackRunner(globalConfig, runnerContext);\n\nexpect(callbackRunner.isSerial).type.toBe<boolean | undefined>();\nexpect(callbackRunner.supportsEventEmitters).type.toBe<false>();\n\n// CallbackTestRunnerInterface\n\nclass CustomCallbackRunner implements CallbackTestRunnerInterface {\n  readonly #maxConcurrency: number;\n  readonly #globalConfig: Config.GlobalConfig;\n\n  constructor(globalConfig: Config.GlobalConfig) {\n    this.#globalConfig = globalConfig;\n    this.#maxConcurrency = globalConfig.maxWorkers;\n  }\n\n  async runTests(\n    tests: Array<Test>,\n    watcher: TestWatcher,\n    onStart: OnTestStart,\n    onResult: OnTestSuccess,\n    onFailure: OnTestFailure,\n    options: TestRunnerOptions,\n  ): Promise<void> {\n    expect(this.#globalConfig).type.toBe<Config.GlobalConfig>();\n    expect(this.#maxConcurrency).type.toBe<number>();\n\n    return;\n  }\n}\n\n// EmittingRunner\n\nclass EmittingRunner extends EmittingTestRunner {\n  async runTests(\n    tests: Array<Test>,\n    watcher: TestWatcher,\n    options: TestRunnerOptions,\n  ): Promise<void> {\n    expect(this._globalConfig).type.toBe<Config.GlobalConfig>();\n    expect(this._context).type.toBe<TestRunnerContext>();\n\n    return;\n  }\n\n  on<Name extends keyof TestEvents>(\n    eventName: string,\n    listener: (eventData: TestEvents[Name]) => void | Promise<void>,\n  ): UnsubscribeFn {\n    return () => {};\n  }\n}\n\nconst emittingRunner = new EmittingRunner(globalConfig, runnerContext);\n\nexpect(emittingRunner.isSerial).type.toBe<boolean | undefined>();\nexpect(emittingRunner.supportsEventEmitters).type.toBe<true>();\n\n// EmittingTestRunnerInterface\n\nclass CustomEmittingRunner implements EmittingTestRunnerInterface {\n  readonly #maxConcurrency: number;\n  readonly #globalConfig: Config.GlobalConfig;\n  readonly supportsEventEmitters = true;\n\n  constructor(globalConfig: Config.GlobalConfig) {\n    this.#globalConfig = globalConfig;\n    this.#maxConcurrency = globalConfig.maxWorkers;\n  }\n\n  async runTests(\n    tests: Array<Test>,\n    watcher: TestWatcher,\n    options: TestRunnerOptions,\n  ): Promise<void> {\n    expect(this.#globalConfig).type.toBe<Config.GlobalConfig>();\n    expect(this.#maxConcurrency).type.toBe<number>();\n\n    return;\n  }\n\n  on<Name extends keyof TestEvents>(\n    eventName: string,\n    listener: (eventData: TestEvents[Name]) => void | Promise<void>,\n  ): UnsubscribeFn {\n    return () => {};\n  }\n}\n",
  "packages/jest-runner/__typetests__/jest-runner.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-resolve-dependencies/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport type {IHasteFS} from 'jest-haste-map';\nimport type {ResolveModuleConfig, default as Resolver} from 'jest-resolve';\nimport {type SnapshotResolver, isSnapshotPath} from 'jest-snapshot';\n\nexport type ResolvedModule = {\n  file: string;\n  dependencies: Array<string>;\n};\n\n/**\n * DependencyResolver is used to resolve the direct dependencies of a module or\n * to retrieve a list of all transitive inverse dependencies.\n */\nexport class DependencyResolver {\n  private readonly _hasteFS: IHasteFS;\n  private readonly _resolver: Resolver;\n  private readonly _snapshotResolver: SnapshotResolver;\n\n  constructor(\n    resolver: Resolver,\n    hasteFS: IHasteFS,\n    snapshotResolver: SnapshotResolver,\n  ) {\n    this._resolver = resolver;\n    this._hasteFS = hasteFS;\n    this._snapshotResolver = snapshotResolver;\n  }\n\n  resolve(file: string, options?: ResolveModuleConfig): Array<string> {\n    const dependencies = this._hasteFS.getDependencies(file);\n    const fallbackOptions: ResolveModuleConfig = {conditions: undefined};\n    if (!dependencies) {\n      return [];\n    }\n\n    return dependencies.reduce<Array<string>>((acc, dependency) => {\n      if (this._resolver.isCoreModule(dependency)) {\n        return acc;\n      }\n\n      let resolvedDependency;\n      let resolvedMockDependency;\n      try {\n        resolvedDependency = this._resolver.resolveModule(\n          file,\n          dependency,\n          options ?? fallbackOptions,\n        );\n      } catch {\n        try {\n          resolvedDependency = this._resolver.getMockModule(\n            file,\n            dependency,\n            options ?? fallbackOptions,\n          );\n        } catch {\n          // leave resolvedDependency as undefined if nothing can be found\n        }\n      }\n\n      if (resolvedDependency == null) {\n        return acc;\n      }\n\n      acc.push(resolvedDependency);\n\n      // If we resolve a dependency, then look for a mock dependency\n      // of the same name in that dependency's directory.\n      try {\n        resolvedMockDependency = this._resolver.getMockModule(\n          resolvedDependency,\n          path.basename(dependency),\n          options ?? fallbackOptions,\n        );\n      } catch {\n        // leave resolvedMockDependency as undefined if nothing can be found\n      }\n\n      if (resolvedMockDependency != null) {\n        const dependencyMockDir = path.resolve(\n          path.dirname(resolvedDependency),\n          '__mocks__',\n        );\n\n        resolvedMockDependency = path.resolve(resolvedMockDependency);\n\n        // make sure mock is in the correct directory\n        if (dependencyMockDir === path.dirname(resolvedMockDependency)) {\n          acc.push(resolvedMockDependency);\n        }\n      }\n\n      return acc;\n    }, []);\n  }\n\n  resolveInverseModuleMap(\n    paths: Set<string>,\n    filter: (file: string) => boolean,\n    options?: ResolveModuleConfig,\n  ): Array<ResolvedModule> {\n    if (paths.size === 0) {\n      return [];\n    }\n\n    const collectModules = (\n      related: Set<string>,\n      moduleMap: Array<ResolvedModule>,\n      changed: Set<string>,\n    ) => {\n      const visitedModules = new Set();\n      const result: Array<ResolvedModule> = [];\n      while (changed.size > 0) {\n        changed = new Set(\n          moduleMap.reduce<Array<string>>((acc, module) => {\n            if (\n              visitedModules.has(module.file) ||\n              !module.dependencies.some(dep => changed.has(dep))\n            ) {\n              return acc;\n            }\n\n            const file = module.file;\n            if (filter(file)) {\n              result.push(module);\n              related.delete(file);\n            }\n            visitedModules.add(file);\n            acc.push(file);\n            return acc;\n          }, []),\n        );\n      }\n      return [\n        ...result,\n        ...[...related].map(file => ({dependencies: [], file})),\n      ];\n    };\n\n    const relatedPaths = new Set<string>();\n    const changed = new Set<string>();\n    for (const path of paths) {\n      if (this._hasteFS.exists(path)) {\n        const modulePath = isSnapshotPath(path)\n          ? this._snapshotResolver.resolveTestPath(path)\n          : path;\n        changed.add(modulePath);\n        if (filter(modulePath)) {\n          relatedPaths.add(modulePath);\n        }\n      }\n    }\n    const modules: Array<ResolvedModule> = [];\n    for (const file of this._hasteFS.getAbsoluteFileIterator()) {\n      modules.push({\n        dependencies: this.resolve(file, options),\n        file,\n      });\n    }\n    return collectModules(relatedPaths, modules, changed);\n  }\n\n  resolveInverse(\n    paths: Set<string>,\n    filter: (file: string) => boolean,\n    options?: ResolveModuleConfig,\n  ): Array<string> {\n    return this.resolveInverseModuleMap(paths, filter, options).map(\n      module => module.file,\n    );\n  }\n}\n",
  "packages/jest-resolve-dependencies/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { IHasteFS } from 'jest-haste-map';\nimport type { ResolveModuleConfig, default as Resolver } from 'jest-resolve';\nimport { type SnapshotResolver } from 'jest-snapshot';\nexport type ResolvedModule = {\n    file: string;\n    dependencies: Array<string>;\n};\n/**\n * DependencyResolver is used to resolve the direct dependencies of a module or\n * to retrieve a list of all transitive inverse dependencies.\n */\nexport declare class DependencyResolver {\n    private readonly _hasteFS;\n    private readonly _resolver;\n    private readonly _snapshotResolver;\n    constructor(resolver: Resolver, hasteFS: IHasteFS, snapshotResolver: SnapshotResolver);\n    resolve(file: string, options?: ResolveModuleConfig): Array<string>;\n    resolveInverseModuleMap(paths: Set<string>, filter: (file: string) => boolean, options?: ResolveModuleConfig): Array<ResolvedModule>;\n    resolveInverse(paths: Set<string>, filter: (file: string) => boolean, options?: ResolveModuleConfig): Array<string>;\n}\n",
  "packages/jest-resolve-dependencies/src/__tests__/dependency_resolver.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport {makeProjectConfig} from '@jest/test-utils';\nimport type {Config} from '@jest/types';\nimport type Resolver from 'jest-resolve';\nimport {buildSnapshotResolver} from 'jest-snapshot';\nimport {DependencyResolver} from '../index';\n\nconst maxWorkers = 1;\nlet dependencyResolver: DependencyResolver;\nlet runtimeContextResolver: Resolver;\nlet config: Config.ProjectConfig;\nconst cases: Record<string, (path: string) => boolean> = {\n  fancyCondition: path => path.length > 10,\n  testRegex: path => /.test.js$/.test(path),\n};\nconst filter = (path: string) =>\n  Object.keys(cases).every(key => cases[key](path));\n\nbeforeEach(async () => {\n  const Runtime = (require('jest-runtime') as typeof import('jest-runtime'))\n    .default;\n  config = makeProjectConfig({\n    cacheDirectory: path.resolve(tmpdir(), 'jest-resolve-dependencies-test'),\n    moduleDirectories: ['node_modules'],\n    moduleNameMapper: [['^\\\\$asdf/(.*)$', '<rootDir>/$1']],\n    /**\n     * `rootDir` must be an absolute path\n     * @See https://github.com/jestjs/jest/blob/76632c6ec3f56708ec5781158972a295d0cc9332/packages/jest-haste-map/src/lib/fast_path.ts#L19-L25\n     */\n    rootDir: process.cwd(),\n    roots: ['./packages/jest-resolve-dependencies'],\n  });\n  const runtimeContext = await Runtime.createContext(config, {\n    maxWorkers,\n    watchman: false,\n  });\n\n  runtimeContextResolver = runtimeContext.resolver;\n  dependencyResolver = new DependencyResolver(\n    runtimeContext.resolver,\n    runtimeContext.hasteFS,\n    await buildSnapshotResolver(config),\n  );\n});\n\ntest('resolves no dependencies for non-existent path', () => {\n  const resolved = dependencyResolver.resolve('/non/existent/path');\n  expect(resolved).toHaveLength(0);\n});\n\ntest('resolves dependencies for existing path', () => {\n  const resolved = dependencyResolver.resolve(\n    path.resolve(__dirname, '__fixtures__', 'file.js'),\n  );\n  expect(resolved).toEqual([\n    expect.stringContaining('jest-resolve-dependencies'),\n    expect.stringContaining('jest-regex-util'),\n  ]);\n});\n\ntest('includes the mocks of dependencies as dependencies', () => {\n  const resolved = dependencyResolver.resolve(\n    path.resolve(__dirname, '__fixtures__/hasMocked/file.test.js'),\n  );\n\n  expect(resolved).toEqual([\n    expect.stringContaining(path.join('hasMocked', 'file.js')),\n    expect.stringContaining(path.join('hasMocked', '__mocks__', 'file.js')),\n    expect.stringContaining(path.join('__mocks__', 'fake-node-module.js')),\n  ]);\n});\n\ntest('resolves dependencies for scoped packages', () => {\n  const resolved = dependencyResolver.resolve(\n    path.resolve(__dirname, '__fixtures__', 'scoped.js'),\n  );\n  expect(resolved).toEqual([\n    expect.stringContaining(path.join('@myorg', 'pkg')),\n  ]);\n});\n\ntest('resolves no inverse dependencies for empty paths set', () => {\n  const paths = new Set<string>();\n  const resolved = dependencyResolver.resolveInverse(paths, filter);\n  expect(resolved).toHaveLength(0);\n});\n\ntest('resolves no inverse dependencies for set of non-existent paths', () => {\n  const paths = new Set(['/non/existent/path', '/another/one']);\n  const resolved = dependencyResolver.resolveInverse(paths, filter);\n  expect(resolved).toHaveLength(0);\n});\n\ntest('resolves inverse dependencies for existing path', () => {\n  const paths = new Set([path.resolve(__dirname, '__fixtures__/file.js')]);\n  const resolved = dependencyResolver.resolveInverse(paths, filter);\n  expect(resolved).toEqual([\n    expect.stringContaining(\n      path.join('__tests__', '__fixtures__', 'file.test.js'),\n    ),\n  ]);\n});\n\ntest('resolves inverse dependencies of mock', () => {\n  const paths = new Set([\n    path.resolve(__dirname, '__fixtures__/hasMocked/__mocks__/file.js'),\n  ]);\n  const resolved = dependencyResolver.resolveInverse(paths, filter);\n\n  expect(resolved).toEqual([\n    expect.stringContaining(\n      path.join('__tests__/__fixtures__/hasMocked/file.test.js'),\n    ),\n  ]);\n});\n\ntest('resolves inverse dependencies from available snapshot', () => {\n  const paths = new Set([\n    path.resolve(__dirname, '__fixtures__/file.js'),\n    path.resolve(__dirname, '__fixtures__/__snapshots__/related.test.js.snap'),\n  ]);\n  const resolved = dependencyResolver.resolveInverse(paths, filter);\n  expect(resolved).toEqual(\n    expect.arrayContaining([\n      expect.stringContaining(\n        path.join('__tests__', '__fixtures__', 'file.test.js'),\n      ),\n      expect.stringContaining(\n        path.join('__tests__', '__fixtures__', 'related.test.js'),\n      ),\n    ]),\n  );\n});\n\ntest('resolves dependencies correctly when dependency resolution fails', () => {\n  jest.spyOn(runtimeContextResolver, 'resolveModule').mockImplementation(() => {\n    throw new Error('resolveModule has failed');\n  });\n  jest.spyOn(runtimeContextResolver, 'getMockModule').mockImplementation(() => {\n    throw new Error('getMockModule has failed');\n  });\n\n  const resolved = dependencyResolver.resolve(\n    path.resolve(__dirname, '__fixtures__', 'file.test.js'),\n  );\n\n  expect(resolved).toEqual([]);\n});\n\ntest('resolves dependencies correctly when mock dependency resolution fails', () => {\n  jest.spyOn(runtimeContextResolver, 'getMockModule').mockImplementation(() => {\n    throw new Error('getMockModule has failed');\n  });\n\n  const resolved = dependencyResolver.resolve(\n    path.resolve(__dirname, '__fixtures__', 'file.test.js'),\n  );\n\n  expect(resolved).toEqual([\n    expect.stringContaining(path.join('__tests__', '__fixtures__', 'file.js')),\n  ]);\n});\n",
  "packages/jest-resolve-dependencies/src/__tests__/dependency_resolver.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-resolve/src/utils.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport chalk from 'chalk';\nimport {ValidationError} from 'jest-validate';\nimport Resolver from './resolver';\n\nconst BULLET: string = chalk.bold('\\u25CF ');\nconst DOCUMENTATION_NOTE = `  ${chalk.bold('Configuration Documentation:')}\n  https://jestjs.io/docs/configuration\n`;\n\nconst createValidationError = (message: string) =>\n  new ValidationError(`${BULLET}Validation Error`, message, DOCUMENTATION_NOTE);\n\nconst replaceRootDirInPath = (rootDir: string, filePath: string): string => {\n  if (!filePath.startsWith('<rootDir>')) {\n    return filePath;\n  }\n\n  return path.resolve(\n    rootDir,\n    path.normalize(`./${filePath.slice('<rootDir>'.length)}`),\n  );\n};\n\nconst resolveWithPrefix = (\n  resolver: string | undefined | null,\n  {\n    filePath,\n    humanOptionName,\n    optionName,\n    prefix,\n    requireResolveFunction,\n    rootDir,\n  }: {\n    filePath: string;\n    humanOptionName: string;\n    optionName: string;\n    prefix: string;\n    requireResolveFunction: (moduleName: string) => string;\n    rootDir: string;\n  },\n): string => {\n  const fileName = replaceRootDirInPath(rootDir, filePath);\n  let module = Resolver.findNodeModule(`${prefix}${fileName}`, {\n    basedir: rootDir,\n    resolver: resolver || undefined,\n  });\n  if (module) {\n    return module;\n  }\n\n  try {\n    return requireResolveFunction(`${prefix}${fileName}`);\n  } catch {}\n\n  module = Resolver.findNodeModule(fileName, {\n    basedir: rootDir,\n    resolver: resolver || undefined,\n  });\n  if (module) {\n    return module;\n  }\n\n  try {\n    return requireResolveFunction(fileName);\n  } catch {}\n\n  throw createValidationError(\n    `  ${humanOptionName} ${chalk.bold(\n      fileName,\n    )} cannot be found. Make sure the ${chalk.bold(\n      optionName,\n    )} configuration option points to an existing node module.`,\n  );\n};\n\n/**\n * Finds the test environment to use:\n *\n * 1. looks for jest-environment-<name> relative to project.\n * 1. looks for jest-environment-<name> relative to Jest.\n * 1. looks for <name> relative to project.\n * 1. looks for <name> relative to Jest.\n */\nexport const resolveTestEnvironment = ({\n  rootDir,\n  testEnvironment: filePath,\n  requireResolveFunction,\n}: {\n  rootDir: string;\n  testEnvironment: string;\n  requireResolveFunction: (moduleName: string) => string;\n}): string => {\n  // we don't want to resolve the actual `jsdom` module if `jest-environment-jsdom` is not installed, but `jsdom` package is\n  if (filePath === 'jsdom') {\n    filePath = 'jest-environment-jsdom';\n  }\n\n  try {\n    return resolveWithPrefix(undefined, {\n      filePath,\n      humanOptionName: 'Test environment',\n      optionName: 'testEnvironment',\n      prefix: 'jest-environment-',\n      requireResolveFunction,\n      rootDir,\n    });\n  } catch (error: any) {\n    if (filePath === 'jest-environment-jsdom') {\n      error.message +=\n        '\\n\\nAs of Jest 28 \"jest-environment-jsdom\" is no longer shipped by default, make sure to install it separately.';\n    }\n\n    throw error;\n  }\n};\n\n/**\n * Finds the watch plugins to use:\n *\n * 1. looks for jest-watch-<name> relative to project.\n * 1. looks for jest-watch-<name> relative to Jest.\n * 1. looks for <name> relative to project.\n * 1. looks for <name> relative to Jest.\n */\nexport const resolveWatchPlugin = (\n  resolver: string | undefined | null,\n  {\n    filePath,\n    rootDir,\n    requireResolveFunction,\n  }: {\n    filePath: string;\n    rootDir: string;\n    requireResolveFunction: (moduleName: string) => string;\n  },\n): string =>\n  resolveWithPrefix(resolver, {\n    filePath,\n    humanOptionName: 'Watch plugin',\n    optionName: 'watchPlugins',\n    prefix: 'jest-watch-',\n    requireResolveFunction,\n    rootDir,\n  });\n\n/**\n * Finds the runner to use:\n *\n * 1. looks for jest-runner-<name> relative to project.\n * 1. looks for jest-runner-<name> relative to Jest.\n * 1. looks for <name> relative to project.\n * 1. looks for <name> relative to Jest.\n */\nexport const resolveRunner = (\n  resolver: string | undefined | null,\n  {\n    filePath,\n    rootDir,\n    requireResolveFunction,\n  }: {\n    filePath: string;\n    rootDir: string;\n    requireResolveFunction: (moduleName: string) => string;\n  },\n): string =>\n  resolveWithPrefix(resolver, {\n    filePath,\n    humanOptionName: 'Jest Runner',\n    optionName: 'runner',\n    prefix: 'jest-runner-',\n    requireResolveFunction,\n    rootDir,\n  });\n\nexport const resolveSequencer = (\n  resolver: string | undefined | null,\n  {\n    filePath,\n    rootDir,\n    requireResolveFunction,\n  }: {\n    filePath: string;\n    rootDir: string;\n    requireResolveFunction: (moduleName: string) => string;\n  },\n): string =>\n  resolveWithPrefix(resolver, {\n    filePath,\n    humanOptionName: 'Jest Sequencer',\n    optionName: 'testSequencer',\n    prefix: 'jest-sequencer-',\n    requireResolveFunction,\n    rootDir,\n  });\n",
  "packages/jest-resolve/src/utils.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n/**\n * Finds the test environment to use:\n *\n * 1. looks for jest-environment-<name> relative to project.\n * 1. looks for jest-environment-<name> relative to Jest.\n * 1. looks for <name> relative to project.\n * 1. looks for <name> relative to Jest.\n */\nexport declare const resolveTestEnvironment: ({ rootDir, testEnvironment: filePath, requireResolveFunction, }: {\n    rootDir: string;\n    testEnvironment: string;\n    requireResolveFunction: (moduleName: string) => string;\n}) => string;\n/**\n * Finds the watch plugins to use:\n *\n * 1. looks for jest-watch-<name> relative to project.\n * 1. looks for jest-watch-<name> relative to Jest.\n * 1. looks for <name> relative to project.\n * 1. looks for <name> relative to Jest.\n */\nexport declare const resolveWatchPlugin: (resolver: string | undefined | null, { filePath, rootDir, requireResolveFunction, }: {\n    filePath: string;\n    rootDir: string;\n    requireResolveFunction: (moduleName: string) => string;\n}) => string;\n/**\n * Finds the runner to use:\n *\n * 1. looks for jest-runner-<name> relative to project.\n * 1. looks for jest-runner-<name> relative to Jest.\n * 1. looks for <name> relative to project.\n * 1. looks for <name> relative to Jest.\n */\nexport declare const resolveRunner: (resolver: string | undefined | null, { filePath, rootDir, requireResolveFunction, }: {\n    filePath: string;\n    rootDir: string;\n    requireResolveFunction: (moduleName: string) => string;\n}) => string;\nexport declare const resolveSequencer: (resolver: string | undefined | null, { filePath, rootDir, requireResolveFunction, }: {\n    filePath: string;\n    rootDir: string;\n    requireResolveFunction: (moduleName: string) => string;\n}) => string;\n",
  "packages/jest-resolve/src/types.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nexport type ResolverConfig = {\n  defaultPlatform?: string | null;\n  extensions: Array<string>;\n  hasCoreModules: boolean;\n  moduleDirectories: Array<string>;\n  moduleNameMapper?: Array<ModuleNameMapperConfig> | null;\n  modulePaths?: Array<string>;\n  platforms?: Array<string>;\n  resolver?: string | null;\n  rootDir: string;\n};\n\ntype ModuleNameMapperConfig = {\n  regex: RegExp;\n  moduleName: string | Array<string>;\n};\n\n// https://github.com/Microsoft/TypeScript/issues/3496#issuecomment-128553540\ntype JSONValue = string | number | boolean | JSONObject | Array<JSONValue>;\ninterface JSONObject {\n  [key: string]: JSONValue;\n}\n\nexport type PackageJSON = JSONObject;\n",
  "packages/jest-resolve/src/types.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport type ResolverConfig = {\n    defaultPlatform?: string | null;\n    extensions: Array<string>;\n    hasCoreModules: boolean;\n    moduleDirectories: Array<string>;\n    moduleNameMapper?: Array<ModuleNameMapperConfig> | null;\n    modulePaths?: Array<string>;\n    platforms?: Array<string>;\n    resolver?: string | null;\n    rootDir: string;\n};\ntype ModuleNameMapperConfig = {\n    regex: RegExp;\n    moduleName: string | Array<string>;\n};\ntype JSONValue = string | number | boolean | JSONObject | Array<JSONValue>;\ninterface JSONObject {\n    [key: string]: JSONValue;\n}\nexport type PackageJSON = JSONObject;\nexport {};\n",
  "packages/jest-resolve/src/shouldLoadAsEsm.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {dirname, extname} from 'path';\n// @ts-expect-error: experimental, not added to the types\nimport {SyntheticModule} from 'vm';\nimport {findClosestPackageJson, readPackageCached} from './fileWalkers';\n\nconst runtimeSupportsVmModules = typeof SyntheticModule === 'function';\n\nconst cachedFileLookups = new Map<string, boolean>();\nconst cachedDirLookups = new Map<string, boolean>();\nconst cachedChecks = new Map<string, boolean>();\n\nexport function clearCachedLookups(): void {\n  cachedFileLookups.clear();\n  cachedDirLookups.clear();\n  cachedChecks.clear();\n}\n\nexport default function cachedShouldLoadAsEsm(\n  path: string,\n  extensionsToTreatAsEsm: Array<string>,\n): boolean {\n  if (!runtimeSupportsVmModules) {\n    return false;\n  }\n\n  let cachedLookup = cachedFileLookups.get(path);\n\n  if (cachedLookup === undefined) {\n    cachedLookup = shouldLoadAsEsm(path, extensionsToTreatAsEsm);\n    cachedFileLookups.set(path, cachedLookup);\n  }\n\n  return cachedLookup;\n}\n\n// this is a bad version of what https://github.com/nodejs/modules/issues/393 would provide\nfunction shouldLoadAsEsm(\n  path: string,\n  extensionsToTreatAsEsm: Array<string>,\n): boolean {\n  const extension = extname(path);\n\n  if (extension === '.mjs') {\n    return true;\n  }\n\n  if (extension === '.cjs') {\n    return false;\n  }\n\n  if (extension !== '.js') {\n    return extensionsToTreatAsEsm.includes(extension);\n  }\n\n  const cwd = dirname(path);\n\n  let cachedLookup = cachedDirLookups.get(cwd);\n\n  if (cachedLookup === undefined) {\n    cachedLookup = cachedPkgCheck(cwd);\n    cachedFileLookups.set(cwd, cachedLookup);\n  }\n\n  return cachedLookup;\n}\n\nfunction cachedPkgCheck(cwd: string): boolean {\n  const pkgPath = findClosestPackageJson(cwd);\n  if (!pkgPath) {\n    return false;\n  }\n\n  let hasModuleField = cachedChecks.get(pkgPath);\n  if (hasModuleField != null) {\n    return hasModuleField;\n  }\n\n  try {\n    const pkg = readPackageCached(pkgPath);\n    hasModuleField = pkg.type === 'module';\n  } catch {\n    hasModuleField = false;\n  }\n\n  cachedChecks.set(pkgPath, hasModuleField);\n  return hasModuleField;\n}\n",
  "packages/jest-resolve/src/shouldLoadAsEsm.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport declare function clearCachedLookups(): void;\nexport default function cachedShouldLoadAsEsm(path: string, extensionsToTreatAsEsm: Array<string>): boolean;\n",
  "packages/jest-resolve/src/resolver.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {isBuiltin} from 'module';\nimport * as path from 'path';\nimport chalk from 'chalk';\nimport slash from 'slash';\nimport type {IModuleMap} from 'jest-haste-map';\nimport {tryRealpath} from 'jest-util';\nimport ModuleNotFoundError from './ModuleNotFoundError';\nimport defaultResolver, {\n  type AsyncResolver,\n  type Resolver as ResolverInterface,\n  type SyncResolver,\n  defaultAsyncResolver,\n} from './defaultResolver';\nimport {clearFsCache} from './fileWalkers';\nimport nodeModulesPaths, {GlobalPaths} from './nodeModulesPaths';\nimport shouldLoadAsEsm, {clearCachedLookups} from './shouldLoadAsEsm';\nimport type {ResolverConfig} from './types';\n\nexport type FindNodeModuleConfig = {\n  basedir: string;\n  conditions?: Array<string>;\n  extensions?: Array<string>;\n  moduleDirectory?: Array<string>;\n  paths?: Array<string>;\n  resolver?: string | null;\n  rootDir?: string;\n  throwIfNotFound?: boolean;\n};\n\nexport type ResolveModuleConfig = {\n  conditions?: Array<string>;\n  skipNodeResolution?: boolean;\n  paths?: Array<string>;\n};\n\nconst NATIVE_PLATFORM = 'native';\n\n// We might be inside a symlink.\nconst resolvedCwd = tryRealpath(process.cwd());\nconst {NODE_PATH} = process.env;\nconst nodePaths = NODE_PATH\n  ? NODE_PATH.split(path.delimiter)\n      .filter(Boolean)\n      // The resolver expects absolute paths.\n      .map(p => path.resolve(resolvedCwd, p))\n  : undefined;\n\nexport default class Resolver {\n  private readonly _options: ResolverConfig;\n  private readonly _moduleMap: IModuleMap;\n  private readonly _moduleIDCache: Map<string, string>;\n  private readonly _moduleNameCache: Map<string, string>;\n  private readonly _modulePathCache: Map<string, Array<string>>;\n  private readonly _supportsNativePlatform: boolean;\n\n  constructor(moduleMap: IModuleMap, options: ResolverConfig) {\n    this._options = {\n      defaultPlatform: options.defaultPlatform,\n      extensions: options.extensions,\n      hasCoreModules:\n        options.hasCoreModules === undefined ? true : options.hasCoreModules,\n      moduleDirectories: options.moduleDirectories || ['node_modules'],\n      moduleNameMapper: options.moduleNameMapper,\n      modulePaths: options.modulePaths,\n      platforms: options.platforms,\n      resolver: options.resolver,\n      rootDir: options.rootDir,\n    };\n    this._supportsNativePlatform = options.platforms\n      ? options.platforms.includes(NATIVE_PLATFORM)\n      : false;\n    this._moduleMap = moduleMap;\n    this._moduleIDCache = new Map();\n    this._moduleNameCache = new Map();\n    this._modulePathCache = new Map();\n  }\n\n  static ModuleNotFoundError = ModuleNotFoundError;\n\n  static tryCastModuleNotFoundError(\n    error: unknown,\n  ): ModuleNotFoundError | null {\n    if (error instanceof ModuleNotFoundError) {\n      return error;\n    }\n\n    const casted = error as ModuleNotFoundError;\n    if (casted.code === 'MODULE_NOT_FOUND') {\n      return ModuleNotFoundError.duckType(casted);\n    }\n\n    return null;\n  }\n\n  static clearDefaultResolverCache(): void {\n    clearFsCache();\n    clearCachedLookups();\n  }\n\n  static findNodeModule(\n    path: string,\n    options: FindNodeModuleConfig,\n  ): string | null {\n    const resolverModule = loadResolver(options.resolver);\n    let resolver: SyncResolver = defaultResolver;\n\n    if (typeof resolverModule === 'function') {\n      resolver = resolverModule;\n    } else if (typeof resolverModule.sync === 'function') {\n      resolver = resolverModule.sync;\n    }\n\n    const paths = options.paths;\n\n    try {\n      return resolver(path, {\n        basedir: options.basedir,\n        conditions: options.conditions,\n        defaultAsyncResolver,\n        defaultResolver,\n        extensions: options.extensions,\n        moduleDirectory: options.moduleDirectory,\n        paths: paths ? [...(nodePaths || []), ...paths] : nodePaths,\n        rootDir: options.rootDir,\n      });\n    } catch (error) {\n      // we always wanna throw if it's an internal import\n      if (options.throwIfNotFound || path.startsWith('#')) {\n        throw error;\n      }\n    }\n    return null;\n  }\n\n  static async findNodeModuleAsync(\n    path: string,\n    options: FindNodeModuleConfig,\n  ): Promise<string | null> {\n    const resolverModule = loadResolver(options.resolver);\n    let resolver: ResolverInterface = defaultAsyncResolver;\n\n    if (typeof resolverModule === 'function') {\n      resolver = resolverModule;\n    } else if (\n      typeof resolverModule.async === 'function' ||\n      typeof resolverModule.sync === 'function'\n    ) {\n      const asyncOrSync = resolverModule.async || resolverModule.sync;\n\n      if (asyncOrSync == null) {\n        throw new Error(`Unable to load resolver at ${options.resolver}`);\n      }\n\n      resolver = asyncOrSync;\n    }\n\n    const paths = options.paths;\n\n    try {\n      const result = await resolver(path, {\n        basedir: options.basedir,\n        conditions: options.conditions,\n        defaultAsyncResolver,\n        defaultResolver,\n        extensions: options.extensions,\n        moduleDirectory: options.moduleDirectory,\n        paths: paths ? [...(nodePaths || []), ...paths] : nodePaths,\n        rootDir: options.rootDir,\n      });\n      return result;\n    } catch (error: unknown) {\n      // we always wanna throw if it's an internal import\n      if (options.throwIfNotFound || path.startsWith('#')) {\n        throw error;\n      }\n    }\n    return null;\n  }\n\n  // unstable as it should be replaced by https://github.com/nodejs/modules/issues/393, and we don't want people to use it\n  static unstable_shouldLoadAsEsm = shouldLoadAsEsm;\n\n  resolveModuleFromDirIfExists(\n    dirname: string,\n    moduleName: string,\n    options?: ResolveModuleConfig,\n  ): string | null {\n    const {extensions, key, moduleDirectory, paths, skipResolution} =\n      this._prepareForResolution(dirname, moduleName, options);\n\n    let module;\n\n    // 1. If we have already resolved this module for this directory name,\n    // return a value from the cache.\n    const cacheResult = this._moduleNameCache.get(key);\n    if (cacheResult) {\n      return cacheResult;\n    }\n\n    // 2. Check if the module is a haste module.\n    module = this.getModule(moduleName);\n    if (module) {\n      this._moduleNameCache.set(key, module);\n      return module;\n    }\n\n    // 3. Check if the module is a node module and resolve it based on\n    // the node module resolution algorithm. If skipNodeResolution is given we\n    // ignore all modules that look like node modules (ie. are not relative\n    // requires). This enables us to speed up resolution when we build a\n    // dependency graph because we don't have to look at modules that may not\n    // exist and aren't mocked.\n    const resolveNodeModule = (name: string, throwIfNotFound = false) => {\n      // Only skip default resolver\n      if (this.isCoreModule(name) && !this._options.resolver) {\n        return name;\n      }\n\n      return Resolver.findNodeModule(name, {\n        basedir: dirname,\n        conditions: options?.conditions,\n        extensions,\n        moduleDirectory,\n        paths,\n        resolver: this._options.resolver,\n        rootDir: this._options.rootDir,\n        throwIfNotFound,\n      });\n    };\n\n    if (!skipResolution) {\n      module = resolveNodeModule(moduleName, Boolean(process.versions.pnp));\n\n      if (module) {\n        this._moduleNameCache.set(key, module);\n        return module;\n      }\n    }\n\n    // 4. Resolve \"haste packages\" which are `package.json` files outside of\n    // `node_modules` folders anywhere in the file system.\n    try {\n      const hasteModulePath = this._getHasteModulePath(moduleName);\n      if (hasteModulePath) {\n        // try resolving with custom resolver first to support extensions,\n        // then fallback to require.resolve\n        const resolvedModule =\n          resolveNodeModule(hasteModulePath) ||\n          require.resolve(hasteModulePath);\n        this._moduleNameCache.set(key, resolvedModule);\n        return resolvedModule;\n      }\n    } catch {}\n\n    return null;\n  }\n\n  async resolveModuleFromDirIfExistsAsync(\n    dirname: string,\n    moduleName: string,\n    options?: ResolveModuleConfig,\n  ): Promise<string | null> {\n    const {extensions, key, moduleDirectory, paths, skipResolution} =\n      this._prepareForResolution(dirname, moduleName, options);\n\n    let module;\n\n    // 1. If we have already resolved this module for this directory name,\n    // return a value from the cache.\n    const cacheResult = this._moduleNameCache.get(key);\n    if (cacheResult) {\n      return cacheResult;\n    }\n\n    // 2. Check if the module is a haste module.\n    module = this.getModule(moduleName);\n    if (module) {\n      this._moduleNameCache.set(key, module);\n      return module;\n    }\n\n    // 3. Check if the module is a node module and resolve it based on\n    // the node module resolution algorithm. If skipNodeResolution is given we\n    // ignore all modules that look like node modules (ie. are not relative\n    // requires). This enables us to speed up resolution when we build a\n    // dependency graph because we don't have to look at modules that may not\n    // exist and aren't mocked.\n    const resolveNodeModule = async (name: string, throwIfNotFound = false) => {\n      // Only skip default resolver\n      if (this.isCoreModule(name) && !this._options.resolver) {\n        return name;\n      }\n\n      return Resolver.findNodeModuleAsync(name, {\n        basedir: dirname,\n        conditions: options?.conditions,\n        extensions,\n        moduleDirectory,\n        paths,\n        resolver: this._options.resolver,\n        rootDir: this._options.rootDir,\n        throwIfNotFound,\n      });\n    };\n\n    if (!skipResolution) {\n      module = await resolveNodeModule(\n        moduleName,\n        Boolean(process.versions.pnp),\n      );\n\n      if (module) {\n        this._moduleNameCache.set(key, module);\n        return module;\n      }\n    }\n\n    // 4. Resolve \"haste packages\" which are `package.json` files outside of\n    // `node_modules` folders anywhere in the file system.\n    try {\n      const hasteModulePath = this._getHasteModulePath(moduleName);\n      if (hasteModulePath) {\n        // try resolving with custom resolver first to support extensions,\n        // then fallback to require.resolve\n        const resolvedModule =\n          (await resolveNodeModule(hasteModulePath)) ||\n          // QUESTION: should this be async?\n          require.resolve(hasteModulePath);\n        this._moduleNameCache.set(key, resolvedModule);\n        return resolvedModule;\n      }\n    } catch {}\n\n    return null;\n  }\n\n  resolveModule(\n    from: string,\n    moduleName: string,\n    options?: ResolveModuleConfig,\n  ): string {\n    const dirname = path.dirname(from);\n    const module =\n      this.resolveStubModuleName(from, moduleName, options) ||\n      this.resolveModuleFromDirIfExists(dirname, moduleName, options);\n    if (module) return module;\n\n    // 5. Throw an error if the module could not be found. `resolve.sync` only\n    // produces an error based on the dirname but we have the actual current\n    // module name available.\n    this._throwModNotFoundError(from, moduleName);\n  }\n\n  async resolveModuleAsync(\n    from: string,\n    moduleName: string,\n    options?: ResolveModuleConfig,\n  ): Promise<string> {\n    const dirname = path.dirname(from);\n    const module =\n      (await this.resolveStubModuleNameAsync(from, moduleName, options)) ||\n      (await this.resolveModuleFromDirIfExistsAsync(\n        dirname,\n        moduleName,\n        options,\n      ));\n\n    if (module) return module;\n\n    // 5. Throw an error if the module could not be found. `resolve` only\n    // produces an error based on the dirname but we have the actual current\n    // module name available.\n    this._throwModNotFoundError(from, moduleName);\n  }\n\n  /**\n   * _prepareForResolution is shared between the sync and async module resolution\n   * methods, to try to keep them as DRY as possible.\n   */\n  private _prepareForResolution(\n    dirname: string,\n    moduleName: string,\n    options?: ResolveModuleConfig,\n  ) {\n    const paths = options?.paths || this._options.modulePaths;\n    const moduleDirectory = this._options.moduleDirectories;\n    const stringifiedOptions = options ? JSON.stringify(options) : '';\n    const key = dirname + path.delimiter + moduleName + stringifiedOptions;\n    const defaultPlatform = this._options.defaultPlatform;\n    const extensions = [...this._options.extensions];\n\n    if (this._supportsNativePlatform) {\n      extensions.unshift(\n        ...this._options.extensions.map(ext => `.${NATIVE_PLATFORM}${ext}`),\n      );\n    }\n    if (defaultPlatform) {\n      extensions.unshift(\n        ...this._options.extensions.map(ext => `.${defaultPlatform}${ext}`),\n      );\n    }\n\n    const skipResolution =\n      options && options.skipNodeResolution && !moduleName.includes(path.sep);\n\n    return {extensions, key, moduleDirectory, paths, skipResolution};\n  }\n\n  /**\n   * _getHasteModulePath attempts to return the path to a haste module.\n   */\n  private _getHasteModulePath(moduleName: string) {\n    const parts = moduleName.split('/');\n    const hastePackage = this.getPackage(parts.shift()!);\n    if (hastePackage) {\n      return path.join(path.dirname(hastePackage), ...parts);\n    }\n    return null;\n  }\n\n  private _throwModNotFoundError(from: string, moduleName: string): never {\n    const relativePath =\n      slash(path.relative(this._options.rootDir, from)) || '.';\n\n    throw new ModuleNotFoundError(\n      `Cannot find module '${moduleName}' from '${relativePath}'`,\n      moduleName,\n    );\n  }\n\n  private _getMapModuleName(matches: RegExpMatchArray | null) {\n    return matches\n      ? (moduleName: string) =>\n          moduleName.replaceAll(\n            /\\$(\\d+)/g,\n            (_, index) => matches[Number.parseInt(index, 10)] || '',\n          )\n      : (moduleName: string) => moduleName;\n  }\n\n  private _isAliasModule(moduleName: string): boolean {\n    const moduleNameMapper = this._options.moduleNameMapper;\n    if (!moduleNameMapper) {\n      return false;\n    }\n\n    return moduleNameMapper.some(({regex}) => regex.test(moduleName));\n  }\n\n  isCoreModule(moduleName: string): boolean {\n    return (\n      this._options.hasCoreModules &&\n      isBuiltin(moduleName) &&\n      !this._isAliasModule(moduleName)\n    );\n  }\n\n  normalizeCoreModuleSpecifier(specifier: string): string {\n    return specifier.startsWith('node:')\n      ? specifier.slice('node:'.length)\n      : specifier;\n  }\n\n  getModule(name: string): string | null {\n    return this._moduleMap.getModule(\n      name,\n      this._options.defaultPlatform,\n      this._supportsNativePlatform,\n    );\n  }\n\n  getModulePath(from: string, moduleName: string): string {\n    if (moduleName[0] !== '.' || path.isAbsolute(moduleName)) {\n      return moduleName;\n    }\n    return path.normalize(`${path.dirname(from)}/${moduleName}`);\n  }\n\n  getPackage(name: string): string | null {\n    return this._moduleMap.getPackage(\n      name,\n      this._options.defaultPlatform,\n      this._supportsNativePlatform,\n    );\n  }\n\n  getMockModule(\n    from: string,\n    name: string,\n    options?: Pick<ResolveModuleConfig, 'conditions'>,\n  ): string | null {\n    const mock = this._moduleMap.getMockModule(name);\n    if (mock) {\n      return mock;\n    } else {\n      const resolvedName = this.resolveStubModuleName(from, name, options);\n      if (resolvedName) {\n        return this._moduleMap.getMockModule(resolvedName) ?? null;\n      }\n    }\n    return null;\n  }\n\n  async getMockModuleAsync(\n    from: string,\n    name: string,\n    options: Pick<ResolveModuleConfig, 'conditions'>,\n  ): Promise<string | null> {\n    const mock = this._moduleMap.getMockModule(name);\n    if (mock) {\n      return mock;\n    } else {\n      const resolvedName = await this.resolveStubModuleNameAsync(\n        from,\n        name,\n        options,\n      );\n      if (resolvedName) {\n        return this._moduleMap.getMockModule(resolvedName) ?? null;\n      }\n    }\n    return null;\n  }\n\n  getModulePaths(from: string): Array<string> {\n    const cachedModule = this._modulePathCache.get(from);\n    if (cachedModule) {\n      return cachedModule;\n    }\n\n    const moduleDirectory = this._options.moduleDirectories;\n    const paths = nodeModulesPaths(from, {moduleDirectory});\n    if (paths.at(-1) === undefined) {\n      // circumvent node-resolve bug that adds `undefined` as last item.\n      paths.pop();\n    }\n    this._modulePathCache.set(from, paths);\n    return paths;\n  }\n\n  getGlobalPaths(moduleName?: string): Array<string> {\n    if (!moduleName || moduleName[0] === '.' || this.isCoreModule(moduleName)) {\n      return [];\n    }\n\n    return GlobalPaths;\n  }\n\n  getModuleID(\n    virtualMocks: Map<string, boolean>,\n    from: string,\n    moduleName = '',\n    options: ResolveModuleConfig,\n  ): string {\n    const stringifiedOptions = options ? JSON.stringify(options) : '';\n    const key = from + path.delimiter + moduleName + stringifiedOptions;\n    const cachedModuleID = this._moduleIDCache.get(key);\n    if (cachedModuleID) {\n      return cachedModuleID;\n    }\n\n    const moduleType = this._getModuleType(moduleName);\n    const absolutePath = this._getAbsolutePath(\n      virtualMocks,\n      from,\n      moduleName,\n      options,\n    );\n    const mockPath = this._getMockPath(from, moduleName, options);\n\n    const sep = path.delimiter;\n    const id =\n      moduleType +\n      sep +\n      (absolutePath ? absolutePath + sep : '') +\n      (mockPath ? mockPath + sep : '') +\n      (stringifiedOptions ? stringifiedOptions + sep : '');\n\n    this._moduleIDCache.set(key, id);\n    return id;\n  }\n\n  async getModuleIDAsync(\n    virtualMocks: Map<string, boolean>,\n    from: string,\n    moduleName = '',\n    options: ResolveModuleConfig,\n  ): Promise<string> {\n    const stringifiedOptions = options ? JSON.stringify(options) : '';\n    const key = from + path.delimiter + moduleName + stringifiedOptions;\n    const cachedModuleID = this._moduleIDCache.get(key);\n    if (cachedModuleID) {\n      return cachedModuleID;\n    }\n    if (moduleName.startsWith('data:')) {\n      return moduleName;\n    }\n\n    const moduleType = this._getModuleType(moduleName);\n    const absolutePath = await this._getAbsolutePathAsync(\n      virtualMocks,\n      from,\n      moduleName,\n      options,\n    );\n    const mockPath = await this._getMockPathAsync(from, moduleName, options);\n\n    const sep = path.delimiter;\n    const id =\n      moduleType +\n      sep +\n      (absolutePath ? absolutePath + sep : '') +\n      (mockPath ? mockPath + sep : '') +\n      (stringifiedOptions ? stringifiedOptions + sep : '');\n\n    this._moduleIDCache.set(key, id);\n    return id;\n  }\n\n  private _getModuleType(moduleName: string): 'node' | 'user' {\n    return this.isCoreModule(moduleName) ? 'node' : 'user';\n  }\n\n  private _getAbsolutePath(\n    virtualMocks: Map<string, boolean>,\n    from: string,\n    moduleName: string,\n    options: ResolveModuleConfig,\n  ): string | null {\n    if (this.isCoreModule(moduleName)) {\n      return this.normalizeCoreModuleSpecifier(moduleName);\n    }\n    if (moduleName.startsWith('data:')) {\n      return moduleName;\n    }\n    return this._isModuleResolved(from, moduleName, options)\n      ? this.getModule(moduleName)\n      : this._getVirtualMockPath(virtualMocks, from, moduleName, options);\n  }\n\n  private async _getAbsolutePathAsync(\n    virtualMocks: Map<string, boolean>,\n    from: string,\n    moduleName: string,\n    options: ResolveModuleConfig,\n  ): Promise<string | null> {\n    if (this.isCoreModule(moduleName)) {\n      return moduleName;\n    }\n    if (moduleName.startsWith('data:')) {\n      return moduleName;\n    }\n    const isModuleResolved = await this._isModuleResolvedAsync(\n      from,\n      moduleName,\n      options,\n    );\n    return isModuleResolved\n      ? this.getModule(moduleName)\n      : this._getVirtualMockPathAsync(virtualMocks, from, moduleName, options);\n  }\n\n  private _getMockPath(\n    from: string,\n    moduleName: string,\n    options: Pick<ResolveModuleConfig, 'conditions'>,\n  ): string | null {\n    return this.isCoreModule(moduleName)\n      ? null\n      : this.getMockModule(from, moduleName, options);\n  }\n\n  private async _getMockPathAsync(\n    from: string,\n    moduleName: string,\n    options: Pick<ResolveModuleConfig, 'conditions'>,\n  ): Promise<string | null> {\n    return this.isCoreModule(moduleName)\n      ? null\n      : this.getMockModuleAsync(from, moduleName, options);\n  }\n\n  private _getVirtualMockPath(\n    virtualMocks: Map<string, boolean>,\n    from: string,\n    moduleName: string,\n    options: ResolveModuleConfig,\n  ): string {\n    const virtualMockPath = this.getModulePath(from, moduleName);\n    return virtualMocks.get(virtualMockPath)\n      ? virtualMockPath\n      : moduleName\n        ? this.resolveModule(from, moduleName, options)\n        : from;\n  }\n\n  private async _getVirtualMockPathAsync(\n    virtualMocks: Map<string, boolean>,\n    from: string,\n    moduleName: string,\n    options?: ResolveModuleConfig,\n  ): Promise<string> {\n    const virtualMockPath = this.getModulePath(from, moduleName);\n    return virtualMocks.get(virtualMockPath)\n      ? virtualMockPath\n      : moduleName\n        ? this.resolveModuleAsync(from, moduleName, options)\n        : from;\n  }\n\n  private _isModuleResolved(\n    from: string,\n    moduleName: string,\n    options: Pick<ResolveModuleConfig, 'conditions'>,\n  ): boolean {\n    return !!(\n      this.getModule(moduleName) ||\n      this.getMockModule(from, moduleName, options)\n    );\n  }\n\n  private async _isModuleResolvedAsync(\n    from: string,\n    moduleName: string,\n    options: Pick<ResolveModuleConfig, 'conditions'>,\n  ): Promise<boolean> {\n    return !!(\n      this.getModule(moduleName) ||\n      (await this.getMockModuleAsync(from, moduleName, options))\n    );\n  }\n\n  resolveStubModuleName(\n    from: string,\n    moduleName: string,\n    options?: Pick<ResolveModuleConfig, 'conditions'>,\n  ): string | null {\n    const dirname = path.dirname(from);\n\n    const {extensions, moduleDirectory, paths} = this._prepareForResolution(\n      dirname,\n      moduleName,\n    );\n    const moduleNameMapper = this._options.moduleNameMapper;\n    const resolver = this._options.resolver;\n\n    if (moduleNameMapper) {\n      for (const {moduleName: mappedModuleName, regex} of moduleNameMapper) {\n        if (regex.test(moduleName)) {\n          // Note: once a moduleNameMapper matches the name, it must result\n          // in a module, or else an error is thrown.\n          const matches = moduleName.match(regex);\n          const mapModuleName = this._getMapModuleName(matches);\n          const possibleModuleNames = Array.isArray(mappedModuleName)\n            ? mappedModuleName\n            : [mappedModuleName];\n          let module: string | null = null;\n          for (const possibleModuleName of possibleModuleNames) {\n            const updatedName = mapModuleName(possibleModuleName);\n            module =\n              this.getModule(updatedName) ||\n              Resolver.findNodeModule(updatedName, {\n                basedir: dirname,\n                conditions: options?.conditions,\n                extensions,\n                moduleDirectory,\n                paths,\n                resolver,\n                rootDir: this._options.rootDir,\n              });\n\n            if (module) {\n              break;\n            }\n          }\n\n          if (!module) {\n            throw createNoMappedModuleFoundError(\n              moduleName,\n              mapModuleName,\n              mappedModuleName,\n              regex,\n              resolver,\n            );\n          }\n          return module;\n        }\n      }\n    }\n    return null;\n  }\n\n  async resolveStubModuleNameAsync(\n    from: string,\n    moduleName: string,\n    options?: Pick<ResolveModuleConfig, 'conditions'>,\n  ): Promise<string | null> {\n    // Strip node URL scheme from core modules imported using it\n    if (this.isCoreModule(moduleName)) {\n      return this.normalizeCoreModuleSpecifier(moduleName);\n    }\n\n    const dirname = path.dirname(from);\n\n    const {extensions, moduleDirectory, paths} = this._prepareForResolution(\n      dirname,\n      moduleName,\n    );\n    const moduleNameMapper = this._options.moduleNameMapper;\n    const resolver = this._options.resolver;\n\n    if (moduleNameMapper) {\n      for (const {moduleName: mappedModuleName, regex} of moduleNameMapper) {\n        if (regex.test(moduleName)) {\n          // Note: once a moduleNameMapper matches the name, it must result\n          // in a module, or else an error is thrown.\n          const matches = moduleName.match(regex);\n          const mapModuleName = this._getMapModuleName(matches);\n          const possibleModuleNames = Array.isArray(mappedModuleName)\n            ? mappedModuleName\n            : [mappedModuleName];\n          let module: string | null = null;\n          for (const possibleModuleName of possibleModuleNames) {\n            const updatedName = mapModuleName(possibleModuleName);\n\n            module =\n              this.getModule(updatedName) ||\n              (await Resolver.findNodeModuleAsync(updatedName, {\n                basedir: dirname,\n                conditions: options?.conditions,\n                extensions,\n                moduleDirectory,\n                paths,\n                resolver,\n                rootDir: this._options.rootDir,\n              }));\n\n            if (module) {\n              break;\n            }\n          }\n\n          if (!module) {\n            throw createNoMappedModuleFoundError(\n              moduleName,\n              mapModuleName,\n              mappedModuleName,\n              regex,\n              resolver,\n            );\n          }\n          return module;\n        }\n      }\n    }\n    return null;\n  }\n}\n\nconst createNoMappedModuleFoundError = (\n  moduleName: string,\n  mapModuleName: (moduleName: string) => string,\n  mappedModuleName: string | Array<string>,\n  regex: RegExp,\n  resolver?: ((...args: Array<unknown>) => unknown) | string | null,\n) => {\n  const mappedAs = Array.isArray(mappedModuleName)\n    ? JSON.stringify(mappedModuleName.map(mapModuleName), null, 2)\n    : mappedModuleName;\n  const original = Array.isArray(mappedModuleName)\n    ? `${\n        JSON.stringify(mappedModuleName, null, 6) // using 6 because of misalignment when nested below\n          .slice(0, -1) + ' '.repeat(4)\n      }]` /// align last bracket correctly as well\n    : mappedModuleName;\n\n  const error = new Error(\n    chalk.red(`${chalk.bold('Configuration error')}:\n\nCould not locate module ${chalk.bold(moduleName)} mapped as:\n${chalk.bold(mappedAs)}.\n\nPlease check your configuration for these entries:\n{\n  \"moduleNameMapper\": {\n    \"${regex.toString()}\": \"${chalk.bold(original)}\"\n  },\n  \"resolver\": ${chalk.bold(String(resolver))}\n}`),\n  );\n\n  error.name = '';\n\n  return error;\n};\n\ntype ResolverSyncObject = {sync: SyncResolver; async?: AsyncResolver};\ntype ResolverAsyncObject = {sync?: SyncResolver; async: AsyncResolver};\nexport type ResolverObject = ResolverSyncObject | ResolverAsyncObject;\n\nfunction loadResolver(\n  resolver: string | undefined | null,\n): SyncResolver | ResolverObject {\n  if (resolver == null) {\n    return defaultResolver;\n  }\n\n  const loadedResolver = require(resolver);\n\n  if (loadedResolver == null) {\n    throw new Error(`Resolver located at ${resolver} does not export anything`);\n  }\n\n  if (typeof loadedResolver === 'function') {\n    return loadedResolver as SyncResolver;\n  }\n\n  if (\n    typeof loadedResolver === 'object' &&\n    (loadedResolver.sync != null || loadedResolver.async != null)\n  ) {\n    return loadedResolver as ResolverObject;\n  }\n\n  throw new Error(\n    `Resolver located at ${resolver} does not export a function or an object with \"sync\" and \"async\" props`,\n  );\n}\n",
  "packages/jest-resolve/src/resolver.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { IModuleMap } from 'jest-haste-map';\nimport ModuleNotFoundError from './ModuleNotFoundError';\nimport { type AsyncResolver, type SyncResolver } from './defaultResolver';\nimport shouldLoadAsEsm from './shouldLoadAsEsm';\nimport type { ResolverConfig } from './types';\nexport type FindNodeModuleConfig = {\n    basedir: string;\n    conditions?: Array<string>;\n    extensions?: Array<string>;\n    moduleDirectory?: Array<string>;\n    paths?: Array<string>;\n    resolver?: string | null;\n    rootDir?: string;\n    throwIfNotFound?: boolean;\n};\nexport type ResolveModuleConfig = {\n    conditions?: Array<string>;\n    skipNodeResolution?: boolean;\n    paths?: Array<string>;\n};\nexport default class Resolver {\n    private readonly _options;\n    private readonly _moduleMap;\n    private readonly _moduleIDCache;\n    private readonly _moduleNameCache;\n    private readonly _modulePathCache;\n    private readonly _supportsNativePlatform;\n    constructor(moduleMap: IModuleMap, options: ResolverConfig);\n    static ModuleNotFoundError: typeof ModuleNotFoundError;\n    static tryCastModuleNotFoundError(error: unknown): ModuleNotFoundError | null;\n    static clearDefaultResolverCache(): void;\n    static findNodeModule(path: string, options: FindNodeModuleConfig): string | null;\n    static findNodeModuleAsync(path: string, options: FindNodeModuleConfig): Promise<string | null>;\n    static unstable_shouldLoadAsEsm: typeof shouldLoadAsEsm;\n    resolveModuleFromDirIfExists(dirname: string, moduleName: string, options?: ResolveModuleConfig): string | null;\n    resolveModuleFromDirIfExistsAsync(dirname: string, moduleName: string, options?: ResolveModuleConfig): Promise<string | null>;\n    resolveModule(from: string, moduleName: string, options?: ResolveModuleConfig): string;\n    resolveModuleAsync(from: string, moduleName: string, options?: ResolveModuleConfig): Promise<string>;\n    /**\n     * _prepareForResolution is shared between the sync and async module resolution\n     * methods, to try to keep them as DRY as possible.\n     */\n    private _prepareForResolution;\n    /**\n     * _getHasteModulePath attempts to return the path to a haste module.\n     */\n    private _getHasteModulePath;\n    private _throwModNotFoundError;\n    private _getMapModuleName;\n    private _isAliasModule;\n    isCoreModule(moduleName: string): boolean;\n    normalizeCoreModuleSpecifier(specifier: string): string;\n    getModule(name: string): string | null;\n    getModulePath(from: string, moduleName: string): string;\n    getPackage(name: string): string | null;\n    getMockModule(from: string, name: string, options?: Pick<ResolveModuleConfig, 'conditions'>): string | null;\n    getMockModuleAsync(from: string, name: string, options: Pick<ResolveModuleConfig, 'conditions'>): Promise<string | null>;\n    getModulePaths(from: string): Array<string>;\n    getGlobalPaths(moduleName?: string): Array<string>;\n    getModuleID(virtualMocks: Map<string, boolean>, from: string, moduleName: string | undefined, options: ResolveModuleConfig): string;\n    getModuleIDAsync(virtualMocks: Map<string, boolean>, from: string, moduleName: string | undefined, options: ResolveModuleConfig): Promise<string>;\n    private _getModuleType;\n    private _getAbsolutePath;\n    private _getAbsolutePathAsync;\n    private _getMockPath;\n    private _getMockPathAsync;\n    private _getVirtualMockPath;\n    private _getVirtualMockPathAsync;\n    private _isModuleResolved;\n    private _isModuleResolvedAsync;\n    resolveStubModuleName(from: string, moduleName: string, options?: Pick<ResolveModuleConfig, 'conditions'>): string | null;\n    resolveStubModuleNameAsync(from: string, moduleName: string, options?: Pick<ResolveModuleConfig, 'conditions'>): Promise<string | null>;\n}\ntype ResolverSyncObject = {\n    sync: SyncResolver;\n    async?: AsyncResolver;\n};\ntype ResolverAsyncObject = {\n    sync?: SyncResolver;\n    async: AsyncResolver;\n};\nexport type ResolverObject = ResolverSyncObject | ResolverAsyncObject;\nexport {};\n",
  "packages/jest-resolve/src/nodeModulesPaths.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * Adapted from: https://github.com/substack/node-resolve\n */\n\nimport * as path from 'path';\nimport {tryRealpath} from 'jest-util';\n\ntype NodeModulesPathsOptions = {\n  moduleDirectory?: Array<string>;\n  paths?: Array<string>;\n};\n\nexport default function nodeModulesPaths(\n  basedir: string,\n  options: NodeModulesPathsOptions,\n): Array<string> {\n  const modules =\n    options && options.moduleDirectory\n      ? [...options.moduleDirectory]\n      : ['node_modules'];\n\n  // ensure that `basedir` is an absolute path at this point,\n  // resolving against the process' current working directory\n  const basedirAbs = path.resolve(basedir);\n\n  let prefix = '/';\n  if (/^([A-Za-z]:)/.test(basedirAbs)) {\n    prefix = '';\n  } else if (/^\\\\\\\\/.test(basedirAbs)) {\n    prefix = '\\\\\\\\';\n  }\n\n  // The node resolution algorithm (as implemented by NodeJS and TypeScript)\n  // traverses parents of the physical path, not the symlinked path\n  let physicalBasedir;\n  try {\n    physicalBasedir = tryRealpath(basedirAbs);\n  } catch {\n    // realpath can throw, e.g. on mapped drives\n    physicalBasedir = basedirAbs;\n  }\n\n  const paths: Array<string> = [physicalBasedir];\n  let parsed = path.parse(physicalBasedir);\n  while (parsed.dir !== paths.at(-1)) {\n    paths.push(parsed.dir);\n    parsed = path.parse(parsed.dir);\n  }\n\n  const dirs = paths.reduce<Array<string>>((dirs, aPath) => {\n    for (const moduleDir of modules) {\n      if (path.isAbsolute(moduleDir)) {\n        if (aPath === basedirAbs && moduleDir) {\n          dirs.push(moduleDir);\n        }\n      } else {\n        dirs.push(path.join(prefix, aPath, moduleDir));\n      }\n    }\n\n    return dirs;\n  }, []);\n\n  if (options.paths) {\n    dirs.push(...options.paths);\n  }\n\n  return dirs;\n}\n\nfunction findGlobalPaths(): Array<string> {\n  const {root} = path.parse(process.cwd());\n  const globalPath = path.join(root, 'node_modules');\n  const resolvePaths = require.resolve.paths('/');\n\n  if (resolvePaths) {\n    // the global paths start one after the root node_modules\n    const rootIndex = resolvePaths.indexOf(globalPath);\n    return rootIndex === -1 ? [] : resolvePaths.slice(rootIndex + 1);\n  }\n  return [];\n}\nexport const GlobalPaths = findGlobalPaths();\n",
  "packages/jest-resolve/src/nodeModulesPaths.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * Adapted from: https://github.com/substack/node-resolve\n */\ntype NodeModulesPathsOptions = {\n    moduleDirectory?: Array<string>;\n    paths?: Array<string>;\n};\nexport default function nodeModulesPaths(basedir: string, options: NodeModulesPathsOptions): Array<string>;\nexport declare const GlobalPaths: string[];\nexport {};\n",
  "packages/jest-resolve/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport Resolver from './resolver';\n\nexport type {\n  AsyncResolver,\n  SyncResolver,\n  ResolverOptions,\n} from './defaultResolver';\nexport type {\n  FindNodeModuleConfig,\n  ResolveModuleConfig,\n  ResolverObject as JestResolver,\n} from './resolver';\nexport type {PackageJSON} from './types';\nexport * from './utils';\n\nexport default Resolver;\n",
  "packages/jest-resolve/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport Resolver from './resolver';\nexport type { AsyncResolver, SyncResolver, ResolverOptions, } from './defaultResolver';\nexport type { FindNodeModuleConfig, ResolveModuleConfig, ResolverObject as JestResolver, } from './resolver';\nexport type { PackageJSON } from './types';\nexport * from './utils';\nexport default Resolver;\n",
  "packages/jest-resolve/src/fileWalkers.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {dirname, resolve} from 'path';\nimport * as fs from 'graceful-fs';\nimport type {ResolverFactory} from 'unrs-resolver';\nimport {tryRealpath} from 'jest-util';\nimport type {PackageJSON} from './types';\n\nlet unrsResolver: ResolverFactory | undefined;\n\nexport function getResolver(): ResolverFactory | undefined {\n  return unrsResolver;\n}\n\nexport function setResolver(nextResolver: ResolverFactory): void {\n  unrsResolver = nextResolver;\n}\n\nexport function clearFsCache(): void {\n  unrsResolver?.clearCache();\n  checkedPaths.clear();\n  checkedRealpathPaths.clear();\n  packageContents.clear();\n}\n\nenum IPathType {\n  FILE = 1,\n  DIRECTORY = 2,\n  OTHER = 3,\n}\nconst checkedPaths = new Map<string, IPathType>();\nfunction statSyncCached(path: string): IPathType {\n  const result = checkedPaths.get(path);\n  if (result != null) {\n    return result;\n  }\n\n  let stat;\n  try {\n    stat = fs.statSync(path, {throwIfNoEntry: false});\n  } catch (error: any) {\n    if (!(error && (error.code === 'ENOENT' || error.code === 'ENOTDIR'))) {\n      throw error;\n    }\n  }\n\n  if (stat) {\n    if (stat.isFile() || stat.isFIFO()) {\n      checkedPaths.set(path, IPathType.FILE);\n      return IPathType.FILE;\n    } else if (stat.isDirectory()) {\n      checkedPaths.set(path, IPathType.DIRECTORY);\n      return IPathType.DIRECTORY;\n    }\n  }\n\n  checkedPaths.set(path, IPathType.OTHER);\n  return IPathType.OTHER;\n}\n\nconst checkedRealpathPaths = new Map<string, string>();\nfunction realpathCached(path: string): string {\n  let result = checkedRealpathPaths.get(path);\n\n  if (result != null) {\n    return result;\n  }\n\n  result = tryRealpath(path);\n\n  checkedRealpathPaths.set(path, result);\n\n  if (path !== result) {\n    // also cache the result in case it's ever referenced directly - no reason to `realpath` that as well\n    checkedRealpathPaths.set(result, result);\n  }\n\n  return result;\n}\n\nconst packageContents = new Map<string, PackageJSON>();\nexport function readPackageCached(path: string): PackageJSON {\n  let result = packageContents.get(path);\n\n  if (result != null) {\n    return result;\n  }\n\n  result = JSON.parse(fs.readFileSync(path, 'utf8')) as PackageJSON;\n\n  packageContents.set(path, result);\n\n  return result;\n}\n\n// adapted from\n// https://github.com/lukeed/escalade/blob/2477005062cdbd8407afc90d3f48f4930354252b/src/sync.js\n// to use cached `fs` calls\nexport function findClosestPackageJson(start: string): string | undefined {\n  let dir = resolve('.', start);\n  if (!isDirectory(dir)) {\n    dir = dirname(dir);\n  }\n\n  while (true) {\n    const pkgJsonFile = resolve(dir, './package.json');\n    const hasPackageJson = isFile(pkgJsonFile);\n\n    if (hasPackageJson) {\n      return pkgJsonFile;\n    }\n\n    const prevDir = dir;\n    dir = dirname(dir);\n\n    if (prevDir === dir) {\n      return undefined;\n    }\n  }\n}\n\n/*\n * helper functions\n */\nexport function isFile(file: string): boolean {\n  return statSyncCached(file) === IPathType.FILE;\n}\n\nexport function isDirectory(dir: string): boolean {\n  return statSyncCached(dir) === IPathType.DIRECTORY;\n}\n\nexport function realpathSync(file: string): string {\n  return realpathCached(file);\n}\n",
  "packages/jest-resolve/src/fileWalkers.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { ResolverFactory } from 'unrs-resolver';\nimport type { PackageJSON } from './types';\nexport declare function getResolver(): ResolverFactory | undefined;\nexport declare function setResolver(nextResolver: ResolverFactory): void;\nexport declare function clearFsCache(): void;\nexport declare function readPackageCached(path: string): PackageJSON;\nexport declare function findClosestPackageJson(start: string): string | undefined;\nexport declare function isFile(file: string): boolean;\nexport declare function isDirectory(dir: string): boolean;\nexport declare function realpathSync(file: string): string;\n",
  "packages/jest-resolve/src/defaultResolver.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {isBuiltin} from 'module';\nimport {fileURLToPath} from 'url';\nimport pnpResolver from 'jest-pnp-resolver';\nimport {\n  type ResolveResult,\n  ResolverFactory,\n  type NapiResolveOptions as UpstreamResolveOptions,\n} from 'unrs-resolver';\nimport {getResolver, setResolver} from './fileWalkers';\n\nexport interface ResolverOptions extends UpstreamResolveOptions {\n  /** Directory to begin resolving from. */\n  basedir: string;\n  /** List of export conditions. */\n  conditions?: Array<string>;\n  /** Instance of default resolver. */\n  defaultResolver: SyncResolver;\n  /** Instance of default async resolver. */\n  defaultAsyncResolver: AsyncResolver;\n  /**\n   * List of directory names to be looked up for modules recursively.\n   *\n   * @defaultValue\n   * The default is `['node_modules']`.\n   */\n  moduleDirectory?: Array<string>;\n  /**\n   * List of `require.paths` to use if nothing is found in `node_modules`.\n   *\n   * @defaultValue\n   * The default is `undefined`.\n   */\n  paths?: Array<string>;\n  /** Current root directory. */\n  rootDir?: string;\n\n  /**\n   * @internal Whether to allow the `jest-pnp-resolver` to be used.\n   * @see https://github.com/arcanis/jest-pnp-resolver/blob/ae8e3992349f3b43d1476572e9315e14358e8944/index.js#L49\n   */\n  allowPnp?: boolean;\n}\n\nexport type SyncResolver = (path: string, options: ResolverOptions) => string;\nexport type AsyncResolver = (\n  path: string,\n  options: ResolverOptions,\n) => Promise<string>;\n\nexport type Resolver = SyncResolver | AsyncResolver;\n\nconst handleResolveResult = (result: ResolveResult) => {\n  if (result.error) {\n    throw new Error(result.error);\n  }\n  return result.path!;\n};\n\nfunction baseResolver(path: string, options: ResolverOptions): string;\nfunction baseResolver(\n  path: string,\n  options: ResolverOptions,\n  async: true,\n): Promise<string>;\nfunction baseResolver(\n  path: string,\n  options: ResolverOptions,\n  async?: true,\n): string | Promise<string> {\n  // https://github.com/oxc-project/oxc-resolver/issues/565\n  // https://github.com/jestjs/jest/issues/15676\n  if (isBuiltin(path)) {\n    return path;\n  }\n\n  if (process.versions.pnp && options.allowPnp !== false) {\n    return pnpResolver(path, options);\n  }\n\n  if (path.startsWith('file://')) {\n    path = fileURLToPath(path);\n  }\n\n  /* eslint-disable prefer-const */\n  let {\n    basedir,\n    conditions,\n    conditionNames,\n    modules,\n    moduleDirectory,\n    paths,\n    roots,\n    rootDir,\n    ...rest\n    /* eslint-enable prefer-const */\n  } = options;\n\n  modules = modules || moduleDirectory;\n\n  const resolveOptions: UpstreamResolveOptions = {\n    conditionNames: conditionNames ||\n      conditions || ['require', 'node', 'default'],\n    modules,\n    roots: roots || (rootDir ? [rootDir] : undefined),\n    ...rest,\n  };\n\n  let unrsResolver = getResolver();\n\n  if (unrsResolver) {\n    unrsResolver = unrsResolver.cloneWithOptions(resolveOptions);\n  } else {\n    unrsResolver = new ResolverFactory(resolveOptions);\n  }\n\n  setResolver(unrsResolver);\n\n  const finalResolver = (\n    resolve: () => ResolveResult | Promise<ResolveResult>,\n  ) => {\n    const resolveWithPathsFallback = (result: ResolveResult) => {\n      if (!result.path && paths?.length) {\n        const modulesArr =\n          modules == null || Array.isArray(modules) ? modules : [modules];\n        if (modulesArr?.length) {\n          paths = paths.filter(p => !modulesArr.includes(p));\n        }\n        if (paths.length > 0) {\n          unrsResolver = unrsResolver!.cloneWithOptions({\n            ...resolveOptions,\n            modules: paths,\n          });\n          setResolver(unrsResolver);\n          return resolve();\n        }\n      }\n      return result;\n    };\n    const result = resolve();\n    if ('then' in result) {\n      return result.then(resolveWithPathsFallback).then(handleResolveResult);\n    }\n    return handleResolveResult(\n      resolveWithPathsFallback(result) as ResolveResult,\n    );\n  };\n\n  return finalResolver(() =>\n    async\n      ? unrsResolver!.async(basedir, path)\n      : unrsResolver!.sync(basedir, path),\n  );\n}\n\nexport const defaultResolver: SyncResolver = baseResolver;\n\nexport const defaultAsyncResolver: AsyncResolver = (\n  path: string,\n  options: ResolverOptions,\n) => baseResolver(path, options, true);\n\nexport default defaultResolver;\n",
  "packages/jest-resolve/src/defaultResolver.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { type NapiResolveOptions as UpstreamResolveOptions } from 'unrs-resolver';\nexport interface ResolverOptions extends UpstreamResolveOptions {\n    /** Directory to begin resolving from. */\n    basedir: string;\n    /** List of export conditions. */\n    conditions?: Array<string>;\n    /** Instance of default resolver. */\n    defaultResolver: SyncResolver;\n    /** Instance of default async resolver. */\n    defaultAsyncResolver: AsyncResolver;\n    /**\n     * List of directory names to be looked up for modules recursively.\n     *\n     * @defaultValue\n     * The default is `['node_modules']`.\n     */\n    moduleDirectory?: Array<string>;\n    /**\n     * List of `require.paths` to use if nothing is found in `node_modules`.\n     *\n     * @defaultValue\n     * The default is `undefined`.\n     */\n    paths?: Array<string>;\n    /** Current root directory. */\n    rootDir?: string;\n}\nexport type SyncResolver = (path: string, options: ResolverOptions) => string;\nexport type AsyncResolver = (path: string, options: ResolverOptions) => Promise<string>;\nexport type Resolver = SyncResolver | AsyncResolver;\nexport declare const defaultResolver: SyncResolver;\nexport declare const defaultAsyncResolver: AsyncResolver;\nexport default defaultResolver;\n",
  "packages/jest-resolve/src/ModuleNotFoundError.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport slash from 'slash';\n\nexport default class ModuleNotFoundError extends Error {\n  public code = 'MODULE_NOT_FOUND';\n  public hint?: string;\n  public requireStack?: Array<string>;\n  public siblingWithSimilarExtensionFound?: boolean;\n  public moduleName?: string;\n\n  private _originalMessage?: string;\n\n  constructor(message: string, moduleName?: string) {\n    super(message);\n    this._originalMessage = message;\n    this.moduleName = moduleName;\n  }\n\n  public buildMessage(rootDir: string): void {\n    if (!this._originalMessage) {\n      this._originalMessage = this.message || '';\n    }\n\n    let message = this._originalMessage;\n\n    if (this.requireStack?.length && this.requireStack.length > 1) {\n      message += `\n\nRequire stack:\n  ${this.requireStack\n    .map(p => p.replace(`${rootDir}${path.sep}`, ''))\n    .map(slash)\n    .join('\\n  ')}\n`;\n    }\n\n    if (this.hint) {\n      message += this.hint;\n    }\n\n    this.message = message;\n  }\n\n  public static duckType(error: ModuleNotFoundError): ModuleNotFoundError {\n    error.buildMessage = ModuleNotFoundError.prototype.buildMessage;\n    return error;\n  }\n}\n",
  "packages/jest-resolve/src/ModuleNotFoundError.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport default class ModuleNotFoundError extends Error {\n    code: string;\n    hint?: string;\n    requireStack?: Array<string>;\n    siblingWithSimilarExtensionFound?: boolean;\n    moduleName?: string;\n    private _originalMessage?;\n    constructor(message: string, moduleName?: string);\n    buildMessage(rootDir: string): void;\n    static duckType(error: ModuleNotFoundError): ModuleNotFoundError;\n}\n",
  "packages/jest-resolve/src/__tests__/resolve.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport * as fs from 'graceful-fs';\nimport {type IModuleMap, ModuleMap} from 'jest-haste-map';\nimport * as path from 'path';\nimport {pathToFileURL} from 'url';\n\nimport userResolver from '../__mocks__/userResolver';\nimport userResolverAsync from '../__mocks__/userResolverAsync';\nimport defaultResolver, {defaultAsyncResolver} from '../defaultResolver';\nimport nodeModulesPaths from '../nodeModulesPaths';\nimport Resolver from '../resolver';\nimport type {ResolverConfig} from '../types';\n\njest.mock('../__mocks__/userResolver').mock('../__mocks__/userResolverAsync');\n\nconst mockUserResolver = jest.mocked(userResolver);\nconst mockUserResolverAsync = jest.mocked(userResolverAsync);\n\nbeforeEach(() => {\n  mockUserResolver.mockClear();\n  mockUserResolverAsync.async.mockClear();\n\n  Resolver.clearDefaultResolverCache();\n});\n\ndescribe('isCoreModule', () => {\n  it('returns false if `hasCoreModules` is false.', () => {\n    const moduleMap = ModuleMap.create('/');\n    const resolver = new Resolver(moduleMap, {\n      hasCoreModules: false,\n    } as ResolverConfig);\n    const isCore = resolver.isCoreModule('assert');\n    expect(isCore).toBe(false);\n  });\n\n  it('returns true if `hasCoreModules` is true and `moduleName` is a core module.', () => {\n    const moduleMap = ModuleMap.create('/');\n    const resolver = new Resolver(moduleMap, {} as ResolverConfig);\n    const isCore = resolver.isCoreModule('assert');\n    expect(isCore).toBe(true);\n  });\n\n  it('returns false if `hasCoreModules` is true and `moduleName` is not a core module.', () => {\n    const moduleMap = ModuleMap.create('/');\n    const resolver = new Resolver(moduleMap, {} as ResolverConfig);\n    const isCore = resolver.isCoreModule('not-a-core-module');\n    expect(isCore).toBe(false);\n  });\n\n  it('returns false if `hasCoreModules` is true and `moduleNameMapper` alias a module same name with core module', () => {\n    const moduleMap = ModuleMap.create('/');\n    const resolver = new Resolver(moduleMap, {\n      moduleNameMapper: [\n        {\n          moduleName: '$1',\n          regex: /^constants$/,\n        },\n      ],\n    } as ResolverConfig);\n    const isCore = resolver.isCoreModule('constants');\n    expect(isCore).toBe(false);\n  });\n\n  it('returns true if using `node:` URLs and `moduleName` is a core module.', () => {\n    const moduleMap = ModuleMap.create('/');\n    const resolver = new Resolver(moduleMap, {} as ResolverConfig);\n    const isCore = resolver.isCoreModule('node:assert');\n    expect(isCore).toBe(true);\n  });\n\n  it('returns false if using `node:` URLs and `moduleName` is not a core module.', () => {\n    const moduleMap = ModuleMap.create('/');\n    const resolver = new Resolver(moduleMap, {} as ResolverConfig);\n    const isCore = resolver.isCoreModule('node:not-a-core-module');\n    expect(isCore).toBe(false);\n  });\n});\n\ndescribe('findNodeModule', () => {\n  it('should resolve builtin modules as-is', () => {\n    expect(\n      Resolver.findNodeModule('url', {\n        basedir: __dirname,\n      }),\n    ).toBe('url');\n    expect(\n      Resolver.findNodeModule('node:url', {\n        basedir: __dirname,\n      }),\n    ).toBe('node:url');\n    expect(\n      Resolver.findNodeModule('url/', {\n        basedir: __dirname,\n      }),\n    ).toBe(path.resolve('node_modules/url/url.js'));\n  });\n\n  it('is possible to override the default resolver', () => {\n    const cwd = process.cwd();\n    const resolvedCwd = fs.realpathSync(cwd) || cwd;\n    const nodePaths = process.env.NODE_PATH\n      ? process.env.NODE_PATH.split(path.delimiter)\n          .filter(Boolean)\n          .map(p => path.resolve(resolvedCwd, p))\n      : null;\n\n    mockUserResolver.mockImplementation(() => 'module');\n\n    const newPath = Resolver.findNodeModule('test', {\n      basedir: '/',\n      conditions: ['conditions, woooo'],\n      extensions: ['js'],\n      moduleDirectory: ['node_modules'],\n      paths: ['/something'],\n      resolver: require.resolve('../__mocks__/userResolver'),\n    });\n\n    expect(newPath).toBe('module');\n    expect(mockUserResolver.mock.calls[0][0]).toBe('test');\n    expect(mockUserResolver.mock.calls[0][1]).toStrictEqual({\n      basedir: '/',\n      conditions: ['conditions, woooo'],\n      defaultAsyncResolver,\n      defaultResolver,\n      extensions: ['js'],\n      moduleDirectory: ['node_modules'],\n      paths: [...(nodePaths || []), '/something'],\n      rootDir: undefined,\n    });\n  });\n\n  it('supports file URLs', () => {\n    const path = pathToFileURL(__filename).href;\n    const newPath = Resolver.findNodeModule(path, {\n      basedir: '/',\n    });\n\n    expect(newPath).toBe(__filename);\n  });\n\n  describe('conditions', () => {\n    const conditionsRoot = path.resolve(__dirname, '../__mocks__/conditions');\n\n    test('resolves without exports, just main', () => {\n      const result = Resolver.findNodeModule('main', {\n        basedir: conditionsRoot,\n        conditions: ['require'],\n      });\n\n      expect(result).toEqual(\n        path.resolve(conditionsRoot, './node_modules/main/file.js'),\n      );\n    });\n\n    test('resolves with import', () => {\n      const result = Resolver.findNodeModule('exports', {\n        basedir: conditionsRoot,\n        conditions: ['import'],\n      });\n\n      expect(result).toEqual(\n        path.resolve(conditionsRoot, './node_modules/exports/import.js'),\n      );\n    });\n\n    test('resolves with require', () => {\n      const result = Resolver.findNodeModule('exports', {\n        basedir: conditionsRoot,\n        conditions: ['require'],\n      });\n\n      expect(result).toEqual(\n        path.resolve(conditionsRoot, './node_modules/exports/require.js'),\n      );\n    });\n\n    test('gets default when nothing is passed', () => {\n      const result = Resolver.findNodeModule('exports', {\n        basedir: conditionsRoot,\n        conditions: [],\n      });\n\n      expect(result).toEqual(\n        path.resolve(conditionsRoot, './node_modules/exports/default.js'),\n      );\n    });\n\n    test('respects order in package.json, not conditions', () => {\n      const resultImport = Resolver.findNodeModule('exports', {\n        basedir: conditionsRoot,\n        conditions: ['import', 'require'],\n      });\n      const resultRequire = Resolver.findNodeModule('exports', {\n        basedir: conditionsRoot,\n        conditions: ['require', 'import'],\n      });\n\n      expect(resultImport).toEqual(resultRequire);\n    });\n\n    test('supports nested paths', () => {\n      const result = Resolver.findNodeModule('exports/nested', {\n        basedir: conditionsRoot,\n        conditions: [],\n      });\n\n      expect(result).toEqual(\n        path.resolve(conditionsRoot, './node_modules/exports/nestedDefault.js'),\n      );\n    });\n\n    test('supports nested paths with wildcard and no extension', () => {\n      const result = Resolver.findNodeModule('exports/directory/file', {\n        basedir: conditionsRoot,\n        conditions: [],\n      });\n\n      expect(result).toEqual(\n        path.resolve(\n          conditionsRoot,\n          './node_modules/exports/some-other-directory/file.js',\n        ),\n      );\n    });\n\n    test('supports nested conditions', () => {\n      const resultRequire = Resolver.findNodeModule('exports/deeplyNested', {\n        basedir: conditionsRoot,\n        conditions: ['require'],\n      });\n      const resultDefault = Resolver.findNodeModule('exports/deeplyNested', {\n        basedir: conditionsRoot,\n        conditions: [],\n      });\n\n      expect(resultRequire).toEqual(\n        path.resolve(conditionsRoot, './node_modules/exports/nestedRequire.js'),\n      );\n\n      expect(resultDefault).toEqual(\n        path.resolve(conditionsRoot, './node_modules/exports/nestedDefault.js'),\n      );\n    });\n\n    test('supports separate directory path', () => {\n      const result = Resolver.findNodeModule('exports/directory/file.js', {\n        basedir: conditionsRoot,\n        conditions: [],\n      });\n\n      expect(result).toEqual(\n        path.resolve(\n          conditionsRoot,\n          './node_modules/exports/some-other-directory/file.js',\n        ),\n      );\n    });\n  });\n\n  describe('self-reference', () => {\n    const selfRefRoot = path.resolve(__dirname, '../__mocks__/self-ref');\n\n    test('supports self-reference', () => {\n      const result = Resolver.findNodeModule('foo', {\n        basedir: path.resolve(selfRefRoot, './foo/index.js'),\n        conditions: [],\n      });\n\n      expect(result).toEqual(path.resolve(selfRefRoot, './foo/file.js'));\n    });\n\n    test('supports nested self-reference', () => {\n      const result = Resolver.findNodeModule('foo', {\n        basedir: path.resolve(selfRefRoot, './foo/nested/index.js'),\n        conditions: [],\n      });\n\n      expect(result).toEqual(path.resolve(selfRefRoot, './foo/file.js'));\n    });\n\n    test('fails if own pkg.json with different name', () => {\n      const result = Resolver.findNodeModule('foo', {\n        basedir: path.resolve(\n          selfRefRoot,\n          './foo/nested-with-own-pkg/index.js',\n        ),\n        conditions: [],\n      });\n\n      expect(result).toBeNull();\n    });\n\n    test('fails if own pkg.json with no exports', () => {\n      const result = Resolver.findNodeModule('foo-no-exports', {\n        basedir: path.resolve(\n          selfRefRoot,\n          './foo/nested-with-no-exports/index.js',\n        ),\n        conditions: [],\n      });\n\n      expect(result).toBeNull();\n    });\n  });\n\n  describe('imports', () => {\n    const importsRoot = path.resolve(__dirname, '../__mocks__/imports');\n\n    test('supports internal reference', () => {\n      const result = Resolver.findNodeModule('#nested', {\n        basedir: path.resolve(importsRoot, './foo-import/index.cjs'),\n        conditions: ['require'],\n      });\n\n      expect(result).toEqual(\n        path.resolve(importsRoot, './foo-import/internal.cjs'),\n      );\n    });\n\n    test('supports external reference', () => {\n      const result = Resolver.findNodeModule('#nested', {\n        basedir: path.resolve(importsRoot, './foo-import/index.js'),\n        conditions: [],\n      });\n\n      expect(result).toEqual(\n        path.resolve(\n          importsRoot,\n          './foo-import/node_modules/external-foo/main.js',\n        ),\n      );\n    });\n\n    test('supports nested pattern', () => {\n      const result = Resolver.findNodeModule('#nested', {\n        basedir: path.resolve(importsRoot, './nested-import/index.cjs'),\n        conditions: ['node', 'require'],\n      });\n\n      expect(result).toEqual(\n        path.resolve(importsRoot, './nested-import/node.cjs'),\n      );\n    });\n\n    describe('supports array pattern', () => {\n      test('resolve to first found', () => {\n        const result = Resolver.findNodeModule('#array-import', {\n          basedir: path.resolve(importsRoot, './array-import/index.cjs'),\n          conditions: ['import'],\n        });\n\n        expect(result).toEqual(\n          path.resolve(importsRoot, './array-import/node.mjs'),\n        );\n      });\n\n      test('skip over not met nested condition', () => {\n        const result = Resolver.findNodeModule('#array-import', {\n          basedir: path.resolve(importsRoot, './array-import/index.cjs'),\n          conditions: ['browser'],\n        });\n\n        expect(result).toEqual(\n          path.resolve(importsRoot, './array-import/browser.cjs'),\n        );\n      });\n\n      test('match nested condition', () => {\n        const result = Resolver.findNodeModule('#array-import', {\n          basedir: path.resolve(importsRoot, './array-import/index.cjs'),\n          conditions: ['chrome', 'browser'],\n        });\n\n        expect(result).toEqual(\n          path.resolve(importsRoot, './array-import/chrome.cjs'),\n        );\n      });\n    });\n\n    test('fails for non-existent mapping', () => {\n      expect(() => {\n        Resolver.findNodeModule('#something-else', {\n          basedir: path.resolve(importsRoot, './foo-import/index.js'),\n          conditions: [],\n        });\n      }).toThrow(\n        `Package import specifier \"#something-else\" is not defined in package ${path.join(importsRoot, 'foo-import/package.json')}`,\n      );\n    });\n  });\n});\n\ndescribe('findNodeModuleAsync', () => {\n  it('is possible to override the default resolver', async () => {\n    const cwd = process.cwd();\n    const resolvedCwd = fs.realpathSync(cwd) || cwd;\n    const nodePaths = process.env.NODE_PATH\n      ? process.env.NODE_PATH.split(path.delimiter)\n          .filter(Boolean)\n          .map(p => path.resolve(resolvedCwd, p))\n      : null;\n\n    mockUserResolverAsync.async.mockResolvedValue('module');\n\n    const newPath = await Resolver.findNodeModuleAsync('test', {\n      basedir: '/',\n      conditions: ['conditions, woooo'],\n      extensions: ['js'],\n      moduleDirectory: ['node_modules'],\n      paths: ['/something'],\n      resolver: require.resolve('../__mocks__/userResolverAsync'),\n    });\n\n    expect(newPath).toBe('module');\n    expect(mockUserResolverAsync.async.mock.calls[0][0]).toBe('test');\n    expect(mockUserResolverAsync.async.mock.calls[0][1]).toStrictEqual({\n      basedir: '/',\n      conditions: ['conditions, woooo'],\n      defaultAsyncResolver,\n      defaultResolver,\n      extensions: ['js'],\n      moduleDirectory: ['node_modules'],\n      paths: [...(nodePaths || []), '/something'],\n      rootDir: undefined,\n    });\n  });\n\n  it('supports file URLs', async () => {\n    const path = pathToFileURL(__filename).href;\n    const newPath = await Resolver.findNodeModuleAsync(path, {\n      basedir: '/',\n    });\n\n    expect(newPath).toBe(__filename);\n  });\n});\n\ndescribe('resolveModule', () => {\n  let moduleMap: IModuleMap;\n  beforeEach(() => {\n    moduleMap = ModuleMap.create('/');\n  });\n\n  it('is possible to resolve node modules', () => {\n    const resolver = new Resolver(moduleMap, {\n      extensions: ['.js'],\n    } as ResolverConfig);\n    const src = require.resolve('../');\n    const resolved = resolver.resolveModule(\n      src,\n      './__mocks__/mockJsDependency',\n    );\n    expect(resolved).toBe(require.resolve('../__mocks__/mockJsDependency.js'));\n  });\n\n  it('is possible to resolve node modules with custom extensions', () => {\n    const resolver = new Resolver(moduleMap, {\n      extensions: ['.js', '.jsx'],\n    } as ResolverConfig);\n    const src = require.resolve('../');\n    const resolvedJsx = resolver.resolveModule(\n      src,\n      './__mocks__/mockJsxDependency',\n    );\n    expect(resolvedJsx).toBe(\n      require.resolve('../__mocks__/mockJsxDependency.jsx'),\n    );\n  });\n\n  it('is possible to resolve node modules with custom extensions and platforms', () => {\n    const resolver = new Resolver(moduleMap, {\n      extensions: ['.js', '.jsx'],\n      platforms: ['native'],\n    } as ResolverConfig);\n    const src = require.resolve('../');\n    const resolvedJsx = resolver.resolveModule(\n      src,\n      './__mocks__/mockJsxDependency',\n    );\n    expect(resolvedJsx).toBe(\n      require.resolve('../__mocks__/mockJsxDependency.native.jsx'),\n    );\n  });\n\n  it('is possible to resolve node modules by resolving their realpath', () => {\n    const resolver = new Resolver(moduleMap, {\n      extensions: ['.js'],\n    } as ResolverConfig);\n    const src = path.join(\n      path.resolve(__dirname, '../../src/__mocks__/bar/node_modules/'),\n      'foo/index.js',\n    );\n    const resolved = resolver.resolveModule(src, 'dep');\n    expect(resolved).toBe(\n      require.resolve('../../src/__mocks__/foo/node_modules/dep/index.js'),\n    );\n  });\n\n  it('is possible to specify custom resolve paths', () => {\n    const resolver = new Resolver(moduleMap, {\n      extensions: ['.js'],\n    } as ResolverConfig);\n    const src = require.resolve('../');\n    const resolved = resolver.resolveModule(src, 'mockJsDependency', {\n      paths: [\n        path.resolve(__dirname, '../../src/__mocks__'),\n        path.resolve(__dirname, '../../src/__tests__'),\n      ],\n    });\n    expect(resolved).toBe(require.resolve('../__mocks__/mockJsDependency.js'));\n  });\n\n  it('does not confuse directories with files', () => {\n    const resolver = new Resolver(moduleMap, {\n      extensions: ['.js'],\n    } as ResolverConfig);\n    const mocksDirectory = path.resolve(__dirname, '../__mocks__');\n    const fooSlashFoo = path.join(mocksDirectory, 'foo/foo.js');\n    const fooSlashIndex = path.join(mocksDirectory, 'foo/index.js');\n\n    const resolvedWithSlash = resolver.resolveModule(fooSlashFoo, './');\n    const resolvedWithDot = resolver.resolveModule(fooSlashFoo, '.');\n    expect(resolvedWithSlash).toBe(fooSlashIndex);\n    expect(resolvedWithSlash).toBe(resolvedWithDot);\n  });\n\n  it('custom resolver can resolve node modules', () => {\n    mockUserResolver.mockImplementation(() => 'module');\n\n    const moduleMap = ModuleMap.create('/');\n    const resolver = new Resolver(moduleMap, {\n      extensions: ['.js'],\n      resolver: require.resolve('../__mocks__/userResolver'),\n    } as ResolverConfig);\n    const src = require.resolve('../');\n    resolver.resolveModule(src, 'fs');\n\n    expect(mockUserResolver).toHaveBeenCalled();\n    expect(mockUserResolver.mock.calls[0][0]).toBe('fs');\n  });\n\n  it('handles unmatched capture groups correctly', () => {\n    const resolver = new Resolver(moduleMap, {\n      extensions: ['.js'],\n      moduleNameMapper: [\n        {\n          moduleName: './__mocks__/foo$1',\n          regex: /^@Foo(\\/.*)?$/,\n        },\n      ],\n    } as ResolverConfig);\n    const src = require.resolve('../');\n    expect(resolver.resolveModule(src, '@Foo')).toBe(\n      require.resolve('../__mocks__/foo.js'),\n    );\n    expect(resolver.resolveModule(src, '@Foo/bar')).toBe(\n      require.resolve('../__mocks__/foo/bar/index.js'),\n    );\n  });\n});\n\ndescribe('resolveModuleAsync', () => {\n  let moduleMap: IModuleMap;\n  beforeEach(() => {\n    moduleMap = ModuleMap.create('/');\n  });\n\n  it('is possible to resolve node modules', async () => {\n    const resolver = new Resolver(moduleMap, {\n      extensions: ['.js'],\n    } as ResolverConfig);\n    const src = require.resolve('../');\n    const resolved = await resolver.resolveModuleAsync(\n      src,\n      './__mocks__/mockJsDependency',\n    );\n    expect(resolved).toBe(require.resolve('../__mocks__/mockJsDependency.js'));\n  });\n\n  it('is possible to resolve node modules with custom extensions', async () => {\n    const resolver = new Resolver(moduleMap, {\n      extensions: ['.js', '.jsx'],\n    } as ResolverConfig);\n    const src = require.resolve('../');\n    const resolvedJsx = await resolver.resolveModuleAsync(\n      src,\n      './__mocks__/mockJsxDependency',\n    );\n    expect(resolvedJsx).toBe(\n      require.resolve('../__mocks__/mockJsxDependency.jsx'),\n    );\n  });\n\n  it('is possible to resolve node modules with custom extensions and platforms', async () => {\n    const resolver = new Resolver(moduleMap, {\n      extensions: ['.js', '.jsx'],\n      platforms: ['native'],\n    } as ResolverConfig);\n    const src = require.resolve('../');\n    const resolvedJsx = await resolver.resolveModuleAsync(\n      src,\n      './__mocks__/mockJsxDependency',\n    );\n    expect(resolvedJsx).toBe(\n      require.resolve('../__mocks__/mockJsxDependency.native.jsx'),\n    );\n  });\n\n  it('is possible to resolve node modules by resolving their realpath', async () => {\n    const resolver = new Resolver(moduleMap, {\n      extensions: ['.js'],\n    } as ResolverConfig);\n    const src = path.join(\n      path.resolve(__dirname, '../../src/__mocks__/bar/node_modules/'),\n      'foo/index.js',\n    );\n    const resolved = await resolver.resolveModuleAsync(src, 'dep');\n    expect(resolved).toBe(\n      require.resolve('../../src/__mocks__/foo/node_modules/dep/index.js'),\n    );\n  });\n\n  it('is possible to specify custom resolve paths', async () => {\n    const resolver = new Resolver(moduleMap, {\n      extensions: ['.js'],\n    } as ResolverConfig);\n    const src = require.resolve('../');\n    const resolved = await resolver.resolveModuleAsync(\n      src,\n      'mockJsDependency',\n      {\n        paths: [\n          path.resolve(__dirname, '../../src/__tests__'),\n          path.resolve(__dirname, '../../src/__mocks__'),\n        ],\n      },\n    );\n    expect(resolved).toBe(require.resolve('../__mocks__/mockJsDependency.js'));\n  });\n\n  it('does not confuse directories with files', async () => {\n    const resolver = new Resolver(moduleMap, {\n      extensions: ['.js'],\n    } as ResolverConfig);\n    const mocksDirectory = path.resolve(__dirname, '../__mocks__');\n    const fooSlashFoo = path.join(mocksDirectory, 'foo/foo.js');\n    const fooSlashIndex = path.join(mocksDirectory, 'foo/index.js');\n\n    const resolvedWithSlash = await resolver.resolveModuleAsync(\n      fooSlashFoo,\n      './',\n    );\n    const resolvedWithDot = await resolver.resolveModuleAsync(fooSlashFoo, '.');\n    expect(resolvedWithSlash).toBe(fooSlashIndex);\n    expect(resolvedWithSlash).toBe(resolvedWithDot);\n  });\n});\n\ndescribe('getMockModule', () => {\n  it('is possible to use custom resolver to resolve deps inside mock modules with moduleNameMapper', () => {\n    mockUserResolver.mockImplementation(() => 'module');\n\n    const moduleMap = ModuleMap.create('/');\n    const resolver = new Resolver(moduleMap, {\n      extensions: ['.js'],\n      moduleNameMapper: [\n        {\n          moduleName: '$1',\n          regex: /(.*)/,\n        },\n      ],\n      resolver: require.resolve('../__mocks__/userResolver'),\n    } as ResolverConfig);\n    const src = require.resolve('../');\n    resolver.getMockModule(src, 'dependentModule');\n\n    expect(mockUserResolver).toHaveBeenCalled();\n    expect(mockUserResolver.mock.calls[0][0]).toBe('dependentModule');\n    expect(mockUserResolver.mock.calls[0][1]).toHaveProperty(\n      'basedir',\n      path.dirname(src),\n    );\n  });\n});\n\ndescribe('getMockModuleAsync', () => {\n  it('is possible to use custom resolver to resolve deps inside mock modules with moduleNameMapper', async () => {\n    mockUserResolverAsync.async.mockResolvedValue('module');\n\n    const moduleMap = ModuleMap.create('/');\n    const resolver = new Resolver(moduleMap, {\n      extensions: ['.js'],\n      moduleNameMapper: [\n        {\n          moduleName: '$1',\n          regex: /(.*)/,\n        },\n      ],\n      resolver: require.resolve('../__mocks__/userResolverAsync'),\n    } as ResolverConfig);\n    const src = require.resolve('../');\n\n    await resolver.resolveModuleAsync(src, 'dependentModule', {\n      conditions: ['browser'],\n    });\n\n    expect(mockUserResolverAsync.async).toHaveBeenCalled();\n    expect(mockUserResolverAsync.async.mock.calls[0][0]).toBe(\n      'dependentModule',\n    );\n    expect(mockUserResolverAsync.async.mock.calls[0][1]).toHaveProperty(\n      'basedir',\n      path.dirname(src),\n    );\n    expect(mockUserResolverAsync.async.mock.calls[0][1]).toHaveProperty(\n      'conditions',\n      ['browser'],\n    );\n  });\n});\n\ndescribe('nodeModulesPaths', () => {\n  it('provides custom module paths after node_modules', () => {\n    const src = require.resolve('../');\n    const result = nodeModulesPaths(src, {paths: ['./customFolder']});\n    expect(result.at(-1)).toBe('./customFolder');\n  });\n\n  it('provides custom module multi paths after node_modules', () => {\n    const src = require.resolve('../');\n    const result = nodeModulesPaths(src, {\n      paths: ['./customFolder', './customFolder2', './customFolder3'],\n    });\n    expect(result.slice(-3)).toStrictEqual([\n      './customFolder',\n      './customFolder2',\n      './customFolder3',\n    ]);\n  });\n});\n\ndescribe('Resolver.getModulePaths() -> nodeModulesPaths()', () => {\n  const _path = path;\n  let moduleMap: IModuleMap;\n\n  beforeEach(() => {\n    jest.resetModules();\n\n    moduleMap = ModuleMap.create('/');\n\n    // Mocking realpath to function the old way, where it just looks at\n    // pathstrings instead of actually trying to access the physical directory.\n    // This test suite won't work otherwise, since we cannot make assumptions\n    // about the test environment when it comes to absolute paths.\n    jest.doMock('graceful-fs', () => ({\n      ...jest.requireActual<typeof import('graceful-fs')>('graceful-fs'),\n      realPathSync: {\n        native: (dirInput: string) => dirInput,\n      },\n    }));\n  });\n\n  afterAll(() => {\n    jest.resetModules();\n    jest.dontMock('path');\n  });\n\n  it('can resolve node modules relative to absolute paths in \"moduleDirectories\" on Windows platforms', () => {\n    jest.doMock('path', () => _path.win32);\n    const path = require('path');\n    const Resolver = require('../').default;\n\n    const cwd = 'D:\\\\temp\\\\project';\n    const src = 'C:\\\\path\\\\to\\\\node_modules';\n    const resolver = new Resolver(moduleMap, {\n      moduleDirectories: [src, 'node_modules'],\n    });\n    const dirs_expected = [\n      src,\n      `${cwd}\\\\node_modules`,\n      `${path.dirname(cwd)}\\\\node_modules`,\n      'D:\\\\node_modules',\n    ];\n    const dirs_actual = resolver.getModulePaths(cwd);\n    expect(dirs_actual).toEqual(expect.arrayContaining(dirs_expected));\n  });\n\n  it('can resolve node modules relative to absolute paths in \"moduleDirectories\" on Posix platforms', () => {\n    jest.doMock('path', () => _path.posix);\n    const path = require('path');\n    const Resolver = require('../').default;\n\n    const cwd = '/temp/project';\n    const src = '/path/to/node_modules';\n    const resolver = new Resolver(moduleMap, {\n      moduleDirectories: [src, 'node_modules'],\n    });\n    const dirs_expected = [\n      src,\n      `${cwd}/node_modules`,\n      `${path.dirname(cwd)}/node_modules`,\n      '/node_modules',\n    ];\n    const dirs_actual = resolver.getModulePaths(cwd);\n    expect(dirs_actual).toEqual(expect.arrayContaining(dirs_expected));\n  });\n});\n\ndescribe('Resolver.getGlobalPaths()', () => {\n  const _path = path;\n  let moduleMap: IModuleMap;\n  beforeEach(() => {\n    moduleMap = ModuleMap.create('/');\n  });\n\n  it('return global paths with npm package', () => {\n    jest.doMock('path', () => _path.posix);\n    const resolver = new Resolver(moduleMap, {} as ResolverConfig);\n    const globalPaths = resolver.getGlobalPaths('jest');\n    for (const globalPath of globalPaths)\n      expect(require.resolve.paths('jest')).toContain(globalPath);\n  });\n\n  it('return empty array with builtin module', () => {\n    jest.doMock('path', () => _path.posix);\n    const resolver = new Resolver(moduleMap, {} as ResolverConfig);\n    const globalPaths = resolver.getGlobalPaths('fs');\n    expect(globalPaths).toStrictEqual([]);\n  });\n\n  it('return global paths with absolute path', () => {\n    jest.doMock('path', () => _path.posix);\n    const resolver = new Resolver(moduleMap, {} as ResolverConfig);\n    const globalPaths = resolver.getGlobalPaths('/');\n    for (const globalPath of globalPaths)\n      expect(require.resolve.paths('/')).toContain(globalPath);\n  });\n\n  it('return empty array with relative path', () => {\n    jest.doMock('path', () => _path.posix);\n    const resolver = new Resolver(moduleMap, {} as ResolverConfig);\n    const globalPaths = resolver.getGlobalPaths('./');\n    expect(globalPaths).toStrictEqual([]);\n  });\n\n  it('return empty array without module name', () => {\n    jest.doMock('path', () => _path.posix);\n    const resolver = new Resolver(moduleMap, {} as ResolverConfig);\n    const globalPaths = resolver.getGlobalPaths();\n    expect(globalPaths).toStrictEqual([]);\n  });\n});\n",
  "packages/jest-resolve/src/__tests__/resolve.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport {};\n",
  "packages/jest-resolve/src/__mocks__/userResolverAsync.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {AsyncResolver} from '../defaultResolver';\n\n// todo: can be replaced with jest.MockedFunction\ndeclare const userResolver: {\n  async: AsyncResolver;\n};\n\nexport default userResolver;\n",
  "packages/jest-resolve/src/__mocks__/userResolver.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {SyncResolver} from '../defaultResolver';\n\ndeclare const userResolver: SyncResolver;\n\nexport default userResolver;\n",
  "packages/jest-resolve/__typetests__/resolver.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {expect} from 'tstyche';\nimport type {\n  AsyncResolver,\n  JestResolver,\n  PackageJSON,\n  ResolverOptions,\n  SyncResolver,\n} from 'jest-resolve';\n\n// PackageJSON\n\nexpect<PackageJSON>().type.toBeAssignableWith({\n  caption: 'test',\n  count: 100,\n  isTest: true,\n  location: {name: 'test', start: [1, 2], valid: false, x: 10, y: 20},\n  values: [0, 10, 20, {x: 1, y: 2}, true, 'test', ['a', 'b']],\n});\n\nexpect<PackageJSON>().type.not.toBeAssignableWith({\n  filter: () => {},\n});\n\n// ResolverOptions\n\nfunction customSyncResolver(path: string, options: ResolverOptions): string {\n  return path;\n}\nexpect<SyncResolver>().type.toBeAssignableWith(customSyncResolver);\n\nasync function customAsyncResolver(\n  path: string,\n  options: ResolverOptions,\n): Promise<string> {\n  return path;\n}\nexpect<AsyncResolver>().type.toBeAssignableWith(customAsyncResolver);\n\n// AsyncResolver\n\nconst asyncResolver: AsyncResolver = async (path, options) => {\n  expect(path).type.toBe<string>();\n\n  expect(options.basedir).type.toBe<string>();\n  expect(options.conditions).type.toBe<Array<string> | undefined>();\n  expect(options.defaultResolver).type.toBe<SyncResolver>();\n  expect(options.extensions).type.toBe<Array<string> | undefined>();\n  expect(options.moduleDirectory).type.toBe<Array<string> | undefined>();\n  expect(options.paths).type.toBe<Array<string> | undefined>();\n  expect(options.rootDir).type.toBe<string | undefined>();\n\n  return path;\n};\n\nconst notReturningAsyncResolver = async () => {};\nexpect<AsyncResolver>().type.not.toBeAssignableWith(\n  notReturningAsyncResolver(),\n);\n\n// SyncResolver\n\nconst syncResolver: SyncResolver = (path, options) => {\n  expect(path).type.toBe<string>();\n\n  expect(options.basedir).type.toBe<string>();\n  expect(options.conditions).type.toBe<Array<string> | undefined>();\n  expect(options.defaultResolver).type.toBe<SyncResolver>();\n  expect(options.extensions).type.toBe<Array<string> | undefined>();\n  expect(options.moduleDirectory).type.toBe<Array<string> | undefined>();\n  expect(options.paths).type.toBe<Array<string> | undefined>();\n  expect(options.rootDir).type.toBe<string | undefined>();\n\n  return path;\n};\n\nconst notReturningSyncResolver = () => {};\nexpect<SyncResolver>().type.not.toBeAssignableWith(notReturningSyncResolver());\n\n// JestResolver\n\nexpect<JestResolver>().type.toBeAssignableWith({async: asyncResolver});\nexpect<JestResolver>().type.toBeAssignableWith({sync: syncResolver});\nexpect<JestResolver>().type.toBeAssignableWith({\n  async: asyncResolver,\n  sync: syncResolver,\n});\nexpect<JestResolver>().type.not.toBeAssignableWith({});\n",
  "packages/jest-resolve/__typetests__/resolver.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-reporters/src/wrapAnsiString.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// word-wrap a string that contains ANSI escape sequences.\n// ANSI escape sequences do not add to the string length.\nexport default function wrapAnsiString(\n  string: string,\n  terminalWidth: number,\n): string {\n  if (terminalWidth === 0) {\n    // if the terminal width is zero, don't bother word-wrapping\n    return string;\n  }\n\n  const ANSI_REGEXP = /[\\u001B\\u009B]\\[\\d{1,2}m/gu;\n  const tokens = [];\n  let lastIndex = 0;\n  let match;\n\n  while ((match = ANSI_REGEXP.exec(string))) {\n    const ansi = match[0];\n    const index = match.index;\n    if (index !== lastIndex) {\n      tokens.push(['string', string.slice(lastIndex, index)]);\n    }\n    tokens.push(['ansi', ansi]);\n    lastIndex = index + ansi.length;\n  }\n\n  if (lastIndex !== string.length - 1) {\n    tokens.push(['string', string.slice(lastIndex)]);\n  }\n\n  let lastLineLength = 0;\n\n  return tokens\n    .reduce(\n      (lines, [kind, token]) => {\n        if (kind === 'string') {\n          if (lastLineLength + token.length > terminalWidth) {\n            while (token.length > 0) {\n              const chunk = token.slice(0, terminalWidth - lastLineLength);\n              const remaining = token.slice(terminalWidth - lastLineLength);\n              lines[lines.length - 1] += chunk;\n              lastLineLength += chunk.length;\n              token = remaining;\n              if (token.length > 0) {\n                lines.push('');\n                lastLineLength = 0;\n              }\n            }\n          } else {\n            lines[lines.length - 1] += token;\n            lastLineLength += token.length;\n          }\n        } else {\n          lines[lines.length - 1] += token;\n        }\n\n        return lines;\n      },\n      [''],\n    )\n    .join('\\n');\n}\n",
  "packages/jest-reporters/src/wrapAnsiString.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport default function wrapAnsiString(string: string, terminalWidth: number): string;\n",
  "packages/jest-reporters/src/types.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {\n  AggregatedResult,\n  Test,\n  TestCaseResult,\n  TestContext,\n  TestResult,\n} from '@jest/test-result';\nimport type {Circus, Config} from '@jest/types';\n\nexport type ReporterOnStartOptions = {\n  estimatedTime: number;\n  showStatus: boolean;\n};\n\nexport interface Reporter {\n  readonly onTestResult?: (\n    test: Test,\n    testResult: TestResult,\n    aggregatedResult: AggregatedResult,\n  ) => Promise<void> | void;\n  readonly onTestFileResult?: (\n    test: Test,\n    testResult: TestResult,\n    aggregatedResult: AggregatedResult,\n  ) => Promise<void> | void;\n  /**\n   * Called before running a spec (prior to `before` hooks)\n   * Not called for `skipped` and `todo` specs\n   */\n  readonly onTestCaseStart?: (\n    test: Test,\n    testCaseStartInfo: Circus.TestCaseStartInfo,\n  ) => Promise<void> | void;\n  readonly onTestCaseResult?: (\n    test: Test,\n    testCaseResult: TestCaseResult,\n  ) => Promise<void> | void;\n  readonly onRunStart?: (\n    results: AggregatedResult,\n    options: ReporterOnStartOptions,\n  ) => Promise<void> | void;\n  readonly onTestStart?: (test: Test) => Promise<void> | void;\n  readonly onTestFileStart?: (test: Test) => Promise<void> | void;\n  readonly onRunComplete?: (\n    testContexts: Set<TestContext>,\n    results: AggregatedResult,\n  ) => Promise<void> | void;\n  readonly getLastError?: () => Error | void;\n}\n\nexport type ReporterContext = {\n  firstRun: boolean;\n  previousSuccess: boolean;\n  changedFiles?: Set<string>;\n  sourcesRelatedToTestsInChangedFiles?: Set<string>;\n  startRun?: (globalConfig: Config.GlobalConfig) => unknown;\n};\n\nexport type SummaryOptions = {\n  currentTestCases?: Array<{test: Test; testCaseResult: TestCaseResult}>;\n  estimatedTime?: number;\n  roundTime?: boolean;\n  width?: number;\n  showSeed?: boolean;\n  seed?: number;\n};\n",
  "packages/jest-reporters/src/types.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { AggregatedResult, Test, TestCaseResult, TestContext, TestResult } from '@jest/test-result';\nimport type { Circus, Config } from '@jest/types';\nexport type ReporterOnStartOptions = {\n    estimatedTime: number;\n    showStatus: boolean;\n};\nexport interface Reporter {\n    readonly onTestResult?: (test: Test, testResult: TestResult, aggregatedResult: AggregatedResult) => Promise<void> | void;\n    readonly onTestFileResult?: (test: Test, testResult: TestResult, aggregatedResult: AggregatedResult) => Promise<void> | void;\n    /**\n     * Called before running a spec (prior to `before` hooks)\n     * Not called for `skipped` and `todo` specs\n     */\n    readonly onTestCaseStart?: (test: Test, testCaseStartInfo: Circus.TestCaseStartInfo) => Promise<void> | void;\n    readonly onTestCaseResult?: (test: Test, testCaseResult: TestCaseResult) => Promise<void> | void;\n    readonly onRunStart?: (results: AggregatedResult, options: ReporterOnStartOptions) => Promise<void> | void;\n    readonly onTestStart?: (test: Test) => Promise<void> | void;\n    readonly onTestFileStart?: (test: Test) => Promise<void> | void;\n    readonly onRunComplete?: (testContexts: Set<TestContext>, results: AggregatedResult) => Promise<void> | void;\n    readonly getLastError?: () => Error | void;\n}\nexport type ReporterContext = {\n    firstRun: boolean;\n    previousSuccess: boolean;\n    changedFiles?: Set<string>;\n    sourcesRelatedToTestsInChangedFiles?: Set<string>;\n    startRun?: (globalConfig: Config.GlobalConfig) => unknown;\n};\nexport type SummaryOptions = {\n    currentTestCases?: Array<{\n        test: Test;\n        testCaseResult: TestCaseResult;\n    }>;\n    estimatedTime?: number;\n    roundTime?: boolean;\n    width?: number;\n    showSeed?: boolean;\n    seed?: number;\n};\n",
  "packages/jest-reporters/src/trimAndFormatPath.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport chalk from 'chalk';\nimport slash from 'slash';\nimport type {Config} from '@jest/types';\nimport relativePath from './relativePath';\n\nexport default function trimAndFormatPath(\n  pad: number,\n  config: Config.ProjectConfig | Config.GlobalConfig,\n  testPath: string,\n  columns: number,\n): string {\n  const maxLength = columns - pad;\n  const relative = relativePath(config, testPath);\n  const {basename} = relative;\n  let {dirname} = relative;\n\n  // length is ok\n  if ((dirname + path.sep + basename).length <= maxLength) {\n    return slash(chalk.dim(dirname + path.sep) + chalk.bold(basename));\n  }\n\n  // we can fit trimmed dirname and full basename\n  const basenameLength = basename.length;\n  if (basenameLength + 4 < maxLength) {\n    const dirnameLength = maxLength - 4 - basenameLength;\n    dirname = `...${dirname.slice(dirname.length - dirnameLength)}`;\n    return slash(chalk.dim(dirname + path.sep) + chalk.bold(basename));\n  }\n\n  if (basenameLength + 4 === maxLength) {\n    return slash(chalk.dim(`...${path.sep}`) + chalk.bold(basename));\n  }\n\n  // can't fit dirname, but can fit trimmed basename\n  return slash(\n    chalk.bold(`...${basename.slice(basename.length - maxLength - 4)}`),\n  );\n}\n",
  "packages/jest-reporters/src/trimAndFormatPath.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config } from '@jest/types';\nexport default function trimAndFormatPath(pad: number, config: Config.ProjectConfig | Config.GlobalConfig, testPath: string, columns: number): string;\n",
  "packages/jest-reporters/src/relativePath.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport type {Config} from '@jest/types';\n\nexport default function relativePath(\n  config: Config.GlobalConfig | Config.ProjectConfig,\n  testPath: string,\n): {basename: string; dirname: string} {\n  // this function can be called with ProjectConfigs or GlobalConfigs. GlobalConfigs\n  // do not have config.cwd, only config.rootDir. Try using config.cwd, fallback\n  // to config.rootDir. (Also, some unit just use config.rootDir, which is ok)\n  testPath = path.relative(\n    (config as Config.ProjectConfig).cwd || config.rootDir,\n    testPath,\n  );\n  const dirname = path.dirname(testPath);\n  const basename = path.basename(testPath);\n  return {basename, dirname};\n}\n",
  "packages/jest-reporters/src/relativePath.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config } from '@jest/types';\nexport default function relativePath(config: Config.GlobalConfig | Config.ProjectConfig, testPath: string): {\n    basename: string;\n    dirname: string;\n};\n",
  "packages/jest-reporters/src/printDisplayName.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk from 'chalk';\nimport type {Config} from '@jest/types';\n\nexport default function printDisplayName(config: Config.ProjectConfig): string {\n  const {displayName} = config;\n  const white = chalk.reset.inverse.white;\n  if (!displayName) {\n    return '';\n  }\n\n  const {name, color} = displayName;\n  const chosenColor = chalk.reset.inverse[color] ?? white;\n  return chalk.supportsColor ? chosenColor(` ${name} `) : name;\n}\n",
  "packages/jest-reporters/src/printDisplayName.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config } from '@jest/types';\nexport default function printDisplayName(config: Config.ProjectConfig): string;\n",
  "packages/jest-reporters/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport formatTestPath from './formatTestPath';\nimport getResultHeader from './getResultHeader';\nimport getSnapshotStatus from './getSnapshotStatus';\nimport getSnapshotSummary from './getSnapshotSummary';\nimport getSummary from './getSummary';\nimport printDisplayName from './printDisplayName';\nimport relativePath from './relativePath';\nimport trimAndFormatPath from './trimAndFormatPath';\n\nexport type {\n  AggregatedResult,\n  SnapshotSummary,\n  Test,\n  TestCaseResult,\n  TestContext,\n  TestResult,\n} from '@jest/test-result';\nexport type {Config} from '@jest/types';\nexport {default as BaseReporter} from './BaseReporter';\nexport {default as CoverageReporter} from './CoverageReporter';\nexport {default as DefaultReporter} from './DefaultReporter';\nexport {default as GitHubActionsReporter} from './GitHubActionsReporter';\nexport {default as NotifyReporter} from './NotifyReporter';\nexport {default as SummaryReporter} from './SummaryReporter';\nexport {default as VerboseReporter} from './VerboseReporter';\nexport type {SummaryReporterOptions} from './SummaryReporter';\nexport type {\n  Reporter,\n  ReporterOnStartOptions,\n  ReporterContext,\n  SummaryOptions,\n} from './types';\nexport const utils = {\n  formatTestPath,\n  getResultHeader,\n  getSnapshotStatus,\n  getSnapshotSummary,\n  getSummary,\n  printDisplayName,\n  relativePath,\n  trimAndFormatPath,\n};\n",
  "packages/jest-reporters/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport formatTestPath from './formatTestPath';\nimport getResultHeader from './getResultHeader';\nimport getSnapshotStatus from './getSnapshotStatus';\nimport getSnapshotSummary from './getSnapshotSummary';\nimport getSummary from './getSummary';\nimport printDisplayName from './printDisplayName';\nimport relativePath from './relativePath';\nimport trimAndFormatPath from './trimAndFormatPath';\nexport type { AggregatedResult, SnapshotSummary, Test, TestCaseResult, TestContext, TestResult, } from '@jest/test-result';\nexport type { Config } from '@jest/types';\nexport { default as BaseReporter } from './BaseReporter';\nexport { default as CoverageReporter } from './CoverageReporter';\nexport { default as DefaultReporter } from './DefaultReporter';\nexport { default as GitHubActionsReporter } from './GitHubActionsReporter';\nexport { default as NotifyReporter } from './NotifyReporter';\nexport { default as SummaryReporter } from './SummaryReporter';\nexport { default as VerboseReporter } from './VerboseReporter';\nexport type { SummaryReporterOptions } from './SummaryReporter';\nexport type { Reporter, ReporterOnStartOptions, ReporterContext, SummaryOptions, } from './types';\nexport declare const utils: {\n    formatTestPath: typeof formatTestPath;\n    getResultHeader: typeof getResultHeader;\n    getSnapshotStatus: typeof getSnapshotStatus;\n    getSnapshotSummary: typeof getSnapshotSummary;\n    getSummary: typeof getSummary;\n    printDisplayName: typeof printDisplayName;\n    relativePath: typeof relativePath;\n    trimAndFormatPath: typeof trimAndFormatPath;\n};\n",
  "packages/jest-reporters/src/getWatermarks.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as istanbulReport from 'istanbul-lib-report';\nimport type {Config} from '@jest/types';\n\nexport default function getWatermarks(\n  config: Config.GlobalConfig,\n): istanbulReport.Watermarks {\n  const defaultWatermarks = istanbulReport.getDefaultWatermarks();\n\n  const {coverageThreshold} = config;\n\n  if (!coverageThreshold || !coverageThreshold.global) {\n    return defaultWatermarks;\n  }\n\n  const keys: Array<keyof Config.CoverageThresholdValue> = [\n    'branches',\n    'functions',\n    'lines',\n    'statements',\n  ];\n  return keys.reduce((watermarks, key) => {\n    const value = coverageThreshold.global[key];\n    if (value !== undefined) {\n      watermarks[key][1] = value;\n    }\n\n    return watermarks;\n  }, defaultWatermarks);\n}\n",
  "packages/jest-reporters/src/getWatermarks.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport * as istanbulReport from 'istanbul-lib-report';\nimport type { Config } from '@jest/types';\nexport default function getWatermarks(config: Config.GlobalConfig): istanbulReport.Watermarks;\n",
  "packages/jest-reporters/src/getSummary.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk from 'chalk';\nimport type {AggregatedResult, Test, TestCaseResult} from '@jest/test-result';\nimport {formatTime, pluralize} from 'jest-util';\nimport type {SummaryOptions} from './types';\n\nexport const PROGRESS_BAR_WIDTH = 40;\n\nfunction getValuesCurrentTestCases(\n  currentTestCases: Array<{test: Test; testCaseResult: TestCaseResult}> = [],\n) {\n  let numFailingTests = 0;\n  let numPassingTests = 0;\n  let numPendingTests = 0;\n  let numTodoTests = 0;\n  let numTotalTests = 0;\n  for (const testCase of currentTestCases) {\n    switch (testCase.testCaseResult.status) {\n      case 'failed': {\n        numFailingTests++;\n        break;\n      }\n      case 'passed': {\n        numPassingTests++;\n        break;\n      }\n      case 'skipped': {\n        numPendingTests++;\n        break;\n      }\n      case 'todo': {\n        numTodoTests++;\n        break;\n      }\n    }\n    numTotalTests++;\n  }\n\n  return {\n    numFailingTests,\n    numPassingTests,\n    numPendingTests,\n    numTodoTests,\n    numTotalTests,\n  };\n}\n\nfunction renderTime(runTime: number, estimatedTime: number, width: number) {\n  // If we are more than one second over the estimated time, highlight it.\n  const renderedTime =\n    estimatedTime && runTime >= estimatedTime + 1\n      ? chalk.bold.yellow(formatTime(runTime, 0))\n      : formatTime(runTime, 0);\n  let time = `${chalk.bold('Time:')}        ${renderedTime}`;\n  if (runTime < estimatedTime) {\n    time += `, estimated ${formatTime(estimatedTime, 0)}`;\n  }\n\n  // Only show a progress bar if the test run is actually going to take\n  // some time.\n  if (estimatedTime > 2 && runTime < estimatedTime && width) {\n    const availableWidth = Math.min(PROGRESS_BAR_WIDTH, width);\n    const length = Math.min(\n      Math.floor((runTime / estimatedTime) * availableWidth),\n      availableWidth,\n    );\n    if (availableWidth >= 2) {\n      time += `\\n${chalk.green('█').repeat(length)}${chalk\n        .white('█')\n        .repeat(availableWidth - length)}`;\n    }\n  }\n  return time;\n}\n\nexport default function getSummary(\n  aggregatedResults: AggregatedResult,\n  options?: SummaryOptions,\n): string {\n  let runTime = (Date.now() - aggregatedResults.startTime) / 1000;\n  if (options && options.roundTime) {\n    runTime = Math.floor(runTime);\n  }\n\n  const valuesForCurrentTestCases = getValuesCurrentTestCases(\n    options?.currentTestCases,\n  );\n\n  const estimatedTime = (options && options.estimatedTime) || 0;\n  const snapshotResults = aggregatedResults.snapshot;\n  const snapshotsAdded = snapshotResults.added;\n  const snapshotsFailed = snapshotResults.unmatched;\n  const snapshotsOutdated = snapshotResults.unchecked;\n  const snapshotsFilesRemoved = snapshotResults.filesRemoved;\n  const snapshotsDidUpdate = snapshotResults.didUpdate;\n  const snapshotsPassed = snapshotResults.matched;\n  const snapshotsTotal = snapshotResults.total;\n  const snapshotsUpdated = snapshotResults.updated;\n  const suitesFailed = aggregatedResults.numFailedTestSuites;\n  const suitesPassed = aggregatedResults.numPassedTestSuites;\n  const suitesPending = aggregatedResults.numPendingTestSuites;\n  const suitesRun = suitesFailed + suitesPassed;\n  const suitesTotal = aggregatedResults.numTotalTestSuites;\n  const testsFailed = aggregatedResults.numFailedTests;\n  const testsPassed = aggregatedResults.numPassedTests;\n  const testsPending = aggregatedResults.numPendingTests;\n  const testsTodo = aggregatedResults.numTodoTests;\n  const testsTotal = aggregatedResults.numTotalTests;\n  const width = (options && options.width) || 0;\n\n  const optionalLines: Array<string> = [];\n\n  if (options?.showSeed === true) {\n    const {seed} = options;\n    if (seed === undefined) {\n      throw new Error('Attempted to display seed but seed value is undefined');\n    }\n    optionalLines.push(`${chalk.bold('Seed:        ') + seed}`);\n  }\n\n  const suites = `${\n    chalk.bold('Test Suites: ') +\n    (suitesFailed ? `${chalk.bold.red(`${suitesFailed} failed`)}, ` : '') +\n    (suitesPending\n      ? `${chalk.bold.yellow(`${suitesPending} skipped`)}, `\n      : '') +\n    (suitesPassed ? `${chalk.bold.green(`${suitesPassed} passed`)}, ` : '') +\n    (suitesRun === suitesTotal ? suitesTotal : `${suitesRun} of ${suitesTotal}`)\n  } total`;\n\n  const updatedTestsFailed =\n    testsFailed + valuesForCurrentTestCases.numFailingTests;\n  const updatedTestsPending =\n    testsPending + valuesForCurrentTestCases.numPendingTests;\n  const updatedTestsTodo = testsTodo + valuesForCurrentTestCases.numTodoTests;\n  const updatedTestsPassed =\n    testsPassed + valuesForCurrentTestCases.numPassingTests;\n  const updatedTestsTotal =\n    testsTotal + valuesForCurrentTestCases.numTotalTests;\n\n  const tests = `${\n    chalk.bold('Tests:       ') +\n    (updatedTestsFailed > 0\n      ? `${chalk.bold.red(`${updatedTestsFailed} failed`)}, `\n      : '') +\n    (updatedTestsPending > 0\n      ? `${chalk.bold.yellow(`${updatedTestsPending} skipped`)}, `\n      : '') +\n    (updatedTestsTodo > 0\n      ? `${chalk.bold.magenta(`${updatedTestsTodo} todo`)}, `\n      : '') +\n    (updatedTestsPassed > 0\n      ? `${chalk.bold.green(`${updatedTestsPassed} passed`)}, `\n      : '')\n  }${updatedTestsTotal} total`;\n\n  const snapshots = `${\n    chalk.bold('Snapshots:   ') +\n    (snapshotsFailed\n      ? `${chalk.bold.red(`${snapshotsFailed} failed`)}, `\n      : '') +\n    (snapshotsOutdated && !snapshotsDidUpdate\n      ? `${chalk.bold.yellow(`${snapshotsOutdated} obsolete`)}, `\n      : '') +\n    (snapshotsOutdated && snapshotsDidUpdate\n      ? `${chalk.bold.green(`${snapshotsOutdated} removed`)}, `\n      : '') +\n    (snapshotsFilesRemoved && !snapshotsDidUpdate\n      ? `${chalk.bold.yellow(\n          `${pluralize('file', snapshotsFilesRemoved)} obsolete`,\n        )}, `\n      : '') +\n    (snapshotsFilesRemoved && snapshotsDidUpdate\n      ? `${chalk.bold.green(\n          `${pluralize('file', snapshotsFilesRemoved)} removed`,\n        )}, `\n      : '') +\n    (snapshotsUpdated\n      ? `${chalk.bold.green(`${snapshotsUpdated} updated`)}, `\n      : '') +\n    (snapshotsAdded\n      ? `${chalk.bold.green(`${snapshotsAdded} written`)}, `\n      : '') +\n    (snapshotsPassed\n      ? `${chalk.bold.green(`${snapshotsPassed} passed`)}, `\n      : '')\n  }${snapshotsTotal} total`;\n\n  const time = renderTime(runTime, estimatedTime, width);\n\n  return [...optionalLines, suites, tests, snapshots, time].join('\\n');\n}\n",
  "packages/jest-reporters/src/getSummary.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { AggregatedResult } from '@jest/test-result';\nimport type { SummaryOptions } from './types';\nexport declare const PROGRESS_BAR_WIDTH = 40;\nexport default function getSummary(aggregatedResults: AggregatedResult, options?: SummaryOptions): string;\n",
  "packages/jest-reporters/src/getSnapshotSummary.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk from 'chalk';\nimport type {SnapshotSummary} from '@jest/test-result';\nimport type {Config} from '@jest/types';\nimport {pluralize} from 'jest-util';\nimport formatTestPath from './formatTestPath';\n\nconst ARROW = ' \\u203A ';\nconst DOWN_ARROW = ' \\u21B3 ';\nconst DOT = ' \\u2022 ';\nconst FAIL_COLOR = chalk.bold.red;\nconst OBSOLETE_COLOR = chalk.bold.yellow;\nconst SNAPSHOT_ADDED = chalk.bold.green;\nconst SNAPSHOT_NOTE = chalk.dim;\nconst SNAPSHOT_REMOVED = chalk.bold.green;\nconst SNAPSHOT_SUMMARY = chalk.bold;\nconst SNAPSHOT_UPDATED = chalk.bold.green;\n\nexport default function getSnapshotSummary(\n  snapshots: SnapshotSummary,\n  globalConfig: Config.GlobalConfig,\n  updateCommand: string,\n): Array<string> {\n  const summary = [];\n  summary.push(SNAPSHOT_SUMMARY('Snapshot Summary'));\n  if (snapshots.added) {\n    summary.push(\n      `${SNAPSHOT_ADDED(\n        `${ARROW + pluralize('snapshot', snapshots.added)} written `,\n      )}from ${pluralize('test suite', snapshots.filesAdded)}.`,\n    );\n  }\n\n  if (snapshots.unmatched) {\n    summary.push(\n      `${FAIL_COLOR(\n        `${ARROW}${pluralize('snapshot', snapshots.unmatched)} failed`,\n      )} from ${pluralize(\n        'test suite',\n        snapshots.filesUnmatched,\n      )}. ${SNAPSHOT_NOTE(\n        `Inspect your code changes or ${updateCommand} to update them.`,\n      )}`,\n    );\n  }\n\n  if (snapshots.updated) {\n    summary.push(\n      `${SNAPSHOT_UPDATED(\n        `${ARROW + pluralize('snapshot', snapshots.updated)} updated `,\n      )}from ${pluralize('test suite', snapshots.filesUpdated)}.`,\n    );\n  }\n\n  if (snapshots.filesRemoved) {\n    if (snapshots.didUpdate) {\n      summary.push(\n        `${SNAPSHOT_REMOVED(\n          `${ARROW}${pluralize(\n            'snapshot file',\n            snapshots.filesRemoved,\n          )} removed `,\n        )}from ${pluralize('test suite', snapshots.filesRemoved)}.`,\n      );\n    } else {\n      summary.push(\n        `${OBSOLETE_COLOR(\n          `${ARROW}${pluralize(\n            'snapshot file',\n            snapshots.filesRemoved,\n          )} obsolete `,\n        )}from ${pluralize(\n          'test suite',\n          snapshots.filesRemoved,\n        )}. ${SNAPSHOT_NOTE(\n          `To remove ${\n            snapshots.filesRemoved === 1 ? 'it' : 'them all'\n          }, ${updateCommand}.`,\n        )}`,\n      );\n    }\n  }\n  if (snapshots.filesRemovedList && snapshots.filesRemovedList.length > 0) {\n    const [head, ...tail] = snapshots.filesRemovedList;\n    summary.push(`  ${DOWN_ARROW} ${DOT}${formatTestPath(globalConfig, head)}`);\n\n    for (const key of tail) {\n      summary.push(`      ${DOT}${formatTestPath(globalConfig, key)}`);\n    }\n  }\n\n  if (snapshots.unchecked) {\n    if (snapshots.didUpdate) {\n      summary.push(\n        `${SNAPSHOT_REMOVED(\n          `${ARROW}${pluralize('snapshot', snapshots.unchecked)} removed `,\n        )}from ${pluralize(\n          'test suite',\n          snapshots.uncheckedKeysByFile.length,\n        )}.`,\n      );\n    } else {\n      summary.push(\n        `${OBSOLETE_COLOR(\n          `${ARROW}${pluralize('snapshot', snapshots.unchecked)} obsolete `,\n        )}from ${pluralize(\n          'test suite',\n          snapshots.uncheckedKeysByFile.length,\n        )}. ${SNAPSHOT_NOTE(\n          `To remove ${\n            snapshots.unchecked === 1 ? 'it' : 'them all'\n          }, ${updateCommand}.`,\n        )}`,\n      );\n    }\n\n    for (const uncheckedFile of snapshots.uncheckedKeysByFile) {\n      summary.push(\n        `  ${DOWN_ARROW}${formatTestPath(\n          globalConfig,\n          uncheckedFile.filePath,\n        )}`,\n      );\n\n      for (const key of uncheckedFile.keys) {\n        summary.push(`      ${DOT}${key}`);\n      }\n    }\n  }\n\n  return summary;\n}\n",
  "packages/jest-reporters/src/getSnapshotSummary.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { SnapshotSummary } from '@jest/test-result';\nimport type { Config } from '@jest/types';\nexport default function getSnapshotSummary(snapshots: SnapshotSummary, globalConfig: Config.GlobalConfig, updateCommand: string): Array<string>;\n",
  "packages/jest-reporters/src/getSnapshotStatus.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk from 'chalk';\nimport type {TestResult} from '@jest/test-result';\nimport {pluralize} from 'jest-util';\n\nconst ARROW = ' \\u203A ';\nconst DOT = ' \\u2022 ';\nconst FAIL_COLOR = chalk.bold.red;\nconst SNAPSHOT_ADDED = chalk.bold.green;\nconst SNAPSHOT_UPDATED = chalk.bold.green;\nconst SNAPSHOT_OUTDATED = chalk.bold.yellow;\n\nexport default function getSnapshotStatus(\n  snapshot: TestResult['snapshot'],\n  afterUpdate: boolean,\n): Array<string> {\n  const statuses = [];\n\n  if (snapshot.added) {\n    statuses.push(\n      SNAPSHOT_ADDED(\n        `${ARROW + pluralize('snapshot', snapshot.added)} written.`,\n      ),\n    );\n  }\n\n  if (snapshot.updated) {\n    statuses.push(\n      SNAPSHOT_UPDATED(\n        `${ARROW + pluralize('snapshot', snapshot.updated)} updated.`,\n      ),\n    );\n  }\n\n  if (snapshot.unmatched) {\n    statuses.push(\n      FAIL_COLOR(\n        `${ARROW + pluralize('snapshot', snapshot.unmatched)} failed.`,\n      ),\n    );\n  }\n\n  if (snapshot.unchecked) {\n    if (afterUpdate) {\n      statuses.push(\n        SNAPSHOT_UPDATED(\n          `${ARROW + pluralize('snapshot', snapshot.unchecked)} removed.`,\n        ),\n      );\n    } else {\n      statuses.push(\n        `${SNAPSHOT_OUTDATED(\n          `${ARROW + pluralize('snapshot', snapshot.unchecked)} obsolete`,\n        )}.`,\n      );\n    }\n\n    for (const key of snapshot.uncheckedKeys) {\n      statuses.push(`  ${DOT}${key}`);\n    }\n  }\n\n  if (snapshot.fileDeleted) {\n    statuses.push(SNAPSHOT_UPDATED(`${ARROW}snapshot file removed.`));\n  }\n\n  return statuses;\n}\n",
  "packages/jest-reporters/src/getSnapshotStatus.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { TestResult } from '@jest/test-result';\nexport default function getSnapshotStatus(snapshot: TestResult['snapshot'], afterUpdate: boolean): Array<string>;\n",
  "packages/jest-reporters/src/getResultHeader.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk from 'chalk';\nimport type {TestResult} from '@jest/test-result';\nimport type {Config} from '@jest/types';\nimport {formatTime} from 'jest-util';\nimport formatTestPath from './formatTestPath';\nimport printDisplayName from './printDisplayName';\n\nconst LONG_TEST_COLOR = chalk.reset.bold.bgRed;\n// Explicitly reset for these messages since they can get written out in the\n// middle of error logging\nconst FAIL_TEXT = 'FAIL';\nconst PASS_TEXT = 'PASS';\n\nconst FAIL = chalk.supportsColor\n  ? chalk.reset.inverse.bold.red(` ${FAIL_TEXT} `)\n  : FAIL_TEXT;\n\nconst PASS = chalk.supportsColor\n  ? chalk.reset.inverse.bold.green(` ${PASS_TEXT} `)\n  : PASS_TEXT;\n\nexport default function getResultHeader(\n  result: TestResult,\n  globalConfig: Config.GlobalConfig,\n  projectConfig?: Config.ProjectConfig,\n): string {\n  const testPath = result.testFilePath;\n  const status =\n    result.numFailingTests > 0 || result.testExecError ? FAIL : PASS;\n\n  const testDetail = [];\n\n  if (result.perfStats?.slow) {\n    const runTime = result.perfStats.runtime / 1000;\n\n    testDetail.push(LONG_TEST_COLOR(formatTime(runTime, 0)));\n  }\n\n  if (result.memoryUsage) {\n    const toMB = (bytes: number) => Math.floor(bytes / 1024 / 1024);\n    testDetail.push(`${toMB(result.memoryUsage)} MB heap size`);\n  }\n\n  const projectDisplayName =\n    projectConfig && projectConfig.displayName\n      ? `${printDisplayName(projectConfig)} `\n      : '';\n\n  return `${status} ${projectDisplayName}${formatTestPath(\n    projectConfig ?? globalConfig,\n    testPath,\n  )}${testDetail.length > 0 ? ` (${testDetail.join(', ')})` : ''}`;\n}\n",
  "packages/jest-reporters/src/getResultHeader.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { TestResult } from '@jest/test-result';\nimport type { Config } from '@jest/types';\nexport default function getResultHeader(result: TestResult, globalConfig: Config.GlobalConfig, projectConfig?: Config.ProjectConfig): string;\n",
  "packages/jest-reporters/src/generateEmptyCoverage.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {V8Coverage} from 'collect-v8-coverage';\nimport * as fs from 'graceful-fs';\nimport {type FileCoverage, createFileCoverage} from 'istanbul-lib-coverage';\nimport {readInitialCoverage} from 'istanbul-lib-instrument';\nimport {createScriptTransformer, shouldInstrument} from '@jest/transform';\nimport type {Config} from '@jest/types';\n\ntype SingleV8Coverage = V8Coverage[number];\n\nexport type CoverageWorkerResult =\n  | {\n      kind: 'BabelCoverage';\n      coverage: FileCoverage;\n    }\n  | {\n      kind: 'V8Coverage';\n      result: SingleV8Coverage;\n    };\n\nexport default async function generateEmptyCoverage(\n  source: string,\n  filename: string,\n  globalConfig: Config.GlobalConfig,\n  config: Config.ProjectConfig,\n  changedFiles?: Set<string>,\n  sourcesRelatedToTestsInChangedFiles?: Set<string>,\n): Promise<CoverageWorkerResult | null> {\n  const coverageOptions = {\n    changedFiles,\n    collectCoverage: globalConfig.collectCoverage,\n    collectCoverageFrom: globalConfig.collectCoverageFrom,\n    coverageProvider: globalConfig.coverageProvider,\n    sourcesRelatedToTestsInChangedFiles,\n  };\n  let coverageWorkerResult: CoverageWorkerResult | null = null;\n  if (shouldInstrument(filename, coverageOptions, config)) {\n    if (coverageOptions.coverageProvider === 'v8') {\n      const stat = fs.statSync(filename);\n      return {\n        kind: 'V8Coverage',\n        result: {\n          functions: [\n            {\n              functionName: '(empty-report)',\n              isBlockCoverage: true,\n              ranges: [\n                {\n                  count: 0,\n                  endOffset: stat.size,\n                  startOffset: 0,\n                },\n              ],\n            },\n          ],\n          scriptId: '0',\n          url: filename,\n        },\n      };\n    }\n\n    const scriptTransformer = await createScriptTransformer(config);\n\n    // Transform file with instrumentation to make sure initial coverage data is well mapped to original code.\n    const {code} = await scriptTransformer.transformSourceAsync(\n      filename,\n      source,\n      {\n        instrument: true,\n        supportsDynamicImport: true,\n        supportsExportNamespaceFrom: true,\n        supportsStaticESM: true,\n        supportsTopLevelAwait: true,\n      },\n    );\n    // TODO: consider passing AST\n    const extracted = readInitialCoverage(code);\n    // Check extracted initial coverage is not null, this can happen when using /* istanbul ignore file */\n    if (extracted) {\n      coverageWorkerResult = {\n        coverage: createFileCoverage(extracted.coverageData),\n        kind: 'BabelCoverage',\n      };\n    }\n  }\n  return coverageWorkerResult;\n}\n",
  "packages/jest-reporters/src/generateEmptyCoverage.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { V8Coverage } from 'collect-v8-coverage';\nimport { type FileCoverage } from 'istanbul-lib-coverage';\nimport type { Config } from '@jest/types';\ntype SingleV8Coverage = V8Coverage[number];\nexport type CoverageWorkerResult = {\n    kind: 'BabelCoverage';\n    coverage: FileCoverage;\n} | {\n    kind: 'V8Coverage';\n    result: SingleV8Coverage;\n};\nexport default function generateEmptyCoverage(source: string, filename: string, globalConfig: Config.GlobalConfig, config: Config.ProjectConfig, changedFiles?: Set<string>, sourcesRelatedToTestsInChangedFiles?: Set<string>): Promise<CoverageWorkerResult | null>;\nexport {};\n",
  "packages/jest-reporters/src/formatTestPath.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport chalk from 'chalk';\nimport slash from 'slash';\nimport type {Config} from '@jest/types';\nimport relativePath from './relativePath';\n\nexport default function formatTestPath(\n  config: Config.GlobalConfig | Config.ProjectConfig,\n  testPath: string,\n): string {\n  const {dirname, basename} = relativePath(config, testPath);\n  return slash(chalk.dim(dirname + path.sep) + chalk.bold(basename));\n}\n",
  "packages/jest-reporters/src/formatTestPath.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config } from '@jest/types';\nexport default function formatTestPath(config: Config.GlobalConfig | Config.ProjectConfig, testPath: string): string;\n",
  "packages/jest-reporters/src/VerboseReporter.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {WriteStream} from 'tty';\nimport chalk from 'chalk';\nimport type {\n  AggregatedResult,\n  AssertionResult,\n  Suite,\n  Test,\n  TestResult,\n} from '@jest/test-result';\nimport type {Config} from '@jest/types';\nimport {formatTime, specialChars} from 'jest-util';\nimport DefaultReporter from './DefaultReporter';\n\nconst {ICONS} = specialChars;\n\nexport default class VerboseReporter extends DefaultReporter {\n  protected override _globalConfig: Config.GlobalConfig;\n\n  static override readonly filename = __filename;\n\n  constructor(globalConfig: Config.GlobalConfig) {\n    super(globalConfig);\n    this._globalConfig = globalConfig;\n  }\n\n  // Verbose mode is for debugging. Buffering of output is undesirable.\n  // See https://github.com/jestjs/jest/issues/8208\n  protected override __wrapStdio(\n    stream: NodeJS.WritableStream | WriteStream,\n  ): void {\n    const write = stream.write.bind(stream);\n\n    stream.write = (chunk: string) => {\n      this.__clearStatus();\n      write(chunk);\n      this.__printStatus();\n      return true;\n    };\n  }\n\n  static filterTestResults(\n    testResults: Array<AssertionResult>,\n  ): Array<AssertionResult> {\n    return testResults.filter(({status}) => status !== 'pending');\n  }\n\n  static groupTestsBySuites(testResults: Array<AssertionResult>): Suite {\n    const root: Suite = {suites: [], tests: [], title: ''};\n    for (const testResult of testResults) {\n      let targetSuite = root;\n\n      // Find the target suite for this test,\n      // creating nested suites as necessary.\n      for (const title of testResult.ancestorTitles) {\n        let matchingSuite = targetSuite.suites.find(s => s.title === title);\n        if (!matchingSuite) {\n          matchingSuite = {suites: [], tests: [], title};\n          targetSuite.suites.push(matchingSuite);\n        }\n        targetSuite = matchingSuite;\n      }\n\n      targetSuite.tests.push(testResult);\n    }\n    return root;\n  }\n\n  override onTestResult(\n    test: Test,\n    result: TestResult,\n    aggregatedResults: AggregatedResult,\n  ): void {\n    super.testFinished(test.context.config, result, aggregatedResults);\n    if (!result.skipped) {\n      this.printTestFileHeader(\n        result.testFilePath,\n        test.context.config,\n        result,\n      );\n      if (!result.testExecError && !result.skipped) {\n        this._logTestResults(result.testResults);\n      }\n      this.printTestFileFailureMessage(\n        result.testFilePath,\n        test.context.config,\n        result,\n      );\n    }\n    super.forceFlushBufferedOutput();\n  }\n\n  private _logTestResults(testResults: Array<AssertionResult>) {\n    this._logSuite(VerboseReporter.groupTestsBySuites(testResults), 0);\n    this._logLine();\n  }\n\n  private _logSuite(suite: Suite, indentLevel: number) {\n    if (suite.title) {\n      this._logLine(suite.title, indentLevel);\n    }\n\n    this._logTests(suite.tests, indentLevel + 1);\n\n    for (const innerSuite of suite.suites) {\n      this._logSuite(innerSuite, indentLevel + 1);\n    }\n  }\n\n  private _getIcon(status: string) {\n    if (status === 'failed') {\n      return chalk.red(ICONS.failed);\n    } else if (status === 'pending') {\n      return chalk.yellow(ICONS.pending);\n    } else if (status === 'todo') {\n      return chalk.magenta(ICONS.todo);\n    } else {\n      return chalk.green(ICONS.success);\n    }\n  }\n\n  private _logTest(test: AssertionResult, indentLevel: number) {\n    const status = this._getIcon(test.status);\n    const time = test.duration\n      ? ` (${formatTime(Math.round(test.duration))})`\n      : '';\n    this._logLine(`${status} ${chalk.dim(test.title + time)}`, indentLevel);\n  }\n\n  private _logTests(tests: Array<AssertionResult>, indentLevel: number) {\n    if (this._globalConfig.expand) {\n      for (const test of tests) this._logTest(test, indentLevel);\n    } else {\n      const summedTests = tests.reduce<{\n        pending: Array<AssertionResult>;\n        todo: Array<AssertionResult>;\n      }>(\n        (result, test) => {\n          if (test.status === 'pending') {\n            result.pending.push(test);\n          } else if (test.status === 'todo') {\n            result.todo.push(test);\n          } else {\n            this._logTest(test, indentLevel);\n          }\n\n          return result;\n        },\n        {pending: [], todo: []},\n      );\n\n      const logTodoOrPendingTest = this._logTodoOrPendingTest(indentLevel);\n      if (summedTests.pending.length > 0) {\n        for (const test of summedTests.pending) logTodoOrPendingTest(test);\n      }\n\n      if (summedTests.todo.length > 0) {\n        for (const test of summedTests.todo) logTodoOrPendingTest(test);\n      }\n    }\n  }\n\n  private _logTodoOrPendingTest(indentLevel: number) {\n    return (test: AssertionResult): void => {\n      const printedTestStatus =\n        test.status === 'pending' ? 'skipped' : test.status;\n      const icon = this._getIcon(test.status);\n      const text = chalk.dim(`${printedTestStatus} ${test.title}`);\n      this._logLine(`${icon} ${text}`, indentLevel);\n    };\n  }\n\n  private _logLine(str?: string, indentLevel?: number) {\n    const indentation = '  '.repeat(indentLevel || 0);\n    this.log(indentation + (str || ''));\n  }\n}\n",
  "packages/jest-reporters/src/VerboseReporter.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { WriteStream } from 'tty';\nimport type { AggregatedResult, AssertionResult, Suite, Test, TestResult } from '@jest/test-result';\nimport type { Config } from '@jest/types';\nimport DefaultReporter from './DefaultReporter';\nexport default class VerboseReporter extends DefaultReporter {\n    protected _globalConfig: Config.GlobalConfig;\n    static readonly filename: string;\n    constructor(globalConfig: Config.GlobalConfig);\n    protected __wrapStdio(stream: NodeJS.WritableStream | WriteStream): void;\n    static filterTestResults(testResults: Array<AssertionResult>): Array<AssertionResult>;\n    static groupTestsBySuites(testResults: Array<AssertionResult>): Suite;\n    onTestResult(test: Test, result: TestResult, aggregatedResults: AggregatedResult): void;\n    private _logTestResults;\n    private _logSuite;\n    private _getIcon;\n    private _logTest;\n    private _logTests;\n    private _logTodoOrPendingTest;\n    private _logLine;\n}\n",
  "packages/jest-reporters/src/SummaryReporter.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk from 'chalk';\nimport type {\n  AggregatedResult,\n  SnapshotSummary,\n  TestContext,\n} from '@jest/test-result';\nimport type {Config} from '@jest/types';\nimport BaseReporter from './BaseReporter';\nimport getResultHeader from './getResultHeader';\nimport getSnapshotSummary from './getSnapshotSummary';\nimport getSummary from './getSummary';\nimport type {ReporterOnStartOptions} from './types';\n\nconst NPM_EVENTS = new Set([\n  'prepublish',\n  'publish',\n  'postpublish',\n  'preinstall',\n  'install',\n  'postinstall',\n  'preuninstall',\n  'uninstall',\n  'postuninstall',\n  'preversion',\n  'version',\n  'postversion',\n  'pretest',\n  'test',\n  'posttest',\n  'prestop',\n  'stop',\n  'poststop',\n  'prestart',\n  'start',\n  'poststart',\n  'prerestart',\n  'restart',\n  'postrestart',\n]);\n\nconst {npm_config_user_agent, npm_lifecycle_event, npm_lifecycle_script} =\n  process.env;\n\nexport type SummaryReporterOptions = {\n  summaryThreshold?: number;\n};\n\nexport default class SummaryReporter extends BaseReporter {\n  private _estimatedTime: number;\n  private readonly _globalConfig: Config.GlobalConfig;\n  private readonly _summaryThreshold: number;\n\n  static readonly filename = __filename;\n\n  constructor(\n    globalConfig: Config.GlobalConfig,\n    options?: SummaryReporterOptions,\n  ) {\n    super();\n    this._globalConfig = globalConfig;\n    this._estimatedTime = 0;\n    this._validateOptions(options);\n    this._summaryThreshold = options?.summaryThreshold ?? 20;\n  }\n\n  private _validateOptions(options?: SummaryReporterOptions) {\n    if (\n      options?.summaryThreshold &&\n      typeof options.summaryThreshold !== 'number'\n    ) {\n      throw new TypeError('The option summaryThreshold should be a number');\n    }\n  }\n\n  // If we write more than one character at a time it is possible that\n  // Node.js exits in the middle of printing the result. This was first observed\n  // in Node.js 0.10 and still persists in Node.js 6.7+.\n  // Let's print the test failure summary character by character which is safer\n  // when hundreds of tests are failing.\n  private _write(string: string) {\n    for (let i = 0; i < string.length; i++) {\n      process.stderr.write(string.charAt(i));\n    }\n  }\n\n  override onRunStart(\n    aggregatedResults: AggregatedResult,\n    options: ReporterOnStartOptions,\n  ): void {\n    super.onRunStart(aggregatedResults, options);\n    this._estimatedTime = options.estimatedTime;\n  }\n\n  override onRunComplete(\n    testContexts: Set<TestContext>,\n    aggregatedResults: AggregatedResult,\n  ): void {\n    const {numTotalTestSuites, testResults, wasInterrupted} = aggregatedResults;\n    if (numTotalTestSuites) {\n      const lastResult = testResults.at(-1);\n      // Print a newline if the last test did not fail to line up newlines\n      // similar to when an error would have been thrown in the test.\n      if (\n        !this._globalConfig.verbose &&\n        lastResult &&\n        !lastResult.numFailingTests &&\n        !lastResult.testExecError\n      ) {\n        this.log('');\n      }\n\n      this._printSummary(aggregatedResults, this._globalConfig);\n      this._printSnapshotSummary(\n        aggregatedResults.snapshot,\n        this._globalConfig,\n      );\n\n      let message = getSummary(aggregatedResults, {\n        estimatedTime: this._estimatedTime,\n        seed: this._globalConfig.seed,\n        showSeed: this._globalConfig.showSeed,\n      });\n\n      if (!this._globalConfig.silent) {\n        message += `\\n${\n          wasInterrupted\n            ? chalk.bold.red('Test run was interrupted.')\n            : this._getTestSummary(testContexts, this._globalConfig)\n        }`;\n      }\n      this.log(message);\n    }\n  }\n\n  private _printSnapshotSummary(\n    snapshots: SnapshotSummary,\n    globalConfig: Config.GlobalConfig,\n  ) {\n    if (\n      snapshots.added ||\n      snapshots.filesRemoved ||\n      snapshots.unchecked ||\n      snapshots.unmatched ||\n      snapshots.updated\n    ) {\n      let updateCommand;\n      const event = npm_lifecycle_event || '';\n      const prefix = NPM_EVENTS.has(event) ? '' : 'run ';\n      const isYarn =\n        typeof npm_config_user_agent === 'string' &&\n        npm_config_user_agent.includes('yarn');\n      const client = isYarn ? 'yarn' : 'npm';\n      const scriptUsesJest =\n        typeof npm_lifecycle_script === 'string' &&\n        npm_lifecycle_script.includes('jest');\n\n      if (globalConfig.watch || globalConfig.watchAll) {\n        updateCommand = 'press `u`';\n      } else if (event && scriptUsesJest) {\n        updateCommand = `run \\`${`${client} ${prefix}${event}${\n          isYarn ? '' : ' --'\n        }`} -u\\``;\n      } else {\n        updateCommand = 're-run jest with `-u`';\n      }\n\n      const snapshotSummary = getSnapshotSummary(\n        snapshots,\n        globalConfig,\n        updateCommand,\n      );\n      for (const summary of snapshotSummary) this.log(summary);\n\n      this.log(''); // print empty line\n    }\n  }\n\n  private _printSummary(\n    aggregatedResults: AggregatedResult,\n    globalConfig: Config.GlobalConfig,\n  ) {\n    // If there were any failing tests and there was a large number of tests\n    // executed, re-print the failing results at the end of execution output.\n    const failedTests = aggregatedResults.numFailedTests;\n    const runtimeErrors = aggregatedResults.numRuntimeErrorTestSuites;\n    if (\n      failedTests + runtimeErrors > 0 &&\n      aggregatedResults.numTotalTestSuites > this._summaryThreshold\n    ) {\n      this.log(chalk.bold('Summary of all failing tests'));\n      for (const testResult of aggregatedResults.testResults) {\n        const {failureMessage} = testResult;\n        if (failureMessage) {\n          this._write(\n            `${getResultHeader(testResult, globalConfig)}\\n${failureMessage}\\n`,\n          );\n        }\n      }\n      this.log(''); // print empty line\n    }\n  }\n\n  private _getTestSummary(\n    testContexts: Set<TestContext>,\n    globalConfig: Config.GlobalConfig,\n  ) {\n    const testPathPatterns = globalConfig.testPathPatterns;\n\n    const getMatchingTestsInfo = () => {\n      const prefix = globalConfig.findRelatedTests\n        ? ' related to files matching '\n        : ' matching ';\n\n      return chalk.dim(prefix) + testPathPatterns.toPretty();\n    };\n\n    let testInfo = '';\n\n    if (globalConfig.runTestsByPath) {\n      testInfo = chalk.dim(' within paths');\n    } else if (globalConfig.onlyChanged) {\n      testInfo = chalk.dim(' related to changed files');\n    } else if (testPathPatterns.isSet()) {\n      testInfo = getMatchingTestsInfo();\n    }\n\n    let nameInfo = '';\n\n    if (globalConfig.runTestsByPath) {\n      nameInfo = ` ${globalConfig.nonFlagArgs.map(p => `\"${p}\"`).join(', ')}`;\n    } else if (globalConfig.testNamePattern) {\n      nameInfo = `${chalk.dim(' with tests matching ')}\"${\n        globalConfig.testNamePattern\n      }\"`;\n    }\n\n    const contextInfo =\n      testContexts.size > 1\n        ? chalk.dim(' in ') + testContexts.size + chalk.dim(' projects')\n        : '';\n\n    return (\n      chalk.dim('Ran all test suites') +\n      testInfo +\n      nameInfo +\n      contextInfo +\n      chalk.dim('.')\n    );\n  }\n}\n",
  "packages/jest-reporters/src/SummaryReporter.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { AggregatedResult, TestContext } from '@jest/test-result';\nimport type { Config } from '@jest/types';\nimport BaseReporter from './BaseReporter';\nimport type { ReporterOnStartOptions } from './types';\nexport type SummaryReporterOptions = {\n    summaryThreshold?: number;\n};\nexport default class SummaryReporter extends BaseReporter {\n    private _estimatedTime;\n    private readonly _globalConfig;\n    private readonly _summaryThreshold;\n    static readonly filename: string;\n    constructor(globalConfig: Config.GlobalConfig, options?: SummaryReporterOptions);\n    private _validateOptions;\n    private _write;\n    onRunStart(aggregatedResults: AggregatedResult, options: ReporterOnStartOptions): void;\n    onRunComplete(testContexts: Set<TestContext>, aggregatedResults: AggregatedResult): void;\n    private _printSnapshotSummary;\n    private _printSummary;\n    private _getTestSummary;\n}\n",
  "packages/jest-reporters/src/Status.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk from 'chalk';\nimport stringLength from 'string-length';\nimport type {\n  AggregatedResult,\n  Test,\n  TestCaseResult,\n  TestResult,\n} from '@jest/test-result';\nimport type {Config} from '@jest/types';\nimport getSummary from './getSummary';\nimport printDisplayName from './printDisplayName';\nimport trimAndFormatPath from './trimAndFormatPath';\nimport type {ReporterOnStartOptions} from './types';\nimport wrapAnsiString from './wrapAnsiString';\n\nconst RUNNING_TEXT = ' RUNS ';\nconst RUNNING = `${chalk.reset.inverse.yellow.bold(RUNNING_TEXT)} `;\n\n/**\n * This class is a perf optimization for sorting the list of currently\n * running tests. It tries to keep tests in the same positions without\n * shifting the whole list.\n */\nclass CurrentTestList {\n  private _array: Array<{\n    testPath: string;\n    config: Config.ProjectConfig;\n  } | null>;\n\n  constructor() {\n    this._array = [];\n  }\n\n  add(testPath: string, config: Config.ProjectConfig) {\n    const index = this._array.indexOf(null);\n    const record = {config, testPath};\n    if (index === -1) {\n      this._array.push(record);\n    } else {\n      this._array[index] = record;\n    }\n  }\n\n  delete(testPath: string) {\n    const record = this._array.find(\n      record => record !== null && record.testPath === testPath,\n    );\n    this._array[this._array.indexOf(record || null)] = null;\n  }\n\n  get() {\n    return this._array;\n  }\n}\n\ntype Cache = {\n  content: string;\n  clear: string;\n};\n\n/**\n * A class that generates the CLI status of currently running tests\n * and also provides an ANSI escape sequence to remove status lines\n * from the terminal.\n */\nexport default class Status {\n  private _cache: Cache | null;\n  private _callback?: () => void;\n  private readonly _currentTests: CurrentTestList;\n  private _currentTestCases: Array<{\n    test: Test;\n    testCaseResult: TestCaseResult;\n  }>;\n  private _done: boolean;\n  private _emitScheduled: boolean;\n  private _estimatedTime: number;\n  private _interval?: NodeJS.Timeout;\n  private _aggregatedResults?: AggregatedResult;\n  private _showStatus: boolean;\n\n  constructor(private readonly _globalConfig: Config.GlobalConfig) {\n    this._cache = null;\n    this._currentTests = new CurrentTestList();\n    this._currentTestCases = [];\n    this._done = false;\n    this._emitScheduled = false;\n    this._estimatedTime = 0;\n    this._showStatus = false;\n  }\n\n  onChange(callback: () => void): void {\n    this._callback = callback;\n  }\n\n  runStarted(\n    aggregatedResults: AggregatedResult,\n    options: ReporterOnStartOptions,\n  ): void {\n    this._estimatedTime = (options && options.estimatedTime) || 0;\n    this._showStatus = options && options.showStatus;\n    this._interval = setInterval(() => this._tick(), 1000);\n    this._aggregatedResults = aggregatedResults;\n    this._debouncedEmit();\n  }\n\n  runFinished(): void {\n    this._done = true;\n    if (this._interval) clearInterval(this._interval);\n    this._emit();\n  }\n\n  addTestCaseResult(test: Test, testCaseResult: TestCaseResult): void {\n    this._currentTestCases.push({test, testCaseResult});\n    if (this._showStatus) {\n      this._debouncedEmit();\n    } else {\n      this._emit();\n    }\n  }\n\n  testStarted(testPath: string, config: Config.ProjectConfig): void {\n    this._currentTests.add(testPath, config);\n    if (this._showStatus) {\n      this._debouncedEmit();\n    } else {\n      this._emit();\n    }\n  }\n\n  testFinished(\n    _config: Config.ProjectConfig,\n    testResult: TestResult,\n    aggregatedResults: AggregatedResult,\n  ): void {\n    const {testFilePath} = testResult;\n    this._aggregatedResults = aggregatedResults;\n    this._currentTests.delete(testFilePath);\n    this._currentTestCases = this._currentTestCases.filter(({test}) => {\n      if (_config !== test.context.config) {\n        return true;\n      }\n      return test.path !== testFilePath;\n    });\n    this._debouncedEmit();\n  }\n\n  get(): Cache {\n    if (this._cache) {\n      return this._cache;\n    }\n\n    if (this._done) {\n      return {clear: '', content: ''};\n    }\n\n    const width = process.stdout.columns;\n    let content = '\\n';\n    for (const record of this._currentTests.get()) {\n      if (record) {\n        const {config, testPath} = record;\n\n        const projectDisplayName = config.displayName\n          ? `${printDisplayName(config)} `\n          : '';\n        const prefix = RUNNING + projectDisplayName;\n\n        content += `${wrapAnsiString(\n          prefix +\n            trimAndFormatPath(stringLength(prefix), config, testPath, width),\n          width,\n        )}\\n`;\n      }\n    }\n\n    if (this._showStatus && this._aggregatedResults) {\n      content += `\\n${getSummary(this._aggregatedResults, {\n        currentTestCases: this._currentTestCases,\n        estimatedTime: this._estimatedTime,\n        roundTime: true,\n        seed: this._globalConfig.seed,\n        showSeed: this._globalConfig.showSeed,\n        width,\n      })}`;\n    }\n\n    let height = 0;\n\n    for (const char of content) {\n      if (char === '\\n') {\n        height++;\n      }\n    }\n\n    const clear = '\\r\\u001B[K\\r\\u001B[1A'.repeat(height);\n    return (this._cache = {clear, content});\n  }\n\n  private _emit() {\n    this._cache = null;\n    if (this._callback) this._callback();\n  }\n\n  private _debouncedEmit() {\n    if (!this._emitScheduled) {\n      // Perf optimization to avoid two separate renders When\n      // one test finishes and another test starts executing.\n      this._emitScheduled = true;\n      setTimeout(() => {\n        this._emit();\n        this._emitScheduled = false;\n      }, 100);\n    }\n  }\n\n  private _tick() {\n    this._debouncedEmit();\n  }\n}\n",
  "packages/jest-reporters/src/Status.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { AggregatedResult, Test, TestCaseResult, TestResult } from '@jest/test-result';\nimport type { Config } from '@jest/types';\nimport type { ReporterOnStartOptions } from './types';\ntype Cache = {\n    content: string;\n    clear: string;\n};\n/**\n * A class that generates the CLI status of currently running tests\n * and also provides an ANSI escape sequence to remove status lines\n * from the terminal.\n */\nexport default class Status {\n    private readonly _globalConfig;\n    private _cache;\n    private _callback?;\n    private readonly _currentTests;\n    private _currentTestCases;\n    private _done;\n    private _emitScheduled;\n    private _estimatedTime;\n    private _interval?;\n    private _aggregatedResults?;\n    private _showStatus;\n    constructor(_globalConfig: Config.GlobalConfig);\n    onChange(callback: () => void): void;\n    runStarted(aggregatedResults: AggregatedResult, options: ReporterOnStartOptions): void;\n    runFinished(): void;\n    addTestCaseResult(test: Test, testCaseResult: TestCaseResult): void;\n    testStarted(testPath: string, config: Config.ProjectConfig): void;\n    testFinished(_config: Config.ProjectConfig, testResult: TestResult, aggregatedResults: AggregatedResult): void;\n    get(): Cache;\n    private _emit;\n    private _debouncedEmit;\n    private _tick;\n}\nexport {};\n",
  "packages/jest-reporters/src/NotifyReporter.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport * as util from 'util';\nimport exit from 'exit-x';\nimport type {AggregatedResult, TestContext} from '@jest/test-result';\nimport type {Config} from '@jest/types';\nimport {pluralize} from 'jest-util';\nimport BaseReporter from './BaseReporter';\nimport type {ReporterContext} from './types';\n\nconst isDarwin = process.platform === 'darwin';\n\nconst icon = path.resolve(__dirname, '../assets/jest_logo.png');\n\nexport default class NotifyReporter extends BaseReporter {\n  private readonly _notifier = loadNotifier();\n  private readonly _globalConfig: Config.GlobalConfig;\n  private readonly _context: ReporterContext;\n\n  static readonly filename = __filename;\n\n  constructor(globalConfig: Config.GlobalConfig, context: ReporterContext) {\n    super();\n    this._globalConfig = globalConfig;\n    this._context = context;\n  }\n\n  override onRunComplete(\n    testContexts: Set<TestContext>,\n    result: AggregatedResult,\n  ): void {\n    const success =\n      result.numFailedTests === 0 && result.numRuntimeErrorTestSuites === 0;\n\n    const firstContext = testContexts.values().next();\n\n    const hasteFS =\n      firstContext && firstContext.value && firstContext.value.hasteFS;\n\n    let packageName;\n    if (hasteFS == null) {\n      packageName = this._globalConfig.rootDir;\n    } else {\n      // assuming root package.json is the first one\n      const [filePath] = hasteFS.matchFiles('package.json');\n\n      packageName =\n        filePath == null\n          ? this._globalConfig.rootDir\n          : hasteFS.getModuleName(filePath);\n    }\n\n    packageName = packageName == null ? '' : `${packageName} - `;\n\n    const notifyMode = this._globalConfig.notifyMode;\n    const statusChanged =\n      this._context.previousSuccess !== success || this._context.firstRun;\n    const testsHaveRun = result.numTotalTests !== 0;\n\n    if (\n      testsHaveRun &&\n      success &&\n      (notifyMode === 'always' ||\n        notifyMode === 'success' ||\n        notifyMode === 'success-change' ||\n        (notifyMode === 'change' && statusChanged) ||\n        (notifyMode === 'failure-change' && statusChanged))\n    ) {\n      const title = util.format('%s%d%% Passed', packageName, 100);\n      const message = `${isDarwin ? '\\u2705 ' : ''}${pluralize(\n        'test',\n        result.numPassedTests,\n      )} passed`;\n\n      this._notifier.notify({\n        hint: 'int:transient:1',\n        icon,\n        message,\n        timeout: false,\n        title,\n      });\n    } else if (\n      testsHaveRun &&\n      !success &&\n      (notifyMode === 'always' ||\n        notifyMode === 'failure' ||\n        notifyMode === 'failure-change' ||\n        (notifyMode === 'change' && statusChanged) ||\n        (notifyMode === 'success-change' && statusChanged))\n    ) {\n      const failed = result.numFailedTests / result.numTotalTests;\n\n      const title = util.format(\n        '%s%d%% Failed',\n        packageName,\n        Math.ceil(Number.isNaN(failed) ? 0 : failed * 100),\n      );\n      const message = util.format(\n        `${isDarwin ? '\\u26D4\\uFE0F ' : ''}%d of %d tests failed`,\n        result.numFailedTests,\n        result.numTotalTests,\n      );\n\n      const watchMode = this._globalConfig.watch || this._globalConfig.watchAll;\n      const restartAnswer = 'Run again';\n      const quitAnswer = 'Exit tests';\n\n      if (watchMode) {\n        this._notifier.notify(\n          {\n            // @ts-expect-error - not all options are supported by all systems (specifically `actions` and `hint`)\n            actions: [restartAnswer, quitAnswer],\n            closeLabel: 'Close',\n            hint: 'int:transient:1',\n            icon,\n            message,\n            timeout: false,\n            title,\n          },\n          (err, _, metadata) => {\n            if (err || !metadata) {\n              return;\n            }\n            if (metadata.activationValue === quitAnswer) {\n              exit(0);\n              return;\n            }\n            if (\n              metadata.activationValue === restartAnswer &&\n              this._context.startRun\n            ) {\n              this._context.startRun(this._globalConfig);\n            }\n          },\n        );\n      } else {\n        this._notifier.notify({\n          hint: 'int:transient:1',\n          icon,\n          message,\n          timeout: false,\n          title,\n        });\n      }\n    }\n\n    this._context.previousSuccess = success;\n    this._context.firstRun = false;\n  }\n}\n\nfunction loadNotifier(): typeof import('node-notifier') {\n  try {\n    return require('node-notifier');\n  } catch (error: any) {\n    if (error.code !== 'MODULE_NOT_FOUND') {\n      throw error;\n    }\n\n    throw new Error(\n      'notify reporter requires optional peer dependency \"node-notifier\" but it was not found',\n    );\n  }\n}\n",
  "packages/jest-reporters/src/NotifyReporter.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { AggregatedResult, TestContext } from '@jest/test-result';\nimport type { Config } from '@jest/types';\nimport BaseReporter from './BaseReporter';\nimport type { ReporterContext } from './types';\nexport default class NotifyReporter extends BaseReporter {\n    private readonly _notifier;\n    private readonly _globalConfig;\n    private readonly _context;\n    static readonly filename: string;\n    constructor(globalConfig: Config.GlobalConfig, context: ReporterContext);\n    onRunComplete(testContexts: Set<TestContext>, result: AggregatedResult): void;\n}\n",
  "packages/jest-reporters/src/GitHubActionsReporter.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {stripVTControlCharacters as stripAnsi} from 'util';\nimport chalk from 'chalk';\nimport type {\n  AggregatedResult,\n  AssertionResult,\n  Status,\n  Test,\n  TestContext,\n  TestResult,\n} from '@jest/test-result';\nimport type {Config} from '@jest/types';\nimport {\n  formatPath,\n  getStackTraceLines,\n  getTopFrame,\n  separateMessageFromStack,\n} from 'jest-message-util';\nimport {specialChars} from 'jest-util';\nimport BaseReporter from './BaseReporter';\n\ntype AnnotationOptions = {\n  file?: string;\n  line?: number | string;\n  message: string;\n  title: string;\n  type: 'error' | 'warning';\n};\n\nconst titleSeparator = ' \\u203A ';\nconst ICONS = specialChars.ICONS;\n\ntype PerformanceInfo = {\n  end: number;\n  runtime: number;\n  slow: boolean;\n  start: number;\n};\n\ntype ResultTreeLeaf = {\n  name: string;\n  status: Status;\n  duration: number;\n  children: Array<never>;\n};\n\ntype ResultTreeNode = {\n  name: string;\n  passed: boolean;\n  children: Array<ResultTreeNode | ResultTreeLeaf>;\n};\n\ntype ResultTree = {\n  children: Array<ResultTreeLeaf | ResultTreeNode>;\n  name: string;\n  passed: boolean;\n  performanceInfo: PerformanceInfo;\n};\n\nexport default class GitHubActionsReporter extends BaseReporter {\n  static readonly filename = __filename;\n  private readonly options: {silent: boolean};\n\n  constructor(\n    _globalConfig: Config.GlobalConfig,\n    reporterOptions: {silent?: boolean} = {},\n  ) {\n    super();\n    this.options = {\n      silent:\n        typeof reporterOptions.silent === 'boolean'\n          ? reporterOptions.silent\n          : true,\n    };\n  }\n\n  override onTestResult(\n    test: Test,\n    testResult: TestResult,\n    aggregatedResults: AggregatedResult,\n  ): void {\n    this.generateAnnotations(test, testResult);\n    if (!this.options.silent) {\n      this.printFullResult(test.context, testResult);\n    }\n    if (this.isLastTestSuite(aggregatedResults)) {\n      this.printFailedTestLogs(test, aggregatedResults);\n    }\n  }\n\n  private generateAnnotations(\n    {context}: Test,\n    {testResults}: TestResult,\n  ): void {\n    for (const result of testResults) {\n      const title = [...result.ancestorTitles, result.title].join(\n        titleSeparator,\n      );\n\n      if (result.retryReasons)\n        for (const [index, retryReason] of result.retryReasons.entries()) {\n          this.#createAnnotation({\n            ...this.#getMessageDetails(retryReason, context.config),\n            title: `RETRY ${index + 1}: ${title}`,\n            type: 'warning',\n          });\n        }\n\n      for (const failureMessage of result.failureMessages) {\n        this.#createAnnotation({\n          ...this.#getMessageDetails(failureMessage, context.config),\n          title,\n          type: 'error',\n        });\n      }\n    }\n  }\n\n  #getMessageDetails(failureMessage: string, config: Config.ProjectConfig) {\n    const {message, stack} = separateMessageFromStack(failureMessage);\n\n    const stackLines = getStackTraceLines(stack);\n    const topFrame = getTopFrame(stackLines);\n\n    const normalizedStackLines = stackLines.map(line =>\n      formatPath(line, config),\n    );\n    const messageText = [message, ...normalizedStackLines].join('\\n');\n\n    return {\n      file: topFrame?.file,\n      line: topFrame?.line,\n      message: messageText,\n    };\n  }\n\n  #createAnnotation({file, line, message, title, type}: AnnotationOptions) {\n    message = stripAnsi(\n      // copied from: https://github.com/actions/toolkit/blob/main/packages/core/src/command.ts\n      message\n        .replaceAll('%', '%25')\n        .replaceAll('\\r', '%0D')\n        .replaceAll('\\n', '%0A'),\n    );\n\n    this.log(\n      `\\n::${type} file=${file},line=${line},title=${title}::${message}`,\n    );\n  }\n\n  private isLastTestSuite(results: AggregatedResult): boolean {\n    const passedTestSuites = results.numPassedTestSuites;\n    const failedTestSuites = results.numFailedTestSuites;\n    const totalTestSuites = results.numTotalTestSuites;\n    const computedTotal = passedTestSuites + failedTestSuites;\n    if (computedTotal < totalTestSuites) {\n      return false;\n    } else if (computedTotal === totalTestSuites) {\n      return true;\n    } else {\n      throw new Error(\n        `Sum(${computedTotal}) of passed (${passedTestSuites}) and failed (${failedTestSuites}) test suites is greater than the total number of test suites (${totalTestSuites}). Please report the bug at https://github.com/jestjs/jest/issues`,\n      );\n    }\n  }\n\n  private printFullResult(context: TestContext, results: TestResult): void {\n    const rootDir = context.config.rootDir;\n    let testDir = results.testFilePath.replace(rootDir, '');\n    testDir = testDir.slice(1);\n    const resultTree = this.getResultTree(\n      results.testResults,\n      testDir,\n      results.perfStats,\n    );\n    this.printResultTree(resultTree);\n  }\n\n  private arrayEqual(a1: Array<any>, a2: Array<any>): boolean {\n    if (a1.length !== a2.length) {\n      return false;\n    }\n    for (const [index, element] of a1.entries()) {\n      if (element !== a2[index]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private arrayChild(a1: Array<any>, a2: Array<any>): boolean {\n    if (a1.length - a2.length !== 1) {\n      return false;\n    }\n    for (const [index, element] of a2.entries()) {\n      if (element !== a1[index]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private getResultTree(\n    suiteResult: Array<AssertionResult>,\n    testPath: string,\n    suitePerf: PerformanceInfo,\n  ): ResultTree {\n    const root: ResultTree = {\n      children: [],\n      name: testPath,\n      passed: true,\n      performanceInfo: suitePerf,\n    };\n    const branches: Array<Array<string>> = [];\n    for (const element of suiteResult) {\n      if (element.ancestorTitles.length === 0) {\n        if (element.status === 'failed') {\n          root.passed = false;\n        }\n        const duration = element.duration || 1;\n        root.children.push({\n          children: [],\n          duration,\n          name: element.title,\n          status: element.status,\n        });\n      } else {\n        let alreadyInserted = false;\n        for (const branch of branches) {\n          if (this.arrayEqual(branch, element.ancestorTitles.slice(0, 1))) {\n            alreadyInserted = true;\n            break;\n          }\n        }\n        if (!alreadyInserted) {\n          branches.push(element.ancestorTitles.slice(0, 1));\n        }\n      }\n    }\n    for (const element of branches) {\n      const newChild = this.getResultChildren(suiteResult, element);\n      if (!newChild.passed) {\n        root.passed = false;\n      }\n      root.children.push(newChild);\n    }\n    return root;\n  }\n\n  private getResultChildren(\n    suiteResult: Array<AssertionResult>,\n    ancestors: Array<string>,\n  ): ResultTreeNode {\n    const node: ResultTreeNode = {\n      children: [],\n      name: ancestors.at(-1)!,\n      passed: true,\n    };\n    const branches: Array<Array<string>> = [];\n    for (const element of suiteResult) {\n      let duration = element.duration;\n      if (!duration || Number.isNaN(duration)) {\n        duration = 1;\n      }\n      if (this.arrayEqual(element.ancestorTitles, ancestors)) {\n        if (element.status === 'failed') {\n          node.passed = false;\n        }\n        node.children.push({\n          children: [],\n          duration,\n          name: element.title,\n          status: element.status,\n        });\n      } else if (\n        this.arrayChild(\n          element.ancestorTitles.slice(0, ancestors.length + 1),\n          ancestors,\n        )\n      ) {\n        let alreadyInserted = false;\n        for (const branch of branches) {\n          if (\n            this.arrayEqual(\n              branch,\n              element.ancestorTitles.slice(0, ancestors.length + 1),\n            )\n          ) {\n            alreadyInserted = true;\n            break;\n          }\n        }\n        if (!alreadyInserted) {\n          branches.push(element.ancestorTitles.slice(0, ancestors.length + 1));\n        }\n      }\n    }\n    for (const element of branches) {\n      const newChild = this.getResultChildren(suiteResult, element);\n      if (!newChild.passed) {\n        node.passed = false;\n      }\n      node.children.push(newChild);\n    }\n    return node;\n  }\n\n  private printResultTree(resultTree: ResultTree): void {\n    let perfMs;\n    if (resultTree.performanceInfo.slow) {\n      perfMs = ` (${chalk.red.inverse(\n        `${resultTree.performanceInfo.runtime} ms`,\n      )})`;\n    } else {\n      perfMs = ` (${resultTree.performanceInfo.runtime} ms)`;\n    }\n    if (resultTree.passed) {\n      this.startGroup(\n        `${chalk.bold.green.inverse('PASS')} ${resultTree.name}${perfMs}`,\n      );\n      for (const child of resultTree.children) {\n        this.recursivePrintResultTree(child, true, 1);\n      }\n      this.endGroup();\n    } else {\n      this.log(\n        `  ${chalk.bold.red.inverse('FAIL')} ${resultTree.name}${perfMs}`,\n      );\n      for (const child of resultTree.children) {\n        this.recursivePrintResultTree(child, false, 1);\n      }\n    }\n  }\n\n  private recursivePrintResultTree(\n    resultTree: ResultTreeNode | ResultTreeLeaf,\n    alreadyGrouped: boolean,\n    depth: number,\n  ): void {\n    if (resultTree.children.length === 0) {\n      if (!('duration' in resultTree)) {\n        throw new Error('Expected a leaf. Got a node.');\n      }\n      let numberSpaces = depth;\n      if (!alreadyGrouped) {\n        numberSpaces++;\n      }\n      const spaces = '  '.repeat(numberSpaces);\n      let resultSymbol;\n      switch (resultTree.status) {\n        case 'passed':\n          resultSymbol = chalk.green(ICONS.success);\n          break;\n        case 'failed':\n          resultSymbol = chalk.red(ICONS.failed);\n          break;\n        case 'todo':\n          resultSymbol = chalk.magenta(ICONS.todo);\n          break;\n        case 'pending':\n        case 'skipped':\n          resultSymbol = chalk.yellow(ICONS.pending);\n          break;\n      }\n      this.log(\n        `${spaces + resultSymbol} ${resultTree.name} (${\n          resultTree.duration\n        } ms)`,\n      );\n    } else {\n      if (!('passed' in resultTree)) {\n        throw new Error('Expected a node. Got a leaf');\n      }\n      if (resultTree.passed) {\n        if (alreadyGrouped) {\n          this.log('  '.repeat(depth) + resultTree.name);\n          for (const child of resultTree.children) {\n            this.recursivePrintResultTree(child, true, depth + 1);\n          }\n        } else {\n          this.startGroup('  '.repeat(depth) + resultTree.name);\n          for (const child of resultTree.children) {\n            this.recursivePrintResultTree(child, true, depth + 1);\n          }\n          this.endGroup();\n        }\n      } else {\n        this.log('  '.repeat(depth + 1) + resultTree.name);\n        for (const child of resultTree.children) {\n          this.recursivePrintResultTree(child, false, depth + 1);\n        }\n      }\n    }\n  }\n\n  private printFailedTestLogs(\n    context: Test,\n    testResults: AggregatedResult,\n  ): boolean {\n    const rootDir = context.context.config.rootDir;\n    const results = testResults.testResults;\n    let written = false;\n    for (const result of results) {\n      let testDir = result.testFilePath;\n      testDir = testDir.replace(rootDir, '');\n      testDir = testDir.slice(1);\n      if (result.failureMessage) {\n        if (!written) {\n          this.log('');\n          written = true;\n        }\n        this.startGroup(`Errors thrown in ${testDir}`);\n        this.log(result.failureMessage);\n        this.endGroup();\n      }\n    }\n    return written;\n  }\n\n  private startGroup(title: string): void {\n    this.log(`::group::${title}`);\n  }\n\n  private endGroup(): void {\n    this.log('::endgroup::');\n  }\n}\n",
  "packages/jest-reporters/src/GitHubActionsReporter.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { AggregatedResult, Test, TestResult } from '@jest/test-result';\nimport type { Config } from '@jest/types';\nimport BaseReporter from './BaseReporter';\nexport default class GitHubActionsReporter extends BaseReporter {\n    #private;\n    static readonly filename: string;\n    private readonly options;\n    constructor(_globalConfig: Config.GlobalConfig, reporterOptions?: {\n        silent?: boolean;\n    });\n    onTestResult(test: Test, testResult: TestResult, aggregatedResults: AggregatedResult): void;\n    private generateAnnotations;\n    private isLastTestSuite;\n    private printFullResult;\n    private arrayEqual;\n    private arrayChild;\n    private getResultTree;\n    private getResultChildren;\n    private printResultTree;\n    private recursivePrintResultTree;\n    private printFailedTestLogs;\n    private startGroup;\n    private endGroup;\n}\n",
  "packages/jest-reporters/src/DefaultReporter.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {WriteStream} from 'tty';\nimport chalk from 'chalk';\nimport {getConsoleOutput} from '@jest/console';\nimport type {\n  AggregatedResult,\n  Test,\n  TestCaseResult,\n  TestResult,\n} from '@jest/test-result';\nimport type {Config} from '@jest/types';\nimport {\n  formatStackTrace,\n  indentAllLines,\n  separateMessageFromStack,\n} from 'jest-message-util';\nimport {clearLine, isInteractive} from 'jest-util';\nimport BaseReporter from './BaseReporter';\nimport Status from './Status';\nimport getResultHeader from './getResultHeader';\nimport getSnapshotStatus from './getSnapshotStatus';\nimport type {ReporterOnStartOptions} from './types';\n\ntype write = WriteStream['write'];\ntype FlushBufferedOutput = () => void;\n\nconst TITLE_BULLET = chalk.bold('\\u25CF ');\n\nexport default class DefaultReporter extends BaseReporter {\n  private _clear: string; // ANSI clear sequence for the last printed status\n  private readonly _err: write;\n  protected _globalConfig: Config.GlobalConfig;\n  private readonly _out: write;\n  private readonly _status: Status;\n  private readonly _bufferedOutput: Set<FlushBufferedOutput>;\n\n  static readonly filename = __filename;\n\n  constructor(globalConfig: Config.GlobalConfig) {\n    super();\n    this._globalConfig = globalConfig;\n    this._clear = '';\n    this._out = process.stdout.write.bind(process.stdout);\n    this._err = process.stderr.write.bind(process.stderr);\n    this._status = new Status(globalConfig);\n    this._bufferedOutput = new Set();\n    this.__wrapStdio(process.stdout);\n    this.__wrapStdio(process.stderr);\n    this._status.onChange(() => {\n      this.__beginSynchronizedUpdate(\n        this._globalConfig.useStderr ? this._err : this._out,\n      );\n      this.__clearStatus();\n      this.__printStatus();\n      this.__endSynchronizedUpdate(\n        this._globalConfig.useStderr ? this._err : this._out,\n      );\n    });\n  }\n\n  protected __wrapStdio(stream: NodeJS.WritableStream | WriteStream): void {\n    const write = stream.write.bind(stream);\n\n    let buffer: Array<string> = [];\n    let timeout: NodeJS.Timeout | null = null;\n\n    const flushBufferedOutput = () => {\n      const string = buffer.join('');\n      buffer = [];\n\n      // This is to avoid conflicts between random output and status text\n      this.__beginSynchronizedUpdate(\n        this._globalConfig.useStderr ? this._err : this._out,\n      );\n      this.__clearStatus();\n      if (string) {\n        write(string);\n      }\n      this.__printStatus();\n      this.__endSynchronizedUpdate(\n        this._globalConfig.useStderr ? this._err : this._out,\n      );\n\n      this._bufferedOutput.delete(flushBufferedOutput);\n    };\n\n    this._bufferedOutput.add(flushBufferedOutput);\n\n    const debouncedFlush = () => {\n      // If the process blows up no errors would be printed.\n      // There should be a smart way to buffer stderr, but for now\n      // we just won't buffer it.\n      if (stream === process.stderr) {\n        flushBufferedOutput();\n      } else {\n        if (!timeout) {\n          timeout = setTimeout(() => {\n            flushBufferedOutput();\n            timeout = null;\n          }, 100);\n        }\n      }\n    };\n\n    stream.write = (chunk: string) => {\n      buffer.push(chunk);\n      debouncedFlush();\n      return true;\n    };\n  }\n\n  // Don't wait for the debounced call and flush all output immediately.\n  forceFlushBufferedOutput(): void {\n    for (const flushBufferedOutput of this._bufferedOutput) {\n      flushBufferedOutput();\n    }\n  }\n\n  protected __clearStatus(): void {\n    if (isInteractive) {\n      if (this._globalConfig.useStderr) {\n        this._err(this._clear);\n      } else {\n        this._out(this._clear);\n      }\n    }\n  }\n\n  protected __printStatus(): void {\n    const {content, clear} = this._status.get();\n    this._clear = clear;\n    if (isInteractive) {\n      if (this._globalConfig.useStderr) {\n        this._err(content);\n      } else {\n        this._out(content);\n      }\n    }\n  }\n\n  override onRunStart(\n    aggregatedResults: AggregatedResult,\n    options: ReporterOnStartOptions,\n  ): void {\n    this._status.runStarted(aggregatedResults, options);\n  }\n\n  override onTestStart(test: Test): void {\n    this._status.testStarted(test.path, test.context.config);\n  }\n\n  override onTestCaseResult(test: Test, testCaseResult: TestCaseResult): void {\n    this._status.addTestCaseResult(test, testCaseResult);\n  }\n\n  override onRunComplete(): void {\n    this.forceFlushBufferedOutput();\n    this._status.runFinished();\n    process.stdout.write = this._out;\n    process.stderr.write = this._err;\n    clearLine(process.stderr);\n  }\n\n  override onTestResult(\n    test: Test,\n    testResult: TestResult,\n    aggregatedResults: AggregatedResult,\n  ): void {\n    this.testFinished(test.context.config, testResult, aggregatedResults);\n    if (!testResult.skipped) {\n      this.printTestFileHeader(\n        testResult.testFilePath,\n        test.context.config,\n        testResult,\n      );\n      this.printTestFileFailureMessage(\n        testResult.testFilePath,\n        test.context.config,\n        testResult,\n      );\n    }\n    this.forceFlushBufferedOutput();\n  }\n\n  testFinished(\n    config: Config.ProjectConfig,\n    testResult: TestResult,\n    aggregatedResults: AggregatedResult,\n  ): void {\n    this._status.testFinished(config, testResult, aggregatedResults);\n  }\n\n  printTestFileHeader(\n    testPath: string,\n    config: Config.ProjectConfig,\n    result: TestResult,\n  ): void {\n    // log retry errors if any exist\n    for (const testResult of result.testResults) {\n      const testRetryReasons = testResult.retryReasons;\n      if (testRetryReasons && testRetryReasons.length > 0) {\n        this.log(\n          `${chalk.reset.inverse.bold.yellow(' LOGGING RETRY ERRORS ')} ${chalk.bold(testResult.fullName)}`,\n        );\n        for (const [index, retryReasons] of testRetryReasons.entries()) {\n          let {message, stack} = separateMessageFromStack(retryReasons);\n          stack = this._globalConfig.noStackTrace\n            ? ''\n            : chalk.dim(\n                formatStackTrace(stack, config, this._globalConfig, testPath),\n              );\n\n          message = indentAllLines(message);\n\n          this.log(\n            `${chalk.reset.inverse.bold.blueBright(` RETRY ${index + 1} `)}\\n`,\n          );\n          this.log(`${message}\\n${stack}\\n`);\n        }\n      }\n    }\n\n    this.log(getResultHeader(result, this._globalConfig, config));\n    if (result.console) {\n      this.log(\n        `  ${TITLE_BULLET}Console\\n\\n${getConsoleOutput(result.console, config, this._globalConfig)}`,\n      );\n    }\n  }\n\n  printTestFileFailureMessage(\n    _testPath: string,\n    _config: Config.ProjectConfig,\n    result: TestResult,\n  ): void {\n    if (result.failureMessage) {\n      this.log(result.failureMessage);\n    }\n    const didUpdate = this._globalConfig.updateSnapshot === 'all';\n    const snapshotStatuses = getSnapshotStatus(result.snapshot, didUpdate);\n    for (const status of snapshotStatuses) this.log(status);\n  }\n}\n",
  "packages/jest-reporters/src/DefaultReporter.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { WriteStream } from 'tty';\nimport type { AggregatedResult, Test, TestCaseResult, TestResult } from '@jest/test-result';\nimport type { Config } from '@jest/types';\nimport BaseReporter from './BaseReporter';\nimport type { ReporterOnStartOptions } from './types';\nexport default class DefaultReporter extends BaseReporter {\n    private _clear;\n    private readonly _err;\n    protected _globalConfig: Config.GlobalConfig;\n    private readonly _out;\n    private readonly _status;\n    private readonly _bufferedOutput;\n    static readonly filename: string;\n    constructor(globalConfig: Config.GlobalConfig);\n    protected __wrapStdio(stream: NodeJS.WritableStream | WriteStream): void;\n    forceFlushBufferedOutput(): void;\n    protected __clearStatus(): void;\n    protected __printStatus(): void;\n    onRunStart(aggregatedResults: AggregatedResult, options: ReporterOnStartOptions): void;\n    onTestStart(test: Test): void;\n    onTestCaseResult(test: Test, testCaseResult: TestCaseResult): void;\n    onRunComplete(): void;\n    onTestResult(test: Test, testResult: TestResult, aggregatedResults: AggregatedResult): void;\n    testFinished(config: Config.ProjectConfig, testResult: TestResult, aggregatedResults: AggregatedResult): void;\n    printTestFileHeader(testPath: string, config: Config.ProjectConfig, result: TestResult): void;\n    printTestFileFailureMessage(_testPath: string, _config: Config.ProjectConfig, result: TestResult): void;\n}\n",
  "packages/jest-reporters/src/CoverageWorker.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport exit from 'exit-x';\nimport * as fs from 'graceful-fs';\nimport type {Config} from '@jest/types';\nimport generateEmptyCoverage, {\n  type CoverageWorkerResult,\n} from './generateEmptyCoverage';\nimport type {ReporterContext} from './types';\n\ntype SerializeSet<T> = T extends Set<infer U> ? Array<U> : T;\n\ntype CoverageReporterContext = Pick<\n  ReporterContext,\n  'changedFiles' | 'sourcesRelatedToTestsInChangedFiles'\n>;\n\ntype CoverageReporterSerializedContext = {\n  [K in keyof CoverageReporterContext]: SerializeSet<ReporterContext[K]>;\n};\n\nexport type CoverageWorkerData = {\n  config: Config.ProjectConfig;\n  context: CoverageReporterSerializedContext;\n  globalConfig: Config.GlobalConfig;\n  path: string;\n};\n\n// Make sure uncaught errors are logged before we exit.\nprocess.on('uncaughtException', err => {\n  if (err.stack) {\n    console.error(err.stack);\n  } else {\n    console.error(err);\n  }\n  exit(1);\n});\n\nexport function worker({\n  config,\n  globalConfig,\n  path,\n  context,\n}: CoverageWorkerData): Promise<CoverageWorkerResult | null> {\n  return generateEmptyCoverage(\n    fs.readFileSync(path, 'utf8'),\n    path,\n    globalConfig,\n    config,\n    context.changedFiles && new Set(context.changedFiles),\n    context.sourcesRelatedToTestsInChangedFiles &&\n      new Set(context.sourcesRelatedToTestsInChangedFiles),\n  );\n}\n",
  "packages/jest-reporters/src/CoverageWorker.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config } from '@jest/types';\nimport { type CoverageWorkerResult } from './generateEmptyCoverage';\nimport type { ReporterContext } from './types';\ntype SerializeSet<T> = T extends Set<infer U> ? Array<U> : T;\ntype CoverageReporterContext = Pick<ReporterContext, 'changedFiles' | 'sourcesRelatedToTestsInChangedFiles'>;\ntype CoverageReporterSerializedContext = {\n    [K in keyof CoverageReporterContext]: SerializeSet<ReporterContext[K]>;\n};\nexport type CoverageWorkerData = {\n    config: Config.ProjectConfig;\n    context: CoverageReporterSerializedContext;\n    globalConfig: Config.GlobalConfig;\n    path: string;\n};\nexport declare function worker({ config, globalConfig, path, context, }: CoverageWorkerData): Promise<CoverageWorkerResult | null>;\nexport {};\n",
  "packages/jest-reporters/src/CoverageReporter.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {mergeProcessCovs} from '@bcoe/v8-coverage';\nimport type {EncodedSourceMap} from '@jridgewell/trace-mapping';\nimport chalk from 'chalk';\nimport {glob} from 'glob';\nimport * as fs from 'graceful-fs';\n/* eslint-disable import-x/default */\nimport istanbulCoverage from 'istanbul-lib-coverage';\nimport istanbulReport from 'istanbul-lib-report';\nimport libSourceMaps from 'istanbul-lib-source-maps';\nimport istanbulReports from 'istanbul-reports';\n/* eslint-enable import-x/default */\nimport v8toIstanbul from 'v8-to-istanbul';\nimport type {\n  AggregatedResult,\n  RuntimeTransformResult,\n  Test,\n  TestContext,\n  TestResult,\n  V8CoverageResult,\n} from '@jest/test-result';\nimport type {Config} from '@jest/types';\nimport {clearLine, isInteractive} from 'jest-util';\nimport {type JestWorkerFarm, Worker} from 'jest-worker';\nimport BaseReporter from './BaseReporter';\nimport getWatermarks from './getWatermarks';\nimport type {ReporterContext} from './types';\n\ntype CoverageWorker = typeof import('./CoverageWorker');\n\nconst FAIL_COLOR = chalk.bold.red;\nconst RUNNING_TEST_COLOR = chalk.bold.dim;\n\nexport default class CoverageReporter extends BaseReporter {\n  private readonly _context: ReporterContext;\n  private readonly _coverageMap: istanbulCoverage.CoverageMap;\n  private readonly _globalConfig: Config.GlobalConfig;\n  private readonly _sourceMapStore: libSourceMaps.MapStore;\n  private readonly _v8CoverageResults: Array<V8CoverageResult>;\n\n  static readonly filename = __filename;\n\n  constructor(globalConfig: Config.GlobalConfig, context: ReporterContext) {\n    super();\n    this._context = context;\n    this._coverageMap = istanbulCoverage.createCoverageMap({});\n    this._globalConfig = globalConfig;\n    this._sourceMapStore = libSourceMaps.createSourceMapStore();\n    this._v8CoverageResults = [];\n  }\n\n  override onTestResult(_test: Test, testResult: TestResult): void {\n    if (testResult.v8Coverage) {\n      this._v8CoverageResults.push(testResult.v8Coverage);\n      return;\n    }\n\n    if (testResult.coverage) {\n      this._coverageMap.merge(testResult.coverage);\n    }\n  }\n\n  override async onRunComplete(\n    testContexts: Set<TestContext>,\n    aggregatedResults: AggregatedResult,\n  ): Promise<void> {\n    await this._addUntestedFiles(testContexts);\n    const {map, reportContext} = await this._getCoverageResult();\n\n    try {\n      const coverageReporters = this._globalConfig.coverageReporters || [];\n\n      if (!this._globalConfig.useStderr && coverageReporters.length === 0) {\n        coverageReporters.push('text-summary');\n      }\n      for (let reporter of coverageReporters) {\n        let additionalOptions = {};\n        if (Array.isArray(reporter)) {\n          [reporter, additionalOptions] = reporter;\n        }\n        istanbulReports\n          .create(reporter, {\n            maxCols: process.stdout.columns || Number.POSITIVE_INFINITY,\n            ...additionalOptions,\n          })\n          .execute(reportContext);\n      }\n      aggregatedResults.coverageMap = map;\n    } catch (error: any) {\n      console.error(\n        chalk.red(`\n        Failed to write coverage reports:\n        ERROR: ${error.toString()}\n        STACK: ${error.stack}\n      `),\n      );\n    }\n\n    this._checkThreshold(map);\n  }\n\n  private async _addUntestedFiles(\n    testContexts: Set<TestContext>,\n  ): Promise<void> {\n    const files: Array<{config: Config.ProjectConfig; path: string}> = [];\n\n    for (const context of testContexts) {\n      const config = context.config;\n      if (\n        this._globalConfig.collectCoverageFrom &&\n        this._globalConfig.collectCoverageFrom.length > 0\n      ) {\n        for (const filePath of context.hasteFS.matchFilesWithGlob(\n          this._globalConfig.collectCoverageFrom,\n          config.rootDir,\n        ))\n          files.push({\n            config,\n            path: filePath,\n          });\n      }\n    }\n\n    if (files.length === 0) {\n      return;\n    }\n\n    if (isInteractive) {\n      process.stderr.write(\n        RUNNING_TEST_COLOR('Running coverage on untested files...'),\n      );\n    }\n\n    let worker:\n      | JestWorkerFarm<CoverageWorker>\n      | typeof import('./CoverageWorker');\n\n    if (this._globalConfig.maxWorkers <= 1) {\n      worker = require('./CoverageWorker');\n    } else {\n      worker = new Worker(require.resolve('./CoverageWorker'), {\n        enableWorkerThreads: this._globalConfig.workerThreads,\n        exposedMethods: ['worker'],\n        forkOptions: {serialization: 'json'},\n        maxRetries: 2,\n        numWorkers: this._globalConfig.maxWorkers,\n      }) as JestWorkerFarm<CoverageWorker>;\n    }\n\n    const instrumentation = files.map(async fileObj => {\n      const filename = fileObj.path;\n      const config = fileObj.config;\n\n      const hasCoverageData = this._v8CoverageResults.some(v8Res =>\n        v8Res.some(innerRes => innerRes.result.url === filename),\n      );\n\n      if (\n        !hasCoverageData &&\n        !this._coverageMap.data[filename] &&\n        'worker' in worker\n      ) {\n        try {\n          const result = await worker.worker({\n            config,\n            context: {\n              changedFiles: this._context.changedFiles && [\n                ...this._context.changedFiles,\n              ],\n              sourcesRelatedToTestsInChangedFiles: this._context\n                .sourcesRelatedToTestsInChangedFiles && [\n                ...this._context.sourcesRelatedToTestsInChangedFiles,\n              ],\n            },\n            globalConfig: this._globalConfig,\n            path: filename,\n          });\n\n          if (result) {\n            if (result.kind === 'V8Coverage') {\n              this._v8CoverageResults.push([\n                {codeTransformResult: undefined, result: result.result},\n              ]);\n            } else {\n              this._coverageMap.addFileCoverage(result.coverage);\n            }\n          }\n        } catch (error: any) {\n          console.error(\n            chalk.red(\n              [\n                `Failed to collect coverage from ${filename}`,\n                `ERROR: ${error.message}`,\n                `STACK: ${error.stack}`,\n              ].join('\\n'),\n            ),\n          );\n        }\n      }\n    });\n\n    try {\n      await Promise.all(instrumentation);\n    } catch {\n      // Do nothing; errors were reported earlier to the console.\n    }\n\n    if (isInteractive) {\n      clearLine(process.stderr);\n    }\n\n    if (worker && 'end' in worker && typeof worker.end === 'function') {\n      await worker.end();\n    }\n  }\n\n  private _checkThreshold(map: istanbulCoverage.CoverageMap) {\n    const {coverageThreshold} = this._globalConfig;\n\n    if (coverageThreshold) {\n      function check(\n        name: string,\n        thresholds: Config.CoverageThresholdValue,\n        actuals: istanbulCoverage.CoverageSummaryData,\n      ) {\n        return (\n          ['statements', 'branches', 'lines', 'functions'] as Array<\n            keyof istanbulCoverage.CoverageSummaryData\n          >\n        ).reduce<Array<string>>((errors, key) => {\n          const actual = actuals[key].pct;\n          const actualUncovered = actuals[key].total - actuals[key].covered;\n          const threshold = thresholds[key];\n\n          if (threshold !== undefined) {\n            if (threshold < 0) {\n              if (threshold * -1 < actualUncovered) {\n                errors.push(\n                  `Jest: Uncovered count for ${key} (${actualUncovered}) ` +\n                    `exceeds ${name} threshold (${-1 * threshold})`,\n                );\n              }\n            } else if (actual < threshold) {\n              errors.push(\n                `Jest: \"${name}\" coverage threshold for ${key} (${threshold}%) not met: ${actual}%`,\n              );\n            }\n          }\n          return errors;\n        }, []);\n      }\n\n      const THRESHOLD_GROUP_TYPES = {\n        GLOB: 'glob',\n        GLOBAL: 'global',\n        PATH: 'path',\n      };\n      const coveredFiles = map.files();\n      const thresholdGroups = Object.keys(coverageThreshold);\n      const groupTypeByThresholdGroup: {[index: string]: string} = {};\n      const filesByGlob: {[index: string]: Array<string>} = {};\n\n      const coveredFilesSortedIntoThresholdGroup = coveredFiles.reduce<\n        Array<[string, string | undefined]>\n      >((files, file) => {\n        const pathOrGlobMatches = thresholdGroups.reduce<\n          Array<[string, string]>\n        >((agg, thresholdGroup) => {\n          // Preserve trailing slash, but not required if root dir\n          // See https://github.com/jestjs/jest/issues/12703\n          const resolvedThresholdGroup = path.resolve(thresholdGroup);\n          const suffix =\n            (thresholdGroup.endsWith(path.sep) ||\n              (process.platform === 'win32' && thresholdGroup.endsWith('/'))) &&\n            !resolvedThresholdGroup.endsWith(path.sep)\n              ? path.sep\n              : '';\n          const absoluteThresholdGroup = `${resolvedThresholdGroup}${suffix}`;\n\n          // The threshold group might be a path:\n\n          if (file.indexOf(absoluteThresholdGroup) === 0) {\n            groupTypeByThresholdGroup[thresholdGroup] =\n              THRESHOLD_GROUP_TYPES.PATH;\n            agg.push([file, thresholdGroup]);\n            return agg;\n          }\n\n          // If the threshold group is not a path it might be a glob:\n\n          // Note: glob.sync is slow. By memoizing the files matching each glob\n          // (rather than recalculating it for each covered file) we save a tonne\n          // of execution time.\n          if (filesByGlob[absoluteThresholdGroup] === undefined) {\n            filesByGlob[absoluteThresholdGroup] = glob\n              .sync(absoluteThresholdGroup, {windowsPathsNoEscape: true})\n              .map(filePath => path.resolve(filePath));\n          }\n\n          if (filesByGlob[absoluteThresholdGroup].includes(file)) {\n            groupTypeByThresholdGroup[thresholdGroup] =\n              THRESHOLD_GROUP_TYPES.GLOB;\n            agg.push([file, thresholdGroup]);\n            return agg;\n          }\n\n          return agg;\n        }, []);\n\n        if (pathOrGlobMatches.length > 0) {\n          files.push(...pathOrGlobMatches);\n          return files;\n        }\n\n        // Neither a glob or a path? Toss it in global if there's a global threshold:\n        if (thresholdGroups.includes(THRESHOLD_GROUP_TYPES.GLOBAL)) {\n          groupTypeByThresholdGroup[THRESHOLD_GROUP_TYPES.GLOBAL] =\n            THRESHOLD_GROUP_TYPES.GLOBAL;\n          files.push([file, THRESHOLD_GROUP_TYPES.GLOBAL]);\n          return files;\n        }\n\n        // A covered file that doesn't have a threshold:\n        files.push([file, undefined]);\n\n        return files;\n      }, []);\n\n      const getFilesInThresholdGroup = (thresholdGroup: string) =>\n        coveredFilesSortedIntoThresholdGroup\n          .filter(fileAndGroup => fileAndGroup[1] === thresholdGroup)\n          .map(fileAndGroup => fileAndGroup[0]);\n\n      function combineCoverage(filePaths: Array<string>) {\n        return filePaths\n          .map(filePath => map.fileCoverageFor(filePath))\n          .reduce(\n            (\n              combinedCoverage:\n                | istanbulCoverage.CoverageSummary\n                | null\n                | undefined,\n              nextFileCoverage: istanbulCoverage.FileCoverage,\n            ) => {\n              if (combinedCoverage === undefined || combinedCoverage === null) {\n                return nextFileCoverage.toSummary();\n              }\n              return combinedCoverage.merge(nextFileCoverage.toSummary());\n            },\n            undefined,\n          );\n      }\n\n      let errors: Array<string> = [];\n\n      for (const thresholdGroup of thresholdGroups) {\n        switch (groupTypeByThresholdGroup[thresholdGroup]) {\n          case THRESHOLD_GROUP_TYPES.GLOBAL: {\n            const coverage = combineCoverage(\n              getFilesInThresholdGroup(THRESHOLD_GROUP_TYPES.GLOBAL),\n            );\n            if (coverage) {\n              errors = [\n                ...errors,\n                ...check(\n                  thresholdGroup,\n                  coverageThreshold[thresholdGroup],\n                  coverage,\n                ),\n              ];\n            }\n            break;\n          }\n          case THRESHOLD_GROUP_TYPES.PATH: {\n            const coverage = combineCoverage(\n              getFilesInThresholdGroup(thresholdGroup),\n            );\n            if (coverage) {\n              errors = [\n                ...errors,\n                ...check(\n                  thresholdGroup,\n                  coverageThreshold[thresholdGroup],\n                  coverage,\n                ),\n              ];\n            }\n            break;\n          }\n          case THRESHOLD_GROUP_TYPES.GLOB:\n            for (const fileMatchingGlob of getFilesInThresholdGroup(\n              thresholdGroup,\n            )) {\n              errors = [\n                ...errors,\n                ...check(\n                  fileMatchingGlob,\n                  coverageThreshold[thresholdGroup],\n                  map.fileCoverageFor(fileMatchingGlob).toSummary(),\n                ),\n              ];\n            }\n\n            break;\n          default:\n            // If the file specified by path is not found, error is returned.\n            if (thresholdGroup !== THRESHOLD_GROUP_TYPES.GLOBAL) {\n              errors = [\n                ...errors,\n                `Jest: Coverage data for ${thresholdGroup} was not found.`,\n              ];\n            }\n          // Sometimes all files in the coverage data are matched by\n          // PATH and GLOB threshold groups in which case, don't error when\n          // the global threshold group doesn't match any files.\n        }\n      }\n\n      errors = errors.filter(\n        err => err !== undefined && err !== null && err.length > 0,\n      );\n\n      if (errors.length > 0) {\n        this.log(`${FAIL_COLOR(errors.join('\\n'))}`);\n        this._setError(new Error(errors.join('\\n')));\n      }\n    }\n  }\n\n  private async _getCoverageResult(): Promise<{\n    map: istanbulCoverage.CoverageMap;\n    reportContext: istanbulReport.Context;\n  }> {\n    if (this._globalConfig.coverageProvider === 'v8') {\n      const mergedCoverages = mergeProcessCovs(\n        this._v8CoverageResults.map(cov => ({result: cov.map(r => r.result)})),\n      );\n\n      const fileTransforms = new Map<string, RuntimeTransformResult>();\n\n      for (const res of this._v8CoverageResults)\n        for (const r of res) {\n          if (r.codeTransformResult && !fileTransforms.has(r.result.url)) {\n            fileTransforms.set(r.result.url, r.codeTransformResult);\n          }\n        }\n\n      const transformedCoverage = await Promise.all(\n        mergedCoverages.result.map(async res => {\n          const fileTransform = fileTransforms.get(res.url);\n\n          let sourcemapContent: EncodedSourceMap | undefined = undefined;\n\n          if (\n            fileTransform?.sourceMapPath &&\n            fs.existsSync(fileTransform.sourceMapPath)\n          ) {\n            sourcemapContent = JSON.parse(\n              fs.readFileSync(fileTransform.sourceMapPath, 'utf8'),\n            );\n          }\n\n          const converter = v8toIstanbul(\n            res.url,\n            0,\n            fileTransform && sourcemapContent\n              ? {\n                  originalSource: fileTransform.originalCode,\n                  source: fileTransform.code,\n                  sourceMap: {\n                    sourcemap: {file: res.url, ...sourcemapContent},\n                  },\n                }\n              : {source: fs.readFileSync(res.url, 'utf8')},\n          );\n\n          await converter.load();\n\n          converter.applyCoverage(res.functions);\n\n          const istanbulData = converter.toIstanbul();\n\n          return istanbulData;\n        }),\n      );\n\n      const map = istanbulCoverage.createCoverageMap({});\n\n      for (const res of transformedCoverage) map.merge(res);\n\n      const reportContext = istanbulReport.createContext({\n        coverageMap: map,\n        dir: this._globalConfig.coverageDirectory,\n        watermarks: getWatermarks(this._globalConfig),\n      });\n\n      return {map, reportContext};\n    }\n\n    const map = await this._sourceMapStore.transformCoverage(this._coverageMap);\n    const reportContext = istanbulReport.createContext({\n      coverageMap: map,\n      dir: this._globalConfig.coverageDirectory,\n      sourceFinder: this._sourceMapStore.sourceFinder,\n      watermarks: getWatermarks(this._globalConfig),\n    });\n\n    return {map, reportContext};\n  }\n}\n",
  "packages/jest-reporters/src/CoverageReporter.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { AggregatedResult, Test, TestContext, TestResult } from '@jest/test-result';\nimport type { Config } from '@jest/types';\nimport BaseReporter from './BaseReporter';\nimport type { ReporterContext } from './types';\nexport default class CoverageReporter extends BaseReporter {\n    private readonly _context;\n    private readonly _coverageMap;\n    private readonly _globalConfig;\n    private readonly _sourceMapStore;\n    private readonly _v8CoverageResults;\n    static readonly filename: string;\n    constructor(globalConfig: Config.GlobalConfig, context: ReporterContext);\n    onTestResult(_test: Test, testResult: TestResult): void;\n    onRunComplete(testContexts: Set<TestContext>, aggregatedResults: AggregatedResult): Promise<void>;\n    private _addUntestedFiles;\n    private _checkThreshold;\n    private _getCoverageResult;\n}\n",
  "packages/jest-reporters/src/BaseReporter.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {WriteStream} from 'tty';\nimport type {\n  AggregatedResult,\n  Test,\n  TestCaseResult,\n  TestContext,\n  TestResult,\n} from '@jest/test-result';\nimport {isInteractive, preRunMessage} from 'jest-util';\nimport type {Reporter, ReporterOnStartOptions} from './types';\n\nconst {remove: preRunMessageRemove} = preRunMessage;\n\nexport default class BaseReporter implements Reporter {\n  private _error?: Error;\n\n  log(message: string): void {\n    process.stderr.write(`${message}\\n`);\n  }\n\n  onRunStart(\n    _results?: AggregatedResult,\n    _options?: ReporterOnStartOptions,\n  ): void {\n    preRunMessageRemove(process.stderr);\n  }\n\n  /* eslint-disable @typescript-eslint/no-empty-function */\n  onTestCaseResult(_test: Test, _testCaseResult: TestCaseResult): void {}\n\n  onTestResult(\n    _test?: Test,\n    _testResult?: TestResult,\n    _results?: AggregatedResult,\n  ): void {}\n\n  onTestStart(_test?: Test): void {}\n\n  onRunComplete(\n    _testContexts?: Set<TestContext>,\n    _aggregatedResults?: AggregatedResult,\n  ): Promise<void> | void {}\n  /* eslint-enable */\n\n  protected _setError(error: Error): void {\n    this._error = error;\n  }\n\n  // Return an error that occurred during reporting. This error will\n  // define whether the test run was successful or failed.\n  getLastError(): Error | undefined {\n    return this._error;\n  }\n\n  protected __beginSynchronizedUpdate(write: WriteStream['write']): void {\n    if (isInteractive) {\n      write('\\u001B[?2026h');\n    }\n  }\n\n  protected __endSynchronizedUpdate(write: WriteStream['write']): void {\n    if (isInteractive) {\n      write('\\u001B[?2026l');\n    }\n  }\n}\n",
  "packages/jest-reporters/src/BaseReporter.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { WriteStream } from 'tty';\nimport type { AggregatedResult, Test, TestCaseResult, TestContext, TestResult } from '@jest/test-result';\nimport type { Reporter, ReporterOnStartOptions } from './types';\nexport default class BaseReporter implements Reporter {\n    private _error?;\n    log(message: string): void;\n    onRunStart(_results?: AggregatedResult, _options?: ReporterOnStartOptions): void;\n    onTestCaseResult(_test: Test, _testCaseResult: TestCaseResult): void;\n    onTestResult(_test?: Test, _testResult?: TestResult, _results?: AggregatedResult): void;\n    onTestStart(_test?: Test): void;\n    onRunComplete(_testContexts?: Set<TestContext>, _aggregatedResults?: AggregatedResult): Promise<void> | void;\n    protected _setError(error: Error): void;\n    getLastError(): Error | undefined;\n    protected __beginSynchronizedUpdate(write: WriteStream['write']): void;\n    protected __endSynchronizedUpdate(write: WriteStream['write']): void;\n}\n",
  "packages/jest-reporters/src/__tests__/utils.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {stripVTControlCharacters as stripAnsi} from 'util';\nimport chalk from 'chalk';\nimport {makeProjectConfig} from '@jest/test-utils';\nimport printDisplayName from '../printDisplayName';\nimport trimAndFormatPath from '../trimAndFormatPath';\nimport wrapAnsiString from '../wrapAnsiString';\n\ndescribe('wrapAnsiString()', () => {\n  it('wraps a long string containing ansi chars', () => {\n    const string =\n      `abcde ${chalk.red.bold('red-bold')} 1234456` +\n      `${chalk.dim('bcd')} ` +\n      '123ttttttththththththththththththththththththththth' +\n      `tetetetetettetetetetetetetete${chalk.underline.bold('stnhsnthsnth')}` +\n      'ssot';\n    expect(wrapAnsiString(string, 10)).toMatchSnapshot();\n    expect(stripAnsi(wrapAnsiString(string, 10))).toMatchSnapshot();\n  });\n\n  it('returns the string unaltered if given a terminal width of zero', () => {\n    const string = \"This string shouldn't cause you any trouble\";\n    expect(wrapAnsiString(string, 0)).toMatchSnapshot();\n    expect(stripAnsi(wrapAnsiString(string, 0))).toMatchSnapshot();\n  });\n});\n\ndescribe('trimAndFormatPath()', () => {\n  it('trims dirname', () => {\n    const pad = 5;\n    const basename = '1234.js';\n    const dirname = '1234567890/1234567890';\n    const columns = 25;\n    const result = trimAndFormatPath(\n      pad,\n      makeProjectConfig({cwd: '', rootDir: ''}),\n      path.join(dirname, basename),\n      columns,\n    );\n\n    expect(result).toMatchSnapshot();\n    expect(stripAnsi(result)).toHaveLength(20);\n  });\n\n  it('trims dirname (longer line width)', () => {\n    const pad = 5;\n    const basename = '1234.js';\n    const dirname = '1234567890/1234567890';\n    const columns = 30;\n    const result = trimAndFormatPath(\n      pad,\n      makeProjectConfig({cwd: '', rootDir: ''}),\n      path.join(dirname, basename),\n      columns,\n    );\n\n    expect(result).toMatchSnapshot();\n    expect(stripAnsi(result)).toHaveLength(25);\n  });\n\n  it('trims dirname and basename', () => {\n    const pad = 5;\n    const basename = '1234.js';\n    const dirname = '1234567890/1234567890';\n    const columns = 15;\n    const result = trimAndFormatPath(\n      pad,\n      makeProjectConfig({cwd: '', rootDir: ''}),\n      path.join(dirname, basename),\n      columns,\n    );\n\n    expect(result).toMatchSnapshot();\n    expect(stripAnsi(result)).toHaveLength(10);\n  });\n\n  it('does not trim anything', () => {\n    const pad = 5;\n    const basename = '1234.js';\n    const dirname = '1234567890/1234567890';\n    const columns = 50;\n    const totalLength = basename.length + path.sep.length + dirname.length;\n    const result = trimAndFormatPath(\n      pad,\n      makeProjectConfig({cwd: '', rootDir: ''}),\n      path.join(dirname, basename),\n      columns,\n    );\n\n    expect(result).toMatchSnapshot();\n    expect(stripAnsi(result)).toHaveLength(totalLength);\n  });\n\n  test('split at the path.sep index', () => {\n    const pad = 5;\n    const basename = '1234.js';\n    const dirname = '1234567890';\n    const columns = 16;\n    const result = trimAndFormatPath(\n      pad,\n      makeProjectConfig({cwd: '', rootDir: ''}),\n      path.join(dirname, basename),\n      columns,\n    );\n\n    expect(result).toMatchSnapshot();\n    expect(stripAnsi(result)).toHaveLength(columns - pad);\n  });\n});\n\ndescribe('printDisplayName', () => {\n  it('should default displayName color to white when displayName is a string', () => {\n    expect(\n      printDisplayName(\n        makeProjectConfig({\n          displayName: {\n            color: 'white',\n            name: 'hello',\n          },\n        }),\n      ),\n    ).toMatchSnapshot();\n  });\n\n  it('should default displayName color to white when color is not a valid value', () => {\n    expect(\n      printDisplayName(\n        makeProjectConfig({\n          displayName: {\n            color: 'rubbish' as any,\n            name: 'hello',\n          },\n        }),\n      ),\n    ).toMatchSnapshot();\n  });\n\n  it('should correctly print the displayName when color and name are valid values', () => {\n    expect(\n      printDisplayName(\n        makeProjectConfig({\n          displayName: {\n            color: 'green',\n            name: 'hello',\n          },\n        }),\n      ),\n    ).toMatchSnapshot();\n  });\n});\n",
  "packages/jest-reporters/src/__tests__/utils.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-reporters/src/__tests__/getWatermarks.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {makeGlobalConfig} from '@jest/test-utils';\nimport getWatermarks from '../getWatermarks';\n\ndescribe('getWatermarks', () => {\n  test('that watermarks use thresholds as upper target', () => {\n    const watermarks = getWatermarks(\n      makeGlobalConfig({\n        coverageThreshold: {\n          global: {\n            branches: 100,\n            functions: 100,\n            lines: 100,\n            statements: 100,\n          },\n        },\n      }),\n    );\n\n    expect(watermarks).toEqual({\n      branches: [expect.any(Number), 100],\n      functions: [expect.any(Number), 100],\n      lines: [expect.any(Number), 100],\n      statements: [expect.any(Number), 100],\n    });\n  });\n\n  test('that watermarks are created always created', () => {\n    const watermarks = getWatermarks(makeGlobalConfig());\n\n    expect(watermarks).toEqual({\n      branches: [expect.any(Number), expect.any(Number)],\n      functions: [expect.any(Number), expect.any(Number)],\n      lines: [expect.any(Number), expect.any(Number)],\n      statements: [expect.any(Number), expect.any(Number)],\n    });\n  });\n});\n",
  "packages/jest-reporters/src/__tests__/getWatermarks.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-reporters/src/__tests__/getSummary.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport {makeEmptyAggregatedTestResult} from '@jest/test-result';\nimport getSummary from '../getSummary';\n\njest.useFakeTimers().setSystemTime(10);\n\ndescribe('getSummary', () => {\n  test('does not print seed value when showSeed is false', () => {\n    const summary = getSummary(makeEmptyAggregatedTestResult(), {\n      estimatedTime: 0,\n      showSeed: false,\n    });\n\n    expect(summary).toMatchSnapshot();\n  });\n\n  test('does print seed value when showSeed is true', () => {\n    const summary = getSummary(makeEmptyAggregatedTestResult(), {\n      estimatedTime: 0,\n      seed: 55_555,\n      showSeed: true,\n    });\n\n    expect(summary).toMatchSnapshot();\n  });\n\n  test('throws error is showSeed is true but seed is not present', () => {\n    expect.assertions(1);\n\n    try {\n      getSummary(makeEmptyAggregatedTestResult(), {\n        estimatedTime: 0,\n        showSeed: true,\n      });\n    } catch (error) {\n      expect(error).toBeInstanceOf(Error);\n    }\n  });\n});\n",
  "packages/jest-reporters/src/__tests__/getSummary.test.d.ts": "export {};\n",
  "packages/jest-reporters/src/__tests__/NotifyReporter.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {AggregatedResult, TestContext} from '@jest/test-result';\nimport {makeGlobalConfig} from '@jest/test-utils';\nimport type {Config} from '@jest/types';\nimport Resolver from 'jest-resolve';\nimport NotifyReporter from '../NotifyReporter';\nimport type {ReporterContext} from '../types';\n\njest.mock('../DefaultReporter');\njest.mock('node-notifier', () => ({\n  notify: jest.fn(),\n}));\n\nconst initialContext: ReporterContext = {\n  firstRun: true,\n  previousSuccess: false,\n  startRun: () => {},\n};\n\nconst aggregatedResultsSuccess = {\n  numFailedTestSuites: 0,\n  numFailedTests: 0,\n  numPassedTestSuites: 1,\n  numPassedTests: 3,\n  numRuntimeErrorTestSuites: 0,\n  numTotalTestSuites: 1,\n  numTotalTests: 3,\n  success: true,\n} as AggregatedResult;\n\nconst aggregatedResultsFailure = {\n  numFailedTestSuites: 1,\n  numFailedTests: 3,\n  numPassedTestSuites: 0,\n  numPassedTests: 9,\n  numRuntimeErrorTestSuites: 0,\n  numTotalTestSuites: 1,\n  numTotalTests: 3,\n  success: false,\n} as AggregatedResult;\n\nconst aggregatedResultsNoTests = {\n  numFailedTestSuites: 0,\n  numFailedTests: 0,\n  numPassedTestSuites: 0,\n  numPassedTests: 0,\n  numPendingTestSuites: 0,\n  numPendingTests: 0,\n  numRuntimeErrorTestSuites: 0,\n  numTotalTestSuites: 0,\n  numTotalTests: 0,\n} as AggregatedResult;\n\n// Simulated sequence of events for NotifyReporter\nconst notifyEvents = [\n  aggregatedResultsNoTests,\n  aggregatedResultsSuccess,\n  aggregatedResultsFailure,\n  aggregatedResultsSuccess,\n  aggregatedResultsSuccess,\n  aggregatedResultsFailure,\n  aggregatedResultsFailure,\n];\n\nconst testModes = ({\n  notifyMode,\n  arl,\n  rootDir,\n  moduleName,\n}: {arl: Array<AggregatedResult>; moduleName?: string} & Pick<\n  Config.GlobalConfig,\n  'notifyMode'\n> &\n  Partial<Pick<Config.ProjectConfig, 'rootDir'>>) => {\n  const notify = require('node-notifier');\n\n  const globalConfig = makeGlobalConfig({notify: true, notifyMode, rootDir});\n\n  let previousContext = initialContext;\n  for (const [i, ar] of arl.entries()) {\n    const newContext: ReporterContext = Object.assign(previousContext, {\n      firstRun: i === 0,\n      previousSuccess: previousContext.previousSuccess,\n    });\n    const reporter = new NotifyReporter(globalConfig, newContext);\n    previousContext = newContext;\n    const testContexts = new Set<TestContext>();\n\n    if (moduleName != null) {\n      testContexts.add({\n        hasteFS: {\n          getModuleName() {\n            return moduleName;\n          },\n\n          matchFiles() {\n            return ['package.json'];\n          },\n        },\n      } as unknown as TestContext);\n    }\n\n    reporter.onRunComplete(testContexts, ar);\n\n    if (ar.numTotalTests === 0) {\n      expect(notify.notify).not.toHaveBeenCalled();\n    }\n  }\n\n  const calls: Array<any> = notify.notify.mock.calls;\n  expect(\n    calls.map(([{message, title}]) => ({\n      message: message.replace('\\u26D4\\uFE0F ', '').replace('\\u2705 ', ''),\n      title,\n    })),\n  ).toMatchSnapshot();\n};\n\ntest('test always', () => {\n  testModes({arl: notifyEvents, notifyMode: 'always'});\n});\n\ntest('test success', () => {\n  testModes({arl: notifyEvents, notifyMode: 'success'});\n});\n\ntest('test change', () => {\n  testModes({arl: notifyEvents, notifyMode: 'change'});\n});\n\ntest('test success-change', () => {\n  testModes({arl: notifyEvents, notifyMode: 'success-change'});\n});\n\ntest('test failure-change', () => {\n  testModes({arl: notifyEvents, notifyMode: 'failure-change'});\n});\n\ntest('test always with rootDir', () => {\n  testModes({arl: notifyEvents, notifyMode: 'always', rootDir: 'some-test'});\n});\n\ntest('test success with rootDir', () => {\n  testModes({arl: notifyEvents, notifyMode: 'success', rootDir: 'some-test'});\n});\n\ntest('test change with rootDir', () => {\n  testModes({arl: notifyEvents, notifyMode: 'change', rootDir: 'some-test'});\n});\n\ntest('test success-change with rootDir', () => {\n  testModes({\n    arl: notifyEvents,\n    notifyMode: 'success-change',\n    rootDir: 'some-test',\n  });\n});\n\ntest('test failure-change with rootDir', () => {\n  testModes({\n    arl: notifyEvents,\n    notifyMode: 'failure-change',\n    rootDir: 'some-test',\n  });\n});\n\ntest('test always with moduleName', () => {\n  testModes({\n    arl: notifyEvents,\n    moduleName: 'some-module',\n    notifyMode: 'always',\n  });\n});\n\ntest('test success with moduleName', () => {\n  testModes({\n    arl: notifyEvents,\n    moduleName: 'some-module',\n    notifyMode: 'success',\n  });\n});\n\ntest('test change with moduleName', () => {\n  testModes({\n    arl: notifyEvents,\n    moduleName: 'some-module',\n    notifyMode: 'change',\n  });\n});\n\ntest('test success-change with moduleName', () => {\n  testModes({\n    arl: notifyEvents,\n    moduleName: 'some-module',\n    notifyMode: 'success-change',\n  });\n});\n\ntest('test failure-change with moduleName', () => {\n  testModes({\n    arl: notifyEvents,\n    moduleName: 'some-module',\n    notifyMode: 'failure-change',\n  });\n});\n\ndescribe('node-notifier is an optional dependency', () => {\n  beforeEach(() => {\n    jest.resetModules();\n  });\n\n  const ctor = () => {\n    const globalConfig = makeGlobalConfig({\n      notify: true,\n      notifyMode: 'success',\n      rootDir: 'some-test',\n    });\n    return new NotifyReporter(globalConfig, initialContext);\n  };\n\n  test('without node-notifier uses mock function that throws an error', () => {\n    jest.doMock('node-notifier', () => {\n      throw new Resolver.ModuleNotFoundError(\n        \"Cannot find module 'node-notifier'\",\n      );\n    });\n\n    expect(ctor).toThrow(\n      'notify reporter requires optional peer dependency \"node-notifier\" but it was not found',\n    );\n  });\n\n  test('throws the error when require throws an unexpected error', () => {\n    const error = new Error('unexpected require error');\n    jest.doMock('node-notifier', () => {\n      throw error;\n    });\n    expect(ctor).toThrow(error);\n  });\n\n  test('uses node-notifier when it is available', () => {\n    const mockNodeNotifier = {notify: jest.fn()};\n    jest.doMock('node-notifier', () => mockNodeNotifier);\n    const result = ctor();\n    expect(result._notifier).toBe(mockNodeNotifier);\n  });\n});\n\nafterEach(() => {\n  jest.clearAllMocks();\n});\n",
  "packages/jest-reporters/src/__tests__/NotifyReporter.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-reporters/src/__tests__/GitHubActionsReporter.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {\n  AggregatedResult,\n  AssertionResult,\n  Status,\n  Test,\n  TestCaseResult,\n  TestResult,\n} from '@jest/test-result';\nimport {normalizeIcons} from '@jest/test-utils';\nimport type {Config} from '@jest/types';\nimport BaseGitHubActionsReporter from '../GitHubActionsReporter';\n\nafterEach(() => {\n  jest.clearAllMocks();\n});\n\nclass GitHubActionsReporter extends BaseGitHubActionsReporter {\n  override log(message: string): void {\n    super.log(normalizeIcons(message));\n  }\n}\n\nconst mockedStderrWrite = jest\n  .spyOn(process.stderr, 'write')\n  .mockImplementation(() => true);\n\ndescribe('annotations', () => {\n  const reporter = new GitHubActionsReporter({} as Config.GlobalConfig);\n\n  const testMeta = {\n    context: {config: {rootDir: '/user/project'}},\n  } as Test;\n\n  const expectationsErrorMessage =\n    'Error: \\u001B[2mexpect(\\u001B[22m\\u001B[31mreceived\\u001B[39m\\u001B[2m).\\u001B[22mtoBe\\u001B[2m(\\u001B[22m\\u001B[32mexpected\\u001B[39m\\u001B[2m) // Object.is equality\\u001B[22m\\n' +\n    '\\n' +\n    'Expected: \\u001B[32m1\\u001B[39m\\n' +\n    'Received: \\u001B[31m10\\u001B[39m\\n' +\n    '    at Object.toBe (/user/project/__tests__/example.test.js:20:14)\\n' +\n    '    at Promise.then.completed (/user/project/jest/packages/jest-circus/build/utils.js:333:28)\\n' +\n    '    at new Promise (<anonymous>)\\n' +\n    '    at callAsyncCircusFn (/user/project/jest/packages/jest-circus/build/utils.js:259:10)\\n' +\n    '    at _callCircusTest (/user/project/jest/packages/jest-circus/build/run.js:276:40)\\n' +\n    '    at processTicksAndRejections (node:internal/process/task_queues:95:5)\\n' +\n    '    at _runTest (/user/project/jest/packages/jest-circus/build/run.js:208:3)\\n' +\n    '    at _runTestsForDescribeBlock (/user/project/jest/packages/jest-circus/build/run.js:96:9)\\n' +\n    '    at run (/user/project/jest/packages/jest-circus/build/run.js:31:3)\\n' +\n    '    at runAndTransformResultsToJestFormat (/user/project/jest/packages/jest-circus/build/legacy-code-todo-rewrite/jestAdapterInit.js:135:21)';\n\n  const referenceErrorMessage =\n    'ReferenceError: abc is not defined\\n' +\n    '    at Object.abc (/user/project/__tests__/example.test.js:25:12)\\n' +\n    '    at Promise.then.completed (/user/project/jest/packages/jest-circus/build/utils.js:333:28)\\n' +\n    '    at new Promise (<anonymous>)\\n' +\n    '    at callAsyncCircusFn (/user/project/jest/packages/jest-circus/build/utils.js:259:10)\\n' +\n    '    at _callCircusTest (/user/project/jest/packages/jest-circus/build/run.js:276:40)\\n' +\n    '    at processTicksAndRejections (node:internal/process/task_queues:95:5)\\n' +\n    '    at _runTest (/user/project/jest/packages/jest-circus/build/run.js:208:3)\\n' +\n    '    at _runTestsForDescribeBlock (/user/project/jest/packages/jest-circus/build/run.js:96:9)\\n' +\n    '    at _runTestsForDescribeBlock (/user/project/jest/packages/jest-circus/build/run.js:90:9)\\n' +\n    '    at run (/user/project/jest/packages/jest-circus/build/run.js:31:3)';\n\n  const retryErrorMessage =\n    'Error: \\u001B[2mexpect(\\u001B[22m\\u001B[31mreceived\\u001B[39m\\u001B[2m).\\u001B[22mtoBeFalsy\\u001B[2m()\\u001B[22m\\n' +\n    '\\n' +\n    'Received: \\u001B[31mtrue\\u001B[39m\\n' +\n    '    at Object.toBeFalsy (/user/project/__tests__/example.test.js:19:20)\\n' +\n    '    at Promise.then.completed (/user/project/jest/packages/jest-circus/build/utils.js:333:28)\\n' +\n    '    at new Promise (<anonymous>)\\n' +\n    '    at callAsyncCircusFn (/user/project/jest/packages/jest-circus/build/utils.js:259:10)\\n' +\n    '    at _callCircusTest (/user/project/jest/packages/jest-circus/build/run.js:276:40)\\n' +\n    '    at _runTest (/user/project/jest/packages/jest-circus/build/run.js:208:3)\\n' +\n    '    at _runTestsForDescribeBlock (/user/project/jest/packages/jest-circus/build/run.js:96:9)\\n' +\n    '    at _runTestsForDescribeBlock (/user/project/jest/packages/jest-circus/build/run.js:90:9)\\n' +\n    '    at run (/user/project/jest/packages/jest-circus/build/run.js:31:3)\\n' +\n    '    at runAndTransformResultsToJestFormat (/user/project/jest/packages/jest-circus/build/legacy-code-todo-rewrite/jestAdapterInit.js:135:21)';\n\n  const testCaseResult = {\n    ancestorTitles: [] as Array<string>,\n    failureMessages: [expectationsErrorMessage],\n    title: 'example test',\n  } as TestCaseResult;\n\n  describe('logs error annotation', () => {\n    test('when an expectation fails to pass', () => {\n      reporter.generateAnnotations(testMeta, {\n        testResults: [\n          {\n            ...testCaseResult,\n            failureMessages: [expectationsErrorMessage],\n          },\n        ],\n      } as TestResult);\n\n      expect(mockedStderrWrite).toHaveBeenCalledTimes(1);\n      expect(mockedStderrWrite.mock.calls[0]).toMatchSnapshot();\n    });\n\n    test('when a test has reference error', () => {\n      reporter.generateAnnotations(\n        {...testMeta, path: '/user/project/__tests__/example.test.js:25:12'},\n        {\n          testResults: [\n            {\n              ...testCaseResult,\n              failureMessages: [referenceErrorMessage],\n            },\n          ],\n        } as TestResult,\n      );\n\n      expect(mockedStderrWrite).toHaveBeenCalledTimes(1);\n      expect(mockedStderrWrite.mock.calls[0]).toMatchSnapshot();\n    });\n\n    test('when test is wrapped in describe block', () => {\n      reporter.generateAnnotations(testMeta, {\n        testResults: [\n          {\n            ...testCaseResult,\n            ancestorTitles: ['describe'],\n          },\n        ],\n      } as TestResult);\n\n      expect(mockedStderrWrite).toHaveBeenCalledTimes(1);\n      expect(mockedStderrWrite.mock.calls[0]).toMatchSnapshot();\n    });\n  });\n\n  describe('logs warning annotation before logging errors', () => {\n    test('when test result includes retry reasons', () => {\n      reporter.generateAnnotations(testMeta, {\n        testResults: [\n          {\n            ...testCaseResult,\n            failureMessages: [retryErrorMessage],\n            retryReasons: [retryErrorMessage],\n          },\n        ],\n      } as TestResult);\n\n      expect(mockedStderrWrite).toHaveBeenCalledTimes(2);\n      expect(mockedStderrWrite.mock.calls).toMatchSnapshot();\n    });\n  });\n});\n\ndescribe('logs', () => {\n  test('can be instantiated', () => {\n    const gha = new GitHubActionsReporter({} as Config.GlobalConfig);\n    expect(gha).toBeTruthy();\n    expect(gha).toBeInstanceOf(GitHubActionsReporter);\n  });\n\n  describe('Result tree generation', () => {\n    test('failed single test without describe', () => {\n      const testResults = [\n        {\n          ancestorTitles: [],\n          duration: 10,\n          status: 'failed',\n          title: 'test',\n        },\n      ] as unknown as Array<AssertionResult>;\n      const suitePerf = {\n        end: 30,\n        runtime: 20,\n        slow: false,\n        start: 10,\n      };\n      const expectedResults = {\n        children: [\n          {\n            children: [],\n            duration: 10,\n            name: 'test',\n            status: 'failed',\n          },\n        ],\n        name: '/',\n        passed: false,\n        performanceInfo: {\n          end: 30,\n          runtime: 20,\n          slow: false,\n          start: 10,\n        },\n      };\n      const gha = new GitHubActionsReporter({} as Config.GlobalConfig, {\n        silent: false,\n      });\n\n      const generated = gha.getResultTree(testResults, '/', suitePerf);\n\n      expect(mockedStderrWrite).not.toHaveBeenCalled();\n      expect(generated).toEqual(expectedResults);\n    });\n\n    test('passed single test without describe', () => {\n      const testResults = [\n        {\n          ancestorTitles: [],\n          duration: 10,\n          status: 'passed',\n          title: 'test',\n        },\n      ] as unknown as Array<AssertionResult>;\n      const suitePerf = {\n        end: 30,\n        runtime: 20,\n        slow: false,\n        start: 10,\n      };\n      const expectedResults = {\n        children: [\n          {\n            children: [],\n            duration: 10,\n            name: 'test',\n            status: 'passed',\n          },\n        ],\n        name: '/',\n        passed: true,\n        performanceInfo: {\n          end: 30,\n          runtime: 20,\n          slow: false,\n          start: 10,\n        },\n      };\n      const gha = new GitHubActionsReporter({} as Config.GlobalConfig, {\n        silent: false,\n      });\n\n      const generated = gha.getResultTree(testResults, '/', suitePerf);\n\n      expect(mockedStderrWrite).not.toHaveBeenCalled();\n      expect(generated).toEqual(expectedResults);\n    });\n\n    test('failed single test inside describe', () => {\n      const testResults = [\n        {\n          ancestorTitles: ['Test describe'],\n          duration: 10,\n          status: 'failed',\n          title: 'test',\n        },\n      ] as unknown as Array<AssertionResult>;\n      const suitePerf = {\n        end: 30,\n        runtime: 20,\n        slow: false,\n        start: 10,\n      };\n      const expectedResults = {\n        children: [\n          {\n            children: [\n              {\n                children: [],\n                duration: 10,\n                name: 'test',\n                status: 'failed',\n              },\n            ],\n            name: 'Test describe',\n            passed: false,\n          },\n        ],\n        name: '/',\n        passed: false,\n        performanceInfo: {\n          end: 30,\n          runtime: 20,\n          slow: false,\n          start: 10,\n        },\n      };\n      const gha = new GitHubActionsReporter({} as Config.GlobalConfig, {\n        silent: false,\n      });\n\n      const generated = gha.getResultTree(testResults, '/', suitePerf);\n\n      expect(mockedStderrWrite).not.toHaveBeenCalled();\n      expect(generated).toEqual(expectedResults);\n    });\n\n    test('passed single test inside describe', () => {\n      const testResults = [\n        {\n          ancestorTitles: ['Test describe'],\n          duration: 10,\n          status: 'passed',\n          title: 'test',\n        },\n      ] as unknown as Array<AssertionResult>;\n      const suitePerf = {\n        end: 30,\n        runtime: 20,\n        slow: false,\n        start: 10,\n      };\n      const expectedResults = {\n        children: [\n          {\n            children: [\n              {\n                children: [],\n                duration: 10,\n                name: 'test',\n                status: 'passed',\n              },\n            ],\n            name: 'Test describe',\n            passed: true,\n          },\n        ],\n        name: '/',\n        passed: true,\n        performanceInfo: {\n          end: 30,\n          runtime: 20,\n          slow: false,\n          start: 10,\n        },\n      };\n      const gha = new GitHubActionsReporter({} as Config.GlobalConfig, {\n        silent: false,\n      });\n\n      const generated = gha.getResultTree(testResults, '/', suitePerf);\n\n      expect(mockedStderrWrite).not.toHaveBeenCalled();\n      expect(generated).toEqual(expectedResults);\n    });\n\n    test('skipped single test and todo single test inside describe', () => {\n      const testResults = [\n        {\n          ancestorTitles: ['Test describe'],\n          duration: 10,\n          status: 'skipped',\n          title: 'test',\n        },\n        {\n          ancestorTitles: ['Test describe'],\n          duration: 14,\n          status: 'todo',\n          title: 'test2',\n        },\n      ] as unknown as Array<AssertionResult>;\n      const suitePerf = {\n        end: 30,\n        runtime: 20,\n        slow: false,\n        start: 10,\n      };\n      const expectedResults = {\n        children: [\n          {\n            children: [\n              {\n                children: [],\n                duration: 10,\n                name: 'test',\n                status: 'skipped',\n              },\n              {\n                children: [],\n                duration: 14,\n                name: 'test2',\n                status: 'todo',\n              },\n            ],\n            name: 'Test describe',\n            passed: true,\n          },\n        ],\n        name: '/',\n        passed: true,\n        performanceInfo: {\n          end: 30,\n          runtime: 20,\n          slow: false,\n          start: 10,\n        },\n      };\n      const gha = new GitHubActionsReporter({} as Config.GlobalConfig, {\n        silent: false,\n      });\n\n      const generated = gha.getResultTree(testResults, '/', suitePerf);\n\n      expect(mockedStderrWrite).not.toHaveBeenCalled();\n      expect(generated).toEqual(expectedResults);\n    });\n  });\n\n  describe('Result tree output', () => {\n    test('failed single test without describe', () => {\n      const generatedTree = {\n        children: [\n          {\n            children: [],\n            duration: 10,\n            name: 'test',\n            status: 'failed' as Status,\n          },\n        ],\n        name: '/',\n        passed: false,\n        performanceInfo: {\n          end: 30,\n          runtime: 20,\n          slow: false,\n          start: 10,\n        },\n      };\n      const gha = new GitHubActionsReporter({} as Config.GlobalConfig, {\n        silent: false,\n      });\n\n      gha.printResultTree(generatedTree);\n\n      expect(mockedStderrWrite.mock.calls).toMatchSnapshot();\n    });\n\n    test('passed single test without describe', () => {\n      const generatedTree = {\n        children: [\n          {\n            children: [],\n            duration: 10,\n            name: 'test',\n            status: 'passed' as Status,\n          },\n        ],\n        name: '/',\n        passed: true,\n        performanceInfo: {\n          end: 30,\n          runtime: 20,\n          slow: false,\n          start: 10,\n        },\n      };\n      const gha = new GitHubActionsReporter({} as Config.GlobalConfig, {\n        silent: false,\n      });\n\n      gha.printResultTree(generatedTree);\n\n      expect(mockedStderrWrite.mock.calls).toMatchSnapshot();\n    });\n\n    test('failed single test inside describe', () => {\n      const generatedTree = {\n        children: [\n          {\n            children: [\n              {\n                children: [],\n                duration: 10,\n                name: 'test',\n                status: 'failed' as Status,\n              },\n            ],\n            name: 'Test describe',\n            passed: false,\n          },\n        ],\n        name: '/',\n        passed: false,\n        performanceInfo: {\n          end: 30,\n          runtime: 20,\n          slow: false,\n          start: 10,\n        },\n      };\n      const gha = new GitHubActionsReporter({} as Config.GlobalConfig, {\n        silent: false,\n      });\n\n      gha.printResultTree(generatedTree);\n\n      expect(mockedStderrWrite.mock.calls).toMatchSnapshot();\n    });\n\n    test('passed single test inside describe', () => {\n      const generatedTree = {\n        children: [\n          {\n            children: [\n              {\n                children: [],\n                duration: 10,\n                name: 'test',\n                status: 'passed' as Status,\n              },\n            ],\n            name: 'Test describe',\n            passed: true,\n          },\n        ],\n        name: '/',\n        passed: true,\n        performanceInfo: {\n          end: 30,\n          runtime: 20,\n          slow: false,\n          start: 10,\n        },\n      };\n      const gha = new GitHubActionsReporter({} as Config.GlobalConfig, {\n        silent: false,\n      });\n\n      gha.printResultTree(generatedTree);\n\n      expect(mockedStderrWrite.mock.calls).toMatchSnapshot();\n    });\n\n    test('todo single test inside describe', () => {\n      const generatedTree = {\n        children: [\n          {\n            children: [\n              {\n                children: [],\n                duration: 10,\n                name: 'test',\n                status: 'todo' as Status,\n              },\n            ],\n            name: 'Test describe',\n            passed: true,\n          },\n        ],\n        name: '/',\n        passed: true,\n        performanceInfo: {\n          end: 30,\n          runtime: 20,\n          slow: false,\n          start: 10,\n        },\n      };\n      const gha = new GitHubActionsReporter({} as Config.GlobalConfig, {\n        silent: false,\n      });\n\n      gha.printResultTree(generatedTree);\n\n      expect(mockedStderrWrite.mock.calls).toMatchSnapshot();\n    });\n\n    test('skipped single test inside describe', () => {\n      const generatedTree = {\n        children: [\n          {\n            children: [\n              {\n                children: [],\n                duration: 10,\n                name: 'test',\n                status: 'skipped' as Status,\n              },\n            ],\n            name: 'Test describe',\n            passed: true,\n          },\n        ],\n        name: '/',\n        passed: true,\n        performanceInfo: {\n          end: 30,\n          runtime: 20,\n          slow: false,\n          start: 10,\n        },\n      };\n      const gha = new GitHubActionsReporter({} as Config.GlobalConfig, {\n        silent: false,\n      });\n\n      gha.printResultTree(generatedTree);\n\n      expect(mockedStderrWrite.mock.calls).toMatchSnapshot();\n    });\n  });\n\n  describe('Reporter interface', () => {\n    test('onTestResult not last', () => {\n      const mockTest = {\n        context: {\n          config: {\n            rootDir: '/testDir',\n          },\n        },\n      };\n      const mockTestResult = {\n        perfStats: {\n          runtime: 20,\n          slow: false,\n        },\n        testFilePath: '/testDir/test1.js',\n        testResults: [\n          {\n            ancestorTitles: [],\n            duration: 10,\n            status: 'passed',\n            title: 'test1',\n          },\n        ],\n      };\n      const mockResults = {\n        numFailedTestSuites: 1,\n        numPassedTestSuites: 1,\n        numTotalTestSuites: 3,\n      };\n      const gha = new GitHubActionsReporter({} as Config.GlobalConfig, {\n        silent: false,\n      });\n      gha.generateAnnotations = jest.fn();\n\n      gha.onTestResult(\n        mockTest as Test,\n        mockTestResult as unknown as TestResult,\n        mockResults as AggregatedResult,\n      );\n\n      expect(mockedStderrWrite.mock.calls).toMatchSnapshot();\n    });\n\n    test('onTestResult last', () => {\n      const mockTest = {\n        context: {\n          config: {\n            rootDir: '/testDir',\n          },\n        },\n      };\n      const mockTestResult = {\n        failureMessage: 'Failure message',\n        perfStats: {\n          runtime: 20,\n          slow: false,\n        },\n        testFilePath: '/testDir/test1.js',\n        testResults: [\n          {\n            ancestorTitles: [],\n            duration: 10,\n            status: 'passed',\n            title: 'test1',\n          },\n        ],\n      };\n      const mockResults = {\n        numFailedTestSuites: 1,\n        numPassedTestSuites: 2,\n        numTotalTestSuites: 3,\n        testResults: [mockTestResult],\n      };\n      const gha = new GitHubActionsReporter({} as Config.GlobalConfig, {\n        silent: false,\n      });\n      gha.generateAnnotations = jest.fn();\n\n      gha.onTestResult(\n        mockTest as Test,\n        mockTestResult as unknown as TestResult,\n        mockResults as unknown as AggregatedResult,\n      );\n\n      expect(mockedStderrWrite.mock.calls).toMatchSnapshot();\n    });\n  });\n});\n",
  "packages/jest-reporters/src/__tests__/GitHubActionsReporter.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-reporters/__typetests__/jest-reporters.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {expect} from 'tstyche';\nimport {\n  type AggregatedResult,\n  type Config,\n  type SnapshotSummary,\n  type SummaryOptions,\n  type TestResult,\n  utils,\n} from '@jest/reporters';\n\ndeclare const aggregatedResults: AggregatedResult;\ndeclare const globalConfig: Config.GlobalConfig;\ndeclare const projectConfig: Config.ProjectConfig;\ndeclare const snapshot: TestResult['snapshot'];\ndeclare const snapshotSummary: SnapshotSummary;\ndeclare const summaryOptions: SummaryOptions;\ndeclare const testResult: TestResult;\n\n// utils.formatTestPath()\n\nexpect(utils.formatTestPath(globalConfig, 'some/path')).type.toBe<string>();\nexpect(utils.formatTestPath(projectConfig, 'some/path')).type.toBe<string>();\nexpect(utils.formatTestPath).type.not.toBeCallableWith();\nexpect(utils.formatTestPath).type.not.toBeCallableWith({}, 'some/path');\nexpect(utils.formatTestPath).type.not.toBeCallableWith(globalConfig, 123);\nexpect(utils.formatTestPath).type.not.toBeCallableWith(projectConfig, 123);\n\n// utils.getResultHeader()\n\nexpect(\n  utils.getResultHeader(testResult, globalConfig, projectConfig),\n).type.toBe<string>();\nexpect(utils.getResultHeader(testResult, globalConfig)).type.toBe<string>();\nexpect(utils.getResultHeader).type.not.toBeCallableWith();\nexpect(utils.getResultHeader).type.not.toBeCallableWith({}, globalConfig);\nexpect(utils.getResultHeader).type.not.toBeCallableWith(\n  {},\n  globalConfig,\n  projectConfig,\n);\nexpect(utils.getResultHeader).type.not.toBeCallableWith(testResult, {});\nexpect(utils.getResultHeader).type.not.toBeCallableWith(\n  testResult,\n  globalConfig,\n  {},\n);\n\n// utils.getSnapshotStatus()\n\nexpect(utils.getSnapshotStatus(snapshot, true)).type.toBe<Array<string>>();\nexpect(utils.getSnapshotStatus).type.not.toBeCallableWith();\nexpect(utils.getSnapshotStatus).type.not.toBeCallableWith({}, true);\nexpect(utils.getSnapshotStatus).type.not.toBeCallableWith(snapshot, 123);\n\n// utils.getSnapshotSummary()\n\nexpect(\n  utils.getSnapshotSummary(snapshotSummary, globalConfig, 'press `u`'),\n).type.toBe<Array<string>>();\nexpect(utils.getSnapshotSummary).type.not.toBeCallableWith();\nexpect(utils.getSnapshotSummary).type.not.toBeCallableWith(\n  {},\n  globalConfig,\n  'press `u`',\n);\nexpect(utils.getSnapshotSummary).type.not.toBeCallableWith(\n  snapshotSummary,\n  {},\n  'press `u`',\n);\nexpect(utils.getSnapshotSummary).type.not.toBeCallableWith(\n  snapshotSummary,\n  globalConfig,\n  true,\n);\n\n// utils.getSummary()\n\nexpect(utils.getSummary(aggregatedResults, summaryOptions)).type.toBe<string>();\nexpect(utils.getSummary(aggregatedResults)).type.toBe<string>();\nexpect(utils.getSummary).type.not.toBeCallableWith();\nexpect(utils.getSummary).type.not.toBeCallableWith({});\nexpect(utils.getSummary).type.not.toBeCallableWith(aggregatedResults, true);\n\n// utils.printDisplayName()\n\nexpect(utils.printDisplayName(projectConfig)).type.toBe<string>();\nexpect(utils.printDisplayName).type.not.toBeCallableWith();\nexpect(utils.printDisplayName).type.not.toBeCallableWith({});\n\n// utils.relativePath()\n\nexpect(utils.relativePath(globalConfig, 'some/path')).type.toBe<{\n  basename: string;\n  dirname: string;\n}>();\nexpect(utils.relativePath(projectConfig, 'some/path')).type.toBe<{\n  basename: string;\n  dirname: string;\n}>();\nexpect(utils.relativePath).type.not.toBeCallableWith();\nexpect(utils.relativePath).type.not.toBeCallableWith({}, 'some/path');\nexpect(utils.relativePath).type.not.toBeCallableWith(projectConfig, true);\n\n// utils.trimAndFormatPath()\n\nexpect(\n  utils.trimAndFormatPath(2, globalConfig, 'some/path', 4),\n).type.toBe<string>();\nexpect(utils.trimAndFormatPath).type.not.toBeCallableWith();\nexpect(utils.trimAndFormatPath).type.not.toBeCallableWith(\n  true,\n  globalConfig,\n  'some/path',\n  4,\n);\nexpect(utils.trimAndFormatPath).type.not.toBeCallableWith(\n  2,\n  {},\n  'some/path',\n  4,\n);\nexpect(utils.trimAndFormatPath).type.not.toBeCallableWith(\n  2,\n  globalConfig,\n  true,\n  4,\n);\nexpect(utils.trimAndFormatPath).type.not.toBeCallableWith(\n  2,\n  globalConfig,\n  'some/path',\n  '4',\n);\n",
  "packages/jest-reporters/__typetests__/jest-reporters.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-regex-util/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {sep} from 'path';\n\nexport const escapePathForRegex = (dir: string): string => {\n  if (sep === '\\\\') {\n    // Replace \"\\\" with \"/\" so it's not escaped by escapeStrForRegex.\n    // replacePathSepForRegex will convert it back.\n    dir = dir.replaceAll('\\\\', '/');\n  }\n  return replacePathSepForRegex(escapeStrForRegex(dir));\n};\n\nexport const escapeStrForRegex = (string: string): string =>\n  string.replaceAll(/[$()*+.?[\\\\\\]^{|}]/g, '\\\\$&');\n\nexport const replacePathSepForRegex = (string: string): string => {\n  if (sep === '\\\\') {\n    return string.replaceAll(\n      /(\\/|(.)?\\\\(?![$()*+.?[\\\\\\]^{|}]))/g,\n      (_match, _, p2) => (p2 && p2 !== '\\\\' ? `${p2}\\\\\\\\` : '\\\\\\\\'),\n    );\n  }\n  return string;\n};\n",
  "packages/jest-regex-util/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport declare const escapePathForRegex: (dir: string) => string;\nexport declare const escapeStrForRegex: (string: string) => string;\nexport declare const replacePathSepForRegex: (string: string) => string;\n",
  "packages/jest-regex-util/src/__tests__/index.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ndescribe('replacePathSepForRegex()', () => {\n  let replacePathSepForRegex: (str: string) => string;\n\n  describe('posix', () => {\n    beforeAll(() => {\n      jest.mock('path', () => ({\n        ...jest.createMockFromModule<typeof import('path')>('path'),\n        sep: '/',\n      }));\n      jest.isolateModules(() => {\n        replacePathSepForRegex = require('../').replacePathSepForRegex;\n      });\n    });\n\n    it('should return the path', () => {\n      const expected = {};\n      expect(replacePathSepForRegex(expected as string)).toBe(expected);\n    });\n  });\n\n  describe('win32', () => {\n    beforeAll(() => {\n      jest.mock('path', () => ({\n        ...jest.createMockFromModule<typeof import('path')>('path'),\n        sep: '\\\\',\n      }));\n      jest.isolateModules(() => {\n        replacePathSepForRegex = require('../').replacePathSepForRegex;\n      });\n    });\n\n    it('should replace POSIX path separators', () => {\n      expect(replacePathSepForRegex('a/b/c')).toBe('a\\\\\\\\b\\\\\\\\c');\n\n      // When a regular expression is created with a string, not enclosing\n      // slashes like \"/<pattern>/\", the \"/\" character does not need to be\n      // escaped as \"\\/\". The result is the double path separator: \"\\\\\"\n      expect(replacePathSepForRegex('a\\\\/b')).toBe('a\\\\\\\\\\\\\\\\b');\n    });\n\n    it('should escape Windows path separators', () => {\n      expect(replacePathSepForRegex('a\\\\b\\\\c')).toBe('a\\\\\\\\b\\\\\\\\c');\n    });\n\n    it('should not escape an escaped dot', () => {\n      expect(replacePathSepForRegex('a\\\\.dotfile')).toBe('a\\\\.dotfile');\n      expect(replacePathSepForRegex('a\\\\\\\\\\\\.dotfile')).toBe('a\\\\\\\\\\\\.dotfile');\n    });\n\n    it('should not escape an escaped regexp symbol', () => {\n      expect(replacePathSepForRegex('b\\\\(86')).toBe('b\\\\(86');\n    });\n\n    it('should escape Windows path separators inside groups', () => {\n      expect(replacePathSepForRegex('[/\\\\\\\\]')).toBe('[\\\\\\\\\\\\\\\\]');\n    });\n\n    it('should escape Windows path separator at the beginning', () => {\n      expect(replacePathSepForRegex('\\\\a')).toBe('\\\\\\\\a');\n    });\n\n    it('should not escape several already escaped path separators', () => {\n      expect(replacePathSepForRegex('\\\\\\\\\\\\\\\\')).toBe('\\\\\\\\\\\\\\\\');\n    });\n  });\n});\n",
  "packages/jest-regex-util/src/__tests__/index.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n",
  "packages/jest-phabricator/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {AggregatedResult} from '@jest/test-result';\n\ntype CoverageMap = AggregatedResult['coverageMap'];\n\nfunction summarize(coverageMap: CoverageMap): CoverageMap {\n  if (!coverageMap) {\n    return coverageMap;\n  }\n\n  const summaries = Object.create(null);\n\n  for (const file of coverageMap.files()) {\n    const covered = [];\n    const lineCoverage = coverageMap.fileCoverageFor(file).getLineCoverage();\n\n    for (const lineNumber of Object.keys(lineCoverage)) {\n      const number = Number.parseInt(lineNumber, 10);\n      // Line numbers start at one\n      covered[number - 1] = lineCoverage[number] ? 'C' : 'U';\n    }\n\n    for (let i = 0; i < covered.length; i++) {\n      if (!covered[i]) {\n        covered[i] = 'N';\n      }\n    }\n\n    summaries[file] = covered.join('');\n  }\n\n  return summaries;\n}\n\nexport default function PhabricatorProcessor(\n  results: AggregatedResult,\n): AggregatedResult {\n  return {...results, coverageMap: summarize(results.coverageMap)};\n}\n",
  "packages/jest-phabricator/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { AggregatedResult } from '@jest/test-result';\nexport default function PhabricatorProcessor(results: AggregatedResult): AggregatedResult;\n",
  "packages/jest-pattern/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nexport {\n  TestPathPatterns,\n  TestPathPatternsExecutor,\n  type TestPathPatternsExecutorOptions,\n} from './TestPathPatterns';\n",
  "packages/jest-pattern/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport { TestPathPatterns, TestPathPatternsExecutor, type TestPathPatternsExecutorOptions, } from './TestPathPatterns';\n",
  "packages/jest-pattern/src/TestPathPatterns.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {replacePathSepForRegex} from 'jest-regex-util';\n\nexport class TestPathPatterns {\n  constructor(readonly patterns: Array<string>) {}\n\n  /**\n   * Return true if there are any patterns.\n   */\n  isSet(): boolean {\n    return this.patterns.length > 0;\n  }\n\n  /**\n   * Return true if the patterns are valid.\n   */\n  isValid(): boolean {\n    return this.toExecutor({\n      // isValid() doesn't require rootDir to be accurate, so just\n      // specify a dummy rootDir here\n      rootDir: '/',\n    }).isValid();\n  }\n\n  /**\n   * Return a human-friendly version of the pattern regex.\n   */\n  toPretty(): string {\n    return this.patterns.join('|');\n  }\n\n  /**\n   * Return a TestPathPatternsExecutor that can execute the patterns.\n   */\n  toExecutor(\n    options: TestPathPatternsExecutorOptions,\n  ): TestPathPatternsExecutor {\n    return new TestPathPatternsExecutor(this, options);\n  }\n\n  /** For jest serializers */\n  toJSON(): any {\n    return {\n      patterns: this.patterns,\n      type: 'TestPathPatterns',\n    };\n  }\n}\n\nexport type TestPathPatternsExecutorOptions = {\n  rootDir: string;\n};\n\nexport class TestPathPatternsExecutor {\n  constructor(\n    readonly patterns: TestPathPatterns,\n    private readonly options: TestPathPatternsExecutorOptions,\n  ) {}\n\n  private toRegex(s: string): RegExp {\n    return new RegExp(s, 'i');\n  }\n\n  /**\n   * Return true if there are any patterns.\n   */\n  isSet(): boolean {\n    return this.patterns.isSet();\n  }\n\n  /**\n   * Return true if the patterns are valid.\n   */\n  isValid(): boolean {\n    try {\n      for (const p of this.patterns.patterns) {\n        this.toRegex(p);\n      }\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Return true if the given ABSOLUTE path matches the patterns.\n   *\n   * Throws an error if the patterns form an invalid regex (see `validate`).\n   */\n  isMatch(absPath: string): boolean {\n    const relPath = path.relative(this.options.rootDir || '/', absPath);\n\n    if (this.patterns.patterns.length === 0) {\n      return true;\n    }\n\n    for (const p of this.patterns.patterns) {\n      const pathToTest = path.isAbsolute(p) ? absPath : relPath;\n\n      // special case: ./foo.spec.js (and .\\foo.spec.js on Windows) should\n      // match /^foo.spec.js/ after stripping root dir\n      let regexStr = p.replace(/^\\.\\//, '^');\n      if (path.sep === '\\\\') {\n        regexStr = regexStr.replace(/^\\.\\\\/, '^');\n      }\n\n      regexStr = replacePathSepForRegex(regexStr);\n      if (this.toRegex(regexStr).test(pathToTest)) {\n        return true;\n      }\n\n      if (this.toRegex(regexStr).test(absPath)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Return a human-friendly version of the pattern regex.\n   */\n  toPretty(): string {\n    return this.patterns.toPretty();\n  }\n}\n",
  "packages/jest-pattern/src/TestPathPatterns.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport declare class TestPathPatterns {\n    readonly patterns: Array<string>;\n    constructor(patterns: Array<string>);\n    /**\n     * Return true if there are any patterns.\n     */\n    isSet(): boolean;\n    /**\n     * Return true if the patterns are valid.\n     */\n    isValid(): boolean;\n    /**\n     * Return a human-friendly version of the pattern regex.\n     */\n    toPretty(): string;\n    /**\n     * Return a TestPathPatternsExecutor that can execute the patterns.\n     */\n    toExecutor(options: TestPathPatternsExecutorOptions): TestPathPatternsExecutor;\n    /** For jest serializers */\n    toJSON(): any;\n}\nexport type TestPathPatternsExecutorOptions = {\n    rootDir: string;\n};\nexport declare class TestPathPatternsExecutor {\n    readonly patterns: TestPathPatterns;\n    private readonly options;\n    constructor(patterns: TestPathPatterns, options: TestPathPatternsExecutorOptions);\n    private toRegex;\n    /**\n     * Return true if there are any patterns.\n     */\n    isSet(): boolean;\n    /**\n     * Return true if the patterns are valid.\n     */\n    isValid(): boolean;\n    /**\n     * Return true if the given ABSOLUTE path matches the patterns.\n     *\n     * Throws an error if the patterns form an invalid regex (see `validate`).\n     */\n    isMatch(absPath: string): boolean;\n    /**\n     * Return a human-friendly version of the pattern regex.\n     */\n    toPretty(): string;\n}\n",
  "packages/jest-pattern/src/__tests__/TestPathPatterns.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {\n  TestPathPatterns,\n  TestPathPatternsExecutor,\n  type TestPathPatternsExecutorOptions,\n} from '../TestPathPatterns';\n\nconst mockSep: jest.Mock<() => string> = jest.fn();\nconst mockIsAbsolute: jest.Mock<(p: string) => boolean> = jest.fn();\nconst mockRelative: jest.Mock<(from: string, to: string) => string> = jest.fn();\njest.mock('path', () => {\n  const actualPath = jest.requireActual('path');\n  return {\n    ...actualPath,\n    isAbsolute(p) {\n      return mockIsAbsolute(p) || actualPath.isAbsolute(p);\n    },\n    relative(from, to) {\n      return mockRelative(from, to) || actualPath.relative(from, to);\n    },\n    get sep() {\n      return mockSep() || actualPath.sep;\n    },\n  } as typeof path;\n});\nconst forcePosix = () => {\n  mockSep.mockReturnValue(path.posix.sep);\n  mockIsAbsolute.mockImplementation(path.posix.isAbsolute);\n  mockRelative.mockImplementation(path.posix.relative);\n};\nconst forceWindows = () => {\n  mockSep.mockReturnValue(path.win32.sep);\n  mockIsAbsolute.mockImplementation(path.win32.isAbsolute);\n  mockRelative.mockImplementation(path.win32.relative);\n};\nbeforeEach(() => {\n  jest.resetAllMocks();\n  forcePosix();\n});\n\nconst config = {rootDir: ''};\n\ninterface TestPathPatternsLike {\n  isSet(): boolean;\n  isValid(): boolean;\n  toPretty(): string;\n}\n\nconst testPathPatternsLikeTests = (\n  makePatterns: (\n    patterns: Array<string>,\n    options: TestPathPatternsExecutorOptions,\n  ) => TestPathPatternsLike,\n) => {\n  describe('isSet', () => {\n    it('returns false if no patterns specified', () => {\n      const testPathPatterns = makePatterns([], config);\n      expect(testPathPatterns.isSet()).toBe(false);\n    });\n\n    it('returns true if patterns specified', () => {\n      const testPathPatterns = makePatterns(['a'], config);\n      expect(testPathPatterns.isSet()).toBe(true);\n    });\n  });\n\n  describe('isValid', () => {\n    it('succeeds for empty patterns', () => {\n      const testPathPatterns = makePatterns([], config);\n      expect(testPathPatterns.isValid()).toBe(true);\n    });\n\n    it('succeeds for valid patterns', () => {\n      const testPathPatterns = makePatterns(['abc+', 'z.*'], config);\n      expect(testPathPatterns.isValid()).toBe(true);\n    });\n\n    it('fails for at least one invalid pattern', () => {\n      const testPathPatterns = makePatterns(['abc+', '(', 'z.*'], config);\n      expect(testPathPatterns.isValid()).toBe(false);\n    });\n  });\n\n  describe('toPretty', () => {\n    it('renders a human-readable string', () => {\n      const testPathPatterns = makePatterns(['a/b', 'c/d'], config);\n      expect(testPathPatterns.toPretty()).toMatchSnapshot();\n    });\n  });\n};\n\ndescribe('TestPathPatterns', () => {\n  testPathPatternsLikeTests(\n    (patterns: Array<string>, _: TestPathPatternsExecutorOptions) =>\n      new TestPathPatterns(patterns),\n  );\n});\n\ndescribe('TestPathPatternsExecutor', () => {\n  const makeExecutor = (\n    patterns: Array<string>,\n    options: TestPathPatternsExecutorOptions,\n  ) => new TestPathPatternsExecutor(new TestPathPatterns(patterns), options);\n\n  testPathPatternsLikeTests(makeExecutor);\n\n  describe('isMatch', () => {\n    it('returns true with no patterns', () => {\n      const testPathPatterns = makeExecutor([], config);\n      expect(testPathPatterns.isMatch('/a/b')).toBe(true);\n    });\n\n    it('returns true for same path', () => {\n      const testPathPatterns = makeExecutor(['/a/b'], config);\n      expect(testPathPatterns.isMatch('/a/b')).toBe(true);\n    });\n\n    it('returns true for same path with case insensitive', () => {\n      const testPathPatternsUpper = makeExecutor(['/A/B'], config);\n      expect(testPathPatternsUpper.isMatch('/a/b')).toBe(true);\n      expect(testPathPatternsUpper.isMatch('/A/B')).toBe(true);\n\n      const testPathPatternsLower = makeExecutor(['/a/b'], config);\n      expect(testPathPatternsLower.isMatch('/A/B')).toBe(true);\n      expect(testPathPatternsLower.isMatch('/a/b')).toBe(true);\n    });\n\n    it('returns true for contained path', () => {\n      const testPathPatterns = makeExecutor(['b/c'], config);\n      expect(testPathPatterns.isMatch('/a/b/c/d')).toBe(true);\n    });\n\n    it('returns true for explicit relative path', () => {\n      const testPathPatterns = makeExecutor(['./b/c'], {\n        rootDir: '/a',\n      });\n      expect(testPathPatterns.isMatch('/a/b/c')).toBe(true);\n    });\n\n    it('returns true for explicit relative path for Windows with ./', () => {\n      forceWindows();\n      const testPathPatterns = makeExecutor(['./b/c'], {\n        rootDir: 'C:\\\\a',\n      });\n      expect(testPathPatterns.isMatch('C:\\\\a\\\\b\\\\c')).toBe(true);\n    });\n\n    it('returns true for explicit relative path for Windows with .\\\\', () => {\n      forceWindows();\n      const testPathPatterns = makeExecutor(['.\\\\b\\\\c'], {\n        rootDir: 'C:\\\\a',\n      });\n      expect(testPathPatterns.isMatch('C:\\\\a\\\\b\\\\c')).toBe(true);\n    });\n\n    it('returns true for partial file match', () => {\n      const testPathPatterns = makeExecutor(['aaa'], config);\n      expect(testPathPatterns.isMatch('/foo/..aaa..')).toBe(true);\n      expect(testPathPatterns.isMatch('/foo/..aaa')).toBe(true);\n      expect(testPathPatterns.isMatch('/foo/aaa..')).toBe(true);\n    });\n\n    it('returns true for path suffix', () => {\n      const testPathPatterns = makeExecutor(['c/d'], config);\n      expect(testPathPatterns.isMatch('/a/b/c/d')).toBe(true);\n    });\n\n    it('returns true if regex matches', () => {\n      const testPathPatterns = makeExecutor(['ab*c?'], config);\n\n      expect(testPathPatterns.isMatch('/foo/a')).toBe(true);\n      expect(testPathPatterns.isMatch('/foo/ab')).toBe(true);\n      expect(testPathPatterns.isMatch('/foo/abb')).toBe(true);\n      expect(testPathPatterns.isMatch('/foo/ac')).toBe(true);\n      expect(testPathPatterns.isMatch('/foo/abc')).toBe(true);\n      expect(testPathPatterns.isMatch('/foo/abbc')).toBe(true);\n\n      expect(testPathPatterns.isMatch('/foo/bc')).toBe(false);\n    });\n\n    it('returns true only if matches relative path', () => {\n      const rootDir = '/home/myuser/';\n\n      const testPathPatterns = makeExecutor(['home'], {\n        rootDir,\n      });\n      expect(\n        testPathPatterns.isMatch(\n          path.relative(rootDir, '/home/myuser/LoginPage.js'),\n        ),\n      ).toBe(false);\n      expect(\n        testPathPatterns.isMatch(\n          path.relative(rootDir, '/home/myuser/HomePage.js'),\n        ),\n      ).toBe(true);\n    });\n\n    it('matches absolute paths regardless of rootDir', () => {\n      forcePosix();\n      const testPathPatterns = makeExecutor(['/a/b'], {\n        rootDir: '/foo/bar',\n      });\n      expect(testPathPatterns.isMatch('/a/b')).toBe(true);\n    });\n\n    it('matches absolute paths for Windows', () => {\n      forceWindows();\n      const testPathPatterns = makeExecutor(['C:\\\\a\\\\b'], {\n        rootDir: 'C:\\\\foo\\\\bar',\n      });\n      expect(testPathPatterns.isMatch('C:\\\\a\\\\b')).toBe(true);\n    });\n\n    it('returns true if match any paths', () => {\n      const testPathPatterns = makeExecutor(['a/b', 'c/d'], config);\n\n      expect(testPathPatterns.isMatch('/foo/a/b')).toBe(true);\n      expect(testPathPatterns.isMatch('/foo/c/d')).toBe(true);\n\n      expect(testPathPatterns.isMatch('/foo/a')).toBe(false);\n      expect(testPathPatterns.isMatch('/foo/b/c')).toBe(false);\n    });\n\n    it('does not normalize Windows paths on POSIX', () => {\n      forcePosix();\n      const testPathPatterns = makeExecutor(['a\\\\z', 'a\\\\\\\\z'], config);\n      expect(testPathPatterns.isMatch('/foo/a/z')).toBe(false);\n    });\n\n    it('normalizes paths for Windows', () => {\n      forceWindows();\n      const testPathPatterns = makeExecutor(['a/b'], config);\n      expect(testPathPatterns.isMatch('C:\\\\foo\\\\a\\\\b')).toBe(true);\n    });\n\n    it('matches absolute path with absPath', () => {\n      const pattern = '^/home/app/';\n      const rootDir = '/home/app';\n      const absolutePath = '/home/app/packages/';\n\n      const testPathPatterns = makeExecutor([pattern], {\n        rootDir,\n      });\n\n      const relativePath = path.relative(rootDir, absolutePath);\n\n      expect(testPathPatterns.isMatch(relativePath)).toBe(false);\n      expect(testPathPatterns.isMatch(absolutePath)).toBe(true);\n    });\n  });\n});\n",
  "packages/jest-pattern/src/__tests__/TestPathPatterns.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-mock/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/// <reference lib=\"ESNext.Disposable\" preserve=\"true\" />\n\n/* eslint-disable local/prefer-rest-params-eventually */\n\nimport {isPromise} from 'jest-util';\n\nexport type MockMetadataType =\n  | 'object'\n  | 'array'\n  | 'regexp'\n  | 'function'\n  | 'constant'\n  | 'collection'\n  | 'null'\n  | 'undefined';\n\nexport type MockMetadata<T, MetadataType = MockMetadataType> = {\n  ref?: number;\n  members?: Record<string, MockMetadata<T>>;\n  mockImpl?: T;\n  name?: string;\n  refID?: number;\n  type?: MetadataType;\n  value?: T;\n  length?: number;\n};\n\nexport type ClassLike = new (...args: any) => any;\nexport type FunctionLike = (...args: any) => any;\n\nexport type ConstructorLikeKeys<T> = keyof {\n  [K in keyof T as Required<T>[K] extends ClassLike ? K : never]: T[K];\n};\n\nexport type MethodLikeKeys<T> = keyof {\n  [K in keyof T as Required<T>[K] extends FunctionLike ? K : never]: T[K];\n};\n\nexport type PropertyLikeKeys<T> = Exclude<\n  keyof T,\n  ConstructorLikeKeys<T> | MethodLikeKeys<T>\n>;\n\nexport type MockedClass<T extends ClassLike> = MockInstance<\n  (...args: ConstructorParameters<T>) => Mocked<InstanceType<T>>\n> &\n  MockedObject<T>;\n\nexport type MockedFunction<T extends FunctionLike> = MockInstance<T> &\n  MockedObject<T>;\n\ntype MockedFunctionShallow<T extends FunctionLike> = MockInstance<T> & T;\n\nexport type MockedObject<T extends object> = {\n  [K in keyof T]: T[K] extends ClassLike\n    ? MockedClass<T[K]>\n    : T[K] extends FunctionLike\n      ? MockedFunction<T[K]>\n      : T[K] extends object\n        ? MockedObject<T[K]>\n        : T[K];\n} & T;\n\ntype MockedObjectShallow<T extends object> = {\n  [K in keyof T]: T[K] extends ClassLike\n    ? MockedClass<T[K]>\n    : T[K] extends FunctionLike\n      ? MockedFunctionShallow<T[K]>\n      : T[K];\n} & T;\n\nexport type Mocked<T> = T extends ClassLike\n  ? MockedClass<T>\n  : T extends FunctionLike\n    ? MockedFunction<T>\n    : T extends object\n      ? MockedObject<T>\n      : T;\n\nexport type MockedShallow<T> = T extends ClassLike\n  ? MockedClass<T>\n  : T extends FunctionLike\n    ? MockedFunctionShallow<T>\n    : T extends object\n      ? MockedObjectShallow<T>\n      : T;\n\nexport type UnknownFunction = (...args: Array<unknown>) => unknown;\nexport type UnknownClass = new (...args: Array<unknown>) => unknown;\n\nexport type SpiedClass<T extends ClassLike = UnknownClass> = MockInstance<\n  (...args: ConstructorParameters<T>) => InstanceType<T>\n>;\n\nexport type SpiedFunction<T extends FunctionLike = UnknownFunction> =\n  MockInstance<(...args: Parameters<T>) => ReturnType<T>>;\n\nexport type SpiedGetter<T> = MockInstance<() => T>;\n\nexport type SpiedSetter<T> = MockInstance<(arg: T) => void>;\n\nexport type Spied<T extends ClassLike | FunctionLike> = T extends ClassLike\n  ? SpiedClass<T>\n  : T extends FunctionLike\n    ? SpiedFunction<T>\n    : never;\n\n/**\n * All what the internal typings need is to be sure that we have any-function.\n * `FunctionLike` type ensures that and helps to constrain the type as well.\n * The default of `UnknownFunction` makes sure that `any`s do not leak to the\n * user side. For instance, calling `fn()` without implementation will return\n * a mock of `(...args: Array<unknown>) => unknown` type. If implementation\n * is provided, its typings are inferred correctly.\n */\nexport interface Mock<T extends FunctionLike = UnknownFunction>\n  extends Function,\n    MockInstance<T> {\n  new (...args: Parameters<T>): ReturnType<T>;\n  (...args: Parameters<T>): ReturnType<T>;\n}\n\ntype ResolveType<T extends FunctionLike> =\n  ReturnType<T> extends PromiseLike<infer U> ? U : never;\n\ntype RejectType<T extends FunctionLike> =\n  ReturnType<T> extends PromiseLike<any> ? unknown : never;\n\nexport interface MockInstance<T extends FunctionLike = UnknownFunction>\n  extends Disposable {\n  _isMockFunction: true;\n  _protoImpl: Function;\n  getMockImplementation(): T | undefined;\n  getMockName(): string;\n  mock: MockFunctionState<T>;\n  mockClear(): this;\n  mockReset(): this;\n  mockRestore(): void;\n  mockImplementation(fn: T): this;\n  mockImplementationOnce(fn: T): this;\n  withImplementation(fn: T, callback: () => Promise<unknown>): Promise<void>;\n  withImplementation(fn: T, callback: () => void): void;\n  mockName(name: string): this;\n  mockReturnThis(): this;\n  mockReturnValue(value: ReturnType<T>): this;\n  mockReturnValueOnce(value: ReturnType<T>): this;\n  mockResolvedValue(value: ResolveType<T>): this;\n  mockResolvedValueOnce(value: ResolveType<T>): this;\n  mockRejectedValue(value: RejectType<T>): this;\n  mockRejectedValueOnce(value: RejectType<T>): this;\n}\n\nexport interface Replaced<T = unknown> {\n  /**\n   * Restore property to its original value known at the time of mocking.\n   */\n  restore(): void;\n  /**\n   * Change the value of the property.\n   */\n  replaceValue(value: T): this;\n}\n\ntype ReplacedPropertyRestorer<T extends object, K extends keyof T> = {\n  (): void;\n  object: T;\n  property: K;\n  replaced: Replaced<T[K]>;\n};\n\ntype MockFunctionResultIncomplete = {\n  type: 'incomplete';\n  /**\n   * Result of a single call to a mock function that has not yet completed.\n   * This occurs if you test the result from within the mock function itself,\n   * or from within a function that was called by the mock.\n   */\n  value: undefined;\n};\ntype MockFunctionResultReturn<T extends FunctionLike = UnknownFunction> = {\n  type: 'return';\n  /**\n   * Result of a single call to a mock function that returned.\n   */\n  value: ReturnType<T>;\n};\ntype MockFunctionResultThrow = {\n  type: 'throw';\n  /**\n   * Result of a single call to a mock function that threw.\n   */\n  value: unknown;\n};\n\ntype MockFunctionResult<T extends FunctionLike = UnknownFunction> =\n  | MockFunctionResultIncomplete\n  | MockFunctionResultReturn<T>\n  | MockFunctionResultThrow;\n\ntype MockFunctionState<T extends FunctionLike = UnknownFunction> = {\n  /**\n   * List of the call arguments of all calls that have been made to the mock.\n   */\n  calls: Array<Parameters<T>>;\n  /**\n   * List of all the object instances that have been instantiated from the mock.\n   */\n  instances: Array<ReturnType<T>>;\n  /**\n   * List of all the function contexts that have been applied to calls to the mock.\n   */\n  contexts: Array<ThisParameterType<T>>;\n  /**\n   * List of the call order indexes of the mock. Jest is indexing the order of\n   * invocations of all mocks in a test file. The index is starting with `1`.\n   */\n  invocationCallOrder: Array<number>;\n  /**\n   * List of the call arguments of the last call that was made to the mock.\n   * If the function was not called, it will return `undefined`.\n   */\n  lastCall?: Parameters<T>;\n  /**\n   * List of the results of all calls that have been made to the mock.\n   */\n  results: Array<MockFunctionResult<T>>;\n};\n\ntype MockFunctionConfig = {\n  mockImpl: Function | undefined;\n  mockName: string;\n  specificMockImpls: Array<Function>;\n};\n\nconst MOCK_CONSTRUCTOR_NAME = 'mockConstructor';\n\nconst FUNCTION_NAME_RESERVED_PATTERN = /[\\s!-/:-@[-`{-~]/;\nconst FUNCTION_NAME_RESERVED_REPLACE = new RegExp(\n  FUNCTION_NAME_RESERVED_PATTERN.source,\n  'g',\n);\n\nconst RESERVED_KEYWORDS = new Set([\n  'arguments',\n  'await',\n  'break',\n  'case',\n  'catch',\n  'class',\n  'const',\n  'continue',\n  'debugger',\n  'default',\n  'delete',\n  'do',\n  'else',\n  'enum',\n  'eval',\n  'export',\n  'extends',\n  'false',\n  'finally',\n  'for',\n  'function',\n  'if',\n  'implements',\n  'import',\n  'in',\n  'instanceof',\n  'interface',\n  'let',\n  'new',\n  'null',\n  'package',\n  'private',\n  'protected',\n  'public',\n  'return',\n  'static',\n  'super',\n  'switch',\n  'this',\n  'throw',\n  'true',\n  'try',\n  'typeof',\n  'var',\n  'void',\n  'while',\n  'with',\n  'yield',\n]);\n\nfunction matchArity(fn: Function, length: number): Function {\n  let mockConstructor;\n\n  switch (length) {\n    case 1:\n      mockConstructor = function (this: unknown, _a: unknown) {\n        return fn.apply(this, arguments);\n      };\n      break;\n    case 2:\n      mockConstructor = function (this: unknown, _a: unknown, _b: unknown) {\n        return fn.apply(this, arguments);\n      };\n      break;\n    case 3:\n      mockConstructor = function (\n        this: unknown,\n        _a: unknown,\n        _b: unknown,\n        _c: unknown,\n      ) {\n        return fn.apply(this, arguments);\n      };\n      break;\n    case 4:\n      mockConstructor = function (\n        this: unknown,\n        _a: unknown,\n        _b: unknown,\n        _c: unknown,\n        _d: unknown,\n      ) {\n        return fn.apply(this, arguments);\n      };\n      break;\n    case 5:\n      mockConstructor = function (\n        this: unknown,\n        _a: unknown,\n        _b: unknown,\n        _c: unknown,\n        _d: unknown,\n        _e: unknown,\n      ) {\n        return fn.apply(this, arguments);\n      };\n      break;\n    case 6:\n      mockConstructor = function (\n        this: unknown,\n        _a: unknown,\n        _b: unknown,\n        _c: unknown,\n        _d: unknown,\n        _e: unknown,\n        _f: unknown,\n      ) {\n        return fn.apply(this, arguments);\n      };\n      break;\n    case 7:\n      mockConstructor = function (\n        this: unknown,\n        _a: unknown,\n        _b: unknown,\n        _c: unknown,\n        _d: unknown,\n        _e: unknown,\n        _f: unknown,\n        _g: unknown,\n      ) {\n        return fn.apply(this, arguments);\n      };\n      break;\n    case 8:\n      mockConstructor = function (\n        this: unknown,\n        _a: unknown,\n        _b: unknown,\n        _c: unknown,\n        _d: unknown,\n        _e: unknown,\n        _f: unknown,\n        _g: unknown,\n        _h: unknown,\n      ) {\n        return fn.apply(this, arguments);\n      };\n      break;\n    case 9:\n      mockConstructor = function (\n        this: unknown,\n        _a: unknown,\n        _b: unknown,\n        _c: unknown,\n        _d: unknown,\n        _e: unknown,\n        _f: unknown,\n        _g: unknown,\n        _h: unknown,\n        _i: unknown,\n      ) {\n        return fn.apply(this, arguments);\n      };\n      break;\n    default:\n      mockConstructor = function (this: unknown) {\n        return fn.apply(this, arguments);\n      };\n      break;\n  }\n\n  return mockConstructor;\n}\n\nfunction getObjectType(value: unknown): string {\n  return Object.prototype.toString.apply(value).slice(8, -1);\n}\n\nfunction getType(ref?: unknown): MockMetadataType | null {\n  const typeName = getObjectType(ref);\n  if (\n    typeName === 'Function' ||\n    typeName === 'AsyncFunction' ||\n    typeName === 'GeneratorFunction' ||\n    typeName === 'AsyncGeneratorFunction'\n  ) {\n    return 'function';\n  } else if (Array.isArray(ref)) {\n    return 'array';\n  } else if (typeName === 'Object' || typeName === 'Module') {\n    return 'object';\n  } else if (\n    typeName === 'Number' ||\n    typeName === 'String' ||\n    typeName === 'Boolean' ||\n    typeName === 'Symbol'\n  ) {\n    return 'constant';\n  } else if (\n    typeName === 'Map' ||\n    typeName === 'WeakMap' ||\n    typeName === 'Set'\n  ) {\n    return 'collection';\n  } else if (typeName === 'RegExp') {\n    return 'regexp';\n  } else if (ref === undefined) {\n    return 'undefined';\n  } else if (ref === null) {\n    return 'null';\n  } else {\n    return null;\n  }\n}\n\nfunction isReadonlyProp(object: unknown, prop: string): boolean {\n  if (\n    prop === 'arguments' ||\n    prop === 'caller' ||\n    prop === 'callee' ||\n    prop === 'name' ||\n    prop === 'length'\n  ) {\n    const typeName = getObjectType(object);\n    return (\n      typeName === 'Function' ||\n      typeName === 'AsyncFunction' ||\n      typeName === 'GeneratorFunction' ||\n      typeName === 'AsyncGeneratorFunction'\n    );\n  }\n\n  if (\n    prop === 'source' ||\n    prop === 'global' ||\n    prop === 'ignoreCase' ||\n    prop === 'multiline'\n  ) {\n    return getObjectType(object) === 'RegExp';\n  }\n\n  return false;\n}\n\nexport class ModuleMocker {\n  private readonly _environmentGlobal: typeof globalThis;\n  private _mockState: WeakMap<Mock, MockFunctionState>;\n  private _mockConfigRegistry: WeakMap<Function, MockFunctionConfig>;\n  private _spyState: Set<() => void>;\n  private _invocationCallCounter: number;\n\n  /**\n   * @see README.md\n   * @param global Global object of the test environment, used to create\n   * mocks\n   */\n  constructor(global: typeof globalThis) {\n    this._environmentGlobal = global;\n    this._mockState = new WeakMap();\n    this._mockConfigRegistry = new WeakMap();\n    this._spyState = new Set();\n    this._invocationCallCounter = 1;\n  }\n\n  private _getSlots(object?: Record<string, any>): Array<string> {\n    if (!object) {\n      return [];\n    }\n\n    const slots = new Set<string>();\n    const EnvObjectProto = this._environmentGlobal.Object.prototype;\n    const EnvFunctionProto = this._environmentGlobal.Function.prototype;\n    const EnvRegExpProto = this._environmentGlobal.RegExp.prototype;\n\n    // Also check the builtins in the current context as they leak through\n    // core node modules.\n    const ObjectProto = Object.prototype;\n    const FunctionProto = Function.prototype;\n    const RegExpProto = RegExp.prototype;\n\n    // Properties of Object.prototype, Function.prototype and RegExp.prototype\n    // are never reported as slots\n    while (\n      object != null &&\n      object !== EnvObjectProto &&\n      object !== EnvFunctionProto &&\n      object !== EnvRegExpProto &&\n      object !== ObjectProto &&\n      object !== FunctionProto &&\n      object !== RegExpProto\n    ) {\n      const ownNames = Object.getOwnPropertyNames(object);\n\n      for (const prop of ownNames) {\n        if (!isReadonlyProp(object, prop)) {\n          const propDesc = Object.getOwnPropertyDescriptor(object, prop);\n          if ((propDesc !== undefined && !propDesc.get) || object.__esModule) {\n            slots.add(prop);\n          }\n        }\n      }\n\n      object = Object.getPrototypeOf(object);\n    }\n\n    return [...slots];\n  }\n\n  private _ensureMockConfig(f: Mock): MockFunctionConfig {\n    let config = this._mockConfigRegistry.get(f);\n    if (!config) {\n      config = this._defaultMockConfig();\n      this._mockConfigRegistry.set(f, config);\n    }\n    return config;\n  }\n\n  private _ensureMockState<T extends UnknownFunction>(\n    f: Mock<T>,\n  ): MockFunctionState<T> {\n    let state = this._mockState.get(f);\n    if (!state) {\n      state = this._defaultMockState();\n      this._mockState.set(f, state);\n    }\n    if (state.calls.length > 0) {\n      state.lastCall = state.calls.at(-1);\n    }\n    return state;\n  }\n\n  private _defaultMockConfig(): MockFunctionConfig {\n    return {\n      mockImpl: undefined,\n      mockName: 'jest.fn()',\n      specificMockImpls: [],\n    };\n  }\n\n  private _defaultMockState(): MockFunctionState {\n    return {\n      calls: [],\n      contexts: [],\n      instances: [],\n      invocationCallOrder: [],\n      results: [],\n    };\n  }\n\n  /* eslint-disable @typescript-eslint/unified-signatures */\n  private _makeComponent<T extends Record<string, any>>(\n    metadata: MockMetadata<T, 'object'>,\n    restore?: () => void,\n  ): T;\n  private _makeComponent<T extends Array<unknown>>(\n    metadata: MockMetadata<T, 'array'>,\n    restore?: () => void,\n  ): T;\n  private _makeComponent<T extends RegExp>(\n    metadata: MockMetadata<T, 'regexp'>,\n    restore?: () => void,\n  ): T;\n  private _makeComponent<T>(\n    metadata: MockMetadata<T, 'constant' | 'collection' | 'null' | 'undefined'>,\n    restore?: () => void,\n  ): T;\n  private _makeComponent<T extends UnknownFunction>(\n    metadata: MockMetadata<T, 'function'>,\n    restore?: () => void,\n  ): Mock<T>;\n  private _makeComponent<T>(\n    metadata: MockMetadata<T>,\n    restore?: () => void,\n  ): Record<string, any>;\n  /* eslint-enable @typescript-eslint/unified-signatures */\n  private _makeComponent<T extends UnknownFunction>(\n    metadata: MockMetadata<T>,\n    restore?: () => void,\n  ): Record<string, any> | Array<unknown> | RegExp | T | Mock | undefined {\n    if (metadata.type === 'object') {\n      return new this._environmentGlobal.Object();\n    } else if (metadata.type === 'array') {\n      return new this._environmentGlobal.Array();\n    } else if (metadata.type === 'regexp') {\n      return new this._environmentGlobal.RegExp('');\n    } else if (\n      metadata.type === 'constant' ||\n      metadata.type === 'collection' ||\n      metadata.type === 'null' ||\n      metadata.type === 'undefined'\n    ) {\n      return metadata.value;\n    } else if (metadata.type === 'function') {\n      const prototype = metadata.members?.prototype?.members ?? {};\n      const prototypeSlots = this._getSlots(prototype);\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      const mocker = this;\n      const mockConstructor = matchArity(function (\n        this: ReturnType<T>,\n        ...args: Parameters<T>\n      ) {\n        const mockState = mocker._ensureMockState(f);\n        const mockConfig = mocker._ensureMockConfig(f);\n        mockState.instances.push(this);\n        mockState.contexts.push(this);\n        mockState.calls.push(args);\n        // Create and record an \"incomplete\" mock result immediately upon\n        // calling rather than waiting for the mock to return. This avoids\n        // issues caused by recursion where results can be recorded in the\n        // wrong order.\n        const mockResult: MockFunctionResult = {\n          type: 'incomplete',\n          value: undefined,\n        };\n        mockState.results.push(mockResult);\n        mockState.invocationCallOrder.push(mocker._invocationCallCounter++);\n\n        // Will be set to the return value of the mock if an error is not thrown\n        let finalReturnValue;\n        // Will be set to the error that is thrown by the mock (if it throws)\n        let thrownError;\n        // Will be set to true if the mock throws an error. The presence of a\n        // value in `thrownError` is not a 100% reliable indicator because a\n        // function could throw a value of undefined.\n        let callDidThrowError = false;\n\n        try {\n          // The bulk of the implementation is wrapped in an immediately\n          // executed arrow function so the return value of the mock function\n          // can be easily captured and recorded, despite the many separate\n          // return points within the logic.\n          finalReturnValue = (() => {\n            if (this instanceof f) {\n              // This is probably being called as a constructor\n              for (const slot of prototypeSlots) {\n                // Copy prototype methods to the instance to make\n                // it easier to interact with mock instance call and\n                // return values\n                if (prototype[slot].type === 'function') {\n                  // @ts-expect-error no index signature\n                  const protoImpl = this[slot];\n                  // @ts-expect-error no index signature\n                  this[slot] = mocker.generateFromMetadata(prototype[slot]);\n                  // @ts-expect-error no index signature\n                  this[slot]._protoImpl = protoImpl;\n                }\n              }\n\n              // Run the mock constructor implementation\n              const mockImpl =\n                mockConfig.specificMockImpls.length > 0\n                  ? mockConfig.specificMockImpls.shift()\n                  : mockConfig.mockImpl;\n              return mockImpl && mockImpl.apply(this, arguments);\n            }\n\n            // If mockImplementationOnce()/mockImplementation() is last set,\n            // implementation use the mock\n            let specificMockImpl = mockConfig.specificMockImpls.shift();\n            if (specificMockImpl === undefined) {\n              specificMockImpl = mockConfig.mockImpl;\n            }\n            if (specificMockImpl) {\n              return specificMockImpl.apply(this, arguments);\n            }\n            // Otherwise use prototype implementation\n            if (f._protoImpl) {\n              return f._protoImpl.apply(this, arguments);\n            }\n\n            return undefined;\n          })();\n        } catch (error) {\n          // Store the thrown error so we can record it, then re-throw it.\n          thrownError = error;\n          callDidThrowError = true;\n          throw error;\n        } finally {\n          // Record the result of the function.\n          // NOTE: Intentionally NOT pushing/indexing into the array of mock\n          //       results here to avoid corrupting results data if mockClear()\n          //       is called during the execution of the mock.\n          // @ts-expect-error reassigning 'incomplete'\n          mockResult.type = callDidThrowError ? 'throw' : 'return';\n          mockResult.value = callDidThrowError ? thrownError : finalReturnValue;\n        }\n\n        return finalReturnValue;\n      }, metadata.length || 0);\n\n      const f = this._createMockFunction(metadata, mockConstructor) as Mock;\n      f._isMockFunction = true;\n      f.getMockImplementation = () => this._ensureMockConfig(f).mockImpl as T;\n\n      if (typeof restore === 'function') {\n        this._spyState.add(restore);\n      }\n\n      this._mockState.set(f, this._defaultMockState());\n      this._mockConfigRegistry.set(f, this._defaultMockConfig());\n\n      Object.defineProperty(f, 'mock', {\n        configurable: false,\n        enumerable: true,\n        get: () => this._ensureMockState(f),\n        set: val => this._mockState.set(f, val),\n      });\n\n      f.mockClear = () => {\n        this._mockState.delete(f);\n        return f;\n      };\n\n      f.mockReset = () => {\n        f.mockClear();\n        this._mockConfigRegistry.delete(f);\n        return f;\n      };\n\n      f.mockRestore = () => {\n        f.mockReset();\n        return restore ? restore() : undefined;\n      };\n\n      f.mockReturnValueOnce = (value: ReturnType<T>) =>\n        // next function call will return this value or default return value\n        f.mockImplementationOnce(() => value);\n\n      f.mockResolvedValueOnce = (value: ResolveType<T>) =>\n        f.mockImplementationOnce(() =>\n          this._environmentGlobal.Promise.resolve(value),\n        );\n\n      f.mockRejectedValueOnce = (value: unknown) =>\n        f.mockImplementationOnce(() =>\n          this._environmentGlobal.Promise.reject(value),\n        );\n\n      f.mockReturnValue = (value: ReturnType<T>) =>\n        // next function call will return specified return value or this one\n        f.mockImplementation(() => value);\n\n      f.mockResolvedValue = (value: ResolveType<T>) =>\n        f.mockImplementation(() =>\n          this._environmentGlobal.Promise.resolve(value),\n        );\n\n      f.mockRejectedValue = (value: unknown) =>\n        f.mockImplementation(() =>\n          this._environmentGlobal.Promise.reject(value),\n        );\n\n      f.mockImplementationOnce = (fn: T) => {\n        // next function call will use this mock implementation return value\n        // or default mock implementation return value\n        const mockConfig = this._ensureMockConfig(f);\n        mockConfig.specificMockImpls.push(fn);\n        return f;\n      };\n\n      f.withImplementation = withImplementation.bind(this);\n      if (Symbol.dispose) {\n        f[Symbol.dispose] = f.mockRestore;\n      }\n\n      function withImplementation(fn: T, callback: () => void): void;\n      function withImplementation(\n        fn: T,\n        callback: () => Promise<unknown>,\n      ): Promise<void>;\n      function withImplementation(\n        this: ModuleMocker,\n        fn: T,\n        callback: (() => void) | (() => Promise<unknown>),\n      ): void | Promise<void> {\n        // Remember previous mock implementation, then set new one\n        const mockConfig = this._ensureMockConfig(f);\n        const previousImplementation = mockConfig.mockImpl;\n        const previousSpecificImplementations = mockConfig.specificMockImpls;\n        mockConfig.mockImpl = fn;\n        mockConfig.specificMockImpls = [];\n\n        const returnedValue = callback();\n\n        if (isPromise(returnedValue)) {\n          return returnedValue.then(() => {\n            mockConfig.mockImpl = previousImplementation;\n            mockConfig.specificMockImpls = previousSpecificImplementations;\n          });\n        } else {\n          mockConfig.mockImpl = previousImplementation;\n          mockConfig.specificMockImpls = previousSpecificImplementations;\n        }\n      }\n\n      f.mockImplementation = (fn: T) => {\n        // next function call will use mock implementation return value\n        const mockConfig = this._ensureMockConfig(f);\n        mockConfig.mockImpl = fn;\n        return f;\n      };\n\n      f.mockReturnThis = () =>\n        f.mockImplementation(function (this: ReturnType<T>) {\n          return this;\n        });\n\n      f.mockName = (name: string) => {\n        if (name) {\n          const mockConfig = this._ensureMockConfig(f);\n          mockConfig.mockName = name;\n        }\n        return f;\n      };\n\n      f.getMockName = () => {\n        const mockConfig = this._ensureMockConfig(f);\n        return mockConfig.mockName || 'jest.fn()';\n      };\n\n      if (metadata.mockImpl) {\n        f.mockImplementation(metadata.mockImpl);\n      }\n\n      return f;\n    } else {\n      const unknownType = metadata.type || 'undefined type';\n      throw new Error(`Unrecognized type ${unknownType}`);\n    }\n  }\n\n  private _createMockFunction<T extends UnknownFunction>(\n    metadata: MockMetadata<T>,\n    mockConstructor: Function,\n  ): Function {\n    let name = metadata.name;\n    if (!name) {\n      return mockConstructor;\n    }\n\n    // Preserve `name` property of mocked function.\n    const boundFunctionPrefix = 'bound ';\n    let bindCall = '';\n    // if-do-while for perf reasons. The common case is for the if to fail.\n    if (name.startsWith(boundFunctionPrefix)) {\n      do {\n        name = name.slice(boundFunctionPrefix.length);\n        // Call bind() just to alter the function name.\n        bindCall = '.bind(null)';\n      } while (name && name.startsWith(boundFunctionPrefix));\n    }\n\n    // Special case functions named `mockConstructor` to guard for infinite loops\n    if (name === MOCK_CONSTRUCTOR_NAME) {\n      return mockConstructor;\n    }\n\n    if (\n      // It's a syntax error to define functions with a reserved keyword as name\n      RESERVED_KEYWORDS.has(name) ||\n      // It's also a syntax error to define functions with a name that starts with a number\n      /^\\d/.test(name)\n    ) {\n      name = `$${name}`;\n    }\n\n    // It's also a syntax error to define a function with a reserved character\n    // as part of it's name.\n    if (FUNCTION_NAME_RESERVED_PATTERN.test(name)) {\n      name = name.replaceAll(FUNCTION_NAME_RESERVED_REPLACE, '$');\n    }\n\n    const body =\n      `return function ${name}() {` +\n      `  return ${MOCK_CONSTRUCTOR_NAME}.apply(this,arguments);` +\n      `}${bindCall}`;\n    const createConstructor = new this._environmentGlobal.Function(\n      MOCK_CONSTRUCTOR_NAME,\n      body,\n    );\n\n    return createConstructor(mockConstructor);\n  }\n\n  private _generateMock<T>(\n    metadata: MockMetadata<T>,\n    callbacks: Array<Function>,\n    refs: Record<\n      number,\n      Record<string, any> | Array<unknown> | RegExp | T | Mock | undefined\n    >,\n  ): Mocked<T> {\n    const mock = this._makeComponent(metadata);\n    if (metadata.refID != null) {\n      refs[metadata.refID] = mock;\n    }\n\n    for (const slot of this._getSlots(metadata.members)) {\n      const slotMetadata = (metadata.members && metadata.members[slot]) || {};\n      if (slotMetadata.ref == null) {\n        mock[slot] = this._generateMock(slotMetadata, callbacks, refs);\n      } else {\n        callbacks.push(\n          (function (ref) {\n            return () => (mock[slot] = refs[ref]);\n          })(slotMetadata.ref),\n        );\n      }\n    }\n\n    if (\n      metadata.type !== 'undefined' &&\n      metadata.type !== 'null' &&\n      mock.prototype &&\n      typeof mock.prototype === 'object'\n    ) {\n      mock.prototype.constructor = mock;\n    }\n\n    return mock as Mocked<T>;\n  }\n\n  /**\n   * Check whether the given property of an object has been already replaced.\n   */\n  private _findReplacedProperty<T extends object, K extends keyof T>(\n    object: T,\n    propertyKey: K,\n  ): ReplacedPropertyRestorer<T, K> | undefined {\n    for (const spyState of this._spyState) {\n      if (\n        'object' in spyState &&\n        'property' in spyState &&\n        spyState.object === object &&\n        spyState.property === propertyKey\n      ) {\n        return spyState as ReplacedPropertyRestorer<T, K>;\n      }\n    }\n\n    return;\n  }\n\n  /**\n   * @see README.md\n   * @param metadata Metadata for the mock in the schema returned by the\n   * getMetadata method of this module.\n   */\n  generateFromMetadata<T>(metadata: MockMetadata<T>): Mocked<T> {\n    const callbacks: Array<Function> = [];\n    const refs = {};\n    const mock = this._generateMock<T>(metadata, callbacks, refs);\n    for (const setter of callbacks) setter();\n    return mock;\n  }\n\n  /**\n   * @see README.md\n   * @param component The component for which to retrieve metadata.\n   */\n  getMetadata<T = unknown>(\n    component: T,\n    _refs?: Map<T, number>,\n  ): MockMetadata<T> | null {\n    const refs = _refs || new Map<T, number>();\n    const ref = refs.get(component);\n    if (ref != null) {\n      return {ref};\n    }\n\n    const type = getType(component);\n    if (!type) {\n      return null;\n    }\n\n    const metadata: MockMetadata<T> = {type};\n    if (\n      type === 'constant' ||\n      type === 'collection' ||\n      type === 'undefined' ||\n      type === 'null'\n    ) {\n      metadata.value = component;\n      return metadata;\n    } else if (type === 'function') {\n      // @ts-expect-error component is a function so it has a name, but not\n      // necessarily a string: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name#function_names_in_classes\n      const componentName = component.name;\n      if (typeof componentName === 'string') {\n        metadata.name = componentName;\n      }\n      if (this.isMockFunction(component)) {\n        metadata.mockImpl = component.getMockImplementation() as T;\n      }\n    }\n\n    metadata.refID = refs.size;\n    refs.set(component, metadata.refID);\n\n    let members: Record<string, MockMetadata<T>> | null = null;\n    // Leave arrays alone\n    if (type !== 'array') {\n      // @ts-expect-error component is object\n      for (const slot of this._getSlots(component)) {\n        if (\n          type === 'function' &&\n          this.isMockFunction(component) &&\n          slot.startsWith('mock')\n        ) {\n          continue;\n        }\n        // @ts-expect-error no index signature\n        const slotMetadata = this.getMetadata<T>(component[slot], refs);\n        if (slotMetadata) {\n          if (!members) {\n            members = {};\n          }\n          members[slot] = slotMetadata;\n        }\n      }\n    }\n\n    if (members) {\n      metadata.members = members;\n    }\n\n    return metadata;\n  }\n\n  isMockFunction<T extends FunctionLike = UnknownFunction>(\n    fn: MockInstance<T>,\n  ): fn is MockInstance<T>;\n  isMockFunction<P extends Array<unknown>, R>(\n    fn: (...args: P) => R,\n  ): fn is Mock<(...args: P) => R>;\n  isMockFunction(fn: unknown): fn is Mock<UnknownFunction>;\n  isMockFunction(fn: unknown): fn is Mock<UnknownFunction> {\n    return fn != null && (fn as Mock)._isMockFunction === true;\n  }\n\n  fn<T extends FunctionLike = UnknownFunction>(implementation?: T): Mock<T> {\n    const length = implementation ? implementation.length : 0;\n    const fn = this._makeComponent<T>({\n      length,\n      type: 'function',\n    });\n    if (implementation) {\n      fn.mockImplementation(implementation);\n    }\n    return fn;\n  }\n\n  spyOn<\n    T extends object,\n    K extends PropertyLikeKeys<T>,\n    V extends Required<T>[K],\n    A extends 'get' | 'set',\n  >(\n    object: T,\n    methodKey: K,\n    accessType: A,\n  ): A extends 'get'\n    ? SpiedGetter<V>\n    : A extends 'set'\n      ? SpiedSetter<V>\n      : never;\n\n  spyOn<\n    T extends object,\n    K extends ConstructorLikeKeys<T> | MethodLikeKeys<T>,\n    V extends Required<T>[K],\n  >(\n    object: T,\n    methodKey: K,\n  ): V extends ClassLike | FunctionLike ? Spied<V> : never;\n\n  spyOn<T extends object>(\n    object: T,\n    methodKey: keyof T,\n    accessType?: 'get' | 'set',\n  ): MockInstance {\n    if (\n      object == null ||\n      (typeof object !== 'object' && typeof object !== 'function')\n    ) {\n      throw new Error(\n        `Cannot use spyOn on a primitive value; ${this._typeOf(object)} given`,\n      );\n    }\n\n    if (methodKey == null) {\n      throw new Error('No property name supplied');\n    }\n\n    if (accessType) {\n      return this._spyOnProperty(object, methodKey, accessType);\n    }\n\n    const original = object[methodKey];\n\n    if (!original) {\n      throw new Error(\n        `Property \\`${String(\n          methodKey,\n        )}\\` does not exist in the provided object`,\n      );\n    }\n\n    if (!this.isMockFunction(original)) {\n      if (typeof original !== 'function') {\n        throw new TypeError(\n          `Cannot spy on the \\`${String(\n            methodKey,\n          )}\\` property because it is not a function; ${this._typeOf(\n            original,\n          )} given instead.${\n            typeof original === 'object'\n              ? ''\n              : ` If you are trying to mock a property, use \\`jest.replaceProperty(object, '${String(\n                  methodKey,\n                )}', value)\\` instead.`\n          }`,\n        );\n      }\n\n      const isMethodOwner = Object.prototype.hasOwnProperty.call(\n        object,\n        methodKey,\n      );\n\n      let descriptor = Object.getOwnPropertyDescriptor(object, methodKey);\n      let proto = Object.getPrototypeOf(object);\n\n      while (!descriptor && proto !== null) {\n        descriptor = Object.getOwnPropertyDescriptor(proto, methodKey);\n        proto = Object.getPrototypeOf(proto);\n      }\n\n      let mock: Mock;\n\n      if (descriptor && descriptor.get) {\n        const originalGet = descriptor.get;\n        mock = this._makeComponent({type: 'function'}, () => {\n          descriptor!.get = originalGet;\n          Object.defineProperty(object, methodKey, descriptor!);\n        });\n        descriptor.get = () => mock;\n        Object.defineProperty(object, methodKey, descriptor);\n      } else {\n        mock = this._makeComponent({type: 'function'}, () => {\n          if (isMethodOwner) {\n            object[methodKey] = original;\n          } else {\n            delete object[methodKey];\n          }\n        });\n        // @ts-expect-error overriding original method with a Mock\n        object[methodKey] = mock;\n      }\n\n      mock.mockImplementation(function (this: unknown) {\n        return original.apply(this, arguments);\n      });\n    }\n\n    return object[methodKey] as Mock;\n  }\n\n  private _spyOnProperty<T extends object>(\n    object: T,\n    propertyKey: keyof T,\n    accessType: 'get' | 'set',\n  ): MockInstance {\n    let descriptor = Object.getOwnPropertyDescriptor(object, propertyKey);\n    let proto = Object.getPrototypeOf(object);\n\n    while (!descriptor && proto !== null) {\n      descriptor = Object.getOwnPropertyDescriptor(proto, propertyKey);\n      proto = Object.getPrototypeOf(proto);\n    }\n\n    if (!descriptor) {\n      throw new Error(\n        `Property \\`${String(\n          propertyKey,\n        )}\\` does not exist in the provided object`,\n      );\n    }\n\n    if (!descriptor.configurable) {\n      throw new Error(\n        `Property \\`${String(propertyKey)}\\` is not declared configurable`,\n      );\n    }\n\n    if (!descriptor[accessType]) {\n      throw new Error(\n        `Property \\`${String(\n          propertyKey,\n        )}\\` does not have access type ${accessType}`,\n      );\n    }\n\n    const original = descriptor[accessType];\n\n    if (!this.isMockFunction(original)) {\n      if (typeof original !== 'function') {\n        throw new TypeError(\n          `Cannot spy on the ${String(\n            propertyKey,\n          )} property because it is not a function; ${this._typeOf(\n            original,\n          )} given instead.${\n            typeof original === 'object'\n              ? ''\n              : ` If you are trying to mock a property, use \\`jest.replaceProperty(object, '${String(\n                  propertyKey,\n                )}', value)\\` instead.`\n          }`,\n        );\n      }\n\n      descriptor[accessType] = this._makeComponent({type: 'function'}, () => {\n        // @ts-expect-error: mock is assignable\n        descriptor![accessType] = original;\n        Object.defineProperty(object, propertyKey, descriptor!);\n      });\n\n      (descriptor[accessType] as Mock).mockImplementation(function (\n        this: unknown,\n      ) {\n        // @ts-expect-error - wrong context\n        return original.apply(this, arguments);\n      });\n    }\n\n    Object.defineProperty(object, propertyKey, descriptor);\n    return descriptor[accessType] as Mock;\n  }\n\n  replaceProperty<T extends object, K extends keyof T>(\n    object: T,\n    propertyKey: K,\n    value: T[K],\n  ): Replaced<T[K]> {\n    if (\n      object == null ||\n      (typeof object !== 'object' && typeof object !== 'function')\n    ) {\n      throw new Error(\n        `Cannot use replaceProperty on a primitive value; ${this._typeOf(\n          object,\n        )} given`,\n      );\n    }\n\n    if (propertyKey == null) {\n      throw new Error('No property name supplied');\n    }\n\n    let descriptor = Object.getOwnPropertyDescriptor(object, propertyKey);\n    let proto = Object.getPrototypeOf(object);\n    while (!descriptor && proto !== null) {\n      descriptor = Object.getOwnPropertyDescriptor(proto, propertyKey);\n      proto = Object.getPrototypeOf(proto);\n    }\n    if (!descriptor) {\n      throw new Error(\n        `Property \\`${String(\n          propertyKey,\n        )}\\` does not exist in the provided object`,\n      );\n    }\n    if (!descriptor.configurable) {\n      throw new Error(\n        `Property \\`${String(propertyKey)}\\` is not declared configurable`,\n      );\n    }\n\n    if (descriptor.get !== undefined) {\n      throw new Error(\n        `Cannot replace the \\`${String(\n          propertyKey,\n        )}\\` property because it has a getter. Use \\`jest.spyOn(object, '${String(\n          propertyKey,\n        )}', 'get').mockReturnValue(value)\\` instead.`,\n      );\n    }\n\n    if (descriptor.set !== undefined) {\n      throw new Error(\n        `Cannot replace the \\`${String(\n          propertyKey,\n        )}\\` property because it has a setter. Use \\`jest.spyOn(object, '${String(\n          propertyKey,\n        )}', 'set').mockReturnValue(value)\\` instead.`,\n      );\n    }\n\n    if (typeof descriptor.value === 'function') {\n      throw new TypeError(\n        `Cannot replace the \\`${String(\n          propertyKey,\n        )}\\` property because it is a function. Use \\`jest.spyOn(object, '${String(\n          propertyKey,\n        )}')\\` instead.`,\n      );\n    }\n\n    const existingRestore = this._findReplacedProperty(object, propertyKey);\n\n    if (existingRestore) {\n      return existingRestore.replaced.replaceValue(value);\n    }\n\n    const isPropertyOwner = Object.prototype.hasOwnProperty.call(\n      object,\n      propertyKey,\n    );\n    const originalValue = descriptor.value;\n\n    const restore: ReplacedPropertyRestorer<T, K> = () => {\n      if (isPropertyOwner) {\n        object[propertyKey] = originalValue;\n      } else {\n        delete object[propertyKey];\n      }\n    };\n\n    const replaced: Replaced<T[K]> = {\n      replaceValue: value => {\n        object[propertyKey] = value;\n\n        return replaced;\n      },\n\n      restore: () => {\n        restore();\n\n        this._spyState.delete(restore);\n      },\n    };\n\n    restore.object = object;\n    restore.property = propertyKey;\n    restore.replaced = replaced;\n\n    this._spyState.add(restore);\n\n    return replaced.replaceValue(value);\n  }\n\n  clearAllMocks(): void {\n    this._mockState = new WeakMap();\n  }\n\n  resetAllMocks(): void {\n    this._mockConfigRegistry = new WeakMap();\n    this._mockState = new WeakMap();\n  }\n\n  restoreAllMocks(): void {\n    for (const restore of this._spyState) restore();\n    this._spyState = new Set();\n  }\n\n  private _typeOf(value: unknown): string {\n    return value == null ? `${value}` : typeof value;\n  }\n\n  mocked<T extends object>(source: T, options?: {shallow: false}): Mocked<T>;\n  mocked<T extends object>(\n    source: T,\n    options: {shallow: true},\n  ): MockedShallow<T>;\n  mocked<T extends object>(\n    source: T,\n    _options?: {shallow: boolean},\n  ): Mocked<T> | MockedShallow<T> {\n    return source as Mocked<T> | MockedShallow<T>;\n  }\n}\n\nconst JestMock = new ModuleMocker(globalThis);\n\nexport const fn = JestMock.fn.bind(JestMock);\nexport const spyOn = JestMock.spyOn.bind(JestMock);\nexport const mocked = JestMock.mocked.bind(JestMock);\nexport const replaceProperty = JestMock.replaceProperty.bind(JestMock);\n",
  "packages/jest-mock/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n/// <reference lib=\"ESNext.Disposable\" preserve=\"true\" />\nexport type MockMetadataType = 'object' | 'array' | 'regexp' | 'function' | 'constant' | 'collection' | 'null' | 'undefined';\nexport type MockMetadata<T, MetadataType = MockMetadataType> = {\n    ref?: number;\n    members?: Record<string, MockMetadata<T>>;\n    mockImpl?: T;\n    name?: string;\n    refID?: number;\n    type?: MetadataType;\n    value?: T;\n    length?: number;\n};\nexport type ClassLike = new (...args: any) => any;\nexport type FunctionLike = (...args: any) => any;\nexport type ConstructorLikeKeys<T> = keyof {\n    [K in keyof T as Required<T>[K] extends ClassLike ? K : never]: T[K];\n};\nexport type MethodLikeKeys<T> = keyof {\n    [K in keyof T as Required<T>[K] extends FunctionLike ? K : never]: T[K];\n};\nexport type PropertyLikeKeys<T> = Exclude<keyof T, ConstructorLikeKeys<T> | MethodLikeKeys<T>>;\nexport type MockedClass<T extends ClassLike> = MockInstance<(...args: ConstructorParameters<T>) => Mocked<InstanceType<T>>> & MockedObject<T>;\nexport type MockedFunction<T extends FunctionLike> = MockInstance<T> & MockedObject<T>;\ntype MockedFunctionShallow<T extends FunctionLike> = MockInstance<T> & T;\nexport type MockedObject<T extends object> = {\n    [K in keyof T]: T[K] extends ClassLike ? MockedClass<T[K]> : T[K] extends FunctionLike ? MockedFunction<T[K]> : T[K] extends object ? MockedObject<T[K]> : T[K];\n} & T;\ntype MockedObjectShallow<T extends object> = {\n    [K in keyof T]: T[K] extends ClassLike ? MockedClass<T[K]> : T[K] extends FunctionLike ? MockedFunctionShallow<T[K]> : T[K];\n} & T;\nexport type Mocked<T> = T extends ClassLike ? MockedClass<T> : T extends FunctionLike ? MockedFunction<T> : T extends object ? MockedObject<T> : T;\nexport type MockedShallow<T> = T extends ClassLike ? MockedClass<T> : T extends FunctionLike ? MockedFunctionShallow<T> : T extends object ? MockedObjectShallow<T> : T;\nexport type UnknownFunction = (...args: Array<unknown>) => unknown;\nexport type UnknownClass = new (...args: Array<unknown>) => unknown;\nexport type SpiedClass<T extends ClassLike = UnknownClass> = MockInstance<(...args: ConstructorParameters<T>) => InstanceType<T>>;\nexport type SpiedFunction<T extends FunctionLike = UnknownFunction> = MockInstance<(...args: Parameters<T>) => ReturnType<T>>;\nexport type SpiedGetter<T> = MockInstance<() => T>;\nexport type SpiedSetter<T> = MockInstance<(arg: T) => void>;\nexport type Spied<T extends ClassLike | FunctionLike> = T extends ClassLike ? SpiedClass<T> : T extends FunctionLike ? SpiedFunction<T> : never;\n/**\n * All what the internal typings need is to be sure that we have any-function.\n * `FunctionLike` type ensures that and helps to constrain the type as well.\n * The default of `UnknownFunction` makes sure that `any`s do not leak to the\n * user side. For instance, calling `fn()` without implementation will return\n * a mock of `(...args: Array<unknown>) => unknown` type. If implementation\n * is provided, its typings are inferred correctly.\n */\nexport interface Mock<T extends FunctionLike = UnknownFunction> extends Function, MockInstance<T> {\n    new (...args: Parameters<T>): ReturnType<T>;\n    (...args: Parameters<T>): ReturnType<T>;\n}\ntype ResolveType<T extends FunctionLike> = ReturnType<T> extends PromiseLike<infer U> ? U : never;\ntype RejectType<T extends FunctionLike> = ReturnType<T> extends PromiseLike<any> ? unknown : never;\nexport interface MockInstance<T extends FunctionLike = UnknownFunction> extends Disposable {\n    _isMockFunction: true;\n    _protoImpl: Function;\n    getMockImplementation(): T | undefined;\n    getMockName(): string;\n    mock: MockFunctionState<T>;\n    mockClear(): this;\n    mockReset(): this;\n    mockRestore(): void;\n    mockImplementation(fn: T): this;\n    mockImplementationOnce(fn: T): this;\n    withImplementation(fn: T, callback: () => Promise<unknown>): Promise<void>;\n    withImplementation(fn: T, callback: () => void): void;\n    mockName(name: string): this;\n    mockReturnThis(): this;\n    mockReturnValue(value: ReturnType<T>): this;\n    mockReturnValueOnce(value: ReturnType<T>): this;\n    mockResolvedValue(value: ResolveType<T>): this;\n    mockResolvedValueOnce(value: ResolveType<T>): this;\n    mockRejectedValue(value: RejectType<T>): this;\n    mockRejectedValueOnce(value: RejectType<T>): this;\n}\nexport interface Replaced<T = unknown> {\n    /**\n     * Restore property to its original value known at the time of mocking.\n     */\n    restore(): void;\n    /**\n     * Change the value of the property.\n     */\n    replaceValue(value: T): this;\n}\ntype MockFunctionResultIncomplete = {\n    type: 'incomplete';\n    /**\n     * Result of a single call to a mock function that has not yet completed.\n     * This occurs if you test the result from within the mock function itself,\n     * or from within a function that was called by the mock.\n     */\n    value: undefined;\n};\ntype MockFunctionResultReturn<T extends FunctionLike = UnknownFunction> = {\n    type: 'return';\n    /**\n     * Result of a single call to a mock function that returned.\n     */\n    value: ReturnType<T>;\n};\ntype MockFunctionResultThrow = {\n    type: 'throw';\n    /**\n     * Result of a single call to a mock function that threw.\n     */\n    value: unknown;\n};\ntype MockFunctionResult<T extends FunctionLike = UnknownFunction> = MockFunctionResultIncomplete | MockFunctionResultReturn<T> | MockFunctionResultThrow;\ntype MockFunctionState<T extends FunctionLike = UnknownFunction> = {\n    /**\n     * List of the call arguments of all calls that have been made to the mock.\n     */\n    calls: Array<Parameters<T>>;\n    /**\n     * List of all the object instances that have been instantiated from the mock.\n     */\n    instances: Array<ReturnType<T>>;\n    /**\n     * List of all the function contexts that have been applied to calls to the mock.\n     */\n    contexts: Array<ThisParameterType<T>>;\n    /**\n     * List of the call order indexes of the mock. Jest is indexing the order of\n     * invocations of all mocks in a test file. The index is starting with `1`.\n     */\n    invocationCallOrder: Array<number>;\n    /**\n     * List of the call arguments of the last call that was made to the mock.\n     * If the function was not called, it will return `undefined`.\n     */\n    lastCall?: Parameters<T>;\n    /**\n     * List of the results of all calls that have been made to the mock.\n     */\n    results: Array<MockFunctionResult<T>>;\n};\nexport declare class ModuleMocker {\n    private readonly _environmentGlobal;\n    private _mockState;\n    private _mockConfigRegistry;\n    private _spyState;\n    private _invocationCallCounter;\n    /**\n     * @see README.md\n     * @param global Global object of the test environment, used to create\n     * mocks\n     */\n    constructor(global: typeof globalThis);\n    private _getSlots;\n    private _ensureMockConfig;\n    private _ensureMockState;\n    private _defaultMockConfig;\n    private _defaultMockState;\n    private _makeComponent;\n    private _createMockFunction;\n    private _generateMock;\n    /**\n     * Check whether the given property of an object has been already replaced.\n     */\n    private _findReplacedProperty;\n    /**\n     * @see README.md\n     * @param metadata Metadata for the mock in the schema returned by the\n     * getMetadata method of this module.\n     */\n    generateFromMetadata<T>(metadata: MockMetadata<T>): Mocked<T>;\n    /**\n     * @see README.md\n     * @param component The component for which to retrieve metadata.\n     */\n    getMetadata<T = unknown>(component: T, _refs?: Map<T, number>): MockMetadata<T> | null;\n    isMockFunction<T extends FunctionLike = UnknownFunction>(fn: MockInstance<T>): fn is MockInstance<T>;\n    isMockFunction<P extends Array<unknown>, R>(fn: (...args: P) => R): fn is Mock<(...args: P) => R>;\n    isMockFunction(fn: unknown): fn is Mock<UnknownFunction>;\n    fn<T extends FunctionLike = UnknownFunction>(implementation?: T): Mock<T>;\n    spyOn<T extends object, K extends PropertyLikeKeys<T>, V extends Required<T>[K], A extends 'get' | 'set'>(object: T, methodKey: K, accessType: A): A extends 'get' ? SpiedGetter<V> : A extends 'set' ? SpiedSetter<V> : never;\n    spyOn<T extends object, K extends ConstructorLikeKeys<T> | MethodLikeKeys<T>, V extends Required<T>[K]>(object: T, methodKey: K): V extends ClassLike | FunctionLike ? Spied<V> : never;\n    private _spyOnProperty;\n    replaceProperty<T extends object, K extends keyof T>(object: T, propertyKey: K, value: T[K]): Replaced<T[K]>;\n    clearAllMocks(): void;\n    resetAllMocks(): void;\n    restoreAllMocks(): void;\n    private _typeOf;\n    mocked<T extends object>(source: T, options?: {\n        shallow: false;\n    }): Mocked<T>;\n    mocked<T extends object>(source: T, options: {\n        shallow: true;\n    }): MockedShallow<T>;\n}\nexport declare const fn: <T extends FunctionLike = UnknownFunction>(implementation?: T) => Mock<T>;\nexport declare const spyOn: {\n    <T extends object, K extends PropertyLikeKeys<T>, V extends Required<T>[K], A extends \"get\" | \"set\">(object: T, methodKey: K, accessType: A): A extends \"get\" ? SpiedGetter<V> : A extends \"set\" ? SpiedSetter<V> : never;\n    <T extends object, K extends ConstructorLikeKeys<T> | MethodLikeKeys<T>, V extends Required<T>[K]>(object: T, methodKey: K): V extends ClassLike | FunctionLike ? Spied<V> : never;\n};\nexport declare const mocked: {\n    <T extends object>(source: T, options?: {\n        shallow: false;\n    }): Mocked<T>;\n    <T extends object>(source: T, options: {\n        shallow: true;\n    }): MockedShallow<T>;\n};\nexport declare const replaceProperty: <T extends object, K extends keyof T>(object: T, propertyKey: K, value: T[K]) => Replaced<T[K]>;\nexport {};\n",
  "packages/jest-mock/src/__tests__/window-spy.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @jest-environment jsdom\n */\n\n/// <reference lib=\"dom\" />\n\nfunction exampleDispatch() {\n  globalThis.dispatchEvent(new CustomEvent('event', {}));\n}\n\ndescribe('spy on `dispatchEvent`', () => {\n  const dispatchEventSpy = jest.spyOn(globalThis, 'dispatchEvent');\n\n  it('should be called', () => {\n    exampleDispatch();\n\n    expect(dispatchEventSpy).toHaveBeenCalled();\n  });\n});\n",
  "packages/jest-mock/src/__tests__/window-spy.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @jest-environment jsdom\n */\ndeclare function exampleDispatch(): void;\n",
  "packages/jest-mock/src/__tests__/index.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/* eslint-disable local/prefer-rest-params-eventually */\n\nimport * as util from 'util';\nimport {type Context, createContext, runInContext, runInNewContext} from 'vm';\nimport {ModuleMocker, fn, mocked, spyOn} from '../';\n\ndescribe('moduleMocker', () => {\n  let moduleMocker: ModuleMocker;\n  let mockContext: Context;\n  let mockGlobals: typeof globalThis;\n\n  beforeEach(() => {\n    mockContext = createContext();\n    mockGlobals = runInNewContext('this', mockContext);\n    moduleMocker = new ModuleMocker(mockGlobals);\n  });\n\n  describe('getMetadata', () => {\n    it('returns the function `name` property', () => {\n      function x() {}\n      const metadata = moduleMocker.getMetadata(x);\n      expect(x.name).toBe('x');\n      expect(metadata!.name).toBe('x');\n    });\n\n    it('does not return broken name property', () => {\n      class By {\n        // @ts-expect-error\n        static name() {\n          return 'this is not a name';\n        }\n      }\n      const metadata = moduleMocker.getMetadata(By);\n      expect(typeof By.name).toBe('function');\n      expect(metadata).not.toHaveProperty('name');\n    });\n\n    it('mocks constant values', () => {\n      const metadata = moduleMocker.getMetadata(Symbol.for('bowties.are.cool'));\n      expect(metadata.value).toEqual(Symbol.for('bowties.are.cool'));\n      expect(moduleMocker.getMetadata('banana').value).toBe('banana');\n      expect(moduleMocker.getMetadata(27).value).toBe(27);\n      expect(moduleMocker.getMetadata(false).value).toBe(false);\n      expect(moduleMocker.getMetadata(Number.POSITIVE_INFINITY).value).toEqual(\n        Number.POSITIVE_INFINITY,\n      );\n    });\n\n    it('does not retrieve metadata for arrays', () => {\n      const array = [1, 2, 3];\n      const metadata = moduleMocker.getMetadata(array);\n      expect(metadata.value).toBeUndefined();\n      expect(metadata.members).toBeUndefined();\n      expect(metadata.type).toBe('array');\n    });\n\n    it('does not retrieve metadata for undefined', () => {\n      const metadata = moduleMocker.getMetadata(undefined);\n      expect(metadata.value).toBeUndefined();\n      expect(metadata.members).toBeUndefined();\n      expect(metadata.type).toBe('undefined');\n    });\n\n    it('does not retrieve metadata for null', () => {\n      const metadata = moduleMocker.getMetadata(null);\n      expect(metadata.value).toBeNull();\n      expect(metadata.members).toBeUndefined();\n      expect(metadata.type).toBe('null');\n    });\n\n    it('retrieves metadata for ES6 classes', () => {\n      class ClassFooMock {\n        bar() {}\n      }\n      const fooInstance = new ClassFooMock();\n      const metadata = moduleMocker.getMetadata(fooInstance);\n      expect(metadata.type).toBe('object');\n      expect(metadata.members.constructor.name).toBe('ClassFooMock');\n    });\n\n    it('retrieves synchronous function metadata', () => {\n      function functionFooMock() {}\n      const metadata = moduleMocker.getMetadata(functionFooMock);\n      expect(metadata.type).toBe('function');\n      expect(metadata.name).toBe('functionFooMock');\n    });\n\n    it('retrieves asynchronous function metadata', () => {\n      async function asyncFunctionFooMock() {}\n      const metadata = moduleMocker.getMetadata(asyncFunctionFooMock);\n      expect(metadata.type).toBe('function');\n      expect(metadata.name).toBe('asyncFunctionFooMock');\n    });\n\n    it(\"retrieves metadata for object literals and it's members\", () => {\n      const metadata = moduleMocker.getMetadata({\n        bar: 'two',\n        foo: 1,\n      });\n      expect(metadata.type).toBe('object');\n      expect(metadata.members.bar.value).toBe('two');\n      expect(metadata.members.bar.type).toBe('constant');\n      expect(metadata.members.foo.value).toBe(1);\n      expect(metadata.members.foo.type).toBe('constant');\n    });\n\n    it('retrieves Date object metadata', () => {\n      const metadata = moduleMocker.getMetadata(Date);\n      expect(metadata.type).toBe('function');\n      expect(metadata.name).toBe('Date');\n      expect(metadata.members.now.name).toBe('now');\n      expect(metadata.members.parse.name).toBe('parse');\n      expect(metadata.members.UTC.name).toBe('UTC');\n    });\n  });\n\n  describe('generateFromMetadata', () => {\n    it('forwards the function name property', () => {\n      function foo() {}\n      const mock = moduleMocker.generateFromMetadata(\n        moduleMocker.getMetadata(foo),\n      );\n      expect(mock.name).toBe('foo');\n    });\n\n    it('fixes illegal function name properties', () => {\n      function getMockFnWithOriginalName(name) {\n        const fn = () => {};\n        Object.defineProperty(fn, 'name', {value: name});\n\n        return moduleMocker.generateFromMetadata(moduleMocker.getMetadata(fn));\n      }\n\n      expect(getMockFnWithOriginalName('1').name).toBe('$1');\n      expect(getMockFnWithOriginalName('foo-bar').name).toBe('foo$bar');\n      expect(getMockFnWithOriginalName('foo-bar-2').name).toBe('foo$bar$2');\n      expect(getMockFnWithOriginalName('foo-bar-3').name).toBe('foo$bar$3');\n      expect(getMockFnWithOriginalName('foo/bar').name).toBe('foo$bar');\n      expect(getMockFnWithOriginalName('foo𠮷bar').name).toBe('foo𠮷bar');\n    });\n\n    it('special cases the mockConstructor name', () => {\n      function mockConstructor() {}\n      const mock = moduleMocker.generateFromMetadata(\n        moduleMocker.getMetadata(mockConstructor),\n      );\n      // Depends on node version\n      expect(!mock.name || mock.name === 'mockConstructor').toBeTruthy();\n    });\n\n    it('wont interfere with previous mocks on a shared prototype', () => {\n      const ClassFoo = function () {};\n      ClassFoo.prototype.x = () => {};\n      const ClassFooMock = moduleMocker.generateFromMetadata(\n        moduleMocker.getMetadata(ClassFoo),\n      );\n      const foo = new ClassFooMock();\n      const bar = new ClassFooMock();\n\n      foo.x.mockImplementation(() => 'Foo');\n      bar.x.mockImplementation(() => 'Bar');\n\n      expect(foo.x()).toBe('Foo');\n      expect(bar.x()).toBe('Bar');\n    });\n\n    it('does not mock non-enumerable getters', () => {\n      const foo = Object.defineProperties(\n        {},\n        {\n          nonEnumGetter: {\n            get: () => {\n              throw new Error();\n            },\n          },\n          nonEnumMethod: {\n            value: () => {},\n          },\n        },\n      );\n      const mock = moduleMocker.generateFromMetadata(\n        moduleMocker.getMetadata(foo),\n      );\n\n      expect(typeof foo.nonEnumMethod).toBe('function');\n\n      expect(mock.nonEnumMethod.mock).toBeDefined();\n      expect(mock.nonEnumGetter).toBeUndefined();\n    });\n\n    it('mocks getters of ES modules', () => {\n      const foo = Object.defineProperties(\n        {},\n        {\n          __esModule: {\n            value: true,\n          },\n          enumGetter: {\n            enumerable: true,\n            get: () => 10,\n          },\n        },\n      );\n      const mock = moduleMocker.generateFromMetadata(\n        moduleMocker.getMetadata(foo),\n      );\n      expect(mock.enumGetter).toBeDefined();\n    });\n\n    it('handles custom toString of transpiled modules', () => {\n      const foo = Object.defineProperties(\n        {foo: 'bar'},\n        {\n          __esModule: {value: true},\n          [Symbol.toStringTag]: {value: 'Module'},\n        },\n      );\n      const mock = moduleMocker.generateFromMetadata(\n        moduleMocker.getMetadata(foo),\n      );\n      expect(mock.foo).toBeDefined();\n    });\n\n    it('mocks ES2015 non-enumerable methods', () => {\n      class ClassFoo {\n        foo() {}\n        toString() {\n          return 'Foo';\n        }\n      }\n\n      const ClassFooMock = moduleMocker.generateFromMetadata(\n        moduleMocker.getMetadata(ClassFoo),\n      );\n      const foo = new ClassFooMock();\n\n      const instanceFoo = new ClassFoo();\n      const instanceFooMock = moduleMocker.generateFromMetadata(\n        moduleMocker.getMetadata(instanceFoo),\n      );\n\n      expect(typeof foo.foo).toBe('function');\n      expect(typeof instanceFooMock.foo).toBe('function');\n      expect(instanceFooMock.foo.mock).toBeDefined();\n\n      expect(instanceFooMock.toString.mock).toBeDefined();\n    });\n\n    it('mocks ES2015 non-enumerable static properties and methods', () => {\n      class ClassFoo {\n        static foo() {}\n        static fooProp: Function;\n      }\n      ClassFoo.fooProp = () => {};\n\n      class ClassBar extends ClassFoo {}\n\n      const ClassBarMock = moduleMocker.generateFromMetadata(\n        moduleMocker.getMetadata(ClassBar),\n      );\n\n      expect(typeof ClassBarMock.foo).toBe('function');\n      expect(typeof ClassBarMock.fooProp).toBe('function');\n      expect(ClassBarMock.foo.mock).toBeDefined();\n      expect(ClassBarMock.fooProp.mock).toBeDefined();\n    });\n\n    it('mocks methods in all the prototype chain (null prototype)', () => {\n      const Foo = Object.assign(Object.create(null), {foo() {}});\n      const Bar = Object.assign(Object.create(Foo), {bar() {}});\n\n      const BarMock = moduleMocker.generateFromMetadata(\n        moduleMocker.getMetadata(Bar),\n      );\n      expect(typeof BarMock.foo).toBe('function');\n      expect(typeof BarMock.bar).toBe('function');\n    });\n\n    it('does not mock methods from Object.prototype', () => {\n      const Foo = {foo() {}};\n      const Bar = Object.assign(Object.create(Foo), {bar() {}});\n\n      const BarMock = moduleMocker.generateFromMetadata(\n        moduleMocker.getMetadata(Bar),\n      );\n\n      expect(BarMock).toBeInstanceOf(mockGlobals.Object);\n      expect(\n        Object.prototype.hasOwnProperty.call(BarMock, 'hasOwnProperty'),\n      ).toBe(false);\n      expect(BarMock.hasOwnProperty).toBe(\n        mockGlobals.Object.prototype.hasOwnProperty,\n      );\n    });\n\n    it('does not mock methods from Object.prototype (in mock context)', () => {\n      const Bar = runInContext(\n        `\n          const Foo = { foo() {} };\n          const Bar = Object.assign(Object.create(Foo), { bar() {} });\n          Bar;\n        `,\n        mockContext,\n      );\n\n      const BarMock = moduleMocker.generateFromMetadata(\n        moduleMocker.getMetadata(Bar),\n      );\n\n      expect(BarMock).toBeInstanceOf(mockGlobals.Object);\n      expect(\n        Object.prototype.hasOwnProperty.call(BarMock, 'hasOwnProperty'),\n      ).toBe(false);\n      expect(BarMock.hasOwnProperty).toBe(\n        mockGlobals.Object.prototype.hasOwnProperty,\n      );\n    });\n\n    it('does not mock methods from Function.prototype', () => {\n      class Foo {}\n      class Bar extends Foo {}\n\n      const BarMock = moduleMocker.generateFromMetadata(\n        moduleMocker.getMetadata(Bar),\n      );\n\n      expect(BarMock).toBeInstanceOf(mockGlobals.Function);\n      expect(Object.prototype.hasOwnProperty.call(BarMock, 'bind')).toBe(false);\n      expect(BarMock.bind).toBe(mockGlobals.Function.prototype.bind);\n    });\n\n    it('does not mock methods from Function.prototype (in mock context)', () => {\n      const Bar = runInContext(\n        `\n          class Foo {}\n          class Bar extends Foo {}\n          Bar;\n        `,\n        mockContext,\n      );\n\n      const BarMock = moduleMocker.generateFromMetadata(\n        moduleMocker.getMetadata(Bar),\n      );\n\n      expect(BarMock).toBeInstanceOf(mockGlobals.Function);\n      expect(Object.prototype.hasOwnProperty.call(BarMock, 'bind')).toBe(false);\n      expect(BarMock.bind).toBe(mockGlobals.Function.prototype.bind);\n    });\n\n    it('does not mock methods from RegExp.prototype', () => {\n      const bar = /bar/;\n\n      const barMock = moduleMocker.generateFromMetadata(\n        moduleMocker.getMetadata(bar),\n      );\n\n      expect(barMock).toBeInstanceOf(mockGlobals.RegExp);\n      expect(Object.prototype.hasOwnProperty.call(barMock, 'test')).toBe(false);\n      expect(barMock.test).toBe(mockGlobals.RegExp.prototype.test);\n    });\n\n    it('does not mock methods from RegExp.prototype (in mock context)', () => {\n      const bar = runInContext(\n        `\n          const bar = /bar/;\n          bar;\n        `,\n        mockContext,\n      );\n\n      const barMock = moduleMocker.generateFromMetadata(\n        moduleMocker.getMetadata(bar),\n      );\n\n      expect(barMock).toBeInstanceOf(mockGlobals.RegExp);\n      expect(Object.prototype.hasOwnProperty.call(barMock, 'test')).toBe(false);\n      expect(barMock.test).toBe(mockGlobals.RegExp.prototype.test);\n    });\n\n    it('mocks methods that are bound multiple times', () => {\n      const func = function func() {};\n      const multipleBoundFunc = func.bind(null).bind(null);\n\n      const multipleBoundFuncMock = moduleMocker.generateFromMetadata(\n        moduleMocker.getMetadata(multipleBoundFunc),\n      );\n\n      expect(typeof multipleBoundFuncMock).toBe('function');\n    });\n\n    it('mocks methods that are bound after mocking', () => {\n      const fooMock = moduleMocker.generateFromMetadata(\n        moduleMocker.getMetadata(() => {}),\n      );\n\n      const barMock = moduleMocker.generateFromMetadata(\n        moduleMocker.getMetadata(fooMock.bind(null)),\n      );\n\n      expect(barMock).not.toThrow();\n    });\n\n    it('mocks regexp instances', () => {\n      expect(() =>\n        moduleMocker.generateFromMetadata(moduleMocker.getMetadata(/a/)),\n      ).not.toThrow();\n    });\n\n    it('mocks functions with numeric names', () => {\n      const obj = {\n        1: () => {},\n      };\n\n      const objMock = moduleMocker.generateFromMetadata(\n        moduleMocker.getMetadata(obj),\n      );\n\n      expect(typeof objMock[1]).toBe('function');\n    });\n\n    describe('mocked functions', () => {\n      it('tracks calls to mocks', () => {\n        const fn = moduleMocker.fn();\n        expect(fn.mock.calls).toEqual([]);\n\n        fn(1, 2, 3);\n        expect(fn.mock.calls).toEqual([[1, 2, 3]]);\n\n        fn('a', 'b', 'c');\n        expect(fn.mock.calls).toEqual([\n          [1, 2, 3],\n          ['a', 'b', 'c'],\n        ]);\n      });\n\n      it('tracks instances made by mocks', () => {\n        const fn = moduleMocker.fn();\n        expect(fn.mock.instances).toEqual([]);\n\n        const instance1 = new fn();\n        expect(fn.mock.instances[0]).toBe(instance1);\n\n        const instance2 = new fn();\n        expect(fn.mock.instances[1]).toBe(instance2);\n      });\n\n      it('tracks context objects passed to mock calls', () => {\n        const fn = moduleMocker.fn();\n        expect(fn.mock.instances).toEqual([]);\n\n        const ctx0 = {};\n        fn.apply(ctx0, []);\n        expect(fn.mock.contexts[0]).toBe(ctx0);\n\n        const ctx1 = {};\n        fn.call(ctx1);\n        expect(fn.mock.contexts[1]).toBe(ctx1);\n\n        const ctx2 = {};\n        const bound2 = fn.bind(ctx2);\n        bound2();\n        expect(fn.mock.contexts[2]).toBe(ctx2);\n\n        // null context\n        fn.apply(null, []); // eslint-disable-line no-useless-call\n        expect(fn.mock.contexts[3]).toBeNull();\n        fn.call(null); // eslint-disable-line no-useless-call\n        expect(fn.mock.contexts[4]).toBeNull();\n        fn.bind(null)();\n        expect(fn.mock.contexts[5]).toBeNull();\n\n        // Unspecified context is `undefined` in strict mode (like in this test) and `window` otherwise.\n        fn();\n        expect(fn.mock.contexts[6]).toBeUndefined();\n      });\n\n      it('supports clearing mock calls', () => {\n        const fn = moduleMocker.fn();\n        expect(fn.mock.calls).toEqual([]);\n\n        fn(1, 2, 3);\n        expect(fn.mock.calls).toEqual([[1, 2, 3]]);\n        expect(fn.mock.contexts).toEqual([undefined]);\n\n        fn.mockReturnValue('abcd');\n\n        fn.mockClear();\n        expect(fn.mock.calls).toEqual([]);\n        expect(fn.mock.contexts).toEqual([]);\n\n        fn('a', 'b', 'c');\n        expect(fn.mock.calls).toEqual([['a', 'b', 'c']]);\n        expect(fn.mock.contexts).toEqual([undefined]);\n\n        expect(fn()).toBe('abcd');\n      });\n\n      it('supports clearing mocks', () => {\n        const fn = moduleMocker.fn();\n        expect(fn.mock.calls).toEqual([]);\n\n        fn(1, 2, 3);\n        expect(fn.mock.calls).toEqual([[1, 2, 3]]);\n\n        fn.mockClear();\n        expect(fn.mock.calls).toEqual([]);\n\n        fn('a', 'b', 'c');\n        expect(fn.mock.calls).toEqual([['a', 'b', 'c']]);\n      });\n\n      it('supports clearing all mocks', () => {\n        const fn1 = moduleMocker.fn();\n        fn1.mockImplementation(() => 'abcd');\n        fn1(1, 2, 3);\n        expect(fn1.mock.calls).toEqual([[1, 2, 3]]);\n\n        const fn2 = moduleMocker.fn();\n        fn2.mockReturnValue('abcde');\n        fn2('a', 'b', 'c', 'd');\n        expect(fn2.mock.calls).toEqual([['a', 'b', 'c', 'd']]);\n\n        moduleMocker.clearAllMocks();\n        expect(fn1.mock.calls).toEqual([]);\n        expect(fn2.mock.calls).toEqual([]);\n        expect(fn1()).toBe('abcd');\n        expect(fn2()).toBe('abcde');\n      });\n\n      it('supports resetting mock return values', () => {\n        const fn = moduleMocker.fn();\n        fn.mockReturnValue('abcd');\n\n        const before = fn();\n        expect(before).toBe('abcd');\n\n        fn.mockReset();\n\n        const after = fn();\n        expect(after).not.toBe('abcd');\n      });\n\n      it('supports resetting single use mock return values', () => {\n        const fn = moduleMocker.fn();\n        fn.mockReturnValueOnce('abcd');\n\n        fn.mockReset();\n\n        const after = fn();\n        expect(after).not.toBe('abcd');\n      });\n\n      it('supports resetting mock implementations', () => {\n        const fn = moduleMocker.fn();\n        fn.mockImplementation(() => 'abcd');\n\n        const before = fn();\n        expect(before).toBe('abcd');\n\n        fn.mockReset();\n\n        const after = fn();\n        expect(after).not.toBe('abcd');\n      });\n\n      it('supports resetting single use mock implementations', () => {\n        const fn = moduleMocker.fn();\n        fn.mockImplementationOnce(() => 'abcd');\n\n        fn.mockReset();\n\n        const after = fn();\n        expect(after).not.toBe('abcd');\n      });\n\n      it('supports resetting all mocks', () => {\n        const fn1 = moduleMocker.fn();\n        fn1.mockImplementation(() => 'abcd');\n        fn1(1, 2, 3);\n        expect(fn1.mock.calls).toEqual([[1, 2, 3]]);\n\n        const fn2 = moduleMocker.fn();\n        fn2.mockReturnValue('abcd');\n        fn2('a', 'b', 'c');\n        expect(fn2.mock.calls).toEqual([['a', 'b', 'c']]);\n\n        moduleMocker.resetAllMocks();\n        expect(fn1.mock.calls).toEqual([]);\n        expect(fn2.mock.calls).toEqual([]);\n        expect(fn1()).not.toBe('abcd');\n        expect(fn2()).not.toBe('abcd');\n      });\n\n      it('is not affected by restoreAllMocks', () => {\n        const fn1 = moduleMocker.fn();\n        fn1.mockImplementation(() => 'abcd');\n        fn1(1, 2, 3);\n        expect(fn1.mock.calls).toEqual([[1, 2, 3]]);\n        moduleMocker.restoreAllMocks();\n        expect(fn1(1)).toBe('abcd');\n        expect(fn1.mock.calls).toEqual([[1, 2, 3], [1]]);\n      });\n\n      it('is cleared and stubbed when restored explicitly', () => {\n        const fn1 = moduleMocker.fn();\n        fn1.mockImplementation(() => 'abcd');\n        fn1(1, 2, 3);\n        expect(fn1.mock.calls).toEqual([[1, 2, 3]]);\n        fn1.mockRestore();\n        expect(fn1(1)).toBeUndefined();\n        expect(fn1.mock.calls).toEqual([[1]]);\n      });\n\n      it('maintains function arity', () => {\n        const mockFunctionArity1 = moduleMocker.fn(x => x);\n        const mockFunctionArity2 = moduleMocker.fn((x, y) => y);\n\n        expect(mockFunctionArity1).toHaveLength(1);\n        expect(mockFunctionArity2).toHaveLength(2);\n      });\n    });\n\n    it('mocks the method in the passed object itself', () => {\n      const parent = {func: () => 'abcd'};\n      const child = Object.create(parent);\n\n      moduleMocker.spyOn(child, 'func').mockReturnValue('efgh');\n\n      expect(Object.prototype.hasOwnProperty.call(child, 'func')).toBe(true);\n      expect(child.func()).toBe('efgh');\n      expect(parent.func()).toBe('abcd');\n    });\n\n    it('should delete previously inexistent methods when restoring', () => {\n      const parent = {func: () => 'abcd'};\n      const child = Object.create(parent);\n\n      moduleMocker.spyOn(child, 'func').mockReturnValue('efgh');\n\n      moduleMocker.restoreAllMocks();\n      expect(child.func()).toBe('abcd');\n\n      moduleMocker.spyOn(parent, 'func').mockReturnValue('jklm');\n\n      expect(Object.prototype.hasOwnProperty.call(child, 'func')).toBe(false);\n      expect(child.func()).toBe('jklm');\n    });\n\n    it('supports mock value returning undefined', () => {\n      const obj = {\n        func: () => 'some text',\n      };\n\n      moduleMocker.spyOn(obj, 'func').mockReturnValue(undefined);\n\n      expect(obj.func()).not.toBe('some text');\n    });\n\n    it('supports mock value once returning undefined', () => {\n      const obj = {\n        func: () => 'some text',\n      };\n\n      moduleMocker.spyOn(obj, 'func').mockReturnValueOnce(undefined);\n\n      expect(obj.func()).not.toBe('some text');\n    });\n\n    it('mockReturnValueOnce mocks value just once', () => {\n      const fake = jest.fn(a => a + 2);\n      fake.mockReturnValueOnce(42);\n      expect(fake(2)).toBe(42);\n      expect(fake(2)).toBe(4);\n    });\n\n    it('supports mocking resolvable async functions', () => {\n      const fn = moduleMocker.fn();\n      fn.mockResolvedValue('abcd');\n\n      const promise = fn();\n\n      expect(promise).toBeInstanceOf(mockGlobals.Promise);\n\n      return expect(promise).resolves.toBe('abcd');\n    });\n\n    it('supports mocking resolvable async functions only once', () => {\n      const fn = moduleMocker.fn();\n      fn.mockResolvedValue('abcd');\n      fn.mockResolvedValueOnce('abcde');\n\n      return Promise.all([\n        expect(fn()).resolves.toBe('abcde'),\n        expect(fn()).resolves.toBe('abcd'),\n      ]);\n    });\n\n    it('supports mocking rejectable async functions', () => {\n      const err = new Error('rejected');\n      const fn = moduleMocker.fn();\n      fn.mockRejectedValue(err);\n\n      const promise = fn();\n\n      expect(promise).toBeInstanceOf(mockGlobals.Promise);\n\n      return expect(promise).rejects.toBe(err);\n    });\n\n    it('supports mocking rejectable async functions only once', () => {\n      const defaultErr = new Error('default rejected');\n      const err = new Error('rejected');\n      const fn = moduleMocker.fn();\n      fn.mockRejectedValue(defaultErr);\n      fn.mockRejectedValueOnce(err);\n\n      return Promise.all([\n        expect(fn()).rejects.toBe(err),\n        expect(fn()).rejects.toBe(defaultErr),\n      ]);\n    });\n\n    describe('return values', () => {\n      it('tracks return values', () => {\n        const fn = moduleMocker.fn(x => x * 2);\n\n        expect(fn.mock.results).toEqual([]);\n\n        fn(1);\n        fn(2);\n\n        expect(fn.mock.results).toEqual([\n          {\n            type: 'return',\n            value: 2,\n          },\n          {\n            type: 'return',\n            value: 4,\n          },\n        ]);\n      });\n\n      it('tracks mocked return values', () => {\n        const fn = moduleMocker.fn(x => x * 2);\n        fn.mockReturnValueOnce('MOCKED!');\n\n        fn(1);\n        fn(2);\n\n        expect(fn.mock.results).toEqual([\n          {\n            type: 'return',\n            value: 'MOCKED!',\n          },\n          {\n            type: 'return',\n            value: 4,\n          },\n        ]);\n      });\n\n      it('supports resetting return values', () => {\n        const fn = moduleMocker.fn(x => x * 2);\n\n        expect(fn.mock.results).toEqual([]);\n\n        fn(1);\n        fn(2);\n\n        expect(fn.mock.results).toEqual([\n          {\n            type: 'return',\n            value: 2,\n          },\n          {\n            type: 'return',\n            value: 4,\n          },\n        ]);\n\n        fn.mockReset();\n\n        expect(fn.mock.results).toEqual([]);\n      });\n    });\n\n    it('tracks thrown errors without interfering with other tracking', () => {\n      const error = new Error('ODD!');\n      const fn = moduleMocker.fn((x, y) => {\n        // multiply params\n        const result = x * y;\n\n        if (result % 2 === 1) {\n          // throw error if result is odd\n          throw error;\n        } else {\n          return result;\n        }\n      });\n\n      expect(fn(2, 4)).toBe(8);\n\n      // Mock still throws the error even though it was internally\n      // caught and recorded\n      expect(() => {\n        fn(3, 5);\n      }).toThrow('ODD!');\n\n      expect(fn(6, 3)).toBe(18);\n\n      // All call args tracked\n      expect(fn.mock.calls).toEqual([\n        [2, 4],\n        [3, 5],\n        [6, 3],\n      ]);\n      // Results are tracked\n      expect(fn.mock.results).toEqual([\n        {\n          type: 'return',\n          value: 8,\n        },\n        {\n          type: 'throw',\n          value: error,\n        },\n        {\n          type: 'return',\n          value: 18,\n        },\n      ]);\n    });\n\n    it('a call that throws undefined is tracked properly', () => {\n      const fn = moduleMocker.fn(() => {\n        // eslint-disable-next-line no-throw-literal\n        throw undefined;\n      });\n\n      try {\n        fn(2, 4);\n      } catch {\n        // ignore error\n      }\n\n      // All call args tracked\n      expect(fn.mock.calls).toEqual([[2, 4]]);\n      // Results are tracked\n      expect(fn.mock.results).toEqual([\n        {\n          type: 'throw',\n          value: undefined,\n        },\n      ]);\n    });\n\n    it('results of recursive calls are tracked properly', () => {\n      // sums up all integers from 0 -> value, using recursion\n      const fn = moduleMocker.fn(value => {\n        if (value === 0) {\n          return 0;\n        } else {\n          return value + fn(value - 1);\n        }\n      });\n\n      fn(4);\n\n      // All call args tracked\n      expect(fn.mock.calls).toEqual([[4], [3], [2], [1], [0]]);\n      // Results are tracked\n      // (in correct order of calls, rather than order of returns)\n      expect(fn.mock.results).toEqual([\n        {\n          type: 'return',\n          value: 10,\n        },\n        {\n          type: 'return',\n          value: 6,\n        },\n        {\n          type: 'return',\n          value: 3,\n        },\n        {\n          type: 'return',\n          value: 1,\n        },\n        {\n          type: 'return',\n          value: 0,\n        },\n      ]);\n    });\n\n    it('test results of recursive calls from within the recursive call', () => {\n      // sums up all integers from 0 -> value, using recursion\n      const fn = moduleMocker.fn(value => {\n        if (value === 0) {\n          return 0;\n        } else {\n          const recursiveResult = fn(value - 1);\n\n          if (value === 3) {\n            // All recursive calls have been made at this point.\n            expect(fn.mock.calls).toEqual([[4], [3], [2], [1], [0]]);\n            // But only the last 3 calls have returned at this point.\n            expect(fn.mock.results).toEqual([\n              {\n                type: 'incomplete',\n                value: undefined,\n              },\n              {\n                type: 'incomplete',\n                value: undefined,\n              },\n              {\n                type: 'return',\n                value: 3,\n              },\n              {\n                type: 'return',\n                value: 1,\n              },\n              {\n                type: 'return',\n                value: 0,\n              },\n            ]);\n          }\n\n          return value + recursiveResult;\n        }\n      });\n\n      fn(4);\n    });\n\n    it('call mockClear inside recursive mock', () => {\n      // sums up all integers from 0 -> value, using recursion\n      const fn = moduleMocker.fn(value => {\n        if (value === 3) {\n          fn.mockClear();\n        }\n\n        if (value === 0) {\n          return 0;\n        } else {\n          return value + fn(value - 1);\n        }\n      });\n\n      fn(3);\n\n      // All call args (after the call that cleared the mock) are tracked\n      expect(fn.mock.calls).toEqual([[2], [1], [0]]);\n      // Results (after the call that cleared the mock) are tracked\n      expect(fn.mock.results).toEqual([\n        {\n          type: 'return',\n          value: 3,\n        },\n        {\n          type: 'return',\n          value: 1,\n        },\n        {\n          type: 'return',\n          value: 0,\n        },\n      ]);\n    });\n\n    describe('invocationCallOrder', () => {\n      it('tracks invocationCallOrder made by mocks', () => {\n        const fn1 = moduleMocker.fn();\n        expect(fn1.mock.invocationCallOrder).toEqual([]);\n\n        fn1(1, 2, 3);\n        expect(fn1.mock.invocationCallOrder[0]).toBe(1);\n\n        fn1('a', 'b', 'c');\n        expect(fn1.mock.invocationCallOrder[1]).toBe(2);\n\n        fn1(1, 2, 3);\n        expect(fn1.mock.invocationCallOrder[2]).toBe(3);\n\n        const fn2 = moduleMocker.fn();\n        expect(fn2.mock.invocationCallOrder).toEqual([]);\n\n        fn2('d', 'e', 'f');\n        expect(fn2.mock.invocationCallOrder[0]).toBe(4);\n\n        fn2(4, 5, 6);\n        expect(fn2.mock.invocationCallOrder[1]).toBe(5);\n      });\n\n      it('supports clearing mock invocationCallOrder', () => {\n        const fn = moduleMocker.fn();\n        expect(fn.mock.invocationCallOrder).toEqual([]);\n\n        fn(1, 2, 3);\n        expect(fn.mock.invocationCallOrder).toEqual([1]);\n\n        fn.mockReturnValue('abcd');\n\n        fn.mockClear();\n        expect(fn.mock.invocationCallOrder).toEqual([]);\n\n        fn('a', 'b', 'c');\n        expect(fn.mock.invocationCallOrder).toEqual([2]);\n\n        expect(fn()).toBe('abcd');\n      });\n\n      it('supports clearing all mocks invocationCallOrder', () => {\n        const fn1 = moduleMocker.fn();\n        fn1.mockImplementation(() => 'abcd');\n\n        fn1(1, 2, 3);\n        expect(fn1.mock.invocationCallOrder).toEqual([1]);\n\n        const fn2 = moduleMocker.fn();\n\n        fn2.mockReturnValue('abcde');\n        fn2('a', 'b', 'c', 'd');\n        expect(fn2.mock.invocationCallOrder).toEqual([2]);\n\n        moduleMocker.clearAllMocks();\n        expect(fn1.mock.invocationCallOrder).toEqual([]);\n        expect(fn2.mock.invocationCallOrder).toEqual([]);\n        expect(fn1()).toBe('abcd');\n        expect(fn2()).toBe('abcde');\n      });\n\n      it('handles a property called `prototype`', () => {\n        const mock = moduleMocker.generateFromMetadata(\n          moduleMocker.getMetadata({prototype: 1}),\n        );\n\n        expect(mock.prototype).toBe(1);\n      });\n    });\n  });\n\n  describe('getMockImplementation', () => {\n    it('should mock calls to a mock function', () => {\n      const mockFn = moduleMocker.fn();\n\n      mockFn.mockImplementation(() => 'Foo');\n\n      expect(typeof mockFn.getMockImplementation()).toBe('function');\n      expect(mockFn.getMockImplementation()()).toBe('Foo');\n    });\n  });\n\n  describe('mockImplementationOnce', () => {\n    it('should mock constructor', () => {\n      const mock1 = jest.fn();\n      const mock2 = jest.fn();\n      const Module = jest.fn(() => ({someFn: mock1}));\n      const testFn = function () {\n        const m = new Module();\n        m.someFn();\n      };\n\n      Module.mockImplementationOnce(() => ({someFn: mock2}));\n\n      testFn();\n      expect(mock2).toHaveBeenCalled();\n      expect(mock1).not.toHaveBeenCalled();\n      testFn();\n      expect(mock1).toHaveBeenCalled();\n    });\n\n    it('should mock single call to a mock function', () => {\n      const mockFn = moduleMocker.fn();\n\n      mockFn\n        .mockImplementationOnce(() => 'Foo')\n        .mockImplementationOnce(() => 'Bar');\n\n      expect(mockFn()).toBe('Foo');\n      expect(mockFn()).toBe('Bar');\n      expect(mockFn()).toBeUndefined();\n    });\n\n    it('should fallback to default mock function when no specific mock is available', () => {\n      const mockFn = moduleMocker.fn();\n\n      mockFn\n        .mockImplementationOnce(() => 'Foo')\n        .mockImplementationOnce(() => 'Bar')\n        .mockImplementation(() => 'Default');\n\n      expect(mockFn()).toBe('Foo');\n      expect(mockFn()).toBe('Bar');\n      expect(mockFn()).toBe('Default');\n      expect(mockFn()).toBe('Default');\n    });\n  });\n\n  describe('withImplementation', () => {\n    it('sets an implementation which is available within the callback', () => {\n      const mock1 = jest.fn();\n      const mock2 = jest.fn();\n\n      const Module = jest.fn(() => ({someFn: mock1}));\n      const testFn = function () {\n        const m = new Module();\n        m.someFn();\n      };\n\n      Module.withImplementation(\n        () => ({someFn: mock2}),\n        () => {\n          testFn();\n          expect(mock2).toHaveBeenCalled();\n          expect(mock1).not.toHaveBeenCalled();\n        },\n      );\n\n      testFn();\n      expect(mock1).toHaveBeenCalled();\n\n      expect.assertions(3);\n    });\n\n    it('returns a promise if the provided callback is asynchronous', async () => {\n      const mock1 = jest.fn();\n      const mock2 = jest.fn();\n\n      const Module = jest.fn(() => ({someFn: mock1}));\n      const testFn = function () {\n        const m = new Module();\n        m.someFn();\n      };\n\n      const promise = Module.withImplementation(\n        () => ({someFn: mock2}),\n        async () => {\n          testFn();\n          expect(mock2).toHaveBeenCalled();\n          expect(mock1).not.toHaveBeenCalled();\n        },\n      );\n\n      expect(util.types.isPromise(promise)).toBe(true);\n\n      await promise;\n\n      testFn();\n      expect(mock1).toHaveBeenCalled();\n\n      expect.assertions(4);\n    });\n\n    it('mockImplementationOnce does not bleed into withImplementation', () => {\n      const mock = jest\n        .fn(() => 'outside callback')\n        .mockImplementationOnce(() => 'once');\n\n      mock.withImplementation(\n        () => 'inside callback',\n        () => {\n          expect(mock()).toBe('inside callback');\n        },\n      );\n\n      expect(mock()).toBe('once');\n      expect(mock()).toBe('outside callback');\n    });\n\n    it('mockReturnValueOnce does not bleed into withImplementation', () => {\n      const mock = jest\n        .fn(() => 'outside callback')\n        .mockReturnValueOnce('once');\n\n      mock.withImplementation(\n        () => 'inside callback',\n        () => {\n          expect(mock()).toBe('inside callback');\n        },\n      );\n\n      expect(mock()).toBe('once');\n      expect(mock()).toBe('outside callback');\n    });\n  });\n\n  test('mockReturnValue does not override mockImplementationOnce', () => {\n    const mockFn = jest\n      .fn()\n      .mockReturnValue(1)\n      .mockImplementationOnce(() => 2);\n    expect(mockFn()).toBe(2);\n    expect(mockFn()).toBe(1);\n  });\n\n  test('mockImplementation resets the mock', () => {\n    const fn = jest.fn();\n    expect(fn()).toBeUndefined();\n    fn.mockReturnValue('returnValue');\n    fn.mockImplementation(() => 'foo');\n    expect(fn()).toBe('foo');\n  });\n\n  it('should recognize a mocked function', () => {\n    const mockFn = moduleMocker.fn();\n\n    expect(moduleMocker.isMockFunction(() => {})).toBe(false);\n    expect(moduleMocker.isMockFunction(mockFn)).toBe(true);\n  });\n\n  test('default mockName is jest.fn()', () => {\n    const fn = jest.fn();\n    expect(fn.getMockName()).toBe('jest.fn()');\n  });\n\n  test('mockName sets the mock name', () => {\n    const fn = jest.fn();\n    fn.mockName('myMockFn');\n    expect(fn.getMockName()).toBe('myMockFn');\n  });\n\n  test('jest.fn should provide the correct lastCall', () => {\n    const mock = jest.fn();\n\n    expect(mock.mock).not.toHaveProperty('lastCall');\n\n    mock('first');\n    mock('second');\n    mock('last', 'call');\n\n    expect(mock).toHaveBeenLastCalledWith('last', 'call');\n    expect(mock.mock.lastCall).toEqual(['last', 'call']);\n  });\n\n  test('lastCall gets reset by mockReset', () => {\n    const mock = jest.fn();\n\n    mock('first');\n    mock('last', 'call');\n\n    expect(mock.mock.lastCall).toEqual(['last', 'call']);\n\n    mock.mockReset();\n\n    expect(mock.mock).not.toHaveProperty('lastCall');\n  });\n\n  test('mockName gets reset by mockReset', () => {\n    const fn = jest.fn();\n    expect(fn.getMockName()).toBe('jest.fn()');\n    fn.mockName('myMockFn');\n    expect(fn.getMockName()).toBe('myMockFn');\n    fn.mockReset();\n    expect(fn.getMockName()).toBe('jest.fn()');\n  });\n\n  test('mockName gets reset by mockRestore', () => {\n    const fn = jest.fn();\n    expect(fn.getMockName()).toBe('jest.fn()');\n    fn.mockName('myMockFn');\n    expect(fn.getMockName()).toBe('myMockFn');\n    fn.mockRestore();\n    expect(fn.getMockName()).toBe('jest.fn()');\n  });\n\n  test('mockName is not reset by mockClear', () => {\n    const fn = jest.fn(() => false);\n    fn.mockName('myMockFn');\n    expect(fn.getMockName()).toBe('myMockFn');\n    fn.mockClear();\n    expect(fn.getMockName()).toBe('myMockFn');\n  });\n\n  describe('spyOn', () => {\n    it('should work', () => {\n      let isOriginalCalled = false;\n      let originalCallThis;\n      let originalCallArguments;\n      const obj = {\n        method() {\n          isOriginalCalled = true;\n          // eslint-disable-next-line @typescript-eslint/no-this-alias\n          originalCallThis = this;\n          originalCallArguments = arguments;\n        },\n      };\n\n      const spy = moduleMocker.spyOn(obj, 'method');\n\n      const thisArg = {this: true};\n      const firstArg = {first: true};\n      const secondArg = {second: true};\n      obj.method.call(thisArg, firstArg, secondArg);\n      expect(isOriginalCalled).toBe(true);\n      expect(originalCallThis).toBe(thisArg);\n      expect(originalCallArguments).toHaveLength(2);\n      expect(originalCallArguments[0]).toBe(firstArg);\n      expect(originalCallArguments[1]).toBe(secondArg);\n      expect(spy).toHaveBeenCalled();\n\n      isOriginalCalled = false;\n      originalCallThis = null;\n      originalCallArguments = null;\n      spy.mockRestore();\n      obj.method.call(thisArg, firstArg, secondArg);\n      expect(isOriginalCalled).toBe(true);\n      expect(originalCallThis).toBe(thisArg);\n      expect(originalCallArguments).toHaveLength(2);\n      expect(originalCallArguments[0]).toBe(firstArg);\n      expect(originalCallArguments[1]).toBe(secondArg);\n      expect(spy).not.toHaveBeenCalled();\n    });\n\n    describe('should throw', () => {\n      it.each`\n        value         | type\n        ${'foo'}      | ${'string'}\n        ${1}          | ${'number'}\n        ${Number.NaN} | ${'number'}\n        ${1n}         | ${'bigint'}\n        ${Symbol()}   | ${'symbol'}\n        ${true}       | ${'boolean'}\n        ${false}      | ${'boolean'}\n        ${undefined}  | ${'undefined'}\n        ${null}       | ${'null'}\n      `(\n        'when primitive value $value is provided instead of an object',\n        ({value, type}) => {\n          expect(() => {\n            moduleMocker.spyOn(value, 'method');\n          }).toThrow(`Cannot use spyOn on a primitive value; ${type} given`);\n        },\n      );\n\n      it('when property name is not provided', () => {\n        expect(() => {\n          moduleMocker.spyOn({}, null);\n        }).toThrow('No property name supplied');\n      });\n\n      it('when property does not exist', () => {\n        expect(() => {\n          moduleMocker.spyOn({}, 'doesNotExist');\n        }).toThrow(\n          'Property `doesNotExist` does not exist in the provided object',\n        );\n      });\n\n      it('when getter does not exist', () => {\n        expect(() => {\n          moduleMocker.spyOn({}, 'missingGet', 'get');\n        }).toThrow(\n          'Property `missingGet` does not exist in the provided object',\n        );\n      });\n\n      it('when setter does not exist', () => {\n        expect(() => {\n          moduleMocker.spyOn({}, 'missingSet', 'set');\n        }).toThrow(\n          'Property `missingSet` does not exist in the provided object',\n        );\n      });\n\n      it('when getter is not configurable', () => {\n        expect(() => {\n          const obj = {};\n\n          Object.defineProperty(obj, 'property', {\n            configurable: false,\n            get() {\n              return 1;\n            },\n          });\n\n          moduleMocker.spyOn(obj, 'property', 'get');\n        }).toThrow('Property `property` is not declared configurable');\n      });\n\n      it('when setter is not configurable', () => {\n        expect(() => {\n          const obj = {};\n          let value = 38;\n\n          Object.defineProperty(obj, 'property', {\n            configurable: false,\n            get() {\n              return value;\n            },\n            set(newValue) {\n              value = newValue;\n            },\n          });\n\n          moduleMocker.spyOn(obj, 'property', 'set');\n        }).toThrow('Property `property` is not declared configurable');\n      });\n\n      it('when property does not have access type get', () => {\n        expect(() => {\n          const obj = {};\n          let value = 38;\n\n          // eslint-disable-next-line accessor-pairs\n          Object.defineProperty(obj, 'property', {\n            configurable: true,\n            set(newValue) {\n              value = newValue;\n            },\n          });\n\n          moduleMocker.spyOn(obj, 'property', 'get');\n        }).toThrow('Property `property` does not have access type get');\n      });\n\n      it('when property does not have access type set', () => {\n        expect(() => {\n          const obj = {};\n\n          Object.defineProperty(obj, 'property', {\n            configurable: true,\n            get() {\n              return 1;\n            },\n          });\n\n          moduleMocker.spyOn(obj, 'property', 'set');\n        }).toThrow('Property `property` does not have access type set');\n      });\n\n      it('when trying to spy on a non function property', () => {\n        expect(() => {\n          moduleMocker.spyOn({property: 123}, 'property');\n        }).toThrow(\n          \"Cannot spy on the `property` property because it is not a function; number given instead. If you are trying to mock a property, use `jest.replaceProperty(object, 'property', value)` instead.\",\n        );\n      });\n    });\n\n    it('supports spying on a method named `0`', () => {\n      let haveBeenCalled = false;\n      const obj = {\n        0: () => {\n          haveBeenCalled = true;\n        },\n      };\n\n      const spy = moduleMocker.spyOn(obj, 0);\n      obj[0].call(null);\n\n      expect(haveBeenCalled).toBe(true);\n      expect(spy).toHaveBeenCalled();\n    });\n\n    it('supports spying on a symbol-keyed method', () => {\n      const k = Symbol();\n\n      let haveBeenCalled = false;\n      const obj = {\n        [k]: () => {\n          haveBeenCalled = true;\n        },\n      };\n\n      const spy = moduleMocker.spyOn(obj, k);\n      obj[k].call(null);\n\n      expect(haveBeenCalled).toBe(true);\n      expect(spy).toHaveBeenCalled();\n    });\n\n    it('supports spying on a method which is defined on a function', () => {\n      let haveBeenCalled = false;\n      const obj = () => true;\n\n      Object.defineProperty(obj, 'method', {\n        configurable: true,\n        value: () => {\n          haveBeenCalled = true;\n        },\n        writable: true,\n      });\n\n      const spy = moduleMocker.spyOn(obj, 'method');\n      obj.method.call(null);\n\n      expect(haveBeenCalled).toBe(true);\n      expect(spy).toHaveBeenCalled();\n    });\n\n    it('supports clearing a spy', () => {\n      let methodOneCalls = 0;\n      const obj = {\n        methodOne() {\n          methodOneCalls++;\n        },\n      };\n\n      const spy1 = moduleMocker.spyOn(obj, 'methodOne');\n\n      obj.methodOne();\n\n      // The spy and the original function are called.\n      expect(methodOneCalls).toBe(1);\n      expect(spy1.mock.calls).toHaveLength(1);\n\n      expect(moduleMocker.isMockFunction(obj.methodOne)).toBe(true);\n\n      spy1.mockClear();\n\n      // After clearing the spy, the method is still mock function.\n      expect(moduleMocker.isMockFunction(obj.methodOne)).toBe(true);\n\n      // After clearing the spy, call count is reset.\n      expect(spy1.mock.calls).toHaveLength(0);\n    });\n\n    it('supports clearing all spies', () => {\n      let methodOneCalls = 0;\n      let methodTwoCalls = 0;\n      const obj = {\n        methodOne() {\n          methodOneCalls++;\n        },\n        methodTwo() {\n          methodTwoCalls++;\n        },\n      };\n\n      const spy1 = moduleMocker.spyOn(obj, 'methodOne');\n      const spy2 = moduleMocker.spyOn(obj, 'methodTwo');\n\n      obj.methodOne();\n      obj.methodTwo();\n\n      // Both spies and both original functions are called.\n      expect(methodOneCalls).toBe(1);\n      expect(methodTwoCalls).toBe(1);\n      expect(spy1.mock.calls).toHaveLength(1);\n      expect(spy2.mock.calls).toHaveLength(1);\n\n      expect(moduleMocker.isMockFunction(obj.methodOne)).toBe(true);\n      expect(moduleMocker.isMockFunction(obj.methodTwo)).toBe(true);\n\n      moduleMocker.clearAllMocks();\n\n      // After clearing all mocks, the methods are still mock functions.\n      expect(moduleMocker.isMockFunction(obj.methodOne)).toBe(true);\n      expect(moduleMocker.isMockFunction(obj.methodTwo)).toBe(true);\n\n      // After clearing all mocks, call counts are reset.\n      expect(spy1.mock.calls).toHaveLength(0);\n      expect(spy2.mock.calls).toHaveLength(0);\n    });\n\n    it('supports resetting a spy', () => {\n      const methodOneReturn = 10;\n      let methodOneRealCalls = 0;\n      const obj = {\n        methodOne() {\n          methodOneRealCalls++;\n          return methodOneReturn;\n        },\n      };\n\n      const spy1 = moduleMocker.spyOn(obj, 'methodOne').mockReturnValue(100);\n\n      // Return value is mocked.\n      expect(obj.methodOne()).toBe(100);\n      // Real impl has not been used.\n      expect(methodOneRealCalls).toBe(0);\n\n      expect(moduleMocker.isMockFunction(obj.methodOne)).toBe(true);\n\n      spy1.mockReset();\n\n      // After resetting the spy, the method is still mock functions.\n      expect(moduleMocker.isMockFunction(obj.methodOne)).toBe(true);\n\n      // After resetting the spy, the method returns undefined.\n      expect(obj.methodOne()).toBeUndefined();\n\n      // Real implementation has still not been called.\n      expect(methodOneRealCalls).toBe(0);\n    });\n\n    it('supports resetting all spies', () => {\n      const methodOneReturn = 10;\n      const methodTwoReturn = {};\n      let methodOneRealCalls = 0;\n      let methodTwoRealCalls = 0;\n      const obj = {\n        methodOne() {\n          methodOneRealCalls++;\n          return methodOneReturn;\n        },\n        methodTwo() {\n          methodTwoRealCalls++;\n          return methodTwoReturn;\n        },\n      };\n\n      // methodOne is spied on and mocked.\n      moduleMocker.spyOn(obj, 'methodOne').mockReturnValue(100);\n      // methodTwo is spied on but not mocked.\n      moduleMocker.spyOn(obj, 'methodTwo');\n\n      // Return values are mocked.\n      expect(obj.methodOne()).toBe(100);\n      expect(obj.methodTwo()).toBe(methodTwoReturn);\n\n      // The real implementation has not been called when mocked.\n      expect(methodOneRealCalls).toBe(0);\n\n      // But has for the unmocked spy.\n      expect(methodTwoRealCalls).toBe(1);\n\n      // Both are mock functions.\n      expect(moduleMocker.isMockFunction(obj.methodOne)).toBe(true);\n      expect(moduleMocker.isMockFunction(obj.methodTwo)).toBe(true);\n\n      moduleMocker.resetAllMocks();\n\n      // After resetting all mocks, the methods are still mock functions.\n      expect(moduleMocker.isMockFunction(obj.methodOne)).toBe(true);\n      expect(moduleMocker.isMockFunction(obj.methodTwo)).toBe(true);\n\n      // After resetting all mocks, the methods are stubs returning undefined.\n      expect(obj.methodOne()).toBeUndefined();\n\n      // NB: It may not be desirable for reset to stub a spy that was never mocked -\n      // consider changing in a future major.\n      expect(obj.methodTwo()).toBeUndefined();\n\n      // Real functions have not been called any more times.\n      expect(methodOneRealCalls).toBe(0);\n      expect(methodTwoRealCalls).toBe(1);\n    });\n\n    it('supports restoring a spy', () => {\n      let methodOneCalls = 0;\n      const obj = {\n        methodOne() {\n          methodOneCalls++;\n        },\n      };\n\n      const spy1 = moduleMocker.spyOn(obj, 'methodOne');\n\n      obj.methodOne();\n\n      // The spy and the original function got called.\n      expect(methodOneCalls).toBe(1);\n      expect(spy1.mock.calls).toHaveLength(1);\n\n      expect(moduleMocker.isMockFunction(obj.methodOne)).toBe(true);\n\n      spy1.mockRestore();\n\n      // After restoring the spy, the method is not mock function.\n      expect(moduleMocker.isMockFunction(obj.methodOne)).toBe(false);\n\n      obj.methodOne();\n\n      // After restoring the spy only the real method bumps its call count, not the spy.\n      expect(methodOneCalls).toBe(2);\n      expect(spy1.mock.calls).toHaveLength(0);\n    });\n\n    it('supports restoring all spies', () => {\n      let methodOneCalls = 0;\n      let methodTwoCalls = 0;\n      const obj = {\n        methodOne() {\n          methodOneCalls++;\n        },\n        methodTwo() {\n          methodTwoCalls++;\n        },\n      };\n\n      const spy1 = moduleMocker.spyOn(obj, 'methodOne');\n      const spy2 = moduleMocker.spyOn(obj, 'methodTwo');\n\n      // First, we call with the spies: both spies and both original functions\n      // should be called.\n      obj.methodOne();\n      obj.methodTwo();\n      expect(methodOneCalls).toBe(1);\n      expect(methodTwoCalls).toBe(1);\n      expect(spy1.mock.calls).toHaveLength(1);\n      expect(spy2.mock.calls).toHaveLength(1);\n\n      moduleMocker.restoreAllMocks();\n\n      // Then, after resetting all mocks, we call methods again. Only the real\n      // methods should bump their count, not the spies.\n      obj.methodOne();\n      obj.methodTwo();\n      expect(methodOneCalls).toBe(2);\n      expect(methodTwoCalls).toBe(2);\n      expect(spy1.mock.calls).toHaveLength(1);\n      expect(spy2.mock.calls).toHaveLength(1);\n    });\n\n    it('should work with getters', () => {\n      let isOriginalCalled = false;\n      let originalCallThis;\n      let originalCallArguments;\n      const obj = {\n        get method() {\n          return function () {\n            isOriginalCalled = true;\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            originalCallThis = this;\n            originalCallArguments = arguments;\n          };\n        },\n      };\n\n      const spy = moduleMocker.spyOn(obj, 'method', 'get');\n\n      const thisArg = {this: true};\n      const firstArg = {first: true};\n      const secondArg = {second: true};\n      obj.method.call(thisArg, firstArg, secondArg);\n      expect(isOriginalCalled).toBe(true);\n      expect(originalCallThis).toBe(thisArg);\n      expect(originalCallArguments).toHaveLength(2);\n      expect(originalCallArguments[0]).toBe(firstArg);\n      expect(originalCallArguments[1]).toBe(secondArg);\n      expect(spy).toHaveBeenCalled();\n\n      isOriginalCalled = false;\n      originalCallThis = null;\n      originalCallArguments = null;\n      spy.mockRestore();\n      obj.method.call(thisArg, firstArg, secondArg);\n      expect(isOriginalCalled).toBe(true);\n      expect(originalCallThis).toBe(thisArg);\n      expect(originalCallArguments).toHaveLength(2);\n      expect(originalCallArguments[0]).toBe(firstArg);\n      expect(originalCallArguments[1]).toBe(secondArg);\n      expect(spy).not.toHaveBeenCalled();\n    });\n\n    it('should work with object of null prototype', () => {\n      const Foo = Object.assign(Object.create(null), {\n        foo() {},\n      });\n\n      const spy = moduleMocker.spyOn(Foo, 'foo');\n\n      Foo.foo();\n\n      expect(spy).toHaveBeenCalled();\n    });\n  });\n\n  describe('spyOnProperty', () => {\n    it('should work - getter', () => {\n      let isOriginalCalled = false;\n      let originalCallThis;\n      let originalCallArguments;\n      const obj = {\n        get method() {\n          return function () {\n            isOriginalCalled = true;\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            originalCallThis = this;\n            originalCallArguments = arguments;\n          };\n        },\n      };\n\n      const spy = moduleMocker.spyOn(obj, 'method', 'get');\n\n      const thisArg = {this: true};\n      const firstArg = {first: true};\n      const secondArg = {second: true};\n      obj.method.call(thisArg, firstArg, secondArg);\n      expect(isOriginalCalled).toBe(true);\n      expect(originalCallThis).toBe(thisArg);\n      expect(originalCallArguments).toHaveLength(2);\n      expect(originalCallArguments[0]).toBe(firstArg);\n      expect(originalCallArguments[1]).toBe(secondArg);\n      expect(spy).toHaveBeenCalled();\n\n      isOriginalCalled = false;\n      originalCallThis = null;\n      originalCallArguments = null;\n      spy.mockRestore();\n      obj.method.call(thisArg, firstArg, secondArg);\n      expect(isOriginalCalled).toBe(true);\n      expect(originalCallThis).toBe(thisArg);\n      expect(originalCallArguments).toHaveLength(2);\n      expect(originalCallArguments[0]).toBe(firstArg);\n      expect(originalCallArguments[1]).toBe(secondArg);\n      expect(spy).not.toHaveBeenCalled();\n    });\n\n    it('should work - setter', () => {\n      const obj = {\n        _property: false,\n        set property(value) {\n          this._property = value;\n        },\n        get property() {\n          return this._property;\n        },\n      };\n\n      const spy = moduleMocker.spyOn(obj, 'property', 'set');\n      obj.property = true;\n      expect(spy).toHaveBeenCalled();\n      expect(obj.property).toBe(true);\n      obj.property = false;\n      spy.mockRestore();\n      obj.property = true;\n      expect(spy).not.toHaveBeenCalled();\n      expect(obj.property).toBe(true);\n    });\n\n    it('should throw on invalid input', () => {\n      expect(() => {\n        moduleMocker.spyOn(null, 'method');\n      }).toThrow('Cannot use spyOn on a primitive value; null given');\n      expect(() => {\n        moduleMocker.spyOn({}, 'method');\n      }).toThrow('Property `method` does not exist in the provided object');\n      expect(() => {\n        moduleMocker.spyOn({method: 10}, 'method');\n      }).toThrow(\n        \"Cannot spy on the `method` property because it is not a function; number given instead. If you are trying to mock a property, use `jest.replaceProperty(object, 'method', value)` instead.\",\n      );\n    });\n\n    it('supports resetting a spy', () => {\n      const methodOneReturn = 0;\n      let methodOneRealCalls = 0;\n      const obj = {\n        get methodOne() {\n          methodOneRealCalls++;\n          return methodOneReturn;\n        },\n      };\n\n      const spy1 = moduleMocker\n        .spyOn(obj, 'methodOne', 'get')\n        .mockReturnValue(10);\n\n      // Return value is mocked.\n      expect(obj.methodOne).toBe(10);\n\n      spy1.mockReset();\n\n      // After resetting the spy, the getter is a stub returning undefined\n      expect(obj.methodOne).toBeUndefined();\n      expect(methodOneRealCalls).toBe(0);\n    });\n\n    it('supports resetting all spies', () => {\n      const methodOneReturn = 10;\n      const methodTwoReturn = 20;\n      const obj = {\n        get methodOne() {\n          return methodOneReturn;\n        },\n        get methodTwo() {\n          return methodTwoReturn;\n        },\n      };\n\n      moduleMocker.spyOn(obj, 'methodOne', 'get').mockReturnValue(100);\n      moduleMocker.spyOn(obj, 'methodTwo', 'get').mockReturnValue(200);\n\n      // Return values are mocked.\n      expect(methodOneReturn).toBe(10);\n      expect(methodTwoReturn).toBe(20);\n      expect(obj.methodOne).toBe(100);\n      expect(obj.methodTwo).toBe(200);\n\n      moduleMocker.resetAllMocks();\n\n      // After resetting all mocks, the methods are stubs\n      expect(obj.methodOne).toBeUndefined();\n      expect(obj.methodTwo).toBeUndefined();\n    });\n\n    it('supports restoring a spy', () => {\n      let methodOneCalls = 0;\n      const obj = {\n        get methodOne() {\n          return function () {\n            methodOneCalls++;\n          };\n        },\n      };\n\n      const spy1 = moduleMocker.spyOn(obj, 'methodOne', 'get');\n\n      obj.methodOne();\n\n      // The spy and the original function are called.\n      expect(methodOneCalls).toBe(1);\n      expect(spy1.mock.calls).toHaveLength(1);\n\n      spy1.mockRestore();\n\n      obj.methodOne();\n\n      // After restoring the spy only the real method bumps its call count, not the spy.\n      expect(methodOneCalls).toBe(2);\n      expect(spy1.mock.calls).toHaveLength(0);\n    });\n\n    it('supports restoring all spies', () => {\n      let methodOneCalls = 0;\n      let methodTwoCalls = 0;\n      const obj = {\n        get methodOne() {\n          return function () {\n            methodOneCalls++;\n          };\n        },\n        get methodTwo() {\n          return function () {\n            methodTwoCalls++;\n          };\n        },\n      };\n\n      const spy1 = moduleMocker.spyOn(obj, 'methodOne', 'get');\n      const spy2 = moduleMocker.spyOn(obj, 'methodTwo', 'get');\n\n      // First, we call with the spies: both spies and both original functions\n      // should be called.\n      obj.methodOne();\n      obj.methodTwo();\n      expect(methodOneCalls).toBe(1);\n      expect(methodTwoCalls).toBe(1);\n      expect(spy1.mock.calls).toHaveLength(1);\n      expect(spy2.mock.calls).toHaveLength(1);\n\n      moduleMocker.restoreAllMocks();\n\n      // Then, after resetting all mocks, we call methods again. Only the real\n      // methods should bump their count, not the spies.\n      obj.methodOne();\n      obj.methodTwo();\n      expect(methodOneCalls).toBe(2);\n      expect(methodTwoCalls).toBe(2);\n      expect(spy1.mock.calls).toHaveLength(1);\n      expect(spy2.mock.calls).toHaveLength(1);\n    });\n\n    it('should work with getters on the prototype chain', () => {\n      let isOriginalCalled = false;\n      let originalCallThis;\n      let originalCallArguments;\n      const prototype = {\n        get method() {\n          return function () {\n            isOriginalCalled = true;\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            originalCallThis = this;\n            originalCallArguments = arguments;\n          };\n        },\n      };\n      const obj = Object.create(prototype, {});\n\n      const spy = moduleMocker.spyOn(obj, 'method', 'get');\n\n      const thisArg = {this: true};\n      const firstArg = {first: true};\n      const secondArg = {second: true};\n      obj.method.call(thisArg, firstArg, secondArg);\n      expect(isOriginalCalled).toBe(true);\n      expect(originalCallThis).toBe(thisArg);\n      expect(originalCallArguments).toHaveLength(2);\n      expect(originalCallArguments[0]).toBe(firstArg);\n      expect(originalCallArguments[1]).toBe(secondArg);\n      expect(spy).toHaveBeenCalled();\n\n      isOriginalCalled = false;\n      originalCallThis = null;\n      originalCallArguments = null;\n      spy.mockRestore();\n      obj.method.call(thisArg, firstArg, secondArg);\n      expect(isOriginalCalled).toBe(true);\n      expect(originalCallThis).toBe(thisArg);\n      expect(originalCallArguments).toHaveLength(2);\n      expect(originalCallArguments[0]).toBe(firstArg);\n      expect(originalCallArguments[1]).toBe(secondArg);\n      expect(spy).not.toHaveBeenCalled();\n    });\n\n    test('should work with setters on the prototype chain', () => {\n      const prototype = {\n        _property: false,\n        set property(value) {\n          this._property = value;\n        },\n        get property() {\n          return this._property;\n        },\n      };\n      const obj = Object.create(prototype, {});\n\n      const spy = moduleMocker.spyOn(obj, 'property', 'set');\n      obj.property = true;\n      expect(spy).toHaveBeenCalled();\n      expect(obj.property).toBe(true);\n      obj.property = false;\n      spy.mockRestore();\n      obj.property = true;\n      expect(spy).not.toHaveBeenCalled();\n      expect(obj.property).toBe(true);\n    });\n\n    it('supports resetting a spy on the prototype chain', () => {\n      let methodOneRealCalls = 0;\n      const prototype = {\n        get methodOne() {\n          methodOneRealCalls++;\n          return 1;\n        },\n      };\n      const obj = Object.create(prototype, {});\n\n      const spy1 = moduleMocker\n        .spyOn(obj, 'methodOne', 'get')\n        .mockReturnValue(10);\n\n      // Return value is mocked.\n      expect(obj.methodOne).toBe(10);\n\n      spy1.mockReset();\n\n      // After resetting the spy, the method is a stub.\n      expect(obj.methodOne).toBeUndefined();\n\n      // The real implementation has not been used.\n      expect(methodOneRealCalls).toBe(0);\n    });\n\n    it('supports resetting all spies on the prototype chain', () => {\n      const methodOneReturn = 10;\n      const methodTwoReturn = 20;\n      const prototype = {\n        get methodOne() {\n          return methodOneReturn;\n        },\n        get methodTwo() {\n          return methodTwoReturn;\n        },\n      };\n      const obj = Object.create(prototype, {});\n\n      moduleMocker.spyOn(obj, 'methodOne', 'get').mockReturnValue(100);\n      moduleMocker.spyOn(obj, 'methodTwo', 'get').mockReturnValue(200);\n\n      // Return values are mocked.\n      expect(obj.methodOne).toBe(100);\n      expect(obj.methodTwo).toBe(200);\n\n      moduleMocker.resetAllMocks();\n\n      // After resetting all mocks, the methods are stubs\n      expect(obj.methodOne).toBeUndefined();\n      expect(obj.methodTwo).toBeUndefined();\n    });\n\n    it('supports restoring a spy on the prototype chain', () => {\n      let methodOneCalls = 0;\n      const prototype = {\n        get methodOne() {\n          return function () {\n            methodOneCalls++;\n          };\n        },\n      };\n      const obj = Object.create(prototype, {});\n\n      const spy1 = moduleMocker.spyOn(obj, 'methodOne', 'get');\n\n      obj.methodOne();\n\n      // The spy and the original function are called, because we have not mocked it.\n      expect(methodOneCalls).toBe(1);\n      expect(spy1.mock.calls).toHaveLength(1);\n\n      spy1.mockRestore();\n\n      obj.methodOne();\n\n      // After restoring the spy only the real method bumps its call count, not the spy.\n      expect(methodOneCalls).toBe(2);\n      expect(spy1.mock.calls).toHaveLength(0);\n    });\n\n    it('supports restoring all spies on the prototype chain', () => {\n      let methodOneCalls = 0;\n      let methodTwoCalls = 0;\n      const prototype = {\n        get methodOne() {\n          return function () {\n            methodOneCalls++;\n          };\n        },\n        get methodTwo() {\n          return function () {\n            methodTwoCalls++;\n          };\n        },\n      };\n      const obj = Object.create(prototype, {});\n\n      const spy1 = moduleMocker.spyOn(obj, 'methodOne', 'get');\n      const spy2 = moduleMocker.spyOn(obj, 'methodTwo', 'get');\n\n      // First, we call with the spies: both spies and both original functions\n      // should be called.\n      obj.methodOne();\n      obj.methodTwo();\n      expect(methodOneCalls).toBe(1);\n      expect(methodTwoCalls).toBe(1);\n      expect(spy1.mock.calls).toHaveLength(1);\n      expect(spy2.mock.calls).toHaveLength(1);\n\n      moduleMocker.restoreAllMocks();\n\n      // Then, after resetting all mocks, we call methods again. Only the real\n      // methods should bump their count, not the spies.\n      obj.methodOne();\n      obj.methodTwo();\n      expect(methodOneCalls).toBe(2);\n      expect(methodTwoCalls).toBe(2);\n      expect(spy1.mock.calls).toHaveLength(1);\n      expect(spy2.mock.calls).toHaveLength(1);\n    });\n  });\n\n  describe('replaceProperty', () => {\n    it('should work', () => {\n      const obj = {\n        property: 1,\n      };\n\n      const replaced = moduleMocker.replaceProperty(obj, 'property', 2);\n\n      expect(obj.property).toBe(2);\n\n      replaced.restore();\n\n      expect(obj.property).toBe(1);\n    });\n\n    it('should allow mocking a property multiple times', () => {\n      const obj = {\n        property: 1,\n      };\n\n      const replacedFirst = moduleMocker.replaceProperty(obj, 'property', 2);\n\n      const replacedSecond = moduleMocker.replaceProperty(obj, 'property', 3);\n\n      expect(obj.property).toBe(3);\n\n      replacedSecond.restore();\n\n      expect(obj.property).toBe(1);\n\n      replacedFirst.restore();\n\n      expect(obj.property).toBe(1);\n    });\n\n    it('should allow mocking with value of different value', () => {\n      const obj = {\n        property: 1,\n      };\n\n      const replaced = moduleMocker.replaceProperty(obj, 'property', {\n        foo: 'bar',\n      });\n\n      expect(obj.property).toStrictEqual({foo: 'bar'});\n\n      replaced.restore();\n\n      expect(obj.property).toBe(1);\n    });\n\n    describe('should throw', () => {\n      it.each`\n        value         | type\n        ${'foo'}      | ${'string'}\n        ${1}          | ${'number'}\n        ${Number.NaN} | ${'number'}\n        ${1n}         | ${'bigint'}\n        ${Symbol()}   | ${'symbol'}\n        ${true}       | ${'boolean'}\n        ${false}      | ${'boolean'}\n        ${undefined}  | ${'undefined'}\n        ${null}       | ${'null'}\n      `(\n        'when primitive value $value is provided instead of an object',\n        ({value, type}) => {\n          expect(() => {\n            moduleMocker.replaceProperty(value, 'property', 1);\n          }).toThrow(\n            `Cannot use replaceProperty on a primitive value; ${type} given`,\n          );\n        },\n      );\n\n      it('when property name is not provided', () => {\n        expect(() => {\n          moduleMocker.replaceProperty({}, null, 1);\n        }).toThrow('No property name supplied');\n      });\n\n      it('when property does not exist', () => {\n        expect(() => {\n          moduleMocker.replaceProperty({}, 'doesNotExist', 1);\n        }).toThrow(\n          'Property `doesNotExist` does not exist in the provided object',\n        );\n      });\n\n      it('when property is not configurable', () => {\n        expect(() => {\n          const obj = {};\n\n          Object.defineProperty(obj, 'property', {\n            configurable: false,\n            value: 1,\n            writable: false,\n          });\n\n          moduleMocker.replaceProperty(obj, 'property', 2);\n        }).toThrow('Property `property` is not declared configurable');\n      });\n\n      it('when trying to replace a method', () => {\n        expect(() => {\n          moduleMocker.replaceProperty({method: () => {}}, 'method', () => {});\n        }).toThrow(\n          \"Cannot replace the `method` property because it is a function. Use `jest.spyOn(object, 'method')` instead.\",\n        );\n      });\n\n      it('when trying to replace a getter', () => {\n        const obj = {\n          get getter() {\n            return 1;\n          },\n        };\n\n        expect(() => {\n          moduleMocker.replaceProperty(obj, 'getter', 1);\n        }).toThrow(\n          'Cannot replace the `getter` property because it has a getter',\n        );\n      });\n\n      it('when trying to replace a setter', () => {\n        const obj = {\n          // eslint-disable-next-line accessor-pairs\n          set setter(_value: number) {},\n        };\n\n        expect(() => {\n          moduleMocker.replaceProperty(obj, 'setter', 1);\n        }).toThrow(\n          'Cannot replace the `setter` property because it has a setter',\n        );\n      });\n    });\n\n    it('supports replacing a property named `0`', () => {\n      const obj = {\n        0: 'zero',\n      };\n\n      moduleMocker.replaceProperty(obj, 0, 'null');\n\n      expect(obj[0]).toBe('null');\n    });\n\n    it('supports replacing a symbol-keyed property', () => {\n      const k = Symbol();\n\n      const obj = {\n        [k]: 'zero',\n      };\n\n      moduleMocker.replaceProperty(obj, k, 'null');\n\n      expect(obj[k]).toBe('null');\n    });\n\n    it('supports replacing a property which is defined on a function', () => {\n      const obj = () => true;\n\n      Object.defineProperty(obj, 'property', {\n        configurable: true,\n        value: 'abc',\n        writable: true,\n      });\n\n      moduleMocker.replaceProperty(obj, 'property', 'def');\n\n      expect(obj.property).toBe('def');\n    });\n\n    it('should work for property from prototype chain', () => {\n      const parent = {property: 'abcd'};\n      const child = Object.create(parent);\n\n      const replaced = moduleMocker.replaceProperty(child, 'property', 'defg');\n\n      expect(child.property).toBe('defg');\n\n      replaced.restore();\n\n      expect(child.property).toBe('abcd');\n      expect(\n        Object.getOwnPropertyDescriptor(child, 'property'),\n      ).toBeUndefined();\n    });\n\n    describe('with restoreAllMocks', () => {\n      it('should work', () => {\n        const obj = {\n          property: 1,\n        };\n\n        const replaced = moduleMocker.replaceProperty(obj, 'property', 2);\n\n        expect(obj.property).toBe(2);\n\n        moduleMocker.restoreAllMocks();\n\n        expect(obj.property).toBe(1);\n\n        // Just make sure that this call won't break anything while calling after the property has been already restored\n        replaced.restore();\n\n        expect(obj.property).toBe(1);\n      });\n\n      it('should work for property mocked multiple times', () => {\n        const obj = {\n          property: 1,\n        };\n\n        const replaced1 = moduleMocker.replaceProperty(obj, 'property', 2);\n        const replaced2 = moduleMocker.replaceProperty(obj, 'property', 3);\n\n        expect(obj.property).toBe(3);\n\n        moduleMocker.restoreAllMocks();\n\n        expect(obj.property).toBe(1);\n\n        // Just make sure that this call won't break anything while calling after the property has been already restored\n        replaced2.restore();\n        replaced1.restore();\n\n        expect(obj.property).toBe(1);\n      });\n    });\n\n    describe('replaceValue', () => {\n      it('should work', () => {\n        const obj = {\n          property: 1,\n        };\n\n        const replaced = moduleMocker.replaceProperty(obj, 'property', 2);\n\n        const result = replaced.replaceValue(3);\n\n        expect(obj.property).toBe(3);\n        expect(result).toBe(replaced);\n      });\n\n      it('should work while passing different type', () => {\n        const obj = {\n          property: 1,\n        };\n\n        const replaced = moduleMocker.replaceProperty(obj, 'property', 2);\n\n        const result = replaced.replaceValue('foo');\n\n        expect(obj.property).toBe('foo');\n        expect(result).toBe(replaced);\n      });\n    });\n  });\n});\n\ndescribe('mocked', () => {\n  it('should return unmodified input', () => {\n    const subject = {};\n    expect(mocked(subject)).toBe(subject);\n  });\n});\n\ntest('`fn` and `spyOn` do not throw', () => {\n  expect(() => {\n    fn();\n    spyOn({apple: () => {}}, 'apple');\n  }).not.toThrow();\n});\n",
  "packages/jest-mock/src/__tests__/index.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport {};\n",
  "packages/jest-mock/src/__tests__/class-mocks.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\ndescribe('Testing the mocking of a class', () => {\n  it('can call an instance method', () => {\n    class TestClass {\n      testMethod(): string {\n        return 'testMethod';\n      }\n    }\n\n    const mockFn = jest\n      .spyOn(TestClass.prototype, 'testMethod')\n      .mockImplementation(() => 'mockTestMethod');\n    const testClassInstance = new TestClass();\n    expect(testClassInstance.testMethod()).toBe('mockTestMethod');\n\n    mockFn.mockRestore();\n    expect(testClassInstance.testMethod()).toBe('testMethod');\n  });\n\n  it('can call a superclass instance method', () => {\n    class SuperTestClass {\n      testMethod(): string {\n        return 'testMethod';\n      }\n    }\n\n    class TestClass extends SuperTestClass {}\n\n    const mockFn = jest\n      .spyOn(TestClass.prototype, 'testMethod')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    const testClassInstance = new TestClass();\n    expect(testClassInstance.testMethod()).toBe('mockTestMethod');\n\n    mockFn.mockRestore();\n    expect(testClassInstance.testMethod()).toBe('testMethod');\n    // eslint-disable-next-line no-prototype-builtins\n    expect(TestClass.prototype.hasOwnProperty('testMethod')).toBe(false);\n  });\n\n  it('can call an instance method named \"get\"', () => {\n    class TestClass {\n      get(): string {\n        return 'get';\n      }\n    }\n\n    const mockFn = jest\n      .spyOn(TestClass.prototype, 'get')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    const testClassInstance = new TestClass();\n    expect(testClassInstance.get()).toBe('mockTestMethod');\n\n    mockFn.mockRestore();\n    expect(testClassInstance.get()).toBe('get');\n  });\n\n  it('can call a superclass instance method named \"get\"', () => {\n    class SuperTestClass {\n      get(): string {\n        return 'get';\n      }\n    }\n\n    class TestClass extends SuperTestClass {}\n\n    const mockFn = jest\n      .spyOn(TestClass.prototype, 'get')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    const testClassInstance = new TestClass();\n    expect(testClassInstance.get()).toBe('mockTestMethod');\n\n    mockFn.mockRestore();\n    expect(testClassInstance.get()).toBe('get');\n    // eslint-disable-next-line no-prototype-builtins\n    expect(TestClass.prototype.hasOwnProperty('get')).toBe(false);\n  });\n\n  it('can call an instance method named \"set\"', () => {\n    class TestClass {\n      set(): string {\n        return 'set';\n      }\n    }\n\n    const mockFn = jest\n      .spyOn(TestClass.prototype, 'set')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    const testClassInstance = new TestClass();\n    expect(testClassInstance.set()).toBe('mockTestMethod');\n\n    mockFn.mockRestore();\n    expect(testClassInstance.set()).toBe('set');\n  });\n\n  it('can call a superclass instance method named \"set\"', () => {\n    class SuperTestClass {\n      set(): string {\n        return 'set';\n      }\n    }\n\n    class TestClass extends SuperTestClass {}\n\n    const mockFn = jest\n      .spyOn(TestClass.prototype, 'set')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    const testClassInstance = new TestClass();\n    expect(testClassInstance.set()).toBe('mockTestMethod');\n\n    mockFn.mockRestore();\n    expect(testClassInstance.set()).toBe('set');\n    // eslint-disable-next-line no-prototype-builtins\n    expect(TestClass.prototype.hasOwnProperty('set')).toBe(false);\n  });\n\n  it('can read a value from an instance getter', () => {\n    class TestClass {\n      get testMethod(): string {\n        return 'testMethod';\n      }\n    }\n\n    const mockFn = jest\n      .spyOn(TestClass.prototype, 'testMethod', 'get')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    const testClassInstance = new TestClass();\n    expect(testClassInstance.testMethod).toBe('mockTestMethod');\n\n    mockFn.mockRestore();\n    expect(testClassInstance.testMethod).toBe('testMethod');\n  });\n\n  it('can read a value from an superclass instance getter', () => {\n    class SuperTestClass {\n      get testMethod(): string {\n        return 'testMethod';\n      }\n    }\n\n    class TestClass extends SuperTestClass {}\n\n    const mockFn = jest\n      .spyOn(TestClass.prototype, 'testMethod', 'get')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    const testClassInstance = new TestClass();\n    expect(testClassInstance.testMethod).toBe('mockTestMethod');\n\n    mockFn.mockRestore();\n    expect(testClassInstance.testMethod).toBe('testMethod');\n  });\n\n  it('can write a value to an instance setter', () => {\n    class TestClass {\n      // eslint-disable-next-line accessor-pairs\n      set testMethod(_x: string) {\n        return;\n      }\n    }\n\n    const mocktestMethod = jest\n      .spyOn(TestClass.prototype, 'testMethod', 'set')\n      .mockImplementation((_x: string) => {\n        return () => {};\n      });\n    const testClassInstance = new TestClass();\n    testClassInstance.testMethod = '';\n    expect(mocktestMethod).toHaveBeenCalledTimes(1);\n\n    mocktestMethod.mockRestore();\n    testClassInstance.testMethod = '';\n    expect(mocktestMethod).toHaveBeenCalledTimes(0);\n  });\n\n  it('can write a value to a superclass instance setter', () => {\n    class SuperTestClass {\n      // eslint-disable-next-line accessor-pairs\n      set testMethod(_x: string) {\n        return;\n      }\n    }\n\n    class TestClass extends SuperTestClass {}\n\n    const mocktestMethod = jest\n      .spyOn(TestClass.prototype, 'testMethod', 'set')\n      .mockImplementation((_x: string) => {\n        return () => {};\n      });\n    const testClassInstance = new TestClass();\n    testClassInstance.testMethod = '';\n    expect(mocktestMethod).toHaveBeenCalledTimes(1);\n\n    mocktestMethod.mockRestore();\n    testClassInstance.testMethod = '';\n    expect(mocktestMethod).toHaveBeenCalledTimes(0);\n  });\n\n  it('can call a static method', () => {\n    class TestClass {\n      static testMethod(): string {\n        return 'testMethod';\n      }\n    }\n\n    const mockFn = jest\n      .spyOn(TestClass, 'testMethod')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    expect(TestClass.testMethod()).toBe('mockTestMethod');\n\n    mockFn.mockRestore();\n    expect(TestClass.testMethod()).toBe('testMethod');\n  });\n\n  it('can call a superclass static method', () => {\n    class SuperTestClass {\n      static testMethod(): string {\n        return 'testMethod';\n      }\n    }\n\n    class TestClass extends SuperTestClass {}\n\n    const mockFn = jest\n      .spyOn(TestClass, 'testMethod')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    expect(TestClass.testMethod()).toBe('mockTestMethod');\n\n    mockFn.mockRestore();\n    expect(TestClass.testMethod()).toBe('testMethod');\n  });\n\n  it('can call a static method named \"get\"', () => {\n    class TestClass {\n      static get(): string {\n        return 'get';\n      }\n    }\n\n    const mockFn = jest.spyOn(TestClass, 'get').mockImplementation(() => {\n      return 'mockTestMethod';\n    });\n    expect(TestClass.get()).toBe('mockTestMethod');\n\n    mockFn.mockRestore();\n    expect(TestClass.get()).toBe('get');\n  });\n\n  it('can call a superclass static method named \"get\"', () => {\n    class SuperTestClass {\n      static get(): string {\n        return 'get';\n      }\n    }\n\n    class TestClass extends SuperTestClass {}\n\n    const mockFn = jest.spyOn(TestClass, 'get').mockImplementation(() => {\n      return 'mockTestMethod';\n    });\n    expect(TestClass.get()).toBe('mockTestMethod');\n\n    mockFn.mockRestore();\n    expect(TestClass.get()).toBe('get');\n    // eslint-disable-next-line no-prototype-builtins\n    expect(TestClass.hasOwnProperty('get')).toBe(false);\n  });\n\n  it('can call a static method named \"set\"', () => {\n    class TestClass {\n      static set(): string {\n        return 'set';\n      }\n    }\n\n    const mockFn = jest.spyOn(TestClass, 'set').mockImplementation(() => {\n      return 'mockTestMethod';\n    });\n    expect(TestClass.set()).toBe('mockTestMethod');\n\n    mockFn.mockRestore();\n    expect(TestClass.set()).toBe('set');\n  });\n\n  it('can call a superclass static method named \"set\"', () => {\n    class SuperTestClass {\n      static set(): string {\n        return 'set';\n      }\n    }\n\n    class TestClass extends SuperTestClass {}\n\n    const mockFn = jest.spyOn(TestClass, 'set').mockImplementation(() => {\n      return 'mockTestMethod';\n    });\n    expect(TestClass.set()).toBe('mockTestMethod');\n\n    mockFn.mockRestore();\n    expect(TestClass.set()).toBe('set');\n    // eslint-disable-next-line no-prototype-builtins\n    expect(TestClass.hasOwnProperty('set')).toBe(false);\n  });\n\n  it('can read a value from a static getter', () => {\n    class TestClass {\n      static get testMethod(): string {\n        return 'testMethod';\n      }\n    }\n\n    const mockFn = jest\n      .spyOn(TestClass, 'testMethod', 'get')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    expect(TestClass.testMethod).toBe('mockTestMethod');\n\n    mockFn.mockRestore();\n    expect(TestClass.testMethod).toBe('testMethod');\n  });\n\n  it('can read a value from a superclass static getter', () => {\n    class SuperTestClass {\n      static get testMethod(): string {\n        return 'testMethod';\n      }\n    }\n\n    class TestClass extends SuperTestClass {}\n\n    const mockFn = jest\n      .spyOn(TestClass, 'testMethod', 'get')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    expect(TestClass.testMethod).toBe('mockTestMethod');\n\n    mockFn.mockRestore();\n    expect(TestClass.testMethod).toBe('testMethod');\n  });\n\n  it('can write a value to a static setter', () => {\n    class TestClass {\n      // eslint-disable-next-line accessor-pairs\n      static set testMethod(_x: string) {\n        return;\n      }\n    }\n\n    const mocktestMethod = jest\n      .spyOn(TestClass, 'testMethod', 'set')\n      .mockImplementation((_x: string) => {\n        return () => {};\n      });\n    TestClass.testMethod = '';\n    expect(mocktestMethod).toHaveBeenCalledTimes(1);\n\n    mocktestMethod.mockRestore();\n    expect(mocktestMethod).toHaveBeenCalledTimes(0);\n  });\n\n  it('can write a value to a superclass static setter', () => {\n    class SuperTestClass {\n      // eslint-disable-next-line accessor-pairs\n      static set testMethod(_x: string) {\n        return;\n      }\n    }\n\n    class TestClass extends SuperTestClass {}\n\n    const mocktestMethod = jest\n      .spyOn(TestClass, 'testMethod', 'set')\n      .mockImplementation((_x: string) => {\n        return () => {};\n      });\n    TestClass.testMethod = '';\n    expect(mocktestMethod).toHaveBeenCalledTimes(1);\n  });\n});\n",
  "packages/jest-mock/src/__tests__/class-mocks.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n",
  "packages/jest-mock/src/__tests__/class-mocks-single-import.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport SuperTestClass, * as testTypes from './__fixtures__/class-mocks-types';\njest.mock('./__fixtures__/class-mocks-types');\n\ndescribe('Testing the mocking of exported functions', () => {\n  it('can mock a directly exported function', () => {\n    jest.spyOn(testTypes, 'testFunction1').mockImplementation(() => {\n      return 'mockTestFunction';\n    });\n    expect(testTypes.testFunction1()).toBe('mockTestFunction');\n  });\n\n  it('can mock an indirectly exported function', () => {\n    jest.spyOn(testTypes, 'testFunction2').mockImplementation(() => {\n      return 'mockTestFunction';\n    });\n    expect(testTypes.testFunction2()).toBe('mockTestFunction');\n  });\n\n  it('can mock an indirectly exported anonymous function', () => {\n    jest.spyOn(testTypes, 'testFunction3').mockImplementation(() => {\n      return 'mockTestFunction';\n    });\n    expect(testTypes.testFunction3()).toBe('mockTestFunction');\n  });\n});\n\ndescribe('Testing the mocking of a class hierarchy defined in a single import', () => {\n  it('can call an instance method - Auto-mocked class', () => {\n    const mockTestMethod = jest\n      .spyOn(SuperTestClass.prototype, 'testMethod')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    const testClassInstance = new SuperTestClass();\n    expect(testClassInstance.testMethod()).toBe('mockTestMethod');\n    expect(mockTestMethod).toHaveBeenCalledTimes(1);\n\n    mockTestMethod.mockClear();\n  });\n\n  it('can call a superclass instance method - Auto-mocked class', () => {\n    const mockTestMethod = jest\n      .spyOn(testTypes.TestClass.prototype, 'testMethod')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    const testClassInstance = new testTypes.TestClass();\n    expect(testClassInstance.testMethod()).toBe('mockTestMethod');\n    expect(mockTestMethod).toHaveBeenCalledTimes(1);\n  });\n\n  it('can call an instance method named \"get\" - Auto-mocked class', () => {\n    const mockTestMethod = jest\n      .spyOn(SuperTestClass.prototype, 'get')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    const testClassInstance = new SuperTestClass();\n    expect(testClassInstance.get()).toBe('mockTestMethod');\n    expect(mockTestMethod).toHaveBeenCalledTimes(1);\n\n    mockTestMethod.mockClear();\n  });\n\n  it('can call a superclass instance method named \"get\" - Auto-mocked class', () => {\n    const mockTestMethod = jest\n      .spyOn(testTypes.TestClass.prototype, 'get')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    const testClassInstance = new testTypes.TestClass();\n    expect(testClassInstance.get()).toBe('mockTestMethod');\n    expect(mockTestMethod).toHaveBeenCalledTimes(1);\n\n    mockTestMethod.mockClear();\n  });\n\n  it('can call an instance method named \"set\" - Auto-mocked class', () => {\n    const mockTestMethod = jest\n      .spyOn(SuperTestClass.prototype, 'set')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    const testClassInstance = new SuperTestClass();\n    expect(testClassInstance.set()).toBe('mockTestMethod');\n    expect(mockTestMethod).toHaveBeenCalledTimes(1);\n\n    mockTestMethod.mockClear();\n  });\n\n  it('can call a superclass instance method named \"set\" - Auto-mocked class', () => {\n    const mockTestMethod = jest\n      .spyOn(testTypes.TestClass.prototype, 'set')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    const testClassInstance = new testTypes.TestClass();\n    expect(testClassInstance.set()).toBe('mockTestMethod');\n    expect(mockTestMethod).toHaveBeenCalledTimes(1);\n\n    mockTestMethod.mockClear();\n  });\n\n  it('can call a static method - Auto-mocked class', () => {\n    const mockTestMethod = jest\n      .spyOn(SuperTestClass, 'staticTestMethod')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    expect(SuperTestClass.staticTestMethod()).toBe('mockTestMethod');\n    expect(mockTestMethod).toHaveBeenCalledTimes(1);\n\n    mockTestMethod.mockClear();\n  });\n\n  it('can call a superclass static method - Auto-mocked class', () => {\n    const mockTestMethod = jest\n      .spyOn(testTypes.TestClass, 'staticTestMethod')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    expect(testTypes.TestClass.staticTestMethod()).toBe('mockTestMethod');\n    expect(mockTestMethod).toHaveBeenCalledTimes(1);\n  });\n\n  it('can call a static method named \"get\" - Auto-mocked class', () => {\n    const mockTestMethod = jest\n      .spyOn(SuperTestClass, 'get')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    expect(SuperTestClass.get()).toBe('mockTestMethod');\n    expect(mockTestMethod).toHaveBeenCalledTimes(1);\n\n    mockTestMethod.mockClear();\n  });\n\n  it('can call a superclass static method named \"get\" - Auto-mocked class', () => {\n    const mockTestMethod = jest\n      .spyOn(testTypes.TestClass, 'get')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    expect(testTypes.TestClass.get()).toBe('mockTestMethod');\n    expect(mockTestMethod).toHaveBeenCalledTimes(1);\n\n    mockTestMethod.mockClear();\n  });\n\n  it('can call a static method named \"set\" - Auto-mocked class', () => {\n    const mockTestMethod = jest\n      .spyOn(SuperTestClass, 'set')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    expect(SuperTestClass.set()).toBe('mockTestMethod');\n    expect(mockTestMethod).toHaveBeenCalledTimes(1);\n\n    mockTestMethod.mockClear();\n  });\n\n  it('can call a superclass static method named \"set\" - Auto-mocked class', () => {\n    const mockTestMethod = jest\n      .spyOn(testTypes.TestClass, 'set')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    expect(testTypes.TestClass.set()).toBe('mockTestMethod');\n    expect(mockTestMethod).toHaveBeenCalledTimes(1);\n\n    mockTestMethod.mockClear();\n  });\n});\n",
  "packages/jest-mock/src/__tests__/class-mocks-single-import.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport {};\n",
  "packages/jest-mock/src/__tests__/class-mocks-dual-import.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {SuperTestClass} from './__fixtures__/SuperTestClass';\nimport TestClass from './__fixtures__/TestClass';\njest.mock('./__fixtures__/SuperTestClass');\njest.mock('./__fixtures__/TestClass');\n\ndescribe('Testing the mocking of a class hierarchy defined in multiple imports', () => {\n  it('can call an instance method - Auto-mocked class', () => {\n    const mockTestMethod = jest\n      .spyOn(SuperTestClass.prototype, 'testMethod')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    const testClassInstance = new SuperTestClass();\n    expect(testClassInstance.testMethod()).toBe('mockTestMethod');\n    expect(mockTestMethod).toHaveBeenCalledTimes(1);\n\n    mockTestMethod.mockClear();\n  });\n\n  it('can call a superclass instance method - Auto-mocked class', () => {\n    const mockTestMethod = jest\n      .spyOn(TestClass.prototype, 'testMethod')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    const testClassInstance = new TestClass();\n    expect(testClassInstance.testMethod()).toBe('mockTestMethod');\n    expect(mockTestMethod).toHaveBeenCalledTimes(1);\n  });\n});\n",
  "packages/jest-mock/src/__tests__/class-mocks-dual-import.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport {};\n",
  "packages/jest-mock/src/__tests__/__fixtures__/class-mocks-types.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nexport default class SuperTestClass {\n  static staticTestProperty = 'staticTestProperty';\n\n  static get staticTestAccessor(): string {\n    return 'staticTestAccessor';\n  }\n\n  static set staticTestAccessor(_x: string) {\n    return;\n  }\n\n  static staticTestMethod(): string {\n    return 'staticTestMethod';\n  }\n\n  static get(): string {\n    return 'get';\n  }\n\n  static set(): string {\n    return 'set';\n  }\n\n  testProperty = 'testProperty';\n\n  get testAccessor(): string {\n    return 'testAccessor';\n  }\n  set testAccessor(_x: string) {\n    return;\n  }\n\n  testMethod(): string {\n    return 'testMethod';\n  }\n\n  get(): string {\n    return 'get';\n  }\n\n  set(): string {\n    return 'set';\n  }\n}\n\nexport class TestClass extends SuperTestClass {}\n\nexport function testFunction1() {\n  return 'testFunction1';\n}\n\nfunction testFunction() {\n  return 'testFunction2';\n}\nexport const testFunction2 = testFunction;\n\nexport const testFunction3 = () => {\n  return 'testFunction3';\n};\n",
  "packages/jest-mock/src/__tests__/__fixtures__/class-mocks-types.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport default class SuperTestClass {\n    static staticTestProperty: string;\n    static get staticTestAccessor(): string;\n    static set staticTestAccessor(_x: string);\n    static staticTestMethod(): string;\n    static get(): string;\n    static set(): string;\n    testProperty: string;\n    get testAccessor(): string;\n    set testAccessor(_x: string);\n    testMethod(): string;\n    get(): string;\n    set(): string;\n}\nexport declare class TestClass extends SuperTestClass {\n}\nexport declare function testFunction1(): string;\ndeclare function testFunction(): string;\nexport declare const testFunction2: typeof testFunction;\nexport declare const testFunction3: () => string;\nexport {};\n",
  "packages/jest-mock/src/__tests__/__fixtures__/TestClass.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {SuperTestClass} from './SuperTestClass';\n\nexport default class TestClass extends SuperTestClass {}\n",
  "packages/jest-mock/src/__tests__/__fixtures__/TestClass.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport { SuperTestClass } from './SuperTestClass';\nexport default class TestClass extends SuperTestClass {\n}\n",
  "packages/jest-mock/src/__tests__/__fixtures__/SuperTestClass.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nexport class SuperTestClass {\n  static staticTestProperty = 'staticTestProperty';\n\n  static get staticTestAccessor(): string {\n    return 'staticTestAccessor';\n  }\n\n  static set staticTestAccessor(_x: string) {\n    return;\n  }\n\n  static staticTestMethod(): string {\n    return 'staticTestMethod';\n  }\n\n  testProperty = 'testProperty';\n\n  get testAccessor(): string {\n    return 'testAccessor';\n  }\n  set testAccessor(_x: string) {\n    return;\n  }\n\n  testMethod(): string {\n    return 'testMethod';\n  }\n}\n",
  "packages/jest-mock/src/__tests__/__fixtures__/SuperTestClass.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport declare class SuperTestClass {\n    static staticTestProperty: string;\n    static get staticTestAccessor(): string;\n    static set staticTestAccessor(_x: string);\n    static staticTestMethod(): string;\n    testProperty: string;\n    get testAccessor(): string;\n    set testAccessor(_x: string);\n    testMethod(): string;\n}\n",
  "packages/jest-mock/__typetests__/utility-types.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {expect, test} from 'tstyche';\nimport type {\n  ClassLike,\n  ConstructorLikeKeys,\n  FunctionLike,\n  MethodLikeKeys,\n  PropertyLikeKeys,\n} from 'jest-mock';\n\nclass SomeClass {\n  propertyB = 123;\n  private _propertyC: undefined;\n  // eslint-disable-next-line no-unused-private-class-members\n  #propertyD = 'abc';\n\n  constructor(public propertyA: string) {}\n\n  methodA(): void {\n    return;\n  }\n\n  methodB(b: string): string {\n    return b;\n  }\n\n  get propertyC() {\n    return this._propertyC;\n  }\n  set propertyC(value) {\n    this._propertyC = value;\n  }\n}\n\nclass IndexClass {\n  [key: string]: Record<string, any>;\n\n  propertyB = {b: 123};\n  private _propertyC = {c: undefined};\n  // eslint-disable-next-line no-unused-private-class-members\n  #propertyD = 'abc';\n\n  constructor(public propertyA: {a: string}) {}\n\n  methodA(): void {\n    return;\n  }\n\n  methodB(b: string): string {\n    return b;\n  }\n\n  get propertyC() {\n    return this._propertyC;\n  }\n  set propertyC(value) {\n    this._propertyC = value;\n  }\n}\n\ninterface OptionalInterface {\n  constructorA?: (new (one: string) => SomeClass) | undefined;\n  constructorB: new (one: string, two: boolean) => SomeClass;\n\n  propertyA?: number | undefined;\n  propertyB?: number;\n  propertyC: number | undefined;\n  propertyD: string;\n\n  methodA?: ((a: boolean) => void) | undefined;\n  methodB: (b: string) => boolean;\n}\n\nconst someObject = {\n  SomeClass,\n\n  methodA() {\n    return;\n  },\n  methodB(b: string) {\n    return true;\n  },\n  methodC: (c: number) => true,\n\n  propertyA: 123,\n  propertyB: 'value',\n\n  someClassInstance: new SomeClass('value'),\n};\n\ntype SomeObject = typeof someObject;\n\ntype IndexObject = {\n  [key: string]: Record<string, any>;\n\n  methodA(): void;\n  methodB(b: string): boolean;\n  methodC: (c: number) => boolean;\n\n  propertyA: {a: number};\n  propertyB: {b: string};\n};\n\ntest('ClassLike', () => {\n  expect<ClassLike>().type.toBeAssignableWith(SomeClass);\n\n  expect<ClassLike>().type.not.toBeAssignableWith(() => {});\n  expect<ClassLike>().type.not.toBeAssignableWith(function abc() {\n    return;\n  });\n  expect<ClassLike>().type.not.toBeAssignableWith('abc');\n  expect<ClassLike>().type.not.toBeAssignableWith(123);\n  expect<ClassLike>().type.not.toBeAssignableWith(false);\n  expect<ClassLike>().type.not.toBeAssignableWith(someObject);\n});\n\ntest('FunctionLike', () => {\n  expect<FunctionLike>().type.toBeAssignableWith(() => {});\n  expect<FunctionLike>().type.toBeAssignableWith(function abc() {\n    return;\n  });\n\n  expect<FunctionLike>().type.not.toBeAssignableWith('abc');\n  expect<FunctionLike>().type.not.toBeAssignableWith(123);\n  expect<FunctionLike>().type.not.toBeAssignableWith(false);\n  expect<FunctionLike>().type.not.toBeAssignableWith(SomeClass);\n  expect<FunctionLike>().type.not.toBeAssignableWith(someObject);\n});\n\ntest('ConstructorKeys', () => {\n  expect<ConstructorLikeKeys<OptionalInterface>>().type.toBe<\n    'constructorA' | 'constructorB'\n  >();\n  expect<ConstructorLikeKeys<SomeObject>>().type.toBe<'SomeClass'>();\n});\n\ntest('MethodKeys', () => {\n  expect<MethodLikeKeys<SomeClass>>().type.toBe<'methodA' | 'methodB'>();\n  expect<MethodLikeKeys<IndexClass>>().type.toBe<'methodA' | 'methodB'>();\n  expect<MethodLikeKeys<OptionalInterface>>().type.toBe<\n    'methodA' | 'methodB'\n  >();\n  expect<MethodLikeKeys<SomeObject>>().type.toBe<\n    'methodA' | 'methodB' | 'methodC'\n  >();\n  expect<MethodLikeKeys<IndexObject>>().type.toBe<\n    'methodA' | 'methodB' | 'methodC'\n  >();\n});\n\ntest('PropertyKeys', () => {\n  expect<PropertyLikeKeys<SomeClass>>().type.toBe<\n    'propertyA' | 'propertyB' | 'propertyC'\n  >();\n  expect<PropertyLikeKeys<IndexClass>>().type.toBe<string | number>();\n  expect<PropertyLikeKeys<OptionalInterface>>().type.toBe<\n    'propertyA' | 'propertyB' | 'propertyC' | 'propertyD'\n  >();\n  expect<PropertyLikeKeys<SomeObject>>().type.toBe<\n    'propertyA' | 'propertyB' | 'someClassInstance'\n  >();\n  expect<PropertyLikeKeys<IndexObject>>().type.toBe<string | number>();\n});\n",
  "packages/jest-mock/__typetests__/utility-types.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-mock/__typetests__/mock-functions.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/// <reference lib=\"dom\" />\n\nimport {describe, expect, test} from 'tstyche';\nimport {\n  type Mock,\n  type Replaced,\n  type SpiedClass,\n  type SpiedFunction,\n  type SpiedGetter,\n  type SpiedSetter,\n  fn,\n  replaceProperty,\n  spyOn,\n} from 'jest-mock';\n\ndescribe('jest.fn()', () => {\n  const mockFnImpl: (this: Date, a: string, b?: number) => boolean = (a, b) =>\n    true;\n\n  const mockFn = fn(mockFnImpl);\n  const mockAsyncFn = fn(async (p: boolean) => 'value');\n\n  const MockObject = fn((credentials: string) => ({\n    connect() {\n      return fn();\n    },\n    disconnect() {\n      return;\n    },\n  }));\n\n  test('when sync function is provided, returned object can be chained', () => {\n    expect(\n      fn(() => 'value')\n        .mockClear()\n        .mockReset()\n        .mockImplementation(() => 'value')\n        .mockImplementationOnce(() => 'value')\n        .mockName('mock')\n        .mockReturnThis()\n        .mockReturnValue('value')\n        .mockReturnValueOnce('value'),\n    ).type.toBe<Mock<() => string>>();\n\n    expect(fn(() => 'value').mockReturnValue).type.not.toBeCallableWith(\n      Promise.resolve('value'),\n    );\n    expect(fn(() => 'value').mockReturnValueOnce).type.not.toBeCallableWith(\n      Promise.resolve('value'),\n    );\n  });\n\n  test('when async function is provided, returned object can be chained', () => {\n    expect(\n      fn(async () => 'value')\n        .mockClear()\n        .mockReset()\n        .mockImplementation(fn(async () => 'value'))\n        .mockImplementationOnce(fn(async () => 'value'))\n        .mockName('mock')\n        .mockResolvedValue('value')\n        .mockResolvedValueOnce('value')\n        .mockRejectedValue('error')\n        .mockRejectedValueOnce('error')\n        .mockReturnThis()\n        .mockReturnValue(Promise.resolve('value'))\n        .mockReturnValueOnce(Promise.resolve('value')),\n    ).type.toBe<Mock<() => Promise<string>>>();\n\n    expect(fn(() => 'value').mockResolvedValue).type.not.toBeCallableWith(\n      'value',\n    );\n    expect(fn(() => 'value').mockResolvedValueOnce).type.not.toBeCallableWith(\n      'value',\n    );\n\n    expect(fn(() => 'value').mockRejectedValue).type.not.toBeCallableWith(\n      'error',\n    );\n    expect(fn(() => 'value').mockRejectedValueOnce).type.not.toBeCallableWith(\n      'error',\n    );\n  });\n\n  test('models typings of mocked function', () => {\n    expect(fn()).type.toBeAssignableTo<Function>();\n\n    expect(fn()).type.toBe<Mock<(...args: Array<unknown>) => unknown>>();\n    expect(fn(() => {})).type.toBe<Mock<() => void>>();\n    expect(fn((a: string, b?: number) => true)).type.toBe<\n      Mock<(a: string, b?: number | undefined) => boolean>\n    >();\n    expect(\n      fn((e: any) => {\n        throw new Error();\n      }),\n    ).type.toBe<Mock<(e: any) => never>>();\n\n    expect(fn).type.not.toBeCallableWith('moduleName');\n  });\n\n  test('infers argument and return types of mocked function', () => {\n    expect(mockFn('one', 2)).type.toBe<boolean>();\n    expect(mockAsyncFn(false)).type.toBe<Promise<string>>();\n\n    expect(mockFn).type.not.toBeCallableWith();\n    expect(mockAsyncFn).type.not.toBeCallableWith();\n  });\n\n  test('infers argument and return types of mocked object', () => {\n    expect(new MockObject('credentials')).type.toBe<{\n      connect(): Mock<(...args: Array<unknown>) => unknown>;\n      disconnect(): void;\n    }>();\n\n    expect(MockObject).type.not.toBeConstructableWith();\n  });\n\n  test('.getMockImplementation()', () => {\n    expect(mockFn.getMockImplementation()).type.toBe<\n      ((a: string, b?: number | undefined) => boolean) | undefined\n    >();\n\n    expect(mockFn.getMockImplementation).type.not.toBeCallableWith('some-mock');\n  });\n\n  test('.getMockName()', () => {\n    expect(mockFn.getMockName()).type.toBe<string>();\n\n    expect(mockFn.getMockName).type.not.toBeCallableWith('some-mock');\n  });\n\n  test('.mock', () => {\n    expect(mockFn.mock.calls.length).type.toBe<number>();\n\n    expect(mockFn.mock.calls[0][0]).type.toBe<string>();\n    expect(mockFn.mock.calls[0][1]).type.toBe<number | undefined>();\n\n    expect(mockFn.mock.calls[1][0]).type.toBe<string>();\n    expect(mockFn.mock.calls[1][1]).type.toBe<number | undefined>();\n\n    expect(mockFn.mock.contexts).type.toBe<Array<Date>>();\n\n    expect(mockFn.mock.lastCall).type.toBe<\n      [a: string, b?: number | undefined] | undefined\n    >();\n\n    expect(mockFn.mock.invocationCallOrder).type.toBe<Array<number>>();\n\n    expect(MockObject.mock.instances).type.toBe<\n      Array<{\n        connect(): Mock<(...args: Array<unknown>) => unknown>;\n        disconnect(): void;\n      }>\n    >();\n\n    const returnValue = mockFn.mock.results[0];\n\n    expect(returnValue.type).type.toBe<'incomplete' | 'return' | 'throw'>();\n    expect(returnValue.value).type.toBe<unknown>();\n\n    if (returnValue.type === 'incomplete') {\n      expect(returnValue.value).type.toBe<undefined>();\n    }\n\n    if (returnValue.type === 'return') {\n      expect(returnValue.value).type.toBe<boolean>();\n    }\n\n    if (returnValue.type === 'throw') {\n      expect(returnValue.value).type.toBe<unknown>();\n    }\n  });\n\n  test('.mockClear()', () => {\n    expect(mockFn.mockClear()).type.toBe<\n      Mock<(a: string, b?: number | undefined) => boolean>\n    >();\n\n    expect(mockFn.mockClear).type.not.toBeCallableWith('some-mock');\n  });\n\n  test('.mockReset()', () => {\n    expect(mockFn.mockReset()).type.toBe<\n      Mock<(a: string, b?: number | undefined) => boolean>\n    >();\n\n    expect(mockFn.mockReset).type.not.toBeCallableWith('some-mock');\n  });\n\n  test('.mockRestore()', () => {\n    expect(mockFn.mockRestore()).type.toBe<void>();\n\n    expect(mockFn.mockRestore).type.not.toBeCallableWith('some-mock');\n  });\n\n  test('.mockImplementation()', () => {\n    expect(\n      mockFn.mockImplementation((a, b) => {\n        expect(a).type.toBe<string>();\n        expect(b).type.toBe<number | undefined>();\n        return false;\n      }),\n    ).type.toBe<Mock<(a: string, b?: number | undefined) => boolean>>();\n\n    expect(mockFn.mockImplementation).type.not.toBeCallableWith(\n      (a: number) => false,\n    );\n    expect(mockFn.mockImplementation).type.not.toBeCallableWith(() => 'false');\n    expect(mockFn.mockImplementation).type.not.toBeCallableWith();\n\n    expect(\n      mockAsyncFn.mockImplementation(async a => {\n        expect(a).type.toBe<boolean>();\n        return 'mock value';\n      }),\n    ).type.toBe<Mock<(p: boolean) => Promise<string>>>();\n\n    expect(mockAsyncFn.mockImplementation).type.not.toBeCallableWith(\n      () => 'mock value',\n    );\n  });\n\n  test('.mockImplementationOnce()', () => {\n    expect(\n      mockFn.mockImplementationOnce((a, b) => {\n        expect(a).type.toBe<string>();\n        expect(b).type.toBe<number | undefined>();\n        return false;\n      }),\n    ).type.toBe<Mock<(a: string, b?: number | undefined) => boolean>>();\n\n    expect(mockFn.mockImplementationOnce).type.not.toBeCallableWith(\n      (a: number) => false,\n    );\n    expect(mockFn.mockImplementationOnce).type.not.toBeCallableWith(\n      () => 'false',\n    );\n    expect(mockFn.mockImplementationOnce).type.not.toBeCallableWith();\n\n    expect(\n      mockAsyncFn.mockImplementationOnce(async a => {\n        expect(a).type.toBe<boolean>();\n        return 'mock value';\n      }),\n    ).type.toBe<Mock<(p: boolean) => Promise<string>>>();\n    expect(mockAsyncFn.mockImplementationOnce).type.not.toBeCallableWith(\n      () => 'mock value',\n    );\n  });\n\n  test('.mockName()', () => {\n    expect(mockFn.mockName('mockedFunction')).type.toBe<\n      Mock<(a: string, b?: number | undefined) => boolean>\n    >();\n\n    expect(mockFn.mockName).type.not.toBeCallableWith(123);\n    expect(mockFn.mockName).type.not.toBeCallableWith();\n  });\n\n  test('.mockReturnThis()', () => {\n    expect(mockFn.mockReturnThis()).type.toBe<\n      Mock<(a: string, b?: number | undefined) => boolean>\n    >();\n\n    expect(mockFn.mockReturnThis).type.not.toBeCallableWith('this');\n  });\n\n  test('.mockReturnValue()', () => {\n    expect(mockFn.mockReturnValue(false)).type.toBe<\n      Mock<(a: string, b?: number | undefined) => boolean>\n    >();\n\n    expect(mockFn.mockReturnValue).type.not.toBeCallableWith('true');\n    expect(mockFn.mockReturnValue).type.not.toBeCallableWith();\n\n    expect(\n      mockAsyncFn.mockReturnValue(Promise.resolve('mock value')),\n    ).type.toBe<Mock<(p: boolean) => Promise<string>>>();\n\n    expect(mockAsyncFn.mockReturnValue).type.not.toBeCallableWith(\n      Promise.resolve(true),\n    );\n  });\n\n  test('.mockReturnValueOnce()', () => {\n    expect(mockFn.mockReturnValueOnce(false)).type.toBe<\n      Mock<(a: string, b?: number | undefined) => boolean>\n    >();\n    expect(mockFn.mockReturnValueOnce).type.not.toBeCallableWith('true');\n\n    expect(mockFn.mockReturnValueOnce).type.not.toBeCallableWith();\n\n    expect(\n      mockAsyncFn.mockReturnValueOnce(Promise.resolve('mock value')),\n    ).type.toBe<Mock<(p: boolean) => Promise<string>>>();\n\n    expect(mockAsyncFn.mockReturnValueOnce).type.not.toBeCallableWith(\n      Promise.resolve(true),\n    );\n  });\n\n  test('.mockResolvedValue()', () => {\n    expect(\n      fn(() => Promise.resolve('')).mockResolvedValue('Mock value'),\n    ).type.toBe<Mock<() => Promise<string>>>();\n\n    expect(\n      fn(() => Promise.resolve('')).mockResolvedValue,\n    ).type.not.toBeCallableWith(123);\n    expect(\n      fn(() => Promise.resolve('')).mockResolvedValue,\n    ).type.not.toBeCallableWith();\n  });\n\n  test('.mockResolvedValueOnce()', () => {\n    expect(\n      fn(() => Promise.resolve('')).mockResolvedValueOnce('Mock value'),\n    ).type.toBe<Mock<() => Promise<string>>>();\n\n    expect(\n      fn(() => Promise.resolve('')).mockResolvedValueOnce,\n    ).type.not.toBeCallableWith(123);\n    expect(\n      fn(() => Promise.resolve('')).mockResolvedValueOnce,\n    ).type.not.toBeCallableWith();\n  });\n\n  test('.mockRejectedValue()', () => {\n    expect(\n      fn(() => Promise.resolve('')).mockRejectedValue(new Error('Mock error')),\n    ).type.toBe<Mock<() => Promise<string>>>();\n    expect(\n      fn(() => Promise.resolve('')).mockRejectedValue('Mock error'),\n    ).type.toBe<Mock<() => Promise<string>>>();\n\n    expect(\n      fn(() => Promise.resolve('')).mockRejectedValue,\n    ).type.not.toBeCallableWith();\n  });\n\n  test('.mockRejectedValueOnce()', () => {\n    expect(\n      fn(() => Promise.resolve('')).mockRejectedValueOnce(\n        new Error('Mock error'),\n      ),\n    ).type.toBe<Mock<() => Promise<string>>>();\n    expect(\n      fn(() => Promise.resolve('')).mockRejectedValueOnce('Mock error'),\n    ).type.toBe<Mock<() => Promise<string>>>();\n\n    expect(\n      fn(() => Promise.resolve('')).mockRejectedValueOnce,\n    ).type.not.toBeCallableWith();\n  });\n\n  test('.withImplementation()', () => {\n    expect(mockFn.withImplementation(mockFnImpl, () => {})).type.toBe<void>();\n    expect(mockFn.withImplementation(mockFnImpl, async () => {})).type.toBe<\n      Promise<void>\n    >();\n\n    expect(mockFn.withImplementation).type.not.toBeCallableWith(mockFnImpl);\n  });\n});\n\ndescribe('jest.spyOn()', () => {\n  const spiedArray = ['a', 'b'];\n\n  const spiedFunction = () => {};\n\n  const spiedObject = {\n    _propertyB: false,\n\n    methodA() {\n      return true;\n    },\n    methodB(a: string, b: number) {\n      return;\n    },\n    methodC(e: any) {\n      throw new Error();\n    },\n\n    propertyA: 'abc',\n\n    set propertyB(value) {\n      this._propertyB = value;\n    },\n    get propertyB() {\n      return this._propertyB;\n    },\n  };\n\n  type IndexSpiedObject = {\n    [key: string]: Record<string, any>;\n\n    methodA(): boolean;\n    methodB(a: string, b: number): void;\n    methodC: (c: number) => boolean;\n    methodE: (e: any) => never;\n\n    propertyA: {a: string};\n  };\n\n  const indexSpiedObject: IndexSpiedObject = {\n    methodA() {\n      return true;\n    },\n    methodB(a: string, b: number) {\n      return;\n    },\n    methodC(c: number) {\n      return true;\n    },\n    methodE(e: any) {\n      throw new Error();\n    },\n\n    propertyA: {a: 'abc'},\n  };\n\n  const spy = spyOn(spiedObject, 'methodA');\n\n  test('models typings of spied object', () => {\n    expect(spy).type.not.toBeAssignableTo<Function>();\n\n    expect(spy()).type.toRaiseError('This expression is not callable.');\n    expect(new spy()).type.toRaiseError(\n      'This expression is not constructable.',\n    );\n\n    expect(spyOn(spiedObject, 'methodA')).type.toBe<\n      SpiedFunction<typeof spiedObject.methodA>\n    >();\n    expect(spyOn(spiedObject, 'methodB')).type.toBe<\n      SpiedFunction<typeof spiedObject.methodB>\n    >();\n    expect(spyOn(spiedObject, 'methodC')).type.toBe<\n      SpiedFunction<typeof spiedObject.methodC>\n    >();\n\n    expect(spyOn(spiedObject, 'propertyB', 'get')).type.toBe<\n      SpiedGetter<typeof spiedObject.propertyB>\n    >();\n    expect(spyOn(spiedObject, 'propertyB', 'set')).type.toBe<\n      SpiedSetter<typeof spiedObject.propertyB>\n    >();\n    expect(spyOn).type.not.toBeCallableWith(spiedObject, 'propertyB');\n    expect(spyOn).type.not.toBeCallableWith(spiedObject, 'methodB', 'get');\n    expect(spyOn).type.not.toBeCallableWith(spiedObject, 'methodB', 'set');\n\n    expect(spyOn(spiedObject, 'propertyA', 'get')).type.toBe<\n      SpiedGetter<typeof spiedObject.propertyA>\n    >();\n    expect(spyOn(spiedObject, 'propertyA', 'set')).type.toBe<\n      SpiedSetter<typeof spiedObject.propertyA>\n    >();\n    expect(spyOn).type.not.toBeCallableWith(spiedObject, 'propertyA');\n\n    expect(spyOn).type.not.toBeCallableWith(spiedObject, 'notThere');\n    expect(spyOn).type.not.toBeCallableWith('abc', 'methodA');\n    expect(spyOn).type.not.toBeCallableWith(123, 'methodA');\n    expect(spyOn).type.not.toBeCallableWith(true, 'methodA');\n    expect(spyOn).type.not.toBeCallableWith(spiedObject);\n    expect(spyOn).type.not.toBeCallableWith();\n\n    expect(\n      spyOn(spiedArray as unknown as ArrayConstructor, 'isArray'),\n    ).type.toBe<SpiedFunction<typeof Array.isArray>>();\n    expect(spyOn).type.not.toBeCallableWith(spiedArray, 'isArray');\n\n    expect(spyOn(spiedFunction as unknown as Function, 'toString')).type.toBe<\n      SpiedFunction<typeof spiedFunction.toString>\n    >();\n    expect(spyOn).type.not.toBeCallableWith(spiedFunction, 'toString');\n\n    expect(spyOn(globalThis, 'Date')).type.toBe<SpiedClass<typeof Date>>();\n    expect(spyOn(Date, 'now')).type.toBe<SpiedFunction<typeof Date.now>>();\n  });\n\n  test('handles object with index signature', () => {\n    expect(spyOn(indexSpiedObject, 'methodA')).type.toBe<\n      SpiedFunction<typeof indexSpiedObject.methodA>\n    >();\n    expect(spyOn(indexSpiedObject, 'methodB')).type.toBe<\n      SpiedFunction<typeof indexSpiedObject.methodB>\n    >();\n    expect(spyOn(indexSpiedObject, 'methodC')).type.toBe<\n      SpiedFunction<typeof indexSpiedObject.methodC>\n    >();\n    expect(spyOn(indexSpiedObject, 'methodE')).type.toBe<\n      SpiedFunction<typeof indexSpiedObject.methodE>\n    >();\n\n    expect(spyOn(indexSpiedObject, 'propertyA', 'get')).type.toBe<\n      SpiedGetter<typeof indexSpiedObject.propertyA>\n    >();\n    expect(spyOn(indexSpiedObject, 'propertyA', 'set')).type.toBe<\n      SpiedSetter<typeof indexSpiedObject.propertyA>\n    >();\n    expect(spyOn).type.not.toBeCallableWith(indexSpiedObject, 'propertyA');\n\n    expect(spyOn).type.not.toBeCallableWith(indexSpiedObject, 'notThere');\n  });\n\n  test('handles interface with optional properties', () => {\n    class SomeClass {\n      constructor(one: string, two?: boolean) {}\n\n      methodA() {\n        return true;\n      }\n      methodB(a: string, b?: number) {\n        return;\n      }\n    }\n\n    interface OptionalInterface {\n      constructorA?: (new (one: string) => SomeClass) | undefined;\n      constructorB: new (one: string, two: boolean) => SomeClass;\n\n      propertyA?: number | undefined;\n      propertyB?: number;\n      propertyC: number | undefined;\n      propertyD: string;\n\n      methodA?: ((a: boolean) => void) | undefined;\n      methodB: (b: string) => boolean;\n    }\n\n    const optionalSpiedObject = {} as OptionalInterface;\n\n    expect(spyOn(optionalSpiedObject, 'constructorA')).type.toBe<\n      SpiedClass<NonNullable<typeof optionalSpiedObject.constructorA>>\n    >();\n    expect(spyOn(optionalSpiedObject, 'constructorB')).type.toBe<\n      SpiedClass<typeof optionalSpiedObject.constructorB>\n    >();\n\n    expect(spyOn).type.not.toBeCallableWith(\n      optionalSpiedObject,\n      'constructorA',\n      'get',\n    );\n    expect(spyOn).type.not.toBeCallableWith(\n      optionalSpiedObject,\n      'constructorA',\n      'set',\n    );\n\n    expect(spyOn(optionalSpiedObject, 'methodA')).type.toBe<\n      SpiedFunction<NonNullable<typeof optionalSpiedObject.methodA>>\n    >();\n    expect(spyOn(optionalSpiedObject, 'methodB')).type.toBe<\n      SpiedFunction<typeof optionalSpiedObject.methodB>\n    >();\n\n    expect(spyOn).type.not.toBeCallableWith(\n      optionalSpiedObject,\n      'methodA',\n      'get',\n    );\n    expect(spyOn).type.not.toBeCallableWith(\n      optionalSpiedObject,\n      'methodA',\n      'set',\n    );\n\n    expect(spyOn(optionalSpiedObject, 'propertyA', 'get')).type.toBe<\n      SpiedGetter<NonNullable<typeof optionalSpiedObject.propertyA>>\n    >();\n    expect(spyOn(optionalSpiedObject, 'propertyA', 'set')).type.toBe<\n      SpiedSetter<NonNullable<typeof optionalSpiedObject.propertyA>>\n    >();\n    expect(spyOn(optionalSpiedObject, 'propertyB', 'get')).type.toBe<\n      SpiedGetter<NonNullable<typeof optionalSpiedObject.propertyB>>\n    >();\n    expect(spyOn(optionalSpiedObject, 'propertyB', 'set')).type.toBe<\n      SpiedSetter<NonNullable<typeof optionalSpiedObject.propertyB>>\n    >();\n    expect(spyOn(optionalSpiedObject, 'propertyC', 'get')).type.toBe<\n      SpiedGetter<typeof optionalSpiedObject.propertyC>\n    >();\n    expect(spyOn(optionalSpiedObject, 'propertyC', 'set')).type.toBe<\n      SpiedSetter<typeof optionalSpiedObject.propertyC>\n    >();\n    expect(spyOn(optionalSpiedObject, 'propertyD', 'get')).type.toBe<\n      SpiedGetter<typeof optionalSpiedObject.propertyD>\n    >();\n    expect(spyOn(optionalSpiedObject, 'propertyD', 'set')).type.toBe<\n      SpiedSetter<typeof optionalSpiedObject.propertyD>\n    >();\n\n    expect(spyOn).type.not.toBeCallableWith(optionalSpiedObject, 'propertyA');\n    expect(spyOn).type.not.toBeCallableWith(optionalSpiedObject, 'propertyB');\n  });\n\n  test('handles properties of `prototype`', () => {\n    expect(\n      spyOn(Storage.prototype, 'setItem').mockImplementation(\n        (key: string, value: string) => {},\n      ),\n    ).type.toBe<SpiedFunction<(key: string, value: string) => void>>();\n\n    expect(\n      spyOn(Storage.prototype, 'setItem').mockImplementation,\n    ).type.not.toBeCallableWith((key: string, value: number) => {});\n  });\n});\n\ndescribe('jest.replaceProperty()', () => {\n  const replaceObject = {\n    method: () => {},\n    property: 1,\n  };\n\n  interface ComplexObject {\n    numberOrUndefined: number | undefined;\n    optionalString?: string;\n    multipleTypes: number | string | {foo: number} | null;\n  }\n\n  const complexObject = {} as ComplexObject;\n\n  interface ObjectWithDynamicProperties {\n    [key: string]: boolean;\n  }\n\n  const objectWithDynamicProperties = {} as ObjectWithDynamicProperties;\n\n  test('models typings of replaced property', () => {\n    expect(replaceProperty(replaceObject, 'property', 1)).type.toBe<\n      Replaced<number>\n    >();\n    expect(replaceProperty(replaceObject, 'method', () => {})).type.toBe<\n      Replaced<() => void>\n    >();\n    expect(\n      replaceProperty(replaceObject, 'property', 1).replaceValue(1).restore(),\n    ).type.toBe<void>();\n\n    expect(replaceProperty).type.not.toBeCallableWith(\n      replaceObject,\n      'invalid',\n      1,\n    );\n    expect(replaceProperty).type.not.toBeCallableWith(\n      replaceObject,\n      'property',\n      'not a number',\n    );\n\n    expect(\n      replaceProperty(replaceObject, 'property', 1).replaceValue,\n    ).type.not.toBeCallableWith('not a number');\n\n    expect(\n      replaceProperty(complexObject, 'numberOrUndefined', undefined),\n    ).type.toBe<Replaced<number | undefined>>();\n    expect(replaceProperty(complexObject, 'numberOrUndefined', 1)).type.toBe<\n      Replaced<number | undefined>\n    >();\n\n    expect(replaceProperty).type.not.toBeCallableWith(\n      complexObject,\n      'numberOrUndefined',\n      'string is not valid TypeScript type',\n    );\n\n    expect(replaceProperty(complexObject, 'optionalString', 'foo')).type.toBe<\n      Replaced<string | undefined>\n    >();\n    expect(\n      replaceProperty(complexObject, 'optionalString', undefined),\n    ).type.toBe<Replaced<string | undefined>>();\n\n    expect(\n      replaceProperty(objectWithDynamicProperties, 'dynamic prop 1', true),\n    ).type.toBe<Replaced<boolean>>();\n    expect(replaceProperty).type.not.toBeCallableWith(\n      objectWithDynamicProperties,\n      'dynamic prop 1',\n      undefined,\n    );\n\n    expect(replaceProperty).type.not.toBeCallableWith(\n      complexObject,\n      'not a property',\n      undefined,\n    );\n\n    expect(\n      replaceProperty(complexObject, 'multipleTypes', 1)\n        .replaceValue('foo')\n        .replaceValue({foo: 1})\n        .replaceValue(null),\n    ).type.toBe<Replaced<ComplexObject['multipleTypes']>>();\n  });\n});\n",
  "packages/jest-mock/__typetests__/mock-functions.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-mock/__typetests__/ModuleMocker.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {expect, test} from 'tstyche';\nimport {type MockMetadata, type Mocked, ModuleMocker} from 'jest-mock';\n\nclass ExampleClass {\n  memberA: Array<number>;\n\n  constructor() {\n    this.memberA = [1, 2, 3];\n  }\n  memberB() {}\n}\n\nconst exampleModule = {\n  instance: new ExampleClass(),\n\n  methodA: function square(a: number, b: number) {\n    return a * b;\n  },\n  methodB: async function asyncSquare(a: number, b: number) {\n    const result = (await a) * b;\n    return result;\n  },\n\n  propertyA: {\n    one: 'foo',\n    three: {\n      nine: 1,\n      ten: [1, 2, 3],\n    },\n    two() {},\n  },\n  propertyB: [1, 2, 3],\n  propertyC: 123,\n  propertyD: 'baz',\n  propertyE: true,\n  propertyF: Symbol.for('a.b.c'),\n};\n\nconst moduleMocker = new ModuleMocker(globalThis);\n\nconst exampleMetadata = moduleMocker.getMetadata(exampleModule);\n\ntest('getMetadata', () => {\n  expect(exampleMetadata).type.toBe<MockMetadata<\n    typeof exampleModule\n  > | null>();\n});\n\ntest('generateFromMetadata', () => {\n  const exampleMock = moduleMocker.generateFromMetadata(exampleMetadata!);\n\n  expect(exampleMock).type.toBe<Mocked<typeof exampleModule>>();\n\n  expect(exampleMock.methodA.mock.calls).type.toBe<\n    Array<[a: number, b: number]>\n  >();\n  expect(exampleMock.methodB.mock.calls).type.toBe<\n    Array<[a: number, b: number]>\n  >();\n\n  expect(exampleMock.instance.memberA).type.toBe<Array<number>>();\n  expect(exampleMock.instance.memberB.mock.calls).type.toBe<Array<[]>>();\n\n  expect(exampleMock.propertyA.one).type.toBe<string>();\n  expect(exampleMock.propertyA.two.mock.calls).type.toBe<Array<[]>>();\n  expect(exampleMock.propertyA.three.nine).type.toBe<number>();\n  expect(exampleMock.propertyA.three.ten).type.toBe<Array<number>>();\n\n  expect(exampleMock.propertyB).type.toBe<Array<number>>();\n  expect(exampleMock.propertyC).type.toBe<number>();\n  expect(exampleMock.propertyD).type.toBe<string>();\n  expect(exampleMock.propertyE).type.toBe<boolean>();\n  expect(exampleMock.propertyF).type.toBe<symbol>();\n});\n",
  "packages/jest-mock/__typetests__/ModuleMocker.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-mock/__typetests__/Mocked.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {describe, expect, test} from 'tstyche';\nimport type {MockInstance, Mocked} from 'jest-mock';\n\ndescribe('Mocked', () => {\n  test('wraps a class type with type definitions of the Jest mock function', () => {\n    class SomeClass {\n      constructor(one: string, two?: boolean) {}\n\n      methodA() {\n        return true;\n      }\n      methodB(a: string, b?: number) {\n        return;\n      }\n    }\n\n    const MockSomeClass = SomeClass as Mocked<typeof SomeClass>;\n\n    expect(MockSomeClass.mock.calls[0]).type.toBe<\n      [one: string, two?: boolean]\n    >();\n\n    expect(MockSomeClass.prototype.methodA.mock.calls[0]).type.toBe<[]>();\n    expect(MockSomeClass.prototype.methodB.mock.calls[0]).type.toBe<\n      [a: string, b?: number]\n    >();\n\n    expect(\n      MockSomeClass.prototype.methodA.mockReturnValue,\n    ).type.not.toBeCallableWith('true');\n    expect(\n      MockSomeClass.prototype.methodB.mockImplementation,\n    ).type.not.toBeCallableWith((a: string, b?: string) => {\n      return;\n    });\n\n    expect(MockSomeClass.mock.instances[0].methodA.mock.calls[0]).type.toBe<\n      []\n    >();\n    expect(MockSomeClass.prototype.methodB.mock.calls[0]).type.toBe<\n      [a: string, b?: number]\n    >();\n\n    const mockSomeInstance = new MockSomeClass('a') as Mocked<\n      InstanceType<typeof MockSomeClass>\n    >;\n\n    expect(mockSomeInstance.methodA.mock.calls[0]).type.toBe<[]>();\n    expect(mockSomeInstance.methodB.mock.calls[0]).type.toBe<\n      [a: string, b?: number]\n    >();\n\n    expect(mockSomeInstance.methodA.mockReturnValue).type.not.toBeCallableWith(\n      'true',\n    );\n    expect(\n      mockSomeInstance.methodB.mockImplementation,\n    ).type.not.toBeCallableWith((a: string, b?: string) => {\n      return;\n    });\n\n    expect(new SomeClass('sample')).type.toBeAssignableWith(mockSomeInstance);\n  });\n\n  test('wraps a function type with type definitions of the Jest mock function', () => {\n    function someFunction(a: string, b?: number): boolean {\n      return true;\n    }\n\n    const mockFunction = someFunction as Mocked<typeof someFunction>;\n\n    expect(mockFunction.mock.calls[0]).type.toBe<[a: string, b?: number]>();\n\n    expect(mockFunction.mockReturnValue).type.not.toBeCallableWith(123);\n    expect(mockFunction.mockImplementation).type.not.toBeCallableWith(\n      (a: boolean, b?: number) => true,\n    );\n\n    expect(someFunction).type.toBeAssignableWith(mockFunction);\n  });\n\n  test('wraps an async function type with type definitions of the Jest mock function', () => {\n    async function someAsyncFunction(a: Array<boolean>): Promise<string> {\n      return 'true';\n    }\n\n    const mockAsyncFunction = someAsyncFunction as Mocked<\n      typeof someAsyncFunction\n    >;\n\n    expect(mockAsyncFunction.mock.calls[0]).type.toBe<[Array<boolean>]>();\n\n    expect(mockAsyncFunction.mockResolvedValue).type.not.toBeCallableWith(123);\n    expect(mockAsyncFunction.mockImplementation).type.not.toBeCallableWith(\n      (a: Array<boolean>) => Promise.resolve(true),\n    );\n\n    expect(someAsyncFunction).type.toBeAssignableWith(mockAsyncFunction);\n  });\n\n  test('wraps a function object type with type definitions of the Jest mock function', () => {\n    interface SomeFunctionObject {\n      (a: number, b?: string): void;\n      one: {\n        (oneA: number, oneB?: boolean): boolean;\n        more: {\n          time: (time: number) => void;\n        };\n      };\n    }\n\n    const someFunctionObject = {} as SomeFunctionObject;\n\n    const mockFunctionObject = someFunctionObject as Mocked<\n      typeof someFunctionObject\n    >;\n\n    expect(mockFunctionObject.mock.calls[0]).type.toBe<\n      [a: number, b?: string]\n    >();\n\n    expect(mockFunctionObject.mockReturnValue).type.not.toBeCallableWith(123);\n    expect(mockFunctionObject.mockImplementation).type.not.toBeCallableWith(\n      () => true,\n    );\n\n    expect(mockFunctionObject.one.more.time.mock.calls[0]).type.toBe<\n      [time: number]\n    >();\n\n    expect(\n      mockFunctionObject.one.more.time.mockReturnValue,\n    ).type.not.toBeCallableWith(123);\n    expect(\n      mockFunctionObject.one.more.time.mockImplementation,\n    ).type.not.toBeCallableWith((time: string) => {\n      return;\n    });\n\n    expect(someFunctionObject).type.toBeAssignableWith(mockFunctionObject);\n  });\n\n  test('wraps an object type with type definitions of the Jest mock function', () => {\n    class SomeClass {\n      constructor(one: string, two?: boolean) {}\n\n      methodA() {\n        return true;\n      }\n      methodB(a: string, b?: number) {\n        return;\n      }\n    }\n\n    const someObject = {\n      SomeClass,\n\n      methodA() {\n        return;\n      },\n      methodB(b: string) {\n        return true;\n      },\n      methodC: (c: number) => true,\n\n      one: {\n        more: {\n          time: (t: number) => {\n            return;\n          },\n        },\n      },\n\n      propertyA: 123,\n      propertyB: 'value',\n\n      someClassInstance: new SomeClass('value'),\n    };\n\n    const mockObject = someObject as Mocked<typeof someObject>;\n\n    expect(mockObject.methodA.mock.calls[0]).type.toBe<[]>();\n    expect(mockObject.methodB.mock.calls[0]).type.toBe<[b: string]>();\n    expect(mockObject.methodC.mock.calls[0]).type.toBe<[c: number]>();\n\n    expect(mockObject.one.more.time.mock.calls[0]).type.toBe<[t: number]>();\n\n    expect(mockObject.SomeClass.mock.calls[0]).type.toBe<\n      [one: string, two?: boolean]\n    >();\n    expect(mockObject.SomeClass.prototype.methodA.mock.calls[0]).type.toBe<\n      []\n    >();\n    expect(mockObject.SomeClass.prototype.methodB.mock.calls[0]).type.toBe<\n      [a: string, b?: number]\n    >();\n\n    expect(mockObject.someClassInstance.methodA.mock.calls[0]).type.toBe<[]>();\n    expect(mockObject.someClassInstance.methodB.mock.calls[0]).type.toBe<\n      [a: string, b?: number]\n    >();\n\n    expect(mockObject.methodA.mockReturnValue).type.not.toBeCallableWith(123);\n    expect(mockObject.methodA.mockImplementation).type.not.toBeCallableWith(\n      (a: number) => 123,\n    );\n    expect(mockObject.methodB.mockReturnValue).type.not.toBeCallableWith(123);\n    expect(mockObject.methodB.mockImplementation).type.not.toBeCallableWith(\n      (b: number) => 123,\n    );\n    expect(mockObject.methodC.mockReturnValue).type.not.toBeCallableWith(123);\n    expect(mockObject.methodC.mockImplementation).type.not.toBeCallableWith(\n      (c: number) => 123,\n    );\n\n    expect(mockObject.one.more.time.mockReturnValue).type.not.toBeCallableWith(\n      123,\n    );\n    expect(\n      mockObject.one.more.time.mockImplementation,\n    ).type.not.toBeCallableWith((t: boolean) => 123);\n\n    expect(\n      mockObject.SomeClass.prototype.methodA.mockReturnValue,\n    ).type.not.toBeCallableWith(123);\n    expect(\n      mockObject.SomeClass.prototype.methodA.mockImplementation,\n    ).type.not.toBeCallableWith((a: number) => 123);\n    expect(\n      mockObject.SomeClass.prototype.methodB.mockReturnValue,\n    ).type.not.toBeCallableWith(123);\n    expect(\n      mockObject.SomeClass.prototype.methodB.mockImplementation,\n    ).type.not.toBeCallableWith((a: number) => 123);\n\n    expect(\n      mockObject.someClassInstance.methodA.mockReturnValue,\n    ).type.not.toBeCallableWith(123);\n    expect(\n      mockObject.someClassInstance.methodA.mockImplementation,\n    ).type.not.toBeCallableWith((a: number) => 123);\n    expect(\n      mockObject.someClassInstance.methodB.mockReturnValue,\n    ).type.not.toBeCallableWith(123);\n    expect(\n      mockObject.someClassInstance.methodB.mockImplementation,\n    ).type.not.toBeCallableWith((a: number) => 123);\n\n    expect(someObject).type.toBeAssignableWith(mockObject);\n  });\n\n  test('wraps the global `console` object type with type definitions of the Jest mock function', () => {\n    const mockConsole = console as Mocked<typeof console>;\n\n    expect(console.log).type.toBeAssignableWith(\n      mockConsole.log.mockImplementation(() => {}),\n    );\n    expect<MockInstance<typeof console.log>>().type.toBeAssignableWith(\n      mockConsole.log.mockImplementation(() => {}),\n    );\n  });\n});\n",
  "packages/jest-mock/__typetests__/Mocked.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-message-util/src/types.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {StackData} from 'stack-utils';\n\nexport interface Frame extends StackData {\n  file: string;\n}\n",
  "packages/jest-message-util/src/types.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { StackData } from 'stack-utils';\nexport interface Frame extends StackData {\n    file: string;\n}\n",
  "packages/jest-message-util/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {fileURLToPath} from 'url';\nimport {types} from 'util';\nimport {codeFrameColumns} from '@babel/code-frame';\nimport chalk from 'chalk';\nimport * as fs from 'graceful-fs';\nimport micromatch from 'micromatch';\nimport slash from 'slash';\nimport StackUtils from 'stack-utils';\nimport type {Config, TestResult} from '@jest/types';\nimport {format as prettyFormat} from 'pretty-format';\nimport type {Frame} from './types';\n\nexport type {Frame} from './types';\n\n// stack utils tries to create pretty stack by making paths relative.\nconst stackUtils = new StackUtils({cwd: 'something which does not exist'});\n\nlet nodeInternals: Array<RegExp> = [];\n\ntry {\n  nodeInternals = StackUtils.nodeInternals();\n} catch {\n  // `StackUtils.nodeInternals()` fails in browsers. We don't need to remove\n  // node internals in the browser though, so no issue.\n}\n\nexport type StackTraceConfig = Pick<\n  Config.ProjectConfig,\n  'rootDir' | 'testMatch'\n>;\n\nexport type StackTraceOptions = {\n  noStackTrace: boolean;\n  noCodeFrame?: boolean;\n};\n\nconst PATH_NODE_MODULES = `${path.sep}node_modules${path.sep}`;\nconst PATH_JEST_PACKAGES = `${path.sep}jest${path.sep}packages${path.sep}`;\n\n// filter for noisy stack trace lines\nconst JASMINE_IGNORE =\n  /^\\s+at(?:(?:.jasmine-)|\\s+jasmine\\.buildExpectationResult)/;\nconst JEST_INTERNALS_IGNORE =\n  /^\\s+at.*?jest(-.*?)?(\\/|\\\\)(build|node_modules|packages)(\\/|\\\\)/;\nconst ANONYMOUS_FN_IGNORE = /^\\s+at <anonymous>.*$/;\nconst ANONYMOUS_PROMISE_IGNORE = /^\\s+at (new )?Promise \\(<anonymous>\\).*$/;\nconst ANONYMOUS_GENERATOR_IGNORE = /^\\s+at Generator.next \\(<anonymous>\\).*$/;\nconst NATIVE_NEXT_IGNORE = /^\\s+at next \\(native\\).*$/;\nconst TITLE_INDENT = '  ';\nconst MESSAGE_INDENT = '    ';\nconst STACK_INDENT = '      ';\nconst ANCESTRY_SEPARATOR = ' \\u203A ';\nconst TITLE_BULLET = chalk.bold('\\u25CF ');\nconst STACK_TRACE_COLOR = chalk.dim;\nconst STACK_PATH_REGEXP = /\\s*at.*\\(?(:\\d*:\\d*|native)\\)?/;\nconst EXEC_ERROR_MESSAGE = 'Test suite failed to run';\nconst NOT_EMPTY_LINE_REGEXP = /^(?!$)/gm;\n\nexport const indentAllLines = (lines: string): string =>\n  lines.replaceAll(NOT_EMPTY_LINE_REGEXP, MESSAGE_INDENT);\n\nconst trim = (string: string) => (string || '').trim();\n\n// Some errors contain not only line numbers in stack traces\n// e.g. SyntaxErrors can contain snippets of code, and we don't\n// want to trim those, because they may have pointers to the column/character\n// which will get misaligned.\nconst trimPaths = (string: string) =>\n  STACK_PATH_REGEXP.test(string) ? trim(string) : string;\n\nconst getRenderedCallsite = (\n  fileContent: string,\n  line: number,\n  column?: number,\n) => {\n  let renderedCallsite = codeFrameColumns(\n    fileContent,\n    {start: {column, line}},\n    {highlightCode: true},\n  );\n\n  renderedCallsite = indentAllLines(renderedCallsite);\n\n  renderedCallsite = `\\n${renderedCallsite}\\n`;\n  return renderedCallsite;\n};\n\nconst blankStringRegexp = /^\\s*$/;\n\nfunction checkForCommonEnvironmentErrors(error: string) {\n  if (\n    error.includes('ReferenceError: document is not defined') ||\n    error.includes('ReferenceError: window is not defined') ||\n    error.includes('ReferenceError: navigator is not defined')\n  ) {\n    return warnAboutWrongTestEnvironment(error, 'jsdom');\n  } else if (error.includes('.unref is not a function')) {\n    return warnAboutWrongTestEnvironment(error, 'node');\n  }\n\n  return error;\n}\n\nfunction warnAboutWrongTestEnvironment(error: string, env: 'jsdom' | 'node') {\n  return (\n    chalk.bold.red(\n      `The error below may be caused by using the wrong test environment, see ${chalk.dim.underline(\n        'https://jestjs.io/docs/configuration#testenvironment-string',\n      )}.\\nConsider using the \"${env}\" test environment.\\n\\n`,\n    ) + error\n  );\n}\n\n// ExecError is an error thrown outside of the test suite (not inside an `it` or\n// `before/after each` hooks). If it's thrown, none of the tests in the file\n// are executed.\nexport const formatExecError = (\n  error: Error | TestResult.SerializableError | string | number | undefined,\n  config: StackTraceConfig,\n  options: StackTraceOptions,\n  testPath?: string,\n  reuseMessage?: boolean,\n  noTitle?: boolean,\n): string => {\n  if (!error || typeof error === 'number') {\n    error = new Error(`Expected an Error, but \"${String(error)}\" was thrown`);\n    error.stack = '';\n  }\n\n  let message, stack;\n  let cause = '';\n  const subErrors = [];\n\n  if (typeof error === 'string' || !error) {\n    error ||= 'EMPTY ERROR';\n    message = '';\n    stack = error;\n  } else {\n    message = error.message;\n    stack =\n      typeof error.stack === 'string'\n        ? error.stack\n        : `thrown: ${prettyFormat(error, {maxDepth: 3})}`;\n    if ('cause' in error) {\n      const prefix = '\\n\\nCause:\\n';\n      if (typeof error.cause === 'string' || typeof error.cause === 'number') {\n        cause += `${prefix}${error.cause}`;\n      } else if (\n        types.isNativeError(error.cause) ||\n        error.cause instanceof Error\n      ) {\n        /* `isNativeError` is used, because the error might come from another realm.\n         `instanceof Error` is used because `isNativeError` does return `false` for some\n         things that are `instanceof Error` like the errors provided in\n         [verror](https://www.npmjs.com/package/verror) or [axios](https://axios-http.com).\n        */\n        const formatted = formatExecError(\n          error.cause,\n          config,\n          options,\n          testPath,\n          reuseMessage,\n          true,\n        );\n        cause += `${prefix}${formatted}`;\n      }\n    }\n    if ('errors' in error && Array.isArray(error.errors)) {\n      for (const subError of error.errors) {\n        subErrors.push(\n          formatExecError(\n            subError,\n            config,\n            options,\n            testPath,\n            reuseMessage,\n            true,\n          ),\n        );\n      }\n    }\n  }\n  if (cause !== '') {\n    cause = indentAllLines(cause);\n  }\n\n  const separated = separateMessageFromStack(stack || '');\n  stack = separated.stack;\n\n  if (separated.message.includes(trim(message))) {\n    // Often stack trace already contains the duplicate of the message\n    message = separated.message;\n  }\n\n  message = checkForCommonEnvironmentErrors(message);\n\n  message = indentAllLines(message);\n\n  stack =\n    stack && !options.noStackTrace\n      ? `\\n${formatStackTrace(stack, config, options, testPath)}`\n      : '';\n\n  if (\n    typeof stack !== 'string' ||\n    (blankStringRegexp.test(message) && blankStringRegexp.test(stack))\n  ) {\n    // this can happen if an empty object is thrown.\n    message = `thrown: ${prettyFormat(error, {maxDepth: 3})}`;\n  }\n\n  let messageToUse;\n\n  if (reuseMessage || noTitle) {\n    messageToUse = ` ${message.trim()}`;\n  } else {\n    messageToUse = `${EXEC_ERROR_MESSAGE}\\n\\n${message}`;\n  }\n  const title = noTitle ? '' : `${TITLE_INDENT + TITLE_BULLET}`;\n  const subErrorStr =\n    subErrors.length > 0\n      ? indentAllLines(\n          `\\n\\nErrors contained in AggregateError:\\n${subErrors.join('\\n')}`,\n        )\n      : '';\n\n  return `${title + messageToUse + stack + cause + subErrorStr}\\n`;\n};\n\nconst removeInternalStackEntries = (\n  lines: Array<string>,\n  options: StackTraceOptions,\n): Array<string> => {\n  let pathCounter = 0;\n\n  return lines.filter(line => {\n    if (ANONYMOUS_FN_IGNORE.test(line)) {\n      return false;\n    }\n\n    if (ANONYMOUS_PROMISE_IGNORE.test(line)) {\n      return false;\n    }\n\n    if (ANONYMOUS_GENERATOR_IGNORE.test(line)) {\n      return false;\n    }\n\n    if (NATIVE_NEXT_IGNORE.test(line)) {\n      return false;\n    }\n\n    if (nodeInternals.some(internal => internal.test(line))) {\n      return false;\n    }\n\n    if (!STACK_PATH_REGEXP.test(line)) {\n      return true;\n    }\n\n    if (JASMINE_IGNORE.test(line)) {\n      return false;\n    }\n\n    if (++pathCounter === 1) {\n      return true; // always keep the first line even if it's from Jest\n    }\n\n    if (options.noStackTrace) {\n      return false;\n    }\n\n    if (JEST_INTERNALS_IGNORE.test(line)) {\n      return false;\n    }\n\n    return true;\n  });\n};\n\nexport const formatPath = (\n  line: string,\n  config: StackTraceConfig,\n  relativeTestPath: string | null = null,\n): string => {\n  // Extract the file path from the trace line.\n  const match = line.match(/(^\\s*at .*?\\(?)([^()]+)(:\\d+:\\d+\\)?.*$)/);\n  if (!match) {\n    return line;\n  }\n\n  let filePath = slash(path.relative(config.rootDir, match[2]));\n  // highlight paths from the current test file\n  if (\n    (config.testMatch &&\n      config.testMatch.length > 0 &&\n      micromatch([filePath], config.testMatch).length > 0) ||\n    filePath === relativeTestPath\n  ) {\n    filePath = chalk.reset.cyan(filePath);\n  }\n  return STACK_TRACE_COLOR(match[1]) + filePath + STACK_TRACE_COLOR(match[3]);\n};\n\nexport function getStackTraceLines(\n  stack: string,\n  options?: StackTraceOptions,\n): Array<string> {\n  options = {noCodeFrame: false, noStackTrace: false, ...options};\n  return removeInternalStackEntries(stack.split(/\\n/), options);\n}\n\nexport function getTopFrame(lines: Array<string>): Frame | null {\n  for (const line of lines) {\n    if (line.includes(PATH_NODE_MODULES) || line.includes(PATH_JEST_PACKAGES)) {\n      continue;\n    }\n\n    const parsedFrame = stackUtils.parseLine(line.trim());\n\n    if (parsedFrame && parsedFrame.file) {\n      if (parsedFrame.file.startsWith('file://')) {\n        parsedFrame.file = slash(fileURLToPath(parsedFrame.file));\n      }\n      return parsedFrame as Frame;\n    }\n  }\n\n  return null;\n}\n\nexport function formatStackTrace(\n  stack: string,\n  config: StackTraceConfig,\n  options: StackTraceOptions,\n  testPath?: string,\n): string {\n  const lines = getStackTraceLines(stack, options);\n  let renderedCallsite = '';\n  const relativeTestPath = testPath\n    ? slash(path.relative(config.rootDir, testPath))\n    : null;\n\n  if (!options.noStackTrace && !options.noCodeFrame) {\n    const topFrame = getTopFrame(lines);\n    if (topFrame) {\n      const {column, file: filename, line} = topFrame;\n\n      if (line && filename && path.isAbsolute(filename)) {\n        let fileContent;\n        try {\n          // TODO: check & read HasteFS instead of reading the filesystem:\n          // see: https://github.com/jestjs/jest/pull/5405#discussion_r164281696\n          fileContent = fs.readFileSync(filename, 'utf8');\n          renderedCallsite = getRenderedCallsite(fileContent, line, column);\n        } catch {\n          // the file does not exist or is inaccessible, we ignore\n        }\n      }\n    }\n  }\n\n  const stacktrace = lines\n    .filter(Boolean)\n    .map(\n      line =>\n        STACK_INDENT + formatPath(trimPaths(line), config, relativeTestPath),\n    )\n    .join('\\n');\n\n  return renderedCallsite\n    ? `${renderedCallsite}\\n${stacktrace}`\n    : `\\n${stacktrace}`;\n}\n\ntype FailedResults = Array<{\n  /** Stringified version of the error */\n  content: string;\n  /** Details related to the failure */\n  failureDetails: unknown;\n  /** Execution result */\n  result: TestResult.AssertionResult;\n}>;\n\nfunction isErrorOrStackWithCause(\n  errorOrStack: Error | string,\n): errorOrStack is Error & {cause: Error | string} {\n  return (\n    typeof errorOrStack !== 'string' &&\n    'cause' in errorOrStack &&\n    (typeof errorOrStack.cause === 'string' ||\n      types.isNativeError(errorOrStack.cause) ||\n      errorOrStack.cause instanceof Error)\n  );\n}\n\nfunction formatErrorStack(\n  errorOrStack: Error | string,\n  config: StackTraceConfig,\n  options: StackTraceOptions,\n  testPath?: string,\n): string {\n  // The stack of new Error('message') contains both the message and the stack,\n  // thus we need to sanitize and clean it for proper display using separateMessageFromStack.\n  const sourceStack =\n    typeof errorOrStack === 'string' ? errorOrStack : errorOrStack.stack || '';\n  let {message, stack} = separateMessageFromStack(sourceStack);\n  stack = options.noStackTrace\n    ? ''\n    : `${STACK_TRACE_COLOR(\n        formatStackTrace(stack, config, options, testPath),\n      )}\\n`;\n\n  message = checkForCommonEnvironmentErrors(message);\n  message = indentAllLines(message);\n\n  let cause = '';\n  if (isErrorOrStackWithCause(errorOrStack)) {\n    const nestedCause = formatErrorStack(\n      errorOrStack.cause,\n      config,\n      options,\n      testPath,\n    );\n    cause = `\\n${MESSAGE_INDENT}Cause:\\n${nestedCause}`;\n  }\n\n  return `${message}\\n${stack}${cause}`;\n}\n\nfunction failureDetailsToErrorOrStack(\n  failureDetails: unknown,\n  content: string,\n): Error | string {\n  if (!failureDetails) {\n    return content;\n  }\n  if (types.isNativeError(failureDetails) || failureDetails instanceof Error) {\n    return failureDetails; // receiving raw errors for jest-circus\n  }\n  if (\n    typeof failureDetails === 'object' &&\n    'error' in failureDetails &&\n    (types.isNativeError(failureDetails.error) ||\n      failureDetails.error instanceof Error)\n  ) {\n    return failureDetails.error; // receiving instances of FailedAssertion for jest-jasmine\n  }\n  return content;\n}\n\nexport const formatResultsErrors = (\n  testResults: Array<TestResult.AssertionResult>,\n  config: StackTraceConfig,\n  options: StackTraceOptions,\n  testPath?: string,\n): string | null => {\n  const failedResults: FailedResults = testResults.reduce<FailedResults>(\n    (errors, result) => {\n      for (const [index, item] of result.failureMessages.entries()) {\n        errors.push({\n          content: item,\n          failureDetails: result.failureDetails[index],\n          result,\n        });\n      }\n      return errors;\n    },\n    [],\n  );\n\n  if (failedResults.length === 0) {\n    return null;\n  }\n\n  return failedResults\n    .map(({result, content, failureDetails}) => {\n      const rootErrorOrStack = failureDetailsToErrorOrStack(\n        failureDetails,\n        content,\n      );\n\n      const title = `${chalk.bold.red(\n        TITLE_INDENT +\n          TITLE_BULLET +\n          result.ancestorTitles.join(ANCESTRY_SEPARATOR) +\n          (result.ancestorTitles.length > 0 ? ANCESTRY_SEPARATOR : '') +\n          result.title,\n      )}\\n`;\n\n      return `${title}\\n${formatErrorStack(\n        rootErrorOrStack,\n        config,\n        options,\n        testPath,\n      )}`;\n    })\n    .join('\\n');\n};\n\nconst errorRegexp = /^Error:?\\s*$/;\n\nconst removeBlankErrorLine = (str: string) =>\n  str\n    .split('\\n')\n    // Lines saying just `Error:` are useless\n    .filter(line => !errorRegexp.test(line))\n    .join('\\n')\n    .trimEnd();\n\n// jasmine and worker farm sometimes don't give us access to the actual\n// Error object, so we have to regexp out the message from the stack string\n// to format it.\nexport const separateMessageFromStack = (\n  content: string,\n): {message: string; stack: string} => {\n  if (!content) {\n    return {message: '', stack: ''};\n  }\n\n  // All lines up to what looks like a stack -- or if nothing looks like a stack\n  // (maybe it's a code frame instead), just the first non-empty line.\n  // If the error is a plain \"Error:\" instead of a SyntaxError or TypeError we\n  // remove the prefix from the message because it is generally not useful.\n  const messageMatch = content.match(\n    /^(?:Error: )?([\\S\\s]*?(?=\\n\\s*at\\s.*:\\d*:\\d*)|\\s*.*)([\\S\\s]*)$/,\n  );\n  if (!messageMatch) {\n    // For typescript\n    throw new Error('If you hit this error, the regex above is buggy.');\n  }\n  const message = removeBlankErrorLine(messageMatch[1]);\n  const stack = removeBlankErrorLine(messageMatch[2]);\n  return {message, stack};\n};\n",
  "packages/jest-message-util/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config, TestResult } from '@jest/types';\nimport type { Frame } from './types';\nexport type { Frame } from './types';\nexport type StackTraceConfig = Pick<Config.ProjectConfig, 'rootDir' | 'testMatch'>;\nexport type StackTraceOptions = {\n    noStackTrace: boolean;\n    noCodeFrame?: boolean;\n};\nexport declare const indentAllLines: (lines: string) => string;\nexport declare const formatExecError: (error: Error | TestResult.SerializableError | string | number | undefined, config: StackTraceConfig, options: StackTraceOptions, testPath?: string, reuseMessage?: boolean, noTitle?: boolean) => string;\nexport declare const formatPath: (line: string, config: StackTraceConfig, relativeTestPath?: string | null) => string;\nexport declare function getStackTraceLines(stack: string, options?: StackTraceOptions): Array<string>;\nexport declare function getTopFrame(lines: Array<string>): Frame | null;\nexport declare function formatStackTrace(stack: string, config: StackTraceConfig, options: StackTraceOptions, testPath?: string): string;\nexport declare const formatResultsErrors: (testResults: Array<TestResult.AssertionResult>, config: StackTraceConfig, options: StackTraceOptions, testPath?: string) => string | null;\nexport declare const separateMessageFromStack: (content: string) => {\n    message: string;\n    stack: string;\n};\n",
  "packages/jest-message-util/src/__tests__/messages.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {readFileSync} from 'graceful-fs';\nimport slash from 'slash';\nimport tempy from 'tempy';\nimport {\n  formatExecError,\n  formatResultsErrors,\n  formatStackTrace,\n  getTopFrame,\n} from '..';\n\nconst rootDir = tempy.directory();\n\njest.mock('graceful-fs', () => ({\n  ...jest.requireActual<typeof import('fs')>('fs'),\n  readFileSync: jest.fn(),\n}));\n\nconst unixStackTrace =\n  '  ' +\n  `at stack (../jest-jasmine2/build/jasmine-2.4.1.js:1580:17)\n  at Object.addResult (../jest-jasmine2/build/jasmine-2.4.1.js:1550:14)\n  at jasmine.addResult (../jest-jasmine2/build/index.js:82:44)\n  at Spec.Env.factory (../jest-jasmine2/build/jasmine-2.4.1.js:641:18)\n  at Spec.addResult (../jest-jasmine2/build/jasmine-2.4.1.js:333:34)\n  at Expectation.addResult (../jest-jasmine2/build/jasmine-2.4.1.js:591:21)\n  at Expectation.toBe (../jest-jasmine2/build/jasmine-2.4.1.js:1504:12)\n  at Object.it (build/__tests__/messages-test.js:45:41)\n  at Object.<anonymous> (../jest-jasmine2/build/jasmine-pit.js:35:32)\n  at attemptAsync (../jest-jasmine2/build/jasmine-2.4.1.js:1919:24)`;\nconst unixError = new Error(unixStackTrace.replace(/\\n\\s*at \\s*/m, ''));\nunixError.stack = unixStackTrace;\n\nconst assertionStack =\n  '  ' +\n  `\n    Expected value to be of type:\n      \"number\"\n    Received:\n      \"\"\n    type:\n      \"string\"\n\n      at Object.it (__tests__/test.js:8:14)\n      at Object.asyncFn (node_modules/jest-jasmine2/build/jasmine_async.js:124:345)\n      at resolve (node_modules/jest-jasmine2/build/queue_runner.js:46:12)\n          at Promise (<anonymous>)\n      at mapper (node_modules/jest-jasmine2/build/queue_runner.js:34:499)\n      at promise.then (node_modules/jest-jasmine2/build/queue_runner.js:74:39)\n          at <anonymous>\n      at process._tickCallback (internal/process/next_tick.js:188:7)\n      at internal/process/next_tick.js:188:7\n`;\nconst assertionError = new Error(assertionStack.replace(/\\n\\s*at \\s*/m, ''));\nassertionError.stack = assertionStack;\n\nconst vendorStack =\n  '  ' +\n  `\n    Expected value to be of type:\n      \"number\"\n    Received:\n      \"\"\n    type:\n      \"string\"\n\n      at Object.it (__tests__/vendor/cool_test.js:6:666)\n      at Object.asyncFn (__tests__/vendor/sulu/node_modules/sulu-content-bundle/best_component.js:1:5)\n`;\n\nconst babelStack =\n  '  ' +\n  `\n    packages/react/src/forwardRef.js: Unexpected token, expected , (20:10)\n    \\u001B[0m \\u001B[90m 18 | \\u001B[39m        \\u001B[36mfalse\\u001B[39m\\u001B[33m,\\u001B[39m\n     \\u001B[90m 19 | \\u001B[39m        \\u001B[32m'forwardRef requires a render function but received a \\`memo\\` '\\u001B[39m\n    \\u001B[31m\\u001B[1m>\\u001B[22m\\u001B[39m\\u001B[90m 20 | \\u001B[39m          \\u001B[32m'component. Instead of forwardRef(memo(...)), use '\\u001B[39m \\u001B[33m+\\u001B[39m\n     \\u001B[90m    | \\u001B[39m          \\u001B[31m\\u001B[1m^\\u001B[22m\\u001B[39m\n     \\u001B[90m 21 | \\u001B[39m          \\u001B[32m'memo(forwardRef(...)).'\\u001B[39m\\u001B[33m,\\u001B[39m\n     \\u001B[90m 22 | \\u001B[39m      )\\u001B[33m;\\u001B[39m\n     \\u001B[90m 23 | \\u001B[39m    } \\u001B[36melse\\u001B[39m \\u001B[36mif\\u001B[39m (\\u001B[36mtypeof\\u001B[39m render \\u001B[33m!==\\u001B[39m \\u001B[32m'function'\\u001B[39m) {\\u001B[0m\n`;\nconst babelError = new Error(babelStack.replace(/\\n\\s*at \\s*/m, ''));\nbabelError.stack = babelStack;\n\nfunction buildErrorWithCause(message: string, opts: {cause: unknown}): Error {\n  const error = new Error(message, opts);\n  if (opts.cause !== error.cause) {\n    // Error with cause not supported in legacy versions of node, we just polyfill it\n    Object.assign(error, opts);\n  }\n  return error;\n}\n\nconst errorWithCauseNestedNested = new Error('boom');\nerrorWithCauseNestedNested.stack = `Error: boom\n    at h (cause.test.js:2:9)\n    at h (cause.test.js:6:5)\n    at g (cause.test.js:13:5)\n    at Object.f (cause.test.js:20:5)\n    at Promise.then.completed (node_modules/jest-circus/build/utils.js:293:28)\n    at new Promise (<anonymous>)\n    at callAsyncCircusFn (node_modules/jest-circus/build/utils.js:226:10)\n    at _callCircusTest (node_modules/jest-circus/build/run.js:248:40)\n    at _runTest (node_modules/jest-circus/build/run.js:184:3)\n    at _runTestsForDescribeBlock (node_modules/jest-circus/build/run.js:86:9)\n    at run (node_modules/jest-circus/build/run.js:26:3)\n    at runAndTransformResultsToJestFormat (node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapterInit.js:120:21)\n    at jestAdapter (node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapter.js:74:19)\n    at runTestInternal (node_modules/jest-runner/build/runTest.js:281:16)\n    at runTest (node_modules/jest-runner/build/runTest.js:341:7)`;\n\nconst errorWithCauseNested = buildErrorWithCause('intercepted by g', {\n  cause: errorWithCauseNestedNested,\n});\nerrorWithCauseNested.stack = `Error: intercepted by g\n    at g (cause.test.js:8:11)\n    at g (cause.test.js:13:5)\n    at Object.f (cause.test.js:20:5)\n    at Promise.then.completed (node_modules/jest-circus/build/utils.js:293:28)\n    at new Promise (<anonymous>)\n    at callAsyncCircusFn (node_modules/jest-circus/build/utils.js:226:10)\n    at _callCircusTest (node_modules/jest-circus/build/run.js:248:40)\n    at _runTest (node_modules/jest-circus/build/run.js:184:3)\n    at _runTestsForDescribeBlock (node_modules/jest-circus/build/run.js:86:9)\n    at run (node_modules/jest-circus/build/run.js:26:3)\n    at runAndTransformResultsToJestFormat (node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapterInit.js:120:21)\n    at jestAdapter (node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapter.js:74:19)\n    at runTestInternal (node_modules/jest-runner/build/runTest.js:281:16)\n    at runTest (node_modules/jest-runner/build/runTest.js:341:7)`;\n\nconst errorWithCause = buildErrorWithCause('intercepted by f', {\n  cause: errorWithCauseNested,\n});\nerrorWithCause.stack = `Error: intercepted by f\n    at f (cause.test.js:15:11)\n    at Object.f (cause.test.js:20:5)\n    at Promise.then.completed (node_modules/jest-circus/build/utils.js:293:28)\n    at new Promise (<anonymous>)\n    at callAsyncCircusFn (node_modules/jest-circus/build/utils.js:226:10)\n    at _callCircusTest (node_modules/jest-circus/build/run.js:248:40)\n    at _runTest (node_modules/jest-circus/build/run.js:184:3)\n    at _runTestsForDescribeBlock (node_modules/jest-circus/build/run.js:86:9)\n    at run (node_modules/jest-circus/build/run.js:26:3)\n    at runAndTransformResultsToJestFormat (node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapterInit.js:120:21)\n    at jestAdapter (node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapter.js:74:19)\n    at runTestInternal (node_modules/jest-runner/build/runTest.js:281:16)\n    at runTest (node_modules/jest-runner/build/runTest.js:341:7)`;\n\nconst errorWithStringCause = buildErrorWithCause('boom', {\n  cause: 'string cause',\n});\nerrorWithStringCause.stack = `Error: boom\n    at f (cause.test.js:15:11)\n    at Object.f (cause.test.js:20:5)\n    at Promise.then.completed (node_modules/jest-circus/build/utils.js:293:28)\n    at new Promise (<anonymous>)\n    at callAsyncCircusFn (node_modules/jest-circus/build/utils.js:226:10)\n    at _callCircusTest (node_modules/jest-circus/build/run.js:248:40)\n    at _runTest (node_modules/jest-circus/build/run.js:184:3)\n    at _runTestsForDescribeBlock (node_modules/jest-circus/build/run.js:86:9)\n    at run (node_modules/jest-circus/build/run.js:26:3)\n    at runAndTransformResultsToJestFormat (node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapterInit.js:120:21)\n    at jestAdapter (node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapter.js:74:19)\n    at runTestInternal (node_modules/jest-runner/build/runTest.js:281:16)\n    at runTest (node_modules/jest-runner/build/runTest.js:341:7)`;\n\nbeforeEach(() => {\n  jest.clearAllMocks();\n});\n\nit('should exclude jasmine from stack trace for Unix paths.', () => {\n  const messages = formatResultsErrors(\n    [\n      {\n        ancestorTitles: [],\n        duration: undefined,\n        failureDetails: [unixError],\n        failureMessages: [unixStackTrace],\n        fullName: 'full name',\n        invocations: undefined,\n        location: null,\n        numPassingAsserts: 0,\n        retryReasons: undefined,\n        status: 'failed',\n        title: 'Unix test',\n      },\n    ],\n    {\n      rootDir: '',\n      testMatch: [],\n    },\n    {\n      noStackTrace: false,\n    },\n  );\n\n  expect(messages).toMatchSnapshot();\n});\n\nit('.formatExecError()', () => {\n  const message = formatExecError(\n    {\n      message: 'Whoops!',\n      stack: '',\n    },\n    {\n      rootDir: '',\n      testMatch: [],\n    },\n    {\n      noStackTrace: false,\n    },\n    'path_test',\n  );\n\n  expect(message).toMatchSnapshot();\n});\n\nit('formatStackTrace should strip node internals', () => {\n  const messages = formatResultsErrors(\n    [\n      {\n        ancestorTitles: [],\n        duration: undefined,\n        failureDetails: [assertionError],\n        failureMessages: [assertionStack],\n        fullName: 'full name',\n        invocations: undefined,\n        location: null,\n        numPassingAsserts: 0,\n        retryReasons: undefined,\n        status: 'failed',\n        title: 'Unix test',\n      },\n    ],\n    {\n      rootDir: '',\n      testMatch: [],\n    },\n    {\n      noStackTrace: false,\n    },\n  );\n\n  expect(messages).toMatchSnapshot();\n});\n\nit('should not exclude vendor from stack trace', () => {\n  const messages = formatResultsErrors(\n    [\n      {\n        ancestorTitles: [],\n        duration: undefined,\n        failureDetails: [],\n        failureMessages: [vendorStack],\n        fullName: 'full name',\n        invocations: undefined,\n        location: null,\n        numPassingAsserts: 0,\n        retryReasons: undefined,\n        status: 'failed',\n        title: 'Vendor test',\n      },\n    ],\n    {\n      rootDir: '',\n      testMatch: [],\n    },\n    {\n      noStackTrace: false,\n    },\n  );\n\n  expect(messages).toMatchSnapshot();\n});\n\nit('retains message in babel code frame error', () => {\n  const messages = formatResultsErrors(\n    [\n      {\n        ancestorTitles: [],\n        duration: undefined,\n        failureDetails: [babelError],\n        failureMessages: [babelStack],\n        fullName: 'full name',\n        invocations: undefined,\n        location: null,\n        numPassingAsserts: 0,\n        retryReasons: undefined,\n        status: 'failed',\n        title: 'Babel test',\n      },\n    ],\n    {\n      rootDir: '',\n      testMatch: [],\n    },\n    {\n      noStackTrace: false,\n    },\n  );\n\n  expect(messages).toMatchSnapshot();\n});\n\nit('formatStackTrace should properly handle deeply nested causes', () => {\n  const messages = formatResultsErrors(\n    [\n      {\n        ancestorTitles: [],\n        duration: undefined,\n        failureDetails: [errorWithCause],\n        failureMessages: [errorWithCause.stack || ''],\n        fullName: 'full name',\n        invocations: undefined,\n        location: null,\n        numPassingAsserts: 0,\n        retryReasons: undefined,\n        status: 'failed',\n        title: 'Error with cause test',\n      },\n    ],\n    {\n      rootDir: '',\n      testMatch: [],\n    },\n    {\n      noStackTrace: false,\n    },\n  );\n\n  expect(messages).toMatchSnapshot();\n});\n\nit('formatStackTrace should properly handle string causes', () => {\n  const messages = formatResultsErrors(\n    [\n      {\n        ancestorTitles: [],\n        duration: undefined,\n        failureDetails: [errorWithStringCause],\n        failureMessages: [errorWithStringCause.stack || ''],\n        fullName: 'full name',\n        invocations: undefined,\n        location: null,\n        numPassingAsserts: 0,\n        retryReasons: undefined,\n        status: 'failed',\n        title: 'Error with string cause test',\n      },\n    ],\n    {\n      rootDir: '',\n      testMatch: [],\n    },\n    {\n      noStackTrace: false,\n    },\n  );\n\n  expect(messages).toMatchSnapshot();\n});\n\nit('codeframe', () => {\n  jest\n    .mocked(readFileSync)\n    .mockImplementationOnce(() => 'throw new Error(\"Whoops!\");');\n\n  const message = formatExecError(\n    {\n      message: 'Whoops!',\n      stack: `\n    at Object.<anonymous> (${slash(rootDir)}/file.js:1:7)\n    at Module._compile (internal/modules/cjs/loader.js:1158:30)\n    at Object.Module._extensions..js (internal/modules/cjs/loader.js:1178:10)\n    at Module.load (internal/modules/cjs/loader.js:1002:32)\n    at Function.Module._load (internal/modules/cjs/loader.js:901:14)\n    at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:74:12)\n`,\n    },\n    {\n      rootDir,\n      testMatch: [],\n    },\n    {\n      noCodeFrame: false,\n      noStackTrace: false,\n    },\n    'path_test',\n  );\n\n  expect(message).toMatchSnapshot();\n});\n\nit('no codeframe', () => {\n  jest\n    .mocked(readFileSync)\n    .mockImplementationOnce(() => 'throw new Error(\"Whoops!\");');\n\n  const message = formatExecError(\n    {\n      message: 'Whoops!',\n      stack: `\n    at Object.<anonymous> (${slash(rootDir)}/file.js:1:7)\n    at Module._compile (internal/modules/cjs/loader.js:1158:30)\n    at Object.Module._extensions..js (internal/modules/cjs/loader.js:1178:10)\n    at Module.load (internal/modules/cjs/loader.js:1002:32)\n    at Function.Module._load (internal/modules/cjs/loader.js:901:14)\n    at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:74:12)\n`,\n    },\n    {\n      rootDir,\n      testMatch: [],\n    },\n    {\n      noCodeFrame: true,\n      noStackTrace: false,\n    },\n    'path_test',\n  );\n\n  expect(message).toMatchSnapshot();\n});\n\nit('no stack', () => {\n  jest\n    .mocked(readFileSync)\n    .mockImplementationOnce(() => 'throw new Error(\"Whoops!\");');\n\n  const message = formatExecError(\n    {\n      message: 'Whoops!',\n      stack: `\n    at Object.<anonymous> (${slash(rootDir)}/file.js:1:7)\n    at Module._compile (internal/modules/cjs/loader.js:1158:30)\n    at Object.Module._extensions..js (internal/modules/cjs/loader.js:1178:10)\n    at Module.load (internal/modules/cjs/loader.js:1002:32)\n    at Function.Module._load (internal/modules/cjs/loader.js:901:14)\n    at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:74:12)\n`,\n    },\n    {\n      rootDir,\n      testMatch: [],\n    },\n    {\n      // if no stack, no codeframe is implied\n      noCodeFrame: true,\n      noStackTrace: true,\n    },\n    'path_test',\n  );\n\n  expect(message).toMatchSnapshot();\n});\n\ndescribe('formatStackTrace', () => {\n  it('prints code frame and stacktrace', () => {\n    jest\n      .mocked(readFileSync)\n      .mockImplementationOnce(() => 'throw new Error(\"Whoops!\");');\n    const message = formatStackTrace(\n      `\n      at Object.<anonymous> (${slash(rootDir)}/file.js:1:7)\n      at Module._compile (internal/modules/cjs/loader.js:1158:30)\n      at Object.Module._extensions..js (internal/modules/cjs/loader.js:1178:10)\n      at Module.load (internal/modules/cjs/loader.js:1002:32)\n      at Function.Module._load (internal/modules/cjs/loader.js:901:14)\n      at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:74:12)\n  `,\n      {\n        rootDir,\n        testMatch: [],\n      },\n      {\n        noCodeFrame: false,\n        noStackTrace: false,\n      },\n      'path_test',\n    );\n\n    expect(message).toMatchSnapshot();\n  });\n\n  it('does not print code frame when noCodeFrame = true', () => {\n    jest\n      .mocked(readFileSync)\n      .mockImplementationOnce(() => 'throw new Error(\"Whoops!\");');\n    const message = formatStackTrace(\n      `\n      at Object.<anonymous> (${slash(rootDir)}/file.js:1:7)\n      at Module._compile (internal/modules/cjs/loader.js:1158:30)\n      at Object.Module._extensions..js (internal/modules/cjs/loader.js:1178:10)\n      at Module.load (internal/modules/cjs/loader.js:1002:32)\n      at Function.Module._load (internal/modules/cjs/loader.js:901:14)\n      at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:74:12)\n  `,\n      {\n        rootDir,\n        testMatch: [],\n      },\n      {\n        noCodeFrame: true,\n        noStackTrace: false,\n      },\n      'path_test',\n    );\n\n    expect(message).toMatchSnapshot();\n  });\n\n  it('does not print codeframe when noStackTrace = true', () => {\n    jest\n      .mocked(readFileSync)\n      .mockImplementationOnce(() => 'throw new Error(\"Whoops!\");');\n    const message = formatStackTrace(\n      `\n      at Object.<anonymous> (${slash(rootDir)}/file.js:1:7)\n      at Module._compile (internal/modules/cjs/loader.js:1158:30)\n      at Object.Module._extensions..js (internal/modules/cjs/loader.js:1178:10)\n      at Module.load (internal/modules/cjs/loader.js:1002:32)\n      at Function.Module._load (internal/modules/cjs/loader.js:901:14)\n      at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:74:12)\n  `,\n      {\n        rootDir,\n        testMatch: [],\n      },\n      {\n        noStackTrace: true,\n      },\n      'path_test',\n    );\n\n    expect(message).toMatchSnapshot();\n  });\n});\n\nit('getTopFrame should return a path for mjs files', () => {\n  let stack: Array<string>;\n  let expectedFile: string;\n  if (process.platform === 'win32') {\n    stack = ['  at stack (file:///C:/Users/user/project/inline.mjs:1:1)'];\n    expectedFile = 'C:/Users/user/project/inline.mjs';\n  } else {\n    stack = ['  at stack (file:///Users/user/project/inline.mjs:1:1)'];\n    expectedFile = '/Users/user/project/inline.mjs';\n  }\n  const frame = getTopFrame(stack);\n\n  expect(frame!.file).toBe(expectedFile);\n});\n\nit('should return the error cause if there is one', () => {\n  const error = new Error('Test exception');\n  // TODO pass `cause` to the `Error` constructor when lowest supported Node version is 16.9.0 and above\n  // See https://github.com/nodejs/node/blob/main/doc/changelogs/CHANGELOG_V16.md#error-cause\n  error.cause = new Error('Cause Error');\n  const message = formatExecError(\n    error,\n    {\n      rootDir: '',\n      testMatch: [],\n    },\n    {\n      noStackTrace: false,\n    },\n  );\n  expect(message).toMatchSnapshot();\n});\n\nit('should return the inner errors of an AggregateError', () => {\n  // See https://github.com/nodejs/node/blob/main/doc/changelogs/CHANGELOG_V15.md#v8-86---35415\n  const aggError = new AggregateError([new Error('Err 1'), new Error('Err 2')]);\n  const message = formatExecError(\n    aggError,\n    {\n      rootDir: '',\n      testMatch: [],\n    },\n    {\n      noStackTrace: false,\n    },\n  );\n  expect(message).toMatchSnapshot();\n});\n",
  "packages/jest-message-util/src/__tests__/messages.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport {};\n",
  "packages/jest-matcher-utils/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk, {type Chalk} from 'chalk';\nimport {getType, isPrimitive} from '@jest/get-type';\nimport {\n  DIFF_DELETE,\n  DIFF_EQUAL,\n  DIFF_INSERT,\n  type Diff,\n  type DiffOptions as ImportDiffOptions,\n  diff as diffDefault,\n  diffStringsRaw,\n  diffStringsUnified,\n} from 'jest-diff';\nimport {\n  format as prettyFormat,\n  plugins as prettyFormatPlugins,\n} from 'pretty-format';\nimport Replaceable from './Replaceable';\nimport deepCyclicCopyReplaceable, {\n  SERIALIZABLE_PROPERTIES,\n} from './deepCyclicCopyReplaceable';\n\nexport {SERIALIZABLE_PROPERTIES};\n\nconst {\n  AsymmetricMatcher,\n  DOMCollection,\n  DOMElement,\n  Immutable,\n  ReactElement,\n  ReactTestComponent,\n} = prettyFormatPlugins;\n\nconst PLUGINS = [\n  ReactTestComponent,\n  ReactElement,\n  DOMElement,\n  DOMCollection,\n  Immutable,\n  AsymmetricMatcher,\n];\n\ntype MatcherHintColor = (arg: string) => string; // subset of Chalk type\n\nexport type MatcherHintOptions = {\n  comment?: string;\n  expectedColor?: MatcherHintColor;\n  isDirectExpectCall?: boolean;\n  isNot?: boolean;\n  promise?: string;\n  receivedColor?: MatcherHintColor;\n  secondArgument?: string;\n  secondArgumentColor?: MatcherHintColor;\n};\n\nexport type DiffOptions = ImportDiffOptions;\n\nexport const EXPECTED_COLOR: Chalk = chalk.green;\nexport const RECEIVED_COLOR: Chalk = chalk.red;\nexport const INVERTED_COLOR: Chalk = chalk.inverse;\nexport const BOLD_WEIGHT: Chalk = chalk.bold;\nexport const DIM_COLOR: Chalk = chalk.dim;\n\nconst MULTILINE_REGEXP = /\\n/;\nconst SPACE_SYMBOL = '\\u{00B7}'; // middle dot\n\nconst NUMBERS = [\n  'zero',\n  'one',\n  'two',\n  'three',\n  'four',\n  'five',\n  'six',\n  'seven',\n  'eight',\n  'nine',\n  'ten',\n  'eleven',\n  'twelve',\n  'thirteen',\n];\n\nexport const SUGGEST_TO_CONTAIN_EQUAL = chalk.dim(\n  'Looks like you wanted to test for object/array equality with the stricter `toContain` matcher. You probably need to use `toContainEqual` instead.',\n);\n\nexport const stringify = (\n  object: unknown,\n  maxDepth = 10,\n  maxWidth = 10,\n): string => {\n  const MAX_LENGTH = 10_000;\n  let result;\n\n  try {\n    result = prettyFormat(object, {\n      maxDepth,\n      maxWidth,\n      min: true,\n      plugins: PLUGINS,\n    });\n  } catch {\n    result = prettyFormat(object, {\n      callToJSON: false,\n      maxDepth,\n      maxWidth,\n      min: true,\n      plugins: PLUGINS,\n    });\n  }\n\n  if (result.length >= MAX_LENGTH && maxDepth > 1) {\n    return stringify(object, Math.floor(maxDepth / 2), maxWidth);\n  } else if (result.length >= MAX_LENGTH && maxWidth > 1) {\n    return stringify(object, maxDepth, Math.floor(maxWidth / 2));\n  } else {\n    return result;\n  }\n};\n\nexport const highlightTrailingWhitespace = (text: string): string =>\n  text.replaceAll(/\\s+$/gm, chalk.inverse('$&'));\n\n// Instead of inverse highlight which now implies a change,\n// replace common spaces with middle dot at the end of any line.\nconst replaceTrailingSpaces = (text: string): string =>\n  text.replaceAll(/\\s+$/gm, spaces => SPACE_SYMBOL.repeat(spaces.length));\n\nexport const printReceived = (object: unknown): string =>\n  RECEIVED_COLOR(replaceTrailingSpaces(stringify(object)));\nexport const printExpected = (value: unknown): string =>\n  EXPECTED_COLOR(replaceTrailingSpaces(stringify(value)));\n\nexport function printWithType<T>(\n  name: string,\n  value: T,\n  print: (value: T) => string,\n): string {\n  const type = getType(value);\n  const hasType =\n    type !== 'null' && type !== 'undefined'\n      ? `${name} has type:  ${type}\\n`\n      : '';\n  const hasValue = `${name} has value: ${print(value)}`;\n  return hasType + hasValue;\n}\n\nexport const ensureNoExpected = (\n  expected: unknown,\n  matcherName: string,\n  options?: MatcherHintOptions,\n): void => {\n  if (expected !== undefined) {\n    // Prepend maybe not only for backward compatibility.\n    const matcherString = (options ? '' : '[.not]') + matcherName;\n    throw new Error(\n      matcherErrorMessage(\n        matcherHint(matcherString, undefined, '', options),\n        // Because expected is omitted in hint above,\n        // expected is black instead of green in message below.\n        'this matcher must not have an expected argument',\n        printWithType('Expected', expected, printExpected),\n      ),\n    );\n  }\n};\n\n/**\n * Ensures that `actual` is of type `number | bigint`\n */\nexport const ensureActualIsNumber = (\n  actual: unknown,\n  matcherName: string,\n  options?: MatcherHintOptions,\n): void => {\n  if (typeof actual !== 'number' && typeof actual !== 'bigint') {\n    // Prepend maybe not only for backward compatibility.\n    const matcherString = (options ? '' : '[.not]') + matcherName;\n    throw new Error(\n      matcherErrorMessage(\n        matcherHint(matcherString, undefined, undefined, options),\n        `${RECEIVED_COLOR('received')} value must be a number or bigint`,\n        printWithType('Received', actual, printReceived),\n      ),\n    );\n  }\n};\n\n/**\n * Ensures that `expected` is of type `number | bigint`\n */\nexport const ensureExpectedIsNumber = (\n  expected: unknown,\n  matcherName: string,\n  options?: MatcherHintOptions,\n): void => {\n  if (typeof expected !== 'number' && typeof expected !== 'bigint') {\n    // Prepend maybe not only for backward compatibility.\n    const matcherString = (options ? '' : '[.not]') + matcherName;\n    throw new Error(\n      matcherErrorMessage(\n        matcherHint(matcherString, undefined, undefined, options),\n        `${EXPECTED_COLOR('expected')} value must be a number or bigint`,\n        printWithType('Expected', expected, printExpected),\n      ),\n    );\n  }\n};\n\n/**\n * Ensures that `actual` & `expected` are of type `number | bigint`\n */\nexport const ensureNumbers = (\n  actual: unknown,\n  expected: unknown,\n  matcherName: string,\n  options?: MatcherHintOptions,\n): void => {\n  ensureActualIsNumber(actual, matcherName, options);\n  ensureExpectedIsNumber(expected, matcherName, options);\n};\n\nexport const ensureExpectedIsNonNegativeInteger = (\n  expected: unknown,\n  matcherName: string,\n  options?: MatcherHintOptions,\n): void => {\n  if (\n    typeof expected !== 'number' ||\n    !Number.isSafeInteger(expected) ||\n    expected < 0\n  ) {\n    // Prepend maybe not only for backward compatibility.\n    const matcherString = (options ? '' : '[.not]') + matcherName;\n    throw new Error(\n      matcherErrorMessage(\n        matcherHint(matcherString, undefined, undefined, options),\n        `${EXPECTED_COLOR('expected')} value must be a non-negative integer`,\n        printWithType('Expected', expected, printExpected),\n      ),\n    );\n  }\n};\n\n// Given array of diffs, return concatenated string:\n// * include common substrings\n// * exclude change substrings which have opposite op\n// * include change substrings which have argument op\n//   with inverse highlight only if there is a common substring\nconst getCommonAndChangedSubstrings = (\n  diffs: Array<Diff>,\n  op: number,\n  hasCommonDiff: boolean,\n): string =>\n  diffs.reduce(\n    (reduced: string, diff: Diff): string =>\n      reduced +\n      (diff[0] === DIFF_EQUAL\n        ? diff[1]\n        : diff[0] === op\n          ? hasCommonDiff\n            ? INVERTED_COLOR(diff[1])\n            : diff[1]\n          : ''),\n    '',\n  );\n\nconst isLineDiffable = (expected: unknown, received: unknown): boolean => {\n  const expectedType = getType(expected);\n  const receivedType = getType(received);\n\n  if (expectedType !== receivedType) {\n    return false;\n  }\n\n  if (isPrimitive(expected)) {\n    // Print generic line diff for strings only:\n    // * if neither string is empty\n    // * if either string has more than one line\n    return (\n      typeof expected === 'string' &&\n      typeof received === 'string' &&\n      expected.length > 0 &&\n      received.length > 0 &&\n      (MULTILINE_REGEXP.test(expected) || MULTILINE_REGEXP.test(received))\n    );\n  }\n\n  if (\n    expectedType === 'date' ||\n    expectedType === 'function' ||\n    expectedType === 'regexp'\n  ) {\n    return false;\n  }\n\n  if (expected instanceof Error && received instanceof Error) {\n    return false;\n  }\n\n  if (\n    receivedType === 'object' &&\n    typeof (received as any).asymmetricMatch === 'function'\n  ) {\n    return false;\n  }\n\n  return true;\n};\n\nconst MAX_DIFF_STRING_LENGTH = 20_000;\n\nexport const printDiffOrStringify = (\n  expected: unknown,\n  received: unknown,\n  expectedLabel: string,\n  receivedLabel: string,\n  expand: boolean, // CLI options: true if `--expand` or false if `--no-expand`\n): string => {\n  if (\n    typeof expected === 'string' &&\n    typeof received === 'string' &&\n    expected.length > 0 &&\n    received.length > 0 &&\n    expected.length <= MAX_DIFF_STRING_LENGTH &&\n    received.length <= MAX_DIFF_STRING_LENGTH &&\n    expected !== received\n  ) {\n    if (expected.includes('\\n') || received.includes('\\n')) {\n      return diffStringsUnified(expected, received, {\n        aAnnotation: expectedLabel,\n        bAnnotation: receivedLabel,\n        changeLineTrailingSpaceColor: chalk.bgYellow,\n        commonLineTrailingSpaceColor: chalk.bgYellow,\n        emptyFirstOrLastLinePlaceholder: '↵', // U+21B5\n        expand,\n        includeChangeCounts: true,\n      });\n    }\n\n    const diffs = diffStringsRaw(expected, received, true);\n    const hasCommonDiff = diffs.some(diff => diff[0] === DIFF_EQUAL);\n\n    const printLabel = getLabelPrinter(expectedLabel, receivedLabel);\n    const expectedLine =\n      printLabel(expectedLabel) +\n      printExpected(\n        getCommonAndChangedSubstrings(diffs, DIFF_DELETE, hasCommonDiff),\n      );\n    const receivedLine =\n      printLabel(receivedLabel) +\n      printReceived(\n        getCommonAndChangedSubstrings(diffs, DIFF_INSERT, hasCommonDiff),\n      );\n\n    return `${expectedLine}\\n${receivedLine}`;\n  }\n\n  if (isLineDiffable(expected, received)) {\n    const {replacedExpected, replacedReceived} =\n      replaceMatchedToAsymmetricMatcher(expected, received, [], []);\n    const difference = diffDefault(replacedExpected, replacedReceived, {\n      aAnnotation: expectedLabel,\n      bAnnotation: receivedLabel,\n      expand,\n      includeChangeCounts: true,\n    });\n\n    if (\n      typeof difference === 'string' &&\n      difference.includes(`- ${expectedLabel}`) &&\n      difference.includes(`+ ${receivedLabel}`)\n    ) {\n      return difference;\n    }\n  }\n\n  const printLabel = getLabelPrinter(expectedLabel, receivedLabel);\n  const expectedLine = printLabel(expectedLabel) + printExpected(expected);\n  const receivedLine =\n    printLabel(receivedLabel) +\n    (stringify(expected) === stringify(received)\n      ? 'serializes to the same string'\n      : printReceived(received));\n\n  return `${expectedLine}\\n${receivedLine}`;\n};\n\n// Sometimes, e.g. when comparing two numbers, the output from jest-diff\n// does not contain more information than the `Expected:` / `Received:` already gives.\n// In those cases, we do not print a diff to make the output shorter and not redundant.\nconst shouldPrintDiff = (actual: unknown, expected: unknown) => {\n  if (typeof actual === 'number' && typeof expected === 'number') {\n    return false;\n  }\n  if (typeof actual === 'bigint' && typeof expected === 'bigint') {\n    return false;\n  }\n  if (typeof actual === 'boolean' && typeof expected === 'boolean') {\n    return false;\n  }\n  return true;\n};\n\nexport function replaceMatchedToAsymmetricMatcher(\n  replacedExpected: unknown,\n  replacedReceived: unknown,\n  expectedCycles: Array<unknown>,\n  receivedCycles: Array<unknown>,\n): {replacedExpected: unknown; replacedReceived: unknown} {\n  return _replaceMatchedToAsymmetricMatcher(\n    deepCyclicCopyReplaceable(replacedExpected),\n    deepCyclicCopyReplaceable(replacedReceived),\n    expectedCycles,\n    receivedCycles,\n  );\n}\n\nfunction _replaceMatchedToAsymmetricMatcher(\n  replacedExpected: unknown,\n  replacedReceived: unknown,\n  expectedCycles: Array<unknown>,\n  receivedCycles: Array<unknown>,\n) {\n  if (!Replaceable.isReplaceable(replacedExpected, replacedReceived)) {\n    return {replacedExpected, replacedReceived};\n  }\n\n  if (\n    expectedCycles.includes(replacedExpected) ||\n    receivedCycles.includes(replacedReceived)\n  ) {\n    return {replacedExpected, replacedReceived};\n  }\n\n  expectedCycles.push(replacedExpected);\n  receivedCycles.push(replacedReceived);\n\n  const expectedReplaceable = new Replaceable(replacedExpected);\n  const receivedReplaceable = new Replaceable(replacedReceived);\n\n  // eslint-disable-next-line unicorn/no-array-for-each\n  expectedReplaceable.forEach((expectedValue: unknown, key: unknown) => {\n    const receivedValue = receivedReplaceable.get(key);\n    if (isAsymmetricMatcher(expectedValue)) {\n      if (expectedValue.asymmetricMatch(receivedValue)) {\n        receivedReplaceable.set(key, expectedValue);\n      }\n    } else if (isAsymmetricMatcher(receivedValue)) {\n      if (receivedValue.asymmetricMatch(expectedValue)) {\n        expectedReplaceable.set(key, receivedValue);\n      }\n    } else if (Replaceable.isReplaceable(expectedValue, receivedValue)) {\n      const replaced = _replaceMatchedToAsymmetricMatcher(\n        expectedValue,\n        receivedValue,\n        expectedCycles,\n        receivedCycles,\n      );\n      expectedReplaceable.set(key, replaced.replacedExpected);\n      receivedReplaceable.set(key, replaced.replacedReceived);\n    }\n  });\n\n  return {\n    replacedExpected: expectedReplaceable.object,\n    replacedReceived: receivedReplaceable.object,\n  };\n}\n\ntype AsymmetricMatcher = {\n  asymmetricMatch: Function;\n};\n\nfunction isAsymmetricMatcher(data: any): data is AsymmetricMatcher {\n  const type = getType(data);\n  return type === 'object' && typeof data.asymmetricMatch === 'function';\n}\n\nexport const diff = (\n  a: unknown,\n  b: unknown,\n  options?: DiffOptions,\n): string | null => (shouldPrintDiff(a, b) ? diffDefault(a, b, options) : null);\n\nexport const pluralize = (word: string, count: number): string =>\n  `${NUMBERS[count] || count} ${word}${count === 1 ? '' : 's'}`;\n\n// To display lines of labeled values as two columns with monospace alignment:\n// given the strings which will describe the values,\n// return function which given each string, returns the label:\n// string, colon, space, and enough padding spaces to align the value.\n\ntype PrintLabel = (string: string) => string;\n\nexport const getLabelPrinter = (...strings: Array<string>): PrintLabel => {\n  const maxLength = strings.reduce(\n    (max, string) => Math.max(string.length, max),\n    0,\n  );\n  return (string: string): string =>\n    `${string}: ${' '.repeat(maxLength - string.length)}`;\n};\n\nexport const matcherErrorMessage = (\n  hint: string, // assertion returned from call to matcherHint\n  generic: string, // condition which correct value must fulfill\n  specific?: string, // incorrect value returned from call to printWithType\n): string =>\n  `${hint}\\n\\n${chalk.bold('Matcher error')}: ${generic}${\n    typeof specific === 'string' ? `\\n\\n${specific}` : ''\n  }`;\n\n// Display assertion for the report when a test fails.\n// New format: rejects/resolves, not, and matcher name have black color\n// Old format: matcher name has dim color\nexport const matcherHint = (\n  matcherName: string,\n  received = 'received',\n  expected = 'expected',\n  options: MatcherHintOptions = {},\n): string => {\n  const {\n    comment = '',\n    expectedColor = EXPECTED_COLOR,\n    isDirectExpectCall = false, // seems redundant with received === ''\n    isNot = false,\n    promise = '',\n    receivedColor = RECEIVED_COLOR,\n    secondArgument = '',\n    secondArgumentColor = EXPECTED_COLOR,\n  } = options;\n  let hint = '';\n  let dimString = 'expect'; // concatenate adjacent dim substrings\n\n  if (!isDirectExpectCall && received !== '') {\n    hint += DIM_COLOR(`${dimString}(`) + receivedColor(received);\n    dimString = ')';\n  }\n\n  if (promise !== '') {\n    hint += DIM_COLOR(`${dimString}.`) + promise;\n    dimString = '';\n  }\n\n  if (isNot) {\n    hint += `${DIM_COLOR(`${dimString}.`)}not`;\n    dimString = '';\n  }\n\n  if (matcherName.includes('.')) {\n    // Old format: for backward compatibility,\n    // especially without promise or isNot options\n    dimString += matcherName;\n  } else {\n    // New format: omit period from matcherName arg\n    hint += DIM_COLOR(`${dimString}.`) + matcherName;\n    dimString = '';\n  }\n\n  if (expected === '') {\n    dimString += '()';\n  } else {\n    hint += DIM_COLOR(`${dimString}(`) + expectedColor(expected);\n    if (secondArgument) {\n      hint += DIM_COLOR(', ') + secondArgumentColor(secondArgument);\n    }\n    dimString = ')';\n  }\n\n  if (comment !== '') {\n    dimString += ` // ${comment}`;\n  }\n\n  if (dimString !== '') {\n    hint += DIM_COLOR(dimString);\n  }\n\n  return hint;\n};\n",
  "packages/jest-matcher-utils/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { type Chalk } from 'chalk';\nimport { type DiffOptions as ImportDiffOptions } from 'jest-diff';\nimport { SERIALIZABLE_PROPERTIES } from './deepCyclicCopyReplaceable';\nexport { SERIALIZABLE_PROPERTIES };\ntype MatcherHintColor = (arg: string) => string;\nexport type MatcherHintOptions = {\n    comment?: string;\n    expectedColor?: MatcherHintColor;\n    isDirectExpectCall?: boolean;\n    isNot?: boolean;\n    promise?: string;\n    receivedColor?: MatcherHintColor;\n    secondArgument?: string;\n    secondArgumentColor?: MatcherHintColor;\n};\nexport type DiffOptions = ImportDiffOptions;\nexport declare const EXPECTED_COLOR: Chalk;\nexport declare const RECEIVED_COLOR: Chalk;\nexport declare const INVERTED_COLOR: Chalk;\nexport declare const BOLD_WEIGHT: Chalk;\nexport declare const DIM_COLOR: Chalk;\nexport declare const SUGGEST_TO_CONTAIN_EQUAL: string;\nexport declare const stringify: (object: unknown, maxDepth?: number, maxWidth?: number) => string;\nexport declare const highlightTrailingWhitespace: (text: string) => string;\nexport declare const printReceived: (object: unknown) => string;\nexport declare const printExpected: (value: unknown) => string;\nexport declare function printWithType<T>(name: string, value: T, print: (value: T) => string): string;\nexport declare const ensureNoExpected: (expected: unknown, matcherName: string, options?: MatcherHintOptions) => void;\n/**\n * Ensures that `actual` is of type `number | bigint`\n */\nexport declare const ensureActualIsNumber: (actual: unknown, matcherName: string, options?: MatcherHintOptions) => void;\n/**\n * Ensures that `expected` is of type `number | bigint`\n */\nexport declare const ensureExpectedIsNumber: (expected: unknown, matcherName: string, options?: MatcherHintOptions) => void;\n/**\n * Ensures that `actual` & `expected` are of type `number | bigint`\n */\nexport declare const ensureNumbers: (actual: unknown, expected: unknown, matcherName: string, options?: MatcherHintOptions) => void;\nexport declare const ensureExpectedIsNonNegativeInteger: (expected: unknown, matcherName: string, options?: MatcherHintOptions) => void;\nexport declare const printDiffOrStringify: (expected: unknown, received: unknown, expectedLabel: string, receivedLabel: string, expand: boolean) => string;\nexport declare function replaceMatchedToAsymmetricMatcher(replacedExpected: unknown, replacedReceived: unknown, expectedCycles: Array<unknown>, receivedCycles: Array<unknown>): {\n    replacedExpected: unknown;\n    replacedReceived: unknown;\n};\nexport declare const diff: (a: unknown, b: unknown, options?: DiffOptions) => string | null;\nexport declare const pluralize: (word: string, count: number) => string;\ntype PrintLabel = (string: string) => string;\nexport declare const getLabelPrinter: (...strings: Array<string>) => PrintLabel;\nexport declare const matcherErrorMessage: (hint: string, // assertion returned from call to matcherHint\ngeneric: string, // condition which correct value must fulfill\nspecific?: string) => string;\nexport declare const matcherHint: (matcherName: string, received?: string, expected?: string, options?: MatcherHintOptions) => string;\n",
  "packages/jest-matcher-utils/src/deepCyclicCopyReplaceable.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {plugins} from 'pretty-format';\n\nconst builtInObject: Array<unknown> = [\n  Array,\n  Date,\n  Float32Array,\n  Float64Array,\n  Int16Array,\n  Int32Array,\n  Int8Array,\n  Map,\n  Set,\n  RegExp,\n  Uint16Array,\n  Uint32Array,\n  Uint8Array,\n  Uint8ClampedArray,\n];\n\nif (typeof Buffer !== 'undefined') {\n  builtInObject.push(Buffer);\n}\n\nif (typeof Window !== 'undefined') {\n  builtInObject.push(Window);\n}\n\nexport const SERIALIZABLE_PROPERTIES = Symbol.for(\n  '@jest/serializableProperties',\n);\n\nconst isBuiltInObject = (object: any) =>\n  builtInObject.includes(object.constructor);\n\nconst isMap = (value: any): value is Map<unknown, unknown> =>\n  value.constructor === Map;\n\nexport default function deepCyclicCopyReplaceable<T>(\n  value: T,\n  cycles = new WeakMap<any, any>(),\n): T {\n  if (typeof value !== 'object' || value === null) {\n    return value;\n  } else if (cycles.has(value)) {\n    return cycles.get(value);\n  } else if (Array.isArray(value)) {\n    return deepCyclicCopyArray(value, cycles);\n  } else if (isMap(value)) {\n    return deepCyclicCopyMap(value, cycles);\n  } else if (isBuiltInObject(value)) {\n    return value;\n  } else if (plugins.DOMElement.test(value)) {\n    return (value as unknown as Element).cloneNode(true) as unknown as T;\n  } else {\n    return deepCyclicCopyObject(value, cycles);\n  }\n}\n\nfunction deepCyclicCopyObject<T>(object: T, cycles: WeakMap<any, unknown>): T {\n  const newObject = Object.create(Object.getPrototypeOf(object));\n  let descriptors: Record<string | symbol, PropertyDescriptor> = {};\n  let obj = object;\n  do {\n    const serializableProperties = getSerializableProperties(obj);\n\n    if (serializableProperties === undefined) {\n      descriptors = Object.assign(\n        Object.create(null),\n        Object.getOwnPropertyDescriptors(obj),\n        descriptors,\n      );\n    } else {\n      for (const property of serializableProperties) {\n        if (!descriptors[property]) {\n          descriptors[property] = Object.getOwnPropertyDescriptor(\n            obj,\n            property,\n          )!;\n        }\n      }\n    }\n  } while (\n    (obj = Object.getPrototypeOf(obj)) &&\n    obj !== Object.getPrototypeOf({})\n  );\n\n  cycles.set(object, newObject);\n\n  const newDescriptors = [\n    ...Object.keys(descriptors),\n    ...Object.getOwnPropertySymbols(descriptors),\n  ].reduce(\n    //@ts-expect-error because typescript do not support symbol key in object\n    //https://github.com/microsoft/TypeScript/issues/1863\n    (newDescriptors: {[x: string]: PropertyDescriptor}, key: string) => {\n      const enumerable = descriptors[key].enumerable;\n\n      newDescriptors[key] = {\n        configurable: true,\n        enumerable,\n        value: deepCyclicCopyReplaceable(\n          // this accesses the value or getter, depending. We just care about the value anyways, and this allows us to not mess with accessors\n          // it has the side effect of invoking the getter here though, rather than copying it over\n          (object as Record<string | symbol, unknown>)[key],\n          cycles,\n        ),\n        writable: true,\n      };\n      return newDescriptors;\n    },\n    Object.create(null),\n  );\n  //@ts-expect-error because typescript do not support symbol key in object\n  //https://github.com/microsoft/TypeScript/issues/1863\n  return Object.defineProperties(newObject, newDescriptors);\n}\n\nfunction deepCyclicCopyArray<T>(\n  array: Array<T>,\n  cycles: WeakMap<any, unknown>,\n): T {\n  const newArray = new (Object.getPrototypeOf(array).constructor)(array.length);\n  const length = array.length;\n\n  cycles.set(array, newArray);\n\n  for (let i = 0; i < length; i++) {\n    newArray[i] = deepCyclicCopyReplaceable(array[i], cycles);\n  }\n\n  return newArray;\n}\n\nfunction deepCyclicCopyMap<T>(\n  map: Map<unknown, unknown>,\n  cycles: WeakMap<any, unknown>,\n): T {\n  const newMap = new Map();\n\n  cycles.set(map, newMap);\n\n  for (const [key, value] of map) {\n    newMap.set(key, deepCyclicCopyReplaceable(value, cycles));\n  }\n\n  return newMap as any;\n}\n\nfunction getSerializableProperties<T>(\n  obj: T,\n): Array<string | symbol> | undefined {\n  if (typeof obj !== 'object' || obj === null) {\n    return;\n  }\n\n  const serializableProperties: unknown = (obj as Record<string | symbol, any>)[\n    SERIALIZABLE_PROPERTIES\n  ];\n\n  if (!Array.isArray(serializableProperties)) {\n    return;\n  }\n\n  return serializableProperties.filter(\n    (key): key is string | symbol =>\n      typeof key === 'string' || typeof key === 'symbol',\n  );\n}\n",
  "packages/jest-matcher-utils/src/deepCyclicCopyReplaceable.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport declare const SERIALIZABLE_PROPERTIES: unique symbol;\nexport default function deepCyclicCopyReplaceable<T>(value: T, cycles?: WeakMap<any, any>): T;\n",
  "packages/jest-matcher-utils/src/Replaceable.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {getType} from '@jest/get-type';\n\nconst supportTypes = new Set(['map', 'array', 'object']);\n\ntype ReplaceableForEachCallBack = (\n  value: unknown,\n  key: unknown,\n  object: unknown,\n) => void;\n\n/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\nexport default class Replaceable {\n  object: any;\n  type: string;\n\n  constructor(object: any) {\n    this.object = object;\n    this.type = getType(object);\n    if (!supportTypes.has(this.type)) {\n      throw new Error(`Type ${this.type} is not support in Replaceable!`);\n    }\n  }\n\n  static isReplaceable(obj1: unknown, obj2: unknown): boolean {\n    const obj1Type = getType(obj1);\n    const obj2Type = getType(obj2);\n    return obj1Type === obj2Type && supportTypes.has(obj1Type);\n  }\n\n  forEach(cb: ReplaceableForEachCallBack): void {\n    if (this.type === 'object') {\n      const descriptors = Object.getOwnPropertyDescriptors(this.object);\n      for (const key of [\n        ...Object.keys(descriptors),\n        ...Object.getOwnPropertySymbols(descriptors),\n      ]\n        //@ts-expect-error because typescript do not support symbol key in object\n        //https://github.com/microsoft/TypeScript/issues/1863\n        .filter(key => descriptors[key].enumerable)) {\n        cb(this.object[key], key, this.object);\n      }\n    } else {\n      // eslint-disable-next-line unicorn/no-array-for-each\n      this.object.forEach(cb);\n    }\n  }\n\n  get(key: any): any {\n    if (this.type === 'map') {\n      return this.object.get(key);\n    }\n    return this.object[key];\n  }\n\n  set(key: any, value: any): void {\n    if (this.type === 'map') {\n      this.object.set(key, value);\n    } else {\n      this.object[key] = value;\n    }\n  }\n}\n/* eslint-enable */\n",
  "packages/jest-matcher-utils/src/Replaceable.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\ntype ReplaceableForEachCallBack = (value: unknown, key: unknown, object: unknown) => void;\nexport default class Replaceable {\n    object: any;\n    type: string;\n    constructor(object: any);\n    static isReplaceable(obj1: unknown, obj2: unknown): boolean;\n    forEach(cb: ReplaceableForEachCallBack): void;\n    get(key: any): any;\n    set(key: any, value: any): void;\n}\nexport {};\n",
  "packages/jest-matcher-utils/src/__tests__/printDiffOrStringify.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {alignedAnsiStyleSerializer} from '@jest/test-utils';\nimport {INVERTED_COLOR, printDiffOrStringify} from '../index';\n\nexpect.addSnapshotSerializer(alignedAnsiStyleSerializer);\n\ndescribe('printDiffOrStringify', () => {\n  const testDiffOrStringify = (expected: unknown, received: unknown): string =>\n    printDiffOrStringify(expected, received, 'Expected', 'Received', true);\n\n  test('expected is empty and received is single line', () => {\n    const expected = '';\n    const received = 'single line';\n    expect(testDiffOrStringify(expected, received)).toMatchSnapshot();\n  });\n\n  test('expected is multi line and received is empty', () => {\n    const expected = 'multi\\nline';\n    const received = '';\n    expect(testDiffOrStringify(expected, received)).toMatchSnapshot();\n  });\n\n  test('expected and received are single line with multiple changes', () => {\n    const expected = 'delete common expected common prev';\n    const received = 'insert common received common next';\n    expect(testDiffOrStringify(expected, received)).toMatchSnapshot();\n  });\n\n  test('expected and received are multi line with trailing spaces', () => {\n    const expected = 'delete \\ncommon expected common\\nprev ';\n    const received = 'insert \\ncommon received common\\nnext ';\n    expect(testDiffOrStringify(expected, received)).toMatchSnapshot();\n  });\n\n  test('has no common after clean up chaff multiline', () => {\n    const expected = 'delete\\ntwo';\n    const received = 'insert\\n2';\n    expect(testDiffOrStringify(expected, received)).toMatchSnapshot();\n  });\n\n  test('has no common after clean up chaff one-line', () => {\n    const expected = 'delete';\n    const received = 'insert';\n    expect(testDiffOrStringify(expected, received)).toMatchSnapshot();\n  });\n\n  test('object contain readonly symbol key object', () => {\n    const expected = {b: 2};\n    const received = {b: 1};\n    const symbolKey = Symbol.for('key');\n    Object.defineProperty(expected, symbolKey, {\n      configurable: true,\n      enumerable: true,\n      value: {\n        a: 1,\n      },\n      writable: false,\n    });\n    Object.defineProperty(received, symbolKey, {\n      configurable: true,\n      enumerable: true,\n      value: {\n        a: 1,\n      },\n      writable: false,\n    });\n    expect(testDiffOrStringify(expected, received)).toMatchSnapshot();\n  });\n\n  describe('MAX_DIFF_STRING_LENGTH', () => {\n    const lessChange = INVERTED_COLOR('single ');\n    const less = 'single line';\n    const more = `multi line${'\\n123456789'.repeat(2000)}`; // 10 + 20K chars\n\n    test('both are less', () => {\n      const difference = testDiffOrStringify('multi\\nline', less);\n\n      expect(difference).toMatch('- multi');\n      expect(difference).toMatch('- line');\n\n      // diffStringsUnified has substring change\n      expect(difference).not.toMatch('+ single line');\n      expect(difference).toMatch(lessChange);\n    });\n\n    test('expected is more', () => {\n      const difference = testDiffOrStringify(more, less);\n\n      expect(difference).toMatch('- multi line');\n      expect(difference).toMatch('+ single line');\n\n      // diffLinesUnified does not have substring change\n      expect(difference).not.toMatch(lessChange);\n    });\n\n    test('received is more', () => {\n      const difference = testDiffOrStringify(less, more);\n\n      expect(difference).toMatch('- single line');\n      expect(difference).toMatch('+ multi line');\n\n      // diffLinesUnified does not have substring change\n      expect(difference).not.toMatch(lessChange);\n    });\n  });\n\n  describe('asymmetricMatcher', () => {\n    test('minimal test', () => {\n      const expected = {a: expect.any(Number), b: 2};\n      const received = {a: 1, b: 1};\n      expect(testDiffOrStringify(expected, received)).toMatchSnapshot();\n    });\n\n    test('jest asymmetricMatcher', () => {\n      const expected = {\n        a: expect.any(Number),\n        b: expect.anything(),\n        c: expect.arrayContaining([1, 3]),\n        d: 'jest is awesome',\n        e: 'jest is awesome',\n        f: {\n          a: new Date(),\n          b: 'jest is awesome',\n        },\n        g: true,\n        [Symbol.for('h')]: 'jest is awesome',\n      };\n      const received = {\n        a: 1,\n        b: 'anything',\n        c: [1, 2, 3],\n        d: expect.stringContaining('jest'),\n        e: expect.stringMatching(/^jest/),\n        f: expect.objectContaining({\n          a: expect.any(Date),\n        }),\n        g: false,\n        [Symbol.for('h')]: expect.any(String),\n      };\n\n      expect(testDiffOrStringify(expected, received)).toMatchSnapshot();\n    });\n\n    test('custom asymmetricMatcher', () => {\n      expect.extend({\n        equal5(received: unknown) {\n          if (received === 5)\n            return {\n              message: () => `expected ${received} not to be 5`,\n              pass: true,\n            };\n          return {\n            message: () => `expected ${received} to be 5`,\n            pass: false,\n          };\n        },\n      });\n      const expected = {\n        a: expect.equal5(),\n        b: false,\n      };\n      const received = {\n        a: 5,\n        b: true,\n      };\n\n      expect(testDiffOrStringify(expected, received)).toMatchSnapshot();\n    });\n\n    test('nested object', () => {\n      const expected = {\n        a: 1,\n        b: {\n          a: 1,\n          b: expect.any(Number),\n        },\n        c: 2,\n      };\n      const received = {\n        a: expect.any(Number),\n        b: {\n          a: 1,\n          b: 2,\n        },\n        c: 1,\n      };\n      expect(testDiffOrStringify(expected, received)).toMatchSnapshot();\n    });\n\n    test('array', () => {\n      const expected: Array<unknown> = [1, expect.any(Number), 3];\n      const received: Array<unknown> = [1, 2, 2];\n      expect(testDiffOrStringify(expected, received)).toMatchSnapshot();\n    });\n\n    test('object in array', () => {\n      const expected: Array<unknown> = [1, {a: 1, b: expect.any(Number)}, 3];\n      const received: Array<unknown> = [1, {a: 1, b: 2}, 2];\n      expect(testDiffOrStringify(expected, received)).toMatchSnapshot();\n    });\n\n    test('map', () => {\n      const expected = new Map<string, unknown>([\n        ['a', 1],\n        ['b', expect.any(Number)],\n        ['c', 3],\n      ]);\n      const received = new Map<string, unknown>([\n        ['a', 1],\n        ['b', 2],\n        ['c', 2],\n      ]);\n      expect(testDiffOrStringify(expected, received)).toMatchSnapshot();\n    });\n\n    test('circular object', () => {\n      const expected: any = {\n        b: expect.any(Number),\n        c: 3,\n      };\n      expected.a = expected;\n      const received: any = {\n        b: 2,\n        c: 2,\n      };\n      received.a = received;\n      expect(testDiffOrStringify(expected, received)).toMatchSnapshot();\n    });\n\n    test('transitive circular', () => {\n      const expected: unknown = {\n        a: 3,\n      };\n      expected.nested = {b: expect.any(Number), parent: expected};\n      const received: any = {\n        a: 2,\n      };\n      received.nested = {b: 2, parent: received};\n      expect(testDiffOrStringify(expected, received)).toMatchSnapshot();\n    });\n\n    test('circular array', () => {\n      const expected: Array<unknown> = [1, expect.any(Number), 3];\n      expected.push(expected);\n      const received: Array<unknown> = [1, 2, 2];\n      received.push(received);\n      expect(testDiffOrStringify(expected, received)).toMatchSnapshot();\n    });\n\n    test('circular map', () => {\n      const expected = new Map<string, unknown>([\n        ['a', 1],\n        ['b', expect.any(Number)],\n        ['c', 3],\n      ]);\n      expected.set('circular', expected);\n      const received = new Map<string, unknown>([\n        ['a', 1],\n        ['b', 2],\n        ['c', 2],\n      ]);\n      received.set('circular', received);\n      expect(testDiffOrStringify(expected, received)).toMatchSnapshot();\n    });\n  });\n});\n",
  "packages/jest-matcher-utils/src/__tests__/printDiffOrStringify.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-matcher-utils/src/__tests__/index.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport chalk from 'chalk';\nimport {alignedAnsiStyleSerializer} from '@jest/test-utils';\nimport {format as prettyFormat} from 'pretty-format';\nimport {\n  type MatcherHintOptions,\n  diff,\n  ensureNoExpected,\n  ensureNumbers,\n  getLabelPrinter,\n  matcherHint,\n  pluralize,\n  stringify,\n} from '../';\n\nexpect.addSnapshotSerializer(alignedAnsiStyleSerializer);\n\ndescribe('stringify()', () => {\n  for (const [v, s] of [\n    [[], '[]'],\n    [{}, '{}'],\n    [1, '1'],\n    [0, '0'],\n    [1.5, '1.5'],\n    [null, 'null'],\n    [undefined, 'undefined'],\n    ['abc', '\"abc\"'],\n    [Symbol.for('abc'), 'Symbol(abc)'],\n    /* eslint-disable unicorn/prefer-number-properties */\n    [NaN, 'NaN'],\n    [Infinity, 'Infinity'],\n    [-Infinity, '-Infinity'],\n    /* eslint-enable */\n    [Number.NaN, 'NaN'],\n    [Number.POSITIVE_INFINITY, 'Infinity'],\n    [Number.NEGATIVE_INFINITY, '-Infinity'],\n    [/ab\\.c/gi, '/ab\\\\.c/gi'],\n    [BigInt(1), '1n'],\n    [BigInt(0), '0n'],\n  ]) {\n    test(stringify(v), () => {\n      expect(stringify(v)).toBe(s);\n    });\n  }\n\n  test('circular references', () => {\n    const a: any = {};\n    a.a = a;\n    expect(stringify(a)).toBe('{\"a\": [Circular]}');\n  });\n\n  test('toJSON error', () => {\n    const evil = {\n      toJSON() {\n        throw new Error('Nope.');\n      },\n    };\n    expect(stringify(evil)).toBe('{\"toJSON\": [Function toJSON]}');\n    expect(stringify({a: {b: {evil}}})).toBe(\n      '{\"a\": {\"b\": {\"evil\": {\"toJSON\": [Function toJSON]}}}}',\n    );\n\n    function Evil() {}\n    Evil.toJSON = evil.toJSON;\n    expect(stringify(Evil)).toBe('[Function Evil]');\n  });\n\n  test('toJSON errors when comparing two objects', () => {\n    function toJSON() {\n      throw new Error('Nope.');\n    }\n    const evilA = {\n      a: 1,\n      toJSON,\n    };\n    const evilB = {\n      b: 1,\n      toJSON,\n    };\n\n    expect(() => expect(evilA).toEqual(evilB)).toThrowErrorMatchingSnapshot();\n  });\n\n  test('reduces maxDepth if stringifying very large objects', () => {\n    const big: any = {a: 1, b: {}};\n    const small: any = {a: 1, b: {}};\n    for (let i = 0; i < 10_000; i += 1) {\n      big.b[i] = 'test';\n    }\n\n    for (let i = 0; i < 10; i += 1) {\n      small.b[i] = 'test';\n    }\n\n    expect(stringify(big)).toBe(prettyFormat(big, {maxDepth: 1, min: true}));\n    expect(stringify(small)).toBe(prettyFormat(small, {min: true}));\n  });\n\n  test('reduces maxWidth if stringifying very large arrays', () => {\n    const big: any = [];\n    const small: any = [];\n    const testString = Array.from({length: 1000}).join('x');\n\n    for (let i = 0; i < 100; i += 1) {\n      big[i] = testString;\n    }\n\n    for (let i = 0; i < 3; i += 1) {\n      small[i] = testString;\n    }\n\n    expect(stringify(big)).toBe(prettyFormat(big, {maxWidth: 5, min: true}));\n    expect(stringify(small)).toBe(prettyFormat(small, {min: true}));\n  });\n});\n\ndescribe('ensureNumbers()', () => {\n  const matcherName = 'toBeCloseTo';\n\n  test('dont throw error when variables are numbers', () => {\n    expect(() => {\n      ensureNumbers(1, 2, matcherName);\n    }).not.toThrow();\n    expect(() => {\n      ensureNumbers(BigInt(1), BigInt(2), matcherName);\n    }).not.toThrow();\n  });\n\n  test('throws error when expected is not a number (backward compatibility)', () => {\n    expect(() => {\n      ensureNumbers(1, 'not_a_number', `.${matcherName}`);\n    }).toThrowErrorMatchingSnapshot();\n  });\n\n  test('throws error when received is not a number (backward compatibility)', () => {\n    expect(() => {\n      ensureNumbers('not_a_number', 3, `.${matcherName}`);\n    }).toThrowErrorMatchingSnapshot();\n  });\n\n  describe('with options', () => {\n    test('promise empty isNot false received', () => {\n      const options: MatcherHintOptions = {\n        isNot: false,\n        promise: '',\n        secondArgument: 'precision',\n      };\n      expect(() => {\n        ensureNumbers('', 0, matcherName, options);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('promise empty isNot true expected', () => {\n      const options: MatcherHintOptions = {\n        isNot: true,\n        // promise undefined is equivalent to empty string\n      };\n      expect(() => {\n        ensureNumbers(0.1, undefined, matcherName, options);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('promise rejects isNot false expected', () => {\n      const options: MatcherHintOptions = {\n        isNot: false,\n        promise: 'rejects',\n      };\n      expect(() => {\n        ensureNumbers(0.01, '0', matcherName, options);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('promise rejects isNot true received', () => {\n      const options: MatcherHintOptions = {\n        isNot: true,\n        promise: 'rejects',\n      };\n      expect(() => {\n        ensureNumbers(Symbol('0.1'), 0, matcherName, options);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('promise resolves isNot false received', () => {\n      const options: MatcherHintOptions = {\n        isNot: false,\n        promise: 'resolves',\n      };\n      expect(() => {\n        ensureNumbers(false, 0, matcherName, options);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('promise resolves isNot true expected', () => {\n      const options: MatcherHintOptions = {\n        isNot: true,\n        promise: 'resolves',\n      };\n      expect(() => {\n        ensureNumbers(0.1, null, matcherName, options);\n      }).toThrowErrorMatchingSnapshot();\n    });\n  });\n});\n\ndescribe('ensureNoExpected()', () => {\n  const matcherName = 'toBeDefined';\n\n  test('dont throw error when undefined', () => {\n    expect(() => {\n      ensureNoExpected(undefined, matcherName);\n    }).not.toThrow();\n  });\n\n  test('throws error when expected is not undefined with matcherName', () => {\n    expect(() => {\n      ensureNoExpected({a: 1}, `.${matcherName}`);\n    }).toThrowErrorMatchingSnapshot();\n  });\n\n  test('throws error when expected is not undefined with matcherName and options', () => {\n    expect(() => {\n      ensureNoExpected({a: 1}, matcherName, {isNot: true});\n    }).toThrowErrorMatchingSnapshot();\n  });\n});\n\njest.mock('jest-diff', () => ({\n  diff: () => 'diff output',\n}));\ndescribe('diff', () => {\n  test('forwards to jest-diff', () => {\n    for (const [actual, expected] of [\n      ['a', 'b'],\n      ['a', {}],\n      ['a', null],\n      ['a', undefined],\n      ['a', 1],\n      ['a', true],\n      [1, true],\n      [BigInt(1), true],\n    ])\n      expect(diff(actual, expected)).toBe('diff output');\n  });\n\n  test('two booleans', () => {\n    expect(diff(false, true)).toBeNull();\n  });\n\n  test('two numbers', () => {\n    expect(diff(1, 2)).toBeNull();\n  });\n\n  test('two bigints', () => {\n    expect(diff(BigInt(1), BigInt(2))).toBeNull();\n  });\n});\n\ndescribe('pluralize()', () => {\n  test('one', () => expect(pluralize('apple', 1)).toBe('one apple'));\n  test('two', () => expect(pluralize('apple', 2)).toBe('two apples'));\n  test('20', () => expect(pluralize('apple', 20)).toBe('20 apples'));\n});\n\ndescribe('getLabelPrinter', () => {\n  test('0 args', () => {\n    const printLabel = getLabelPrinter();\n    expect(printLabel('')).toBe(': ');\n  });\n  test('1 empty string', () => {\n    const printLabel = getLabelPrinter();\n    expect(printLabel('')).toBe(': ');\n  });\n  test('1 non-empty string', () => {\n    const string = 'Expected';\n    const printLabel = getLabelPrinter(string);\n    expect(printLabel(string)).toBe('Expected: ');\n  });\n  test('2 equal lengths', () => {\n    const stringExpected = 'Expected value';\n    const collectionType = 'array';\n    const stringReceived = `Received ${collectionType}`;\n    const printLabel = getLabelPrinter(stringExpected, stringReceived);\n    expect(printLabel(stringExpected)).toBe('Expected value: ');\n    expect(printLabel(stringReceived)).toBe('Received array: ');\n  });\n  test('2 unequal lengths', () => {\n    const stringExpected = 'Expected value';\n    const collectionType = 'set';\n    const stringReceived = `Received ${collectionType}`;\n    const printLabel = getLabelPrinter(stringExpected, stringReceived);\n    expect(printLabel(stringExpected)).toBe('Expected value: ');\n    expect(printLabel(stringReceived)).toBe('Received set:   ');\n  });\n  test('returns incorrect padding if inconsistent arg is shorter', () => {\n    const stringConsistent = 'Expected';\n    const stringInconsistent = 'Received value';\n    const stringInconsistentShorter = 'Received set';\n    const printLabel = getLabelPrinter(stringConsistent, stringInconsistent);\n    expect(printLabel(stringConsistent)).toBe('Expected:       ');\n    expect(printLabel(stringInconsistentShorter)).toBe('Received set:   ');\n  });\n  test('throws if inconsistent arg is longer', () => {\n    const stringConsistent = 'Expected';\n    const stringInconsistent = 'Received value';\n    const stringInconsistentLonger = 'Received string';\n    const printLabel = getLabelPrinter(stringConsistent, stringInconsistent);\n    expect(printLabel(stringConsistent)).toBe('Expected:       ');\n    expect(() => {\n      printLabel(stringInconsistentLonger);\n    }).toThrow('Invalid count value');\n  });\n});\n\ndescribe('matcherHint', () => {\n  test('expectedColor', () => {\n    const expectedColor = (arg: string): string => arg; // default (black) color\n    const expectedArgument = 'n';\n    const received = matcherHint(\n      'toHaveBeenNthCalledWith',\n      'jest.fn()',\n      expectedArgument,\n      {expectedColor, secondArgument: '...expected'},\n    );\n\n    const substringNegative = chalk.green(expectedArgument);\n\n    expect(received).not.toMatch(substringNegative);\n  });\n\n  test('receivedColor', () => {\n    const receivedColor = chalk.cyan.bgAnsi256(158);\n    const receivedArgument = 'received';\n    const received = matcherHint('toMatchSnapshot', receivedArgument, '', {\n      receivedColor,\n    });\n\n    const substringNegative = chalk.red(receivedArgument);\n    const substringPositive = receivedColor(receivedArgument);\n\n    expect(received).not.toMatch(substringNegative);\n    expect(received).toMatch(substringPositive);\n  });\n\n  test('secondArgumentColor', () => {\n    const secondArgumentColor = chalk.bold;\n    const secondArgument = 'hint';\n    const received = matcherHint('toMatchSnapshot', undefined, 'properties', {\n      secondArgument,\n      secondArgumentColor,\n    });\n\n    const substringNegative = chalk.green(secondArgument);\n    const substringPositive = secondArgumentColor(secondArgument);\n\n    expect(received).not.toMatch(substringNegative);\n    expect(received).toMatch(substringPositive);\n  });\n});\n\ndescribe('printDiffOrStringify', () => {\n  test('expected asymmetric matchers should be diffable', () => {\n    jest.dontMock('jest-diff');\n    jest.resetModules();\n    const {printDiffOrStringify} = require('../');\n\n    const expected = expect.objectContaining({\n      array: [\n        {\n          3: 'three',\n          four: '4',\n          one: 1,\n          two: 2,\n        },\n      ],\n      foo: 'bar',\n    });\n    const received = {\n      array: [\n        {\n          3: 'three',\n          four: '4',\n          one: 1,\n          two: 1,\n        },\n      ],\n      foo: 'bar',\n    };\n    expect(\n      printDiffOrStringify(expected, received, 'Expected', 'Received', false),\n    ).toMatchSnapshot();\n  });\n});\n",
  "packages/jest-matcher-utils/src/__tests__/index.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport {};\n",
  "packages/jest-matcher-utils/src/__tests__/deepCyclicCopyReplaceableDom.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @jest-environment jsdom\n */\n\n/// <reference lib=\"dom\" />\n\n/* global document */\n\nimport deepCyclicCopyReplaceable from '../deepCyclicCopyReplaceable';\n\ntest('should copy dom element', () => {\n  const div = document.createElement('div');\n  const copied = deepCyclicCopyReplaceable(div);\n  expect(copied).toEqual(div);\n  expect(div === copied).toBe(false); //assert reference is not the same\n});\n\ntest('should copy complex element', () => {\n  const div = document.createElement('div');\n  const span = document.createElement('span');\n  div.setAttribute('id', 'div');\n  div.textContent = 'this is div';\n  div.append(span);\n  const copied = deepCyclicCopyReplaceable(div);\n  expect(copied).toEqual(div);\n  expect(div === copied).toBe(false); //assert reference is not the same\n  expect(div.children[0] === copied.children[0]).toBe(false); //assert reference is not the same\n});\n\ntest('should ignore window', () => {\n  // eslint-disable-next-line unicorn/prefer-global-this\n  expect(deepCyclicCopyReplaceable(window)).toBe(window);\n});\n",
  "packages/jest-matcher-utils/src/__tests__/deepCyclicCopyReplaceableDom.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @jest-environment jsdom\n */\nexport {};\n",
  "packages/jest-matcher-utils/src/__tests__/deepCyclicCopyReplaceable.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport deepCyclicCopyReplaceable, {\n  SERIALIZABLE_PROPERTIES,\n} from '../deepCyclicCopyReplaceable';\n\ntest('returns the same value for primitive or function values', () => {\n  const fn = () => {};\n\n  expect(deepCyclicCopyReplaceable(undefined)).toBeUndefined();\n  expect(deepCyclicCopyReplaceable(null)).toBeNull();\n  expect(deepCyclicCopyReplaceable(true)).toBe(true);\n  expect(deepCyclicCopyReplaceable(42)).toBe(42);\n  expect(Number.isNaN(deepCyclicCopyReplaceable(Number.NaN))).toBe(true);\n  expect(deepCyclicCopyReplaceable('foo')).toBe('foo');\n  expect(deepCyclicCopyReplaceable(fn)).toBe(fn);\n});\n\ntest('convert accessor descriptor into value descriptor', () => {\n  const obj = {\n    set foo(_) {},\n    get foo() {\n      return 'bar';\n    },\n  };\n  expect(Object.getOwnPropertyDescriptor(obj, 'foo')).toEqual({\n    configurable: true,\n    enumerable: true,\n    get: expect.any(Function),\n    set: expect.any(Function),\n  });\n  const copy = deepCyclicCopyReplaceable(obj);\n\n  expect(Object.getOwnPropertyDescriptor(copy, 'foo')).toEqual({\n    configurable: true,\n    enumerable: true,\n    value: 'bar',\n    writable: true,\n  });\n});\n\ntest('should not skip non-enumerables', () => {\n  const obj = {};\n  Object.defineProperty(obj, 'foo', {enumerable: false, value: 'bar'});\n\n  const copy = deepCyclicCopyReplaceable(obj);\n\n  expect(Object.getOwnPropertyDescriptors(copy)).toEqual({\n    foo: {\n      configurable: true,\n      enumerable: false,\n      value: 'bar',\n      writable: true,\n    },\n  });\n});\n\ntest('copies symbols', () => {\n  const symbol = Symbol('foo');\n  const obj = {[symbol]: 42};\n\n  expect(deepCyclicCopyReplaceable(obj)[symbol]).toBe(42);\n});\n\ntest('copies value of inherited getters', () => {\n  class Foo {\n    #foo = 42;\n    get foo() {\n      return this.#foo;\n    }\n  }\n  const obj = new Foo();\n\n  expect(deepCyclicCopyReplaceable(obj).foo).toBe(42);\n});\n\ntest('copies arrays as array objects', () => {\n  const array = [null, 42, 'foo', 'bar', [], {}];\n\n  expect(deepCyclicCopyReplaceable(array)).toEqual(array);\n  expect(Array.isArray(deepCyclicCopyReplaceable(array))).toBe(true);\n});\n\ntest('handles cyclic dependencies', () => {\n  const cyclic: any = {a: 42, subcycle: {}};\n\n  cyclic.subcycle.baz = cyclic;\n  cyclic.bar = cyclic;\n\n  expect(() => deepCyclicCopyReplaceable(cyclic)).not.toThrow();\n\n  const copy = deepCyclicCopyReplaceable(cyclic);\n\n  expect(copy.a).toBe(42);\n  expect(copy.bar).toEqual(copy);\n  expect(copy.subcycle.baz).toEqual(copy);\n});\n\ntest('Copy Map', () => {\n  const map = new Map([\n    ['a', 1],\n    ['b', 2],\n  ]);\n  const copy = deepCyclicCopyReplaceable(map);\n  expect(copy).toEqual(map);\n  expect(copy.constructor).toBe(Map);\n});\n\ntest('Copy cyclic Map', () => {\n  const map = new Map<string, unknown>([\n    ['a', 1],\n    ['b', 2],\n  ]);\n  map.set('map', map);\n  expect(deepCyclicCopyReplaceable(map)).toEqual(map);\n});\n\ntest('return same value for built-in object type except array, map and object', () => {\n  const date = new Date();\n  const buffer = Buffer.from('jest');\n  const numberArray = new Uint8Array([1, 2, 3]);\n  const regexp = /jest/;\n  const set = new Set(['foo', 'bar']);\n\n  expect(deepCyclicCopyReplaceable(date)).toBe(date);\n  expect(deepCyclicCopyReplaceable(buffer)).toBe(buffer);\n  expect(deepCyclicCopyReplaceable(numberArray)).toBe(numberArray);\n  expect(deepCyclicCopyReplaceable(regexp)).toBe(regexp);\n  expect(deepCyclicCopyReplaceable(set)).toBe(set);\n});\n\ntest('should copy object symbol key property', () => {\n  const symbolKey = Symbol.for('key');\n  expect(deepCyclicCopyReplaceable({[symbolKey]: 1})).toEqual({[symbolKey]: 1});\n});\n\ntest('should set writable, configurable to true', () => {\n  const a = {};\n  Object.defineProperty(a, 'key', {\n    configurable: false,\n    enumerable: true,\n    value: 1,\n    writable: false,\n  });\n  const copied = deepCyclicCopyReplaceable(a);\n  expect(Object.getOwnPropertyDescriptors(copied)).toEqual({\n    key: {configurable: true, enumerable: true, value: 1, writable: true},\n  });\n});\n\ntest('should only copy the properties mapped to be serializable', () => {\n  class Foo {\n    foo = 'foo';\n    bar = ['bar'];\n    get baz() {\n      throw new Error('should not call getter');\n    }\n  }\n\n  // @ts-expect-error: Testing purpose\n  Foo.prototype[SERIALIZABLE_PROPERTIES] = ['foo', 'bar'];\n\n  const obj = new Foo();\n\n  const copied = deepCyclicCopyReplaceable(obj);\n  expect(Object.getOwnPropertyDescriptors(copied)).toEqual({\n    bar: {configurable: true, enumerable: true, value: ['bar'], writable: true},\n    foo: {configurable: true, enumerable: true, value: 'foo', writable: true},\n  });\n});\n\ntest('json from Response', async () => {\n  const response = () => new Response(JSON.stringify({}));\n\n  const text = JSON.parse(await response().text());\n  deepCyclicCopyReplaceable(text);\n\n  const json = await response().json();\n  deepCyclicCopyReplaceable(json);\n});\n",
  "packages/jest-matcher-utils/src/__tests__/deepCyclicCopyReplaceable.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport {};\n",
  "packages/jest-matcher-utils/src/__tests__/Replaceable.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport Replaceable from '../Replaceable';\n\ndescribe('Replaceable', () => {\n  describe('constructor', () => {\n    test('init with object', () => {\n      const replaceable = new Replaceable({a: 1, b: 2});\n      expect(replaceable.object).toEqual({a: 1, b: 2});\n      expect(replaceable.type).toBe('object');\n    });\n\n    test('init with array', () => {\n      const replaceable = new Replaceable([1, 2, 3]);\n      expect(replaceable.object).toEqual([1, 2, 3]);\n      expect(replaceable.type).toBe('array');\n    });\n\n    test('init with Map', () => {\n      const replaceable = new Replaceable(\n        new Map([\n          ['a', 1],\n          ['b', 2],\n        ]),\n      );\n      expect(replaceable.object).toEqual(\n        new Map([\n          ['a', 1],\n          ['b', 2],\n        ]),\n      );\n      expect(replaceable.type).toBe('map');\n    });\n\n    test('init with other type should throw error', () => {\n      expect(() => {\n        // eslint-disable-next-line no-new\n        new Replaceable(new Date());\n      }).toThrow('Type date is not support in Replaceable!');\n    });\n  });\n\n  describe('get', () => {\n    test('get object item', () => {\n      const replaceable = new Replaceable({a: 1, b: 2});\n      expect(replaceable.get('b')).toBe(2);\n    });\n\n    test('get array item', () => {\n      const replaceable = new Replaceable([1, 2, 3]);\n      expect(replaceable.get(1)).toBe(2);\n    });\n\n    test('get Map item', () => {\n      const replaceable = new Replaceable(\n        new Map([\n          ['a', 1],\n          ['b', 2],\n        ]),\n      );\n      expect(replaceable.get('b')).toBe(2);\n    });\n  });\n\n  describe('set', () => {\n    test('set object item', () => {\n      const replaceable = new Replaceable({a: 1, b: 2});\n      replaceable.set('b', 3);\n      expect(replaceable.object).toEqual({a: 1, b: 3});\n    });\n\n    test('set array item', () => {\n      const replaceable = new Replaceable([1, 2, 3]);\n      replaceable.set(1, 3);\n      expect(replaceable.object).toEqual([1, 3, 3]);\n    });\n\n    test('set Map item', () => {\n      const replaceable = new Replaceable(\n        new Map([\n          ['a', 1],\n          ['b', 2],\n        ]),\n      );\n      replaceable.set('b', 3);\n      expect(replaceable.object).toEqual(\n        new Map([\n          ['a', 1],\n          ['b', 3],\n        ]),\n      );\n    });\n  });\n\n  describe('forEach', () => {\n    test('object forEach', () => {\n      const symbolKey = Symbol('jest');\n      const object = {a: 1, b: 2, [symbolKey]: 3};\n      const replaceable = new Replaceable(object);\n      const cb = jest.fn();\n      // eslint-disable-next-line unicorn/no-array-for-each\n      replaceable.forEach(cb);\n      expect(cb).toHaveBeenCalledTimes(3);\n      expect(cb.mock.calls[0]).toEqual([1, 'a', object]);\n      expect(cb.mock.calls[1]).toEqual([2, 'b', object]);\n      expect(cb.mock.calls[2]).toEqual([3, symbolKey, object]);\n    });\n\n    test('array forEach', () => {\n      const replaceable = new Replaceable([1, 2, 3]);\n      const cb = jest.fn();\n      // eslint-disable-next-line unicorn/no-array-for-each\n      replaceable.forEach(cb);\n      expect(cb).toHaveBeenCalledTimes(3);\n      expect(cb.mock.calls[0]).toEqual([1, 0, [1, 2, 3]]);\n      expect(cb.mock.calls[1]).toEqual([2, 1, [1, 2, 3]]);\n      expect(cb.mock.calls[2]).toEqual([3, 2, [1, 2, 3]]);\n    });\n\n    test('map forEach', () => {\n      const map = new Map([\n        ['a', 1],\n        ['b', 2],\n      ]);\n      const replaceable = new Replaceable(map);\n      const cb = jest.fn();\n      // eslint-disable-next-line unicorn/no-array-for-each\n      replaceable.forEach(cb);\n      expect(cb).toHaveBeenCalledTimes(2);\n      expect(cb.mock.calls[0]).toEqual([1, 'a', map]);\n      expect(cb.mock.calls[1]).toEqual([2, 'b', map]);\n    });\n\n    test('forEach should ignore nonenumerable property', () => {\n      const symbolKey = Symbol('jest');\n      const symbolKey2 = Symbol('awesome');\n      const object = {a: 1, [symbolKey]: 3};\n      Object.defineProperty(object, 'b', {\n        configurable: true,\n        enumerable: false,\n        value: 2,\n        writable: true,\n      });\n      Object.defineProperty(object, symbolKey2, {\n        configurable: true,\n        enumerable: false,\n        value: 4,\n        writable: true,\n      });\n      const replaceable = new Replaceable(object);\n      const cb = jest.fn();\n      // eslint-disable-next-line unicorn/no-array-for-each\n      replaceable.forEach(cb);\n      expect(cb).toHaveBeenCalledTimes(2);\n      expect(cb.mock.calls[0]).toEqual([1, 'a', object]);\n      expect(cb.mock.calls[1]).toEqual([3, symbolKey, object]);\n    });\n  });\n\n  describe('isReplaceable', () => {\n    test('should return true if two object types equal and support', () => {\n      expect(Replaceable.isReplaceable({a: 1}, {b: 2})).toBe(true);\n      expect(Replaceable.isReplaceable([], [1, 2, 3])).toBe(true);\n      expect(\n        Replaceable.isReplaceable(\n          new Map(),\n          new Map([\n            ['a', 1],\n            ['b', 2],\n          ]),\n        ),\n      ).toBe(true);\n    });\n\n    test('should return false if two object types not equal', () => {\n      expect(Replaceable.isReplaceable({a: 1}, [1, 2, 3])).toBe(false);\n    });\n\n    test('should return false if object types not support', () => {\n      expect(Replaceable.isReplaceable('foo', 'bar')).toBe(false);\n    });\n  });\n});\n",
  "packages/jest-matcher-utils/src/__tests__/Replaceable.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-leak-detector/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n/// <reference lib=\"es2021.WeakRef\" />\n\nimport {promisify} from 'util';\nimport {getHeapSnapshot, setFlagsFromString} from 'v8';\nimport {runInNewContext} from 'vm';\nimport {isPrimitive} from '@jest/get-type';\nimport {format as prettyFormat} from 'pretty-format';\n\nconst tick = promisify(setImmediate);\n\nexport default class LeakDetector {\n  private _isReferenceBeingHeld: boolean;\n  private readonly _finalizationRegistry?: FinalizationRegistry<undefined>;\n\n  constructor(value: unknown) {\n    if (isPrimitive(value)) {\n      throw new TypeError(\n        [\n          'Primitives cannot leak memory.',\n          `You passed a ${typeof value}: <${prettyFormat(value)}>`,\n        ].join(' '),\n      );\n    }\n\n    // When `_finalizationRegistry` is GCed the callback we set will no longer be called,\n    this._finalizationRegistry = new FinalizationRegistry(() => {\n      this._isReferenceBeingHeld = false;\n    });\n    this._finalizationRegistry.register(value as object, undefined);\n\n    this._isReferenceBeingHeld = true;\n\n    // Ensure value is not leaked by the closure created by the \"weak\" callback.\n    value = null;\n  }\n\n  async isLeaking(): Promise<boolean> {\n    this._runGarbageCollector();\n\n    // wait some ticks to allow GC to run properly, see https://github.com/nodejs/node/issues/34636#issuecomment-669366235\n    for (let i = 0; i < 10; i++) {\n      await tick();\n    }\n\n    if (this._isReferenceBeingHeld) {\n      // triggering a heap snapshot is more aggressive than just `global.gc()`,\n      // but it's also quite slow, so only do it if we still think we're leaking.\n      // https://github.com/nodejs/node/pull/48510#issuecomment-1719289759\n      getHeapSnapshot();\n\n      for (let i = 0; i < 10; i++) {\n        await tick();\n      }\n    }\n\n    return this._isReferenceBeingHeld;\n  }\n\n  private _runGarbageCollector() {\n    const isGarbageCollectorHidden = globalThis.gc == null;\n\n    // GC is usually hidden, so we have to expose it before running.\n    setFlagsFromString('--expose-gc');\n    runInNewContext('gc')();\n\n    // The GC was not initially exposed, so let's hide it again.\n    if (isGarbageCollectorHidden) {\n      setFlagsFromString('--no-expose-gc');\n    }\n  }\n}\n",
  "packages/jest-leak-detector/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport default class LeakDetector {\n    private _isReferenceBeingHeld;\n    private readonly _finalizationRegistry?;\n    constructor(value: unknown);\n    isLeaking(): Promise<boolean>;\n    private _runGarbageCollector;\n}\n",
  "packages/jest-leak-detector/src/__tests__/index.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport LeakDetector from '../index';\n\njest.mock('v8', () => ({\n  ...(jest.requireActual('v8') as Record<string, unknown>),\n  getHeapSnapshot: jest.fn(),\n}));\n\nconst gc = globalThis.gc;\n\n// Some tests override the \"gc\" value. Let's make sure we roll it back to its\n// previous value after executing the test.\nafterEach(() => {\n  globalThis.gc = gc;\n});\n\nit('complains if the value is a primitive', () => {\n  expect(() => new LeakDetector(undefined)).toThrowErrorMatchingSnapshot();\n  expect(() => new LeakDetector(null)).toThrowErrorMatchingSnapshot();\n  expect(() => new LeakDetector(false)).toThrowErrorMatchingSnapshot();\n  expect(() => new LeakDetector(42)).toThrowErrorMatchingSnapshot();\n  expect(() => new LeakDetector('foo')).toThrowErrorMatchingSnapshot();\n  expect(() => new LeakDetector(Symbol())).toThrowErrorMatchingSnapshot();\n  expect(() => new LeakDetector(Symbol('foo'))).toThrowErrorMatchingSnapshot();\n  expect(() => new LeakDetector(Number.NaN)).toThrowErrorMatchingSnapshot();\n});\n\nit('does not show the GC if hidden', async () => {\n  const detector = new LeakDetector({});\n\n  // @ts-expect-error: purposefully removed\n  globalThis.gc = undefined;\n  await detector.isLeaking();\n  expect(globalThis.gc).toBeUndefined();\n});\n\nit('does not hide the GC if visible', async () => {\n  const detector = new LeakDetector({});\n\n  globalThis.gc = () => {};\n  await detector.isLeaking();\n  expect(globalThis.gc).toBeDefined();\n});\n\nit('correctly checks simple leaks', async () => {\n  let reference: unknown = {};\n  let isLeaking: boolean;\n\n  const detector = new LeakDetector(reference);\n\n  // Reference is still held in memory.\n  isLeaking = await detector.isLeaking();\n  expect(isLeaking).toBe(true);\n\n  // We destroy the only reference to the object we had.\n  reference = null;\n\n  // Reference should be gone.\n  isLeaking = await detector.isLeaking();\n  expect(isLeaking).toBe(false);\n});\n\nit('tests different objects', async () => {\n  const refs = [\n    function () {},\n    () => {},\n    Object.create(null),\n    [],\n    /foo/g,\n    new Date(1234),\n    {},\n  ];\n\n  const detectors = refs.map(ref => new LeakDetector(ref));\n\n  let isLeaking: boolean;\n  for (const i in detectors) {\n    isLeaking = await detectors[i].isLeaking();\n    expect(isLeaking).toBe(true);\n    refs[i] = null;\n  }\n\n  for (const i in detectors) {\n    isLeaking = await detectors[i].isLeaking();\n    expect(isLeaking).toBe(false);\n  }\n});\n\nit('correctly checks more complex leaks', async () => {\n  let ref1: any = {};\n  let ref2: any = {};\n\n  // Create a circular dependency between ref1 and ref2.\n  ref1.ref2 = ref2;\n  ref2.ref1 = ref1;\n\n  const detector1 = new LeakDetector(ref1);\n  const detector2 = new LeakDetector(ref2);\n\n  let isLeaking1: boolean;\n  let isLeaking2: boolean;\n\n  // References are still held in memory.\n  isLeaking1 = await detector1.isLeaking();\n  expect(isLeaking1).toBe(true);\n  isLeaking2 = await detector2.isLeaking();\n  expect(isLeaking2).toBe(true);\n\n  // We destroy the reference to ref1.\n  ref1 = null;\n\n  // It will still be referenced by ref2, so both references are still leaking.\n  isLeaking1 = await detector1.isLeaking();\n  expect(isLeaking1).toBe(true);\n  isLeaking2 = await detector2.isLeaking();\n  expect(isLeaking2).toBe(true);\n\n  // We destroy the reference to ref2.\n  ref2 = null;\n\n  // Now both references should be gone (yay mark & sweep!).\n  isLeaking1 = await detector1.isLeaking();\n  expect(isLeaking1).toBe(false);\n  isLeaking2 = await detector2.isLeaking();\n  expect(isLeaking2).toBe(false);\n});\n",
  "packages/jest-leak-detector/src/__tests__/index.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-jasmine2/src/types.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {AssertionError} from 'assert';\nimport type * as Process from 'process';\nimport type {AsymmetricMatchers, JestExpect} from '@jest/expect';\nimport type CallTracker from './jasmine/CallTracker';\nimport type Env from './jasmine/Env';\nimport type JsApiReporter from './jasmine/JsApiReporter';\nimport type ReportDispatcher from './jasmine/ReportDispatcher';\nimport type {default as Spec, SpecResult} from './jasmine/Spec';\nimport type SpyStrategy from './jasmine/SpyStrategy';\nimport type {default as Suite, SuiteResult} from './jasmine/Suite';\nimport type Timer from './jasmine/Timer';\nimport type createSpy from './jasmine/createSpy';\nimport type SpyRegistry from './jasmine/spyRegistry';\n\nexport type SpecDefinitionsFn = () => void;\n\nexport interface AssertionErrorWithStack extends AssertionError {\n  stack: string;\n}\n\nexport type RunDetails = {\n  totalSpecsDefined?: number;\n  failedExpectations?: SuiteResult['failedExpectations'];\n};\n\nexport type Reporter = {\n  jasmineDone: (runDetails: RunDetails) => void;\n  jasmineStarted: (runDetails: RunDetails) => void;\n  specDone: (result: SpecResult) => void;\n  specStarted: (spec: SpecResult) => void;\n  suiteDone: (result: SuiteResult) => void;\n  suiteStarted: (result: SuiteResult) => void;\n};\n\nexport interface Spy extends Record<string, any> {\n  (this: Record<string, unknown>, ...args: Array<any>): unknown;\n  and: SpyStrategy;\n  calls: CallTracker;\n  restoreObjectToOriginalState?: () => void;\n}\n\ntype JasmineMatcher = {\n  (matchersUtil: unknown, context: unknown): JasmineMatcher;\n  compare(...args: Array<unknown>): unknown;\n  negativeCompare(...args: Array<unknown>): unknown;\n};\n\nexport type JasmineMatchersObject = {[id: string]: JasmineMatcher};\n\nexport type Jasmine = {\n  _DEFAULT_TIMEOUT_INTERVAL: number;\n  DEFAULT_TIMEOUT_INTERVAL: number;\n  currentEnv_: ReturnType<typeof Env>['prototype'];\n  getEnv: () => ReturnType<typeof Env>['prototype'];\n  createSpy: typeof createSpy;\n  Env: ReturnType<typeof Env>;\n  JsApiReporter: typeof JsApiReporter;\n  ReportDispatcher: typeof ReportDispatcher;\n  Spec: typeof Spec;\n  SpyRegistry: typeof SpyRegistry;\n  Suite: typeof Suite;\n  Timer: typeof Timer;\n  version: string;\n  testPath: string;\n  addMatchers: (matchers: JasmineMatchersObject) => void;\n} & AsymmetricMatchers & {process: typeof Process};\n\ndeclare global {\n  // eslint-disable-next-line @typescript-eslint/no-namespace\n  namespace NodeJS {\n    interface Global {\n      expect: JestExpect;\n      jasmine: Jasmine;\n    }\n  }\n}\n\ndeclare module '@jest/types' {\n  // eslint-disable-next-line @typescript-eslint/no-namespace\n  namespace Global {\n    interface GlobalAdditions {\n      jasmine: Jasmine;\n      fail: () => void;\n      pending: () => void;\n      spyOn: () => void;\n      spyOnProperty: () => void;\n    }\n  }\n}\n",
  "packages/jest-jasmine2/src/types.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { AssertionError } from 'assert';\nimport type * as Process from 'process';\nimport type { AsymmetricMatchers, JestExpect } from '@jest/expect';\nimport type CallTracker from './jasmine/CallTracker';\nimport type Env from './jasmine/Env';\nimport type JsApiReporter from './jasmine/JsApiReporter';\nimport type ReportDispatcher from './jasmine/ReportDispatcher';\nimport type { default as Spec, SpecResult } from './jasmine/Spec';\nimport type SpyStrategy from './jasmine/SpyStrategy';\nimport type { default as Suite, SuiteResult } from './jasmine/Suite';\nimport type Timer from './jasmine/Timer';\nimport type createSpy from './jasmine/createSpy';\nimport type SpyRegistry from './jasmine/spyRegistry';\nexport type SpecDefinitionsFn = () => void;\nexport interface AssertionErrorWithStack extends AssertionError {\n    stack: string;\n}\nexport type RunDetails = {\n    totalSpecsDefined?: number;\n    failedExpectations?: SuiteResult['failedExpectations'];\n};\nexport type Reporter = {\n    jasmineDone: (runDetails: RunDetails) => void;\n    jasmineStarted: (runDetails: RunDetails) => void;\n    specDone: (result: SpecResult) => void;\n    specStarted: (spec: SpecResult) => void;\n    suiteDone: (result: SuiteResult) => void;\n    suiteStarted: (result: SuiteResult) => void;\n};\nexport interface Spy extends Record<string, any> {\n    (this: Record<string, unknown>, ...args: Array<any>): unknown;\n    and: SpyStrategy;\n    calls: CallTracker;\n    restoreObjectToOriginalState?: () => void;\n}\ntype JasmineMatcher = {\n    (matchersUtil: unknown, context: unknown): JasmineMatcher;\n    compare(...args: Array<unknown>): unknown;\n    negativeCompare(...args: Array<unknown>): unknown;\n};\nexport type JasmineMatchersObject = {\n    [id: string]: JasmineMatcher;\n};\nexport type Jasmine = {\n    _DEFAULT_TIMEOUT_INTERVAL: number;\n    DEFAULT_TIMEOUT_INTERVAL: number;\n    currentEnv_: ReturnType<typeof Env>['prototype'];\n    getEnv: () => ReturnType<typeof Env>['prototype'];\n    createSpy: typeof createSpy;\n    Env: ReturnType<typeof Env>;\n    JsApiReporter: typeof JsApiReporter;\n    ReportDispatcher: typeof ReportDispatcher;\n    Spec: typeof Spec;\n    SpyRegistry: typeof SpyRegistry;\n    Suite: typeof Suite;\n    Timer: typeof Timer;\n    version: string;\n    testPath: string;\n    addMatchers: (matchers: JasmineMatchersObject) => void;\n} & AsymmetricMatchers & {\n    process: typeof Process;\n};\ndeclare global {\n    namespace NodeJS {\n        interface Global {\n            expect: JestExpect;\n            jasmine: Jasmine;\n        }\n    }\n}\ndeclare module '@jest/types' {\n    namespace Global {\n        interface GlobalAdditions {\n            jasmine: Jasmine;\n            fail: () => void;\n            pending: () => void;\n            spyOn: () => void;\n            spyOnProperty: () => void;\n        }\n    }\n}\nexport {};\n",
  "packages/jest-jasmine2/src/treeProcessor.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type Suite from './jasmine/Suite';\n\ntype Options = {\n  nodeComplete: (suite: TreeNode) => void;\n  nodeStart: (suite: TreeNode) => void;\n  queueRunnerFactory: any;\n  runnableIds: Array<string>;\n  tree: TreeNode;\n};\n\nexport type TreeNode = {\n  afterAllFns: Array<unknown>;\n  beforeAllFns: Array<unknown>;\n  disabled?: boolean;\n  execute: (onComplete: () => void, enabled: boolean) => void;\n  id: string;\n  onException: (error: Error) => void;\n  sharedUserContext: () => unknown;\n  children?: Array<TreeNode>;\n} & Pick<Suite, 'getResult' | 'parentSuite' | 'result' | 'markedPending'>;\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nconst noop = () => {};\n\nfunction getNodeWithoutChildrenHandler(node: TreeNode, enabled: boolean) {\n  return function fn(done: (error?: unknown) => void = noop) {\n    node.execute(done, enabled);\n  };\n}\n\nfunction hasNoEnabledTest(node: TreeNode): boolean {\n  return (\n    node.disabled ||\n    node.markedPending ||\n    (node.children?.every(hasNoEnabledTest) ?? false)\n  );\n}\n\nexport default function treeProcessor(options: Options): void {\n  const {nodeComplete, nodeStart, queueRunnerFactory, runnableIds, tree} =\n    options;\n\n  function isEnabled(node: TreeNode, parentEnabled: boolean) {\n    return parentEnabled || runnableIds.includes(node.id);\n  }\n\n  function getNodeHandler(node: TreeNode, parentEnabled: boolean) {\n    const enabled = isEnabled(node, parentEnabled);\n    return node.children\n      ? getNodeWithChildrenHandler(node, enabled)\n      : getNodeWithoutChildrenHandler(node, enabled);\n  }\n\n  function getNodeWithChildrenHandler(node: TreeNode, enabled: boolean) {\n    return async function fn(done: (error?: unknown) => void = noop) {\n      nodeStart(node);\n      await queueRunnerFactory({\n        onException: (error: Error) => node.onException(error),\n        queueableFns: wrapChildren(node, enabled),\n        userContext: node.sharedUserContext(),\n      });\n      nodeComplete(node);\n      done();\n    };\n  }\n\n  function wrapChildren(node: TreeNode, enabled: boolean) {\n    if (!node.children) {\n      throw new Error('`node.children` is not defined.');\n    }\n    const children = node.children.map(child => ({\n      fn: getNodeHandler(child, enabled),\n    }));\n    if (hasNoEnabledTest(node)) {\n      return children;\n    }\n    return [...node.beforeAllFns, ...children, ...node.afterAllFns];\n  }\n\n  const treeHandler = getNodeHandler(tree, false);\n  return treeHandler();\n}\n",
  "packages/jest-jasmine2/src/treeProcessor.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type Suite from './jasmine/Suite';\ntype Options = {\n    nodeComplete: (suite: TreeNode) => void;\n    nodeStart: (suite: TreeNode) => void;\n    queueRunnerFactory: any;\n    runnableIds: Array<string>;\n    tree: TreeNode;\n};\nexport type TreeNode = {\n    afterAllFns: Array<unknown>;\n    beforeAllFns: Array<unknown>;\n    disabled?: boolean;\n    execute: (onComplete: () => void, enabled: boolean) => void;\n    id: string;\n    onException: (error: Error) => void;\n    sharedUserContext: () => unknown;\n    children?: Array<TreeNode>;\n} & Pick<Suite, 'getResult' | 'parentSuite' | 'result' | 'markedPending'>;\nexport default function treeProcessor(options: Options): void;\nexport {};\n",
  "packages/jest-jasmine2/src/setup_jest_globals.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {jestExpect} from '@jest/expect';\nimport type {Config} from '@jest/types';\nimport {\n  SnapshotState,\n  addSerializer,\n  buildSnapshotResolver,\n} from 'jest-snapshot';\nimport type {Plugin} from 'pretty-format';\nimport type {\n  Attributes,\n  default as JasmineSpec,\n  SpecResult,\n} from './jasmine/Spec';\n\nexport type SetupOptions = {\n  config: Config.ProjectConfig;\n  globalConfig: Config.GlobalConfig;\n  localRequire: (moduleName: string) => Plugin;\n  testPath: string;\n};\n\n// Get suppressed errors form  jest-matchers that weren't throw during\n// test execution and add them to the test result, potentially failing\n// a passing test.\nconst addSuppressedErrors = (result: SpecResult) => {\n  const {suppressedErrors} = jestExpect.getState();\n  jestExpect.setState({suppressedErrors: []});\n  if (suppressedErrors.length > 0) {\n    result.status = 'failed';\n\n    result.failedExpectations = suppressedErrors.map(error => ({\n      actual: '',\n      // passing error for custom test reporters\n      error,\n      expected: '',\n      matcherName: '',\n      message: error.message,\n      passed: false,\n      stack: error.stack,\n    }));\n  }\n};\n\nconst addAssertionErrors = (result: SpecResult) => {\n  const assertionErrors = jestExpect.extractExpectedAssertionsErrors();\n  if (assertionErrors.length > 0) {\n    const jasmineErrors = assertionErrors.map(({actual, error, expected}) => ({\n      actual,\n      expected,\n      message: error.stack,\n      passed: false,\n    }));\n    result.status = 'failed';\n    result.failedExpectations = [\n      ...result.failedExpectations,\n      ...jasmineErrors,\n    ];\n  }\n};\n\nconst patchJasmine = () => {\n  // @ts-expect-error: jasmine doesn't exist on globalThis\n  globalThis.jasmine.Spec = (realSpec => {\n    class Spec extends realSpec {\n      constructor(attr: Attributes) {\n        const resultCallback = attr.resultCallback;\n        attr.resultCallback = function (result: SpecResult) {\n          addSuppressedErrors(result);\n          addAssertionErrors(result);\n          resultCallback.call(attr, result);\n        };\n        const onStart = attr.onStart;\n        attr.onStart = (context: JasmineSpec) => {\n          jestExpect.setState({currentTestName: context.getFullName()});\n          onStart?.call(attr, context);\n        };\n        super(attr);\n      }\n    }\n\n    return Spec;\n    // @ts-expect-error: jasmine doesn't exist on globalThis\n  })(globalThis.jasmine.Spec);\n};\n\nexport default async function setupJestGlobals({\n  config,\n  globalConfig,\n  localRequire,\n  testPath,\n}: SetupOptions): Promise<SnapshotState> {\n  // Jest tests snapshotSerializers in order preceding built-in serializers.\n  // Therefore, add in reverse because the last added is the first tested.\n  for (let i = config.snapshotSerializers.length - 1; i >= 0; i--) {\n    addSerializer(localRequire(config.snapshotSerializers[i]));\n  }\n\n  patchJasmine();\n  const {expand, updateSnapshot} = globalConfig;\n  const {prettierPath, rootDir, snapshotFormat} = config;\n  const snapshotResolver = await buildSnapshotResolver(config, localRequire);\n  const snapshotPath = snapshotResolver.resolveSnapshotPath(testPath);\n  const snapshotState = new SnapshotState(snapshotPath, {\n    expand,\n    prettierPath,\n    rootDir,\n    snapshotFormat,\n    updateSnapshot,\n  });\n\n  jestExpect.setState({snapshotState, testPath});\n  // Return it back to the outer scope (test runner outside the VM).\n  return snapshotState;\n}\n",
  "packages/jest-jasmine2/src/setup_jest_globals.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config } from '@jest/types';\nimport { SnapshotState } from 'jest-snapshot';\nimport type { Plugin } from 'pretty-format';\nexport type SetupOptions = {\n    config: Config.ProjectConfig;\n    globalConfig: Config.GlobalConfig;\n    localRequire: (moduleName: string) => Plugin;\n    testPath: string;\n};\nexport default function setupJestGlobals({ config, globalConfig, localRequire, testPath, }: SetupOptions): Promise<SnapshotState>;\n",
  "packages/jest-jasmine2/src/reporter.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {\n  type AssertionResult,\n  type TestResult,\n  createEmptyTestResult,\n} from '@jest/test-result';\nimport type {Config} from '@jest/types';\nimport {formatResultsErrors} from 'jest-message-util';\nimport type {SpecResult} from './jasmine/Spec';\nimport type {SuiteResult} from './jasmine/Suite';\nimport type {Reporter, RunDetails} from './types';\n\ntype Microseconds = number;\n\nexport default class Jasmine2Reporter implements Reporter {\n  private readonly _testResults: Array<AssertionResult>;\n  private readonly _globalConfig: Config.GlobalConfig;\n  private readonly _config: Config.ProjectConfig;\n  private readonly _currentSuites: Array<string>;\n  private _resolve: any;\n  private readonly _resultsPromise: Promise<TestResult>;\n  private readonly _startTimes: Map<string, Microseconds>;\n  private readonly _testPath: string;\n\n  constructor(\n    globalConfig: Config.GlobalConfig,\n    config: Config.ProjectConfig,\n    testPath: string,\n  ) {\n    this._globalConfig = globalConfig;\n    this._config = config;\n    this._testPath = testPath;\n    this._testResults = [];\n    this._currentSuites = [];\n    this._resolve = null;\n    this._resultsPromise = new Promise(resolve => (this._resolve = resolve));\n    this._startTimes = new Map();\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  jasmineStarted(_runDetails: RunDetails): void {}\n\n  specStarted(spec: SpecResult): void {\n    this._startTimes.set(spec.id, Date.now());\n  }\n\n  specDone(result: SpecResult): void {\n    this._testResults.push(\n      this._extractSpecResults(result, [...this._currentSuites]),\n    );\n  }\n\n  suiteStarted(suite: SuiteResult): void {\n    this._currentSuites.push(suite.description);\n  }\n\n  suiteDone(_result: SuiteResult): void {\n    this._currentSuites.pop();\n  }\n\n  jasmineDone(_runDetails: RunDetails): void {\n    let numFailingTests = 0;\n    let numPassingTests = 0;\n    let numPendingTests = 0;\n    let numTodoTests = 0;\n    const testResults = this._testResults;\n    for (const testResult of testResults) {\n      if (testResult.status === 'failed') {\n        numFailingTests++;\n      } else if (testResult.status === 'pending') {\n        numPendingTests++;\n      } else if (testResult.status === 'todo') {\n        numTodoTests++;\n      } else {\n        numPassingTests++;\n      }\n    }\n\n    const testResult = {\n      ...createEmptyTestResult(),\n      console: null,\n      failureMessage: formatResultsErrors(\n        testResults,\n        this._config,\n        this._globalConfig,\n        this._testPath,\n      ),\n      numFailingTests,\n      numPassingTests,\n      numPendingTests,\n      numTodoTests,\n      snapshot: {\n        added: 0,\n        fileDeleted: false,\n        matched: 0,\n        unchecked: 0,\n        unmatched: 0,\n        updated: 0,\n      },\n      testFilePath: this._testPath,\n      testResults,\n    };\n\n    this._resolve(testResult);\n  }\n\n  getResults(): Promise<TestResult> {\n    return this._resultsPromise;\n  }\n\n  private _addMissingMessageToStack(stack: string, message?: string) {\n    // Some errors (e.g. Angular injection error) don't prepend error.message\n    // to stack, instead the first line of the stack is just plain 'Error'\n    const ERROR_REGEX = /^Error:?\\s*\\n/;\n\n    if (stack && message && !stack.includes(message)) {\n      return message + stack.replace(ERROR_REGEX, '\\n');\n    }\n    return stack;\n  }\n\n  private _extractSpecResults(\n    specResult: SpecResult,\n    ancestorTitles: Array<string>,\n  ): AssertionResult {\n    const status =\n      specResult.status === 'disabled' ? 'pending' : specResult.status;\n    const start = this._startTimes.get(specResult.id);\n    const duration =\n      start && !['pending', 'skipped'].includes(status)\n        ? Date.now() - start\n        : null;\n    const location = specResult.__callsite\n      ? {\n          column: specResult.__callsite.getColumnNumber(),\n          line: specResult.__callsite.getLineNumber(),\n        }\n      : null;\n    const results: AssertionResult = {\n      ancestorTitles,\n      duration,\n      failureDetails: [],\n      failureMessages: [],\n      fullName: specResult.fullName,\n      location,\n      numPassingAsserts: 0, // Jasmine2 only returns an array of failed asserts.\n      status,\n      title: specResult.description,\n    };\n\n    for (const failed of specResult.failedExpectations) {\n      const message =\n        !failed.matcherName && typeof failed.stack === 'string'\n          ? this._addMissingMessageToStack(failed.stack, failed.message)\n          : failed.message || '';\n      results.failureMessages.push(message);\n      results.failureDetails.push(failed);\n    }\n\n    return results;\n  }\n}\n",
  "packages/jest-jasmine2/src/reporter.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { type TestResult } from '@jest/test-result';\nimport type { Config } from '@jest/types';\nimport type { SpecResult } from './jasmine/Spec';\nimport type { SuiteResult } from './jasmine/Suite';\nimport type { Reporter, RunDetails } from './types';\nexport default class Jasmine2Reporter implements Reporter {\n    private readonly _testResults;\n    private readonly _globalConfig;\n    private readonly _config;\n    private readonly _currentSuites;\n    private _resolve;\n    private readonly _resultsPromise;\n    private readonly _startTimes;\n    private readonly _testPath;\n    constructor(globalConfig: Config.GlobalConfig, config: Config.ProjectConfig, testPath: string);\n    jasmineStarted(_runDetails: RunDetails): void;\n    specStarted(spec: SpecResult): void;\n    specDone(result: SpecResult): void;\n    suiteStarted(suite: SuiteResult): void;\n    suiteDone(_result: SuiteResult): void;\n    jasmineDone(_runDetails: RunDetails): void;\n    getResults(): Promise<TestResult>;\n    private _addMissingMessageToStack;\n    private _extractSpecResults;\n}\n",
  "packages/jest-jasmine2/src/queueRunner.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {formatTime} from 'jest-util';\nimport PCancelable from './PCancelable';\nimport pTimeout from './pTimeout';\n\nexport type Options = {\n  clearTimeout: (typeof globalThis)['clearTimeout'];\n  fail: (error: Error) => void;\n  onException: (error: Error) => void;\n  queueableFns: Array<QueueableFn>;\n  setTimeout: (typeof globalThis)['setTimeout'];\n  userContext: unknown;\n};\n\nexport interface DoneFn {\n  (error?: any): void;\n  fail: (error: Error) => void;\n}\n\nexport type QueueableFn = {\n  fn: (done: DoneFn) => void;\n  timeout?: () => number;\n  initError?: Error;\n};\n\ntype PromiseCallback = (() => void | PromiseLike<void>) | undefined | null;\n\nexport default function queueRunner(options: Options): PromiseLike<void> & {\n  cancel: () => void;\n  catch: (onRejected?: PromiseCallback) => Promise<void>;\n} {\n  const token = new PCancelable<void>((onCancel, resolve) => {\n    onCancel(resolve);\n  });\n\n  // eslint-disable-next-line unicorn/error-message\n  const mapper = ({fn, timeout, initError = new Error()}: QueueableFn) => {\n    let promise = new Promise<void>(resolve => {\n      const next = function (...args: [Error]) {\n        const err = args[0];\n        if (err) {\n          options.fail.apply(null, args);\n        }\n        resolve();\n      };\n\n      next.fail = function (...args: [Error]) {\n        options.fail.apply(null, args);\n        resolve();\n      };\n      try {\n        fn.call(options.userContext, next);\n      } catch (error: any) {\n        options.onException(error);\n        resolve();\n      }\n    });\n\n    promise = Promise.race<void>([promise, token]);\n\n    if (!timeout) {\n      return promise;\n    }\n\n    const timeoutMs: number = timeout();\n\n    return pTimeout(\n      promise,\n      timeoutMs,\n      options.clearTimeout,\n      options.setTimeout,\n      () => {\n        initError.message = `Timeout - Async callback was not invoked within the ${formatTime(\n          timeoutMs,\n        )} timeout specified by jest.setTimeout.`;\n        initError.stack = initError.message + initError.stack;\n        options.onException(initError);\n      },\n    );\n  };\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve(),\n  );\n\n  return {\n    cancel: token.cancel.bind(token),\n    catch: result.catch.bind(result),\n    // eslint-disable-next-line unicorn/no-thenable\n    then: result.then.bind(result),\n  };\n}\n",
  "packages/jest-jasmine2/src/queueRunner.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport type Options = {\n    clearTimeout: (typeof globalThis)['clearTimeout'];\n    fail: (error: Error) => void;\n    onException: (error: Error) => void;\n    queueableFns: Array<QueueableFn>;\n    setTimeout: (typeof globalThis)['setTimeout'];\n    userContext: unknown;\n};\nexport interface DoneFn {\n    (error?: any): void;\n    fail: (error: Error) => void;\n}\nexport type QueueableFn = {\n    fn: (done: DoneFn) => void;\n    timeout?: () => number;\n    initError?: Error;\n};\ntype PromiseCallback = (() => void | PromiseLike<void>) | undefined | null;\nexport default function queueRunner(options: Options): PromiseLike<void> & {\n    cancel: () => void;\n    catch: (onRejected?: PromiseCallback) => Promise<void>;\n};\nexport {};\n",
  "packages/jest-jasmine2/src/pTimeout.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// A specialized version of `p-timeout` that does not touch globals.\n// It does not throw on timeout.\nexport default function pTimeout(\n  promise: Promise<void>,\n  ms: number,\n  clearTimeout: (typeof globalThis)['clearTimeout'],\n  setTimeout: (typeof globalThis)['setTimeout'],\n  onTimeout: () => void,\n): Promise<void> {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => resolve(onTimeout()), ms);\n    promise.then(\n      val => {\n        clearTimeout(timer);\n        resolve(val);\n      },\n      error => {\n        clearTimeout(timer);\n        reject(error);\n      },\n    );\n  });\n}\n",
  "packages/jest-jasmine2/src/pTimeout.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport default function pTimeout(promise: Promise<void>, ms: number, clearTimeout: (typeof globalThis)['clearTimeout'], setTimeout: (typeof globalThis)['setTimeout'], onTimeout: () => void): Promise<void>;\n",
  "packages/jest-jasmine2/src/jestExpect.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/* eslint-disable local/prefer-spread-eventually */\n\nimport {jestExpect} from '@jest/expect';\nimport type {Global} from '@jest/types';\nimport type {JasmineMatchersObject} from './types';\n\nexport default function jestExpectAdapter(config: {expand: boolean}): void {\n  (globalThis as Global.Global).expect = jestExpect;\n  jestExpect.setState({expand: config.expand});\n\n  const jasmine = (globalThis as Global.Global).jasmine;\n  jasmine.anything = jestExpect.anything;\n  jasmine.any = jestExpect.any;\n  jasmine.objectContaining = jestExpect.objectContaining;\n  jasmine.arrayContaining = jestExpect.arrayContaining;\n  jasmine.stringMatching = jestExpect.stringMatching;\n\n  jasmine.addMatchers = (jasmineMatchersObject: JasmineMatchersObject) => {\n    const jestMatchersObject = Object.create(null);\n    for (const name of Object.keys(jasmineMatchersObject)) {\n      jestMatchersObject[name] = function (...args: Array<unknown>) {\n        // use \"expect.extend\" if you need to use equality testers (via this.equal)\n        const result = jasmineMatchersObject[name](null, null);\n        // if there is no 'negativeCompare', both should be handled by `compare`\n        const negativeCompare = result.negativeCompare || result.compare;\n\n        return this.isNot\n          ? negativeCompare.apply(null, args)\n          : result.compare.apply(null, args);\n      };\n    }\n\n    jestExpect.extend(jestMatchersObject);\n  };\n}\n",
  "packages/jest-jasmine2/src/jestExpect.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport default function jestExpectAdapter(config: {\n    expand: boolean;\n}): void;\n",
  "packages/jest-jasmine2/src/jasmineAsyncInstall.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/**\n * This module adds ability to test async promise code with jasmine by\n * returning a promise from `it/test` and `before/afterEach/All` blocks.\n */\n\nimport co from 'co';\nimport isGeneratorFn from 'is-generator-fn';\nimport pLimit from 'p-limit';\nimport type {Config, Global} from '@jest/types';\nimport {isPromise} from 'jest-util';\nimport isError from './isError';\nimport type Spec from './jasmine/Spec';\nimport type {DoneFn, QueueableFn} from './queueRunner';\nimport type {Jasmine} from './types';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nconst doneFnNoop = () => {};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\ndoneFnNoop.fail = () => {};\n\nfunction promisifyLifeCycleFunction(\n  originalFn: (beforeAllFunction: QueueableFn['fn'], timeout?: number) => void,\n  env: Jasmine['currentEnv_'],\n) {\n  return function <T>(\n    fn:\n      | ((done: DoneFn) => void | PromiseLike<T>)\n      | (() => Promise<T>)\n      | GeneratorFunction\n      | undefined,\n    timeout?: number,\n  ): void {\n    if (!fn) {\n      // @ts-expect-error: missing fn arg is handled by originalFn\n      return originalFn.call(env);\n    }\n\n    if (typeof fn !== 'function') {\n      // Pass non-functions to Jest, which throws a nice error.\n      return originalFn.call(env, fn, timeout);\n    }\n\n    const hasDoneCallback = fn.length > 0;\n\n    if (hasDoneCallback) {\n      // Give the function a name so it can be detected in call stacks, but\n      // otherwise Jasmine will handle it.\n      const asyncJestLifecycleWithCallback = function (\n        this: Global.TestContext,\n        ...args: Array<any>\n      ) {\n        // @ts-expect-error: Support possible extra args at runtime\n        return fn.apply(this, args);\n      };\n      return originalFn.call(env, asyncJestLifecycleWithCallback, timeout);\n    }\n\n    // eslint-disable-next-line unicorn/error-message\n    const extraError = new Error();\n\n    // Without this line v8 stores references to all closures\n    // in the stack in the Error object. This line stringifies the stack\n    // property to allow garbage-collecting objects on the stack\n    // https://crbug.com/v8/7142\n    const originalExtraErrorStack = extraError.stack;\n    extraError.stack = originalExtraErrorStack;\n\n    // We make *all* functions async and run `done` right away if they\n    // didn't return a promise.\n    const asyncJestLifecycle = function (done: DoneFn) {\n      const wrappedFn = isGeneratorFn(fn) ? co.wrap(fn) : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), (error: Error) => {\n          const {isError: checkIsError, message} = isError(error);\n\n          if (message) {\n            extraError.message = message;\n            extraError.stack =\n              originalExtraErrorStack &&\n              originalExtraErrorStack.replace('Error: ', `Error: ${message}`);\n          }\n          done.fail(checkIsError ? error : extraError);\n        });\n      } else {\n        done();\n      }\n    };\n\n    return originalFn.call(env, asyncJestLifecycle, timeout);\n  };\n}\n\n// Similar to promisifyLifeCycleFunction but throws an error\n// when the return value is neither a Promise nor `undefined`\nfunction promisifyIt(\n  originalFn: (\n    description: Global.TestNameLike,\n    fn: QueueableFn['fn'],\n    timeout?: number,\n  ) => Spec,\n  env: Jasmine['currentEnv_'],\n  jasmine: Jasmine,\n) {\n  return function (\n    specName: Global.TestNameLike,\n    fn?: (done: DoneFn) => void | PromiseLike<void>,\n    timeout?: number,\n  ): Spec {\n    if (!fn) {\n      // @ts-expect-error: missing fn arg is handled by originalFn\n      const spec = originalFn.call(env, specName);\n      spec.pend('not implemented');\n      return spec;\n    }\n\n    if (typeof fn !== 'function') {\n      // Pass non-functions to Jest, which throws a nice error.\n      return originalFn.call(env, specName, fn, timeout);\n    }\n\n    const hasDoneCallback = fn.length > 0;\n\n    if (hasDoneCallback) {\n      // Give the function a name so it can be detected in call stacks, but\n      // otherwise Jasmine will handle it.\n      const asyncJestTestWithCallback = function (\n        this: Global.TestContext,\n        ...args: Array<any>\n      ) {\n        // @ts-expect-error: Support possible extra args at runtime\n        return fn.apply(this, args);\n      };\n      return originalFn.call(env, specName, asyncJestTestWithCallback, timeout);\n    }\n\n    // eslint-disable-next-line unicorn/error-message\n    const extraError = new Error();\n\n    // Without this line v8 stores references to all closures\n    // in the stack in the Error object. This line stringifies the stack\n    // property to allow garbage-collecting objects on the stack\n    // https://crbug.com/v8/7142\n    const originalExtraErrorStack = extraError.stack;\n    extraError.stack = originalExtraErrorStack;\n\n    const asyncJestTest = function (done: DoneFn) {\n      const wrappedFn = isGeneratorFn(fn) ? co.wrap(fn) : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), (error: Error) => {\n          const {isError: checkIsError, message} = isError(error);\n\n          if (message) {\n            extraError.message = message;\n            extraError.stack =\n              originalExtraErrorStack &&\n              originalExtraErrorStack.replace('Error: ', `Error: ${message}`);\n          }\n\n          if (jasmine.Spec.isPendingSpecException(error)) {\n            env.pending(message!);\n            done();\n          } else {\n            done.fail(checkIsError ? error : extraError);\n          }\n        });\n      } else if (returnValue === undefined) {\n        done();\n      } else {\n        done.fail(\n          new Error(\n            'Jest: `it` and `test` must return either a Promise or undefined.',\n          ),\n        );\n      }\n    };\n\n    return originalFn.call(env, specName, asyncJestTest, timeout);\n  };\n}\n\nfunction makeConcurrent(\n  originalFn: (\n    description: Global.TestNameLike,\n    fn: QueueableFn['fn'],\n    timeout?: number,\n  ) => Spec,\n  env: Jasmine['currentEnv_'],\n  mutex: ReturnType<typeof pLimit>,\n): Global.ItConcurrentBase {\n  const concurrentFn = function (\n    specName: Global.TestNameLike,\n    fn: Global.ConcurrentTestFn,\n    timeout?: number,\n  ) {\n    let promise: Promise<unknown> = Promise.resolve();\n\n    const spec = originalFn.call(env, specName, () => promise, timeout);\n    if (env != null && !env.specFilter(spec)) {\n      return spec;\n    }\n\n    try {\n      promise = mutex(() => {\n        const promise = fn();\n        if (isPromise(promise)) {\n          return promise;\n        }\n        throw new Error(\n          `Jest: concurrent test \"${spec.getFullName()}\" must return a Promise.`,\n        );\n      });\n    } catch (error) {\n      promise = Promise.reject(error);\n    }\n    // Avoid triggering the uncaught promise rejection handler in case the test errors before\n    // being awaited on.\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    promise.catch(() => {});\n\n    return spec;\n  };\n\n  // eslint-disable-next-line unicorn/consistent-function-scoping\n  const failing = () => {\n    throw new Error(\n      'Jest: `failing` tests are only supported in `jest-circus`.',\n    );\n  };\n\n  failing.each = () => {\n    throw new Error(\n      'Jest: `failing` tests are only supported in `jest-circus`.',\n    );\n  };\n  // each is bound after the function is made concurrent, so for now it is made noop\n  // eslint-disable-next-line @typescript-eslint/no-empty-function,unicorn/consistent-function-scoping\n  concurrentFn.each = () => () => {};\n  concurrentFn.failing = failing;\n\n  return concurrentFn;\n}\n\nexport default function jasmineAsyncInstall(\n  globalConfig: Config.GlobalConfig,\n  global: Global.Global,\n): void {\n  const jasmine = global.jasmine;\n  const mutex = pLimit(globalConfig.maxConcurrency);\n\n  const env = jasmine.getEnv();\n  env.it = promisifyIt(env.it, env, jasmine);\n  env.fit = promisifyIt(env.fit, env, jasmine);\n  global.it.concurrent = (env => {\n    const concurrent = makeConcurrent(\n      env.it,\n      env,\n      mutex,\n    ) as Global.ItConcurrentExtended;\n    concurrent.only = makeConcurrent(env.fit, env, mutex);\n    concurrent.skip = makeConcurrent(env.xit, env, mutex);\n    return concurrent;\n  })(env);\n  global.fit.concurrent = makeConcurrent(env.fit, env, mutex);\n  env.afterAll = promisifyLifeCycleFunction(env.afterAll, env);\n  env.afterEach = promisifyLifeCycleFunction(env.afterEach, env);\n  env.beforeAll = promisifyLifeCycleFunction(env.beforeAll, env);\n  env.beforeEach = promisifyLifeCycleFunction(env.beforeEach, env);\n}\n",
  "packages/jest-jasmine2/src/jasmineAsyncInstall.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config, Global } from '@jest/types';\nexport default function jasmineAsyncInstall(globalConfig: Config.GlobalConfig, global: Global.Global): void;\n",
  "packages/jest-jasmine2/src/isError.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {format as prettyFormat} from 'pretty-format';\n\nexport default function isError(\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  potentialError: any,\n): {isError: boolean; message: string | null} {\n  // duck-type Error, see #2549\n  const isError =\n    potentialError !== null &&\n    typeof potentialError === 'object' &&\n    typeof potentialError.message === 'string' &&\n    typeof potentialError.name === 'string';\n\n  const message = isError\n    ? null\n    : `Failed: ${prettyFormat(potentialError, {maxDepth: 3})}`;\n\n  return {isError, message};\n}\n",
  "packages/jest-jasmine2/src/isError.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport default function isError(potentialError: any): {\n    isError: boolean;\n    message: string | null;\n};\n",
  "packages/jest-jasmine2/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport type {JestEnvironment} from '@jest/environment';\nimport {getCallsite} from '@jest/source-map';\nimport type {TestResult} from '@jest/test-result';\nimport type {Config, Global} from '@jest/types';\nimport type Runtime from 'jest-runtime';\nimport type {SnapshotState} from 'jest-snapshot';\nimport {ErrorWithStack} from 'jest-util';\nimport installEach from './each';\nimport {installErrorOnPrivate} from './errorOnPrivate';\nimport type Spec from './jasmine/Spec';\nimport jasmineAsyncInstall from './jasmineAsyncInstall';\nimport JasmineReporter from './reporter';\n\nexport type {Jasmine} from './types';\n\nconst JASMINE = require.resolve('./jasmine/jasmineLight');\n\nconst jestEachBuildDir = path.dirname(require.resolve('jest-each'));\n\nexport default async function jasmine2(\n  globalConfig: Config.GlobalConfig,\n  config: Config.ProjectConfig,\n  environment: JestEnvironment,\n  runtime: Runtime,\n  testPath: string,\n): Promise<TestResult> {\n  const reporter = new JasmineReporter(globalConfig, config, testPath);\n  const jasmineFactory =\n    runtime.requireInternalModule<typeof import('./jasmine/jasmineLight')>(\n      JASMINE,\n    );\n  const jasmine = jasmineFactory.create({\n    process,\n    testPath,\n    testTimeout: globalConfig.testTimeout,\n  });\n\n  const env = jasmine.getEnv();\n  const jasmineInterface = jasmineFactory._interface(jasmine, env);\n  Object.assign(environment.global, jasmineInterface);\n  env.addReporter(jasmineInterface.jsApiReporter);\n\n  // TODO: Remove config option if V8 exposes some way of getting location of caller\n  // in a future version\n  if (config.testLocationInResults === true) {\n    function wrapIt<T extends Global.ItBase>(original: T): T {\n      const wrapped = (\n        testName: Global.TestName,\n        fn: Global.TestFn,\n        timeout?: number,\n      ) => {\n        const sourcemaps = runtime.getSourceMaps();\n        let stack = getCallsite(1, sourcemaps);\n        const it = original(testName, fn, timeout);\n\n        if (stack.getFileName()?.startsWith(jestEachBuildDir)) {\n          stack = getCallsite(2, sourcemaps);\n        }\n        // @ts-expect-error: `it` is `void` for some reason\n        it.result.__callsite = stack;\n\n        return it;\n      };\n      return wrapped as any as T;\n    }\n\n    environment.global.it = wrapIt(environment.global.it);\n    environment.global.xit = wrapIt(environment.global.xit);\n    environment.global.fit = wrapIt(environment.global.fit);\n  }\n\n  jasmineAsyncInstall(globalConfig, environment.global);\n\n  installEach(environment);\n\n  const failing = () => {\n    throw new ErrorWithStack(\n      'Jest: `failing` tests are only supported in `jest-circus`.',\n      failing,\n    );\n  };\n\n  failing.each = () => {\n    throw new ErrorWithStack(\n      'Jest: `failing` tests are only supported in `jest-circus`.',\n      failing.each,\n    );\n  };\n\n  environment.global.it.failing = failing;\n  environment.global.fit.failing = failing;\n  environment.global.xit.failing = failing;\n\n  environment.global.test = environment.global.it;\n  environment.global.it.only = environment.global.fit;\n  environment.global.it.todo = env.todo;\n  environment.global.it.skip = environment.global.xit;\n  environment.global.xtest = environment.global.xit;\n  environment.global.describe.skip = environment.global.xdescribe;\n  environment.global.describe.only = environment.global.fdescribe;\n\n  if (config.fakeTimers.enableGlobally) {\n    if (config.fakeTimers.legacyFakeTimers) {\n      environment.fakeTimers!.useFakeTimers();\n    } else {\n      environment.fakeTimersModern!.useFakeTimers();\n    }\n  }\n\n  env.beforeEach(() => {\n    if (config.resetModules) {\n      runtime.resetModules();\n    }\n\n    if (config.clearMocks) {\n      runtime.clearAllMocks();\n    }\n\n    if (config.resetMocks) {\n      runtime.resetAllMocks();\n\n      if (\n        config.fakeTimers.enableGlobally &&\n        config.fakeTimers.legacyFakeTimers\n      ) {\n        environment.fakeTimers!.useFakeTimers();\n      }\n    }\n\n    if (config.restoreMocks) {\n      runtime.restoreAllMocks();\n    }\n  });\n\n  env.addReporter(reporter);\n\n  runtime\n    .requireInternalModule<\n      typeof import('./jestExpect')\n    >(require.resolve('./jestExpect.js'))\n    .default({expand: globalConfig.expand});\n\n  if (globalConfig.errorOnDeprecated) {\n    installErrorOnPrivate(environment.global);\n  } else {\n    Object.defineProperty(jasmine, 'DEFAULT_TIMEOUT_INTERVAL', {\n      configurable: true,\n      enumerable: true,\n      get() {\n        return this._DEFAULT_TIMEOUT_INTERVAL;\n      },\n      set(value) {\n        this._DEFAULT_TIMEOUT_INTERVAL = value;\n      },\n    });\n  }\n\n  const snapshotState: SnapshotState = await runtime\n    .requireInternalModule<\n      typeof import('./setup_jest_globals')\n    >(require.resolve('./setup_jest_globals.js'))\n    .default({\n      config,\n      globalConfig,\n      localRequire: runtime.requireModule.bind(runtime),\n      testPath,\n    });\n\n  for (const path of config.setupFilesAfterEnv) {\n    const esm = runtime.unstable_shouldLoadAsEsm(path);\n\n    if (esm) {\n      await runtime.unstable_importModule(path);\n    } else {\n      const setupFile = runtime.requireModule(path);\n      if (typeof setupFile === 'function') {\n        await setupFile();\n      }\n    }\n  }\n\n  if (globalConfig.testNamePattern) {\n    const testNameRegex = new RegExp(globalConfig.testNamePattern, 'i');\n    env.specFilter = (spec: Spec) => testNameRegex.test(spec.getFullName());\n  }\n  const esm = runtime.unstable_shouldLoadAsEsm(testPath);\n\n  if (esm) {\n    await runtime.unstable_importModule(testPath);\n  } else {\n    runtime.requireModule(testPath);\n  }\n\n  await env.execute();\n\n  const results = await reporter.getResults();\n\n  return addSnapshotData(results, snapshotState);\n}\n\nconst addSnapshotData = (results: TestResult, snapshotState: SnapshotState) => {\n  for (const {fullName, status} of results.testResults) {\n    if (status === 'pending' || status === 'failed') {\n      // if test is skipped or failed, we don't want to mark\n      // its snapshots as obsolete.\n      snapshotState.markSnapshotsAsCheckedForTest(fullName);\n    }\n  }\n\n  const uncheckedCount = snapshotState.getUncheckedCount();\n  const uncheckedKeys = snapshotState.getUncheckedKeys();\n\n  if (uncheckedCount) {\n    snapshotState.removeUncheckedKeys();\n  }\n\n  const status = snapshotState.save();\n  results.snapshot.fileDeleted = status.deleted;\n  results.snapshot.added = snapshotState.added;\n  results.snapshot.matched = snapshotState.matched;\n  results.snapshot.unmatched = snapshotState.unmatched;\n  results.snapshot.updated = snapshotState.updated;\n  results.snapshot.unchecked = status.deleted ? 0 : uncheckedCount;\n  // Copy the array to prevent memory leaks\n  results.snapshot.uncheckedKeys = [...uncheckedKeys];\n\n  return results;\n};\n",
  "packages/jest-jasmine2/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { JestEnvironment } from '@jest/environment';\nimport type { TestResult } from '@jest/test-result';\nimport type { Config } from '@jest/types';\nimport type Runtime from 'jest-runtime';\nexport type { Jasmine } from './types';\nexport default function jasmine2(globalConfig: Config.GlobalConfig, config: Config.ProjectConfig, environment: JestEnvironment, runtime: Runtime, testPath: string): Promise<TestResult>;\n",
  "packages/jest-jasmine2/src/expectationResultFactory.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {FailedAssertion} from '@jest/test-result';\nimport {format as prettyFormat} from 'pretty-format';\n\nfunction messageFormatter({error, message, passed}: Options) {\n  if (passed) {\n    return 'Passed.';\n  }\n  if (message) {\n    return message;\n  }\n  if (typeof error === 'string') {\n    return error;\n  }\n  if (\n    // duck-type Error, see #2549\n    error &&\n    typeof error === 'object' &&\n    typeof error.message === 'string' &&\n    typeof error.name === 'string'\n  ) {\n    if (error.message === '') {\n      return error.name;\n    }\n    return `${error.name}: ${error.message}`;\n  }\n  return `thrown: ${prettyFormat(error, {maxDepth: 3})}`;\n}\n\nfunction stackFormatter(\n  options: Options,\n  initError: Error | undefined,\n  errorMessage: string,\n) {\n  if (options.passed) {\n    return '';\n  }\n\n  if (options.error) {\n    if (typeof options.error.stack === 'string') {\n      return options.error.stack;\n    }\n\n    if (options.error === errorMessage) {\n      return errorMessage;\n    }\n  }\n\n  if (initError) {\n    return `${errorMessage.trimEnd()}\\n\\n${initError.stack}`;\n  }\n\n  return new Error(errorMessage).stack;\n}\n\nexport type Options = {\n  matcherName: string;\n  passed: boolean;\n  actual?: any;\n  error?: any;\n  expected?: any;\n  message?: string | null;\n};\n\nexport default function expectationResultFactory(\n  options: Options,\n  initError?: Error,\n): FailedAssertion {\n  const message = messageFormatter(options);\n  const stack = stackFormatter(options, initError, message);\n\n  if (options.passed) {\n    return {\n      error: options.error,\n      matcherName: options.matcherName,\n      message,\n      passed: options.passed,\n      stack,\n    };\n  }\n\n  return {\n    actual: options.actual,\n    error: options.error,\n    expected: options.expected,\n    matcherName: options.matcherName,\n    message,\n    passed: options.passed,\n    stack,\n  };\n}\n",
  "packages/jest-jasmine2/src/expectationResultFactory.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { FailedAssertion } from '@jest/test-result';\nexport type Options = {\n    matcherName: string;\n    passed: boolean;\n    actual?: any;\n    error?: any;\n    expected?: any;\n    message?: string | null;\n};\nexport default function expectationResultFactory(options: Options, initError?: Error): FailedAssertion;\n",
  "packages/jest-jasmine2/src/errorOnPrivate.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {Global} from '@jest/types';\nimport {ErrorWithStack} from 'jest-util';\n\ntype DisabledGlobalKeys = 'fail' | 'pending' | 'spyOn' | 'spyOnProperty';\n\n// prettier-ignore\nconst disabledGlobals: Record<DisabledGlobalKeys, string> = {\n  fail: 'Illegal usage of global `fail`, prefer throwing an error, or the `done.fail` callback.',\n  pending: 'Illegal usage of global `pending`, prefer explicitly skipping a test using `test.skip`',\n  spyOn: 'Illegal usage of global `spyOn`, prefer `jest.spyOn`.',\n  spyOnProperty: 'Illegal usage of global `spyOnProperty`, prefer `jest.spyOn`.',\n};\n\ntype DisabledJasmineMethodsKeys =\n  | 'addMatchers'\n  | 'any'\n  | 'anything'\n  | 'arrayContaining'\n  | 'createSpy'\n  | 'objectContaining'\n  | 'stringMatching';\n\n// prettier-ignore\nconst disabledJasmineMethods: Record<DisabledJasmineMethodsKeys, string> = {\n  addMatchers: 'Illegal usage of `jasmine.addMatchers`, prefer `expect.extends`.',\n  any: 'Illegal usage of `jasmine.any`, prefer `expect.any`.',\n  anything: 'Illegal usage of `jasmine.anything`, prefer `expect.anything`.',\n  arrayContaining: 'Illegal usage of `jasmine.arrayContaining`, prefer `expect.arrayContaining`.',\n  createSpy: 'Illegal usage of `jasmine.createSpy`, prefer `jest.fn`.',\n  objectContaining: 'Illegal usage of `jasmine.objectContaining`, prefer `expect.objectContaining`.',\n  stringMatching: 'Illegal usage of `jasmine.stringMatching`, prefer `expect.stringMatching`.',\n};\n\nexport function installErrorOnPrivate(global: Global.Global): void {\n  const jasmine = global.jasmine;\n\n  for (const functionName of Object.keys(\n    disabledGlobals,\n  ) as Array<DisabledGlobalKeys>) {\n    global[functionName] = () => {\n      throwAtFunction(disabledGlobals[functionName], global[functionName]);\n    };\n  }\n\n  for (const methodName of Object.keys(\n    disabledJasmineMethods,\n  ) as Array<DisabledJasmineMethodsKeys>) {\n    // @ts-expect-error - void unallowd, but it throws 🤷\n    jasmine[methodName] = () => {\n      throwAtFunction(disabledJasmineMethods[methodName], jasmine[methodName]);\n    };\n  }\n\n  function set() {\n    throwAtFunction(\n      'Illegal usage of `jasmine.DEFAULT_TIMEOUT_INTERVAL`, prefer `jest.setTimeout`.',\n      set,\n    );\n  }\n\n  const original = jasmine.DEFAULT_TIMEOUT_INTERVAL;\n\n  Object.defineProperty(jasmine, 'DEFAULT_TIMEOUT_INTERVAL', {\n    configurable: true,\n    enumerable: true,\n    get: () => original,\n    set,\n  });\n}\n\nfunction throwAtFunction(\n  message: string,\n  fn: (...args: Array<any>) => unknown,\n) {\n  throw new ErrorWithStack(message, fn);\n}\n",
  "packages/jest-jasmine2/src/errorOnPrivate.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Global } from '@jest/types';\nexport declare function installErrorOnPrivate(global: Global.Global): void;\n",
  "packages/jest-jasmine2/src/each.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {JestEnvironment} from '@jest/environment';\nimport {bind as bindEach} from 'jest-each';\n\nexport default function each(environment: JestEnvironment): void {\n  environment.global.it.each = bindEach(environment.global.it);\n  environment.global.fit.each = bindEach(environment.global.fit);\n  environment.global.xit.each = bindEach(environment.global.xit);\n  environment.global.describe.each = bindEach(\n    environment.global.describe,\n    false,\n  );\n  environment.global.xdescribe.each = bindEach(\n    environment.global.xdescribe,\n    false,\n  );\n  environment.global.fdescribe.each = bindEach(\n    environment.global.fdescribe,\n    false,\n  );\n  environment.global.it.concurrent.each = bindEach(\n    environment.global.it.concurrent,\n    false,\n  );\n  environment.global.it.concurrent.only.each = bindEach(\n    environment.global.it.concurrent.only,\n    false,\n  );\n  environment.global.it.concurrent.skip.each = bindEach(\n    environment.global.it.concurrent.skip,\n    false,\n  );\n}\n",
  "packages/jest-jasmine2/src/each.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { JestEnvironment } from '@jest/environment';\nexport default function each(environment: JestEnvironment): void;\n",
  "packages/jest-jasmine2/src/assertionErrorMessage.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk from 'chalk';\nimport {\n  type DiffOptions,\n  diff,\n  printExpected,\n  printReceived,\n} from 'jest-matcher-utils';\nimport type {AssertionErrorWithStack} from './types';\n\nconst assertOperatorsMap: Record<string, string> = {\n  '!=': 'notEqual',\n  '!==': 'notStrictEqual',\n  '==': 'equal',\n  '===': 'strictEqual',\n};\n\nconst humanReadableOperators: Record<string, string> = {\n  deepEqual: 'to deeply equal',\n  deepStrictEqual: 'to deeply and strictly equal',\n  equal: 'to be equal',\n  notDeepEqual: 'not to deeply equal',\n  notDeepStrictEqual: 'not to deeply and strictly equal',\n  notEqual: 'to not be equal',\n  notStrictEqual: 'not be strictly equal',\n  strictEqual: 'to strictly be equal',\n};\n\nconst getOperatorName = (operator: string | null, stack: string) => {\n  if (typeof operator === 'string') {\n    return assertOperatorsMap[operator] || operator;\n  }\n  if (stack.match('.doesNotThrow')) {\n    return 'doesNotThrow';\n  }\n  if (stack.match('.throws')) {\n    return 'throws';\n  }\n  return '';\n};\n\nconst operatorMessage = (operator: string | null) => {\n  const niceOperatorName = getOperatorName(operator, '');\n  const humanReadableOperator = humanReadableOperators[niceOperatorName];\n\n  return typeof operator === 'string'\n    ? `${humanReadableOperator || niceOperatorName} to:\\n`\n    : '';\n};\n\nconst assertThrowingMatcherHint = (operatorName: string) =>\n  operatorName\n    ? chalk.dim('assert') +\n      chalk.dim(`.${operatorName}(`) +\n      chalk.red('function') +\n      chalk.dim(')')\n    : '';\n\nconst assertMatcherHint = (\n  operator: string | null,\n  operatorName: string,\n  expected: unknown,\n) => {\n  let message = '';\n\n  if (operator === '==' && expected === true) {\n    message =\n      chalk.dim('assert') +\n      chalk.dim('(') +\n      chalk.red('received') +\n      chalk.dim(')');\n  } else if (operatorName) {\n    message =\n      chalk.dim('assert') +\n      chalk.dim(`.${operatorName}(`) +\n      chalk.red('received') +\n      chalk.dim(', ') +\n      chalk.green('expected') +\n      chalk.dim(')');\n  }\n\n  return message;\n};\n\nfunction assertionErrorMessage(\n  error: AssertionErrorWithStack,\n  options: DiffOptions,\n): string {\n  const {expected, actual, generatedMessage, message, operator, stack} = error;\n  const diffString = diff(expected, actual, options);\n  const hasCustomMessage = !generatedMessage;\n  const operatorName = getOperatorName(operator, stack);\n  const trimmedStack = stack\n    .replace(message, '')\n    .replaceAll(/AssertionError(.*)/g, '');\n\n  if (operatorName === 'doesNotThrow') {\n    return `${\n      buildHintString(assertThrowingMatcherHint(operatorName)) +\n      chalk.reset('Expected the function not to throw an error.\\n') +\n      chalk.reset('Instead, it threw:\\n')\n    }  ${printReceived(actual)}${chalk.reset(\n      hasCustomMessage ? `\\n\\nMessage:\\n  ${message}` : '',\n    )}${trimmedStack}`;\n  }\n\n  if (operatorName === 'throws') {\n    if (error.generatedMessage) {\n      return (\n        buildHintString(assertThrowingMatcherHint(operatorName)) +\n        chalk.reset(error.message) +\n        chalk.reset(hasCustomMessage ? `\\n\\nMessage:\\n  ${message}` : '') +\n        trimmedStack\n      );\n    }\n    return (\n      buildHintString(assertThrowingMatcherHint(operatorName)) +\n      chalk.reset('Expected the function to throw an error.\\n') +\n      chalk.reset(\"But it didn't throw anything.\") +\n      chalk.reset(hasCustomMessage ? `\\n\\nMessage:\\n  ${message}` : '') +\n      trimmedStack\n    );\n  }\n\n  if (operatorName === 'fail') {\n    return (\n      buildHintString(assertMatcherHint(operator, operatorName, expected)) +\n      chalk.reset(hasCustomMessage ? `Message:\\n  ${message}` : '') +\n      trimmedStack\n    );\n  }\n\n  return `${\n    buildHintString(assertMatcherHint(operator, operatorName, expected)) +\n    chalk.reset(`Expected value ${operatorMessage(operator)}`)\n  }  ${printExpected(expected)}\\n${chalk.reset('Received:\\n')}  ${printReceived(\n    actual,\n  )}${chalk.reset(hasCustomMessage ? `\\n\\nMessage:\\n  ${message}` : '')}${\n    diffString ? `\\n\\nDifference:\\n\\n${diffString}` : ''\n  }${trimmedStack}`;\n}\n\nfunction buildHintString(hint: string) {\n  return hint ? `${hint}\\n\\n` : '';\n}\n\nexport default assertionErrorMessage;\n",
  "packages/jest-jasmine2/src/assertionErrorMessage.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { type DiffOptions } from 'jest-matcher-utils';\nimport type { AssertionErrorWithStack } from './types';\ndeclare function assertionErrorMessage(error: AssertionErrorWithStack, options: DiffOptions): string;\nexport default assertionErrorMessage;\n",
  "packages/jest-jasmine2/src/PCancelable.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nclass CancelError extends Error {\n  constructor() {\n    super('Promise was canceled');\n    this.name = 'CancelError';\n  }\n}\n\nexport default class PCancelable<T> implements PromiseLike<T> {\n  private _pending = true;\n  private _canceled = false;\n  private readonly _promise: Promise<T>;\n  private _cancel?: () => void;\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  private _reject: (reason?: unknown) => void = () => {};\n\n  constructor(\n    executor: (\n      onCancel: (cancelHandler: () => void) => void,\n      resolve: (value: T | PromiseLike<T>) => void,\n      reject: (reason?: unknown) => void,\n    ) => void,\n  ) {\n    this._promise = new Promise((resolve, reject) => {\n      this._reject = reject;\n\n      return executor(\n        fn => {\n          this._cancel = fn;\n        },\n        val => {\n          this._pending = false;\n          resolve(val);\n        },\n        err => {\n          this._pending = false;\n          reject(err);\n        },\n      );\n    });\n  }\n\n  // eslint-disable-next-line unicorn/no-thenable\n  then<TResult1 = T, TResult2 = never>(\n    onFulfilled?:\n      | ((value: T) => TResult1 | PromiseLike<TResult1>)\n      | undefined\n      | null,\n    onRejected?:\n      | ((reason: unknown) => TResult2 | PromiseLike<TResult2>)\n      | undefined\n      | null,\n  ): Promise<TResult1 | TResult2> {\n    return this._promise.then(onFulfilled, onRejected);\n  }\n\n  catch<TResult>(\n    onRejected?:\n      | ((reason: unknown) => TResult | PromiseLike<TResult>)\n      | undefined\n      | null,\n  ): Promise<T | TResult> {\n    return this._promise.catch(onRejected);\n  }\n\n  cancel(): void {\n    if (!this._pending || this._canceled) {\n      return;\n    }\n\n    if (typeof this._cancel === 'function') {\n      try {\n        this._cancel();\n      } catch (error) {\n        this._reject(error);\n      }\n    }\n\n    this._canceled = true;\n    this._reject(new CancelError());\n  }\n}\n",
  "packages/jest-jasmine2/src/PCancelable.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport default class PCancelable<T> implements PromiseLike<T> {\n    private _pending;\n    private _canceled;\n    private readonly _promise;\n    private _cancel?;\n    private _reject;\n    constructor(executor: (onCancel: (cancelHandler: () => void) => void, resolve: (value: T | PromiseLike<T>) => void, reject: (reason?: unknown) => void) => void);\n    then<TResult1 = T, TResult2 = never>(onFulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onRejected?: ((reason: unknown) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\n    catch<TResult>(onRejected?: ((reason: unknown) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\n    cancel(): void;\n}\n",
  "packages/jest-jasmine2/src/ExpectationFailed.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nexport default class ExpectationFailed extends Error {}\n",
  "packages/jest-jasmine2/src/ExpectationFailed.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport default class ExpectationFailed extends Error {\n}\n",
  "packages/jest-jasmine2/src/jasmine/spyRegistry.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n// This file is a heavily modified fork of Jasmine. Original license:\n/*\nCopyright (c) 2008-2016 Pivotal Labs\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nimport type {Spy} from '../types';\nimport CallTracker from './CallTracker';\nimport SpyStrategy from './SpyStrategy';\nimport createSpy from './createSpy';\n\nconst formatErrorMsg = (domain: string, usage?: string) => {\n  const usageDefinition = usage ? `\\nUsage: ${usage}` : '';\n  return (msg: string) => `${domain} : ${msg}${usageDefinition}`;\n};\n\nfunction isSpy(putativeSpy: {\n  and: unknown;\n  calls: unknown;\n}): putativeSpy is Spy {\n  if (!putativeSpy) {\n    return false;\n  }\n  return (\n    putativeSpy.and instanceof SpyStrategy &&\n    putativeSpy.calls instanceof CallTracker\n  );\n}\n\nconst getErrorMsg = formatErrorMsg('<spyOn>', 'spyOn(<object>, <methodName>)');\n\nexport default class SpyRegistry {\n  allowRespy: (allow: unknown) => void;\n  spyOn: (\n    obj: Record<string, Spy>,\n    methodName: string,\n    accessType?: keyof PropertyDescriptor,\n  ) => Spy;\n  clearSpies: () => void;\n  respy: unknown;\n\n  private readonly _spyOnProperty: (\n    obj: Record<string, Spy>,\n    propertyName: string,\n    accessType: keyof PropertyDescriptor,\n  ) => Spy;\n\n  constructor({\n    currentSpies = () => [],\n  }: {\n    currentSpies?: () => Array<Spy>;\n  } = {}) {\n    this.allowRespy = function (allow) {\n      this.respy = allow;\n    };\n\n    this.spyOn = (obj, methodName, accessType) => {\n      if (accessType) {\n        return this._spyOnProperty(obj, methodName, accessType);\n      }\n\n      if (obj === void 0) {\n        throw new Error(\n          getErrorMsg(\n            `could not find an object to spy upon for ${methodName}()`,\n          ),\n        );\n      }\n\n      if (methodName === void 0) {\n        throw new Error(getErrorMsg('No method name supplied'));\n      }\n\n      if (obj[methodName] === void 0) {\n        throw new Error(getErrorMsg(`${methodName}() method does not exist`));\n      }\n\n      if (obj[methodName] && isSpy(obj[methodName])) {\n        if (this.respy) {\n          return obj[methodName];\n        } else {\n          throw new Error(\n            getErrorMsg(`${methodName} has already been spied upon`),\n          );\n        }\n      }\n\n      let descriptor;\n      try {\n        descriptor = Object.getOwnPropertyDescriptor(obj, methodName);\n      } catch {\n        // IE 8 doesn't support `definePropery` on non-DOM nodes\n      }\n\n      if (descriptor && !(descriptor.writable || descriptor.set)) {\n        throw new Error(\n          getErrorMsg(\n            `${methodName} is not declared writable or has no setter`,\n          ),\n        );\n      }\n\n      const originalMethod = obj[methodName];\n      const spiedMethod = createSpy(methodName, originalMethod);\n      let restoreStrategy;\n\n      if (Object.prototype.hasOwnProperty.call(obj, methodName)) {\n        restoreStrategy = function () {\n          obj[methodName] = originalMethod;\n        };\n      } else {\n        restoreStrategy = function () {\n          if (!delete obj[methodName]) {\n            obj[methodName] = originalMethod;\n          }\n        };\n      }\n\n      currentSpies().push({\n        restoreObjectToOriginalState: restoreStrategy,\n      } as Spy);\n\n      obj[methodName] = spiedMethod;\n\n      return spiedMethod;\n    };\n\n    this._spyOnProperty = function (obj, propertyName, accessType = 'get') {\n      if (!obj) {\n        throw new Error(\n          getErrorMsg(\n            `could not find an object to spy upon for ${propertyName}`,\n          ),\n        );\n      }\n\n      if (!propertyName) {\n        throw new Error(getErrorMsg('No property name supplied'));\n      }\n\n      let descriptor: PropertyDescriptor | undefined;\n      try {\n        descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);\n      } catch {\n        // IE 8 doesn't support `definePropery` on non-DOM nodes\n      }\n\n      if (!descriptor) {\n        throw new Error(getErrorMsg(`${propertyName} property does not exist`));\n      }\n\n      if (!descriptor.configurable) {\n        throw new Error(\n          getErrorMsg(`${propertyName} is not declared configurable`),\n        );\n      }\n\n      if (!descriptor[accessType]) {\n        throw new Error(\n          getErrorMsg(\n            `Property ${propertyName} does not have access type ${accessType}`,\n          ),\n        );\n      }\n\n      if (obj[propertyName] && isSpy(obj[propertyName])) {\n        if (this.respy) {\n          return obj[propertyName];\n        } else {\n          throw new Error(\n            getErrorMsg(`${propertyName} has already been spied upon`),\n          );\n        }\n      }\n\n      const originalDescriptor = descriptor;\n      const spiedProperty = createSpy(propertyName, descriptor[accessType]);\n      let restoreStrategy;\n\n      if (Object.prototype.hasOwnProperty.call(obj, propertyName)) {\n        restoreStrategy = function () {\n          Object.defineProperty(obj, propertyName, originalDescriptor);\n        };\n      } else {\n        restoreStrategy = function () {\n          delete obj[propertyName];\n        };\n      }\n\n      currentSpies().push({\n        restoreObjectToOriginalState: restoreStrategy,\n      } as Spy);\n\n      const spiedDescriptor = {...descriptor, [accessType]: spiedProperty};\n\n      Object.defineProperty(obj, propertyName, spiedDescriptor);\n\n      return spiedProperty;\n    };\n\n    this.clearSpies = function () {\n      const spies = currentSpies();\n      for (let i = spies.length - 1; i >= 0; i--) {\n        const spyEntry = spies[i];\n        spyEntry.restoreObjectToOriginalState!();\n      }\n    };\n  }\n}\n",
  "packages/jest-jasmine2/src/jasmine/spyRegistry.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport type { Spy } from '../types';\nexport default class SpyRegistry {\n    allowRespy: (allow: unknown) => void;\n    spyOn: (obj: Record<string, Spy>, methodName: string, accessType?: keyof PropertyDescriptor) => Spy;\n    clearSpies: () => void;\n    respy: unknown;\n    private readonly _spyOnProperty;\n    constructor({ currentSpies, }?: {\n        currentSpies?: () => Array<Spy>;\n    });\n}\n",
  "packages/jest-jasmine2/src/jasmine/jasmineLight.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n// This file is a heavily modified fork of Jasmine. Original license:\n/*\nCopyright (c) 2008-2016 Pivotal Labs\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n/* eslint-disable sort-keys */\n\nimport type {Global} from '@jest/types';\nimport type {Jasmine, SpecDefinitionsFn} from '../types';\nimport Env from './Env';\nimport JsApiReporter from './JsApiReporter';\nimport ReportDispatcher from './ReportDispatcher';\nimport Spec from './Spec';\nimport Suite from './Suite';\nimport Timer from './Timer';\nimport createSpy from './createSpy';\nimport SpyRegistry from './spyRegistry';\n\nconst testTimeoutSymbol = Symbol.for('TEST_TIMEOUT_SYMBOL');\n\ndeclare global {\n  // eslint-disable-next-line @typescript-eslint/no-namespace\n  namespace NodeJS {\n    interface Global {\n      [testTimeoutSymbol]: number;\n    }\n  }\n}\n\nexport const create = function (createOptions: Record<string, any>): Jasmine {\n  const j$ = {...createOptions} as Jasmine;\n\n  Object.defineProperty(j$, '_DEFAULT_TIMEOUT_INTERVAL', {\n    configurable: true,\n    enumerable: true,\n    get() {\n      return (\n        (globalThis as Global.Global)[testTimeoutSymbol] ||\n        createOptions.testTimeout ||\n        5000\n      );\n    },\n    set(value) {\n      (globalThis as Global.Global)[testTimeoutSymbol] = value;\n    },\n  });\n\n  j$.getEnv = function () {\n    const env = (j$.currentEnv_ = j$.currentEnv_ || new j$.Env());\n    //jasmine. singletons in here (setTimeout blah blah).\n    return env;\n  };\n  j$.createSpy = createSpy;\n  j$.Env = Env(j$);\n  j$.JsApiReporter = JsApiReporter;\n  j$.ReportDispatcher = ReportDispatcher;\n  j$.Spec = Spec;\n  j$.SpyRegistry = SpyRegistry;\n  j$.Suite = Suite;\n  j$.Timer = Timer;\n  j$.version = '2.5.2-light';\n\n  return j$;\n};\n\n// Interface is a reserved word in strict mode, so can't export it as ESM\nexport const _interface = function (jasmine: Jasmine, env: any) {\n  const jasmineInterface = {\n    describe(description: string, specDefinitions: SpecDefinitionsFn) {\n      return env.describe(description, specDefinitions);\n    },\n\n    xdescribe(description: string, specDefinitions: SpecDefinitionsFn) {\n      return env.xdescribe(description, specDefinitions);\n    },\n\n    fdescribe(description: string, specDefinitions: SpecDefinitionsFn) {\n      return env.fdescribe(description, specDefinitions);\n    },\n\n    it() {\n      return env.it.apply(env, arguments);\n    },\n\n    xit() {\n      return env.xit.apply(env, arguments);\n    },\n\n    fit() {\n      return env.fit.apply(env, arguments);\n    },\n\n    beforeEach() {\n      if (typeof arguments[0] !== 'function') {\n        throw new TypeError(\n          'Invalid first argument. It must be a callback function.',\n        );\n      }\n      return env.beforeEach.apply(env, arguments);\n    },\n\n    afterEach() {\n      if (typeof arguments[0] !== 'function') {\n        throw new TypeError(\n          'Invalid first argument. It must be a callback function.',\n        );\n      }\n      return env.afterEach.apply(env, arguments);\n    },\n\n    beforeAll() {\n      if (typeof arguments[0] !== 'function') {\n        throw new TypeError(\n          'Invalid first argument. It must be a callback function.',\n        );\n      }\n      return env.beforeAll.apply(env, arguments);\n    },\n\n    afterAll() {\n      if (typeof arguments[0] !== 'function') {\n        throw new TypeError(\n          'Invalid first argument. It must be a callback function.',\n        );\n      }\n      return env.afterAll.apply(env, arguments);\n    },\n\n    pending() {\n      return env.pending.apply(env, arguments);\n    },\n\n    fail() {\n      return env.fail.apply(env, arguments);\n    },\n\n    spyOn(obj: Record<string, any>, methodName: string, accessType?: string) {\n      return env.spyOn(obj, methodName, accessType);\n    },\n\n    jsApiReporter: new jasmine.JsApiReporter({\n      timer: new jasmine.Timer(),\n    }),\n\n    jasmine,\n  };\n\n  return jasmineInterface;\n};\n",
  "packages/jest-jasmine2/src/jasmine/jasmineLight.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport type { Jasmine, SpecDefinitionsFn } from '../types';\ndeclare const testTimeoutSymbol: unique symbol;\ndeclare global {\n    namespace NodeJS {\n        interface Global {\n            [testTimeoutSymbol]: number;\n        }\n    }\n}\nexport declare const create: (createOptions: Record<string, any>) => Jasmine;\nexport declare const _interface: (jasmine: Jasmine, env: any) => {\n    describe(description: string, specDefinitions: SpecDefinitionsFn): any;\n    xdescribe(description: string, specDefinitions: SpecDefinitionsFn): any;\n    fdescribe(description: string, specDefinitions: SpecDefinitionsFn): any;\n    it(): any;\n    xit(): any;\n    fit(): any;\n    beforeEach(): any;\n    afterEach(): any;\n    beforeAll(): any;\n    afterAll(): any;\n    pending(): any;\n    fail(): any;\n    spyOn(obj: Record<string, any>, methodName: string, accessType?: string): any;\n    jsApiReporter: any;\n    jasmine: any;\n};\nexport {};\n",
  "packages/jest-jasmine2/src/jasmine/createSpy.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n// This file is a heavily modified fork of Jasmine. Original license:\n/*\nCopyright (c) 2008-2016 Pivotal Labs\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n/* eslint-disable sort-keys */\n\nimport type {Spy} from '../types';\nimport CallTracker, {type Context} from './CallTracker';\nimport SpyStrategy from './SpyStrategy';\n\ninterface Fn extends Record<string, unknown> {\n  (): unknown;\n}\n\nfunction createSpy(name: string, originalFn: Fn): Spy {\n  const spyStrategy = new SpyStrategy({\n    name,\n    fn: originalFn,\n    getSpy() {\n      return spy;\n    },\n  });\n  const callTracker = new CallTracker();\n  const spy: Spy = function (...args) {\n    const callData: Context = {\n      object: this,\n      args: Array.prototype.slice.apply(arguments),\n    };\n\n    callTracker.track(callData);\n    const returnValue = spyStrategy.exec.apply(this, args);\n    callData.returnValue = returnValue;\n\n    return returnValue;\n  };\n\n  for (const prop in originalFn) {\n    if (prop === 'and' || prop === 'calls') {\n      throw new Error(\n        \"Jasmine spies would overwrite the 'and' and 'calls' properties \" +\n          'on the object being spied upon',\n      );\n    }\n\n    spy[prop] = originalFn[prop];\n  }\n\n  spy.and = spyStrategy;\n  spy.calls = callTracker;\n\n  return spy;\n}\n\nexport default createSpy;\n",
  "packages/jest-jasmine2/src/jasmine/createSpy.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport type { Spy } from '../types';\ninterface Fn extends Record<string, unknown> {\n    (): unknown;\n}\ndeclare function createSpy(name: string, originalFn: Fn): Spy;\nexport default createSpy;\n",
  "packages/jest-jasmine2/src/jasmine/Timer.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n// This file is a heavily modified fork of Jasmine. Original license:\n/*\nCopyright (c) 2008-2016 Pivotal Labs\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nconst defaultNow = (function (Date) {\n  return function () {\n    return Date.now();\n  };\n})(Date);\n\nexport default class Timer {\n  start: () => void;\n  elapsed: () => number;\n\n  constructor(options?: {now?: () => number}) {\n    options = options || {};\n\n    const now = options.now || defaultNow;\n    let startTime: number;\n\n    this.start = function () {\n      startTime = now();\n    };\n\n    this.elapsed = function () {\n      return now() - startTime;\n    };\n  }\n}\n",
  "packages/jest-jasmine2/src/jasmine/Timer.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport default class Timer {\n    start: () => void;\n    elapsed: () => number;\n    constructor(options?: {\n        now?: () => number;\n    });\n}\n",
  "packages/jest-jasmine2/src/jasmine/Suite.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n// This file is a heavily modified fork of Jasmine. Original license:\n/*\nCopyright (c) 2008-2016 Pivotal Labs\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/* eslint-disable sort-keys */\n\nimport type {Circus} from '@jest/types';\nimport {convertDescriptorToString} from 'jest-util';\nimport ExpectationFailed from '../ExpectationFailed';\nimport expectationResultFactory from '../expectationResultFactory';\nimport type {QueueableFn} from '../queueRunner';\nimport type Spec from './Spec';\n\nexport type SuiteResult = {\n  id: string;\n  description: string;\n  fullName: string;\n  failedExpectations: Array<ReturnType<typeof expectationResultFactory>>;\n  testPath: string;\n  status?: string;\n};\n\nexport type Attributes = {\n  id: string;\n  parentSuite?: Suite;\n  description: Circus.TestNameLike;\n  throwOnExpectationFailure?: boolean;\n  getTestPath: () => string;\n};\n\nexport default class Suite {\n  id: string;\n  parentSuite?: Suite;\n  description: Circus.TestNameLike;\n  throwOnExpectationFailure: boolean;\n  beforeFns: Array<QueueableFn>;\n  afterFns: Array<QueueableFn>;\n  beforeAllFns: Array<QueueableFn>;\n  afterAllFns: Array<QueueableFn>;\n  disabled: boolean;\n  children: Array<Suite | Spec>;\n  result: SuiteResult;\n  sharedContext?: object;\n  markedPending: boolean;\n  markedTodo: boolean;\n  isFocused: boolean;\n\n  constructor(attrs: Attributes) {\n    this.markedPending = false;\n    this.markedTodo = false;\n    this.isFocused = false;\n    this.id = attrs.id;\n    this.parentSuite = attrs.parentSuite;\n    this.description = convertDescriptorToString(attrs.description);\n    this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;\n\n    this.beforeFns = [];\n    this.afterFns = [];\n    this.beforeAllFns = [];\n    this.afterAllFns = [];\n    this.disabled = false;\n\n    this.children = [];\n\n    this.result = {\n      id: this.id,\n      description: this.description,\n      fullName: this.getFullName(),\n      failedExpectations: [],\n      testPath: attrs.getTestPath(),\n    };\n  }\n  getFullName() {\n    const fullName = [];\n    for (\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      let parentSuite: Suite | undefined = this;\n      parentSuite;\n      parentSuite = parentSuite.parentSuite\n    ) {\n      if (parentSuite.parentSuite) {\n        fullName.unshift(parentSuite.description);\n      }\n    }\n    return fullName.join(' ');\n  }\n  disable() {\n    this.disabled = true;\n  }\n  pend(_message?: string) {\n    this.markedPending = true;\n  }\n  beforeEach(fn: QueueableFn) {\n    this.beforeFns.unshift(fn);\n  }\n  beforeAll(fn: QueueableFn) {\n    this.beforeAllFns.push(fn);\n  }\n  afterEach(fn: QueueableFn) {\n    this.afterFns.unshift(fn);\n  }\n  afterAll(fn: QueueableFn) {\n    this.afterAllFns.unshift(fn);\n  }\n\n  addChild(child: Suite | Spec) {\n    this.children.push(child);\n  }\n\n  status() {\n    if (this.disabled) {\n      return 'disabled';\n    }\n\n    if (this.markedPending) {\n      return 'pending';\n    }\n\n    if (this.result.failedExpectations.length > 0) {\n      return 'failed';\n    } else {\n      return 'finished';\n    }\n  }\n\n  isExecutable() {\n    return !this.disabled;\n  }\n\n  canBeReentered() {\n    return this.beforeAllFns.length === 0 && this.afterAllFns.length === 0;\n  }\n\n  getResult() {\n    this.result.status = this.status();\n    return this.result;\n  }\n\n  sharedUserContext() {\n    if (!this.sharedContext) {\n      this.sharedContext = {};\n    }\n\n    return this.sharedContext;\n  }\n\n  clonedSharedUserContext() {\n    return this.sharedUserContext();\n  }\n\n  onException(...args: Parameters<Spec['onException']>) {\n    if (args[0] instanceof ExpectationFailed) {\n      return;\n    }\n\n    if (isAfterAll(this.children)) {\n      const data = {\n        matcherName: '',\n        passed: false,\n        expected: '',\n        actual: '',\n        error: arguments[0],\n      };\n      this.result.failedExpectations.push(expectationResultFactory(data));\n    } else {\n      for (const child of this.children) {\n        child.onException.apply(child, args);\n      }\n    }\n  }\n\n  addExpectationResult(...args: Parameters<Spec['addExpectationResult']>) {\n    if (isAfterAll(this.children) && isFailure(args)) {\n      const data = args[1];\n      this.result.failedExpectations.push(expectationResultFactory(data));\n      if (this.throwOnExpectationFailure) {\n        throw new ExpectationFailed();\n      }\n    } else {\n      for (const child of this.children) {\n        try {\n          child.addExpectationResult.apply(child, args);\n        } catch {\n          // keep going\n        }\n      }\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  execute(..._args: Array<any>) {}\n}\n\nfunction isAfterAll(children: Array<Spec | Suite>) {\n  return children && children[0] && children[0].result.status;\n}\n\nfunction isFailure(args: Array<unknown>) {\n  return !args[0];\n}\n",
  "packages/jest-jasmine2/src/jasmine/Suite.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport type { Circus } from '@jest/types';\nimport expectationResultFactory from '../expectationResultFactory';\nimport type { QueueableFn } from '../queueRunner';\nimport type Spec from './Spec';\nexport type SuiteResult = {\n    id: string;\n    description: string;\n    fullName: string;\n    failedExpectations: Array<ReturnType<typeof expectationResultFactory>>;\n    testPath: string;\n    status?: string;\n};\nexport type Attributes = {\n    id: string;\n    parentSuite?: Suite;\n    description: Circus.TestNameLike;\n    throwOnExpectationFailure?: boolean;\n    getTestPath: () => string;\n};\nexport default class Suite {\n    id: string;\n    parentSuite?: Suite;\n    description: Circus.TestNameLike;\n    throwOnExpectationFailure: boolean;\n    beforeFns: Array<QueueableFn>;\n    afterFns: Array<QueueableFn>;\n    beforeAllFns: Array<QueueableFn>;\n    afterAllFns: Array<QueueableFn>;\n    disabled: boolean;\n    children: Array<Suite | Spec>;\n    result: SuiteResult;\n    sharedContext?: object;\n    markedPending: boolean;\n    markedTodo: boolean;\n    isFocused: boolean;\n    constructor(attrs: Attributes);\n    getFullName(): string;\n    disable(): void;\n    pend(_message?: string): void;\n    beforeEach(fn: QueueableFn): void;\n    beforeAll(fn: QueueableFn): void;\n    afterEach(fn: QueueableFn): void;\n    afterAll(fn: QueueableFn): void;\n    addChild(child: Suite | Spec): void;\n    status(): \"failed\" | \"finished\" | \"pending\" | \"disabled\";\n    isExecutable(): boolean;\n    canBeReentered(): boolean;\n    getResult(): SuiteResult;\n    sharedUserContext(): object;\n    clonedSharedUserContext(): object;\n    onException(...args: Parameters<Spec['onException']>): void;\n    addExpectationResult(...args: Parameters<Spec['addExpectationResult']>): void;\n    execute(..._args: Array<any>): void;\n}\n",
  "packages/jest-jasmine2/src/jasmine/SpyStrategy.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n// This file is a heavily modified fork of Jasmine. Original license:\n/*\nCopyright (c) 2008-2016 Pivotal Labs\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/* eslint-disable @typescript-eslint/no-empty-function */\n\nexport default class SpyStrategy {\n  identity: () => string;\n  exec: (...args: Array<any>) => unknown;\n  callThrough: () => unknown;\n  returnValue: (value: unknown) => unknown;\n  returnValues: () => unknown;\n  throwError: (something: string | Error) => unknown;\n  callFake: (fn: Function) => unknown;\n  stub: (fn: Function) => unknown;\n\n  constructor({\n    name = 'unknown',\n    fn = function () {},\n    getSpy = function () {},\n  }: {name?: string; fn?: Function; getSpy?: () => unknown} = {}) {\n    const identity = name;\n    const originalFn = fn;\n    let plan: Function = function () {};\n\n    this.identity = function () {\n      return identity;\n    };\n\n    this.exec = function () {\n      return plan.apply(this, arguments);\n    };\n\n    this.callThrough = function () {\n      plan = originalFn;\n      return getSpy();\n    };\n\n    this.returnValue = function (value) {\n      plan = function () {\n        return value;\n      };\n      return getSpy();\n    };\n\n    this.returnValues = function () {\n      const values = Array.prototype.slice.call(arguments);\n      plan = function () {\n        return values.shift();\n      };\n      return getSpy();\n    };\n\n    this.throwError = function (something) {\n      const error =\n        something instanceof Error ? something : new Error(something);\n      plan = function () {\n        throw error;\n      };\n      return getSpy();\n    };\n\n    this.callFake = function (fn) {\n      if (typeof fn !== 'function') {\n        throw new TypeError(\n          `Argument passed to callFake should be a function, got ${fn}`,\n        );\n      }\n      plan = fn;\n      return getSpy();\n    };\n\n    this.stub = function (_fn) {\n      plan = function () {};\n      return getSpy();\n    };\n  }\n}\n",
  "packages/jest-jasmine2/src/jasmine/SpyStrategy.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport default class SpyStrategy {\n    identity: () => string;\n    exec: (...args: Array<any>) => unknown;\n    callThrough: () => unknown;\n    returnValue: (value: unknown) => unknown;\n    returnValues: () => unknown;\n    throwError: (something: string | Error) => unknown;\n    callFake: (fn: Function) => unknown;\n    stub: (fn: Function) => unknown;\n    constructor({ name, fn, getSpy, }?: {\n        name?: string;\n        fn?: Function;\n        getSpy?: () => unknown;\n    });\n}\n",
  "packages/jest-jasmine2/src/jasmine/Spec.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n// This file is a heavily modified fork of Jasmine. Original license:\n/*\nCopyright (c) 2008-2016 Pivotal Labs\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n/* eslint-disable sort-keys, @typescript-eslint/no-empty-function */\n\nimport {AssertionError} from 'assert';\nimport type {FailedAssertion, Status} from '@jest/test-result';\nimport type {Circus} from '@jest/types';\nimport {convertDescriptorToString} from 'jest-util';\nimport ExpectationFailed from '../ExpectationFailed';\nimport assertionErrorMessage from '../assertionErrorMessage';\nimport expectationResultFactory, {\n  type Options as ExpectationResultFactoryOptions,\n} from '../expectationResultFactory';\nimport type {QueueableFn, default as queueRunner} from '../queueRunner';\nimport type {AssertionErrorWithStack} from '../types';\n\nexport type Attributes = {\n  id: string;\n  resultCallback: (result: Spec['result']) => void;\n  description: Circus.TestNameLike;\n  throwOnExpectationFailure: unknown;\n  getTestPath: () => string;\n  queueableFn: QueueableFn;\n  beforeAndAfterFns: () => {\n    befores: Array<QueueableFn>;\n    afters: Array<QueueableFn>;\n  };\n  userContext: () => unknown;\n  onStart: (context: Spec) => void;\n  getSpecName: (spec: Spec) => string;\n  queueRunnerFactory: typeof queueRunner;\n};\n\nexport type SpecResult = {\n  id: string;\n  description: string;\n  fullName: string;\n  duration?: number;\n  failedExpectations: Array<FailedAssertion>;\n  testPath: string;\n  passedExpectations: Array<ReturnType<typeof expectationResultFactory>>;\n  pendingReason: string;\n  status: Status;\n  __callsite?: {\n    getColumnNumber: () => number;\n    getLineNumber: () => number;\n  };\n};\n\nexport default class Spec {\n  id: string;\n  description: string;\n  resultCallback: (result: SpecResult) => void;\n  queueableFn: QueueableFn;\n  beforeAndAfterFns: () => {\n    befores: Array<QueueableFn>;\n    afters: Array<QueueableFn>;\n  };\n  userContext: () => unknown;\n  onStart: (spec: Spec) => void;\n  getSpecName: (spec: Spec) => string;\n  queueRunnerFactory: typeof queueRunner;\n  throwOnExpectationFailure: boolean;\n  initError: Error;\n  result: SpecResult;\n  disabled?: boolean;\n  currentRun?: ReturnType<typeof queueRunner>;\n  markedTodo?: boolean;\n  markedPending?: boolean;\n  expand?: boolean;\n\n  static pendingSpecExceptionMessage: string;\n\n  static isPendingSpecException(e: Error) {\n    return !!(\n      e &&\n      e.toString &&\n      e.toString().includes(Spec.pendingSpecExceptionMessage)\n    );\n  }\n\n  constructor(attrs: Attributes) {\n    this.resultCallback = attrs.resultCallback || function () {};\n    this.id = attrs.id;\n    this.description = convertDescriptorToString(attrs.description);\n    this.queueableFn = attrs.queueableFn;\n    this.beforeAndAfterFns =\n      attrs.beforeAndAfterFns ||\n      function () {\n        return {befores: [], afters: []};\n      };\n    this.userContext =\n      attrs.userContext ||\n      function () {\n        return {};\n      };\n    this.onStart = attrs.onStart || function () {};\n    this.getSpecName =\n      attrs.getSpecName ||\n      function () {\n        return '';\n      };\n    this.queueRunnerFactory = attrs.queueRunnerFactory || function () {};\n    this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;\n\n    // eslint-disable-next-line unicorn/error-message\n    this.initError = new Error();\n    this.initError.name = '';\n\n    // Without this line v8 stores references to all closures\n    // in the stack in the Error object. This line stringifies the stack\n    // property to allow garbage-collecting objects on the stack\n    // https://crbug.com/v8/7142\n    // eslint-disable-next-line no-self-assign\n    this.initError.stack = this.initError.stack;\n\n    this.queueableFn.initError = this.initError;\n\n    // @ts-expect-error: misses some fields added later\n    this.result = {\n      id: this.id,\n      description: this.description,\n      fullName: this.getFullName(),\n      failedExpectations: [],\n      passedExpectations: [],\n      pendingReason: '',\n      testPath: attrs.getTestPath(),\n    };\n  }\n\n  addExpectationResult(\n    passed: boolean,\n    data: ExpectationResultFactoryOptions,\n    isError?: boolean,\n  ) {\n    const expectationResult = expectationResultFactory(data, this.initError);\n    if (passed) {\n      this.result.passedExpectations.push(expectationResult);\n    } else {\n      this.result.failedExpectations.push(expectationResult);\n\n      if (this.throwOnExpectationFailure && !isError) {\n        throw new ExpectationFailed();\n      }\n    }\n  }\n\n  execute(onComplete?: () => void, enabled?: boolean) {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n\n    this.onStart(this);\n\n    if (\n      !this.isExecutable() ||\n      this.markedPending ||\n      this.markedTodo ||\n      enabled === false\n    ) {\n      complete(enabled);\n      return;\n    }\n\n    const fns = this.beforeAndAfterFns();\n    const allFns = fns.befores.concat(this.queueableFn).concat(fns.afters);\n\n    this.currentRun = this.queueRunnerFactory({\n      queueableFns: allFns,\n      onException() {\n        // @ts-expect-error: wrong context\n        self.onException.apply(self, arguments);\n      },\n      userContext: this.userContext(),\n      setTimeout,\n      clearTimeout,\n      fail: () => {},\n    });\n\n    this.currentRun.then(() => complete(true));\n\n    function complete(enabledAgain?: boolean) {\n      self.result.status = self.status(enabledAgain);\n      self.resultCallback(self.result);\n\n      if (onComplete) {\n        onComplete();\n      }\n    }\n  }\n\n  cancel() {\n    if (this.currentRun) {\n      this.currentRun.cancel();\n    }\n  }\n\n  onException(error: ExpectationFailed | AssertionErrorWithStack) {\n    if (Spec.isPendingSpecException(error)) {\n      this.pend(extractCustomPendingMessage(error));\n      return;\n    }\n\n    if (error instanceof ExpectationFailed) {\n      return;\n    }\n\n    this.addExpectationResult(\n      false,\n      {\n        matcherName: '',\n        passed: false,\n        expected: '',\n        actual: '',\n        error: this.isAssertionError(error)\n          ? assertionErrorMessage(error, {expand: this.expand})\n          : error,\n      },\n      true,\n    );\n  }\n\n  disable() {\n    this.disabled = true;\n  }\n\n  pend(message?: string) {\n    this.markedPending = true;\n    if (message) {\n      this.result.pendingReason = message;\n    }\n  }\n\n  todo() {\n    this.markedTodo = true;\n  }\n\n  getResult() {\n    this.result.status = this.status();\n    return this.result;\n  }\n\n  status(enabled?: boolean) {\n    if (this.disabled || enabled === false) {\n      return 'disabled';\n    }\n\n    if (this.markedTodo) {\n      return 'todo';\n    }\n\n    if (this.markedPending) {\n      return 'pending';\n    }\n\n    if (this.result.failedExpectations.length > 0) {\n      return 'failed';\n    } else {\n      return 'passed';\n    }\n  }\n\n  isExecutable() {\n    return !this.disabled;\n  }\n\n  getFullName() {\n    return this.getSpecName(this);\n  }\n\n  isAssertionError(error: Error) {\n    return (\n      error instanceof AssertionError ||\n      (error && error.name === AssertionError.name)\n    );\n  }\n}\n\nSpec.pendingSpecExceptionMessage = '=> marked Pending';\n\nconst extractCustomPendingMessage = function (e: Error) {\n  const fullMessage = e.toString();\n  const boilerplateStart = fullMessage.indexOf(\n    Spec.pendingSpecExceptionMessage,\n  );\n  const boilerplateEnd =\n    boilerplateStart + Spec.pendingSpecExceptionMessage.length;\n\n  return fullMessage.slice(boilerplateEnd);\n};\n",
  "packages/jest-jasmine2/src/jasmine/Spec.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport type { FailedAssertion, Status } from '@jest/test-result';\nimport type { Circus } from '@jest/types';\nimport ExpectationFailed from '../ExpectationFailed';\nimport expectationResultFactory, { type Options as ExpectationResultFactoryOptions } from '../expectationResultFactory';\nimport type { QueueableFn, default as queueRunner } from '../queueRunner';\nimport type { AssertionErrorWithStack } from '../types';\nexport type Attributes = {\n    id: string;\n    resultCallback: (result: Spec['result']) => void;\n    description: Circus.TestNameLike;\n    throwOnExpectationFailure: unknown;\n    getTestPath: () => string;\n    queueableFn: QueueableFn;\n    beforeAndAfterFns: () => {\n        befores: Array<QueueableFn>;\n        afters: Array<QueueableFn>;\n    };\n    userContext: () => unknown;\n    onStart: (context: Spec) => void;\n    getSpecName: (spec: Spec) => string;\n    queueRunnerFactory: typeof queueRunner;\n};\nexport type SpecResult = {\n    id: string;\n    description: string;\n    fullName: string;\n    duration?: number;\n    failedExpectations: Array<FailedAssertion>;\n    testPath: string;\n    passedExpectations: Array<ReturnType<typeof expectationResultFactory>>;\n    pendingReason: string;\n    status: Status;\n    __callsite?: {\n        getColumnNumber: () => number;\n        getLineNumber: () => number;\n    };\n};\nexport default class Spec {\n    id: string;\n    description: string;\n    resultCallback: (result: SpecResult) => void;\n    queueableFn: QueueableFn;\n    beforeAndAfterFns: () => {\n        befores: Array<QueueableFn>;\n        afters: Array<QueueableFn>;\n    };\n    userContext: () => unknown;\n    onStart: (spec: Spec) => void;\n    getSpecName: (spec: Spec) => string;\n    queueRunnerFactory: typeof queueRunner;\n    throwOnExpectationFailure: boolean;\n    initError: Error;\n    result: SpecResult;\n    disabled?: boolean;\n    currentRun?: ReturnType<typeof queueRunner>;\n    markedTodo?: boolean;\n    markedPending?: boolean;\n    expand?: boolean;\n    static pendingSpecExceptionMessage: string;\n    static isPendingSpecException(e: Error): boolean;\n    constructor(attrs: Attributes);\n    addExpectationResult(passed: boolean, data: ExpectationResultFactoryOptions, isError?: boolean): void;\n    execute(onComplete?: () => void, enabled?: boolean): void;\n    cancel(): void;\n    onException(error: ExpectationFailed | AssertionErrorWithStack): void;\n    disable(): void;\n    pend(message?: string): void;\n    todo(): void;\n    getResult(): SpecResult;\n    status(enabled?: boolean): \"failed\" | \"pending\" | \"disabled\" | \"todo\" | \"passed\";\n    isExecutable(): boolean;\n    getFullName(): string;\n    isAssertionError(error: Error): boolean;\n}\n",
  "packages/jest-jasmine2/src/jasmine/ReportDispatcher.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n// This file is a heavily modified fork of Jasmine. Original license:\n/*\nCopyright (c) 2008-2016 Pivotal Labs\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nimport type {Reporter, RunDetails} from '../types';\nimport type {SpecResult} from './Spec';\nimport type {SuiteResult} from './Suite';\n\nexport default class ReportDispatcher implements Reporter {\n  addReporter: (reporter: Reporter) => void;\n  provideFallbackReporter: (reporter: Reporter) => void;\n  clearReporters: () => void;\n\n  // @ts-expect-error: confused by loop in ctor\n  jasmineDone: (runDetails: RunDetails) => void;\n  // @ts-expect-error: confused by loop in ctor\n  jasmineStarted: (runDetails: RunDetails) => void;\n  // @ts-expect-error: confused by loop in ctor\n  specDone: (result: SpecResult) => void;\n  // @ts-expect-error: confused by loop in ctor\n  specStarted: (spec: SpecResult) => void;\n  // @ts-expect-error: confused by loop in ctor\n  suiteDone: (result: SuiteResult) => void;\n  // @ts-expect-error: confused by loop in ctor\n  suiteStarted: (result: SuiteResult) => void;\n\n  constructor(methods: Array<keyof Reporter>) {\n    const dispatchedMethods = methods || [];\n\n    for (const method of dispatchedMethods) {\n      this[method] = (function (m) {\n        return function () {\n          dispatch(m, arguments);\n        };\n      })(method);\n    }\n\n    let reporters: Array<Reporter> = [];\n    let fallbackReporter: Reporter | null = null;\n\n    this.addReporter = function (reporter) {\n      reporters.push(reporter);\n    };\n\n    this.provideFallbackReporter = function (reporter) {\n      fallbackReporter = reporter;\n    };\n\n    this.clearReporters = function () {\n      reporters = [];\n    };\n\n    return this;\n\n    function dispatch(method: keyof Reporter, args: unknown) {\n      if (reporters.length === 0 && fallbackReporter !== null) {\n        reporters.push(fallbackReporter);\n      }\n      for (const reporter of reporters) {\n        if (reporter[method]) {\n          // @ts-expect-error: wrong context\n          reporter[method].apply(reporter, args);\n        }\n      }\n    }\n  }\n}\n",
  "packages/jest-jasmine2/src/jasmine/ReportDispatcher.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport type { Reporter, RunDetails } from '../types';\nimport type { SpecResult } from './Spec';\nimport type { SuiteResult } from './Suite';\nexport default class ReportDispatcher implements Reporter {\n    addReporter: (reporter: Reporter) => void;\n    provideFallbackReporter: (reporter: Reporter) => void;\n    clearReporters: () => void;\n    jasmineDone: (runDetails: RunDetails) => void;\n    jasmineStarted: (runDetails: RunDetails) => void;\n    specDone: (result: SpecResult) => void;\n    specStarted: (spec: SpecResult) => void;\n    suiteDone: (result: SuiteResult) => void;\n    suiteStarted: (result: SuiteResult) => void;\n    constructor(methods: Array<keyof Reporter>);\n}\n",
  "packages/jest-jasmine2/src/jasmine/JsApiReporter.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n// This file is a heavily modified fork of Jasmine. Original license:\n/*\nCopyright (c) 2008-2016 Pivotal Labs\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n/* eslint-disable sort-keys, @typescript-eslint/no-empty-function */\nimport type {Reporter, RunDetails} from '../types';\nimport type {SpecResult} from './Spec';\nimport type {SuiteResult} from './Suite';\nimport type Timer from './Timer';\n\nconst noopTimer = {\n  start() {},\n  elapsed() {\n    return 0;\n  },\n};\n\nexport default class JsApiReporter implements Reporter {\n  started: boolean;\n  finished: boolean;\n  runDetails: RunDetails;\n  jasmineStarted: (runDetails: RunDetails) => void;\n  jasmineDone: (runDetails: RunDetails) => void;\n  status: () => unknown;\n  executionTime: () => unknown;\n\n  suiteStarted: (result: SuiteResult) => void;\n  suiteDone: (result: SuiteResult) => void;\n  suiteResults: (index: number, length: number) => Array<SuiteResult>;\n  suites: () => Record<string, SuiteResult>;\n\n  specResults: (index: number, length: number) => Array<SpecResult>;\n  specDone: (result: SpecResult) => void;\n  specs: () => Array<SpecResult>;\n  specStarted: (spec: SpecResult) => void;\n\n  constructor(options: {timer?: Timer}) {\n    const timer = options.timer || noopTimer;\n    let status = 'loaded';\n\n    this.started = false;\n    this.finished = false;\n    this.runDetails = {};\n\n    this.jasmineStarted = () => {\n      this.started = true;\n      status = 'started';\n      timer.start();\n    };\n\n    let executionTime: number;\n\n    function validateAfterAllExceptions({failedExpectations}: RunDetails) {\n      if (failedExpectations && failedExpectations.length > 0) {\n        throw failedExpectations[0];\n      }\n    }\n\n    this.jasmineDone = function (runDetails) {\n      validateAfterAllExceptions(runDetails);\n      this.finished = true;\n      this.runDetails = runDetails;\n      executionTime = timer.elapsed();\n      status = 'done';\n    };\n\n    this.status = function () {\n      return status;\n    };\n\n    const suites: Array<SuiteResult> = [];\n    const suites_hash: Record<string, SuiteResult> = {};\n\n    this.specStarted = function () {};\n\n    this.suiteStarted = function (result: SuiteResult) {\n      suites_hash[result.id] = result;\n    };\n\n    this.suiteDone = function (result: SuiteResult) {\n      storeSuite(result);\n    };\n\n    this.suiteResults = function (index, length) {\n      return suites.slice(index, index + length);\n    };\n\n    function storeSuite(result: SuiteResult) {\n      suites.push(result);\n      suites_hash[result.id] = result;\n    }\n\n    this.suites = function () {\n      return suites_hash;\n    };\n\n    const specs: Array<SpecResult> = [];\n\n    this.specDone = function (result) {\n      specs.push(result);\n    };\n\n    this.specResults = function (index, length) {\n      return specs.slice(index, index + length);\n    };\n\n    this.specs = function () {\n      return specs;\n    };\n\n    this.executionTime = function () {\n      return executionTime;\n    };\n  }\n}\n",
  "packages/jest-jasmine2/src/jasmine/JsApiReporter.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport type { Reporter, RunDetails } from '../types';\nimport type { SpecResult } from './Spec';\nimport type { SuiteResult } from './Suite';\nimport type Timer from './Timer';\nexport default class JsApiReporter implements Reporter {\n    started: boolean;\n    finished: boolean;\n    runDetails: RunDetails;\n    jasmineStarted: (runDetails: RunDetails) => void;\n    jasmineDone: (runDetails: RunDetails) => void;\n    status: () => unknown;\n    executionTime: () => unknown;\n    suiteStarted: (result: SuiteResult) => void;\n    suiteDone: (result: SuiteResult) => void;\n    suiteResults: (index: number, length: number) => Array<SuiteResult>;\n    suites: () => Record<string, SuiteResult>;\n    specResults: (index: number, length: number) => Array<SpecResult>;\n    specDone: (result: SpecResult) => void;\n    specs: () => Array<SpecResult>;\n    specStarted: (spec: SpecResult) => void;\n    constructor(options: {\n        timer?: Timer;\n    });\n}\n",
  "packages/jest-jasmine2/src/jasmine/Env.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n// This file is a heavily modified fork of Jasmine. Original license:\n/*\nCopyright (c) 2008-2016 Pivotal Labs\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n/* eslint-disable sort-keys */\n\nimport {AssertionError} from 'assert';\nimport type {Circus} from '@jest/types';\nimport {ErrorWithStack, convertDescriptorToString, isPromise} from 'jest-util';\nimport assertionErrorMessage from '../assertionErrorMessage';\nimport isError from '../isError';\nimport queueRunner, {\n  type Options as QueueRunnerOptions,\n  type QueueableFn,\n} from '../queueRunner';\nimport treeProcessor, {type TreeNode} from '../treeProcessor';\nimport type {\n  AssertionErrorWithStack,\n  Jasmine,\n  Reporter,\n  SpecDefinitionsFn,\n  Spy,\n} from '../types';\nimport type {default as Spec, SpecResult} from './Spec';\nimport type Suite from './Suite';\n\nexport default function jasmineEnv(j$: Jasmine) {\n  return class Env {\n    specFilter: (spec: Spec) => boolean;\n    catchExceptions: (value: unknown) => boolean;\n    throwOnExpectationFailure: (value: unknown) => void;\n    catchingExceptions: () => boolean;\n    topSuite: () => Suite;\n    fail: (error: Error | AssertionErrorWithStack) => void;\n    pending: (message: string) => void;\n    afterAll: (afterAllFunction: QueueableFn['fn'], timeout?: number) => void;\n    fit: (\n      description: Circus.TestNameLike,\n      fn: QueueableFn['fn'],\n      timeout?: number,\n    ) => Spec;\n    throwingExpectationFailures: () => boolean;\n    randomizeTests: (value: unknown) => void;\n    randomTests: () => boolean;\n    seed: (value: unknown) => unknown;\n    execute: (\n      runnablesToRun?: Array<string>,\n      suiteTree?: Suite,\n    ) => Promise<void>;\n    fdescribe: (\n      description: Circus.TestNameLike,\n      specDefinitions: SpecDefinitionsFn,\n    ) => Suite;\n    spyOn: (\n      obj: Record<string, Spy>,\n      methodName: string,\n      accessType?: keyof PropertyDescriptor,\n    ) => Spy;\n    beforeEach: (\n      beforeEachFunction: QueueableFn['fn'],\n      timeout?: number,\n    ) => void;\n    afterEach: (afterEachFunction: QueueableFn['fn'], timeout?: number) => void;\n    clearReporters: () => void;\n    addReporter: (reporterToAdd: Reporter) => void;\n    it: (\n      description: Circus.TestNameLike,\n      fn: QueueableFn['fn'],\n      timeout?: number,\n    ) => Spec;\n    xdescribe: (\n      description: Circus.TestNameLike,\n      specDefinitions: SpecDefinitionsFn,\n    ) => Suite;\n    xit: (\n      description: Circus.TestNameLike,\n      fn: QueueableFn['fn'],\n      timeout?: number,\n    ) => Spec;\n    beforeAll: (beforeAllFunction: QueueableFn['fn'], timeout?: number) => void;\n    todo: () => Spec;\n    provideFallbackReporter: (reporterToAdd: Reporter) => void;\n    allowRespy: (allow: boolean) => void;\n    describe: (\n      description: Circus.TestNameLike,\n      specDefinitions: SpecDefinitionsFn,\n    ) => Suite;\n\n    constructor() {\n      let totalSpecsDefined = 0;\n\n      let catchExceptions = true;\n\n      const realSetTimeout = globalThis.setTimeout;\n      const realClearTimeout = globalThis.clearTimeout;\n\n      const runnableResources: Record<string, {spies: Array<Spy>}> = {};\n      const currentlyExecutingSuites: Array<Suite> = [];\n      let currentSpec: Spec | null = null;\n      let throwOnExpectationFailure = false;\n      let random = false;\n      let seed: unknown | null = null;\n      let nextSpecId = 0;\n      let nextSuiteId = 0;\n\n      const getNextSpecId = function () {\n        return `spec${nextSpecId++}`;\n      };\n\n      const getNextSuiteId = function () {\n        return `suite${nextSuiteId++}`;\n      };\n\n      const topSuite = new j$.Suite({\n        id: getNextSuiteId(),\n        description: '',\n        getTestPath() {\n          return j$.testPath;\n        },\n      });\n      let currentDeclarationSuite = topSuite;\n\n      const currentSuite = function () {\n        return currentlyExecutingSuites.at(-1)!;\n      };\n\n      const currentRunnable = function () {\n        return currentSpec || currentSuite();\n      };\n\n      const reporter = new j$.ReportDispatcher([\n        'jasmineStarted',\n        'jasmineDone',\n        'suiteStarted',\n        'suiteDone',\n        'specStarted',\n        'specDone',\n      ]);\n\n      this.specFilter = function () {\n        return true;\n      };\n\n      const defaultResourcesForRunnable = function (\n        id: string,\n        _parentRunnableId?: string,\n      ) {\n        const resources = {spies: []};\n\n        runnableResources[id] = resources;\n      };\n\n      const clearResourcesForRunnable = function (id: string) {\n        spyRegistry.clearSpies();\n        delete runnableResources[id];\n      };\n\n      const beforeAndAfterFns = function (suite: Suite) {\n        return function () {\n          let afters: Array<QueueableFn> = [];\n          let befores: Array<QueueableFn> = [];\n\n          while (suite) {\n            befores = befores.concat(suite.beforeFns);\n            afters = afters.concat(suite.afterFns);\n\n            suite = suite.parentSuite!;\n          }\n\n          return {\n            befores: befores.reverse(),\n            afters,\n          };\n        };\n      };\n\n      const getSpecName = function (spec: Spec, suite: Suite) {\n        const fullName = [spec.description];\n        const suiteFullName = suite.getFullName();\n\n        if (suiteFullName !== '') {\n          fullName.unshift(suiteFullName);\n        }\n\n        return fullName.join(' ');\n      };\n\n      this.catchExceptions = function (value) {\n        catchExceptions = !!value;\n        return catchExceptions;\n      };\n\n      this.catchingExceptions = function () {\n        return catchExceptions;\n      };\n\n      this.throwOnExpectationFailure = function (value) {\n        throwOnExpectationFailure = !!value;\n      };\n\n      this.throwingExpectationFailures = function () {\n        return throwOnExpectationFailure;\n      };\n\n      this.randomizeTests = function (value) {\n        random = !!value;\n      };\n\n      this.randomTests = function () {\n        return random;\n      };\n\n      this.seed = function (value) {\n        if (value) {\n          seed = value;\n        }\n        return seed;\n      };\n\n      const queueRunnerFactory = (options: QueueRunnerOptions) => {\n        options.clearTimeout = realClearTimeout;\n        options.fail = this.fail;\n        options.setTimeout = realSetTimeout;\n        return queueRunner(options);\n      };\n\n      this.topSuite = function () {\n        return topSuite;\n      };\n\n      const uncaught: NodeJS.UncaughtExceptionListener &\n        NodeJS.UnhandledRejectionListener = (err: any) => {\n        if (currentSpec) {\n          currentSpec.onException(err);\n          currentSpec.cancel();\n        } else {\n          console.error('Unhandled error');\n          console.error(err.stack);\n        }\n      };\n\n      let oldListenersException: Array<NodeJS.UncaughtExceptionListener>;\n      let oldListenersRejection: Array<NodeJS.UnhandledRejectionListener>;\n      const executionSetup = function () {\n        // Need to ensure we are the only ones handling these exceptions.\n        oldListenersException = [...process.listeners('uncaughtException')];\n        oldListenersRejection = [...process.listeners('unhandledRejection')];\n\n        j$.process.removeAllListeners('uncaughtException');\n        j$.process.removeAllListeners('unhandledRejection');\n\n        j$.process.on('uncaughtException', uncaught);\n        j$.process.on('unhandledRejection', uncaught);\n      };\n\n      const executionTeardown = function () {\n        j$.process.removeListener('uncaughtException', uncaught);\n        j$.process.removeListener('unhandledRejection', uncaught);\n\n        // restore previous exception handlers\n        for (const listener of oldListenersException) {\n          j$.process.on('uncaughtException', listener);\n        }\n\n        for (const listener of oldListenersRejection) {\n          j$.process.on('unhandledRejection', listener);\n        }\n      };\n\n      this.execute = async function (runnablesToRun, suiteTree = topSuite) {\n        if (!runnablesToRun) {\n          if (focusedRunnables.length > 0) {\n            runnablesToRun = focusedRunnables;\n          } else {\n            runnablesToRun = [suiteTree.id];\n          }\n        }\n\n        if (currentlyExecutingSuites.length === 0) {\n          executionSetup();\n        }\n\n        const lastDeclarationSuite = currentDeclarationSuite;\n\n        await treeProcessor({\n          nodeComplete(suite) {\n            if (!suite.disabled) {\n              clearResourcesForRunnable(suite.id);\n            }\n            currentlyExecutingSuites.pop();\n            if (suite === topSuite) {\n              reporter.jasmineDone({\n                failedExpectations: topSuite.result.failedExpectations,\n              });\n            } else {\n              reporter.suiteDone(suite.getResult());\n            }\n          },\n          nodeStart(suite) {\n            currentlyExecutingSuites.push(suite as Suite);\n            defaultResourcesForRunnable(\n              suite.id,\n              suite.parentSuite && suite.parentSuite.id,\n            );\n            if (suite === topSuite) {\n              reporter.jasmineStarted({totalSpecsDefined});\n            } else {\n              reporter.suiteStarted(suite.result);\n            }\n          },\n          queueRunnerFactory,\n          runnableIds: runnablesToRun,\n          tree: suiteTree as TreeNode,\n        });\n\n        currentDeclarationSuite = lastDeclarationSuite;\n\n        if (currentlyExecutingSuites.length === 0) {\n          executionTeardown();\n        }\n      };\n\n      this.addReporter = function (reporterToAdd) {\n        reporter.addReporter(reporterToAdd);\n      };\n\n      this.provideFallbackReporter = function (reporterToAdd) {\n        reporter.provideFallbackReporter(reporterToAdd);\n      };\n\n      this.clearReporters = function () {\n        reporter.clearReporters();\n      };\n\n      const spyRegistry = new j$.SpyRegistry({\n        currentSpies() {\n          if (!currentRunnable()) {\n            throw new Error(\n              'Spies must be created in a before function or a spec',\n            );\n          }\n          return runnableResources[currentRunnable().id].spies;\n        },\n      });\n\n      this.allowRespy = function (allow) {\n        spyRegistry.allowRespy(allow);\n      };\n\n      this.spyOn = function (...args) {\n        return spyRegistry.spyOn.apply(spyRegistry, args);\n      };\n\n      const suiteFactory = function (description: Circus.TestNameLike) {\n        const suite = new j$.Suite({\n          id: getNextSuiteId(),\n          description,\n          parentSuite: currentDeclarationSuite,\n          throwOnExpectationFailure,\n          getTestPath() {\n            return j$.testPath;\n          },\n        });\n\n        return suite;\n      };\n\n      this.describe = function (\n        description: Circus.TestNameLike,\n        specDefinitions,\n      ) {\n        const suite = suiteFactory(description);\n        if (specDefinitions === undefined) {\n          throw new Error(\n            'Missing second argument. It must be a callback function.',\n          );\n        }\n        if (typeof specDefinitions !== 'function') {\n          throw new TypeError(\n            `Invalid second argument, ${specDefinitions}. It must be a callback function.`,\n          );\n        }\n        if (specDefinitions.length > 0) {\n          throw new Error('describe does not expect any arguments');\n        }\n        if (currentDeclarationSuite.markedPending) {\n          suite.pend();\n        }\n        if (currentDeclarationSuite.markedTodo) {\n          // @ts-expect-error TODO Possible error: Suite does not have todo method\n          suite.todo();\n        }\n        addSpecsToSuite(suite, specDefinitions);\n        return suite;\n      };\n\n      this.xdescribe = function (description, specDefinitions) {\n        const suite = suiteFactory(description);\n        suite.pend();\n        addSpecsToSuite(suite, specDefinitions);\n        return suite;\n      };\n\n      const focusedRunnables: Array<string> = [];\n\n      this.fdescribe = function (description, specDefinitions) {\n        const suite = suiteFactory(description);\n        suite.isFocused = true;\n\n        focusedRunnables.push(suite.id);\n        unfocusAncestor();\n        addSpecsToSuite(suite, specDefinitions);\n\n        return suite;\n      };\n\n      const addSpecsToSuite = (\n        suite: Suite,\n        specDefinitions: SpecDefinitionsFn,\n      ) => {\n        const parentSuite = currentDeclarationSuite;\n        parentSuite.addChild(suite);\n        currentDeclarationSuite = suite;\n\n        let declarationError: undefined | Error = undefined;\n        let describeReturnValue: unknown | Error;\n        try {\n          describeReturnValue = specDefinitions.call(suite);\n        } catch (error: any) {\n          declarationError = error;\n        }\n\n        if (isPromise(describeReturnValue)) {\n          declarationError = new Error(\n            'Returning a Promise from \"describe\" is not supported. Tests must be defined synchronously.',\n          );\n        } else if (describeReturnValue !== undefined) {\n          declarationError = new Error(\n            'A \"describe\" callback must not return a value.',\n          );\n        }\n\n        if (declarationError) {\n          this.it('encountered a declaration exception', () => {\n            throw declarationError;\n          });\n        }\n\n        currentDeclarationSuite = parentSuite;\n      };\n\n      function findFocusedAncestor(suite: Suite) {\n        while (suite) {\n          if (suite.isFocused) {\n            return suite.id;\n          }\n          suite = suite.parentSuite!;\n        }\n\n        return null;\n      }\n\n      function unfocusAncestor() {\n        const focusedAncestor = findFocusedAncestor(currentDeclarationSuite);\n        if (focusedAncestor) {\n          for (let i = 0; i < focusedRunnables.length; i++) {\n            if (focusedRunnables[i] === focusedAncestor) {\n              focusedRunnables.splice(i, 1);\n              break;\n            }\n          }\n        }\n      }\n\n      const specFactory = (\n        description: Circus.TestNameLike,\n        fn: QueueableFn['fn'],\n        suite: Suite,\n        timeout?: number,\n      ): Spec => {\n        totalSpecsDefined++;\n        const spec = new j$.Spec({\n          id: getNextSpecId(),\n          beforeAndAfterFns: beforeAndAfterFns(suite),\n          resultCallback: specResultCallback,\n          getSpecName(spec: Spec) {\n            return getSpecName(spec, suite);\n          },\n          getTestPath() {\n            return j$.testPath;\n          },\n          onStart: specStarted,\n          description,\n          queueRunnerFactory,\n          userContext() {\n            return suite.clonedSharedUserContext();\n          },\n          queueableFn: {\n            fn,\n            timeout() {\n              return timeout || j$._DEFAULT_TIMEOUT_INTERVAL;\n            },\n          },\n          throwOnExpectationFailure,\n        });\n\n        if (!this.specFilter(spec)) {\n          spec.disable();\n        }\n\n        return spec;\n\n        function specResultCallback(result: SpecResult) {\n          clearResourcesForRunnable(spec.id);\n          currentSpec = null;\n          reporter.specDone(result);\n        }\n\n        function specStarted(spec: Spec) {\n          currentSpec = spec;\n          defaultResourcesForRunnable(spec.id, suite.id);\n          reporter.specStarted(spec.result);\n        }\n      };\n\n      this.it = function (description, fn, timeout) {\n        description = convertDescriptorToString(description);\n        if (fn === undefined) {\n          throw new Error(\n            'Missing second argument. It must be a callback function. Perhaps you want to use `test.todo` for a test placeholder.',\n          );\n        }\n        if (typeof fn !== 'function') {\n          throw new TypeError(\n            `Invalid second argument, ${fn}. It must be a callback function.`,\n          );\n        }\n        const spec = specFactory(\n          description,\n          fn,\n          currentDeclarationSuite,\n          timeout,\n        );\n        if (currentDeclarationSuite.markedPending) {\n          spec.pend();\n        }\n\n        // When a test is defined inside another, jasmine will not run it.\n        // This check throws an error to warn the user about the edge-case.\n        if (currentSpec !== null) {\n          throw new Error(\n            `Tests cannot be nested. Test \"${spec.description}\" cannot run because it is nested within \"${currentSpec.description}\".`,\n          );\n        }\n        currentDeclarationSuite.addChild(spec);\n        return spec;\n      };\n\n      this.xit = function (...args) {\n        const spec = this.it.apply(this, args);\n        spec.pend('Temporarily disabled with xit');\n        return spec;\n      };\n\n      this.todo = function () {\n        const description = arguments[0];\n        if (arguments.length !== 1 || typeof description !== 'string') {\n          throw new ErrorWithStack(\n            'Todo must be called with only a description.',\n            this.todo,\n          );\n        }\n\n        const spec = specFactory(\n          description,\n          // eslint-disable-next-line @typescript-eslint/no-empty-function\n          () => {},\n          currentDeclarationSuite,\n        );\n        if (currentDeclarationSuite.markedPending) {\n          spec.pend();\n        } else {\n          spec.todo();\n        }\n        currentDeclarationSuite.addChild(spec);\n        return spec;\n      };\n\n      this.fit = function (description, fn, timeout) {\n        const spec = specFactory(\n          description,\n          fn,\n          currentDeclarationSuite,\n          timeout,\n        );\n        currentDeclarationSuite.addChild(spec);\n        if (currentDeclarationSuite.markedPending) {\n          spec.pend();\n        } else {\n          focusedRunnables.push(spec.id);\n        }\n        unfocusAncestor();\n        return spec;\n      };\n\n      this.beforeEach = function (beforeEachFunction, timeout) {\n        currentDeclarationSuite.beforeEach({\n          fn: beforeEachFunction,\n          timeout() {\n            return timeout || j$._DEFAULT_TIMEOUT_INTERVAL;\n          },\n        });\n      };\n\n      this.beforeAll = function (beforeAllFunction, timeout) {\n        currentDeclarationSuite.beforeAll({\n          fn: beforeAllFunction,\n          timeout() {\n            return timeout || j$._DEFAULT_TIMEOUT_INTERVAL;\n          },\n        });\n      };\n\n      this.afterEach = function (afterEachFunction, timeout) {\n        currentDeclarationSuite.afterEach({\n          fn: afterEachFunction,\n          timeout() {\n            return timeout || j$._DEFAULT_TIMEOUT_INTERVAL;\n          },\n        });\n      };\n\n      this.afterAll = function (afterAllFunction, timeout) {\n        currentDeclarationSuite.afterAll({\n          fn: afterAllFunction,\n          timeout() {\n            return timeout || j$._DEFAULT_TIMEOUT_INTERVAL;\n          },\n        });\n      };\n\n      this.pending = function (message) {\n        let fullMessage = j$.Spec.pendingSpecExceptionMessage;\n        if (message) {\n          fullMessage += message;\n        }\n        throw fullMessage;\n      };\n\n      this.fail = function (error) {\n        let checkIsError;\n        let message;\n\n        if (\n          error instanceof AssertionError ||\n          (error && error.name === AssertionError.name)\n        ) {\n          checkIsError = false;\n          // @ts-expect-error TODO Possible error: j$.Spec does not have expand property\n          message = assertionErrorMessage(error, {expand: j$.Spec.expand});\n        } else {\n          const check = isError(error);\n\n          checkIsError = check.isError;\n          message = check.message || undefined;\n        }\n        const errorAsErrorObject = checkIsError ? error : new Error(message);\n        const runnable = currentRunnable();\n\n        if (!runnable) {\n          errorAsErrorObject.message = `Caught error after test environment was torn down\\n\\n${errorAsErrorObject.message}`;\n\n          throw errorAsErrorObject;\n        }\n\n        runnable.addExpectationResult(false, {\n          matcherName: '',\n          passed: false,\n          expected: '',\n          actual: '',\n          message,\n          error: errorAsErrorObject,\n        });\n      };\n    }\n  };\n}\n",
  "packages/jest-jasmine2/src/jasmine/Env.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport type { Circus } from '@jest/types';\nimport { type QueueableFn } from '../queueRunner';\nimport type { AssertionErrorWithStack, Jasmine, Reporter, SpecDefinitionsFn, Spy } from '../types';\nimport type { default as Spec } from './Spec';\nimport type Suite from './Suite';\nexport default function jasmineEnv(j$: Jasmine): {\n    new (): {\n        specFilter: (spec: Spec) => boolean;\n        catchExceptions: (value: unknown) => boolean;\n        throwOnExpectationFailure: (value: unknown) => void;\n        catchingExceptions: () => boolean;\n        topSuite: () => Suite;\n        fail: (error: Error | AssertionErrorWithStack) => void;\n        pending: (message: string) => void;\n        afterAll: (afterAllFunction: QueueableFn[\"fn\"], timeout?: number) => void;\n        fit: (description: Circus.TestNameLike, fn: QueueableFn[\"fn\"], timeout?: number) => Spec;\n        throwingExpectationFailures: () => boolean;\n        randomizeTests: (value: unknown) => void;\n        randomTests: () => boolean;\n        seed: (value: unknown) => unknown;\n        execute: (runnablesToRun?: Array<string>, suiteTree?: Suite) => Promise<void>;\n        fdescribe: (description: Circus.TestNameLike, specDefinitions: SpecDefinitionsFn) => Suite;\n        spyOn: (obj: Record<string, Spy>, methodName: string, accessType?: keyof PropertyDescriptor) => Spy;\n        beforeEach: (beforeEachFunction: QueueableFn[\"fn\"], timeout?: number) => void;\n        afterEach: (afterEachFunction: QueueableFn[\"fn\"], timeout?: number) => void;\n        clearReporters: () => void;\n        addReporter: (reporterToAdd: Reporter) => void;\n        it: (description: Circus.TestNameLike, fn: QueueableFn[\"fn\"], timeout?: number) => Spec;\n        xdescribe: (description: Circus.TestNameLike, specDefinitions: SpecDefinitionsFn) => Suite;\n        xit: (description: Circus.TestNameLike, fn: QueueableFn[\"fn\"], timeout?: number) => Spec;\n        beforeAll: (beforeAllFunction: QueueableFn[\"fn\"], timeout?: number) => void;\n        todo: () => Spec;\n        provideFallbackReporter: (reporterToAdd: Reporter) => void;\n        allowRespy: (allow: boolean) => void;\n        describe: (description: Circus.TestNameLike, specDefinitions: SpecDefinitionsFn) => Suite;\n    };\n};\n",
  "packages/jest-jasmine2/src/jasmine/CallTracker.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n// This file is a heavily modified fork of Jasmine. Original license:\n/*\nCopyright (c) 2008-2016 Pivotal Labs\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nexport type Context = {\n  object: unknown;\n  args: Array<unknown>;\n  returnValue?: unknown;\n};\n\nclass CallTracker {\n  track: (context: Context) => void;\n  any: () => boolean;\n  count: () => number;\n  argsFor: (index: number) => Array<unknown>;\n  all: () => Array<Context>;\n  allArgs: () => Array<unknown>;\n  first: () => Context;\n  mostRecent: () => Context;\n  reset: () => void;\n\n  constructor() {\n    let calls: Array<Context> = [];\n\n    this.track = function (context: Context) {\n      calls.push(context);\n    };\n\n    this.any = function () {\n      return calls.length > 0;\n    };\n\n    this.count = function () {\n      return calls.length;\n    };\n\n    this.argsFor = function (index) {\n      const call = calls[index];\n      return call ? call.args : [];\n    };\n\n    this.all = function () {\n      return calls;\n    };\n\n    this.allArgs = function () {\n      const callArgs: Array<unknown> = [];\n      for (const call of calls) {\n        callArgs.push(call.args);\n      }\n\n      return callArgs;\n    };\n\n    this.first = function () {\n      return calls[0];\n    };\n\n    this.mostRecent = function () {\n      return calls.at(-1)!;\n    };\n\n    this.reset = function () {\n      calls = [];\n    };\n  }\n}\n\nexport default CallTracker;\n",
  "packages/jest-jasmine2/src/jasmine/CallTracker.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport type Context = {\n    object: unknown;\n    args: Array<unknown>;\n    returnValue?: unknown;\n};\ndeclare class CallTracker {\n    track: (context: Context) => void;\n    any: () => boolean;\n    count: () => number;\n    argsFor: (index: number) => Array<unknown>;\n    all: () => Array<Context>;\n    allArgs: () => Array<unknown>;\n    first: () => Context;\n    mostRecent: () => Context;\n    reset: () => void;\n    constructor();\n}\nexport default CallTracker;\n",
  "packages/jest-jasmine2/src/__tests__/todoError.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\ndescribe('test/it.todo error throwing', () => {\n  it('it throws error when given no arguments', () => {\n    expect(() => {\n      // @ts-expect-error\n      it.todo();\n    }).toThrow('Todo must be called with only a description.');\n  });\n  it('it throws error when given more than one argument', () => {\n    expect(() => {\n      // @ts-expect-error: Testing runtime errors here\n      it.todo('test1', () => {});\n    }).toThrow('Todo must be called with only a description.');\n  });\n  it('it throws error when given none string description', () => {\n    expect(() => {\n      it.todo(() => {});\n    }).toThrow('Todo must be called with only a description.');\n  });\n});\n",
  "packages/jest-jasmine2/src/__tests__/todoError.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n",
  "packages/jest-jasmine2/src/__tests__/reporter.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {SpecResult} from '../jasmine/Spec';\nimport type {SuiteResult} from '../jasmine/Suite';\nimport JasmineReporter from '../reporter';\n\ndescribe('Jasmine2Reporter', () => {\n  let reporter: JasmineReporter;\n\n  beforeEach(() => {\n    // @ts-expect-error\n    reporter = new JasmineReporter({});\n  });\n\n  it('reports nested suites', () => {\n    const makeSpec = (name: string) =>\n      ({\n        description: 'description',\n        failedExpectations: [],\n        fullName: name,\n      }) as any as SpecResult;\n    reporter.suiteStarted({description: 'parent'} as SuiteResult);\n    reporter.suiteStarted({description: 'child'} as SuiteResult);\n    reporter.specDone(makeSpec('spec 1'));\n    // @ts-expect-error\n    reporter.suiteDone();\n    reporter.suiteStarted({description: 'child 2'} as SuiteResult);\n    reporter.specDone(makeSpec('spec 2'));\n    // @ts-expect-error\n    reporter.jasmineDone();\n\n    return reporter.getResults().then(runResults => {\n      const firstResult = runResults.testResults[0];\n      expect(firstResult.ancestorTitles[0]).toBe('parent');\n      expect(firstResult.ancestorTitles[1]).toBe('child');\n      const secondResult = runResults.testResults[1];\n      expect(secondResult.ancestorTitles[1]).toBe('child 2');\n    });\n  });\n});\n",
  "packages/jest-jasmine2/src/__tests__/reporter.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport {};\n",
  "packages/jest-jasmine2/src/__tests__/queueRunner.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport queueRunner, {type Options, type QueueableFn} from '../queueRunner';\n\ndescribe('queueRunner', () => {\n  it('runs every function in the queue.', async () => {\n    const fnOne = jest.fn(next => next());\n    const fnTwo = jest.fn(next => next());\n    const options: Options = {\n      clearTimeout,\n      fail: jest.fn(),\n      onException: jest.fn(),\n      queueableFns: [{fn: fnOne}, {fn: fnTwo}],\n      setTimeout,\n      userContext: {} as any,\n    };\n\n    await queueRunner(options);\n    expect(fnOne).toHaveBeenCalled();\n    expect(fnTwo).toHaveBeenCalled();\n  });\n\n  it('exposes `fail` to `next`.', async () => {\n    const fail = jest.fn();\n    const fnOne = jest.fn(next => next.fail());\n    const fnTwo = jest.fn(next => next());\n    const options: Options = {\n      clearTimeout,\n      fail,\n      onException: jest.fn(),\n      queueableFns: [{fn: fnOne}, {fn: fnTwo}],\n      setTimeout,\n      userContext: {} as any,\n    };\n\n    await queueRunner(options);\n    expect(fnOne).toHaveBeenCalled();\n    expect(fail).toHaveBeenCalled();\n    // Even if `fail` is called, the queue keeps running.\n    expect(fnTwo).toHaveBeenCalled();\n  });\n\n  it('passes errors to `onException`.', async () => {\n    const error = new Error('The error a test throws.');\n    const fnOne = jest.fn(() => {\n      throw error;\n    });\n    const fnTwo = jest.fn(next => next());\n    const onException = jest.fn();\n    const options: Options = {\n      clearTimeout,\n      fail: jest.fn(),\n      onException,\n      queueableFns: [{fn: fnOne}, {fn: fnTwo}],\n      setTimeout,\n      userContext: {} as any,\n    };\n\n    await queueRunner(options);\n    expect(fnOne).toHaveBeenCalled();\n    expect(onException).toHaveBeenCalledWith(error);\n    // Even if one of them errors, the queue keeps running.\n    expect(fnTwo).toHaveBeenCalled();\n  });\n\n  it('passes an error to `onException` on timeout.', async () => {\n    const fnOne = jest.fn<QueueableFn['fn']>(_next => {});\n    const fnTwo = jest.fn<QueueableFn['fn']>(next => next());\n    const onException = jest.fn<(error: Error) => void>();\n    const options: Options = {\n      clearTimeout,\n      fail: jest.fn(),\n      onException,\n      queueableFns: [\n        {\n          fn: fnOne,\n          // It times out in zero seconds.\n          timeout: () => 0,\n        },\n        {fn: fnTwo},\n      ],\n      setTimeout,\n      userContext: {} as any,\n    };\n\n    await queueRunner(options);\n    expect(fnOne).toHaveBeenCalled();\n    expect(onException).toHaveBeenCalled();\n    // i.e. the `message` of the error passed to `onException`.\n    expect(onException.mock.calls[0][0].message).toEqual(\n      'Timeout - Async callback was not invoked within the 0 ms timeout ' +\n        'specified by jest.setTimeout.',\n    );\n    expect(fnTwo).toHaveBeenCalled();\n  });\n\n  it('calls `fail` with arguments', async () => {\n    const failFn = jest.fn(next => next.fail('miserably', 'failed'));\n    const options: Options = {\n      clearTimeout,\n      fail: jest.fn(),\n      onException: jest.fn(),\n      queueableFns: [{fn: failFn}],\n      setTimeout,\n      userContext: {} as any,\n    };\n\n    await queueRunner(options);\n\n    expect(options.fail).toHaveBeenCalledWith('miserably', 'failed');\n  });\n\n  it('calls `fail` when done(error) is invoked', async () => {\n    const error = new Error('I am an error');\n    const fail = jest.fn();\n    const fnOne = jest.fn(next => next(error));\n    const fnTwo = jest.fn(next => next());\n    const options: Options = {\n      clearTimeout,\n      fail,\n      onException: jest.fn(),\n      queueableFns: [{fn: fnOne}, {fn: fnTwo}],\n      setTimeout,\n      userContext: {} as any,\n    };\n\n    await queueRunner(options);\n    expect(fnOne).toHaveBeenCalled();\n    expect(fail).toHaveBeenCalledWith(error);\n    // Even if `fail` is called, the queue keeps running.\n    expect(fnTwo).toHaveBeenCalled();\n  });\n});\n",
  "packages/jest-jasmine2/src/__tests__/queueRunner.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport {};\n",
  "packages/jest-jasmine2/src/__tests__/pTimeout.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\njest.useFakeTimers();\n\nimport pTimeout from '../pTimeout';\n\ndescribe('pTimeout', () => {\n  beforeEach(() => {\n    jest.spyOn(globalThis, 'setTimeout');\n    jest.spyOn(globalThis, 'clearTimeout');\n  });\n\n  it('calls `clearTimeout` and resolves when `promise` resolves.', async () => {\n    const onTimeout = jest.fn();\n    const promise = Promise.resolve();\n    await pTimeout(promise, 1000, clearTimeout, setTimeout, onTimeout);\n    expect(setTimeout).toHaveBeenCalled();\n    expect(clearTimeout).toHaveBeenCalled();\n    expect(onTimeout).not.toHaveBeenCalled();\n  });\n\n  it('calls `clearTimeout` and rejects when `promise` rejects.', async () => {\n    const onTimeout = jest.fn();\n    const promise = Promise.reject();\n    try {\n      await pTimeout(promise, 1000, clearTimeout, setTimeout, onTimeout);\n    } catch {}\n    expect(setTimeout).toHaveBeenCalled();\n    expect(clearTimeout).toHaveBeenCalled();\n    expect(onTimeout).not.toHaveBeenCalled();\n  });\n\n  it('calls `onTimeout` on timeout.', async () => {\n    const onTimeout = jest.fn();\n    // A Promise that never resolves or rejects.\n    const promise = new Promise<void>(() => {});\n    const timeoutPromise = pTimeout(\n      promise,\n      1000,\n      clearTimeout,\n      setTimeout,\n      onTimeout,\n    );\n    jest.runAllTimers();\n    await timeoutPromise;\n    expect(setTimeout).toHaveBeenCalled();\n    expect(onTimeout).toHaveBeenCalled();\n  });\n});\n",
  "packages/jest-jasmine2/src/__tests__/pTimeout.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport {};\n",
  "packages/jest-jasmine2/src/__tests__/iterators.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\ndescribe('iterators', () => {\n  it('works for arrays', () => {\n    const mixedArray = [1, {}, []];\n\n    expect(mixedArray).toEqual(mixedArray);\n    expect([1, 2, 3]).toEqual([1, 2, 3]);\n    expect([1]).not.toEqual([2]);\n    expect([1, 2, 3]).not.toEqual([1, 2]);\n    expect([1, 2, 3]).not.toEqual([1, 2, 3, 4]);\n  });\n\n  it('works for custom iterables', () => {\n    const iterable = {\n      0: 'a',\n      1: 'b',\n      2: 'c',\n      length: 3,\n      [Symbol.iterator]: Array.prototype[Symbol.iterator],\n    };\n    const expectedIterable = {\n      0: 'a',\n      1: 'b',\n      2: 'c',\n      length: 3,\n      [Symbol.iterator]: Array.prototype[Symbol.iterator],\n    };\n    expect(iterable).toEqual(expectedIterable);\n    expect(iterable).not.toEqual(['a', 'b']);\n    expect(iterable).not.toEqual(['a', 'b', 'c']);\n    expect(iterable).not.toEqual(['a', 'b', 'c', 'd']);\n  });\n\n  it('works for Sets', () => {\n    const numbers = [1, 2, 3, 4];\n    const setOfNumbers = new Set(numbers);\n    expect(setOfNumbers).not.toEqual(new Set());\n    expect(setOfNumbers).not.toBe(numbers);\n    expect(setOfNumbers).not.toEqual([1, 2]);\n    expect(setOfNumbers).not.toEqual([1, 2, 3]);\n    expect(setOfNumbers).toEqual(new Set(numbers));\n\n    const nestedSets = new Set([new Set([1, 2])]);\n    expect(nestedSets).not.toEqual(new Set([new Set([1, 4])]));\n    expect(nestedSets).toEqual(new Set([new Set([1, 2])]));\n  });\n\n  it('works for Maps', () => {\n    const keyValuePairs: ReadonlyArray<[string, string]> = [\n      ['key1', 'value1'],\n      ['key2', 'value2'],\n    ];\n    const smallerKeyValuePairs: ReadonlyArray<[string, string]> = [\n      ['key1', 'value1'],\n    ];\n    const biggerKeyValuePairs: ReadonlyArray<[string, string]> = [\n      ['key1', 'value1'],\n      ['key2', 'value2'],\n      ['key3', 'value3'],\n    ];\n    const map = new Map(keyValuePairs);\n    expect(map).not.toEqual(smallerKeyValuePairs);\n    expect(map).not.toEqual(new Map(smallerKeyValuePairs));\n    expect(map).not.toEqual(biggerKeyValuePairs);\n    expect(map).not.toEqual(new Map(biggerKeyValuePairs));\n    expect(map).not.toEqual(keyValuePairs);\n    expect(map).not.toBe(keyValuePairs);\n    expect(map).toEqual(new Map(keyValuePairs));\n  });\n});\n",
  "packages/jest-jasmine2/src/__tests__/iterators.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n",
  "packages/jest-jasmine2/src/__tests__/itToTestAlias.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\ntest('global.test', () => {});\n",
  "packages/jest-jasmine2/src/__tests__/itToTestAlias.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n",
  "packages/jest-jasmine2/src/__tests__/itTestError.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\ndescribe('test/it error throwing', () => {\n  it('it throws error with missing callback function', () => {\n    expect(() => {\n      // @ts-expect-error: Testing runtime errors here\n      it('test1');\n    }).toThrow(\n      'Missing second argument. It must be a callback function. Perhaps you want to use `test.todo` for a test placeholder.',\n    );\n  });\n  it(\"it throws an error when first argument isn't valid\", () => {\n    expect(() => {\n      // @ts-expect-error: Testing runtime errors here\n      it(() => {});\n    }).toThrow(\n      'Invalid first argument, () => {}. It must be a named class, named function, number, or string.',\n    );\n  });\n  it('it throws an error when callback function is not a function', () => {\n    expect(() => {\n      // @ts-expect-error: Testing runtime errors here\n      it('test3', 'test3b');\n    }).toThrow(\n      'Invalid second argument, test3b. It must be a callback function.',\n    );\n  });\n  test('test throws error with missing callback function', () => {\n    expect(() => {\n      // @ts-expect-error: Testing runtime errors here\n      test('test4');\n    }).toThrow(\n      'Missing second argument. It must be a callback function. Perhaps you want to use `test.todo` for a test placeholder.',\n    );\n  });\n  test(\"test throws an error when first argument isn't valid\", () => {\n    expect(() => {\n      // @ts-expect-error: Testing runtime errors here\n      test(() => {});\n    }).toThrow(\n      'Invalid first argument, () => {}. It must be a named class, named function, number, or string.',\n    );\n  });\n  test('test throws an error when callback function is not a function', () => {\n    expect(() => {\n      // @ts-expect-error: Testing runtime errors here\n      test('test6', 'test6b');\n    }).toThrow(\n      'Invalid second argument, test6b. It must be a callback function.',\n    );\n  });\n});\n",
  "packages/jest-jasmine2/src/__tests__/itTestError.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n",
  "packages/jest-jasmine2/src/__tests__/hooksError.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ndescribe.each(['beforeEach', 'beforeAll', 'afterEach', 'afterAll'] as const)(\n  '%s hooks error throwing',\n  fn => {\n    test.each([\n      ['String'],\n      [1],\n      [[]],\n      [{}],\n      [Symbol('hello')],\n      [true],\n      [null],\n      [undefined],\n    ])(\n      `${fn} throws an error when %p is provided as a first argument to it`,\n      el => {\n        expect(() => {\n          // @ts-expect-error: Testing runtime errors\n          globalThis[fn](el);\n        }).toThrow('Invalid first argument. It must be a callback function.');\n      },\n    );\n  },\n);\n",
  "packages/jest-jasmine2/src/__tests__/hooksError.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n",
  "packages/jest-jasmine2/src/__tests__/expectationResultFactory.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport expectationResultFactory from '../expectationResultFactory';\n\ndescribe('expectationResultFactory', () => {\n  it('returns the result if passed.', () => {\n    const options = {\n      matcherName: 'testMatcher',\n      passed: true,\n    };\n    const result = expectationResultFactory(options);\n    expect(result).toMatchSnapshot();\n  });\n\n  it('returns the result if failed.', () => {\n    const options = {\n      actual: 'Fail',\n      expected: 'Pass',\n      matcherName: 'testMatcher',\n      passed: false,\n    };\n    const result = expectationResultFactory(options);\n    expect(result.message).toBe('thrown: undefined');\n  });\n\n  it('returns the result if failed (with `message`).', () => {\n    const message = 'This message is not \"Expected `Pass`, received `Fail`.\"';\n    const options = {\n      actual: 'Fail',\n      error: new Error('This will be ignored in `message`.'),\n      expected: 'Pass',\n      matcherName: 'testMatcher',\n      message,\n      passed: false,\n    };\n    const result = expectationResultFactory(options);\n    expect(result.message).toEqual(message);\n  });\n\n  it('returns the result if failed (with `error`).', () => {\n    const options = {\n      actual: 'Fail',\n      error: new Error('Expected `Pass`, received `Fail`.'),\n      expected: 'Pass',\n      matcherName: 'testMatcher',\n      passed: false,\n    };\n    const result = expectationResultFactory(options);\n    expect(result.message).toBe('Error: Expected `Pass`, received `Fail`.');\n  });\n\n  it('returns the error name if the error message is empty', () => {\n    const options = {\n      actual: 'Fail',\n      error: new Error(),\n      expected: 'Pass',\n      matcherName: 'testMatcher',\n      passed: false,\n    };\n    const result = expectationResultFactory(options);\n    expect(result.message).toBe('Error');\n  });\n\n  it('returns the result if failed (with `error` as a string).', () => {\n    const options = {\n      actual: 'Fail',\n      error: 'Expected `Pass`, received `Fail`.',\n      expected: 'Pass',\n      matcherName: 'testMatcher',\n      passed: false,\n    };\n    const result = expectationResultFactory(options);\n    expect(result.message).toBe('Expected `Pass`, received `Fail`.');\n  });\n\n  it('returns the result if failed (with `error.stack` not as a string).', () => {\n    const options = {\n      actual: 'Fail',\n      error: {stack: 42},\n      expected: 'Pass',\n      matcherName: 'testMatcher',\n      passed: false,\n    };\n    const result = expectationResultFactory(options);\n    expect(result.message).toMatchSnapshot();\n  });\n});\n",
  "packages/jest-jasmine2/src/__tests__/expectationResultFactory.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport {};\n",
  "packages/jest-jasmine2/src/__tests__/concurrent.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\ndescribe('concurrent', () => {\n  test.concurrent.each([\n    [1, 2],\n    [2, 3],\n    [3, 4],\n  ])('should add 1 to number', async (a, sum) => {\n    expect(a + 1).toEqual(sum);\n  });\n});\n",
  "packages/jest-jasmine2/src/__tests__/concurrent.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n",
  "packages/jest-jasmine2/src/__tests__/Suite.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport Suite, {type Attributes} from '../jasmine/Suite';\n\ndescribe('Suite', () => {\n  let suite: Suite;\n\n  beforeEach(() => {\n    suite = new Suite({\n      getTestPath: () => '',\n    } as Attributes);\n  });\n\n  it(\"doesn't throw on addExpectationResult when there are no children\", () => {\n    expect(() => {\n      // @ts-expect-error: Testing runtime errors here\n      suite.addExpectationResult();\n    }).not.toThrow();\n  });\n});\n",
  "packages/jest-jasmine2/src/__tests__/Suite.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport {};\n",
  "packages/jest-haste-map/src/worker.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {createHash} from 'crypto';\nimport * as path from 'path';\nimport * as fs from 'graceful-fs';\nimport {requireOrImportModule} from 'jest-util';\nimport blacklist from './blacklist';\nimport H from './constants';\nimport {extractor as defaultDependencyExtractor} from './lib/dependencyExtractor';\nimport type {\n  DependencyExtractor,\n  HasteImpl,\n  WorkerMessage,\n  WorkerMetadata,\n} from './types';\n\nconst PACKAGE_JSON = `${path.sep}package.json`;\n\nfunction sha1hex(content: string | Buffer): string {\n  return createHash('sha1').update(content).digest('hex');\n}\n\nexport async function worker(data: WorkerMessage): Promise<WorkerMetadata> {\n  const hasteImpl: HasteImpl | null = data.hasteImplModulePath\n    ? require(data.hasteImplModulePath)\n    : null;\n\n  let content: string | undefined;\n  let dependencies: WorkerMetadata['dependencies'];\n  let id: WorkerMetadata['id'];\n  let module: WorkerMetadata['module'];\n  let sha1: WorkerMetadata['sha1'];\n\n  const {computeDependencies, computeSha1, rootDir, filePath} = data;\n\n  const getContent = (): string => {\n    if (content === undefined) {\n      content = fs.readFileSync(filePath, 'utf8');\n    }\n\n    return content;\n  };\n\n  if (filePath.endsWith(PACKAGE_JSON)) {\n    // Process a package.json that is returned as a PACKAGE type with its name.\n    try {\n      const fileData = JSON.parse(getContent());\n\n      if (fileData.name) {\n        const relativeFilePath = path.relative(rootDir, filePath);\n        id = fileData.name;\n        module = [relativeFilePath, H.PACKAGE];\n      }\n    } catch (error: any) {\n      throw new Error(`Cannot parse ${filePath} as JSON: ${error.message}`);\n    }\n  } else if (!blacklist.has(filePath.slice(filePath.lastIndexOf('.')))) {\n    // Process a random file that is returned as a MODULE.\n    if (hasteImpl) {\n      id = hasteImpl.getHasteName(filePath);\n    }\n\n    if (computeDependencies) {\n      const content = getContent();\n      const extractor = data.dependencyExtractor\n        ? await requireOrImportModule<DependencyExtractor>(\n            data.dependencyExtractor,\n            false,\n          )\n        : defaultDependencyExtractor;\n      dependencies = [\n        ...extractor.extract(\n          content,\n          filePath,\n          defaultDependencyExtractor.extract,\n        ),\n      ];\n    }\n\n    if (id) {\n      const relativeFilePath = path.relative(rootDir, filePath);\n      module = [relativeFilePath, H.MODULE];\n    }\n  }\n\n  // If a SHA-1 is requested on update, compute it.\n  if (computeSha1) {\n    sha1 = sha1hex(content || fs.readFileSync(filePath));\n  }\n\n  return {dependencies, id, module, sha1};\n}\n\nexport async function getSha1(data: WorkerMessage): Promise<WorkerMetadata> {\n  const sha1 = data.computeSha1\n    ? sha1hex(fs.readFileSync(data.filePath))\n    : null;\n\n  return {\n    dependencies: undefined,\n    id: undefined,\n    module: undefined,\n    sha1,\n  };\n}\n",
  "packages/jest-haste-map/src/worker.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { WorkerMessage, WorkerMetadata } from './types';\nexport declare function worker(data: WorkerMessage): Promise<WorkerMetadata>;\nexport declare function getSha1(data: WorkerMessage): Promise<WorkerMetadata>;\n",
  "packages/jest-haste-map/src/types.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// eslint-disable-next-line no-restricted-imports\nimport type {Stats} from 'fs';\nimport type HasteFS from './HasteFS';\nimport type ModuleMap from './ModuleMap';\n\ntype ValueType<T> = T extends Map<string, infer V> ? V : never;\n\nexport type SerializableModuleMap = {\n  duplicates: ReadonlyArray<[string, [string, [string, [string, number]]]]>;\n  map: ReadonlyArray<[string, ValueType<ModuleMapData>]>;\n  mocks: ReadonlyArray<[string, ValueType<MockData>]>;\n  rootDir: string;\n};\n\nexport interface IModuleMap<S = SerializableModuleMap> {\n  getModule(\n    name: string,\n    platform?: string | null,\n    supportsNativePlatform?: boolean | null,\n    type?: HTypeValue | null,\n  ): string | null;\n\n  getPackage(\n    name: string,\n    platform: string | null | undefined,\n    _supportsNativePlatform: boolean | null,\n  ): string | null;\n\n  getMockModule(name: string): string | undefined;\n\n  getRawModuleMap(): RawModuleMap;\n\n  toJSON(): S;\n}\n\nexport interface IHasteFS {\n  exists(path: string): boolean;\n  getAbsoluteFileIterator(): Iterable<string>;\n  getAllFiles(): Array<string>;\n  getDependencies(file: string): Array<string> | null;\n  getSize(path: string): number | null;\n  matchFiles(pattern: RegExp | string): Array<string>;\n  matchFilesWithGlob(\n    globs: ReadonlyArray<string>,\n    root: string | null,\n  ): Set<string>;\n  getModuleName(file: string): string | null;\n}\n\nexport interface IHasteMap {\n  on(eventType: 'change', handler: (event: ChangeEvent) => void): void;\n  build(): Promise<{hasteFS: IHasteFS; moduleMap: IModuleMap}>;\n}\n\nexport type HasteMapStatic<S = SerializableModuleMap> = {\n  getCacheFilePath(\n    tmpdir: string,\n    name: string,\n    ...extra: Array<string>\n  ): string;\n  getModuleMapFromJSON(json: S): IModuleMap<S>;\n};\n\nexport type IgnoreMatcher = (item: string) => boolean;\n\nexport type WorkerMessage = {\n  computeDependencies: boolean;\n  computeSha1: boolean;\n  dependencyExtractor?: string | null;\n  rootDir: string;\n  filePath: string;\n  hasteImplModulePath?: string;\n  retainAllFiles?: boolean;\n};\n\nexport type WorkerMetadata = {\n  dependencies: Array<string> | undefined | null;\n  id: string | undefined | null;\n  module: ModuleMetaData | undefined | null;\n  sha1: string | undefined | null;\n};\n\nexport type CrawlerOptions = {\n  computeSha1: boolean;\n  enableSymlinks: boolean;\n  data: InternalHasteMap;\n  extensions: Array<string>;\n  forceNodeFilesystemAPI: boolean;\n  ignore: IgnoreMatcher;\n  rootDir: string;\n  roots: Array<string>;\n};\n\nexport type HasteImpl = {\n  getHasteName(filePath: string): string | undefined;\n};\n\nexport type FileData = Map<string, FileMetaData>;\n\nexport type FileMetaData = [\n  id: string,\n  mtime: number,\n  size: number,\n  visited: 0 | 1,\n  dependencies: string,\n  sha1: string | null | undefined,\n];\n\nexport type MockData = Map<string, string>;\nexport type ModuleMapData = Map<string, ModuleMapItem>;\nexport type WatchmanClockSpec = string | {scm: {'mergebase-with': string}};\nexport type WatchmanClocks = Map<string, WatchmanClockSpec>;\nexport type HasteRegExp = RegExp | ((str: string) => boolean);\n\nexport type DuplicatesSet = Map<string, /* type */ number>;\nexport type DuplicatesIndex = Map<string, Map<string, DuplicatesSet>>;\n\nexport type InternalHasteMap = {\n  clocks: WatchmanClocks;\n  duplicates: DuplicatesIndex;\n  files: FileData;\n  map: ModuleMapData;\n  mocks: MockData;\n};\nexport type HasteMap = {\n  hasteFS: HasteFS;\n  moduleMap: ModuleMap;\n  __hasteMapForTest?: InternalHasteMap | null;\n};\n\nexport type RawModuleMap = {\n  rootDir: string;\n  duplicates: DuplicatesIndex;\n  map: ModuleMapData;\n  mocks: MockData;\n};\n\nexport type ModuleMapItem = {[platform: string]: ModuleMetaData};\nexport type ModuleMetaData = [path: string, type: number];\n\nexport type HType = {\n  ID: 0;\n  MTIME: 1;\n  SIZE: 2;\n  VISITED: 3;\n  DEPENDENCIES: 4;\n  SHA1: 5;\n  PATH: 0;\n  TYPE: 1;\n  MODULE: 0;\n  PACKAGE: 1;\n  GENERIC_PLATFORM: 'g';\n  NATIVE_PLATFORM: 'native';\n  DEPENDENCY_DELIM: '\\0';\n};\n\nexport type HTypeValue = HType[keyof HType];\n\nexport type EventsQueue = Array<{\n  filePath: string;\n  stat: Stats | undefined;\n  type: string;\n}>;\n\nexport type ChangeEvent = {\n  eventsQueue: EventsQueue;\n  hasteFS: HasteFS;\n  moduleMap: ModuleMap;\n};\n\nexport type DependencyExtractor = {\n  extract: (\n    code: string,\n    filePath: string,\n    defaultExtract: DependencyExtractor['extract'],\n  ) => Iterable<string>;\n  getCacheKey?: () => string;\n};\n",
  "packages/jest-haste-map/src/types.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Stats } from 'fs';\nimport type HasteFS from './HasteFS';\nimport type ModuleMap from './ModuleMap';\ntype ValueType<T> = T extends Map<string, infer V> ? V : never;\nexport type SerializableModuleMap = {\n    duplicates: ReadonlyArray<[string, [string, [string, [string, number]]]]>;\n    map: ReadonlyArray<[string, ValueType<ModuleMapData>]>;\n    mocks: ReadonlyArray<[string, ValueType<MockData>]>;\n    rootDir: string;\n};\nexport interface IModuleMap<S = SerializableModuleMap> {\n    getModule(name: string, platform?: string | null, supportsNativePlatform?: boolean | null, type?: HTypeValue | null): string | null;\n    getPackage(name: string, platform: string | null | undefined, _supportsNativePlatform: boolean | null): string | null;\n    getMockModule(name: string): string | undefined;\n    getRawModuleMap(): RawModuleMap;\n    toJSON(): S;\n}\nexport interface IHasteFS {\n    exists(path: string): boolean;\n    getAbsoluteFileIterator(): Iterable<string>;\n    getAllFiles(): Array<string>;\n    getDependencies(file: string): Array<string> | null;\n    getSize(path: string): number | null;\n    matchFiles(pattern: RegExp | string): Array<string>;\n    matchFilesWithGlob(globs: ReadonlyArray<string>, root: string | null): Set<string>;\n    getModuleName(file: string): string | null;\n}\nexport interface IHasteMap {\n    on(eventType: 'change', handler: (event: ChangeEvent) => void): void;\n    build(): Promise<{\n        hasteFS: IHasteFS;\n        moduleMap: IModuleMap;\n    }>;\n}\nexport type HasteMapStatic<S = SerializableModuleMap> = {\n    getCacheFilePath(tmpdir: string, name: string, ...extra: Array<string>): string;\n    getModuleMapFromJSON(json: S): IModuleMap<S>;\n};\nexport type IgnoreMatcher = (item: string) => boolean;\nexport type WorkerMessage = {\n    computeDependencies: boolean;\n    computeSha1: boolean;\n    dependencyExtractor?: string | null;\n    rootDir: string;\n    filePath: string;\n    hasteImplModulePath?: string;\n    retainAllFiles?: boolean;\n};\nexport type WorkerMetadata = {\n    dependencies: Array<string> | undefined | null;\n    id: string | undefined | null;\n    module: ModuleMetaData | undefined | null;\n    sha1: string | undefined | null;\n};\nexport type CrawlerOptions = {\n    computeSha1: boolean;\n    enableSymlinks: boolean;\n    data: InternalHasteMap;\n    extensions: Array<string>;\n    forceNodeFilesystemAPI: boolean;\n    ignore: IgnoreMatcher;\n    rootDir: string;\n    roots: Array<string>;\n};\nexport type HasteImpl = {\n    getHasteName(filePath: string): string | undefined;\n};\nexport type FileData = Map<string, FileMetaData>;\nexport type FileMetaData = [\n    id: string,\n    mtime: number,\n    size: number,\n    visited: 0 | 1,\n    dependencies: string,\n    sha1: string | null | undefined\n];\nexport type MockData = Map<string, string>;\nexport type ModuleMapData = Map<string, ModuleMapItem>;\nexport type WatchmanClockSpec = string | {\n    scm: {\n        'mergebase-with': string;\n    };\n};\nexport type WatchmanClocks = Map<string, WatchmanClockSpec>;\nexport type HasteRegExp = RegExp | ((str: string) => boolean);\nexport type DuplicatesSet = Map<string, /* type */ number>;\nexport type DuplicatesIndex = Map<string, Map<string, DuplicatesSet>>;\nexport type InternalHasteMap = {\n    clocks: WatchmanClocks;\n    duplicates: DuplicatesIndex;\n    files: FileData;\n    map: ModuleMapData;\n    mocks: MockData;\n};\nexport type HasteMap = {\n    hasteFS: HasteFS;\n    moduleMap: ModuleMap;\n    __hasteMapForTest?: InternalHasteMap | null;\n};\nexport type RawModuleMap = {\n    rootDir: string;\n    duplicates: DuplicatesIndex;\n    map: ModuleMapData;\n    mocks: MockData;\n};\nexport type ModuleMapItem = {\n    [platform: string]: ModuleMetaData;\n};\nexport type ModuleMetaData = [path: string, type: number];\nexport type HType = {\n    ID: 0;\n    MTIME: 1;\n    SIZE: 2;\n    VISITED: 3;\n    DEPENDENCIES: 4;\n    SHA1: 5;\n    PATH: 0;\n    TYPE: 1;\n    MODULE: 0;\n    PACKAGE: 1;\n    GENERIC_PLATFORM: 'g';\n    NATIVE_PLATFORM: 'native';\n    DEPENDENCY_DELIM: '\\0';\n};\nexport type HTypeValue = HType[keyof HType];\nexport type EventsQueue = Array<{\n    filePath: string;\n    stat: Stats | undefined;\n    type: string;\n}>;\nexport type ChangeEvent = {\n    eventsQueue: EventsQueue;\n    hasteFS: HasteFS;\n    moduleMap: ModuleMap;\n};\nexport type DependencyExtractor = {\n    extract: (code: string, filePath: string, defaultExtract: DependencyExtractor['extract']) => Iterable<string>;\n    getCacheKey?: () => string;\n};\nexport {};\n",
  "packages/jest-haste-map/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {createHash} from 'crypto';\nimport {EventEmitter} from 'events';\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport {deserialize, serialize} from 'v8';\nimport {type Stats, readFileSync, writeFileSync} from 'graceful-fs';\nimport type {Config} from '@jest/types';\nimport {escapePathForRegex} from 'jest-regex-util';\nimport {invariant, requireOrImportModule} from 'jest-util';\nimport {type JestWorkerFarm, Worker} from 'jest-worker';\nimport HasteFS from './HasteFS';\nimport HasteModuleMap from './ModuleMap';\nimport H from './constants';\nimport {nodeCrawl} from './crawlers/node';\nimport {watchmanCrawl} from './crawlers/watchman';\nimport getMockName from './getMockName';\nimport * as fastPath from './lib/fast_path';\nimport getPlatformExtension from './lib/getPlatformExtension';\nimport isWatchmanInstalled from './lib/isWatchmanInstalled';\nimport normalizePathSep from './lib/normalizePathSep';\nimport type {\n  ChangeEvent,\n  CrawlerOptions,\n  DependencyExtractor,\n  EventsQueue,\n  FileData,\n  FileMetaData,\n  HasteMapStatic,\n  HasteRegExp,\n  IHasteMap,\n  IModuleMap,\n  InternalHasteMap,\n  HasteMap as InternalHasteMapObject,\n  MockData,\n  ModuleMapData,\n  ModuleMapItem,\n  ModuleMetaData,\n  SerializableModuleMap,\n  WorkerMetadata,\n} from './types';\nimport {FSEventsWatcher} from './watchers/FSEventsWatcher';\n// @ts-expect-error: not converted to TypeScript - it's a fork: https://github.com/jestjs/jest/pull/10919\nimport NodeWatcher from './watchers/NodeWatcher';\n// @ts-expect-error: not converted to TypeScript - it's a fork: https://github.com/jestjs/jest/pull/5387\nimport WatchmanWatcher from './watchers/WatchmanWatcher';\nimport {getSha1, worker} from './worker';\n// TypeScript doesn't like us importing from outside `rootDir`, but it doesn't\n// understand `require`.\nconst {version: VERSION} = require('../package.json');\n\ntype Options = {\n  cacheDirectory?: string;\n  computeDependencies?: boolean;\n  computeSha1?: boolean;\n  console?: Console;\n  dependencyExtractor?: string | null;\n  enableSymlinks?: boolean;\n  extensions: Array<string>;\n  forceNodeFilesystemAPI?: boolean;\n  hasteImplModulePath?: string;\n  hasteMapModulePath?: string;\n  id: string;\n  ignorePattern?: HasteRegExp;\n  maxWorkers: number;\n  mocksPattern?: string;\n  platforms: Array<string>;\n  resetCache?: boolean;\n  retainAllFiles: boolean;\n  rootDir: string;\n  roots: Array<string>;\n  skipPackageJson?: boolean;\n  throwOnModuleCollision?: boolean;\n  useWatchman?: boolean;\n  watch?: boolean;\n  workerThreads?: boolean;\n};\n\ntype InternalOptions = {\n  cacheDirectory: string;\n  computeDependencies: boolean;\n  computeSha1: boolean;\n  dependencyExtractor: string | null;\n  enableSymlinks: boolean;\n  extensions: Array<string>;\n  forceNodeFilesystemAPI: boolean;\n  hasteImplModulePath?: string;\n  id: string;\n  ignorePattern?: HasteRegExp;\n  maxWorkers: number;\n  mocksPattern: RegExp | null;\n  platforms: Array<string>;\n  resetCache?: boolean;\n  retainAllFiles: boolean;\n  rootDir: string;\n  roots: Array<string>;\n  skipPackageJson: boolean;\n  throwOnModuleCollision: boolean;\n  useWatchman: boolean;\n  watch: boolean;\n  workerThreads?: boolean;\n};\n\ntype Watcher = {\n  close(): Promise<void>;\n};\n\ntype HasteWorker = typeof import('./worker');\n\nlet isWatchmanInstalledPromise: Promise<boolean> | undefined;\n\nexport const ModuleMap = HasteModuleMap as {\n  create: (rootPath: string) => IModuleMap;\n};\nexport type {\n  IHasteFS,\n  IHasteMap,\n  IModuleMap,\n  SerializableModuleMap,\n} from './types';\n\nconst CHANGE_INTERVAL = 30;\nconst MAX_WAIT_TIME = 240_000;\nconst NODE_MODULES = `${path.sep}node_modules${path.sep}`;\nconst PACKAGE_JSON = `${path.sep}package.json`;\nconst VCS_DIRECTORIES = ['.git', '.hg', '.sl']\n  .map(vcs => escapePathForRegex(path.sep + vcs + path.sep))\n  .join('|');\n\ntype WorkerOptions = {forceInBand: boolean};\n\n/**\n * HasteMap is a JavaScript implementation of Facebook's haste module system.\n *\n * This implementation is inspired by https://github.com/facebook/node-haste\n * and was built with for high-performance in large code repositories with\n * hundreds of thousands of files. This implementation is scalable and provides\n * predictable performance.\n *\n * Because the haste map creation and synchronization is critical to startup\n * performance and most tasks are blocked by I/O this class makes heavy use of\n * synchronous operations. It uses worker processes for parallelizing file\n * access and metadata extraction.\n *\n * The data structures created by `jest-haste-map` can be used directly from the\n * cache without further processing. The metadata objects in the `files` and\n * `map` objects contain cross-references: a metadata object from one can look\n * up the corresponding metadata object in the other map. Note that in most\n * projects, the number of files will be greater than the number of haste\n * modules one module can refer to many files based on platform extensions.\n *\n * type HasteMap = {\n *   clocks: WatchmanClocks,\n *   files: {[filepath: string]: FileMetaData},\n *   map: {[id: string]: ModuleMapItem},\n *   mocks: {[id: string]: string},\n * }\n *\n * // Watchman clocks are used for query synchronization and file system deltas.\n * type WatchmanClocks = {[filepath: string]: string};\n *\n * type FileMetaData = {\n *   id: ?string, // used to look up module metadata objects in `map`.\n *   mtime: number, // check for outdated files.\n *   size: number, // size of the file in bytes.\n *   visited: boolean, // whether the file has been parsed or not.\n *   dependencies: Array<string>, // all relative dependencies of this file.\n *   sha1: ?string, // SHA-1 of the file, if requested via options.\n * };\n *\n * // Modules can be targeted to a specific platform based on the file name.\n * // Example: platform.ios.js and Platform.android.js will both map to the same\n * // `Platform` module. The platform should be specified during resolution.\n * type ModuleMapItem = {[platform: string]: ModuleMetaData};\n *\n * //\n * type ModuleMetaData = {\n *   path: string, // the path to look up the file object in `files`.\n *   type: string, // the module type (either `package` or `module`).\n * };\n *\n * Note that the data structures described above are conceptual only. The actual\n * implementation uses arrays and constant keys for metadata storage. Instead of\n * `{id: 'flatMap', mtime: 3421, size: 42, visited: true, dependencies: []}` the real\n * representation is similar to `['flatMap', 3421, 42, 1, []]` to save storage space\n * and reduce parse and write time of a big JSON blob.\n *\n * The HasteMap is created as follows:\n *  1. read data from the cache or create an empty structure.\n *\n *  2. crawl the file system.\n *     * empty cache: crawl the entire file system.\n *     * cache available:\n *       * if watchman is available: get file system delta changes.\n *       * if watchman is unavailable: crawl the entire file system.\n *     * build metadata objects for every file. This builds the `files` part of\n *       the `HasteMap`.\n *\n *  3. parse and extract metadata from changed files.\n *     * this is done in parallel over worker processes to improve performance.\n *     * the worst case is to parse all files.\n *     * the best case is no file system access and retrieving all data from\n *       the cache.\n *     * the average case is a small number of changed files.\n *\n *  4. serialize the new `HasteMap` in a cache file.\n *     Worker processes can directly access the cache through `HasteMap.read()`.\n *\n */\nclass HasteMap extends EventEmitter implements IHasteMap {\n  private _buildPromise: Promise<InternalHasteMapObject> | null = null;\n  private _cachePath = '';\n  private _changeInterval?: ReturnType<typeof setInterval>;\n  private readonly _console: Console;\n  private readonly _options: InternalOptions;\n  private _watchers: Array<Watcher> = [];\n  private _worker: JestWorkerFarm<HasteWorker> | HasteWorker | null = null;\n\n  static getStatic(config: Config.ProjectConfig): HasteMapStatic {\n    if (config.haste.hasteMapModulePath) {\n      return require(config.haste.hasteMapModulePath);\n    }\n    return HasteMap;\n  }\n\n  static async create(options: Options): Promise<IHasteMap> {\n    if (options.hasteMapModulePath) {\n      const CustomHasteMap = require(options.hasteMapModulePath);\n      return new CustomHasteMap(options);\n    }\n    const hasteMap = new HasteMap(options);\n\n    await hasteMap.setupCachePath(options);\n\n    return hasteMap;\n  }\n\n  private constructor(options: Options) {\n    super();\n    this._options = {\n      cacheDirectory: options.cacheDirectory || tmpdir(),\n      computeDependencies: options.computeDependencies ?? true,\n      computeSha1: options.computeSha1 || false,\n      dependencyExtractor: options.dependencyExtractor || null,\n      enableSymlinks: options.enableSymlinks || false,\n      extensions: options.extensions,\n      forceNodeFilesystemAPI: !!options.forceNodeFilesystemAPI,\n      hasteImplModulePath: options.hasteImplModulePath,\n      id: options.id,\n      maxWorkers: options.maxWorkers,\n      mocksPattern: options.mocksPattern\n        ? new RegExp(options.mocksPattern)\n        : null,\n      platforms: options.platforms,\n      resetCache: options.resetCache,\n      retainAllFiles: options.retainAllFiles,\n      rootDir: options.rootDir,\n      roots: [...new Set(options.roots)],\n      skipPackageJson: !!options.skipPackageJson,\n      throwOnModuleCollision: !!options.throwOnModuleCollision,\n      useWatchman: options.useWatchman ?? true,\n      watch: !!options.watch,\n      workerThreads: options.workerThreads,\n    };\n    this._console = options.console || globalThis.console;\n\n    if (options.ignorePattern) {\n      if (options.ignorePattern instanceof RegExp) {\n        this._options.ignorePattern = new RegExp(\n          `${options.ignorePattern.source}|${VCS_DIRECTORIES}`,\n          options.ignorePattern.flags,\n        );\n      } else {\n        throw new TypeError(\n          'jest-haste-map: the `ignorePattern` option must be a RegExp',\n        );\n      }\n    } else {\n      this._options.ignorePattern = new RegExp(VCS_DIRECTORIES);\n    }\n\n    if (this._options.enableSymlinks && this._options.useWatchman) {\n      throw new Error(\n        'jest-haste-map: enableSymlinks config option was set, but ' +\n          'is incompatible with watchman.\\n' +\n          'Set either `enableSymlinks` to false or `useWatchman` to false.',\n      );\n    }\n  }\n\n  private async setupCachePath(options: Options): Promise<void> {\n    const rootDirHash = createHash('sha1')\n      .update(options.rootDir)\n      .digest('hex')\n      .slice(0, 32);\n    let hasteImplHash = '';\n    let dependencyExtractorHash = '';\n\n    if (options.hasteImplModulePath) {\n      const hasteImpl = require(options.hasteImplModulePath);\n      if (hasteImpl.getCacheKey) {\n        hasteImplHash = String(hasteImpl.getCacheKey());\n      }\n    }\n\n    if (options.dependencyExtractor) {\n      const dependencyExtractor =\n        await requireOrImportModule<DependencyExtractor>(\n          options.dependencyExtractor,\n          false,\n        );\n      if (dependencyExtractor.getCacheKey) {\n        dependencyExtractorHash = String(dependencyExtractor.getCacheKey());\n      }\n    }\n\n    this._cachePath = HasteMap.getCacheFilePath(\n      this._options.cacheDirectory,\n      `haste-map-${this._options.id}-${rootDirHash}`,\n      VERSION,\n      this._options.id,\n      this._options.roots\n        .map(root => fastPath.relative(options.rootDir, root))\n        .join(':'),\n      this._options.extensions.join(':'),\n      this._options.platforms.join(':'),\n      this._options.computeSha1.toString(),\n      options.mocksPattern || '',\n      (options.ignorePattern || '').toString(),\n      hasteImplHash,\n      dependencyExtractorHash,\n      this._options.computeDependencies.toString(),\n    );\n  }\n\n  static getCacheFilePath(\n    tmpdir: string,\n    id: string,\n    ...extra: Array<string>\n  ): string {\n    const hash = createHash('sha1').update(extra.join(''));\n    return path.join(\n      tmpdir,\n      `${id.replaceAll(/\\W/g, '-')}-${hash.digest('hex').slice(0, 32)}`,\n    );\n  }\n\n  static getModuleMapFromJSON(json: SerializableModuleMap): HasteModuleMap {\n    return HasteModuleMap.fromJSON(json);\n  }\n\n  getCacheFilePath(): string {\n    return this._cachePath;\n  }\n\n  build(): Promise<InternalHasteMapObject> {\n    if (!this._buildPromise) {\n      this._buildPromise = (async () => {\n        const data = await this._buildFileMap();\n\n        // Persist when we don't know if files changed (changedFiles undefined)\n        // or when we know a file was changed or deleted.\n        let hasteMap: InternalHasteMap;\n        if (\n          data.changedFiles === undefined ||\n          data.changedFiles.size > 0 ||\n          data.removedFiles.size > 0\n        ) {\n          hasteMap = await this._buildHasteMap(data);\n          this._persist(hasteMap);\n        } else {\n          hasteMap = data.hasteMap;\n        }\n\n        const rootDir = this._options.rootDir;\n        const hasteFS = new HasteFS({\n          files: hasteMap.files,\n          rootDir,\n        });\n        const moduleMap = new HasteModuleMap({\n          duplicates: hasteMap.duplicates,\n          map: hasteMap.map,\n          mocks: hasteMap.mocks,\n          rootDir,\n        });\n        const __hasteMapForTest =\n          (process.env.NODE_ENV === 'test' && hasteMap) || null;\n        await this._watch(hasteMap);\n        return {\n          __hasteMapForTest,\n          hasteFS,\n          moduleMap,\n        };\n      })();\n    }\n    return this._buildPromise;\n  }\n\n  /**\n   * 1. read data from the cache or create an empty structure.\n   */\n  read(): InternalHasteMap {\n    let hasteMap: InternalHasteMap;\n\n    try {\n      hasteMap = deserialize(readFileSync(this._cachePath));\n    } catch {\n      hasteMap = this._createEmptyMap();\n    }\n\n    return hasteMap;\n  }\n\n  readModuleMap(): HasteModuleMap {\n    const data = this.read();\n    return new HasteModuleMap({\n      duplicates: data.duplicates,\n      map: data.map,\n      mocks: data.mocks,\n      rootDir: this._options.rootDir,\n    });\n  }\n\n  /**\n   * 2. crawl the file system.\n   */\n  private async _buildFileMap(): Promise<{\n    removedFiles: FileData;\n    changedFiles?: FileData;\n    hasteMap: InternalHasteMap;\n  }> {\n    let hasteMap: InternalHasteMap;\n    try {\n      const read = this._options.resetCache ? this._createEmptyMap : this.read;\n      hasteMap = read.call(this);\n    } catch {\n      hasteMap = this._createEmptyMap();\n    }\n    return this._crawl(hasteMap);\n  }\n\n  /**\n   * 3. parse and extract metadata from changed files.\n   */\n  private _processFile(\n    hasteMap: InternalHasteMap,\n    map: ModuleMapData,\n    mocks: MockData,\n    filePath: string,\n    workerOptions?: WorkerOptions,\n  ): Promise<void> | null {\n    const rootDir = this._options.rootDir;\n\n    const setModule = (id: string, module: ModuleMetaData) => {\n      let moduleMap = map.get(id);\n      if (!moduleMap) {\n        moduleMap = Object.create(null) as ModuleMapItem;\n        map.set(id, moduleMap);\n      }\n      const platform =\n        getPlatformExtension(module[H.PATH], this._options.platforms) ||\n        H.GENERIC_PLATFORM;\n\n      const existingModule = moduleMap[platform];\n\n      if (existingModule && existingModule[H.PATH] !== module[H.PATH]) {\n        const method = this._options.throwOnModuleCollision ? 'error' : 'warn';\n\n        this._console[method](\n          [\n            `jest-haste-map: Haste module naming collision: ${id}`,\n            '  The following files share their name; please adjust your hasteImpl:',\n            `    * <rootDir>${path.sep}${existingModule[H.PATH]}`,\n            `    * <rootDir>${path.sep}${module[H.PATH]}`,\n            '',\n          ].join('\\n'),\n        );\n\n        if (this._options.throwOnModuleCollision) {\n          throw new DuplicateError(existingModule[H.PATH], module[H.PATH]);\n        }\n\n        // We do NOT want consumers to use a module that is ambiguous.\n        delete moduleMap[platform];\n\n        if (Object.keys(moduleMap).length === 1) {\n          map.delete(id);\n        }\n\n        let dupsByPlatform = hasteMap.duplicates.get(id);\n        if (dupsByPlatform == null) {\n          dupsByPlatform = new Map();\n          hasteMap.duplicates.set(id, dupsByPlatform);\n        }\n\n        const dups = new Map([\n          [module[H.PATH], module[H.TYPE]],\n          [existingModule[H.PATH], existingModule[H.TYPE]],\n        ]);\n        dupsByPlatform.set(platform, dups);\n\n        return;\n      }\n\n      const dupsByPlatform = hasteMap.duplicates.get(id);\n      if (dupsByPlatform != null) {\n        const dups = dupsByPlatform.get(platform);\n        if (dups != null) {\n          dups.set(module[H.PATH], module[H.TYPE]);\n        }\n        return;\n      }\n\n      moduleMap[platform] = module;\n    };\n\n    const relativeFilePath = fastPath.relative(rootDir, filePath);\n    const fileMetadata = hasteMap.files.get(relativeFilePath);\n    if (!fileMetadata) {\n      throw new Error(\n        'jest-haste-map: File to process was not found in the haste map.',\n      );\n    }\n\n    const moduleMetadata = hasteMap.map.get(fileMetadata[H.ID]);\n    const computeSha1 = this._options.computeSha1 && !fileMetadata[H.SHA1];\n\n    // Callback called when the response from the worker is successful.\n    const workerReply = (metadata: WorkerMetadata) => {\n      // `1` for truthy values instead of `true` to save cache space.\n      fileMetadata[H.VISITED] = 1;\n\n      const metadataId = metadata.id;\n      const metadataModule = metadata.module;\n\n      if (metadataId && metadataModule) {\n        fileMetadata[H.ID] = metadataId;\n        setModule(metadataId, metadataModule);\n      }\n\n      fileMetadata[H.DEPENDENCIES] = metadata.dependencies\n        ? metadata.dependencies.join(H.DEPENDENCY_DELIM)\n        : '';\n\n      if (computeSha1) {\n        fileMetadata[H.SHA1] = metadata.sha1;\n      }\n    };\n\n    // Callback called when the response from the worker is an error.\n    const workerError = (error: Error | any) => {\n      if (typeof error !== 'object' || !error.message || !error.stack) {\n        error = new Error(error);\n        error.stack = ''; // Remove stack for stack-less errors.\n      }\n\n      if (!['ENOENT', 'EACCES'].includes(error.code)) {\n        throw error;\n      }\n\n      // If a file cannot be read we remove it from the file list and\n      // ignore the failure silently.\n      hasteMap.files.delete(relativeFilePath);\n    };\n\n    // If we retain all files in the virtual HasteFS representation, we avoid\n    // reading them if they aren't important (node_modules).\n    if (this._options.retainAllFiles && filePath.includes(NODE_MODULES)) {\n      if (computeSha1) {\n        return this._getWorker(workerOptions)\n          .getSha1({\n            computeDependencies: this._options.computeDependencies,\n            computeSha1,\n            dependencyExtractor: this._options.dependencyExtractor,\n            filePath,\n            hasteImplModulePath: this._options.hasteImplModulePath,\n            rootDir,\n          })\n          .then(workerReply, workerError);\n      }\n\n      return null;\n    }\n\n    if (\n      this._options.mocksPattern &&\n      this._options.mocksPattern.test(filePath)\n    ) {\n      const mockPath = getMockName(filePath);\n      const existingMockPath = mocks.get(mockPath);\n\n      if (existingMockPath) {\n        const secondMockPath = fastPath.relative(rootDir, filePath);\n        if (existingMockPath !== secondMockPath) {\n          const method = this._options.throwOnModuleCollision\n            ? 'error'\n            : 'warn';\n\n          this._console[method](\n            [\n              `jest-haste-map: duplicate manual mock found: ${mockPath}`,\n              '  The following files share their name; please delete one of them:',\n              `    * <rootDir>${path.sep}${existingMockPath}`,\n              `    * <rootDir>${path.sep}${secondMockPath}`,\n              '',\n            ].join('\\n'),\n          );\n\n          if (this._options.throwOnModuleCollision) {\n            throw new DuplicateError(existingMockPath, secondMockPath);\n          }\n        }\n      }\n\n      mocks.set(mockPath, relativeFilePath);\n    }\n\n    if (fileMetadata[H.VISITED]) {\n      if (!fileMetadata[H.ID]) {\n        return null;\n      }\n\n      if (moduleMetadata != null) {\n        const platform =\n          getPlatformExtension(filePath, this._options.platforms) ||\n          H.GENERIC_PLATFORM;\n\n        const module = moduleMetadata[platform];\n\n        if (module == null) {\n          return null;\n        }\n\n        const moduleId = fileMetadata[H.ID];\n        let modulesByPlatform = map.get(moduleId);\n        if (!modulesByPlatform) {\n          modulesByPlatform = Object.create(null) as ModuleMapItem;\n          map.set(moduleId, modulesByPlatform);\n        }\n        modulesByPlatform[platform] = module;\n\n        return null;\n      }\n    }\n\n    return this._getWorker(workerOptions)\n      .worker({\n        computeDependencies: this._options.computeDependencies,\n        computeSha1,\n        dependencyExtractor: this._options.dependencyExtractor,\n        filePath,\n        hasteImplModulePath: this._options.hasteImplModulePath,\n        rootDir,\n      })\n      .then(workerReply, workerError);\n  }\n\n  private _buildHasteMap(data: {\n    removedFiles: FileData;\n    changedFiles?: FileData;\n    hasteMap: InternalHasteMap;\n  }): Promise<InternalHasteMap> {\n    const {removedFiles, changedFiles, hasteMap} = data;\n\n    // If any files were removed or we did not track what files changed, process\n    // every file looking for changes. Otherwise, process only changed files.\n    let map: ModuleMapData;\n    let mocks: MockData;\n    let filesToProcess: FileData;\n    if (changedFiles === undefined || removedFiles.size > 0) {\n      map = new Map();\n      mocks = new Map();\n      filesToProcess = hasteMap.files;\n    } else {\n      map = hasteMap.map;\n      mocks = hasteMap.mocks;\n      filesToProcess = changedFiles;\n    }\n\n    for (const [relativeFilePath, fileMetadata] of removedFiles) {\n      this._recoverDuplicates(hasteMap, relativeFilePath, fileMetadata[H.ID]);\n    }\n\n    const promises: Array<Promise<void>> = [];\n    for (const relativeFilePath of filesToProcess.keys()) {\n      if (\n        this._options.skipPackageJson &&\n        relativeFilePath.endsWith(PACKAGE_JSON)\n      ) {\n        continue;\n      }\n      // SHA-1, if requested, should already be present thanks to the crawler.\n      const filePath = fastPath.resolve(\n        this._options.rootDir,\n        relativeFilePath,\n      );\n      const promise = this._processFile(hasteMap, map, mocks, filePath);\n      if (promise) {\n        promises.push(promise);\n      }\n    }\n\n    return Promise.all(promises).then(\n      () => {\n        this._cleanup();\n        hasteMap.map = map;\n        hasteMap.mocks = mocks;\n        return hasteMap;\n      },\n      error => {\n        this._cleanup();\n        throw error;\n      },\n    );\n  }\n\n  private _cleanup() {\n    const worker = this._worker;\n\n    if (worker && 'end' in worker) {\n      worker.end();\n    }\n\n    this._worker = null;\n  }\n\n  /**\n   * 4. serialize the new `HasteMap` in a cache file.\n   */\n  private _persist(hasteMap: InternalHasteMap) {\n    writeFileSync(this._cachePath, serialize(hasteMap));\n  }\n\n  /**\n   * Creates workers or parses files and extracts metadata in-process.\n   */\n  private _getWorker(\n    options: WorkerOptions | undefined,\n  ): JestWorkerFarm<HasteWorker> | HasteWorker {\n    if (!this._worker) {\n      if (options?.forceInBand || this._options.maxWorkers <= 1) {\n        this._worker = {getSha1, worker};\n      } else {\n        this._worker = new Worker(require.resolve('./worker'), {\n          enableWorkerThreads: this._options.workerThreads,\n          exposedMethods: ['getSha1', 'worker'],\n          forkOptions: {serialization: 'json'},\n          maxRetries: 3,\n          numWorkers: this._options.maxWorkers,\n        }) as JestWorkerFarm<HasteWorker>;\n      }\n    }\n\n    return this._worker;\n  }\n\n  private async _crawl(hasteMap: InternalHasteMap) {\n    const options = this._options;\n    const ignore = this._ignore.bind(this);\n    const crawl = (await this._shouldUseWatchman()) ? watchmanCrawl : nodeCrawl;\n    const crawlerOptions: CrawlerOptions = {\n      computeSha1: options.computeSha1,\n      data: hasteMap,\n      enableSymlinks: options.enableSymlinks,\n      extensions: options.extensions,\n      forceNodeFilesystemAPI: options.forceNodeFilesystemAPI,\n      ignore,\n      rootDir: options.rootDir,\n      roots: options.roots,\n    };\n\n    const retry = (retryError: Error) => {\n      if (crawl === watchmanCrawl) {\n        this._console.warn(\n          'jest-haste-map: Watchman crawl failed. Retrying once with node ' +\n            'crawler.\\n' +\n            \"  Usually this happens when watchman isn't running. Create an \" +\n            \"empty `.watchmanconfig` file in your project's root folder or \" +\n            'initialize a git or hg repository in your project.\\n' +\n            `  ${retryError}`,\n        );\n        return nodeCrawl(crawlerOptions).catch(error => {\n          throw new Error(\n            'Crawler retry failed:\\n' +\n              `  Original error: ${retryError.message}\\n` +\n              `  Retry error: ${error.message}\\n`,\n          );\n        });\n      }\n\n      throw retryError;\n    };\n\n    try {\n      return await crawl(crawlerOptions);\n    } catch (error: any) {\n      return retry(error);\n    }\n  }\n\n  /**\n   * Watch mode\n   */\n  private async _watch(hasteMap: InternalHasteMap): Promise<void> {\n    if (!this._options.watch) {\n      return;\n    }\n\n    // In watch mode, we'll only warn about module collisions and we'll retain\n    // all files, even changes to node_modules.\n    this._options.throwOnModuleCollision = false;\n    this._options.retainAllFiles = true;\n\n    // WatchmanWatcher > FSEventsWatcher > sane.NodeWatcher\n    const Watcher = (await this._shouldUseWatchman())\n      ? WatchmanWatcher\n      : FSEventsWatcher.isSupported()\n        ? FSEventsWatcher\n        : NodeWatcher;\n\n    const extensions = this._options.extensions;\n    const ignorePattern = this._options.ignorePattern;\n    const rootDir = this._options.rootDir;\n\n    let changeQueue: Promise<null | void> = Promise.resolve();\n    let eventsQueue: EventsQueue = [];\n    // We only need to copy the entire haste map once on every \"frame\".\n    let mustCopy = true;\n\n    const createWatcher = (root: string): Promise<Watcher> => {\n      const watcher = new Watcher(root, {\n        dot: true,\n        glob: extensions.map(extension => `**/*.${extension}`),\n        ignored: ignorePattern,\n      });\n\n      return new Promise((resolve, reject) => {\n        const rejectTimeout = setTimeout(\n          () => reject(new Error('Failed to start watch mode.')),\n          MAX_WAIT_TIME,\n        );\n\n        watcher.once('ready', () => {\n          clearTimeout(rejectTimeout);\n          watcher.on('all', onChange);\n          resolve(watcher);\n        });\n      });\n    };\n\n    const emitChange = () => {\n      if (eventsQueue.length > 0) {\n        mustCopy = true;\n        const changeEvent: ChangeEvent = {\n          eventsQueue,\n          hasteFS: new HasteFS({files: hasteMap.files, rootDir}),\n          moduleMap: new HasteModuleMap({\n            duplicates: hasteMap.duplicates,\n            map: hasteMap.map,\n            mocks: hasteMap.mocks,\n            rootDir,\n          }),\n        };\n        this.emit('change', changeEvent);\n        eventsQueue = [];\n      }\n    };\n\n    const onChange = (\n      type: string,\n      filePath: string,\n      root: string,\n      stat?: Stats,\n    ) => {\n      filePath = path.join(root, normalizePathSep(filePath));\n      if (\n        (stat && stat.isDirectory()) ||\n        this._ignore(filePath) ||\n        !extensions.some(extension => filePath.endsWith(extension))\n      ) {\n        return;\n      }\n\n      const relativeFilePath = fastPath.relative(rootDir, filePath);\n      const fileMetadata = hasteMap.files.get(relativeFilePath);\n\n      // The file has been accessed, not modified\n      if (\n        type === 'change' &&\n        fileMetadata &&\n        stat &&\n        fileMetadata[H.MTIME] === stat.mtime.getTime()\n      ) {\n        return;\n      }\n\n      changeQueue = changeQueue\n        .then(() => {\n          // If we get duplicate events for the same file, ignore them.\n          if (\n            eventsQueue.some(\n              event =>\n                event.type === type &&\n                event.filePath === filePath &&\n                ((!event.stat && !stat) ||\n                  (!!event.stat &&\n                    !!stat &&\n                    event.stat.mtime.getTime() === stat.mtime.getTime())),\n            )\n          ) {\n            return null;\n          }\n\n          if (mustCopy) {\n            mustCopy = false;\n            hasteMap = {\n              clocks: new Map(hasteMap.clocks),\n              duplicates: new Map(hasteMap.duplicates),\n              files: new Map(hasteMap.files),\n              map: new Map(hasteMap.map),\n              mocks: new Map(hasteMap.mocks),\n            };\n          }\n\n          const add = () => {\n            eventsQueue.push({filePath, stat, type});\n            return null;\n          };\n\n          const fileMetadata = hasteMap.files.get(relativeFilePath);\n\n          // If it's not an addition, delete the file and all its metadata\n          if (fileMetadata != null) {\n            const moduleName = fileMetadata[H.ID];\n            const platform =\n              getPlatformExtension(filePath, this._options.platforms) ||\n              H.GENERIC_PLATFORM;\n            hasteMap.files.delete(relativeFilePath);\n\n            let moduleMap = hasteMap.map.get(moduleName);\n            if (moduleMap != null) {\n              // We are forced to copy the object because jest-haste-map exposes\n              // the map as an immutable entity.\n              moduleMap = copy(moduleMap);\n              delete moduleMap[platform];\n              if (Object.keys(moduleMap).length === 0) {\n                hasteMap.map.delete(moduleName);\n              } else {\n                hasteMap.map.set(moduleName, moduleMap);\n              }\n            }\n\n            if (\n              this._options.mocksPattern &&\n              this._options.mocksPattern.test(filePath)\n            ) {\n              const mockName = getMockName(filePath);\n              hasteMap.mocks.delete(mockName);\n            }\n\n            this._recoverDuplicates(hasteMap, relativeFilePath, moduleName);\n          }\n\n          // If the file was added or changed,\n          // parse it and update the haste map.\n          if (type === 'add' || type === 'change') {\n            invariant(\n              stat,\n              'since the file exists or changed, it should have stats',\n            );\n            const fileMetadata: FileMetaData = [\n              '',\n              stat.mtime.getTime(),\n              stat.size,\n              0,\n              '',\n              null,\n            ];\n            hasteMap.files.set(relativeFilePath, fileMetadata);\n            const promise = this._processFile(\n              hasteMap,\n              hasteMap.map,\n              hasteMap.mocks,\n              filePath,\n              {forceInBand: true},\n            );\n            // Cleanup\n            this._cleanup();\n            if (promise) {\n              return promise.then(add);\n            } else {\n              // If a file in node_modules has changed,\n              // emit an event regardless.\n              add();\n            }\n          } else {\n            add();\n          }\n          return null;\n        })\n        .catch((error: Error) => {\n          this._console.error(\n            `jest-haste-map: watch error:\\n  ${error.stack}\\n`,\n          );\n        });\n    };\n\n    this._changeInterval = setInterval(emitChange, CHANGE_INTERVAL);\n    return Promise.all(this._options.roots.map(createWatcher)).then(\n      watchers => {\n        this._watchers = watchers;\n      },\n    );\n  }\n\n  /**\n   * This function should be called when the file under `filePath` is removed\n   * or changed. When that happens, we want to figure out if that file was\n   * part of a group of files that had the same ID. If it was, we want to\n   * remove it from the group. Furthermore, if there is only one file\n   * remaining in the group, then we want to restore that single file as the\n   * correct resolution for its ID, and cleanup the duplicates index.\n   */\n  private _recoverDuplicates(\n    hasteMap: InternalHasteMap,\n    relativeFilePath: string,\n    moduleName: string,\n  ) {\n    let dupsByPlatform = hasteMap.duplicates.get(moduleName);\n    if (dupsByPlatform == null) {\n      return;\n    }\n\n    const platform =\n      getPlatformExtension(relativeFilePath, this._options.platforms) ||\n      H.GENERIC_PLATFORM;\n    let dups = dupsByPlatform.get(platform);\n    if (dups == null) {\n      return;\n    }\n\n    dupsByPlatform = copyMap(dupsByPlatform);\n    hasteMap.duplicates.set(moduleName, dupsByPlatform);\n\n    dups = copyMap(dups);\n    dupsByPlatform.set(platform, dups);\n    dups.delete(relativeFilePath);\n\n    if (dups.size !== 1) {\n      return;\n    }\n\n    const uniqueModule = dups.entries().next().value;\n\n    if (!uniqueModule) {\n      return;\n    }\n\n    let dedupMap = hasteMap.map.get(moduleName);\n\n    if (!dedupMap) {\n      dedupMap = Object.create(null) as ModuleMapItem;\n      hasteMap.map.set(moduleName, dedupMap);\n    }\n    dedupMap[platform] = uniqueModule;\n    dupsByPlatform.delete(platform);\n    if (dupsByPlatform.size === 0) {\n      hasteMap.duplicates.delete(moduleName);\n    }\n  }\n\n  async end(): Promise<void> {\n    if (this._changeInterval) {\n      clearInterval(this._changeInterval);\n    }\n\n    if (this._watchers.length === 0) {\n      return;\n    }\n\n    await Promise.all(this._watchers.map(watcher => watcher.close()));\n\n    this._watchers = [];\n  }\n\n  /**\n   * Helpers\n   */\n  private _ignore(filePath: string): boolean {\n    const ignorePattern = this._options.ignorePattern;\n    const ignoreMatched =\n      ignorePattern instanceof RegExp\n        ? ignorePattern.test(filePath)\n        : ignorePattern && ignorePattern(filePath);\n\n    return (\n      ignoreMatched ||\n      (!this._options.retainAllFiles && filePath.includes(NODE_MODULES))\n    );\n  }\n\n  private async _shouldUseWatchman(): Promise<boolean> {\n    if (!this._options.useWatchman) {\n      return false;\n    }\n    if (!isWatchmanInstalledPromise) {\n      isWatchmanInstalledPromise = isWatchmanInstalled();\n    }\n    return isWatchmanInstalledPromise;\n  }\n\n  private _createEmptyMap(): InternalHasteMap {\n    return {\n      clocks: new Map(),\n      duplicates: new Map(),\n      files: new Map(),\n      map: new Map(),\n      mocks: new Map(),\n    };\n  }\n\n  static H = H;\n}\n\nexport class DuplicateError extends Error {\n  mockPath1: string;\n  mockPath2: string;\n\n  constructor(mockPath1: string, mockPath2: string) {\n    super('Duplicated files or mocks. Please check the console for more info');\n\n    this.mockPath1 = mockPath1;\n    this.mockPath2 = mockPath2;\n  }\n}\n\nfunction copy<T extends Record<string, unknown>>(object: T): T {\n  return Object.assign(Object.create(null), object);\n}\n\nfunction copyMap<K, V>(input: Map<K, V>): Map<K, V> {\n  return new Map(input);\n}\n\n// Export the smallest API surface required by Jest\ntype IJestHasteMap = HasteMapStatic & {\n  create(options: Options): Promise<IHasteMap>;\n  getStatic(config: Config.ProjectConfig): HasteMapStatic;\n};\nconst JestHasteMap: IJestHasteMap = HasteMap;\nexport default JestHasteMap;\n",
  "packages/jest-haste-map/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config } from '@jest/types';\nimport type { HasteMapStatic, HasteRegExp, IHasteMap, IModuleMap } from './types';\ntype Options = {\n    cacheDirectory?: string;\n    computeDependencies?: boolean;\n    computeSha1?: boolean;\n    console?: Console;\n    dependencyExtractor?: string | null;\n    enableSymlinks?: boolean;\n    extensions: Array<string>;\n    forceNodeFilesystemAPI?: boolean;\n    hasteImplModulePath?: string;\n    hasteMapModulePath?: string;\n    id: string;\n    ignorePattern?: HasteRegExp;\n    maxWorkers: number;\n    mocksPattern?: string;\n    platforms: Array<string>;\n    resetCache?: boolean;\n    retainAllFiles: boolean;\n    rootDir: string;\n    roots: Array<string>;\n    skipPackageJson?: boolean;\n    throwOnModuleCollision?: boolean;\n    useWatchman?: boolean;\n    watch?: boolean;\n    workerThreads?: boolean;\n};\nexport declare const ModuleMap: {\n    create: (rootPath: string) => IModuleMap;\n};\nexport type { IHasteFS, IHasteMap, IModuleMap, SerializableModuleMap, } from './types';\nexport declare class DuplicateError extends Error {\n    mockPath1: string;\n    mockPath2: string;\n    constructor(mockPath1: string, mockPath2: string);\n}\ntype IJestHasteMap = HasteMapStatic & {\n    create(options: Options): Promise<IHasteMap>;\n    getStatic(config: Config.ProjectConfig): HasteMapStatic;\n};\ndeclare const JestHasteMap: IJestHasteMap;\nexport default JestHasteMap;\n",
  "packages/jest-haste-map/src/getMockName.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\n\nconst MOCKS_PATTERN = `${path.sep}__mocks__${path.sep}`;\n\nconst getMockName = (filePath: string): string => {\n  const mockPath = filePath.split(MOCKS_PATTERN)[1];\n  return mockPath\n    .slice(0, mockPath.lastIndexOf(path.extname(mockPath)))\n    .replaceAll('\\\\', '/');\n};\n\nexport default getMockName;\n",
  "packages/jest-haste-map/src/getMockName.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\ndeclare const getMockName: (filePath: string) => string;\nexport default getMockName;\n",
  "packages/jest-haste-map/src/constants.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/*\n * This file exports a set of constants that are used for Jest's haste map\n * serialization. On very large repositories, the haste map cache becomes very\n * large to the point where it is the largest overhead in starting up Jest.\n *\n * This constant key map allows to keep the map smaller without having to build\n * a custom serialization library.\n */\n\nimport type {HType} from './types';\n\n/* eslint-disable sort-keys */\nconst constants: HType = {\n  /* dependency serialization */\n  DEPENDENCY_DELIM: '\\0',\n\n  /* file map attributes */\n  ID: 0,\n  MTIME: 1,\n  SIZE: 2,\n  VISITED: 3,\n  DEPENDENCIES: 4,\n  SHA1: 5,\n\n  /* module map attributes */\n  PATH: 0,\n  TYPE: 1,\n\n  /* module types */\n  MODULE: 0,\n  PACKAGE: 1,\n\n  /* platforms */\n  GENERIC_PLATFORM: 'g',\n  NATIVE_PLATFORM: 'native',\n};\n/* eslint-enable */\n\nexport default constants;\n",
  "packages/jest-haste-map/src/constants.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { HType } from './types';\ndeclare const constants: HType;\nexport default constants;\n",
  "packages/jest-haste-map/src/blacklist.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// This list is compiled after the MDN list of the most common MIME types (see\n// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/\n// Complete_list_of_MIME_types).\n//\n// Only MIME types starting with \"image/\", \"video/\", \"audio/\" and \"font/\" are\n// reflected in the list. Adding \"application/\" is too risky since some text\n// file formats (like \".js\" and \".json\") have an \"application/\" MIME type.\n//\n// Feel free to add any extensions that cannot be a Haste module.\n\nconst extensions = new Set<string>([\n  // JSONs are never haste modules, except for \"package.json\", which is handled.\n  '.json',\n\n  // Image extensions.\n  '.bmp',\n  '.gif',\n  '.ico',\n  '.jpeg',\n  '.jpg',\n  '.png',\n  '.svg',\n  '.tiff',\n  '.tif',\n  '.webp',\n\n  // Video extensions.\n  '.avi',\n  '.mp4',\n  '.mpeg',\n  '.mpg',\n  '.ogv',\n  '.webm',\n  '.3gp',\n  '.3g2',\n\n  // Audio extensions.\n  '.aac',\n  '.midi',\n  '.mid',\n  '.mp3',\n  '.oga',\n  '.wav',\n  '.3gp',\n  '.3g2',\n\n  // Font extensions.\n  '.eot',\n  '.otf',\n  '.ttf',\n  '.woff',\n  '.woff2',\n]);\n\nexport default extensions;\n",
  "packages/jest-haste-map/src/blacklist.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\ndeclare const extensions: Set<string>;\nexport default extensions;\n",
  "packages/jest-haste-map/src/ModuleMap.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport H from './constants';\nimport * as fastPath from './lib/fast_path';\nimport type {\n  DuplicatesSet,\n  HTypeValue,\n  IModuleMap,\n  ModuleMetaData,\n  RawModuleMap,\n  SerializableModuleMap,\n} from './types';\n\nconst EMPTY_OBJ: Record<string, ModuleMetaData> = {};\nconst EMPTY_MAP = new Map();\n\nexport default class ModuleMap implements IModuleMap {\n  static DuplicateHasteCandidatesError: typeof DuplicateHasteCandidatesError;\n  private readonly _raw: RawModuleMap;\n  private json: SerializableModuleMap | undefined;\n\n  private static mapToArrayRecursive(\n    map: Map<string, any>,\n  ): Array<[string, unknown]> {\n    let arr = [...map];\n    if (arr[0] && arr[0][1] instanceof Map) {\n      arr = arr.map(\n        el => [el[0], this.mapToArrayRecursive(el[1])] as [string, unknown],\n      );\n    }\n    return arr;\n  }\n\n  private static mapFromArrayRecursive(\n    arr: ReadonlyArray<[string, unknown]>,\n  ): Map<string, unknown> {\n    if (arr[0] && Array.isArray(arr[1])) {\n      arr = arr.map(el => [\n        el[0],\n        this.mapFromArrayRecursive(el[1] as Array<[string, unknown]>),\n      ]) as Array<[string, unknown]>;\n    }\n    return new Map(arr);\n  }\n\n  constructor(raw: RawModuleMap) {\n    this._raw = raw;\n  }\n\n  getModule(\n    name: string,\n    platform?: string | null,\n    supportsNativePlatform?: boolean | null,\n    type?: HTypeValue | null,\n  ): string | null {\n    if (type == null) {\n      type = H.MODULE;\n    }\n    const module = this._getModuleMetadata(\n      name,\n      platform,\n      !!supportsNativePlatform,\n    );\n    if (module && module[H.TYPE] === type) {\n      const modulePath = module[H.PATH];\n      return modulePath && fastPath.resolve(this._raw.rootDir, modulePath);\n    }\n    return null;\n  }\n\n  getPackage(\n    name: string,\n    platform: string | null | undefined,\n    _supportsNativePlatform: boolean | null,\n  ): string | null {\n    return this.getModule(name, platform, null, H.PACKAGE);\n  }\n\n  getMockModule(name: string): string | undefined {\n    const mockPath =\n      this._raw.mocks.get(name) || this._raw.mocks.get(`${name}/index`);\n    return mockPath && fastPath.resolve(this._raw.rootDir, mockPath);\n  }\n\n  getRawModuleMap(): RawModuleMap {\n    return {\n      duplicates: this._raw.duplicates,\n      map: this._raw.map,\n      mocks: this._raw.mocks,\n      rootDir: this._raw.rootDir,\n    };\n  }\n\n  toJSON(): SerializableModuleMap {\n    if (!this.json) {\n      this.json = {\n        duplicates: ModuleMap.mapToArrayRecursive(\n          this._raw.duplicates,\n        ) as SerializableModuleMap['duplicates'],\n        map: [...this._raw.map],\n        mocks: [...this._raw.mocks],\n        rootDir: this._raw.rootDir,\n      };\n    }\n    return this.json;\n  }\n\n  static fromJSON(serializableModuleMap: SerializableModuleMap): ModuleMap {\n    return new ModuleMap({\n      duplicates: ModuleMap.mapFromArrayRecursive(\n        serializableModuleMap.duplicates,\n      ) as RawModuleMap['duplicates'],\n      map: new Map(serializableModuleMap.map),\n      mocks: new Map(serializableModuleMap.mocks),\n      rootDir: serializableModuleMap.rootDir,\n    });\n  }\n\n  /**\n   * When looking up a module's data, we walk through each eligible platform for\n   * the query. For each platform, we want to check if there are known\n   * duplicates for that name+platform pair. The duplication logic normally\n   * removes elements from the `map` object, but we want to check upfront to be\n   * extra sure. If metadata exists both in the `duplicates` object and the\n   * `map`, this would be a bug.\n   */\n  private _getModuleMetadata(\n    name: string,\n    platform: string | null | undefined,\n    supportsNativePlatform: boolean,\n  ): ModuleMetaData | null {\n    const map = this._raw.map.get(name) || EMPTY_OBJ;\n    const dupMap = this._raw.duplicates.get(name) || EMPTY_MAP;\n    if (platform != null) {\n      this._assertNoDuplicates(\n        name,\n        platform,\n        supportsNativePlatform,\n        dupMap.get(platform),\n      );\n      if (map[platform] != null) {\n        return map[platform];\n      }\n    }\n    if (supportsNativePlatform) {\n      this._assertNoDuplicates(\n        name,\n        H.NATIVE_PLATFORM,\n        supportsNativePlatform,\n        dupMap.get(H.NATIVE_PLATFORM),\n      );\n      if (map[H.NATIVE_PLATFORM]) {\n        return map[H.NATIVE_PLATFORM];\n      }\n    }\n    this._assertNoDuplicates(\n      name,\n      H.GENERIC_PLATFORM,\n      supportsNativePlatform,\n      dupMap.get(H.GENERIC_PLATFORM),\n    );\n    if (map[H.GENERIC_PLATFORM]) {\n      return map[H.GENERIC_PLATFORM];\n    }\n    return null;\n  }\n\n  private _assertNoDuplicates(\n    name: string,\n    platform: string,\n    supportsNativePlatform: boolean,\n    relativePathSet: DuplicatesSet | null,\n  ) {\n    if (relativePathSet == null) {\n      return;\n    }\n    // Force flow refinement\n    const previousSet = relativePathSet;\n    const duplicates = new Map();\n\n    for (const [relativePath, type] of previousSet) {\n      const duplicatePath = fastPath.resolve(this._raw.rootDir, relativePath);\n      duplicates.set(duplicatePath, type);\n    }\n\n    throw new DuplicateHasteCandidatesError(\n      name,\n      platform,\n      supportsNativePlatform,\n      duplicates,\n    );\n  }\n\n  static create(rootDir: string): ModuleMap {\n    return new ModuleMap({\n      duplicates: new Map(),\n      map: new Map(),\n      mocks: new Map(),\n      rootDir,\n    });\n  }\n}\n\nclass DuplicateHasteCandidatesError extends Error {\n  hasteName: string;\n  platform: string | null;\n  supportsNativePlatform: boolean;\n  duplicatesSet: DuplicatesSet;\n\n  constructor(\n    name: string,\n    platform: string,\n    supportsNativePlatform: boolean,\n    duplicatesSet: DuplicatesSet,\n  ) {\n    const platformMessage = getPlatformMessage(platform);\n    super(\n      `The name \\`${name}\\` was looked up in the Haste module map. It ` +\n        'cannot be resolved, because there exists several different ' +\n        'files, or packages, that provide a module for ' +\n        `that particular name and platform. ${platformMessage} You must ` +\n        `delete or exclude files until there remains only one of these:\\n\\n${[\n          ...duplicatesSet,\n        ]\n          .map(\n            ([dupFilePath, dupFileType]) =>\n              `  * \\`${dupFilePath}\\` (${getTypeMessage(dupFileType)})\\n`,\n          )\n          .sort()\n          .join('')}`,\n    );\n    this.hasteName = name;\n    this.platform = platform;\n    this.supportsNativePlatform = supportsNativePlatform;\n    this.duplicatesSet = duplicatesSet;\n  }\n}\n\nfunction getPlatformMessage(platform: string) {\n  if (platform === H.GENERIC_PLATFORM) {\n    return 'The platform is generic (no extension).';\n  }\n  return `The platform extension is \\`${platform}\\`.`;\n}\n\nfunction getTypeMessage(type: number) {\n  switch (type) {\n    case H.MODULE:\n      return 'module';\n    case H.PACKAGE:\n      return 'package';\n  }\n  return 'unknown';\n}\n\nModuleMap.DuplicateHasteCandidatesError = DuplicateHasteCandidatesError;\n",
  "packages/jest-haste-map/src/ModuleMap.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { DuplicatesSet, HTypeValue, IModuleMap, RawModuleMap, SerializableModuleMap } from './types';\nexport default class ModuleMap implements IModuleMap {\n    static DuplicateHasteCandidatesError: typeof DuplicateHasteCandidatesError;\n    private readonly _raw;\n    private json;\n    private static mapToArrayRecursive;\n    private static mapFromArrayRecursive;\n    constructor(raw: RawModuleMap);\n    getModule(name: string, platform?: string | null, supportsNativePlatform?: boolean | null, type?: HTypeValue | null): string | null;\n    getPackage(name: string, platform: string | null | undefined, _supportsNativePlatform: boolean | null): string | null;\n    getMockModule(name: string): string | undefined;\n    getRawModuleMap(): RawModuleMap;\n    toJSON(): SerializableModuleMap;\n    static fromJSON(serializableModuleMap: SerializableModuleMap): ModuleMap;\n    /**\n     * When looking up a module's data, we walk through each eligible platform for\n     * the query. For each platform, we want to check if there are known\n     * duplicates for that name+platform pair. The duplication logic normally\n     * removes elements from the `map` object, but we want to check upfront to be\n     * extra sure. If metadata exists both in the `duplicates` object and the\n     * `map`, this would be a bug.\n     */\n    private _getModuleMetadata;\n    private _assertNoDuplicates;\n    static create(rootDir: string): ModuleMap;\n}\ndeclare class DuplicateHasteCandidatesError extends Error {\n    hasteName: string;\n    platform: string | null;\n    supportsNativePlatform: boolean;\n    duplicatesSet: DuplicatesSet;\n    constructor(name: string, platform: string, supportsNativePlatform: boolean, duplicatesSet: DuplicatesSet);\n}\nexport {};\n",
  "packages/jest-haste-map/src/HasteFS.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {globsToMatcher, replacePathSepForGlob} from 'jest-util';\nimport H from './constants';\nimport * as fastPath from './lib/fast_path';\nimport type {FileData, IHasteFS} from './types';\n\nexport default class HasteFS implements IHasteFS {\n  private readonly _rootDir: string;\n  private readonly _files: FileData;\n\n  constructor({rootDir, files}: {rootDir: string; files: FileData}) {\n    this._rootDir = rootDir;\n    this._files = files;\n  }\n\n  getModuleName(file: string): string | null {\n    const fileMetadata = this._getFileData(file);\n    return (fileMetadata && fileMetadata[H.ID]) || null;\n  }\n\n  getSize(file: string): number | null {\n    const fileMetadata = this._getFileData(file);\n    return (fileMetadata && fileMetadata[H.SIZE]) || null;\n  }\n\n  getDependencies(file: string): Array<string> | null {\n    const fileMetadata = this._getFileData(file);\n\n    if (fileMetadata) {\n      return fileMetadata[H.DEPENDENCIES]\n        ? fileMetadata[H.DEPENDENCIES].split(H.DEPENDENCY_DELIM)\n        : [];\n    } else {\n      return null;\n    }\n  }\n\n  getSha1(file: string): string | null {\n    const fileMetadata = this._getFileData(file);\n    return (fileMetadata && fileMetadata[H.SHA1]) || null;\n  }\n\n  exists(file: string): boolean {\n    return this._getFileData(file) != null;\n  }\n\n  getAllFiles(): Array<string> {\n    return [...this.getAbsoluteFileIterator()];\n  }\n\n  getFileIterator(): Iterable<string> {\n    return this._files.keys();\n  }\n\n  *getAbsoluteFileIterator(): Iterable<string> {\n    for (const file of this.getFileIterator()) {\n      yield fastPath.resolve(this._rootDir, file);\n    }\n  }\n\n  matchFiles(pattern: RegExp | string): Array<string> {\n    if (!(pattern instanceof RegExp)) {\n      pattern = new RegExp(pattern);\n    }\n    const files = [];\n    for (const file of this.getAbsoluteFileIterator()) {\n      if (pattern.test(file)) {\n        files.push(file);\n      }\n    }\n    return files;\n  }\n\n  matchFilesWithGlob(globs: Array<string>, root: string | null): Set<string> {\n    const files = new Set<string>();\n    const matcher = globsToMatcher(globs);\n\n    for (const file of this.getAbsoluteFileIterator()) {\n      const filePath = root ? fastPath.relative(root, file) : file;\n      if (matcher(replacePathSepForGlob(filePath))) {\n        files.add(file);\n      }\n    }\n    return files;\n  }\n\n  private _getFileData(file: string) {\n    const relativePath = fastPath.relative(this._rootDir, file);\n    return this._files.get(relativePath);\n  }\n}\n",
  "packages/jest-haste-map/src/HasteFS.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { FileData, IHasteFS } from './types';\nexport default class HasteFS implements IHasteFS {\n    private readonly _rootDir;\n    private readonly _files;\n    constructor({ rootDir, files }: {\n        rootDir: string;\n        files: FileData;\n    });\n    getModuleName(file: string): string | null;\n    getSize(file: string): number | null;\n    getDependencies(file: string): Array<string> | null;\n    getSha1(file: string): string | null;\n    exists(file: string): boolean;\n    getAllFiles(): Array<string>;\n    getFileIterator(): Iterable<string>;\n    getAbsoluteFileIterator(): Iterable<string>;\n    matchFiles(pattern: RegExp | string): Array<string>;\n    matchFilesWithGlob(globs: Array<string>, root: string | null): Set<string>;\n    private _getFileData;\n}\n",
  "packages/jest-haste-map/src/watchers/FSEventsWatcher.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {EventEmitter} from 'events';\nimport * as path from 'path';\nimport anymatch, {type Matcher} from 'anymatch';\nimport * as fs from 'graceful-fs';\nimport micromatch from 'micromatch';\n// @ts-expect-error -- no types\nimport walker from 'walker';\n\n// eslint-disable-next-line @typescript-eslint/prefer-ts-expect-error, @typescript-eslint/ban-ts-comment\n// @ts-ignore: this is for CI which runs linux and might not have this\nlet fsevents: typeof import('fsevents') | null = null;\ntry {\n  fsevents = require('fsevents');\n} catch {\n  // Optional dependency, only supported on Darwin.\n}\n\nconst CHANGE_EVENT = 'change';\nconst DELETE_EVENT = 'delete';\nconst ADD_EVENT = 'add';\nconst ALL_EVENT = 'all';\n\ntype FsEventsWatcherEvent =\n  | typeof CHANGE_EVENT\n  | typeof DELETE_EVENT\n  | typeof ADD_EVENT\n  | typeof ALL_EVENT;\n\n/**\n * Export `FSEventsWatcher` class.\n * Watches `dir`.\n */\nexport class FSEventsWatcher extends EventEmitter {\n  readonly root: string;\n  readonly ignored?: Matcher;\n  readonly glob: Array<string>;\n  readonly dot: boolean;\n  readonly hasIgnore: boolean;\n  readonly doIgnore: (path: string) => boolean;\n  readonly fsEventsWatchStopper: () => Promise<void>;\n  private readonly _tracked: Set<string>;\n\n  static isSupported(): boolean {\n    return fsevents !== null;\n  }\n\n  private static normalizeProxy(\n    callback: (normalizedPath: string, stats: fs.Stats) => void,\n  ) {\n    return (filepath: string, stats: fs.Stats): void =>\n      callback(path.normalize(filepath), stats);\n  }\n\n  private static recReaddir(\n    dir: string,\n    dirCallback: (normalizedPath: string, stats: fs.Stats) => void,\n    fileCallback: (normalizedPath: string, stats: fs.Stats) => void,\n    endCallback: () => void,\n    errorCallback: () => void,\n    ignored?: Matcher,\n  ) {\n    walker(dir)\n      .filterDir(\n        (currentDir: string) => !ignored || !anymatch(ignored, currentDir),\n      )\n      .on('dir', FSEventsWatcher.normalizeProxy(dirCallback))\n      .on('file', FSEventsWatcher.normalizeProxy(fileCallback))\n      .on('error', errorCallback)\n      .on('end', () => {\n        endCallback();\n      });\n  }\n\n  constructor(\n    dir: string,\n    opts: {\n      root: string;\n      ignored?: Matcher;\n      glob: string | Array<string>;\n      dot: boolean;\n    },\n  ) {\n    if (!fsevents) {\n      throw new Error(\n        '`fsevents` unavailable (this watcher can only be used on Darwin)',\n      );\n    }\n\n    super();\n\n    this.dot = opts.dot || false;\n    this.ignored = opts.ignored;\n    this.glob = Array.isArray(opts.glob) ? opts.glob : [opts.glob];\n\n    this.hasIgnore =\n      Boolean(opts.ignored) && !(Array.isArray(opts) && opts.length > 0);\n    this.doIgnore = opts.ignored ? anymatch(opts.ignored) : () => false;\n\n    this.root = path.resolve(dir);\n    this.fsEventsWatchStopper = fsevents.watch(\n      this.root,\n      this.handleEvent.bind(this),\n    );\n\n    this._tracked = new Set();\n    FSEventsWatcher.recReaddir(\n      this.root,\n      (filepath: string) => {\n        this._tracked.add(filepath);\n      },\n      (filepath: string) => {\n        this._tracked.add(filepath);\n      },\n      this.emit.bind(this, 'ready'),\n      this.emit.bind(this, 'error'),\n      this.ignored,\n    );\n  }\n\n  /**\n   * End watching.\n   */\n  async close(callback?: () => void): Promise<void> {\n    await this.fsEventsWatchStopper();\n    this.removeAllListeners();\n    if (typeof callback === 'function') {\n      process.nextTick(() => callback());\n    }\n  }\n\n  private isFileIncluded(relativePath: string) {\n    if (this.doIgnore(relativePath)) {\n      return false;\n    }\n    return this.glob.length > 0\n      ? micromatch([relativePath], this.glob, {dot: this.dot}).length > 0\n      : this.dot || micromatch([relativePath], '**/*').length > 0;\n  }\n\n  private handleEvent(filepath: string) {\n    const relativePath = path.relative(this.root, filepath);\n    if (!this.isFileIncluded(relativePath)) {\n      return;\n    }\n\n    fs.lstat(filepath, (error, stat) => {\n      if (error && error.code !== 'ENOENT') {\n        this.emit('error', error);\n        return;\n      }\n\n      if (error) {\n        // Ignore files that aren't tracked and don't exist.\n        if (!this._tracked.has(filepath)) {\n          return;\n        }\n\n        this._emit(DELETE_EVENT, relativePath);\n        this._tracked.delete(filepath);\n        return;\n      }\n\n      if (this._tracked.has(filepath)) {\n        this._emit(CHANGE_EVENT, relativePath, stat);\n      } else {\n        this._tracked.add(filepath);\n        this._emit(ADD_EVENT, relativePath, stat);\n      }\n    });\n  }\n\n  /**\n   * Emit events.\n   */\n  private _emit(type: FsEventsWatcherEvent, file: string, stat?: fs.Stats) {\n    this.emit(type, file, this.root, stat);\n    this.emit(ALL_EVENT, type, file, this.root, stat);\n  }\n}\n",
  "packages/jest-haste-map/src/watchers/FSEventsWatcher.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport { EventEmitter } from 'events';\nimport { type Matcher } from 'anymatch';\n/**\n * Export `FSEventsWatcher` class.\n * Watches `dir`.\n */\nexport declare class FSEventsWatcher extends EventEmitter {\n    readonly root: string;\n    readonly ignored?: Matcher;\n    readonly glob: Array<string>;\n    readonly dot: boolean;\n    readonly hasIgnore: boolean;\n    readonly doIgnore: (path: string) => boolean;\n    readonly fsEventsWatchStopper: () => Promise<void>;\n    private readonly _tracked;\n    static isSupported(): boolean;\n    private static normalizeProxy;\n    private static recReaddir;\n    constructor(dir: string, opts: {\n        root: string;\n        ignored?: Matcher;\n        glob: string | Array<string>;\n        dot: boolean;\n    });\n    /**\n     * End watching.\n     */\n    close(callback?: () => void): Promise<void>;\n    private isFileIncluded;\n    private handleEvent;\n    /**\n     * Emit events.\n     */\n    private _emit;\n}\n",
  "packages/jest-haste-map/src/lib/normalizePathSep.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\n\nlet normalizePathSep: (string: string) => string;\nif (path.sep === '/') {\n  normalizePathSep = (filePath: string): string => filePath;\n} else {\n  normalizePathSep = (filePath: string): string =>\n    filePath.replaceAll('/', path.sep);\n}\n\nexport default normalizePathSep;\n",
  "packages/jest-haste-map/src/lib/normalizePathSep.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\ndeclare let normalizePathSep: (string: string) => string;\nexport default normalizePathSep;\n",
  "packages/jest-haste-map/src/lib/isWatchmanInstalled.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {execFile} from 'child_process';\nimport {promisify} from 'util';\n\nexport default async function isWatchmanInstalled(): Promise<boolean> {\n  try {\n    await promisify(execFile)('watchman', ['--version']);\n    return true;\n  } catch {\n    return false;\n  }\n}\n",
  "packages/jest-haste-map/src/lib/isWatchmanInstalled.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport default function isWatchmanInstalled(): Promise<boolean>;\n",
  "packages/jest-haste-map/src/lib/getPlatformExtension.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst SUPPORTED_PLATFORM_EXTS = new Set(['android', 'ios', 'native', 'web']);\n\n// Extract platform extension: index.ios.js -> ios\nexport default function getPlatformExtension(\n  file: string,\n  platforms?: Array<string>,\n): string | null {\n  const last = file.lastIndexOf('.');\n  const secondToLast = file.lastIndexOf('.', last - 1);\n  if (secondToLast === -1) {\n    return null;\n  }\n  const platform = file.slice(secondToLast + 1, last);\n  // If an overriding platform array is passed, check that first\n\n  if (platforms && platforms.includes(platform)) {\n    return platform;\n  }\n  return SUPPORTED_PLATFORM_EXTS.has(platform) ? platform : null;\n}\n",
  "packages/jest-haste-map/src/lib/getPlatformExtension.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport default function getPlatformExtension(file: string, platforms?: Array<string>): string | null;\n",
  "packages/jest-haste-map/src/lib/fast_path.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\n\n// rootDir and filename must be absolute paths (resolved)\nexport function relative(rootDir: string, filename: string): string {\n  return filename.indexOf(rootDir + path.sep) === 0\n    ? filename.slice(rootDir.length + 1)\n    : path.relative(rootDir, filename);\n}\n\nconst INDIRECTION_FRAGMENT = `..${path.sep}`;\n\n// rootDir must be an absolute path and relativeFilename must be simple\n// (e.g.: foo/bar or ../foo/bar, but never ./foo or foo/../bar)\nexport function resolve(rootDir: string, relativeFilename: string): string {\n  return relativeFilename.indexOf(INDIRECTION_FRAGMENT) === 0\n    ? path.resolve(rootDir, relativeFilename)\n    : rootDir + path.sep + relativeFilename;\n}\n",
  "packages/jest-haste-map/src/lib/fast_path.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport declare function relative(rootDir: string, filename: string): string;\nexport declare function resolve(rootDir: string, relativeFilename: string): string;\n",
  "packages/jest-haste-map/src/lib/dependencyExtractor.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {DependencyExtractor} from '../types';\n\nconst NOT_A_DOT = '(?<!\\\\.\\\\s*)';\nconst CAPTURE_STRING_LITERAL = (pos: number) =>\n  `([\\`'\"])([^'\"\\`]*?)(?:\\\\${pos})`;\nconst WORD_SEPARATOR = '\\\\b';\nconst LEFT_PARENTHESIS = '\\\\(';\nconst RIGHT_PARENTHESIS = '\\\\)';\nconst WHITESPACE = '\\\\s*';\nconst OPTIONAL_COMMA = '(:?,\\\\s*)?';\n\nfunction createRegExp(parts: Array<string>, flags: string) {\n  return new RegExp(parts.join(''), flags);\n}\n\nfunction alternatives(...parts: Array<string>) {\n  return `(?:${parts.join('|')})`;\n}\n\nfunction functionCallStart(...names: Array<string>) {\n  return [\n    NOT_A_DOT,\n    WORD_SEPARATOR,\n    alternatives(...names),\n    WHITESPACE,\n    LEFT_PARENTHESIS,\n    WHITESPACE,\n  ];\n}\n\nconst BLOCK_COMMENT_RE = /\\/\\*[^]*?\\*\\//g;\nconst LINE_COMMENT_RE = /\\/\\/.*/g;\n\nconst REQUIRE_OR_DYNAMIC_IMPORT_RE = createRegExp(\n  [\n    ...functionCallStart('require', 'import'),\n    CAPTURE_STRING_LITERAL(1),\n    WHITESPACE,\n    OPTIONAL_COMMA,\n    RIGHT_PARENTHESIS,\n  ],\n  'g',\n);\n\nconst IMPORT_OR_EXPORT_RE = createRegExp(\n  [\n    '\\\\b(?:import|export)\\\\s+(?!type(?:of)?\\\\s+)(?:[^\\'\"]+\\\\s+from\\\\s+)?',\n    CAPTURE_STRING_LITERAL(1),\n  ],\n  'g',\n);\n\nconst JEST_EXTENSIONS_RE = createRegExp(\n  [\n    ...functionCallStart(\n      'jest\\\\s*\\\\.\\\\s*(?:requireActual|requireMock|createMockFromModule)',\n    ),\n    CAPTURE_STRING_LITERAL(1),\n    WHITESPACE,\n    OPTIONAL_COMMA,\n    RIGHT_PARENTHESIS,\n  ],\n  'g',\n);\n\nexport const extractor: DependencyExtractor = {\n  extract(code) {\n    const dependencies = new Set<string>();\n\n    const addDependency = (match: string, _: string, dep: string) => {\n      dependencies.add(dep);\n      return match;\n    };\n\n    code\n      .replaceAll(BLOCK_COMMENT_RE, '')\n      .replaceAll(LINE_COMMENT_RE, '')\n      .replace(IMPORT_OR_EXPORT_RE, addDependency)\n      .replace(REQUIRE_OR_DYNAMIC_IMPORT_RE, addDependency)\n      .replace(JEST_EXTENSIONS_RE, addDependency);\n\n    return dependencies;\n  },\n};\n",
  "packages/jest-haste-map/src/lib/dependencyExtractor.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { DependencyExtractor } from '../types';\nexport declare const extractor: DependencyExtractor;\n",
  "packages/jest-haste-map/src/crawlers/watchman.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport * as watchman from 'fb-watchman';\nimport H from '../constants';\nimport * as fastPath from '../lib/fast_path';\nimport normalizePathSep from '../lib/normalizePathSep';\nimport type {\n  CrawlerOptions,\n  FileData,\n  FileMetaData,\n  InternalHasteMap,\n} from '../types';\n\ntype WatchmanRoots = Map<string, Array<string>>;\n\ntype WatchmanListCapabilitiesResponse = {\n  capabilities: Array<string>;\n};\n\ntype WatchmanCapabilityCheckResponse = {\n  // { 'suffix-set': true }\n  capabilities: Record<string, boolean>;\n  // '2021.06.07.00'\n  version: string;\n};\n\ntype WatchmanWatchProjectResponse = {\n  watch: string;\n  relative_path: string;\n};\n\ntype WatchmanQueryResponse = {\n  warning?: string;\n  is_fresh_instance: boolean;\n  version: string;\n  clock:\n    | string\n    | {\n        scm: {'mergebase-with': string; mergebase: string};\n        clock: string;\n      };\n  files: Array<{\n    name: string;\n    exists: boolean;\n    mtime_ms: number | {toNumber: () => number};\n    size: number;\n    'content.sha1hex'?: string;\n  }>;\n};\n\nconst watchmanURL = 'https://facebook.github.io/watchman/docs/troubleshooting';\n\nfunction watchmanError(error: Error): Error {\n  error.message =\n    `Watchman error: ${error.message.trim()}. Make sure watchman ` +\n    `is running for this project. See ${watchmanURL}.`;\n  return error;\n}\n\n/**\n * Wrap watchman capabilityCheck method as a promise.\n *\n * @param client watchman client\n * @param caps capabilities to verify\n * @returns a promise resolving to a list of verified capabilities\n */\nasync function capabilityCheck(\n  client: watchman.Client,\n  caps: Partial<watchman.Capabilities>,\n): Promise<WatchmanCapabilityCheckResponse> {\n  return new Promise((resolve, reject) => {\n    client.capabilityCheck(\n      // @ts-expect-error: incorrectly typed\n      caps,\n      (error, response) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(response);\n        }\n      },\n    );\n  });\n}\n\nexport async function watchmanCrawl(options: CrawlerOptions): Promise<{\n  changedFiles?: FileData;\n  removedFiles: FileData;\n  hasteMap: InternalHasteMap;\n}> {\n  const fields = ['name', 'exists', 'mtime_ms', 'size'];\n  const {data, extensions, ignore, rootDir, roots} = options;\n  const defaultWatchExpression: Array<any> = ['allof', ['type', 'f']];\n  const clocks = data.clocks;\n  const client = new watchman.Client();\n\n  // https://facebook.github.io/watchman/docs/capabilities.html\n  // Check adds about ~28ms\n  const capabilities = await capabilityCheck(client, {\n    // If a required capability is missing then an error will be thrown,\n    // we don't need this assertion, so using optional instead.\n    optional: ['suffix-set'],\n  });\n\n  if (capabilities?.capabilities['suffix-set']) {\n    // If available, use the optimized `suffix-set` operation:\n    // https://facebook.github.io/watchman/docs/expr/suffix.html#suffix-set\n    defaultWatchExpression.push(['suffix', extensions]);\n  } else {\n    // Otherwise use the older and less optimal suffix tuple array\n    defaultWatchExpression.push([\n      'anyof',\n      ...extensions.map(extension => ['suffix', extension]),\n    ]);\n  }\n\n  let clientError;\n  client.on('error', error => (clientError = watchmanError(error)));\n\n  const cmd = <T>(...args: Array<any>): Promise<T> =>\n    new Promise((resolve, reject) =>\n      // @ts-expect-error: client is typed strictly, but incomplete\n      client.command(args, (error, result) =>\n        error ? reject(watchmanError(error)) : resolve(result),\n      ),\n    );\n\n  if (options.computeSha1) {\n    const {capabilities} =\n      await cmd<WatchmanListCapabilitiesResponse>('list-capabilities');\n\n    if (capabilities.includes('field-content.sha1hex')) {\n      fields.push('content.sha1hex');\n    }\n  }\n\n  async function getWatchmanRoots(\n    roots: Array<string>,\n  ): Promise<WatchmanRoots> {\n    const watchmanRoots = new Map();\n    await Promise.all(\n      roots.map(async root => {\n        const response = await cmd<WatchmanWatchProjectResponse>(\n          'watch-project',\n          root,\n        );\n        const existing = watchmanRoots.get(response.watch);\n        // A root can only be filtered if it was never seen with a\n        // relative_path before.\n        const canBeFiltered = !existing || existing.length > 0;\n\n        if (canBeFiltered) {\n          if (response.relative_path) {\n            watchmanRoots.set(response.watch, [\n              ...(existing || []),\n              response.relative_path,\n            ]);\n          } else {\n            // Make the filter directories an empty array to signal that this\n            // root was already seen and needs to be watched for all files or\n            // directories.\n            watchmanRoots.set(response.watch, []);\n          }\n        }\n      }),\n    );\n    return watchmanRoots;\n  }\n\n  async function queryWatchmanForDirs(rootProjectDirMappings: WatchmanRoots) {\n    const results = new Map<string, WatchmanQueryResponse>();\n    let isFresh = false;\n    await Promise.all(\n      [...rootProjectDirMappings].map(async ([root, directoryFilters]) => {\n        const expression = [...defaultWatchExpression];\n        const glob = [];\n\n        if (directoryFilters.length > 0) {\n          expression.push([\n            'anyof',\n            ...directoryFilters.map(dir => ['dirname', dir]),\n          ]);\n\n          for (const directory of directoryFilters) {\n            for (const extension of extensions) {\n              glob.push(`${directory}/**/*.${extension}`);\n            }\n          }\n        } else {\n          for (const extension of extensions) {\n            glob.push(`**/*.${extension}`);\n          }\n        }\n\n        // Jest is only going to store one type of clock; a string that\n        // represents a local clock. However, the Watchman crawler supports\n        // a second type of clock that can be written by automation outside of\n        // Jest, called an \"scm query\", which fetches changed files based on\n        // source control mergebases. The reason this is necessary is because\n        // local clocks are not portable across systems, but scm queries are.\n        // By using scm queries, we can create the haste map on a different\n        // system and import it, transforming the clock into a local clock.\n        const since = clocks.get(fastPath.relative(rootDir, root));\n\n        const query =\n          since === undefined\n            ? // Use the `since` generator if we have a clock available\n              {expression, fields, glob, glob_includedotfiles: true}\n            : // Otherwise use the `glob` filter\n              {expression, fields, since};\n\n        const response = await cmd<WatchmanQueryResponse>('query', root, query);\n\n        if ('warning' in response) {\n          console.warn('watchman warning:', response.warning);\n        }\n\n        // When a source-control query is used, we ignore the \"is fresh\"\n        // response from Watchman because it will be true despite the query\n        // being incremental.\n        const isSourceControlQuery =\n          typeof since !== 'string' &&\n          since?.scm?.['mergebase-with'] !== undefined;\n        if (!isSourceControlQuery) {\n          isFresh = isFresh || response.is_fresh_instance;\n        }\n\n        results.set(root, response);\n      }),\n    );\n\n    return {\n      isFresh,\n      results,\n    };\n  }\n\n  let files = data.files;\n  let removedFiles = new Map();\n  const changedFiles = new Map();\n  let results: Map<string, WatchmanQueryResponse>;\n  let isFresh = false;\n  try {\n    const watchmanRoots = await getWatchmanRoots(roots);\n    const watchmanFileResults = await queryWatchmanForDirs(watchmanRoots);\n\n    // Reset the file map if watchman was restarted and sends us a list of\n    // files.\n    if (watchmanFileResults.isFresh) {\n      files = new Map();\n      removedFiles = new Map(data.files);\n      isFresh = true;\n    }\n\n    results = watchmanFileResults.results;\n  } finally {\n    client.end();\n  }\n\n  if (clientError) {\n    throw clientError;\n  }\n\n  for (const [watchRoot, response] of results) {\n    const fsRoot = normalizePathSep(watchRoot);\n    const relativeFsRoot = fastPath.relative(rootDir, fsRoot);\n    clocks.set(\n      relativeFsRoot,\n      // Ensure we persist only the local clock.\n      typeof response.clock === 'string'\n        ? response.clock\n        : response.clock.clock,\n    );\n\n    for (const fileData of response.files) {\n      const filePath = fsRoot + path.sep + normalizePathSep(fileData.name);\n      const relativeFilePath = fastPath.relative(rootDir, filePath);\n      const existingFileData = data.files.get(relativeFilePath);\n\n      // If watchman is fresh, the removed files map starts with all files\n      // and we remove them as we verify they still exist.\n      if (isFresh && existingFileData && fileData.exists) {\n        removedFiles.delete(relativeFilePath);\n      }\n\n      if (!fileData.exists) {\n        // No need to act on files that do not exist and were not tracked.\n        if (existingFileData) {\n          files.delete(relativeFilePath);\n\n          // If watchman is not fresh, we will know what specific files were\n          // deleted since we last ran and can track only those files.\n          if (!isFresh) {\n            removedFiles.set(relativeFilePath, existingFileData);\n          }\n        }\n      } else if (!ignore(filePath)) {\n        const mtime =\n          typeof fileData.mtime_ms === 'number'\n            ? fileData.mtime_ms\n            : fileData.mtime_ms.toNumber();\n        const size = fileData.size;\n\n        let sha1hex = fileData['content.sha1hex'];\n        if (typeof sha1hex !== 'string' || sha1hex.length !== 40) {\n          sha1hex = undefined;\n        }\n\n        let nextData: FileMetaData;\n\n        if (existingFileData && existingFileData[H.MTIME] === mtime) {\n          nextData = existingFileData;\n        } else if (\n          existingFileData &&\n          sha1hex &&\n          existingFileData[H.SHA1] === sha1hex\n        ) {\n          nextData = [\n            existingFileData[0],\n            mtime,\n            existingFileData[2],\n            existingFileData[3],\n            existingFileData[4],\n            existingFileData[5],\n          ];\n        } else {\n          // See ../constants.ts\n          nextData = ['', mtime, size, 0, '', sha1hex ?? null];\n        }\n\n        files.set(relativeFilePath, nextData);\n        changedFiles.set(relativeFilePath, nextData);\n      }\n    }\n  }\n\n  data.files = files;\n  return {\n    changedFiles: isFresh ? undefined : changedFiles,\n    hasteMap: data,\n    removedFiles,\n  };\n}\n",
  "packages/jest-haste-map/src/crawlers/watchman.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { CrawlerOptions, FileData, InternalHasteMap } from '../types';\nexport declare function watchmanCrawl(options: CrawlerOptions): Promise<{\n    changedFiles?: FileData;\n    removedFiles: FileData;\n    hasteMap: InternalHasteMap;\n}>;\n",
  "packages/jest-haste-map/src/crawlers/node.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {spawn} from 'child_process';\nimport * as path from 'path';\nimport * as fs from 'graceful-fs';\nimport H from '../constants';\nimport * as fastPath from '../lib/fast_path';\nimport type {\n  CrawlerOptions,\n  FileData,\n  IgnoreMatcher,\n  InternalHasteMap,\n} from '../types';\n\ntype Result = Array<[/* id */ string, /* mtime */ number, /* size */ number]>;\n\ntype Callback = (result: Result) => void;\n\nasync function hasNativeFindSupport(\n  forceNodeFilesystemAPI: boolean,\n): Promise<boolean> {\n  if (forceNodeFilesystemAPI) {\n    return false;\n  }\n\n  try {\n    return await new Promise(resolve => {\n      // Check the find binary supports the non-POSIX -iname parameter wrapped in parens.\n      const args = [\n        '.',\n        '-type',\n        'f',\n        '(',\n        '-iname',\n        '*.ts',\n        '-o',\n        '-iname',\n        '*.js',\n        ')',\n      ];\n      const child = spawn('find', args, {cwd: __dirname});\n      child.on('error', () => {\n        resolve(false);\n      });\n      child.on('exit', code => {\n        resolve(code === 0);\n      });\n    });\n  } catch {\n    return false;\n  }\n}\n\nfunction find(\n  roots: Array<string>,\n  extensions: Array<string>,\n  ignore: IgnoreMatcher,\n  enableSymlinks: boolean,\n  callback: Callback,\n): void {\n  const result: Result = [];\n  let activeCalls = 0;\n\n  function search(directory: string): void {\n    activeCalls++;\n    fs.readdir(directory, {withFileTypes: true}, (err, entries) => {\n      activeCalls--;\n      if (err) {\n        if (activeCalls === 0) {\n          callback(result);\n        }\n        return;\n      }\n      for (const entry of entries) {\n        const file = path.join(directory, entry.name);\n\n        if (ignore(file)) {\n          continue;\n        }\n\n        if (entry.isSymbolicLink()) {\n          continue;\n        }\n        if (entry.isDirectory()) {\n          search(file);\n          continue;\n        }\n\n        activeCalls++;\n\n        const stat = enableSymlinks ? fs.stat : fs.lstat;\n\n        stat(file, (err, stat) => {\n          activeCalls--;\n\n          // This logic is unnecessary for node > v10.10, but leaving it in\n          // since we need it for backwards-compatibility still.\n          if (!err && stat && !stat.isSymbolicLink()) {\n            if (stat.isDirectory()) {\n              search(file);\n            } else {\n              const ext = path.extname(file).slice(1);\n              if (extensions.includes(ext)) {\n                result.push([file, stat.mtime.getTime(), stat.size]);\n              }\n            }\n          }\n\n          if (activeCalls === 0) {\n            callback(result);\n          }\n        });\n      }\n\n      if (activeCalls === 0) {\n        callback(result);\n      }\n    });\n  }\n\n  if (roots.length > 0) {\n    for (const root of roots) search(root);\n  } else {\n    callback(result);\n  }\n}\n\nfunction findNative(\n  roots: Array<string>,\n  extensions: Array<string>,\n  ignore: IgnoreMatcher,\n  enableSymlinks: boolean,\n  callback: Callback,\n): void {\n  const args = [...roots];\n  if (enableSymlinks) {\n    args.push('(', '-type', 'f', '-o', '-type', 'l', ')');\n  } else {\n    args.push('-type', 'f');\n  }\n\n  if (extensions.length > 0) {\n    args.push('(');\n  }\n  for (const [index, ext] of extensions.entries()) {\n    if (index) {\n      args.push('-o');\n    }\n    args.push('-iname', `*.${ext}`);\n  }\n  if (extensions.length > 0) {\n    args.push(')');\n  }\n\n  const child = spawn('find', args);\n  let stdout = '';\n  if (child.stdout === null) {\n    throw new Error(\n      'stdout is null - this should never happen. Please open up an issue at https://github.com/jestjs/jest',\n    );\n  }\n  child.stdout.setEncoding('utf8');\n  child.stdout.on('data', data => (stdout += data));\n\n  child.stdout.on('close', () => {\n    const lines = stdout\n      .trim()\n      .split('\\n')\n      .filter(x => !ignore(x));\n    const result: Result = [];\n    let count = lines.length;\n    if (count) {\n      for (const path of lines) {\n        fs.stat(path, (err, stat) => {\n          // Filter out symlinks that describe directories\n          if (!err && stat && !stat.isDirectory()) {\n            result.push([path, stat.mtime.getTime(), stat.size]);\n          }\n          if (--count === 0) {\n            callback(result);\n          }\n        });\n      }\n    } else {\n      callback([]);\n    }\n  });\n}\n\nexport async function nodeCrawl(options: CrawlerOptions): Promise<{\n  removedFiles: FileData;\n  hasteMap: InternalHasteMap;\n}> {\n  const {\n    data,\n    extensions,\n    forceNodeFilesystemAPI,\n    ignore,\n    rootDir,\n    enableSymlinks,\n    roots,\n  } = options;\n\n  const useNativeFind = await hasNativeFindSupport(forceNodeFilesystemAPI);\n\n  return new Promise(resolve => {\n    const callback = (list: Result) => {\n      const files = new Map();\n      const removedFiles = new Map(data.files);\n      for (const fileData of list) {\n        const [filePath, mtime, size] = fileData;\n        const relativeFilePath = fastPath.relative(rootDir, filePath);\n        const existingFile = data.files.get(relativeFilePath);\n        if (existingFile && existingFile[H.MTIME] === mtime) {\n          files.set(relativeFilePath, existingFile);\n        } else {\n          // See ../constants.js; SHA-1 will always be null and fulfilled later.\n          files.set(relativeFilePath, ['', mtime, size, 0, '', null]);\n        }\n        removedFiles.delete(relativeFilePath);\n      }\n      data.files = files;\n\n      resolve({\n        hasteMap: data,\n        removedFiles,\n      });\n    };\n\n    if (useNativeFind) {\n      findNative(roots, extensions, ignore, enableSymlinks, callback);\n    } else {\n      find(roots, extensions, ignore, enableSymlinks, callback);\n    }\n  });\n}\n",
  "packages/jest-haste-map/src/crawlers/node.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { CrawlerOptions, FileData, InternalHasteMap } from '../types';\nexport declare function nodeCrawl(options: CrawlerOptions): Promise<{\n    removedFiles: FileData;\n    hasteMap: InternalHasteMap;\n}>;\n",
  "packages/jest-haste-map/src/__tests__/includes_dotfiles.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport HasteMap from '../index';\n\nconst rootDir = path.join(__dirname, './test_dotfiles_root');\n\nconst commonOptions = {\n  extensions: ['js'],\n  maxWorkers: 1,\n  platforms: [],\n  resetCache: true,\n  retainAllFiles: true,\n  rootDir,\n  roots: [rootDir],\n};\n\ntest('watchman crawler and node crawler both include dotfiles', async () => {\n  const hasteMapWithWatchman = await HasteMap.create({\n    ...commonOptions,\n    id: 'withWatchman',\n    useWatchman: true,\n  });\n\n  const hasteMapWithNode = await HasteMap.create({\n    ...commonOptions,\n    id: 'withNode',\n    useWatchman: false,\n  });\n\n  const [builtHasteMapWithWatchman, builtHasteMapWithNode] = await Promise.all([\n    hasteMapWithWatchman.build(),\n    hasteMapWithNode.build(),\n  ]);\n\n  expect(\n    builtHasteMapWithWatchman.hasteFS.matchFiles('.eslintrc.js'),\n  ).toHaveLength(1);\n\n  expect(builtHasteMapWithWatchman.hasteFS.getAllFiles().sort()).toEqual(\n    builtHasteMapWithNode.hasteFS.getAllFiles().sort(),\n  );\n});\n",
  "packages/jest-haste-map/src/__tests__/includes_dotfiles.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-globals/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {Jest} from '@jest/environment';\nimport type {JestExpect} from '@jest/expect';\nimport type {Global} from '@jest/types';\nimport type {\n  ClassLike,\n  FunctionLike,\n  Mock as JestMock,\n  Mocked as JestMocked,\n  MockedClass as JestMockedClass,\n  MockedFunction as JestMockedFunction,\n  MockedObject as JestMockedObject,\n  Replaced as JestReplaced,\n  Spied as JestSpied,\n  SpiedClass as JestSpiedClass,\n  SpiedFunction as JestSpiedFunction,\n  SpiedGetter as JestSpiedGetter,\n  SpiedSetter as JestSpiedSetter,\n  UnknownFunction,\n} from 'jest-mock';\n\nexport declare const expect: JestExpect;\n\nexport declare const it: Global.GlobalAdditions['it'];\nexport declare const test: Global.GlobalAdditions['test'];\nexport declare const fit: Global.GlobalAdditions['fit'];\nexport declare const xit: Global.GlobalAdditions['xit'];\nexport declare const xtest: Global.GlobalAdditions['xtest'];\nexport declare const describe: Global.GlobalAdditions['describe'];\nexport declare const xdescribe: Global.GlobalAdditions['xdescribe'];\nexport declare const fdescribe: Global.GlobalAdditions['fdescribe'];\nexport declare const beforeAll: Global.GlobalAdditions['beforeAll'];\nexport declare const beforeEach: Global.GlobalAdditions['beforeEach'];\nexport declare const afterEach: Global.GlobalAdditions['afterEach'];\nexport declare const afterAll: Global.GlobalAdditions['afterAll'];\n\ndeclare const jest: Jest;\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\ndeclare namespace jest {\n  /**\n   * Constructs the type of a mock function, e.g. the return type of `jest.fn()`.\n   */\n  export type Mock<T extends FunctionLike = UnknownFunction> = JestMock<T>;\n  /**\n   * Wraps a class, function or object type with Jest mock type definitions.\n   */\n  export type Mocked<T extends object> = JestMocked<T>;\n  /**\n   * Wraps a class type with Jest mock type definitions.\n   */\n  export type MockedClass<T extends ClassLike> = JestMockedClass<T>;\n  /**\n   * Wraps a function type with Jest mock type definitions.\n   */\n  export type MockedFunction<T extends FunctionLike> = JestMockedFunction<T>;\n  /**\n   * Wraps an object type with Jest mock type definitions.\n   */\n  export type MockedObject<T extends object> = JestMockedObject<T>;\n  /**\n   * Constructs the type of a replaced property.\n   */\n  export type Replaced<T> = JestReplaced<T>;\n  /**\n   * Constructs the type of a spied class or function.\n   */\n  export type Spied<T extends ClassLike | FunctionLike> = JestSpied<T>;\n  /**\n   * Constructs the type of a spied class.\n   */\n  export type SpiedClass<T extends ClassLike> = JestSpiedClass<T>;\n  /**\n   * Constructs the type of a spied function.\n   */\n  export type SpiedFunction<T extends FunctionLike> = JestSpiedFunction<T>;\n  /**\n   * Constructs the type of a spied getter.\n   */\n  export type SpiedGetter<T> = JestSpiedGetter<T>;\n  /**\n   * Constructs the type of a spied setter.\n   */\n  export type SpiedSetter<T> = JestSpiedSetter<T>;\n}\n\nexport {jest};\n\nthrow new Error(\n  'Do not import `@jest/globals` outside of the Jest test environment',\n);\n",
  "packages/jest-globals/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Jest } from '@jest/environment';\nimport type { JestExpect } from '@jest/expect';\nimport type { Global } from '@jest/types';\nimport type { ClassLike, FunctionLike, Mock as JestMock, Mocked as JestMocked, MockedClass as JestMockedClass, MockedFunction as JestMockedFunction, MockedObject as JestMockedObject, Replaced as JestReplaced, Spied as JestSpied, SpiedClass as JestSpiedClass, SpiedFunction as JestSpiedFunction, SpiedGetter as JestSpiedGetter, SpiedSetter as JestSpiedSetter, UnknownFunction } from 'jest-mock';\nexport declare const expect: JestExpect;\nexport declare const it: Global.GlobalAdditions['it'];\nexport declare const test: Global.GlobalAdditions['test'];\nexport declare const fit: Global.GlobalAdditions['fit'];\nexport declare const xit: Global.GlobalAdditions['xit'];\nexport declare const xtest: Global.GlobalAdditions['xtest'];\nexport declare const describe: Global.GlobalAdditions['describe'];\nexport declare const xdescribe: Global.GlobalAdditions['xdescribe'];\nexport declare const fdescribe: Global.GlobalAdditions['fdescribe'];\nexport declare const beforeAll: Global.GlobalAdditions['beforeAll'];\nexport declare const beforeEach: Global.GlobalAdditions['beforeEach'];\nexport declare const afterEach: Global.GlobalAdditions['afterEach'];\nexport declare const afterAll: Global.GlobalAdditions['afterAll'];\ndeclare const jest: Jest;\ndeclare namespace jest {\n    /**\n     * Constructs the type of a mock function, e.g. the return type of `jest.fn()`.\n     */\n    type Mock<T extends FunctionLike = UnknownFunction> = JestMock<T>;\n    /**\n     * Wraps a class, function or object type with Jest mock type definitions.\n     */\n    type Mocked<T extends object> = JestMocked<T>;\n    /**\n     * Wraps a class type with Jest mock type definitions.\n     */\n    type MockedClass<T extends ClassLike> = JestMockedClass<T>;\n    /**\n     * Wraps a function type with Jest mock type definitions.\n     */\n    type MockedFunction<T extends FunctionLike> = JestMockedFunction<T>;\n    /**\n     * Wraps an object type with Jest mock type definitions.\n     */\n    type MockedObject<T extends object> = JestMockedObject<T>;\n    /**\n     * Constructs the type of a replaced property.\n     */\n    type Replaced<T> = JestReplaced<T>;\n    /**\n     * Constructs the type of a spied class or function.\n     */\n    type Spied<T extends ClassLike | FunctionLike> = JestSpied<T>;\n    /**\n     * Constructs the type of a spied class.\n     */\n    type SpiedClass<T extends ClassLike> = JestSpiedClass<T>;\n    /**\n     * Constructs the type of a spied function.\n     */\n    type SpiedFunction<T extends FunctionLike> = JestSpiedFunction<T>;\n    /**\n     * Constructs the type of a spied getter.\n     */\n    type SpiedGetter<T> = JestSpiedGetter<T>;\n    /**\n     * Constructs the type of a spied setter.\n     */\n    type SpiedSetter<T> = JestSpiedSetter<T>;\n}\nexport { jest };\n",
  "packages/jest-globals/src/__tests__/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ntest('throw when directly imported', () => {\n  expect(() => {\n    require('../');\n  }).toThrow(\n    'Do not import `@jest/globals` outside of the Jest test environment',\n  );\n});\n",
  "packages/jest-globals/src/__tests__/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n",
  "packages/jest-get-type/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ntype ValueType =\n  | 'array'\n  | 'bigint'\n  | 'boolean'\n  | 'function'\n  | 'null'\n  | 'number'\n  | 'object'\n  | 'regexp'\n  | 'map'\n  | 'set'\n  | 'date'\n  | 'string'\n  | 'symbol'\n  | 'undefined';\n\n// get the type of a value with handling the edge cases like `typeof []`\n// and `typeof null`\nexport function getType(value: unknown): ValueType {\n  if (value === undefined) {\n    return 'undefined';\n  } else if (value === null) {\n    return 'null';\n  } else if (Array.isArray(value)) {\n    return 'array';\n  } else if (typeof value === 'boolean') {\n    return 'boolean';\n  } else if (typeof value === 'function') {\n    return 'function';\n  } else if (typeof value === 'number') {\n    return 'number';\n  } else if (typeof value === 'string') {\n    return 'string';\n  } else if (typeof value === 'bigint') {\n    return 'bigint';\n  } else if (typeof value === 'object') {\n    if (value.constructor === RegExp) {\n      return 'regexp';\n    } else if (value.constructor === Map) {\n      return 'map';\n    } else if (value.constructor === Set) {\n      return 'set';\n    } else if (value.constructor === Date) {\n      return 'date';\n    }\n    return 'object';\n  } else if (typeof value === 'symbol') {\n    return 'symbol';\n  }\n\n  throw new Error(`value of unknown type: ${value}`);\n}\n\nexport const isPrimitive = (value: unknown): boolean => Object(value) !== value;\n",
  "packages/jest-get-type/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\ntype ValueType = 'array' | 'bigint' | 'boolean' | 'function' | 'null' | 'number' | 'object' | 'regexp' | 'map' | 'set' | 'date' | 'string' | 'symbol' | 'undefined';\nexport declare function getType(value: unknown): ValueType;\nexport declare const isPrimitive: (value: unknown) => boolean;\nexport {};\n",
  "packages/jest-get-type/src/__tests__/isPrimitive.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {isPrimitive} from '..';\n\ndescribe('.isPrimitive()', () => {\n  test.each([\n    null,\n    undefined,\n    100,\n    'hello world',\n    true,\n    Symbol.for('a'),\n    0,\n    Number.NaN,\n    Number.POSITIVE_INFINITY,\n    BigInt(1),\n  ])('returns true when given primitive value of: %s', primitive => {\n    expect(isPrimitive(primitive)).toBe(true);\n  });\n\n  test.each([\n    {},\n    [],\n    () => {},\n    /abc/,\n    new Map(),\n    new Set(),\n    new Date(),\n    Object.create(null),\n  ])('returns false when given non primitive value of: %j', value => {\n    expect(isPrimitive(value)).toBe(false);\n  });\n});\n",
  "packages/jest-get-type/src/__tests__/isPrimitive.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport {};\n",
  "packages/jest-get-type/src/__tests__/getType.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {getType} from '../';\n\ndescribe('.getType()', () => {\n  test('null', () => expect(getType(null)).toBe('null'));\n  test('undefined', () => expect(getType(undefined)).toBe('undefined'));\n  test('object', () => expect(getType({})).toBe('object'));\n  test('array', () => expect(getType([])).toBe('array'));\n  test('number', () => expect(getType(1)).toBe('number'));\n  test('string', () => expect(getType('oi')).toBe('string'));\n  test('function', () => expect(getType(() => {})).toBe('function'));\n  test('boolean', () => expect(getType(true)).toBe('boolean'));\n  test('symbol', () => expect(getType(Symbol.for('a'))).toBe('symbol'));\n  test('regexp', () => expect(getType(/abc/)).toBe('regexp'));\n  test('map', () => expect(getType(new Map())).toBe('map'));\n  test('set', () => expect(getType(new Set())).toBe('set'));\n  test('date', () => expect(getType(new Date())).toBe('date'));\n  test('bigint', () => expect(getType(BigInt(1))).toBe('bigint'));\n});\n",
  "packages/jest-get-type/src/__tests__/getType.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport {};\n",
  "packages/jest-fake-timers/src/modernFakeTimers.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {\n  type FakeTimerWithContext,\n  type FakeMethod as FakeableAPI,\n  type InstalledClock,\n  type FakeTimerInstallOpts as SinonFakeTimersConfig,\n  withGlobal,\n} from '@sinonjs/fake-timers';\nimport type {Config} from '@jest/types';\nimport {formatStackTrace} from 'jest-message-util';\n\nexport default class FakeTimers {\n  private _clock!: InstalledClock;\n  private readonly _config: Config.ProjectConfig;\n  private _fakingTime: boolean;\n  private readonly _global: typeof globalThis;\n  private readonly _fakeTimers: FakeTimerWithContext;\n\n  constructor({\n    global,\n    config,\n  }: {\n    global: typeof globalThis;\n    config: Config.ProjectConfig;\n  }) {\n    this._global = global;\n    this._config = config;\n\n    this._fakingTime = false;\n    this._fakeTimers = withGlobal(global);\n  }\n\n  clearAllTimers(): void {\n    if (this._fakingTime) {\n      this._clock.reset();\n    }\n  }\n\n  dispose(): void {\n    this.useRealTimers();\n  }\n\n  runAllTimers(): void {\n    if (this._checkFakeTimers()) {\n      this._clock.runAll();\n    }\n  }\n\n  async runAllTimersAsync(): Promise<void> {\n    if (this._checkFakeTimers()) {\n      await this._clock.runAllAsync();\n    }\n  }\n\n  runOnlyPendingTimers(): void {\n    if (this._checkFakeTimers()) {\n      this._clock.runToLast();\n    }\n  }\n\n  async runOnlyPendingTimersAsync(): Promise<void> {\n    if (this._checkFakeTimers()) {\n      await this._clock.runToLastAsync();\n    }\n  }\n\n  advanceTimersToNextTimer(steps = 1): void {\n    if (this._checkFakeTimers()) {\n      for (let i = steps; i > 0; i--) {\n        this._clock.next();\n        // Fire all timers at this point: https://github.com/sinonjs/fake-timers/issues/250\n        this._clock.tick(0);\n\n        if (this._clock.countTimers() === 0) {\n          break;\n        }\n      }\n    }\n  }\n\n  async advanceTimersToNextTimerAsync(steps = 1): Promise<void> {\n    if (this._checkFakeTimers()) {\n      for (let i = steps; i > 0; i--) {\n        await this._clock.nextAsync();\n        // Fire all timers at this point: https://github.com/sinonjs/fake-timers/issues/250\n        await this._clock.tickAsync(0);\n\n        if (this._clock.countTimers() === 0) {\n          break;\n        }\n      }\n    }\n  }\n\n  advanceTimersByTime(msToRun: number): void {\n    if (this._checkFakeTimers()) {\n      this._clock.tick(msToRun);\n    }\n  }\n\n  async advanceTimersByTimeAsync(msToRun: number): Promise<void> {\n    if (this._checkFakeTimers()) {\n      await this._clock.tickAsync(msToRun);\n    }\n  }\n\n  advanceTimersToNextFrame(): void {\n    if (this._checkFakeTimers()) {\n      this._clock.runToFrame();\n    }\n  }\n\n  runAllTicks(): void {\n    if (this._checkFakeTimers()) {\n      // @ts-expect-error - doesn't exist?\n      this._clock.runMicrotasks();\n    }\n  }\n\n  useRealTimers(): void {\n    if (this._fakingTime) {\n      this._clock.uninstall();\n      this._fakingTime = false;\n    }\n  }\n\n  useFakeTimers(fakeTimersConfig?: Config.FakeTimersConfig): void {\n    if (this._fakingTime) {\n      this._clock.uninstall();\n    }\n\n    this._clock = this._fakeTimers.install(\n      this._toSinonFakeTimersConfig(fakeTimersConfig),\n    );\n\n    this._fakingTime = true;\n  }\n\n  reset(): void {\n    if (this._checkFakeTimers()) {\n      const {now} = this._clock;\n      this._clock.reset();\n      this._clock.setSystemTime(now);\n    }\n  }\n\n  setSystemTime(now?: number | Date): void {\n    if (this._checkFakeTimers()) {\n      this._clock.setSystemTime(now);\n    }\n  }\n\n  getRealSystemTime(): number {\n    return Date.now();\n  }\n\n  now(): number {\n    if (this._fakingTime) {\n      return this._clock.now;\n    }\n    return Date.now();\n  }\n\n  getTimerCount(): number {\n    if (this._checkFakeTimers()) {\n      return this._clock.countTimers();\n    }\n\n    return 0;\n  }\n\n  private _checkFakeTimers() {\n    if (!this._fakingTime) {\n      this._global.console.warn(\n        'A function to advance timers was called but the timers APIs are not replaced ' +\n          'with fake timers. Call `jest.useFakeTimers()` in this test file or enable ' +\n          \"fake timers for all tests by setting 'fakeTimers': {'enableGlobally': true} \" +\n          `in Jest configuration file.\\nStack Trace:\\n${formatStackTrace(\n            // eslint-disable-next-line unicorn/error-message\n            new Error().stack!,\n            this._config,\n            {noStackTrace: false},\n          )}`,\n      );\n    }\n\n    return this._fakingTime;\n  }\n\n  private _toSinonFakeTimersConfig(\n    fakeTimersConfig: Config.FakeTimersConfig = {},\n  ): SinonFakeTimersConfig {\n    fakeTimersConfig = {\n      ...this._config.fakeTimers,\n      ...fakeTimersConfig,\n    } as Config.FakeTimersConfig;\n\n    const advanceTimeDelta =\n      typeof fakeTimersConfig.advanceTimers === 'number'\n        ? fakeTimersConfig.advanceTimers\n        : undefined;\n\n    const toFake = new Set(\n      Object.keys(this._fakeTimers.timers) as Array<FakeableAPI>,\n    );\n\n    if (fakeTimersConfig.doNotFake)\n      for (const nameOfFakeableAPI of fakeTimersConfig.doNotFake) {\n        toFake.delete(nameOfFakeableAPI);\n      }\n\n    return {\n      advanceTimeDelta,\n      loopLimit: fakeTimersConfig.timerLimit || 100_000,\n      now: fakeTimersConfig.now ?? Date.now(),\n      shouldAdvanceTime: Boolean(fakeTimersConfig.advanceTimers),\n      shouldClearNativeTimers: true,\n      toFake: [...toFake],\n    };\n  }\n}\n",
  "packages/jest-fake-timers/src/modernFakeTimers.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config } from '@jest/types';\nexport default class FakeTimers {\n    private _clock;\n    private readonly _config;\n    private _fakingTime;\n    private readonly _global;\n    private readonly _fakeTimers;\n    constructor({ global, config, }: {\n        global: typeof globalThis;\n        config: Config.ProjectConfig;\n    });\n    clearAllTimers(): void;\n    dispose(): void;\n    runAllTimers(): void;\n    runAllTimersAsync(): Promise<void>;\n    runOnlyPendingTimers(): void;\n    runOnlyPendingTimersAsync(): Promise<void>;\n    advanceTimersToNextTimer(steps?: number): void;\n    advanceTimersToNextTimerAsync(steps?: number): Promise<void>;\n    advanceTimersByTime(msToRun: number): void;\n    advanceTimersByTimeAsync(msToRun: number): Promise<void>;\n    advanceTimersToNextFrame(): void;\n    runAllTicks(): void;\n    useRealTimers(): void;\n    useFakeTimers(fakeTimersConfig?: Config.FakeTimersConfig): void;\n    reset(): void;\n    setSystemTime(now?: number | Date): void;\n    getRealSystemTime(): number;\n    now(): number;\n    getTimerCount(): number;\n    private _checkFakeTimers;\n    private _toSinonFakeTimersConfig;\n}\n",
  "packages/jest-fake-timers/src/legacyFakeTimers.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/* eslint-disable local/prefer-spread-eventually */\n\nimport {promisify} from 'util';\nimport {type StackTraceConfig, formatStackTrace} from 'jest-message-util';\nimport type {\n  FunctionLike,\n  Mock,\n  ModuleMocker,\n  UnknownFunction,\n} from 'jest-mock';\nimport {setGlobal} from 'jest-util';\n\ntype Callback = (...args: Array<unknown>) => void;\n\ntype TimerID = string;\n\ntype Tick = {\n  uuid: string;\n  callback: Callback;\n};\n\ntype Timer = {\n  type: string;\n  callback: Callback;\n  expiry: number;\n  interval?: number;\n};\n\ntype TimerAPI = {\n  cancelAnimationFrame: typeof globalThis.cancelAnimationFrame;\n  clearImmediate: typeof globalThis.clearImmediate;\n  clearInterval: typeof globalThis.clearInterval;\n  clearTimeout: typeof globalThis.clearTimeout;\n  nextTick: typeof process.nextTick;\n  requestAnimationFrame: typeof globalThis.requestAnimationFrame;\n  setImmediate: typeof globalThis.setImmediate;\n  setInterval: typeof globalThis.setInterval;\n  setTimeout: typeof globalThis.setTimeout;\n};\n\ntype FakeTimerAPI = {\n  cancelAnimationFrame: Mock<FakeTimers['_fakeClearTimer']>;\n  clearImmediate: Mock<FakeTimers['_fakeClearImmediate']>;\n  clearInterval: Mock<FakeTimers['_fakeClearTimer']>;\n  clearTimeout: Mock<FakeTimers['_fakeClearTimer']>;\n  nextTick: Mock<FakeTimers['_fakeNextTick']>;\n  requestAnimationFrame: Mock<FakeTimers['_fakeRequestAnimationFrame']>;\n  setImmediate: Mock<FakeTimers['_fakeSetImmediate']>;\n  setInterval: Mock<FakeTimers['_fakeSetInterval']>;\n  setTimeout: Mock<FakeTimers['_fakeSetTimeout']>;\n};\n\ntype TimerConfig<Ref> = {\n  idToRef: (id: number) => Ref;\n  refToId: (ref: Ref) => number | void;\n};\n\nconst MS_IN_A_YEAR = 31_536_000_000;\n\nexport default class FakeTimers<TimerRef = unknown> {\n  private _cancelledTicks!: Record<string, boolean>;\n  private readonly _config: StackTraceConfig;\n  private _disposed: boolean;\n  private _fakeTimerAPIs!: FakeTimerAPI;\n  private _fakingTime = false;\n  private readonly _global: typeof globalThis;\n  private _immediates!: Array<Tick>;\n  private readonly _maxLoops: number;\n  private readonly _moduleMocker: ModuleMocker;\n  private _now!: number;\n  private _ticks!: Array<Tick>;\n  private readonly _timerAPIs: TimerAPI;\n  private _timers!: Map<string, Timer>;\n  private _uuidCounter: number;\n  private readonly _timerConfig: TimerConfig<TimerRef>;\n\n  constructor({\n    global,\n    moduleMocker,\n    timerConfig,\n    config,\n    maxLoops,\n  }: {\n    global: typeof globalThis;\n    moduleMocker: ModuleMocker;\n    timerConfig: TimerConfig<TimerRef>;\n    config: StackTraceConfig;\n    maxLoops?: number;\n  }) {\n    this._global = global;\n    this._timerConfig = timerConfig;\n    this._config = config;\n    this._maxLoops = maxLoops || 100_000;\n    this._uuidCounter = 1;\n    this._moduleMocker = moduleMocker;\n\n    // Store original timer APIs for future reference\n    this._timerAPIs = {\n      cancelAnimationFrame: global.cancelAnimationFrame,\n      clearImmediate: global.clearImmediate,\n      clearInterval: global.clearInterval,\n      clearTimeout: global.clearTimeout,\n      nextTick: global.process && global.process.nextTick,\n      requestAnimationFrame: global.requestAnimationFrame,\n      setImmediate: global.setImmediate,\n      setInterval: global.setInterval,\n      setTimeout: global.setTimeout,\n    };\n\n    this._disposed = false;\n\n    this.reset();\n  }\n\n  clearAllTimers(): void {\n    this._immediates = [];\n    this._timers.clear();\n  }\n\n  dispose(): void {\n    this._disposed = true;\n    this.clearAllTimers();\n  }\n\n  reset(): void {\n    this._cancelledTicks = {};\n    this._now = 0;\n    this._ticks = [];\n    this._immediates = [];\n    this._timers = new Map();\n  }\n\n  now(): number {\n    if (this._fakingTime) {\n      return this._now;\n    }\n    return Date.now();\n  }\n\n  runAllTicks(): void {\n    this._checkFakeTimers();\n    // Only run a generous number of ticks and then bail.\n    // This is just to help avoid recursive loops\n    let i;\n    for (i = 0; i < this._maxLoops; i++) {\n      const tick = this._ticks.shift();\n\n      if (tick === undefined) {\n        break;\n      }\n\n      if (\n        !Object.prototype.hasOwnProperty.call(this._cancelledTicks, tick.uuid)\n      ) {\n        // Callback may throw, so update the map prior calling.\n        this._cancelledTicks[tick.uuid] = true;\n        tick.callback();\n      }\n    }\n\n    if (i === this._maxLoops) {\n      throw new Error(\n        `Ran ${this._maxLoops} ticks, and there are still more! ` +\n          \"Assuming we've hit an infinite recursion and bailing out...\",\n      );\n    }\n  }\n\n  runAllImmediates(): void {\n    this._checkFakeTimers();\n    // Only run a generous number of immediates and then bail.\n    let i;\n    for (i = 0; i < this._maxLoops; i++) {\n      const immediate = this._immediates.shift();\n      if (immediate === undefined) {\n        break;\n      }\n      this._runImmediate(immediate);\n    }\n\n    if (i === this._maxLoops) {\n      throw new Error(\n        `Ran ${this._maxLoops} immediates, and there are still more! Assuming ` +\n          \"we've hit an infinite recursion and bailing out...\",\n      );\n    }\n  }\n\n  private _runImmediate(immediate: Tick) {\n    try {\n      immediate.callback();\n    } finally {\n      this._fakeClearImmediate(immediate.uuid);\n    }\n  }\n\n  runAllTimers(): void {\n    this._checkFakeTimers();\n    this.runAllTicks();\n    this.runAllImmediates();\n\n    // Only run a generous number of timers and then bail.\n    // This is just to help avoid recursive loops\n    let i;\n    for (i = 0; i < this._maxLoops; i++) {\n      const nextTimerHandleAndExpiry = this._getNextTimerHandleAndExpiry();\n\n      // If there are no more timer handles, stop!\n      if (nextTimerHandleAndExpiry === null) {\n        break;\n      }\n\n      const [nextTimerHandle, expiry] = nextTimerHandleAndExpiry;\n      this._now = expiry;\n      this._runTimerHandle(nextTimerHandle);\n\n      // Some of the immediate calls could be enqueued\n      // during the previous handling of the timers, we should\n      // run them as well.\n      if (this._immediates.length > 0) {\n        this.runAllImmediates();\n      }\n\n      if (this._ticks.length > 0) {\n        this.runAllTicks();\n      }\n    }\n\n    if (i === this._maxLoops) {\n      throw new Error(\n        `Ran ${this._maxLoops} timers, and there are still more! ` +\n          \"Assuming we've hit an infinite recursion and bailing out...\",\n      );\n    }\n  }\n\n  runOnlyPendingTimers(): void {\n    // We need to hold the current shape of `this._timers` because existing\n    // timers can add new ones to the map and hence would run more than necessary.\n    // See https://github.com/jestjs/jest/pull/4608 for details\n    const timerEntries = [...this._timers.entries()];\n    this._checkFakeTimers();\n    for (const _immediate of this._immediates) this._runImmediate(_immediate);\n\n    for (const [timerHandle, timer] of timerEntries.sort(\n      ([, left], [, right]) => left.expiry - right.expiry,\n    )) {\n      this._now = timer.expiry;\n      this._runTimerHandle(timerHandle);\n    }\n  }\n\n  advanceTimersToNextTimer(steps = 1): void {\n    if (steps < 1) {\n      return;\n    }\n    const nextExpiry = [...this._timers.values()].reduce(\n      (minExpiry: number | null, timer: Timer): number => {\n        if (minExpiry === null || timer.expiry < minExpiry) return timer.expiry;\n        return minExpiry;\n      },\n      null,\n    );\n    if (nextExpiry !== null) {\n      this.advanceTimersByTime(nextExpiry - this._now);\n      this.advanceTimersToNextTimer(steps - 1);\n    }\n  }\n\n  advanceTimersByTime(msToRun: number): void {\n    this._checkFakeTimers();\n    // Only run a generous number of timers and then bail.\n    // This is just to help avoid recursive loops\n    let i;\n    for (i = 0; i < this._maxLoops; i++) {\n      const timerHandleAndExpiry = this._getNextTimerHandleAndExpiry();\n\n      // If there are no more timer handles, stop!\n      if (timerHandleAndExpiry === null) {\n        break;\n      }\n      const [timerHandle, nextTimerExpiry] = timerHandleAndExpiry;\n\n      if (this._now + msToRun < nextTimerExpiry) {\n        // There are no timers between now and the target we're running to\n        break;\n      } else {\n        msToRun -= nextTimerExpiry - this._now;\n        this._now = nextTimerExpiry;\n        this._runTimerHandle(timerHandle);\n      }\n    }\n\n    // Advance the clock by whatever time we still have left to run\n    this._now += msToRun;\n\n    if (i === this._maxLoops) {\n      throw new Error(\n        `Ran ${this._maxLoops} timers, and there are still more! ` +\n          \"Assuming we've hit an infinite recursion and bailing out...\",\n      );\n    }\n  }\n\n  runWithRealTimers(cb: Callback): void {\n    const prevClearImmediate = this._global.clearImmediate;\n    const prevClearInterval = this._global.clearInterval;\n    const prevClearTimeout = this._global.clearTimeout;\n    const prevNextTick = this._global.process.nextTick;\n    const prevSetImmediate = this._global.setImmediate;\n    const prevSetInterval = this._global.setInterval;\n    const prevSetTimeout = this._global.setTimeout;\n\n    this.useRealTimers();\n\n    let cbErr = null;\n    let errThrown = false;\n    try {\n      cb();\n    } catch (error) {\n      errThrown = true;\n      cbErr = error;\n    }\n\n    this._global.clearImmediate = prevClearImmediate;\n    this._global.clearInterval = prevClearInterval;\n    this._global.clearTimeout = prevClearTimeout;\n    this._global.process.nextTick = prevNextTick;\n    this._global.setImmediate = prevSetImmediate;\n    this._global.setInterval = prevSetInterval;\n    this._global.setTimeout = prevSetTimeout;\n\n    if (errThrown) {\n      throw cbErr;\n    }\n  }\n\n  useRealTimers(): void {\n    const global = this._global;\n\n    if (typeof global.cancelAnimationFrame === 'function') {\n      setGlobal(\n        global,\n        'cancelAnimationFrame',\n        this._timerAPIs.cancelAnimationFrame,\n      );\n    }\n    if (typeof global.clearImmediate === 'function') {\n      setGlobal(global, 'clearImmediate', this._timerAPIs.clearImmediate);\n    }\n    setGlobal(global, 'clearInterval', this._timerAPIs.clearInterval);\n    setGlobal(global, 'clearTimeout', this._timerAPIs.clearTimeout);\n    if (typeof global.requestAnimationFrame === 'function') {\n      setGlobal(\n        global,\n        'requestAnimationFrame',\n        this._timerAPIs.requestAnimationFrame,\n      );\n    }\n    if (typeof global.setImmediate === 'function') {\n      setGlobal(global, 'setImmediate', this._timerAPIs.setImmediate);\n    }\n    setGlobal(global, 'setInterval', this._timerAPIs.setInterval);\n    setGlobal(global, 'setTimeout', this._timerAPIs.setTimeout);\n\n    global.process.nextTick = this._timerAPIs.nextTick;\n\n    this._fakingTime = false;\n  }\n\n  useFakeTimers(): void {\n    this._createMocks();\n\n    const global = this._global;\n    if (typeof global.cancelAnimationFrame === 'function') {\n      setGlobal(\n        global,\n        'cancelAnimationFrame',\n        this._fakeTimerAPIs.cancelAnimationFrame,\n      );\n    }\n    if (typeof global.clearImmediate === 'function') {\n      setGlobal(global, 'clearImmediate', this._fakeTimerAPIs.clearImmediate);\n    }\n    setGlobal(global, 'clearInterval', this._fakeTimerAPIs.clearInterval);\n    setGlobal(global, 'clearTimeout', this._fakeTimerAPIs.clearTimeout);\n    if (typeof global.requestAnimationFrame === 'function') {\n      setGlobal(\n        global,\n        'requestAnimationFrame',\n        this._fakeTimerAPIs.requestAnimationFrame,\n      );\n    }\n    if (typeof global.setImmediate === 'function') {\n      setGlobal(global, 'setImmediate', this._fakeTimerAPIs.setImmediate);\n    }\n    setGlobal(global, 'setInterval', this._fakeTimerAPIs.setInterval);\n    setGlobal(global, 'setTimeout', this._fakeTimerAPIs.setTimeout);\n\n    global.process.nextTick = this._fakeTimerAPIs.nextTick;\n\n    this._fakingTime = true;\n  }\n\n  getTimerCount(): number {\n    this._checkFakeTimers();\n\n    return this._timers.size + this._immediates.length + this._ticks.length;\n  }\n\n  private _checkFakeTimers() {\n    if (!this._fakingTime) {\n      this._global.console.warn(\n        'A function to advance timers was called but the timers APIs are not mocked ' +\n          'with fake timers. Call `jest.useFakeTimers({legacyFakeTimers: true})` ' +\n          'in this test file or enable fake timers for all tests by setting ' +\n          \"{'enableGlobally': true, 'legacyFakeTimers': true} in \" +\n          `Jest configuration file.\\nStack Trace:\\n${formatStackTrace(\n            // eslint-disable-next-line unicorn/error-message\n            new Error().stack!,\n            this._config,\n            {noStackTrace: false},\n          )}`,\n      );\n    }\n  }\n\n  #createMockFunction<T extends FunctionLike = UnknownFunction>(\n    implementation: T,\n  ) {\n    return this._moduleMocker.fn(implementation.bind(this));\n  }\n\n  private _createMocks() {\n    const promisifiableFakeSetTimeout = this.#createMockFunction(\n      this._fakeSetTimeout,\n    );\n    // @ts-expect-error: no index\n    promisifiableFakeSetTimeout[promisify.custom] = (\n      delay?: number,\n      arg?: unknown,\n    ) =>\n      new Promise(resolve => promisifiableFakeSetTimeout(resolve, delay, arg));\n\n    this._fakeTimerAPIs = {\n      cancelAnimationFrame: this.#createMockFunction(this._fakeClearTimer),\n      clearImmediate: this.#createMockFunction(this._fakeClearImmediate),\n      clearInterval: this.#createMockFunction(this._fakeClearTimer),\n      clearTimeout: this.#createMockFunction(this._fakeClearTimer),\n      nextTick: this.#createMockFunction(this._fakeNextTick),\n      requestAnimationFrame: this.#createMockFunction(\n        this._fakeRequestAnimationFrame,\n      ),\n      setImmediate: this.#createMockFunction(this._fakeSetImmediate),\n      setInterval: this.#createMockFunction(this._fakeSetInterval),\n      setTimeout: promisifiableFakeSetTimeout,\n    };\n  }\n\n  private _fakeClearTimer(timerRef: TimerRef) {\n    const uuid = this._timerConfig.refToId(timerRef);\n\n    if (uuid) {\n      this._timers.delete(String(uuid));\n    }\n  }\n\n  private _fakeClearImmediate(uuid: TimerID) {\n    this._immediates = this._immediates.filter(\n      immediate => immediate.uuid !== uuid,\n    );\n  }\n\n  private _fakeNextTick(callback: Callback, ...args: Array<unknown>) {\n    if (this._disposed) {\n      return;\n    }\n\n    const uuid = String(this._uuidCounter++);\n\n    this._ticks.push({\n      callback: () => callback.apply(null, args),\n      uuid,\n    });\n\n    const cancelledTicks = this._cancelledTicks;\n    this._timerAPIs.nextTick(() => {\n      if (!Object.prototype.hasOwnProperty.call(cancelledTicks, uuid)) {\n        // Callback may throw, so update the map prior calling.\n        cancelledTicks[uuid] = true;\n        callback.apply(null, args);\n      }\n    });\n  }\n\n  private _fakeRequestAnimationFrame(callback: Callback) {\n    return this._fakeSetTimeout(() => {\n      // TODO: Use performance.now() once it's mocked\n      callback(this._now);\n    }, 1000 / 60);\n  }\n\n  private _fakeSetImmediate(callback: Callback, ...args: Array<unknown>) {\n    if (this._disposed) {\n      return null;\n    }\n\n    const uuid = String(this._uuidCounter++);\n\n    this._immediates.push({\n      callback: () => callback.apply(null, args),\n      uuid,\n    });\n\n    this._timerAPIs.setImmediate(() => {\n      if (!this._disposed) {\n        if (this._immediates.some(x => x.uuid === uuid)) {\n          try {\n            callback.apply(null, args);\n          } finally {\n            this._fakeClearImmediate(uuid);\n          }\n        }\n      }\n    });\n\n    return uuid;\n  }\n\n  private _fakeSetInterval(\n    callback: Callback,\n    intervalDelay?: number,\n    ...args: Array<unknown>\n  ) {\n    if (this._disposed) {\n      return null;\n    }\n\n    if (intervalDelay == null) {\n      intervalDelay = 0;\n    }\n\n    const uuid = this._uuidCounter++;\n\n    this._timers.set(String(uuid), {\n      callback: () => callback.apply(null, args),\n      expiry: this._now + intervalDelay,\n      interval: intervalDelay,\n      type: 'interval',\n    });\n\n    return this._timerConfig.idToRef(uuid);\n  }\n\n  private _fakeSetTimeout(\n    callback: Callback,\n    delay?: number,\n    ...args: Array<unknown>\n  ) {\n    if (this._disposed) {\n      return null;\n    }\n\n    // eslint-disable-next-line no-bitwise,unicorn/prefer-math-trunc\n    delay = Number(delay) | 0;\n\n    const uuid = this._uuidCounter++;\n\n    this._timers.set(String(uuid), {\n      callback: () => callback.apply(null, args),\n      expiry: this._now + delay,\n      interval: undefined,\n      type: 'timeout',\n    });\n\n    return this._timerConfig.idToRef(uuid);\n  }\n\n  private _getNextTimerHandleAndExpiry(): [string, number] | null {\n    let nextTimerHandle = null;\n    let soonestTime = MS_IN_A_YEAR;\n\n    for (const [uuid, timer] of this._timers.entries()) {\n      if (timer.expiry < soonestTime) {\n        soonestTime = timer.expiry;\n        nextTimerHandle = uuid;\n      }\n    }\n\n    if (nextTimerHandle === null) {\n      return null;\n    }\n\n    return [nextTimerHandle, soonestTime];\n  }\n\n  private _runTimerHandle(timerHandle: TimerID) {\n    const timer = this._timers.get(timerHandle);\n\n    if (!timer) {\n      // Timer has been cleared - we'll hit this when a timer is cleared within\n      // another timer in runOnlyPendingTimers\n      return;\n    }\n\n    switch (timer.type) {\n      case 'timeout':\n        this._timers.delete(timerHandle);\n        timer.callback();\n        break;\n\n      case 'interval':\n        timer.expiry = this._now + (timer.interval || 0);\n        timer.callback();\n        break;\n\n      default:\n        throw new Error(`Unexpected timer type: ${timer.type}`);\n    }\n  }\n}\n",
  "packages/jest-fake-timers/src/legacyFakeTimers.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { type StackTraceConfig } from 'jest-message-util';\nimport type { ModuleMocker } from 'jest-mock';\ntype Callback = (...args: Array<unknown>) => void;\ntype TimerConfig<Ref> = {\n    idToRef: (id: number) => Ref;\n    refToId: (ref: Ref) => number | void;\n};\nexport default class FakeTimers<TimerRef = unknown> {\n    #private;\n    private _cancelledTicks;\n    private readonly _config;\n    private _disposed;\n    private _fakeTimerAPIs;\n    private _fakingTime;\n    private readonly _global;\n    private _immediates;\n    private readonly _maxLoops;\n    private readonly _moduleMocker;\n    private _now;\n    private _ticks;\n    private readonly _timerAPIs;\n    private _timers;\n    private _uuidCounter;\n    private readonly _timerConfig;\n    constructor({ global, moduleMocker, timerConfig, config, maxLoops, }: {\n        global: typeof globalThis;\n        moduleMocker: ModuleMocker;\n        timerConfig: TimerConfig<TimerRef>;\n        config: StackTraceConfig;\n        maxLoops?: number;\n    });\n    clearAllTimers(): void;\n    dispose(): void;\n    reset(): void;\n    now(): number;\n    runAllTicks(): void;\n    runAllImmediates(): void;\n    private _runImmediate;\n    runAllTimers(): void;\n    runOnlyPendingTimers(): void;\n    advanceTimersToNextTimer(steps?: number): void;\n    advanceTimersByTime(msToRun: number): void;\n    runWithRealTimers(cb: Callback): void;\n    useRealTimers(): void;\n    useFakeTimers(): void;\n    getTimerCount(): number;\n    private _checkFakeTimers;\n    private _createMocks;\n    private _fakeClearTimer;\n    private _fakeClearImmediate;\n    private _fakeNextTick;\n    private _fakeRequestAnimationFrame;\n    private _fakeSetImmediate;\n    private _fakeSetInterval;\n    private _fakeSetTimeout;\n    private _getNextTimerHandleAndExpiry;\n    private _runTimerHandle;\n}\nexport {};\n",
  "packages/jest-fake-timers/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nexport {default as LegacyFakeTimers} from './legacyFakeTimers';\nexport {default as ModernFakeTimers} from './modernFakeTimers';\n",
  "packages/jest-fake-timers/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport { default as LegacyFakeTimers } from './legacyFakeTimers';\nexport { default as ModernFakeTimers } from './modernFakeTimers';\n",
  "packages/jest-fake-timers/src/__tests__/sinon-integration.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {makeProjectConfig} from '@jest/test-utils';\nimport FakeTimers from '../modernFakeTimers';\n\njest.spyOn(Date, 'now').mockImplementation(() => 123_456);\n\nconst mockInstall = jest.fn();\n\nconst mockWithGlobal = {\n  install: mockInstall,\n  timers: {\n    Date: jest.fn(),\n    cancelAnimationFrame: jest.fn(),\n    clearImmediate: jest.fn(),\n    clearInterval: jest.fn(),\n    clearTimeout: jest.fn(),\n    hrtime: jest.fn(),\n    nextTick: jest.fn(),\n    performance: jest.fn(),\n    queueMicrotask: jest.fn(),\n    requestAnimationFrame: jest.fn(),\n    setImmediate: jest.fn(),\n    setInterval: jest.fn(),\n    setTimeout: jest.fn(),\n  },\n};\n\njest.mock('@sinonjs/fake-timers', () => {\n  return {\n    withGlobal: jest.fn(() => mockWithGlobal),\n  };\n});\n\nafterEach(() => {\n  jest.clearAllMocks();\n});\n\ndescribe('`@sinonjs/fake-timers` integration', () => {\n  test('uses default global config, when `useFakeTimers()` is called without options', () => {\n    const timers = new FakeTimers({\n      config: makeProjectConfig(),\n      global: globalThis,\n    });\n\n    timers.useFakeTimers();\n\n    expect(mockInstall).toHaveBeenCalledWith({\n      advanceTimeDelta: undefined,\n      loopLimit: 100_000,\n      now: 123_456,\n      shouldAdvanceTime: false,\n      shouldClearNativeTimers: true,\n      toFake: [\n        'Date',\n        'cancelAnimationFrame',\n        'clearImmediate',\n        'clearInterval',\n        'clearTimeout',\n        'hrtime',\n        'nextTick',\n        'performance',\n        'queueMicrotask',\n        'requestAnimationFrame',\n        'setImmediate',\n        'setInterval',\n        'setTimeout',\n      ],\n    });\n  });\n\n  test('uses custom global config, when `useFakeTimers()` is called without options', () => {\n    const timers = new FakeTimers({\n      config: makeProjectConfig({\n        fakeTimers: {\n          advanceTimers: true,\n          doNotFake: ['Date', 'nextTick'],\n          now: 0,\n          timerLimit: 100,\n        },\n      }),\n      global: globalThis,\n    });\n\n    timers.useFakeTimers();\n\n    expect(mockInstall).toHaveBeenCalledWith({\n      advanceTimeDelta: undefined,\n      loopLimit: 100,\n      now: 0,\n      shouldAdvanceTime: true,\n      shouldClearNativeTimers: true,\n      toFake: [\n        'cancelAnimationFrame',\n        'clearImmediate',\n        'clearInterval',\n        'clearTimeout',\n        'hrtime',\n        'performance',\n        'queueMicrotask',\n        'requestAnimationFrame',\n        'setImmediate',\n        'setInterval',\n        'setTimeout',\n      ],\n    });\n  });\n\n  test('overrides default global config, when `useFakeTimers()` is called with options,', () => {\n    const timers = new FakeTimers({\n      config: makeProjectConfig(),\n      global: globalThis,\n    });\n\n    timers.useFakeTimers({\n      advanceTimers: 40,\n      doNotFake: ['Date', 'queueMicrotask'],\n      now: new Date('1995-12-17'),\n      timerLimit: 2000,\n    });\n\n    expect(mockInstall).toHaveBeenCalledWith({\n      advanceTimeDelta: 40,\n      loopLimit: 2000,\n      now: new Date('1995-12-17'),\n      shouldAdvanceTime: true,\n      shouldClearNativeTimers: true,\n      toFake: [\n        'cancelAnimationFrame',\n        'clearImmediate',\n        'clearInterval',\n        'clearTimeout',\n        'hrtime',\n        'nextTick',\n        'performance',\n        'requestAnimationFrame',\n        'setImmediate',\n        'setInterval',\n        'setTimeout',\n      ],\n    });\n  });\n\n  test('overrides custom global config, when `useFakeTimers()` is called with options,', () => {\n    const timers = new FakeTimers({\n      config: makeProjectConfig({\n        fakeTimers: {\n          advanceTimers: 20,\n          doNotFake: ['Date', 'nextTick'],\n          now: 0,\n          timerLimit: 1000,\n        },\n      }),\n      global: globalThis,\n    });\n\n    timers.useFakeTimers({\n      advanceTimers: false,\n      doNotFake: ['hrtime'],\n      now: 123_456,\n    });\n\n    expect(mockInstall).toHaveBeenCalledWith({\n      advanceTimeDelta: undefined,\n      loopLimit: 1000,\n      now: 123_456,\n      shouldAdvanceTime: false,\n      shouldClearNativeTimers: true,\n      toFake: [\n        'Date',\n        'cancelAnimationFrame',\n        'clearImmediate',\n        'clearInterval',\n        'clearTimeout',\n        'nextTick',\n        'performance',\n        'queueMicrotask',\n        'requestAnimationFrame',\n        'setImmediate',\n        'setInterval',\n        'setTimeout',\n      ],\n    });\n  });\n});\n",
  "packages/jest-fake-timers/src/__tests__/sinon-integration.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport {};\n",
  "packages/jest-fake-timers/src/__tests__/modernFakeTimers.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {makeProjectConfig} from '@jest/test-utils';\nimport FakeTimers from '../modernFakeTimers';\n\ndescribe('FakeTimers', () => {\n  describe('construction', () => {\n    it('installs setTimeout mock', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n      expect(global.setTimeout).toBeDefined();\n    });\n\n    it('installs clearTimeout mock', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n      expect(global.clearTimeout).toBeDefined();\n    });\n\n    it('installs setInterval mock', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n      expect(global.setInterval).toBeDefined();\n    });\n\n    it('installs clearInterval mock', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n      expect(global.clearInterval).toBeDefined();\n    });\n\n    it('mocks process.nextTick if it exists on global', () => {\n      const origNextTick = () => {};\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process: {\n          nextTick: origNextTick,\n        },\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n      expect(global.process.nextTick).not.toBe(origNextTick);\n    });\n\n    it('mocks setImmediate if it exists on global', () => {\n      const origSetImmediate = () => {};\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setImmediate: origSetImmediate,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n      expect(global.setImmediate).not.toBe(origSetImmediate);\n    });\n\n    it('mocks clearImmediate if setImmediate is on global', () => {\n      const origSetImmediate = () => {};\n      const origClearImmediate = () => {};\n      const global = {\n        Date,\n        clearImmediate: origClearImmediate,\n        clearInterval,\n        clearTimeout,\n        process,\n        setImmediate: origSetImmediate,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n      expect(global.clearImmediate).not.toBe(origClearImmediate);\n    });\n\n    it('mocks requestAnimationFrame if it exists on global', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        requestAnimationFrame: () => -1,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n      expect(global.requestAnimationFrame).toBeDefined();\n    });\n\n    it('mocks cancelAnimationFrame if it exists on global', () => {\n      const global = {\n        Date,\n        cancelAnimationFrame: () => {},\n        clearInterval,\n        clearTimeout,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n      expect(global.cancelAnimationFrame).toBeDefined();\n    });\n  });\n\n  describe('runAllTicks', () => {\n    it('runs all ticks, in order', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process: {\n          nextTick: () => {},\n        },\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      const runOrder: Array<string> = [];\n      const mock1 = jest.fn(() => runOrder.push('mock1'));\n      const mock2 = jest.fn(() => runOrder.push('mock2'));\n\n      global.process.nextTick(mock1);\n      global.process.nextTick(mock2);\n\n      expect(mock1).toHaveBeenCalledTimes(0);\n      expect(mock2).toHaveBeenCalledTimes(0);\n\n      timers.runAllTicks();\n\n      expect(mock1).toHaveBeenCalledTimes(1);\n      expect(mock2).toHaveBeenCalledTimes(1);\n      expect(runOrder).toEqual(['mock1', 'mock2']);\n    });\n\n    it('does nothing when no ticks have been scheduled', () => {\n      const nextTick = jest.fn();\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process: {\n          nextTick,\n        },\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n      timers.runAllTicks();\n\n      expect(nextTick).toHaveBeenCalledTimes(0);\n    });\n\n    it('only runs a scheduled callback once', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process: {\n          nextTick: () => {},\n        },\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      const mock1 = jest.fn();\n      global.process.nextTick(mock1);\n      expect(mock1).toHaveBeenCalledTimes(0);\n\n      timers.runAllTicks();\n      expect(mock1).toHaveBeenCalledTimes(1);\n\n      timers.runAllTicks();\n      expect(mock1).toHaveBeenCalledTimes(1);\n    });\n\n    it('throws before allowing infinite recursion', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process: {\n          nextTick: () => {},\n        },\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({\n        config: makeProjectConfig({fakeTimers: {timerLimit: 100}}),\n        global,\n      });\n\n      timers.useFakeTimers();\n\n      global.process.nextTick(function infinitelyRecursingCallback() {\n        global.process.nextTick(infinitelyRecursingCallback);\n      });\n\n      expect(() => {\n        timers.runAllTicks();\n      }).toThrow(\n        'Aborting after running 100 timers, assuming an infinite loop!',\n      );\n    });\n  });\n\n  describe('runAllTimers', () => {\n    it('runs all timers in order', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      const runOrder: Array<string> = [];\n      const mock1 = jest.fn(() => runOrder.push('mock1'));\n      const mock2 = jest.fn(() => runOrder.push('mock2'));\n      const mock3 = jest.fn(() => runOrder.push('mock3'));\n      const mock4 = jest.fn(() => runOrder.push('mock4'));\n      const mock5 = jest.fn(() => runOrder.push('mock5'));\n      const mock6 = jest.fn(() => runOrder.push('mock6'));\n\n      global.setTimeout(mock1, 100);\n      global.setTimeout(mock2, Number.NaN);\n      global.setTimeout(mock3, 0);\n      const intervalHandler = global.setInterval(() => {\n        mock4();\n        global.clearInterval(intervalHandler);\n      }, 200);\n      global.setTimeout(mock5, Number.POSITIVE_INFINITY);\n      global.setTimeout(mock6, Number.NEGATIVE_INFINITY);\n\n      timers.runAllTimers();\n      expect(runOrder).toEqual([\n        'mock2',\n        'mock3',\n        'mock5',\n        'mock6',\n        'mock1',\n        'mock4',\n      ]);\n    });\n\n    it('warns when trying to advance timers while real timers are used', () => {\n      const consoleWarnSpy = jest\n        .spyOn(console, 'warn')\n        .mockImplementation(() => {\n          // nothing\n        });\n      const timers = new FakeTimers({\n        config: makeProjectConfig({rootDir: __dirname}),\n        global: globalThis,\n      });\n      timers.runAllTimers();\n      expect(\n        consoleWarnSpy.mock.calls[0][0].split('\\nStack Trace')[0],\n      ).toMatchSnapshot();\n      consoleWarnSpy.mockRestore();\n      timers.useRealTimers();\n    });\n\n    it('does nothing when no timers have been scheduled', () => {\n      const nativeSetTimeout = jest.fn();\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval: nativeSetTimeout,\n        setTimeout: nativeSetTimeout,\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n      timers.runAllTimers();\n    });\n\n    it('only runs a setTimeout callback once (ever)', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      const fn = jest.fn();\n      global.setTimeout(fn, 0);\n      expect(fn).toHaveBeenCalledTimes(0);\n\n      timers.runAllTimers();\n      expect(fn).toHaveBeenCalledTimes(1);\n\n      timers.runAllTimers();\n      expect(fn).toHaveBeenCalledTimes(1);\n    });\n\n    it('runs callbacks with arguments after the interval', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      const fn = jest.fn();\n      global.setTimeout(fn, 0, 'mockArg1', 'mockArg2');\n\n      timers.runAllTimers();\n      expect(fn).toHaveBeenCalledTimes(1);\n      expect(fn).toHaveBeenCalledWith('mockArg1', 'mockArg2');\n    });\n\n    it(\"doesn't pass the callback to native setTimeout\", () => {\n      const nativeSetTimeout = jest.fn();\n\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval: nativeSetTimeout,\n        setTimeout: nativeSetTimeout,\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      // @sinonjs/fake-timers uses `setTimeout` during init to figure out if it's in Node or\n      // browser env. So clear its calls before we install them into the env\n      nativeSetTimeout.mockClear();\n      timers.useFakeTimers();\n\n      const mock1 = jest.fn();\n      global.setTimeout(mock1, 0);\n\n      timers.runAllTimers();\n      expect(mock1).toHaveBeenCalledTimes(1);\n      expect(nativeSetTimeout).toHaveBeenCalledTimes(0);\n    });\n\n    it('throws before allowing infinite recursion', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config: makeProjectConfig({fakeTimers: {timerLimit: 1000}}),\n        global,\n      });\n      timers.useFakeTimers();\n\n      global.setTimeout(function infinitelyRecursingCallback() {\n        global.setTimeout(infinitelyRecursingCallback, 0);\n      }, 0);\n\n      expect(() => {\n        timers.runAllTimers();\n      }).toThrow(\n        new Error(\n          'Aborting after running 1000 timers, assuming an infinite loop!',\n        ),\n      );\n    });\n\n    it('also clears ticks', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      const fn = jest.fn();\n      global.setTimeout(() => {\n        process.nextTick(fn);\n      }, 0);\n      expect(fn).toHaveBeenCalledTimes(0);\n\n      timers.runAllTimers();\n      expect(fn).toHaveBeenCalledTimes(1);\n    });\n  });\n\n  describe('advanceTimersByTime', () => {\n    it('runs timers in order', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      const runOrder: Array<string> = [];\n      const mock1 = jest.fn(() => runOrder.push('mock1'));\n      const mock2 = jest.fn(() => runOrder.push('mock2'));\n      const mock3 = jest.fn(() => runOrder.push('mock3'));\n      const mock4 = jest.fn(() => runOrder.push('mock4'));\n\n      global.setTimeout(mock1, 100);\n      global.setTimeout(mock2, 0);\n      global.setTimeout(mock3, 0);\n      global.setInterval(() => {\n        mock4();\n      }, 200);\n\n      // Move forward to t=50\n      timers.advanceTimersByTime(50);\n      expect(runOrder).toEqual(['mock2', 'mock3']);\n\n      // Move forward to t=60\n      timers.advanceTimersByTime(10);\n      expect(runOrder).toEqual(['mock2', 'mock3']);\n\n      // Move forward to t=100\n      timers.advanceTimersByTime(40);\n      expect(runOrder).toEqual(['mock2', 'mock3', 'mock1']);\n\n      // Move forward to t=200\n      timers.advanceTimersByTime(100);\n      expect(runOrder).toEqual(['mock2', 'mock3', 'mock1', 'mock4']);\n\n      // Move forward to t=400\n      timers.advanceTimersByTime(200);\n      expect(runOrder).toEqual(['mock2', 'mock3', 'mock1', 'mock4', 'mock4']);\n    });\n\n    it('does nothing when no timers have been scheduled', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      timers.advanceTimersByTime(100);\n    });\n  });\n\n  describe('advanceTimersToNextTimer', () => {\n    it('runs timers in order', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      const runOrder: Array<string> = [];\n      const mock1 = jest.fn(() => runOrder.push('mock1'));\n      const mock2 = jest.fn(() => runOrder.push('mock2'));\n      const mock3 = jest.fn(() => runOrder.push('mock3'));\n      const mock4 = jest.fn(() => runOrder.push('mock4'));\n\n      global.setTimeout(mock1, 100);\n      global.setTimeout(mock2, 0);\n      global.setTimeout(mock3, 0);\n      global.setInterval(() => {\n        mock4();\n      }, 200);\n\n      timers.advanceTimersToNextTimer();\n      // Move forward to t=0\n      expect(runOrder).toEqual(['mock2', 'mock3']);\n\n      timers.advanceTimersToNextTimer();\n      // Move forward to t=100\n      expect(runOrder).toEqual(['mock2', 'mock3', 'mock1']);\n\n      timers.advanceTimersToNextTimer();\n      // Move forward to t=200\n      expect(runOrder).toEqual(['mock2', 'mock3', 'mock1', 'mock4']);\n\n      timers.advanceTimersToNextTimer();\n      // Move forward to t=400\n      expect(runOrder).toEqual(['mock2', 'mock3', 'mock1', 'mock4', 'mock4']);\n    });\n\n    it('run correct amount of steps', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      const runOrder: Array<string> = [];\n      const mock1 = jest.fn(() => runOrder.push('mock1'));\n      const mock2 = jest.fn(() => runOrder.push('mock2'));\n      const mock3 = jest.fn(() => runOrder.push('mock3'));\n      const mock4 = jest.fn(() => runOrder.push('mock4'));\n\n      global.setTimeout(mock1, 100);\n      global.setTimeout(mock2, 0);\n      global.setTimeout(mock3, 0);\n      global.setInterval(() => {\n        mock4();\n      }, 200);\n\n      // Move forward to t=100\n      timers.advanceTimersToNextTimer(2);\n      expect(runOrder).toEqual(['mock2', 'mock3', 'mock1']);\n\n      // Move forward to t=600\n      timers.advanceTimersToNextTimer(3);\n      expect(runOrder).toEqual([\n        'mock2',\n        'mock3',\n        'mock1',\n        'mock4',\n        'mock4',\n        'mock4',\n      ]);\n    });\n\n    it('setTimeout inside setTimeout', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      const runOrder: Array<string> = [];\n      const mock1 = jest.fn(() => runOrder.push('mock1'));\n      const mock2 = jest.fn(() => runOrder.push('mock2'));\n      const mock3 = jest.fn(() => runOrder.push('mock3'));\n      const mock4 = jest.fn(() => runOrder.push('mock4'));\n\n      global.setTimeout(mock1, 0);\n      global.setTimeout(() => {\n        mock2();\n        global.setTimeout(mock3, 50);\n      }, 25);\n      global.setTimeout(mock4, 100);\n\n      // Move forward to t=75\n      timers.advanceTimersToNextTimer(3);\n      expect(runOrder).toEqual(['mock1', 'mock2', 'mock3']);\n    });\n\n    it('does nothing when no timers have been scheduled', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      timers.advanceTimersToNextTimer();\n    });\n  });\n\n  describe('advanceTimersToNextFrame', () => {\n    it('runs scheduled animation frame callbacks in order', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        requestAnimationFrame: () => -1,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      const runOrder: Array<string> = [];\n      const mock1 = jest.fn(() => runOrder.push('mock1'));\n      const mock2 = jest.fn(() => runOrder.push('mock2'));\n      const mock3 = jest.fn(() => runOrder.push('mock3'));\n\n      global.requestAnimationFrame(mock1);\n      global.requestAnimationFrame(mock2);\n      global.requestAnimationFrame(mock3);\n\n      timers.advanceTimersToNextFrame();\n\n      expect(runOrder).toEqual(['mock1', 'mock2', 'mock3']);\n    });\n\n    it('should only run currently scheduled animation frame callbacks', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        requestAnimationFrame: () => -1,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      const runOrder: Array<string> = [];\n      function run() {\n        runOrder.push('first-frame');\n\n        // scheduling another animation frame in the first frame\n        global.requestAnimationFrame(() => runOrder.push('second-frame'));\n      }\n\n      global.requestAnimationFrame(run);\n\n      // only the first frame should be executed\n      timers.advanceTimersToNextFrame();\n\n      expect(runOrder).toEqual(['first-frame']);\n\n      timers.advanceTimersToNextFrame();\n\n      expect(runOrder).toEqual(['first-frame', 'second-frame']);\n    });\n\n    it('should allow cancelling of scheduled animation frame callbacks', () => {\n      const global = {\n        Date,\n        cancelAnimationFrame: () => {},\n        clearInterval,\n        clearTimeout,\n        process,\n        requestAnimationFrame: () => -1,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      const callback = jest.fn();\n      timers.useFakeTimers();\n\n      const timerId = global.requestAnimationFrame(callback);\n      global.cancelAnimationFrame(timerId);\n\n      timers.advanceTimersToNextFrame();\n\n      expect(callback).not.toHaveBeenCalled();\n    });\n\n    it('should only advance as much time is needed to get to the next frame', () => {\n      const global = {\n        Date,\n        cancelAnimationFrame: () => {},\n        clearInterval,\n        clearTimeout,\n        process,\n        requestAnimationFrame: () => -1,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      const runOrder: Array<string> = [];\n      const start = global.Date.now();\n\n      const callback = () => runOrder.push('frame');\n      global.requestAnimationFrame(callback);\n\n      // Advancing timers less than a frame (which is 16ms)\n      timers.advanceTimersByTime(6);\n      expect(global.Date.now()).toEqual(start + 6);\n\n      // frame not yet executed\n      expect(runOrder).toEqual([]);\n\n      // move timers forward to execute frame\n      timers.advanceTimersToNextFrame();\n\n      // frame has executed as time has moved forward 10ms to get to the 16ms frame time\n      expect(runOrder).toEqual(['frame']);\n      expect(global.Date.now()).toEqual(start + 16);\n    });\n\n    it('should execute any timers on the way to the animation frame', () => {\n      const global = {\n        Date,\n        cancelAnimationFrame: () => {},\n        clearInterval,\n        clearTimeout,\n        process,\n        requestAnimationFrame: () => -1,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      const runOrder: Array<string> = [];\n\n      global.requestAnimationFrame(() => runOrder.push('frame'));\n\n      // scheduling a timeout that will be executed on the way to the frame\n      global.setTimeout(() => runOrder.push('timeout'), 10);\n\n      // move timers forward to execute frame\n      timers.advanceTimersToNextFrame();\n\n      expect(runOrder).toEqual(['timeout', 'frame']);\n    });\n\n    it('should not execute any timers scheduled inside of an animation frame callback', () => {\n      const global = {\n        Date,\n        cancelAnimationFrame: () => {},\n        clearInterval,\n        clearTimeout,\n        process,\n        requestAnimationFrame: () => -1,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      const runOrder: Array<string> = [];\n\n      global.requestAnimationFrame(() => {\n        runOrder.push('frame');\n        // scheduling a timer inside of a frame\n        global.setTimeout(() => runOrder.push('timeout'), 1);\n      });\n\n      timers.advanceTimersToNextFrame();\n\n      // timeout not yet executed\n      expect(runOrder).toEqual(['frame']);\n\n      // validating that the timer will still be executed\n      timers.advanceTimersByTime(1);\n      expect(runOrder).toEqual(['frame', 'timeout']);\n    });\n\n    it('should call animation frame callbacks with the latest system time', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        performance,\n        process,\n        requestAnimationFrame: () => -1,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      const callback = jest.fn();\n\n      global.requestAnimationFrame(callback);\n\n      timers.advanceTimersToNextFrame();\n\n      // `requestAnimationFrame` callbacks are called with a `DOMHighResTimeStamp`\n      expect(callback).toHaveBeenCalledWith(global.performance.now());\n    });\n  });\n\n  describe('reset', () => {\n    it('resets all pending setTimeouts', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      const mock1 = jest.fn();\n      global.setTimeout(mock1, 100);\n\n      timers.reset();\n      timers.runAllTimers();\n      expect(mock1).toHaveBeenCalledTimes(0);\n    });\n\n    it('resets all pending setIntervals', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      const mock1 = jest.fn();\n      global.setInterval(mock1, 200);\n\n      timers.reset();\n      timers.runAllTimers();\n      expect(mock1).toHaveBeenCalledTimes(0);\n    });\n\n    it('resets all pending ticks callbacks', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process: {\n          nextTick: () => {},\n        },\n        setImmediate: () => {},\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      const mock1 = jest.fn();\n      global.process.nextTick(mock1);\n      global.setImmediate(mock1);\n\n      timers.reset();\n      timers.runAllTicks();\n      expect(mock1).toHaveBeenCalledTimes(0);\n    });\n\n    it('resets current advanceTimersByTime time cursor', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      const mock1 = jest.fn();\n      global.setTimeout(mock1, 100);\n      timers.advanceTimersByTime(50);\n\n      timers.reset();\n      global.setTimeout(mock1, 100);\n\n      timers.advanceTimersByTime(50);\n      expect(mock1).toHaveBeenCalledTimes(0);\n    });\n\n    it('resets all scheduled animation frames', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        requestAnimationFrame: () => -1,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      const mock1 = jest.fn();\n      global.requestAnimationFrame(mock1);\n\n      timers.reset();\n      timers.runAllTimers();\n      expect(mock1).toHaveBeenCalledTimes(0);\n    });\n  });\n\n  describe('runOnlyPendingTimers', () => {\n    it('runs all timers in order', () => {\n      const nativeSetImmediate = jest.fn();\n\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setImmediate: nativeSetImmediate,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      const runOrder: Array<string> = [];\n\n      global.setTimeout(function cb() {\n        runOrder.push('mock1');\n        global.setTimeout(cb, 100);\n      }, 100);\n\n      global.setTimeout(function cb() {\n        runOrder.push('mock2');\n        global.setTimeout(cb, 50);\n      }, 0);\n\n      global.setInterval(() => {\n        runOrder.push('mock3');\n      }, 200);\n\n      global.setImmediate(() => {\n        runOrder.push('mock4');\n      });\n\n      global.setImmediate(function cb() {\n        runOrder.push('mock5');\n        global.setTimeout(cb, 400);\n      });\n\n      timers.runOnlyPendingTimers();\n      const firsRunOrder = [\n        'mock4',\n        'mock5',\n        'mock2',\n        'mock2',\n        'mock1',\n        'mock2',\n        'mock2',\n        'mock3',\n        'mock1',\n        'mock2',\n      ];\n\n      expect(runOrder).toEqual(firsRunOrder);\n\n      timers.runOnlyPendingTimers();\n      expect(runOrder).toEqual([\n        ...firsRunOrder,\n        'mock2',\n        'mock1',\n        'mock2',\n        'mock2',\n        'mock3',\n        'mock5',\n        'mock1',\n        'mock2',\n      ]);\n    });\n\n    it('does not run timers that were cleared in another timer', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      const fn = jest.fn();\n      const timer = global.setTimeout(fn, 10);\n      global.setTimeout(() => {\n        global.clearTimeout(timer);\n      }, 0);\n\n      timers.runOnlyPendingTimers();\n      expect(fn).not.toHaveBeenCalled();\n    });\n  });\n\n  describe('useRealTimers', () => {\n    it('resets native timer APIs', () => {\n      const nativeSetTimeout = jest.fn();\n      const nativeSetInterval = jest.fn();\n      const nativeClearTimeout = jest.fn();\n      const nativeClearInterval = jest.fn();\n\n      const global = {\n        Date,\n        clearInterval: nativeClearInterval,\n        clearTimeout: nativeClearTimeout,\n        process,\n        setInterval: nativeSetInterval,\n        setTimeout: nativeSetTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      // Ensure that timers has overridden the native timer APIs\n      // (because if it didn't, this test might pass when it shouldn't)\n      expect(global.setTimeout).not.toBe(nativeSetTimeout);\n      expect(global.setInterval).not.toBe(nativeSetInterval);\n      expect(global.clearTimeout).not.toBe(nativeClearTimeout);\n      expect(global.clearInterval).not.toBe(nativeClearInterval);\n\n      timers.useRealTimers();\n\n      expect(global.setTimeout).toBe(nativeSetTimeout);\n      expect(global.setInterval).toBe(nativeSetInterval);\n      expect(global.clearTimeout).toBe(nativeClearTimeout);\n      expect(global.clearInterval).toBe(nativeClearInterval);\n    });\n\n    it('resets native process.nextTick when present', () => {\n      const nativeProcessNextTick = jest.fn();\n\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process: {nextTick: nativeProcessNextTick},\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      // Ensure that timers has overridden the native timer APIs\n      // (because if it didn't, this test might pass when it shouldn't)\n      expect(global.process.nextTick).not.toBe(nativeProcessNextTick);\n\n      timers.useRealTimers();\n\n      expect(global.process.nextTick).toBe(nativeProcessNextTick);\n    });\n\n    it('resets native setImmediate when present', () => {\n      const nativeSetImmediate = jest.fn();\n      const nativeClearImmediate = jest.fn();\n\n      const global = {\n        Date,\n        clearImmediate: nativeClearImmediate,\n        clearInterval,\n        clearTimeout,\n        process,\n        setImmediate: nativeSetImmediate,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      // Ensure that timers has overridden the native timer APIs\n      // (because if it didn't, this test might pass when it shouldn't)\n      expect(global.setImmediate).not.toBe(nativeSetImmediate);\n      expect(global.clearImmediate).not.toBe(nativeClearImmediate);\n\n      timers.useRealTimers();\n\n      expect(global.setImmediate).toBe(nativeSetImmediate);\n      expect(global.clearImmediate).toBe(nativeClearImmediate);\n    });\n  });\n\n  describe('useFakeTimers', () => {\n    it('resets mock timer APIs', () => {\n      const nativeSetTimeout = jest.fn();\n      const nativeSetInterval = jest.fn();\n      const nativeClearTimeout = jest.fn();\n      const nativeClearInterval = jest.fn();\n\n      const global = {\n        Date,\n        clearInterval: nativeClearInterval,\n        clearTimeout: nativeClearTimeout,\n        process,\n        setInterval: nativeSetInterval,\n        setTimeout: nativeSetTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useRealTimers();\n\n      // Ensure that the real timers are installed at this point\n      // (because if they aren't, this test might pass when it shouldn't)\n      expect(global.setTimeout).toBe(nativeSetTimeout);\n      expect(global.setInterval).toBe(nativeSetInterval);\n      expect(global.clearTimeout).toBe(nativeClearTimeout);\n      expect(global.clearInterval).toBe(nativeClearInterval);\n\n      timers.useFakeTimers();\n\n      expect(global.setTimeout).not.toBe(nativeSetTimeout);\n      expect(global.setInterval).not.toBe(nativeSetInterval);\n      expect(global.clearTimeout).not.toBe(nativeClearTimeout);\n      expect(global.clearInterval).not.toBe(nativeClearInterval);\n    });\n\n    it('resets mock process.nextTick when present', () => {\n      const nativeProcessNextTick = jest.fn();\n\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process: {nextTick: nativeProcessNextTick},\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useRealTimers();\n\n      // Ensure that the real timers are installed at this point\n      // (because if they aren't, this test might pass when it shouldn't)\n      expect(global.process.nextTick).toBe(nativeProcessNextTick);\n\n      timers.useFakeTimers();\n\n      expect(global.process.nextTick).not.toBe(nativeProcessNextTick);\n    });\n\n    it('resets mock setImmediate when present', () => {\n      const nativeSetImmediate = jest.fn();\n      const nativeClearImmediate = jest.fn();\n\n      const global = {\n        Date,\n        clearImmediate: nativeClearImmediate,\n        clearInterval,\n        clearTimeout,\n        process,\n        setImmediate: nativeSetImmediate,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const fakeTimers = new FakeTimers({config: makeProjectConfig(), global});\n      fakeTimers.useRealTimers();\n\n      // Ensure that the real timers are installed at this point\n      // (because if they aren't, this test might pass when it shouldn't)\n      expect(global.setImmediate).toBe(nativeSetImmediate);\n      expect(global.clearImmediate).toBe(nativeClearImmediate);\n\n      fakeTimers.useFakeTimers();\n\n      expect(global.setImmediate).not.toBe(nativeSetImmediate);\n      expect(global.clearImmediate).not.toBe(nativeClearImmediate);\n    });\n  });\n\n  describe('getTimerCount', () => {\n    let timers: FakeTimers;\n    let fakedGlobal: typeof globalThis;\n    beforeEach(() => {\n      fakedGlobal = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setImmediate,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      timers = new FakeTimers({\n        config: makeProjectConfig(),\n        global: fakedGlobal,\n      });\n\n      timers.useFakeTimers();\n    });\n\n    afterEach(() => {\n      timers.useRealTimers();\n    });\n\n    it('returns the correct count', () => {\n      fakedGlobal.setTimeout(() => {}, 0);\n      fakedGlobal.setTimeout(() => {}, 0);\n      fakedGlobal.setTimeout(() => {}, 10);\n\n      expect(timers.getTimerCount()).toBe(3);\n\n      timers.advanceTimersByTime(5);\n\n      expect(timers.getTimerCount()).toBe(1);\n\n      timers.advanceTimersByTime(5);\n\n      expect(timers.getTimerCount()).toBe(0);\n    });\n\n    it('includes immediates and ticks', () => {\n      fakedGlobal.setTimeout(() => {}, 0);\n      fakedGlobal.setImmediate(() => {});\n      process.nextTick(() => {});\n\n      expect(timers.getTimerCount()).toBe(3);\n    });\n\n    it('not includes cancelled immediates', () => {\n      fakedGlobal.setImmediate(() => {});\n      expect(timers.getTimerCount()).toBe(1);\n      timers.clearAllTimers();\n\n      expect(timers.getTimerCount()).toBe(0);\n    });\n  });\n\n  describe('advanceTimersToNextTimerAsync', () => {\n    it('should advance the clock at the moment of the first scheduled timer', async () => {\n      const global = {\n        Date,\n        Promise,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n      timers.setSystemTime(0);\n\n      const spy = jest.fn();\n      global.setTimeout(async () => {\n        await Promise.resolve();\n        global.setTimeout(spy, 100);\n      }, 100);\n\n      await timers.advanceTimersToNextTimerAsync();\n      expect(timers.now()).toBe(100);\n\n      await timers.advanceTimersToNextTimerAsync();\n      expect(timers.now()).toBe(200);\n      expect(spy).toHaveBeenCalled();\n    });\n\n    it('should advance the clock at the moment of the n-th scheduled timer', async () => {\n      const global = {\n        Date,\n        Promise,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n      timers.setSystemTime(0);\n\n      const spy = jest.fn();\n      global.setTimeout(async () => {\n        await Promise.resolve();\n        global.setTimeout(spy, 100);\n      }, 100);\n\n      await timers.advanceTimersToNextTimerAsync(2);\n\n      expect(timers.now()).toBe(200);\n      expect(spy).toHaveBeenCalled();\n    });\n  });\n\n  describe('runAllTimersAsync', () => {\n    it('should advance the clock to the last scheduled timer', async () => {\n      const global = {\n        Date,\n        Promise,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n      timers.setSystemTime(0);\n\n      const spy = jest.fn();\n      const spy2 = jest.fn();\n      global.setTimeout(async () => {\n        await Promise.resolve();\n        global.setTimeout(spy, 100);\n        global.setTimeout(spy2, 200);\n      }, 100);\n\n      await timers.runAllTimersAsync();\n      expect(timers.now()).toBe(300);\n      expect(spy).toHaveBeenCalled();\n      expect(spy2).toHaveBeenCalled();\n    });\n  });\n\n  describe('runOnlyPendingTimersAsync', () => {\n    it('should advance the clock to the last scheduled timer', async () => {\n      const global = {\n        Date,\n        Promise,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n      timers.setSystemTime(0);\n\n      const spy = jest.fn();\n      const spy2 = jest.fn();\n      global.setTimeout(spy, 50);\n      global.setTimeout(spy2, 50);\n      global.setTimeout(async () => {\n        await Promise.resolve();\n      }, 100);\n\n      await timers.runOnlyPendingTimersAsync();\n      expect(timers.now()).toBe(100);\n      expect(spy).toHaveBeenCalled();\n      expect(spy2).toHaveBeenCalled();\n    });\n  });\n\n  describe('advanceTimersByTimeAsync', () => {\n    it('should advance the clock', async () => {\n      const global = {\n        Date,\n        Promise,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      const spy = jest.fn();\n      global.setTimeout(async () => {\n        await Promise.resolve();\n        global.setTimeout(spy, 100);\n      }, 100);\n\n      await timers.advanceTimersByTimeAsync(200);\n      expect(spy).toHaveBeenCalled();\n    });\n  });\n\n  describe('now', () => {\n    let timers: FakeTimers;\n    let fakedGlobal: typeof globalThis;\n\n    beforeEach(() => {\n      fakedGlobal = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      timers = new FakeTimers({\n        config: makeProjectConfig(),\n        global: fakedGlobal,\n      });\n    });\n\n    it('returns the current clock', () => {\n      timers.useFakeTimers();\n      timers.setSystemTime(0);\n      fakedGlobal.setTimeout(() => {}, 2);\n      fakedGlobal.setTimeout(() => {}, 100);\n\n      expect(timers.now()).toBe(0);\n\n      // This should run the 2ms timer, and then advance _now by 3ms\n      timers.advanceTimersByTime(5);\n      expect(timers.now()).toBe(5);\n\n      // Advance _now even though there are no timers to run\n      timers.advanceTimersByTime(5);\n      expect(timers.now()).toBe(10);\n\n      // Run up to the 100ms timer\n      timers.runAllTimers();\n      expect(timers.now()).toBe(100);\n\n      // Verify that runOnlyPendingTimers advances now only up to the first\n      // recursive timer\n      fakedGlobal.setTimeout(function infinitelyRecursingCallback() {\n        fakedGlobal.setTimeout(infinitelyRecursingCallback, 20);\n      }, 10);\n      timers.runOnlyPendingTimers();\n      expect(timers.now()).toBe(110);\n\n      // For modern timers, reset() explicitly preserves the clock time\n      timers.reset();\n      expect(timers.now()).toBe(110);\n    });\n\n    it('returns the real time if useFakeTimers is not called', () => {\n      const before = Date.now();\n      const now = timers.now();\n      const after = Date.now();\n      expect(now).toBeGreaterThanOrEqual(before);\n      expect(now).toBeLessThanOrEqual(after);\n    });\n  });\n});\n",
  "packages/jest-fake-timers/src/__tests__/modernFakeTimers.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport {};\n",
  "packages/jest-fake-timers/src/__tests__/legacyFakeTimers.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/// <reference lib=\"dom\" />\n\nimport * as util from 'util';\nimport {runInNewContext} from 'vm';\nimport {ModuleMocker} from 'jest-mock';\nimport FakeTimers from '../legacyFakeTimers';\n\nconst timerConfig = {\n  idToRef: (id: number) => id,\n  refToId: (ref: number) => ref,\n};\n\nconst config = {\n  rootDir: '/',\n  testMatch: [],\n};\n\ndescribe('FakeTimers', () => {\n  let moduleMocker: ModuleMocker;\n\n  beforeEach(() => {\n    const global = runInNewContext('this');\n    moduleMocker = new ModuleMocker(global);\n  });\n\n  describe('construction', () => {\n    it('installs setTimeout mock', () => {\n      const global = {process} as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n      expect(global.setTimeout).toBeDefined();\n    });\n\n    it('accepts to promisify setTimeout mock', async () => {\n      const global = {process} as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n      const timeoutPromise = util.promisify(global.setTimeout)(0, 'resolved');\n      timers.runAllTimers();\n      await expect(timeoutPromise).resolves.toBe('resolved');\n    });\n\n    it('installs clearTimeout mock', () => {\n      const global = {process} as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n      expect(global.clearTimeout).toBeDefined();\n    });\n\n    it('installs setInterval mock', () => {\n      const global = {process} as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n      expect(global.setInterval).toBeDefined();\n    });\n\n    it('installs clearInterval mock', () => {\n      const global = {process} as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n      expect(global.clearInterval).toBeDefined();\n    });\n\n    it('mocks process.nextTick if it exists on global', () => {\n      const origNextTick = () => {};\n      const global = {\n        process: {\n          nextTick: origNextTick,\n        },\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n      expect(global.process.nextTick).not.toBe(origNextTick);\n    });\n\n    it('mocks setImmediate if it exists on global', () => {\n      const origSetImmediate = () => {};\n      const global = {\n        process,\n        setImmediate: origSetImmediate,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n      expect(global.setImmediate).not.toBe(origSetImmediate);\n    });\n\n    it('mocks clearImmediate if setImmediate is on global', () => {\n      const origSetImmediate = () => {};\n      const origClearImmediate = () => {};\n      const global = {\n        clearImmediate: origClearImmediate,\n        process,\n        setImmediate: origSetImmediate,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n      expect(global.clearImmediate).not.toBe(origClearImmediate);\n    });\n\n    it('does not mock requestAnimationFrame if not available', () => {\n      const global = {\n        process,\n      } as unknown as typeof globalThis & Window;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n      expect(global.requestAnimationFrame).toBeUndefined();\n    });\n\n    it('mocks requestAnimationFrame if available on global', () => {\n      const origRequestAnimationFrame = () => {};\n      const global = {\n        process,\n        requestAnimationFrame: origRequestAnimationFrame,\n      } as unknown as typeof globalThis & Window;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n      expect(global.requestAnimationFrame).toBeDefined();\n      expect(global.requestAnimationFrame).not.toBe(origRequestAnimationFrame);\n    });\n\n    it('does not mock cancelAnimationFrame if not available on global', () => {\n      const global = {\n        process,\n      } as unknown as typeof globalThis & Window;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n      expect(global.cancelAnimationFrame).toBeUndefined();\n    });\n\n    it('mocks cancelAnimationFrame if available on global', () => {\n      const origCancelAnimationFrame = () => {};\n      const global = {\n        cancelAnimationFrame: origCancelAnimationFrame,\n        process,\n      } as unknown as typeof globalThis & Window;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n      expect(global.cancelAnimationFrame).toBeDefined();\n      expect(global.cancelAnimationFrame).not.toBe(origCancelAnimationFrame);\n    });\n  });\n\n  describe('runAllTicks', () => {\n    it('runs all ticks, in order', () => {\n      const global = {\n        process: {\n          nextTick: () => {},\n        },\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      const runOrder: Array<string> = [];\n      const mock1 = jest.fn(() => runOrder.push('mock1'));\n      const mock2 = jest.fn(() => runOrder.push('mock2'));\n\n      global.process.nextTick(mock1);\n      global.process.nextTick(mock2);\n\n      expect(mock1).toHaveBeenCalledTimes(0);\n      expect(mock2).toHaveBeenCalledTimes(0);\n\n      timers.runAllTicks();\n\n      expect(mock1).toHaveBeenCalledTimes(1);\n      expect(mock2).toHaveBeenCalledTimes(1);\n      expect(runOrder).toEqual(['mock1', 'mock2']);\n    });\n\n    it('does nothing when no ticks have been scheduled', () => {\n      const nextTick = jest.fn();\n      const global = {\n        process: {\n          nextTick,\n        },\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n      timers.runAllTicks();\n\n      expect(nextTick).toHaveBeenCalledTimes(0);\n    });\n\n    it('only runs a scheduled callback once', () => {\n      const global = {\n        process: {\n          nextTick: () => {},\n        },\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      const mock1 = jest.fn();\n      global.process.nextTick(mock1);\n      expect(mock1).toHaveBeenCalledTimes(0);\n\n      timers.runAllTicks();\n      expect(mock1).toHaveBeenCalledTimes(1);\n\n      timers.runAllTicks();\n      expect(mock1).toHaveBeenCalledTimes(1);\n    });\n\n    it('cancels a callback even from native nextTick', () => {\n      const nativeNextTick = jest.fn<typeof process.nextTick>();\n\n      const global = {\n        process: {\n          nextTick: nativeNextTick,\n        },\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      const mock1 = jest.fn();\n      global.process.nextTick(mock1);\n      timers.runAllTicks();\n      expect(mock1).toHaveBeenCalledTimes(1);\n      expect(nativeNextTick).toHaveBeenCalledTimes(1);\n\n      // Now imagine we fast forward to the next real tick. We need to be sure\n      // that native nextTick doesn't try to run the callback again\n      nativeNextTick.mock.calls[0][0]();\n      expect(mock1).toHaveBeenCalledTimes(1);\n    });\n\n    it('cancels a callback even from native setImmediate', () => {\n      const nativeSetImmediate = jest.fn<typeof setImmediate>();\n\n      const global = {\n        process,\n        setImmediate: nativeSetImmediate,\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      const mock1 = jest.fn();\n      global.setImmediate(mock1);\n      timers.runAllImmediates();\n      expect(mock1).toHaveBeenCalledTimes(1);\n      expect(nativeSetImmediate).toHaveBeenCalledTimes(1);\n\n      // ensure that native setImmediate doesn't try to run the callback again\n      nativeSetImmediate.mock.calls[0][0]();\n      expect(mock1).toHaveBeenCalledTimes(1);\n    });\n\n    it('doesnt run a tick callback if native nextTick already did', () => {\n      const nativeNextTick = jest.fn<typeof process.nextTick>();\n\n      const global = {\n        process: {\n          nextTick: nativeNextTick,\n        },\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      const mock1 = jest.fn();\n      global.process.nextTick(mock1);\n\n      // Emulate native nextTick running...\n      nativeNextTick.mock.calls[0][0]();\n      expect(mock1).toHaveBeenCalledTimes(1);\n\n      // Ensure runAllTicks() doesn't run the callback again\n      timers.runAllTicks();\n      expect(mock1).toHaveBeenCalledTimes(1);\n    });\n\n    it('doesnt run immediate if native setImmediate already did', () => {\n      const nativeSetImmediate = jest.fn<typeof setImmediate>();\n\n      const global = {\n        process,\n        setImmediate: nativeSetImmediate,\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      const mock1 = jest.fn();\n      global.setImmediate(mock1);\n\n      // Emulate native setImmediate running...\n      nativeSetImmediate.mock.calls[0][0]();\n      expect(mock1).toHaveBeenCalledTimes(1);\n\n      // Ensure runAllTicks() doesn't run the callback again\n      timers.runAllImmediates();\n      expect(mock1).toHaveBeenCalledTimes(1);\n    });\n\n    it('native doesnt run immediate if fake already did', () => {\n      const nativeSetImmediate = jest.fn<typeof setImmediate>();\n\n      const global = {\n        process,\n        setImmediate: nativeSetImmediate,\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      const mock1 = jest.fn();\n      global.setImmediate(mock1);\n\n      //run all immediates now\n      timers.runAllImmediates();\n      expect(mock1).toHaveBeenCalledTimes(1);\n\n      // Emulate native setImmediate running ensuring it doesn't re-run\n      nativeSetImmediate.mock.calls[0][0]();\n\n      expect(mock1).toHaveBeenCalledTimes(1);\n    });\n\n    it('throws before allowing infinite recursion', () => {\n      const global = {\n        process: {\n          nextTick: () => {},\n        },\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({\n        config,\n        global,\n        maxLoops: 100,\n        moduleMocker,\n        timerConfig,\n      });\n\n      timers.useFakeTimers();\n\n      global.process.nextTick(function infinitelyRecursingCallback() {\n        global.process.nextTick(infinitelyRecursingCallback);\n      });\n\n      expect(() => {\n        timers.runAllTicks();\n      }).toThrow(\n        new Error(\n          \"Ran 100 ticks, and there are still more! Assuming we've hit an \" +\n            'infinite recursion and bailing out...',\n        ),\n      );\n    });\n  });\n\n  describe('runAllTimers', () => {\n    it('runs all timers in order', () => {\n      const global = {\n        cancelAnimationFrame: () => {},\n        process,\n        requestAnimationFrame: () => {},\n      } as unknown as typeof globalThis & Window;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      const runOrder: Array<string> = [];\n      const mock1 = jest.fn(() => runOrder.push('mock1'));\n      const mock2 = jest.fn(() => runOrder.push('mock2'));\n      const mock3 = jest.fn(() => runOrder.push('mock3'));\n      const mock4 = jest.fn(() => runOrder.push('mock4'));\n      const mock5 = jest.fn(() => runOrder.push('mock5'));\n      const mock6 = jest.fn(() => runOrder.push('mock6'));\n      const mockAnimationFrame = jest.fn(() => runOrder.push('animationFrame'));\n\n      global.setTimeout(mock1, 100);\n      global.setTimeout(mock2, Number.NaN);\n      global.setTimeout(mock3, 0);\n      const intervalHandler = global.setInterval(() => {\n        mock4();\n        global.clearInterval(intervalHandler);\n      }, 200);\n      global.setTimeout(mock5, Number.POSITIVE_INFINITY);\n      global.setTimeout(mock6, Number.NEGATIVE_INFINITY);\n      global.requestAnimationFrame(mockAnimationFrame);\n\n      timers.runAllTimers();\n      expect(runOrder).toEqual([\n        'mock2',\n        'mock3',\n        'mock5',\n        'mock6',\n        'animationFrame',\n        'mock1',\n        'mock4',\n      ]);\n    });\n\n    it('warns when trying to advance timers while real timers are used', () => {\n      const mockConsole = {warn: jest.fn<typeof console.warn>()};\n      const timers = new FakeTimers({\n        config: {\n          rootDir: __dirname,\n          testMatch: [],\n        },\n        global: {console: mockConsole} as unknown as typeof globalThis,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.runAllTimers();\n      expect(\n        mockConsole.warn.mock.calls[0][0].split('\\nStack Trace')[0],\n      ).toMatchSnapshot();\n    });\n\n    it('does nothing when no timers have been scheduled', () => {\n      const nativeSetTimeout = jest.fn();\n      const global = {\n        process,\n        setTimeout: nativeSetTimeout,\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n      timers.runAllTimers();\n    });\n\n    it('only runs a setTimeout callback once (ever)', () => {\n      const global = {process} as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      const fn = jest.fn();\n      global.setTimeout(fn, 0);\n      expect(fn).toHaveBeenCalledTimes(0);\n\n      timers.runAllTimers();\n      expect(fn).toHaveBeenCalledTimes(1);\n\n      timers.runAllTimers();\n      expect(fn).toHaveBeenCalledTimes(1);\n    });\n\n    it('runs callbacks with arguments after the interval', () => {\n      const global = {process} as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      const fn = jest.fn();\n      global.setTimeout(fn, 0, 'mockArg1', 'mockArg2');\n\n      timers.runAllTimers();\n      expect(fn).toHaveBeenCalledTimes(1);\n      expect(fn).toHaveBeenCalledWith('mockArg1', 'mockArg2');\n    });\n\n    it('doesnt pass the callback to native setTimeout', () => {\n      const nativeSetTimeout = jest.fn();\n\n      const global = {\n        process,\n        setTimeout: nativeSetTimeout,\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      const mock1 = jest.fn();\n      global.setTimeout(mock1, 0);\n\n      timers.runAllTimers();\n      expect(mock1).toHaveBeenCalledTimes(1);\n      expect(nativeSetTimeout).toHaveBeenCalledTimes(0);\n    });\n\n    it('throws before allowing infinite recursion', () => {\n      const global = {process} as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        maxLoops: 100,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      global.setTimeout(function infinitelyRecursingCallback() {\n        global.setTimeout(infinitelyRecursingCallback, 0);\n      }, 0);\n\n      expect(() => {\n        timers.runAllTimers();\n      }).toThrow(\n        new Error(\n          \"Ran 100 timers, and there are still more! Assuming we've hit an \" +\n            'infinite recursion and bailing out...',\n        ),\n      );\n    });\n\n    it('also clears ticks', () => {\n      const global = {process} as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      const fn = jest.fn();\n      global.setTimeout(() => {\n        process.nextTick(fn);\n      }, 0);\n      expect(fn).toHaveBeenCalledTimes(0);\n\n      timers.runAllTimers();\n      expect(fn).toHaveBeenCalledTimes(1);\n    });\n  });\n\n  describe('advanceTimersByTime', () => {\n    it('runs timers in order', () => {\n      const global = {\n        cancelAnimationFrame: () => {},\n        process,\n        requestAnimationFrame: () => {},\n      } as unknown as typeof globalThis & Window;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      const runOrder: Array<string | ['animationFrame', number]> = [];\n      const mock1 = jest.fn(() => runOrder.push('mock1'));\n      const mock2 = jest.fn(() => runOrder.push('mock2'));\n      const mock3 = jest.fn(() => runOrder.push('mock3'));\n      const mock4 = jest.fn(() => runOrder.push('mock4'));\n      const mockAnimationFrame = jest.fn(timestamp =>\n        runOrder.push(['animationFrame', timestamp]),\n      );\n\n      global.setTimeout(mock1, 100);\n      global.setTimeout(mock2, 0);\n      global.setTimeout(mock3, 0);\n      global.setInterval(() => {\n        mock4();\n      }, 200);\n      global.requestAnimationFrame(mockAnimationFrame);\n\n      // Move forward to t=15\n      timers.advanceTimersByTime(15);\n      expect(runOrder).toEqual(['mock2', 'mock3']);\n\n      // Move forward to t=16\n      timers.advanceTimersByTime(1);\n      expect(runOrder).toEqual(['mock2', 'mock3', ['animationFrame', 16]]);\n\n      // Move forward to t=60\n      timers.advanceTimersByTime(44);\n      expect(runOrder).toEqual(['mock2', 'mock3', ['animationFrame', 16]]);\n\n      // Move forward to t=100\n      timers.advanceTimersByTime(40);\n      expect(runOrder).toEqual([\n        'mock2',\n        'mock3',\n        ['animationFrame', 16],\n        'mock1',\n      ]);\n\n      // Move forward to t=200\n      timers.advanceTimersByTime(100);\n      expect(runOrder).toEqual([\n        'mock2',\n        'mock3',\n        ['animationFrame', 16],\n        'mock1',\n        'mock4',\n      ]);\n\n      // Move forward to t=400\n      timers.advanceTimersByTime(200);\n      expect(runOrder).toEqual([\n        'mock2',\n        'mock3',\n        ['animationFrame', 16],\n        'mock1',\n        'mock4',\n        'mock4',\n      ]);\n    });\n\n    it('does nothing when no timers have been scheduled', () => {\n      const global = {process} as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      timers.advanceTimersByTime(100);\n    });\n    it('throws before allowing infinite recursion', () => {\n      const global = {process} as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        maxLoops: 100,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      global.setTimeout(function infinitelyRecursingCallback() {\n        global.setTimeout(infinitelyRecursingCallback, 0);\n      }, 0);\n\n      expect(() => {\n        timers.advanceTimersByTime(50);\n      }).toThrow(\n        new Error(\n          \"Ran 100 timers, and there are still more! Assuming we've hit an \" +\n            'infinite recursion and bailing out...',\n        ),\n      );\n    });\n  });\n\n  describe('advanceTimersToNextTimer', () => {\n    it('runs timers in order', () => {\n      const global = {\n        cancelAnimationFrame: () => {},\n        process,\n        requestAnimationFrame: () => {},\n      } as unknown as typeof globalThis & Window;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      const runOrder: Array<string> = [];\n      const mock1 = jest.fn(() => runOrder.push('mock1'));\n      const mock2 = jest.fn(() => runOrder.push('mock2'));\n      const mock3 = jest.fn(() => runOrder.push('mock3'));\n      const mock4 = jest.fn(() => runOrder.push('mock4'));\n      const mockAnimationFrame = jest.fn(() => runOrder.push('animationFrame'));\n\n      global.setTimeout(mock1, 100);\n      global.setTimeout(mock2, 0);\n      global.setTimeout(mock3, 0);\n      global.setInterval(() => {\n        mock4();\n      }, 200);\n      global.requestAnimationFrame(mockAnimationFrame);\n\n      timers.advanceTimersToNextTimer();\n      // Move forward to t=0\n      expect(runOrder).toEqual(['mock2', 'mock3']);\n\n      timers.advanceTimersToNextTimer();\n      // Move forward to t=17\n      expect(runOrder).toEqual(['mock2', 'mock3', 'animationFrame']);\n\n      timers.advanceTimersToNextTimer();\n      // Move forward to t=100\n      expect(runOrder).toEqual(['mock2', 'mock3', 'animationFrame', 'mock1']);\n\n      timers.advanceTimersToNextTimer();\n      // Move forward to t=200\n      expect(runOrder).toEqual([\n        'mock2',\n        'mock3',\n        'animationFrame',\n        'mock1',\n        'mock4',\n      ]);\n\n      timers.advanceTimersToNextTimer();\n      // Move forward to t=400\n      expect(runOrder).toEqual([\n        'mock2',\n        'mock3',\n        'animationFrame',\n        'mock1',\n        'mock4',\n        'mock4',\n      ]);\n    });\n\n    it('run correct amount of steps', () => {\n      const global = {\n        cancelAnimationFrame: () => {},\n        process,\n        requestAnimationFrame: () => {},\n      } as unknown as typeof globalThis & Window;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      const runOrder: Array<string> = [];\n      const mock1 = jest.fn(() => runOrder.push('mock1'));\n      const mock2 = jest.fn(() => runOrder.push('mock2'));\n      const mock3 = jest.fn(() => runOrder.push('mock3'));\n      const mock4 = jest.fn(() => runOrder.push('mock4'));\n      const mockAnimationFrame = jest.fn(() => runOrder.push('animationFrame'));\n\n      global.setTimeout(mock1, 100);\n      global.setTimeout(mock2, 0);\n      global.setTimeout(mock3, 0);\n      global.setInterval(() => {\n        mock4();\n      }, 200);\n      global.requestAnimationFrame(mockAnimationFrame);\n\n      // Move forward to t=17\n      timers.advanceTimersToNextTimer(2);\n      expect(runOrder).toEqual(['mock2', 'mock3', 'animationFrame']);\n\n      // Move forward to t=100\n      timers.advanceTimersToNextTimer(1);\n      expect(runOrder).toEqual(['mock2', 'mock3', 'animationFrame', 'mock1']);\n\n      // Move forward to t=600\n      timers.advanceTimersToNextTimer(3);\n      expect(runOrder).toEqual([\n        'mock2',\n        'mock3',\n        'animationFrame',\n        'mock1',\n        'mock4',\n        'mock4',\n        'mock4',\n      ]);\n    });\n\n    it('setTimeout inside setTimeout', () => {\n      const global = {process} as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      const runOrder: Array<string> = [];\n      const mock1 = jest.fn(() => runOrder.push('mock1'));\n      const mock2 = jest.fn(() => runOrder.push('mock2'));\n      const mock3 = jest.fn(() => runOrder.push('mock3'));\n      const mock4 = jest.fn(() => runOrder.push('mock4'));\n\n      global.setTimeout(mock1, 0);\n      global.setTimeout(() => {\n        mock2();\n        global.setTimeout(mock3, 50);\n      }, 25);\n      global.setTimeout(mock4, 100);\n\n      // Move forward to t=75\n      timers.advanceTimersToNextTimer(3);\n      expect(runOrder).toEqual(['mock1', 'mock2', 'mock3']);\n    });\n\n    it('does nothing when no timers have been scheduled', () => {\n      const global = {process} as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      timers.advanceTimersToNextTimer();\n    });\n  });\n\n  describe('reset', () => {\n    it('resets all pending setTimeouts', () => {\n      const global = {process} as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      const mock1 = jest.fn();\n      global.setTimeout(mock1, 100);\n\n      timers.reset();\n      timers.runAllTimers();\n      expect(mock1).toHaveBeenCalledTimes(0);\n    });\n\n    it('resets all pending setIntervals', () => {\n      const global = {process} as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      const mock1 = jest.fn();\n      global.setInterval(mock1, 200);\n\n      timers.reset();\n      timers.runAllTimers();\n      expect(mock1).toHaveBeenCalledTimes(0);\n    });\n\n    it('resets all pending animation frames', () => {\n      const global = {\n        cancelAnimationFrame: () => {},\n        process,\n        requestAnimationFrame: () => {},\n      } as unknown as typeof globalThis & Window;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      const mock1 = jest.fn();\n      global.requestAnimationFrame(mock1);\n\n      timers.reset();\n      timers.runAllTimers();\n      expect(mock1).toHaveBeenCalledTimes(0);\n    });\n\n    it('resets all pending ticks callbacks & immediates', () => {\n      const global = {\n        process: {\n          nextTick: () => {},\n        },\n        setImmediate: () => {},\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      const mock1 = jest.fn();\n      global.process.nextTick(mock1);\n      global.setImmediate(mock1);\n\n      timers.reset();\n      timers.runAllTicks();\n      timers.runAllImmediates();\n      expect(mock1).toHaveBeenCalledTimes(0);\n    });\n\n    it('resets current advanceTimersByTime time cursor', () => {\n      const global = {process} as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      const mock1 = jest.fn();\n      global.setTimeout(mock1, 100);\n      timers.advanceTimersByTime(50);\n\n      timers.reset();\n      global.setTimeout(mock1, 100);\n\n      timers.advanceTimersByTime(50);\n      expect(mock1).toHaveBeenCalledTimes(0);\n    });\n  });\n\n  describe('runOnlyPendingTimers', () => {\n    it('runs all timers in order', () => {\n      const nativeSetImmediate = jest.fn<typeof setImmediate>();\n\n      const global = {\n        cancelAnimationFrame: () => {},\n        process,\n        requestAnimationFrame: () => {},\n        setImmediate: nativeSetImmediate,\n      } as unknown as typeof globalThis & Window;\n\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      const runOrder: Array<string> = [];\n\n      global.setTimeout(function cb() {\n        runOrder.push('mock1');\n        global.setTimeout(cb, 100);\n      }, 100);\n\n      global.setTimeout(function cb() {\n        runOrder.push('mock2');\n        global.setTimeout(cb, 0);\n      }, 0);\n\n      global.setInterval(() => {\n        runOrder.push('mock3');\n      }, 200);\n\n      global.setImmediate(() => {\n        runOrder.push('mock4');\n      });\n\n      global.setImmediate(function cb() {\n        runOrder.push('mock5');\n        global.setTimeout(cb, 400);\n      });\n\n      global.requestAnimationFrame(function cb() {\n        runOrder.push('animationFrame');\n        global.requestAnimationFrame(cb);\n      });\n\n      timers.runOnlyPendingTimers();\n      expect(runOrder).toEqual([\n        'mock4',\n        'mock5',\n        'mock2',\n        'animationFrame',\n        'mock1',\n        'mock3',\n      ]);\n\n      timers.runOnlyPendingTimers();\n      expect(runOrder).toEqual([\n        'mock4',\n        'mock5',\n        'mock2',\n        'animationFrame',\n        'mock1',\n        'mock3',\n\n        'mock2',\n        'animationFrame',\n        'mock1',\n        'mock3',\n        'mock5',\n      ]);\n    });\n\n    it('does not run timers that were cleared in another timer', () => {\n      const global = {process} as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      const fn = jest.fn();\n      const timer = global.setTimeout(fn, 10);\n      global.setTimeout(() => {\n        global.clearTimeout(timer);\n      }, 0);\n\n      timers.runOnlyPendingTimers();\n      expect(fn).not.toHaveBeenCalled();\n    });\n  });\n\n  describe('runWithRealTimers', () => {\n    it('executes callback with native timers', () => {\n      const nativeClearInterval = jest.fn();\n      const nativeClearTimeout = jest.fn();\n      const nativeSetInterval = jest.fn();\n      const nativeSetTimeout = jest.fn();\n\n      const global = {\n        clearInterval: nativeClearInterval,\n        clearTimeout: nativeClearTimeout,\n        process,\n        setInterval: nativeSetInterval,\n        setTimeout: nativeSetTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      // clearInterval()\n      timers.runWithRealTimers(() => {\n        (global as any).clearInterval();\n      });\n      expect(nativeClearInterval).toHaveBeenCalledTimes(1);\n      expect(global.clearInterval).toHaveBeenCalledTimes(0);\n\n      // clearTimeout()\n      timers.runWithRealTimers(() => {\n        (global as any).clearTimeout();\n      });\n      expect(nativeClearTimeout).toHaveBeenCalledTimes(1);\n      expect(global.clearTimeout).toHaveBeenCalledTimes(0);\n\n      // setInterval()\n      timers.runWithRealTimers(() => {\n        (global as any).setInterval();\n      });\n      expect(nativeSetInterval).toHaveBeenCalledTimes(1);\n      expect(global.setInterval).toHaveBeenCalledTimes(0);\n\n      // setTimeout()\n      timers.runWithRealTimers(() => {\n        (global as any).setTimeout();\n      });\n      expect(nativeSetTimeout).toHaveBeenCalledTimes(1);\n      expect(global.setTimeout).toHaveBeenCalledTimes(0);\n    });\n\n    it('resets mock timers after executing callback', () => {\n      const nativeClearInterval = jest.fn();\n      const nativeClearTimeout = jest.fn();\n      const nativeSetInterval = jest.fn();\n      const nativeSetTimeout = jest.fn();\n\n      const global = {\n        clearInterval: nativeClearInterval,\n        clearTimeout: nativeClearTimeout,\n        process,\n        setInterval: nativeSetInterval,\n        setTimeout: nativeSetTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      // clearInterval()\n      timers.runWithRealTimers(() => {\n        (global as any).clearInterval();\n      });\n      expect(nativeClearInterval).toHaveBeenCalledTimes(1);\n      expect(global.clearInterval).toHaveBeenCalledTimes(0);\n\n      (global as any).clearInterval();\n      expect(nativeClearInterval).toHaveBeenCalledTimes(1);\n      expect(global.clearInterval).toHaveBeenCalledTimes(1);\n\n      // clearTimeout()\n      timers.runWithRealTimers(() => {\n        (global as any).clearTimeout();\n      });\n      expect(nativeClearTimeout).toHaveBeenCalledTimes(1);\n      expect(global.clearTimeout).toHaveBeenCalledTimes(0);\n\n      (global as any).clearTimeout();\n      expect(nativeClearTimeout).toHaveBeenCalledTimes(1);\n      expect(global.clearTimeout).toHaveBeenCalledTimes(1);\n\n      // setInterval()\n      timers.runWithRealTimers(() => {\n        (global as any).setInterval();\n      });\n      expect(nativeSetInterval).toHaveBeenCalledTimes(1);\n      expect(global.setInterval).toHaveBeenCalledTimes(0);\n\n      (global as any).setInterval();\n      expect(nativeSetInterval).toHaveBeenCalledTimes(1);\n      expect(global.setInterval).toHaveBeenCalledTimes(1);\n\n      // setTimeout()\n      timers.runWithRealTimers(() => {\n        (global as any).setTimeout();\n      });\n      expect(nativeSetTimeout).toHaveBeenCalledTimes(1);\n      expect(global.setTimeout).toHaveBeenCalledTimes(0);\n\n      (global as any).setTimeout();\n      expect(nativeSetTimeout).toHaveBeenCalledTimes(1);\n      expect(global.setTimeout).toHaveBeenCalledTimes(1);\n    });\n\n    it('resets mock timer functions even if callback throws', () => {\n      const nativeSetTimeout = jest.fn();\n      const global = {\n        process,\n        setTimeout: nativeSetTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      expect(() => {\n        timers.runWithRealTimers(() => {\n          (global as any).setTimeout();\n          throw new Error('test');\n        });\n      }).toThrow(new Error('test'));\n      expect(nativeSetTimeout).toHaveBeenCalledTimes(1);\n      expect(global.setTimeout).toHaveBeenCalledTimes(0);\n\n      (global as any).setTimeout();\n      expect(nativeSetTimeout).toHaveBeenCalledTimes(1);\n      expect(global.setTimeout).toHaveBeenCalledTimes(1);\n    });\n  });\n\n  describe('useRealTimers', () => {\n    it('resets native timer APIs', () => {\n      const nativeSetTimeout = jest.fn();\n      const nativeSetInterval = jest.fn();\n      const nativeClearTimeout = jest.fn();\n      const nativeClearInterval = jest.fn();\n\n      const global = {\n        clearInterval: nativeClearInterval,\n        clearTimeout: nativeClearTimeout,\n        process,\n        setInterval: nativeSetInterval,\n        setTimeout: nativeSetTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      // Ensure that timers has overridden the native timer APIs\n      // (because if it didn't, this test might pass when it shouldn't)\n      expect(global.setTimeout).not.toBe(nativeSetTimeout);\n      expect(global.setInterval).not.toBe(nativeSetInterval);\n      expect(global.clearTimeout).not.toBe(nativeClearTimeout);\n      expect(global.clearInterval).not.toBe(nativeClearInterval);\n\n      timers.useRealTimers();\n\n      expect(global.setTimeout).toBe(nativeSetTimeout);\n      expect(global.setInterval).toBe(nativeSetInterval);\n      expect(global.clearTimeout).toBe(nativeClearTimeout);\n      expect(global.clearInterval).toBe(nativeClearInterval);\n    });\n\n    it('resets native process.nextTick when present', () => {\n      const nativeProcessNextTick = jest.fn();\n\n      const global = {\n        process: {nextTick: nativeProcessNextTick},\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      // Ensure that timers has overridden the native timer APIs\n      // (because if it didn't, this test might pass when it shouldn't)\n      expect(global.process.nextTick).not.toBe(nativeProcessNextTick);\n\n      timers.useRealTimers();\n\n      expect(global.process.nextTick).toBe(nativeProcessNextTick);\n    });\n\n    it('resets native setImmediate when present', () => {\n      const nativeSetImmediate = jest.fn<typeof setImmediate>();\n      const nativeClearImmediate = jest.fn<typeof clearImmediate>();\n\n      const global = {\n        clearImmediate: nativeClearImmediate,\n        process,\n        setImmediate: nativeSetImmediate,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      // Ensure that timers has overridden the native timer APIs\n      // (because if it didn't, this test might pass when it shouldn't)\n      expect(global.setImmediate).not.toBe(nativeSetImmediate);\n      expect(global.clearImmediate).not.toBe(nativeClearImmediate);\n\n      timers.useRealTimers();\n\n      expect(global.setImmediate).toBe(nativeSetImmediate);\n      expect(global.clearImmediate).toBe(nativeClearImmediate);\n    });\n\n    it('resets native requestAnimationFrame when present', () => {\n      const nativeCancelAnimationFrame = jest.fn();\n      const nativeRequestAnimationFrame = jest.fn();\n\n      const global = {\n        cancelAnimationFrame: nativeCancelAnimationFrame,\n        process,\n        requestAnimationFrame: nativeRequestAnimationFrame,\n      } as unknown as typeof globalThis & Window;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      // Ensure that timers has overridden the native timer APIs\n      // (because if it didn't, this test might pass when it shouldn't)\n      expect(global.cancelAnimationFrame).not.toBe(nativeCancelAnimationFrame);\n      expect(global.requestAnimationFrame).not.toBe(\n        nativeRequestAnimationFrame,\n      );\n\n      timers.useRealTimers();\n\n      expect(global.cancelAnimationFrame).toBe(nativeCancelAnimationFrame);\n      expect(global.requestAnimationFrame).toBe(nativeRequestAnimationFrame);\n    });\n  });\n\n  describe('useFakeTimers', () => {\n    it('resets mock timer APIs', () => {\n      const nativeSetTimeout = jest.fn();\n      const nativeSetInterval = jest.fn();\n      const nativeClearTimeout = jest.fn();\n      const nativeClearInterval = jest.fn();\n\n      const global = {\n        clearInterval: nativeClearInterval,\n        clearTimeout: nativeClearTimeout,\n        process,\n        setInterval: nativeSetInterval,\n        setTimeout: nativeSetTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useRealTimers();\n\n      // Ensure that the real timers are installed at this point\n      // (because if they aren't, this test might pass when it shouldn't)\n      expect(global.setTimeout).toBe(nativeSetTimeout);\n      expect(global.setInterval).toBe(nativeSetInterval);\n      expect(global.clearTimeout).toBe(nativeClearTimeout);\n      expect(global.clearInterval).toBe(nativeClearInterval);\n\n      timers.useFakeTimers();\n\n      expect(global.setTimeout).not.toBe(nativeSetTimeout);\n      expect(global.setInterval).not.toBe(nativeSetInterval);\n      expect(global.clearTimeout).not.toBe(nativeClearTimeout);\n      expect(global.clearInterval).not.toBe(nativeClearInterval);\n    });\n\n    it('resets mock process.nextTick when present', () => {\n      const nativeProcessNextTick = jest.fn();\n\n      const global = {\n        process: {nextTick: nativeProcessNextTick},\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useRealTimers();\n\n      // Ensure that the real timers are installed at this point\n      // (because if they aren't, this test might pass when it shouldn't)\n      expect(global.process.nextTick).toBe(nativeProcessNextTick);\n\n      timers.useFakeTimers();\n\n      expect(global.process.nextTick).not.toBe(nativeProcessNextTick);\n    });\n\n    it('resets mock setImmediate when present', () => {\n      const nativeSetImmediate = jest.fn<typeof setImmediate>();\n      const nativeClearImmediate = jest.fn<typeof clearImmediate>();\n\n      const global = {\n        clearImmediate: nativeClearImmediate,\n        process,\n        setImmediate: nativeSetImmediate,\n      } as unknown as typeof globalThis;\n      const fakeTimers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      fakeTimers.useRealTimers();\n\n      // Ensure that the real timers are installed at this point\n      // (because if they aren't, this test might pass when it shouldn't)\n      expect(global.setImmediate).toBe(nativeSetImmediate);\n      expect(global.clearImmediate).toBe(nativeClearImmediate);\n\n      fakeTimers.useFakeTimers();\n\n      expect(global.setImmediate).not.toBe(nativeSetImmediate);\n      expect(global.clearImmediate).not.toBe(nativeClearImmediate);\n    });\n\n    it('resets mock requestAnimationFrame when present', () => {\n      const nativeCancelAnimationFrame = jest.fn();\n      const nativeRequestAnimationFrame = jest.fn();\n\n      const global = {\n        cancelAnimationFrame: nativeCancelAnimationFrame,\n        process,\n        requestAnimationFrame: nativeRequestAnimationFrame,\n      } as unknown as typeof globalThis & Window;\n      const fakeTimers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      fakeTimers.useRealTimers();\n\n      // Ensure that the real timers are installed at this point\n      // (because if they aren't, this test might pass when it shouldn't)\n      expect(global.cancelAnimationFrame).toBe(nativeCancelAnimationFrame);\n      expect(global.requestAnimationFrame).toBe(nativeRequestAnimationFrame);\n\n      fakeTimers.useFakeTimers();\n\n      expect(global.cancelAnimationFrame).not.toBe(nativeCancelAnimationFrame);\n      expect(global.requestAnimationFrame).not.toBe(\n        nativeRequestAnimationFrame,\n      );\n    });\n  });\n\n  describe('getTimerCount', () => {\n    let timers: FakeTimers<number>;\n    let fakedGlobal: typeof globalThis;\n\n    beforeEach(() => {\n      fakedGlobal = {\n        Date,\n        cancelAnimationFrame: () => {},\n        clearTimeout,\n        process,\n        requestAnimationFrame: () => {},\n        setImmediate,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      timers = new FakeTimers({\n        config,\n        global: fakedGlobal,\n        moduleMocker,\n        timerConfig,\n      });\n    });\n\n    it('returns the correct count', () => {\n      timers.useFakeTimers();\n\n      fakedGlobal.setTimeout(() => {}, 0);\n      fakedGlobal.setTimeout(() => {}, 0);\n      fakedGlobal.setTimeout(() => {}, 10);\n\n      expect(timers.getTimerCount()).toBe(3);\n\n      timers.advanceTimersByTime(5);\n\n      expect(timers.getTimerCount()).toBe(1);\n\n      timers.advanceTimersByTime(5);\n\n      expect(timers.getTimerCount()).toBe(0);\n    });\n\n    it('includes immediates and ticks', () => {\n      timers.useFakeTimers();\n\n      fakedGlobal.setTimeout(() => {}, 0);\n      fakedGlobal.setImmediate(() => {});\n      process.nextTick(() => {});\n\n      expect(timers.getTimerCount()).toBe(3);\n    });\n\n    it('not includes cancelled immediates', () => {\n      timers.useFakeTimers();\n\n      fakedGlobal.setImmediate(() => {});\n      expect(timers.getTimerCount()).toBe(1);\n      timers.clearAllTimers();\n\n      expect(timers.getTimerCount()).toBe(0);\n    });\n\n    it('includes animation frames', () => {\n      timers.useFakeTimers();\n\n      fakedGlobal.requestAnimationFrame(() => {});\n      expect(timers.getTimerCount()).toBe(1);\n      timers.clearAllTimers();\n\n      expect(timers.getTimerCount()).toBe(0);\n    });\n  });\n\n  describe('now', () => {\n    let timers: FakeTimers<number>;\n    let fakedGlobal: typeof globalThis;\n\n    beforeEach(() => {\n      fakedGlobal = {\n        Date,\n        clearTimeout,\n        process,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      timers = new FakeTimers({\n        config,\n        global: fakedGlobal,\n        moduleMocker,\n        timerConfig,\n      });\n    });\n\n    it('returns the current clock', () => {\n      timers.useFakeTimers();\n      fakedGlobal.setTimeout(() => {}, 2);\n      fakedGlobal.setTimeout(() => {}, 100);\n\n      expect(timers.now()).toBe(0);\n\n      // This should run the 2ms timer, and then advance _now by 3ms\n      timers.advanceTimersByTime(5);\n      expect(timers.now()).toBe(5);\n\n      // Advance _now even though there are no timers to run\n      timers.advanceTimersByTime(5);\n      expect(timers.now()).toBe(10);\n\n      // Run up to the 100ms timer\n      timers.runAllTimers();\n      expect(timers.now()).toBe(100);\n\n      // Verify that runOnlyPendingTimers advances now only up to the first\n      // recursive timer\n      fakedGlobal.setTimeout(function infinitelyRecursingCallback() {\n        fakedGlobal.setTimeout(infinitelyRecursingCallback, 20);\n      }, 10);\n      timers.runOnlyPendingTimers();\n      expect(timers.now()).toBe(110);\n\n      // For legacy timers, reset() sets the clock to 0\n      timers.reset();\n      expect(timers.now()).toBe(0);\n    });\n\n    it('returns the real time if useFakeTimers is not called', () => {\n      const before = Date.now();\n      const now = timers.now();\n      const after = Date.now();\n      expect(now).toBeGreaterThanOrEqual(before);\n      expect(now).toBeLessThanOrEqual(after);\n    });\n  });\n});\n",
  "packages/jest-fake-timers/src/__tests__/legacyFakeTimers.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-expect/src/types.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {AsymmetricMatchers, BaseExpect, Inverse, Matchers} from 'expect';\nimport type {\n  SnapshotMatchers,\n  SnapshotState,\n  addSerializer,\n} from 'jest-snapshot';\n\nexport type JestExpect = {\n  <T = unknown>(\n    actual: T,\n  ): JestMatchers<void, T> &\n    Inverse<JestMatchers<void, T>> &\n    PromiseMatchers<T>;\n  // Duplicated due to https://github.com/microsoft/rushstack/issues/1709\n  addSnapshotSerializer: typeof addSerializer;\n} & BaseExpect &\n  AsymmetricMatchers &\n  Inverse<Omit<AsymmetricMatchers, 'any' | 'anything'>>;\n\ntype JestMatchers<R extends void | Promise<void>, T> = Matchers<R, T> &\n  SnapshotMatchers<R, T>;\n\ntype PromiseMatchers<T = unknown> = {\n  /**\n   * Unwraps the reason of a rejected promise so any other matcher can be chained.\n   * If the promise is fulfilled the assertion fails.\n   */\n  rejects: JestMatchers<Promise<void>, T> &\n    Inverse<JestMatchers<Promise<void>, T>>;\n  /**\n   * Unwraps the value of a fulfilled promise so any other matcher can be chained.\n   * If the promise is rejected the assertion fails.\n   */\n  resolves: JestMatchers<Promise<void>, T> &\n    Inverse<JestMatchers<Promise<void>, T>>;\n};\n\ndeclare module 'expect' {\n  interface MatcherState {\n    snapshotState: SnapshotState;\n    /** Whether the test was called with `test.failing()` */\n    testFailing?: boolean;\n  }\n  interface BaseExpect {\n    addSnapshotSerializer: typeof addSerializer;\n  }\n}\n",
  "packages/jest-expect/src/types.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { AsymmetricMatchers, BaseExpect, Inverse, Matchers } from 'expect';\nimport type { SnapshotMatchers, SnapshotState, addSerializer } from 'jest-snapshot';\nexport type JestExpect = {\n    <T = unknown>(actual: T): JestMatchers<void, T> & Inverse<JestMatchers<void, T>> & PromiseMatchers<T>;\n    addSnapshotSerializer: typeof addSerializer;\n} & BaseExpect & AsymmetricMatchers & Inverse<Omit<AsymmetricMatchers, 'any' | 'anything'>>;\ntype JestMatchers<R extends void | Promise<void>, T> = Matchers<R, T> & SnapshotMatchers<R, T>;\ntype PromiseMatchers<T = unknown> = {\n    /**\n     * Unwraps the reason of a rejected promise so any other matcher can be chained.\n     * If the promise is fulfilled the assertion fails.\n     */\n    rejects: JestMatchers<Promise<void>, T> & Inverse<JestMatchers<Promise<void>, T>>;\n    /**\n     * Unwraps the value of a fulfilled promise so any other matcher can be chained.\n     * If the promise is rejected the assertion fails.\n     */\n    resolves: JestMatchers<Promise<void>, T> & Inverse<JestMatchers<Promise<void>, T>>;\n};\ndeclare module 'expect' {\n    interface MatcherState {\n        snapshotState: SnapshotState;\n        /** Whether the test was called with `test.failing()` */\n        testFailing?: boolean;\n    }\n    interface BaseExpect {\n        addSnapshotSerializer: typeof addSerializer;\n    }\n}\nexport {};\n",
  "packages/jest-expect/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {expect} from 'expect';\nimport {\n  addSerializer,\n  toMatchInlineSnapshot,\n  toMatchSnapshot,\n  toThrowErrorMatchingInlineSnapshot,\n  toThrowErrorMatchingSnapshot,\n} from 'jest-snapshot';\nimport type {JestExpect} from './types';\n\nexport type {\n  AsymmetricMatchers,\n  Matchers,\n  MatcherContext,\n  MatcherFunction,\n  MatcherFunctionWithContext,\n  MatcherState,\n  MatcherUtils,\n} from 'expect';\nexport type {JestExpect} from './types';\n\nfunction createJestExpect(): JestExpect {\n  expect.extend({\n    toMatchInlineSnapshot,\n    toMatchSnapshot,\n    toThrowErrorMatchingInlineSnapshot,\n    toThrowErrorMatchingSnapshot,\n  });\n\n  expect.addSnapshotSerializer = addSerializer;\n\n  return expect as JestExpect;\n}\n\nexport const jestExpect = createJestExpect();\n",
  "packages/jest-expect/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport type { AsymmetricMatchers, Matchers, MatcherContext, MatcherFunction, MatcherFunctionWithContext, MatcherState, MatcherUtils, } from 'expect';\nexport type { JestExpect } from './types';\nexport declare const jestExpect: any;\n",
  "packages/jest-expect/__typetests__/jest-expect.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {describe, expect, test} from 'tstyche';\nimport {jestExpect} from '@jest/expect';\nimport {expect as _expect} from 'expect';\n\ndeclare module 'expect' {\n  interface Matchers<R, T> {\n    toTypedEqual(expected: T): void;\n  }\n}\n\ndescribe('JestExpect', () => {\n  test('defines the `.toMatchSnapshot()` matcher', () => {\n    expect(jestExpect(null)).type.toHaveProperty('toMatchSnapshot');\n\n    expect(_expect(null)).type.not.toHaveProperty('toMatchSnapshot');\n  });\n\n  test('defines the `.addSnapshotSerializer()` method', () => {\n    expect(jestExpect).type.toHaveProperty('addSnapshotSerializer');\n\n    expect(_expect).type.not.toHaveProperty('addSnapshotSerializer');\n  });\n\n  test('is superset of `Expect`', () => {\n    expect(jestExpect).type.toBeAssignableTo(_expect);\n\n    expect(_expect).type.not.toBeAssignableTo(jestExpect);\n  });\n\n  test('allows type inference of the `actual` argument', () => {\n    expect(jestExpect(100).toTypedEqual(100)).type.toBe<void>();\n    expect(jestExpect(101).not.toTypedEqual(100)).type.toBe<void>();\n\n    expect(jestExpect(100).toTypedEqual).type.not.toBeCallableWith('three');\n  });\n});\n",
  "packages/jest-expect/__typetests__/jest-expect.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\ndeclare module 'expect' {\n    interface Matchers<R, T> {\n        toTypedEqual(expected: T): void;\n    }\n}\nexport {};\n",
  "packages/jest-environment-node/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {type Context, createContext, runInContext} from 'vm';\nimport type {\n  EnvironmentContext,\n  JestEnvironment,\n  JestEnvironmentConfig,\n} from '@jest/environment';\nimport {LegacyFakeTimers, ModernFakeTimers} from '@jest/fake-timers';\nimport type {Config, Global} from '@jest/types';\nimport {ModuleMocker} from 'jest-mock';\nimport {\n  type DeletionMode,\n  canDeleteProperties,\n  deleteProperties,\n  initializeGarbageCollectionUtils,\n  installCommonGlobals,\n  protectProperties,\n} from 'jest-util';\nimport {logValidationWarning} from 'jest-validate';\n\ntype Timer = {\n  id: number;\n  ref: () => Timer;\n  unref: () => Timer;\n};\n\n// some globals we do not want, either because deprecated or we set it ourselves\nconst denyList = new Set([\n  'GLOBAL',\n  'root',\n  'global',\n  'globalThis',\n  'Buffer',\n  'ArrayBuffer',\n  'Uint8Array',\n  // if env is loaded within a jest test\n  'jest-symbol-do-not-touch',\n]);\n\ntype GlobalProperties = Array<keyof typeof globalThis>;\n\nconst nodeGlobals = new Map(\n  (Object.getOwnPropertyNames(globalThis) as GlobalProperties)\n    .filter(global => !denyList.has(global as string))\n    .map(nodeGlobalsKey => {\n      const descriptor = Object.getOwnPropertyDescriptor(\n        globalThis,\n        nodeGlobalsKey,\n      );\n\n      if (!descriptor) {\n        throw new Error(\n          `No property descriptor for ${nodeGlobalsKey}, this is a bug in Jest.`,\n        );\n      }\n\n      return [nodeGlobalsKey, descriptor];\n    }),\n);\n\nfunction isString(value: unknown): value is string {\n  return typeof value === 'string';\n}\n\nconst timerIdToRef = (id: number) => ({\n  id,\n  ref() {\n    return this;\n  },\n  unref() {\n    return this;\n  },\n});\n\nconst timerRefToId = (timer: Timer): number | undefined => timer?.id;\n\nexport default class NodeEnvironment implements JestEnvironment<Timer> {\n  context: Context | null;\n  fakeTimers: LegacyFakeTimers<Timer> | null;\n  fakeTimersModern: ModernFakeTimers | null;\n  global: Global.Global;\n  moduleMocker: ModuleMocker | null;\n  customExportConditions = ['node', 'node-addons'];\n  private readonly _configuredExportConditions?: Array<string>;\n  private _globalProxy: GlobalProxy;\n\n  // while `context` is unused, it should always be passed\n  constructor(config: JestEnvironmentConfig, _context: EnvironmentContext) {\n    const {projectConfig} = config;\n\n    const globalsCleanupMode = readGlobalsCleanupConfig(projectConfig);\n    initializeGarbageCollectionUtils(globalThis, globalsCleanupMode);\n\n    this._globalProxy = new GlobalProxy();\n    this.context = createContext(this._globalProxy.proxy());\n    const global = runInContext(\n      'this',\n      Object.assign(this.context, projectConfig.testEnvironmentOptions),\n    ) as Global.Global;\n    this.global = global;\n\n    const contextGlobals = new Set(\n      Object.getOwnPropertyNames(global) as GlobalProperties,\n    );\n    for (const [nodeGlobalsKey, descriptor] of nodeGlobals) {\n      protectProperties(globalThis[nodeGlobalsKey]);\n      if (!contextGlobals.has(nodeGlobalsKey)) {\n        if (descriptor.configurable) {\n          Object.defineProperty(global, nodeGlobalsKey, {\n            configurable: true,\n            enumerable: descriptor.enumerable,\n            get() {\n              const value = globalThis[nodeGlobalsKey];\n\n              // override lazy getter\n              Object.defineProperty(global, nodeGlobalsKey, {\n                configurable: true,\n                enumerable: descriptor.enumerable,\n                value,\n                writable: true,\n              });\n\n              return value;\n            },\n            set(value: unknown) {\n              // override lazy getter\n              Object.defineProperty(global, nodeGlobalsKey, {\n                configurable: true,\n                enumerable: descriptor.enumerable,\n                value,\n                writable: true,\n              });\n            },\n          });\n        } else if ('value' in descriptor) {\n          Object.defineProperty(global, nodeGlobalsKey, {\n            configurable: false,\n            enumerable: descriptor.enumerable,\n            value: descriptor.value,\n            writable: descriptor.writable,\n          });\n        } else {\n          Object.defineProperty(global, nodeGlobalsKey, {\n            configurable: false,\n            enumerable: descriptor.enumerable,\n            get: descriptor.get,\n            set: descriptor.set,\n          });\n        }\n      }\n    }\n\n    global.global = global;\n    global.Buffer = Buffer;\n    global.ArrayBuffer = ArrayBuffer;\n    // TextEncoder (global or via 'util') references a Uint8Array constructor\n    // different than the global one used by users in tests. This makes sure the\n    // same constructor is referenced by both.\n    global.Uint8Array = Uint8Array;\n\n    installCommonGlobals(global, projectConfig.globals, globalsCleanupMode);\n\n    if ('asyncDispose' in Symbol && !('asyncDispose' in global.Symbol)) {\n      const globalSymbol = global.Symbol as unknown as SymbolConstructor;\n      // @ts-expect-error - it's readonly - but we have checked above that it's not there\n      globalSymbol.asyncDispose = globalSymbol.for('nodejs.asyncDispose');\n      // @ts-expect-error - it's readonly - but we have checked above that it's not there\n      globalSymbol.dispose = globalSymbol.for('nodejs.dispose');\n    }\n\n    // Node's error-message stack size is limited at 10, but it's pretty useful\n    // to see more than that when a test fails.\n    global.Error.stackTraceLimit = 100;\n\n    if ('customExportConditions' in projectConfig.testEnvironmentOptions) {\n      const {customExportConditions} = projectConfig.testEnvironmentOptions;\n      if (\n        Array.isArray(customExportConditions) &&\n        customExportConditions.every(isString)\n      ) {\n        this._configuredExportConditions = customExportConditions;\n      } else {\n        throw new Error(\n          'Custom export conditions specified but they are not an array of strings',\n        );\n      }\n    }\n\n    this.moduleMocker = new ModuleMocker(global);\n\n    this.fakeTimers = new LegacyFakeTimers({\n      config: projectConfig,\n      global,\n      moduleMocker: this.moduleMocker,\n      timerConfig: {\n        idToRef: timerIdToRef,\n        refToId: timerRefToId,\n      },\n    });\n\n    this.fakeTimersModern = new ModernFakeTimers({\n      config: projectConfig,\n      global,\n    });\n\n    this._globalProxy.envSetupCompleted();\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  async setup(): Promise<void> {}\n\n  async teardown(): Promise<void> {\n    if (this.fakeTimers) {\n      this.fakeTimers.dispose();\n    }\n    if (this.fakeTimersModern) {\n      this.fakeTimersModern.dispose();\n    }\n    this.context = null;\n    this.fakeTimers = null;\n    this.fakeTimersModern = null;\n    this._globalProxy.clear();\n  }\n\n  exportConditions(): Array<string> {\n    return this._configuredExportConditions ?? this.customExportConditions;\n  }\n\n  getVmContext(): Context | null {\n    return this.context;\n  }\n}\n\nexport const TestEnvironment = NodeEnvironment;\n\n/**\n * Creates a new empty global object and wraps it with a {@link Proxy}.\n *\n * The purpose is to register any property set on the global object,\n * and {@link #deleteProperties} on them at environment teardown,\n * to clean up memory and prevent leaks.\n */\nclass GlobalProxy implements ProxyHandler<typeof globalThis> {\n  private global: typeof globalThis = Object.create(\n    Object.getPrototypeOf(globalThis),\n  );\n  private globalProxy: typeof globalThis = new Proxy(this.global, this);\n  private isEnvSetup = false;\n  private propertyToValue = new Map<string | symbol, unknown>();\n  private leftovers: Array<{property: string | symbol; value: unknown}> = [];\n\n  constructor() {\n    this.register = this.register.bind(this);\n  }\n\n  proxy(): typeof globalThis {\n    return this.globalProxy;\n  }\n\n  /**\n   * Marks that the environment setup has completed, and properties set on\n   * the global object from now on should be deleted at teardown.\n   */\n  envSetupCompleted(): void {\n    this.isEnvSetup = true;\n  }\n\n  /**\n   * Deletes any property that was set on the global object, except for:\n   * 1. Properties that were set before {@link #envSetupCompleted} was invoked.\n   * 2. Properties protected by {@link #protectProperties}.\n   */\n  clear(): void {\n    for (const {value} of [\n      ...[...this.propertyToValue.entries()].map(([property, value]) => ({\n        property,\n        value,\n      })),\n      ...this.leftovers,\n    ]) {\n      deleteProperties(value);\n    }\n    this.propertyToValue.clear();\n    this.leftovers = [];\n    this.global = {} as typeof globalThis;\n    this.globalProxy = {} as typeof globalThis;\n  }\n\n  defineProperty(\n    target: typeof globalThis,\n    property: string | symbol,\n    attributes: PropertyDescriptor,\n  ): boolean {\n    const newAttributes = {...attributes};\n\n    if ('set' in newAttributes && newAttributes.set !== undefined) {\n      const originalSet = newAttributes.set;\n      const register = this.register;\n      newAttributes.set = value => {\n        originalSet(value);\n        const newValue = Reflect.get(target, property);\n        register(property, newValue);\n      };\n    }\n\n    const result = Reflect.defineProperty(target, property, newAttributes);\n\n    if ('value' in newAttributes) {\n      this.register(property, newAttributes.value);\n    }\n\n    return result;\n  }\n\n  deleteProperty(\n    target: typeof globalThis,\n    property: string | symbol,\n  ): boolean {\n    const result = Reflect.deleteProperty(target, property);\n    const value = this.propertyToValue.get(property);\n    if (value) {\n      this.leftovers.push({property, value});\n      this.propertyToValue.delete(property);\n    }\n    return result;\n  }\n\n  private register(property: string | symbol, value: unknown) {\n    const currentValue = this.propertyToValue.get(property);\n    if (value !== currentValue) {\n      if (!this.isEnvSetup && canDeleteProperties(value)) {\n        protectProperties(value);\n      }\n      if (currentValue) {\n        this.leftovers.push({property, value: currentValue});\n      }\n\n      this.propertyToValue.set(property, value);\n    }\n  }\n}\n\nfunction readGlobalsCleanupConfig(\n  projectConfig: Config.ProjectConfig,\n): DeletionMode {\n  const rawConfig = projectConfig.testEnvironmentOptions.globalsCleanup;\n  const config = rawConfig?.toString()?.toLowerCase();\n  switch (config) {\n    case 'off':\n    case 'on':\n    case 'soft':\n      return config;\n    default: {\n      if (config !== undefined) {\n        logValidationWarning(\n          'testEnvironmentOptions.globalsCleanup',\n          `Unknown value given: ${rawConfig}`,\n          'Available options are: [on, soft, off]',\n        );\n      }\n      return 'soft';\n    }\n  }\n}\n",
  "packages/jest-environment-node/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { type Context } from 'vm';\nimport type { EnvironmentContext, JestEnvironment, JestEnvironmentConfig } from '@jest/environment';\nimport { LegacyFakeTimers, ModernFakeTimers } from '@jest/fake-timers';\nimport type { Global } from '@jest/types';\nimport { ModuleMocker } from 'jest-mock';\ntype Timer = {\n    id: number;\n    ref: () => Timer;\n    unref: () => Timer;\n};\nexport default class NodeEnvironment implements JestEnvironment<Timer> {\n    context: Context | null;\n    fakeTimers: LegacyFakeTimers<Timer> | null;\n    fakeTimersModern: ModernFakeTimers | null;\n    global: Global.Global;\n    moduleMocker: ModuleMocker | null;\n    customExportConditions: string[];\n    private readonly _configuredExportConditions?;\n    private _globalProxy;\n    constructor(config: JestEnvironmentConfig, _context: EnvironmentContext);\n    setup(): Promise<void>;\n    teardown(): Promise<void>;\n    exportConditions(): Array<string>;\n    getVmContext(): Context | null;\n}\nexport declare const TestEnvironment: typeof NodeEnvironment;\nexport {};\n",
  "packages/jest-environment-node/src/__tests__/node_environment.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {EnvironmentContext} from '@jest/environment';\nimport {makeGlobalConfig, makeProjectConfig} from '@jest/test-utils';\nimport NodeEnvironment from '../';\n\nconst context: EnvironmentContext = {\n  console,\n  docblockPragmas: {},\n  testPath: __filename,\n};\n\ndescribe('NodeEnvironment', () => {\n  it('uses a copy of the process object', () => {\n    const testEnvConfig = {\n      globalConfig: makeGlobalConfig(),\n      projectConfig: makeProjectConfig(),\n    };\n    const env1 = new NodeEnvironment(testEnvConfig, context);\n    const env2 = new NodeEnvironment(testEnvConfig, context);\n\n    expect(env1.global.process).not.toBe(env2.global.process);\n  });\n\n  it('exposes process.on', () => {\n    const env1 = new NodeEnvironment(\n      {\n        globalConfig: makeGlobalConfig(),\n        projectConfig: makeProjectConfig(),\n      },\n      context,\n    );\n\n    expect(env1.global.process.on).not.toBeNull();\n  });\n\n  it('exposes global.global', () => {\n    const env1 = new NodeEnvironment(\n      {\n        globalConfig: makeGlobalConfig(),\n        projectConfig: makeProjectConfig(),\n      },\n      context,\n    );\n\n    expect(env1.global.global).toBe(env1.global);\n  });\n\n  it('should configure setTimeout/setInterval to use the node api', () => {\n    const env1 = new NodeEnvironment(\n      {\n        globalConfig: makeGlobalConfig(),\n        projectConfig: makeProjectConfig(),\n      },\n      context,\n    );\n\n    env1.fakeTimers!.useFakeTimers();\n\n    const timer1 = env1.global.setTimeout(() => {}, 0);\n    const timer2 = env1.global.setInterval(() => {}, 0);\n\n    for (const timer of [timer1, timer2]) {\n      expect(timer.id).toBeDefined();\n      expect(typeof timer.ref).toBe('function');\n      expect(typeof timer.unref).toBe('function');\n    }\n  });\n\n  it('has modern fake timers implementation', () => {\n    const env = new NodeEnvironment(\n      {\n        globalConfig: makeGlobalConfig(),\n        projectConfig: makeProjectConfig(),\n      },\n      context,\n    );\n\n    expect(env.fakeTimersModern).toBeDefined();\n  });\n\n  test('TextEncoder references the same global Uint8Array constructor', () => {\n    expect(new TextEncoder().encode('abc')).toBeInstanceOf(Uint8Array);\n  });\n});\n",
  "packages/jest-environment-node/src/__tests__/node_environment.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-environment-node/src/__tests__/globals_cleanup_3.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ndescribe('Globals Cleanup 3', () => {\n  test('assign Object prototype descriptors to a new empty object', () => {\n    const descriptors = Object.getOwnPropertyDescriptors(\n      Object.getPrototypeOf({}),\n    );\n    Object.assign({}, descriptors);\n  });\n});\n",
  "packages/jest-environment-node/src/__tests__/globals_cleanup_3.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n",
  "packages/jest-environment-node/src/__tests__/globals_cleanup_2.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {AsyncLocalStorage, createHook} from 'async_hooks';\nimport {clsx} from 'clsx';\nimport {onNodeVersions} from '@jest/test-utils';\n\ndescribe('Globals Cleanup 2', () => {\n  test('dispatch event', () => {\n    new EventTarget().dispatchEvent(new Event('foo'));\n  });\n\n  test('set modules on global', () => {\n    (globalThis as any).async_hooks = require('async_hooks');\n    (globalThis as any).AsyncLocalStorage =\n      require('async_hooks').AsyncLocalStorage;\n    (globalThis as any).createHook = require('async_hooks').createHook;\n    (globalThis as any).clsx = require('clsx');\n    expect(AsyncLocalStorage).toBeDefined();\n    expect(clsx).toBeDefined();\n    expect(createHook).toBeDefined();\n    expect(createHook({})).toBeDefined();\n    expect(clsx()).toBeDefined();\n  });\n\n  onNodeVersions('>=19.8.0', () => {\n    test('use static function from core module set on global', () => {\n      expect(AsyncLocalStorage.snapshot).toBeDefined();\n      expect(AsyncLocalStorage.snapshot()).toBeDefined();\n    });\n  });\n});\n",
  "packages/jest-environment-node/src/__tests__/globals_cleanup_2.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-environment-node/src/__tests__/globals_cleanup_1.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {AsyncLocalStorage, createHook} from 'async_hooks';\nimport {clsx} from 'clsx';\nimport {onNodeVersions} from '@jest/test-utils';\n\ndescribe('Globals Cleanup 1', () => {\n  test('dispatch event', () => {\n    new EventTarget().dispatchEvent(new Event('foo'));\n  });\n\n  test('set modules on global', () => {\n    (globalThis as any).async_hooks = require('async_hooks');\n    (globalThis as any).AsyncLocalStorage =\n      require('async_hooks').AsyncLocalStorage;\n    (globalThis as any).createHook = require('async_hooks').createHook;\n    (globalThis as any).clsx = require('clsx');\n    expect(AsyncLocalStorage).toBeDefined();\n    expect(clsx).toBeDefined();\n    expect(createHook).toBeDefined();\n    expect(createHook({})).toBeDefined();\n    expect(clsx()).toBeDefined();\n  });\n\n  onNodeVersions('>=19.8.0', () => {\n    test('use static function from core module set on global', () => {\n      expect(AsyncLocalStorage.snapshot).toBeDefined();\n      expect(AsyncLocalStorage.snapshot()).toBeDefined();\n    });\n  });\n});\n",
  "packages/jest-environment-node/src/__tests__/globals_cleanup_1.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-environment-jsdom-abstract/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {Context} from 'vm';\nimport type * as jsdom from 'jsdom';\nimport type {\n  EnvironmentContext,\n  JestEnvironment,\n  JestEnvironmentConfig,\n} from '@jest/environment';\nimport {LegacyFakeTimers, ModernFakeTimers} from '@jest/fake-timers';\nimport type {Global} from '@jest/types';\nimport {ModuleMocker} from 'jest-mock';\nimport {installCommonGlobals} from 'jest-util';\n\n// The `Window` interface does not have an `Error.stackTraceLimit` property, but\n// `JSDOMEnvironment` assumes it is there.\ntype Win = Window &\n  Global.Global & {\n    Error: {\n      stackTraceLimit: number;\n    };\n  };\n\nfunction isString(value: unknown): value is string {\n  return typeof value === 'string';\n}\n\nexport default abstract class BaseJSDOMEnvironment\n  implements JestEnvironment<number>\n{\n  dom: jsdom.JSDOM | null;\n  fakeTimers: LegacyFakeTimers<number> | null;\n  fakeTimersModern: ModernFakeTimers | null;\n  global: Win;\n  private errorEventListener: ((event: Event & {error: Error}) => void) | null;\n  moduleMocker: ModuleMocker | null;\n  customExportConditions = ['browser'];\n  private readonly _configuredExportConditions?: Array<string>;\n\n  protected constructor(\n    config: JestEnvironmentConfig,\n    context: EnvironmentContext,\n    jsdomModule: typeof jsdom,\n  ) {\n    const {projectConfig} = config;\n\n    const {JSDOM, ResourceLoader, VirtualConsole} = jsdomModule;\n\n    const virtualConsole = new VirtualConsole();\n    virtualConsole.sendTo(context.console, {omitJSDOMErrors: true});\n    virtualConsole.on('jsdomError', error => {\n      context.console.error(error);\n    });\n\n    this.dom = new JSDOM(\n      typeof projectConfig.testEnvironmentOptions.html === 'string'\n        ? projectConfig.testEnvironmentOptions.html\n        : '<!DOCTYPE html>',\n      {\n        pretendToBeVisual: true,\n        resources:\n          typeof projectConfig.testEnvironmentOptions.userAgent === 'string'\n            ? new ResourceLoader({\n                userAgent: projectConfig.testEnvironmentOptions.userAgent,\n              })\n            : undefined,\n        runScripts: 'dangerously',\n        url: 'http://localhost/',\n        virtualConsole,\n        ...projectConfig.testEnvironmentOptions,\n      },\n    );\n    const global = (this.global = this.dom.window as unknown as Win);\n\n    if (global == null) {\n      throw new Error('JSDOM did not return a Window object');\n    }\n\n    // TODO: remove at some point - for \"universal\" code (code should use `globalThis`)\n    global.global = global;\n\n    // Node's error-message stack size is limited at 10, but it's pretty useful\n    // to see more than that when a test fails.\n    this.global.Error.stackTraceLimit = 100;\n    installCommonGlobals(global, projectConfig.globals);\n\n    // TODO: remove this ASAP, but it currently causes tests to run really slow\n    global.Buffer = Buffer;\n\n    // Report uncaught errors.\n    this.errorEventListener = event => {\n      if (userErrorListenerCount === 0 && event.error != null) {\n        process.emit('uncaughtException', event.error);\n      }\n    };\n    global.addEventListener('error', this.errorEventListener);\n\n    // However, don't report them as uncaught if the user listens to 'error' event.\n    // In that case, we assume the might have custom error handling logic.\n    const originalAddListener = global.addEventListener.bind(global);\n    const originalRemoveListener = global.removeEventListener.bind(global);\n    let userErrorListenerCount = 0;\n    global.addEventListener = function (\n      ...args: Parameters<typeof originalAddListener>\n    ) {\n      if (args[0] === 'error') {\n        userErrorListenerCount++;\n      }\n      return originalAddListener.apply(this, args);\n    };\n    global.removeEventListener = function (\n      ...args: Parameters<typeof originalRemoveListener>\n    ) {\n      if (args[0] === 'error') {\n        userErrorListenerCount--;\n      }\n      return originalRemoveListener.apply(this, args);\n    };\n\n    if ('customExportConditions' in projectConfig.testEnvironmentOptions) {\n      const {customExportConditions} = projectConfig.testEnvironmentOptions;\n      if (\n        Array.isArray(customExportConditions) &&\n        customExportConditions.every(isString)\n      ) {\n        this._configuredExportConditions = customExportConditions;\n      } else {\n        throw new Error(\n          'Custom export conditions specified but they are not an array of strings',\n        );\n      }\n    }\n\n    this.moduleMocker = new ModuleMocker(global);\n\n    this.fakeTimers = new LegacyFakeTimers({\n      config: projectConfig,\n      global: global as unknown as typeof globalThis,\n      moduleMocker: this.moduleMocker,\n      timerConfig: {\n        idToRef: (id: number) => id,\n        refToId: (ref: number) => ref,\n      },\n    });\n\n    this.fakeTimersModern = new ModernFakeTimers({\n      config: projectConfig,\n      global: global as unknown as typeof globalThis,\n    });\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  async setup(): Promise<void> {}\n\n  async teardown(): Promise<void> {\n    if (this.fakeTimers) {\n      this.fakeTimers.dispose();\n    }\n    if (this.fakeTimersModern) {\n      this.fakeTimersModern.dispose();\n    }\n    if (this.global != null) {\n      if (this.errorEventListener) {\n        this.global.removeEventListener('error', this.errorEventListener);\n      }\n      this.global.close();\n    }\n    this.errorEventListener = null;\n    // @ts-expect-error: this.global not allowed to be `null`\n    this.global = null;\n    this.dom = null;\n    this.fakeTimers = null;\n    this.fakeTimersModern = null;\n  }\n\n  exportConditions(): Array<string> {\n    return this._configuredExportConditions ?? this.customExportConditions;\n  }\n\n  getVmContext(): Context | null {\n    if (this.dom) {\n      return this.dom.getInternalVMContext();\n    }\n    return null;\n  }\n}\n",
  "packages/jest-environment-jsdom-abstract/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Context } from 'vm';\nimport type * as jsdom from 'jsdom';\nimport type { EnvironmentContext, JestEnvironment, JestEnvironmentConfig } from '@jest/environment';\nimport { LegacyFakeTimers, ModernFakeTimers } from '@jest/fake-timers';\nimport type { Global } from '@jest/types';\nimport { ModuleMocker } from 'jest-mock';\ntype Win = Window & Global.Global & {\n    Error: {\n        stackTraceLimit: number;\n    };\n};\nexport default abstract class BaseJSDOMEnvironment implements JestEnvironment<number> {\n    dom: jsdom.JSDOM | null;\n    fakeTimers: LegacyFakeTimers<number> | null;\n    fakeTimersModern: ModernFakeTimers | null;\n    global: Win;\n    private errorEventListener;\n    moduleMocker: ModuleMocker | null;\n    customExportConditions: string[];\n    private readonly _configuredExportConditions?;\n    protected constructor(config: JestEnvironmentConfig, context: EnvironmentContext, jsdomModule: typeof jsdom);\n    setup(): Promise<void>;\n    teardown(): Promise<void>;\n    exportConditions(): Array<string>;\n    getVmContext(): Context | null;\n}\nexport {};\n",
  "packages/jest-environment-jsdom/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as JSDOM from 'jsdom';\nimport type {\n  EnvironmentContext,\n  JestEnvironmentConfig,\n} from '@jest/environment';\nimport BaseEnv from '@jest/environment-jsdom-abstract';\n\nexport default class JSDOMEnvironment extends BaseEnv {\n  constructor(config: JestEnvironmentConfig, context: EnvironmentContext) {\n    super(config, context, JSDOM);\n  }\n}\n\nexport const TestEnvironment = JSDOMEnvironment;\n",
  "packages/jest-environment-jsdom/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { EnvironmentContext, JestEnvironmentConfig } from '@jest/environment';\nimport BaseEnv from '@jest/environment-jsdom-abstract';\nexport default class JSDOMEnvironment extends BaseEnv {\n    constructor(config: JestEnvironmentConfig, context: EnvironmentContext);\n}\nexport declare const TestEnvironment: typeof JSDOMEnvironment;\n",
  "packages/jest-environment-jsdom/src/__tests__/jsdom_environment.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {makeGlobalConfig, makeProjectConfig} from '@jest/test-utils';\nimport JSDomEnvironment from '../';\n\ndescribe('JSDomEnvironment', () => {\n  it('should configure setTimeout/setInterval to use the browser api', () => {\n    const env = new JSDomEnvironment(\n      {\n        globalConfig: makeGlobalConfig(),\n        projectConfig: makeProjectConfig(),\n      },\n      {console, docblockPragmas: {}, testPath: __filename},\n    );\n\n    env.fakeTimers!.useFakeTimers();\n\n    const timer1 = env.global.setTimeout(() => {}, 0);\n    const timer2 = env.global.setInterval(() => {}, 0);\n\n    for (const timer of [timer1, timer2]) {\n      expect(typeof timer).toBe('number');\n    }\n  });\n\n  it('has modern fake timers implementation', () => {\n    const env = new JSDomEnvironment(\n      {\n        globalConfig: makeGlobalConfig(),\n        projectConfig: makeProjectConfig(),\n      },\n      {console, docblockPragmas: {}, testPath: __filename},\n    );\n\n    expect(env.fakeTimersModern).toBeDefined();\n  });\n\n  it('should respect userAgent option', () => {\n    const env = new JSDomEnvironment(\n      {\n        globalConfig: makeGlobalConfig(),\n        projectConfig: makeProjectConfig({\n          testEnvironmentOptions: {\n            userAgent: 'foo',\n          },\n        }),\n      },\n      {console, docblockPragmas: {}, testPath: __filename},\n    );\n\n    expect(env.dom.window.navigator.userAgent).toBe('foo');\n  });\n\n  it('should respect url option', () => {\n    const env = new JSDomEnvironment(\n      {\n        globalConfig: makeGlobalConfig(),\n        projectConfig: makeProjectConfig(),\n      },\n      {console, docblockPragmas: {}, testPath: __filename},\n    );\n\n    expect(env.dom.window.location.href).toBe('http://localhost/');\n\n    const envWithUrl = new JSDomEnvironment(\n      {\n        globalConfig: makeGlobalConfig(),\n        projectConfig: makeProjectConfig({\n          testEnvironmentOptions: {\n            url: 'https://jestjs.io',\n          },\n        }),\n      },\n      {console, docblockPragmas: {}, testPath: __filename},\n    );\n\n    expect(envWithUrl.dom.window.location.href).toBe('https://jestjs.io/');\n  });\n\n  /**\n   * When used in conjunction with Custom Elements (part of the WebComponents standard)\n   * setting the `global` and `global.document` to null too early is problematic because:\n   *\n   * CustomElement's disconnectedCallback method is called when a custom element\n   * is removed from the DOM. The disconnectedCallback could need the document\n   * in order to remove some listener for example.\n   *\n   * global.close calls jsdom's Window.js.close which does this._document.body.innerHTML = \"\".\n   * The custom element will be removed from the DOM at this point, therefore disconnectedCallback\n   * will be called, so please make sure the global.document is still available at this point.\n   */\n  it('should call CE disconnectedCallback with valid globals on teardown', () => {\n    const env = new JSDomEnvironment(\n      {\n        globalConfig: makeGlobalConfig(),\n        projectConfig: makeProjectConfig(),\n      },\n      {console, docblockPragmas: {}, testPath: __filename},\n    );\n\n    let hasDisconnected = false;\n    let documentWhenDisconnected = null;\n\n    // define a custom element\n    const {HTMLElement} = env.global;\n    class MyCustomElement extends HTMLElement {\n      disconnectedCallback() {\n        hasDisconnected = true;\n        documentWhenDisconnected = env.global.document;\n      }\n    }\n\n    // append an instance of the custom element\n    env.global.customElements.define('my-custom-element', MyCustomElement);\n    const instance = env.global.document.createElement('my-custom-element');\n    env.global.document.body.append(instance);\n\n    // teardown will disconnect the custom elements\n    env.teardown();\n\n    expect(hasDisconnected).toBe(true);\n    expect(documentWhenDisconnected).not.toBeNull();\n  });\n\n  it('should not fire load event after the environment was teared down', async () => {\n    const env = new JSDomEnvironment(\n      {\n        globalConfig: makeGlobalConfig(),\n        projectConfig: makeProjectConfig(),\n      },\n      {console, docblockPragmas: {}, testPath: __filename},\n    );\n\n    const loadHandler = jest.fn();\n    env.global.document.addEventListener('load', loadHandler);\n    env.teardown();\n\n    // The `load` event is fired in microtasks, wait until the microtask queue is reliably flushed\n    await new Promise(resolve => setTimeout(resolve, 0));\n\n    expect(loadHandler).not.toHaveBeenCalled();\n  });\n});\n",
  "packages/jest-environment-jsdom/src/__tests__/jsdom_environment.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-environment/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {Context} from 'vm';\nimport type {LegacyFakeTimers, ModernFakeTimers} from '@jest/fake-timers';\nimport type {Circus, Config, Global} from '@jest/types';\nimport type {Mocked, ModuleMocker} from 'jest-mock';\n\nexport type EnvironmentContext = {\n  console: Console;\n  docblockPragmas: Record<string, string | Array<string>>;\n  testPath: string;\n};\n\n// Different Order than https://nodejs.org/api/modules.html#modules_the_module_wrapper , however needs to be in the form [jest-transform]ScriptTransformer accepts\nexport type ModuleWrapper = (\n  this: Module['exports'],\n  module: Module,\n  exports: Module['exports'],\n  require: Module['require'],\n  __dirname: string,\n  __filename: Module['filename'],\n  jest?: Jest,\n  ...sandboxInjectedGlobals: Array<Global.Global[keyof Global.Global]>\n) => unknown;\n\nexport interface JestImportMeta extends ImportMeta {\n  jest: Jest;\n}\n\nexport interface JestEnvironmentConfig {\n  projectConfig: Config.ProjectConfig;\n  globalConfig: Config.GlobalConfig;\n}\n\nexport declare class JestEnvironment<Timer = unknown> {\n  constructor(config: JestEnvironmentConfig, context: EnvironmentContext);\n  global: Global.Global;\n  fakeTimers: LegacyFakeTimers<Timer> | null;\n  fakeTimersModern: ModernFakeTimers | null;\n  moduleMocker: ModuleMocker | null;\n  getVmContext(): Context | null;\n  setup(): Promise<void>;\n  teardown(): Promise<void>;\n  handleTestEvent?: Circus.EventHandler;\n  exportConditions?: () => Array<string>;\n}\n\nexport type Module = NodeModule;\n\n// TODO: Move to some separate package\nexport interface Jest {\n  /**\n   * Advances all timers by `msToRun` milliseconds. All pending \"macro-tasks\"\n   * that have been queued via `setTimeout()` or `setInterval()`, and would be\n   * executed within this time frame will be executed.\n   */\n  advanceTimersByTime(msToRun: number): void;\n  /**\n   * Advances all timers by `msToRun` milliseconds, firing callbacks if necessary.\n   *\n   * @remarks\n   * Not available when using legacy fake timers implementation.\n   */\n  advanceTimersByTimeAsync(msToRun: number): Promise<void>;\n  /**\n   * Advances all timers by the needed milliseconds to execute callbacks currently scheduled with `requestAnimationFrame`.\n   * `advanceTimersToNextFrame()` is a helpful way to execute code that is scheduled using `requestAnimationFrame`.\n   *\n   * @remarks\n   * Not available when using legacy fake timers implementation.\n   */\n  advanceTimersToNextFrame(): void;\n  /**\n   * Advances all timers by the needed milliseconds so that only the next\n   * timeouts/intervals will run. Optionally, you can provide steps, so it will\n   * run steps amount of next timeouts/intervals.\n   */\n  advanceTimersToNextTimer(steps?: number): void;\n  /**\n   * Advances the clock to the moment of the first scheduled timer, firing it.\n   * Optionally, you can provide steps, so it will run steps amount of\n   * next timeouts/intervals.\n   *\n   * @remarks\n   * Not available when using legacy fake timers implementation.\n   */\n  advanceTimersToNextTimerAsync(steps?: number): Promise<void>;\n  /**\n   * Disables automatic mocking in the module loader.\n   */\n  autoMockOff(): Jest;\n  /**\n   * Enables automatic mocking in the module loader.\n   */\n  autoMockOn(): Jest;\n  /**\n   * Clears the `mock.calls`, `mock.instances`, `mock.contexts` and `mock.results` properties of\n   * all mocks. Equivalent to calling `.mockClear()` on every mocked function.\n   */\n  clearAllMocks(): Jest;\n  /**\n   * Removes any pending timers from the timer system. If any timers have been\n   * scheduled, they will be cleared and will never have the opportunity to\n   * execute in the future.\n   */\n  clearAllTimers(): void;\n  /**\n   * Given the name of a module, use the automatic mocking system to generate a\n   * mocked version of the module for you.\n   *\n   * This is useful when you want to create a manual mock that extends the\n   * automatic mock's behavior.\n   */\n  createMockFromModule<T = unknown>(moduleName: string): Mocked<T>;\n  /**\n   * Indicates that the module system should never return a mocked version of\n   * the specified module and its dependencies.\n   */\n  deepUnmock(moduleName: string): Jest;\n  /**\n   * Disables automatic mocking in the module loader.\n   *\n   * After this method is called, all `require()`s will return the real\n   * versions of each module (rather than a mocked version).\n   */\n  disableAutomock(): Jest;\n  /**\n   * When using `babel-jest`, calls to `jest.mock()` will automatically be hoisted\n   * to the top of the code block. Use this method if you want to explicitly\n   * avoid this behavior.\n   */\n  doMock<T = unknown>(\n    moduleName: string,\n    moduleFactory?: () => T,\n    options?: {virtual?: boolean},\n  ): Jest;\n  /**\n   * When using `babel-jest`, calls to `jest.unmock()` will automatically be hoisted\n   * to the top of the code block. Use this method if you want to explicitly\n   * avoid this behavior.\n   */\n  dontMock(moduleName: string): Jest;\n  /**\n   * Enables automatic mocking in the module loader.\n   */\n  enableAutomock(): Jest;\n  /**\n   * Creates a mock function. Optionally takes a mock implementation.\n   */\n  fn: ModuleMocker['fn'];\n  /**\n   * When mocking time, `Date.now()` will also be mocked. If you for some reason\n   * need access to the real current time, you can invoke this function.\n   *\n   * @remarks\n   * Not available when using legacy fake timers implementation.\n   */\n  getRealSystemTime(): number;\n  /**\n   * Retrieves the seed value. It will be randomly generated for each test run\n   * or can be manually set via the `--seed` CLI argument.\n   */\n  getSeed(): number;\n  /**\n   * Returns the number of fake timers still left to run.\n   */\n  getTimerCount(): number;\n  /**\n   * Returns `true` if test environment has been torn down.\n   *\n   * @example\n   * ```js\n   * if (jest.isEnvironmentTornDown()) {\n   *   // The Jest environment has been torn down, so stop doing work\n   *   return;\n   * }\n   * ```\n   */\n  isEnvironmentTornDown(): boolean;\n  /**\n   * Determines if the given function is a mocked function.\n   */\n  isMockFunction: ModuleMocker['isMockFunction'];\n  /**\n   * `jest.isolateModules()` goes a step further than `jest.resetModules()` and\n   * creates a sandbox registry for the modules that are loaded inside the callback\n   * function. This is useful to isolate specific modules for every test so that\n   * local module state doesn't conflict between tests.\n   */\n  isolateModules(fn: () => void): Jest;\n  /**\n   * `jest.isolateModulesAsync()` is the equivalent of `jest.isolateModules()`, but for\n   * async functions to be wrapped. The caller is expected to `await` the completion of\n   * `isolateModulesAsync`.\n   */\n  isolateModulesAsync(fn: () => Promise<void>): Promise<void>;\n  /**\n   * Mocks a module with an auto-mocked version when it is being required.\n   */\n  mock<T = unknown>(\n    moduleName: string,\n    moduleFactory?: () => T,\n    options?: {virtual?: boolean},\n  ): Jest;\n  /**\n   * Mocks a module with the provided module factory when it is being imported.\n   */\n  unstable_mockModule<T = unknown>(\n    moduleName: string,\n    moduleFactory: () => T | Promise<T>,\n    options?: {virtual?: boolean},\n  ): Jest;\n  /**\n   * Wraps types of the `source` object and its deep members with type definitions\n   * of Jest mock function. Pass `{shallow: true}` option to disable the deeply\n   * mocked behavior.\n   */\n  mocked: ModuleMocker['mocked'];\n  /**\n   * Returns the current time in ms of the fake timer clock.\n   */\n  now(): number;\n  /**\n   * Registers a callback function that is invoked whenever a mock is generated for a module.\n   * This callback is passed the module path and the newly created mock object, and must return\n   * the (potentially modified) mock object.\n   *\n   * If multiple callbacks are registered, they will be called in the order they were added.\n   * Each callback receives the result of the previous callback as the `moduleMock` parameter,\n   * making it possible to apply sequential transformations.\n   */\n  onGenerateMock<T>(cb: (modulePath: string, moduleMock: T) => T): Jest;\n  /**\n   * Replaces property on an object with another value.\n   *\n   * @remarks\n   * For mocking functions or 'get' or 'set' accessors, use `jest.spyOn()` instead.\n   */\n  replaceProperty: ModuleMocker['replaceProperty'];\n  /**\n   * Returns the actual module instead of a mock, bypassing all checks on\n   * whether the module should receive a mock implementation or not.\n   *\n   * @example\n   * ```js\n   * jest.mock('../myModule', () => {\n   *   // Require the original module to not be mocked...\n   *   const originalModule = jest.requireActual('../myModule');\n   *\n   *   return {\n   *     __esModule: true, // Use it when dealing with esModules\n   *     ...originalModule,\n   *     getRandom: jest.fn().mockReturnValue(10),\n   *   };\n   * });\n   *\n   * const getRandom = require('../myModule').getRandom;\n   *\n   * getRandom(); // Always returns 10\n   * ```\n   */\n  requireActual<T = unknown>(moduleName: string): T;\n  /**\n   * Returns a mock module instead of the actual module, bypassing all checks\n   * on whether the module should be required normally or not.\n   */\n  requireMock<T = unknown>(moduleName: string): T;\n  /**\n   * Resets the state of all mocks. Equivalent to calling `.mockReset()` on\n   * every mocked function.\n   */\n  resetAllMocks(): Jest;\n  /**\n   * Resets the module registry - the cache of all required modules. This is\n   * useful to isolate modules where local state might conflict between tests.\n   */\n  resetModules(): Jest;\n  /**\n   * Restores all mocks and replaced properties back to their original value.\n   * Equivalent to calling `.mockRestore()` on every mocked function\n   * and `.restore()` on every replaced property.\n   *\n   * Beware that `jest.restoreAllMocks()` only works when the mock was created\n   * with `jest.spyOn()`; other mocks will require you to manually restore them.\n   */\n  restoreAllMocks(): Jest;\n  /**\n   * Runs failed tests n-times until they pass or until the max number of\n   * retries is exhausted.\n   *\n   * If `logErrorsBeforeRetry` is enabled, Jest will log the error(s) that caused\n   * the test to fail to the console, providing visibility on why a retry occurred.\n   * retries is exhausted.\n   *\n   * `waitBeforeRetry` is the number of milliseconds to wait before retrying\n   *\n   * `retryImmediately` is the flag to retry the failed test immediately after\n   *  failure\n   *\n   * @remarks\n   * Only available with `jest-circus` runner.\n   */\n  retryTimes(\n    numRetries: number,\n    options?: {\n      logErrorsBeforeRetry?: boolean;\n      retryImmediately?: boolean;\n      waitBeforeRetry?: number;\n    },\n  ): Jest;\n  /**\n   * Exhausts tasks queued by `setImmediate()`.\n   *\n   * @remarks\n   * Only available when using legacy fake timers implementation.\n   */\n  runAllImmediates(): void;\n  /**\n   * Exhausts the micro-task queue (usually interfaced in node via\n   * `process.nextTick()`).\n   */\n  runAllTicks(): void;\n  /**\n   * Exhausts the macro-task queue (i.e., all tasks queued by `setTimeout()`\n   * and `setInterval()`).\n   */\n  runAllTimers(): void;\n  /**\n   * Exhausts the macro-task queue (i.e., all tasks queued by `setTimeout()`\n   * and `setInterval()`).\n   *\n   * @remarks\n   * If new timers are added while it is executing they will be run as well.\n   * @remarks\n   * Not available when using legacy fake timers implementation.\n   */\n  runAllTimersAsync(): Promise<void>;\n  /**\n   * Executes only the macro-tasks that are currently pending (i.e., only the\n   * tasks that have been queued by `setTimeout()` or `setInterval()` up to this\n   * point). If any of the currently pending macro-tasks schedule new\n   * macro-tasks, those new tasks will not be executed by this call.\n   */\n  runOnlyPendingTimers(): void;\n  /**\n   * Executes only the macro-tasks that are currently pending (i.e., only the\n   * tasks that have been queued by `setTimeout()` or `setInterval()` up to this\n   * point). If any of the currently pending macro-tasks schedule new\n   * macro-tasks, those new tasks will not be executed by this call.\n   *\n   * @remarks\n   * Not available when using legacy fake timers implementation.\n   */\n  runOnlyPendingTimersAsync(): Promise<void>;\n  /**\n   * Explicitly supplies the mock object that the module system should return\n   * for the specified module.\n   *\n   * @remarks\n   * It is recommended to use `jest.mock()` instead. The `jest.mock()` API's second\n   * argument is a module factory instead of the expected exported module object.\n   */\n  setMock(moduleName: string, moduleExports: unknown): Jest;\n  /**\n   * Set the current system time used by fake timers. Simulates a user changing\n   * the system clock while your program is running. It affects the current time,\n   * but it does not in itself cause e.g. timers to fire; they will fire exactly\n   * as they would have done without the call to `jest.setSystemTime()`.\n   *\n   * @remarks\n   * Not available when using legacy fake timers implementation.\n   */\n  setSystemTime(now?: number | Date): void;\n  /**\n   * Set the default timeout interval for tests and before/after hooks in\n   * milliseconds.\n   *\n   * @remarks\n   * The default timeout interval is 5 seconds if this method is not called.\n   */\n  setTimeout(timeout: number): Jest;\n  /**\n   * Creates a mock function similar to `jest.fn()` but also tracks calls to\n   * `object[methodName]`.\n   *\n   * Optional third argument of `accessType` can be either 'get' or 'set', which\n   * proves to be useful when you want to spy on a getter or a setter, respectively.\n   *\n   * @remarks\n   * By default, `jest.spyOn()` also calls the spied method. This is different\n   * behavior from most other test libraries.\n   */\n  spyOn: ModuleMocker['spyOn'];\n  /**\n   * Indicates that the module system should never return a mocked version of\n   * the specified module from `require()` (e.g. that it should always return the\n   * real module).\n   */\n  unmock(moduleName: string): Jest;\n  /**\n   * Indicates that the module system should never return a mocked version of\n   * the specified module when it is being imported (e.g. that it should always\n   * return the real module).\n   */\n  unstable_unmockModule(moduleName: string): Jest;\n  /**\n   * Instructs Jest to use fake versions of the global date, performance,\n   * time and timer APIs. Fake timers implementation is backed by\n   * [`@sinonjs/fake-timers`](https://github.com/sinonjs/fake-timers).\n   *\n   * @remarks\n   * Calling `jest.useFakeTimers()` once again in the same test file would reinstall\n   * fake timers using the provided options.\n   */\n  useFakeTimers(\n    fakeTimersConfig?: Config.FakeTimersConfig | Config.LegacyFakeTimersConfig,\n  ): Jest;\n  /**\n   * Instructs Jest to restore the original implementations of the global date,\n   * performance, time and timer APIs.\n   */\n  useRealTimers(): Jest;\n}\n",
  "packages/jest-environment/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Context } from 'vm';\nimport type { LegacyFakeTimers, ModernFakeTimers } from '@jest/fake-timers';\nimport type { Circus, Config, Global } from '@jest/types';\nimport type { Mocked, ModuleMocker } from 'jest-mock';\nexport type EnvironmentContext = {\n    console: Console;\n    docblockPragmas: Record<string, string | Array<string>>;\n    testPath: string;\n};\nexport type ModuleWrapper = (this: Module['exports'], module: Module, exports: Module['exports'], require: Module['require'], __dirname: string, __filename: Module['filename'], jest?: Jest, ...sandboxInjectedGlobals: Array<Global.Global[keyof Global.Global]>) => unknown;\nexport interface JestImportMeta extends ImportMeta {\n    jest: Jest;\n}\nexport interface JestEnvironmentConfig {\n    projectConfig: Config.ProjectConfig;\n    globalConfig: Config.GlobalConfig;\n}\nexport declare class JestEnvironment<Timer = unknown> {\n    constructor(config: JestEnvironmentConfig, context: EnvironmentContext);\n    global: Global.Global;\n    fakeTimers: LegacyFakeTimers<Timer> | null;\n    fakeTimersModern: ModernFakeTimers | null;\n    moduleMocker: ModuleMocker | null;\n    getVmContext(): Context | null;\n    setup(): Promise<void>;\n    teardown(): Promise<void>;\n    handleTestEvent?: Circus.EventHandler;\n    exportConditions?: () => Array<string>;\n}\nexport type Module = NodeModule;\nexport interface Jest {\n    /**\n     * Advances all timers by `msToRun` milliseconds. All pending \"macro-tasks\"\n     * that have been queued via `setTimeout()` or `setInterval()`, and would be\n     * executed within this time frame will be executed.\n     */\n    advanceTimersByTime(msToRun: number): void;\n    /**\n     * Advances all timers by `msToRun` milliseconds, firing callbacks if necessary.\n     *\n     * @remarks\n     * Not available when using legacy fake timers implementation.\n     */\n    advanceTimersByTimeAsync(msToRun: number): Promise<void>;\n    /**\n     * Advances all timers by the needed milliseconds to execute callbacks currently scheduled with `requestAnimationFrame`.\n     * `advanceTimersToNextFrame()` is a helpful way to execute code that is scheduled using `requestAnimationFrame`.\n     *\n     * @remarks\n     * Not available when using legacy fake timers implementation.\n     */\n    advanceTimersToNextFrame(): void;\n    /**\n     * Advances all timers by the needed milliseconds so that only the next\n     * timeouts/intervals will run. Optionally, you can provide steps, so it will\n     * run steps amount of next timeouts/intervals.\n     */\n    advanceTimersToNextTimer(steps?: number): void;\n    /**\n     * Advances the clock to the moment of the first scheduled timer, firing it.\n     * Optionally, you can provide steps, so it will run steps amount of\n     * next timeouts/intervals.\n     *\n     * @remarks\n     * Not available when using legacy fake timers implementation.\n     */\n    advanceTimersToNextTimerAsync(steps?: number): Promise<void>;\n    /**\n     * Disables automatic mocking in the module loader.\n     */\n    autoMockOff(): Jest;\n    /**\n     * Enables automatic mocking in the module loader.\n     */\n    autoMockOn(): Jest;\n    /**\n     * Clears the `mock.calls`, `mock.instances`, `mock.contexts` and `mock.results` properties of\n     * all mocks. Equivalent to calling `.mockClear()` on every mocked function.\n     */\n    clearAllMocks(): Jest;\n    /**\n     * Removes any pending timers from the timer system. If any timers have been\n     * scheduled, they will be cleared and will never have the opportunity to\n     * execute in the future.\n     */\n    clearAllTimers(): void;\n    /**\n     * Given the name of a module, use the automatic mocking system to generate a\n     * mocked version of the module for you.\n     *\n     * This is useful when you want to create a manual mock that extends the\n     * automatic mock's behavior.\n     */\n    createMockFromModule<T = unknown>(moduleName: string): Mocked<T>;\n    /**\n     * Indicates that the module system should never return a mocked version of\n     * the specified module and its dependencies.\n     */\n    deepUnmock(moduleName: string): Jest;\n    /**\n     * Disables automatic mocking in the module loader.\n     *\n     * After this method is called, all `require()`s will return the real\n     * versions of each module (rather than a mocked version).\n     */\n    disableAutomock(): Jest;\n    /**\n     * When using `babel-jest`, calls to `jest.mock()` will automatically be hoisted\n     * to the top of the code block. Use this method if you want to explicitly\n     * avoid this behavior.\n     */\n    doMock<T = unknown>(moduleName: string, moduleFactory?: () => T, options?: {\n        virtual?: boolean;\n    }): Jest;\n    /**\n     * When using `babel-jest`, calls to `jest.unmock()` will automatically be hoisted\n     * to the top of the code block. Use this method if you want to explicitly\n     * avoid this behavior.\n     */\n    dontMock(moduleName: string): Jest;\n    /**\n     * Enables automatic mocking in the module loader.\n     */\n    enableAutomock(): Jest;\n    /**\n     * Creates a mock function. Optionally takes a mock implementation.\n     */\n    fn: ModuleMocker['fn'];\n    /**\n     * When mocking time, `Date.now()` will also be mocked. If you for some reason\n     * need access to the real current time, you can invoke this function.\n     *\n     * @remarks\n     * Not available when using legacy fake timers implementation.\n     */\n    getRealSystemTime(): number;\n    /**\n     * Retrieves the seed value. It will be randomly generated for each test run\n     * or can be manually set via the `--seed` CLI argument.\n     */\n    getSeed(): number;\n    /**\n     * Returns the number of fake timers still left to run.\n     */\n    getTimerCount(): number;\n    /**\n     * Returns `true` if test environment has been torn down.\n     *\n     * @example\n     * ```js\n     * if (jest.isEnvironmentTornDown()) {\n     *   // The Jest environment has been torn down, so stop doing work\n     *   return;\n     * }\n     * ```\n     */\n    isEnvironmentTornDown(): boolean;\n    /**\n     * Determines if the given function is a mocked function.\n     */\n    isMockFunction: ModuleMocker['isMockFunction'];\n    /**\n     * `jest.isolateModules()` goes a step further than `jest.resetModules()` and\n     * creates a sandbox registry for the modules that are loaded inside the callback\n     * function. This is useful to isolate specific modules for every test so that\n     * local module state doesn't conflict between tests.\n     */\n    isolateModules(fn: () => void): Jest;\n    /**\n     * `jest.isolateModulesAsync()` is the equivalent of `jest.isolateModules()`, but for\n     * async functions to be wrapped. The caller is expected to `await` the completion of\n     * `isolateModulesAsync`.\n     */\n    isolateModulesAsync(fn: () => Promise<void>): Promise<void>;\n    /**\n     * Mocks a module with an auto-mocked version when it is being required.\n     */\n    mock<T = unknown>(moduleName: string, moduleFactory?: () => T, options?: {\n        virtual?: boolean;\n    }): Jest;\n    /**\n     * Mocks a module with the provided module factory when it is being imported.\n     */\n    unstable_mockModule<T = unknown>(moduleName: string, moduleFactory: () => T | Promise<T>, options?: {\n        virtual?: boolean;\n    }): Jest;\n    /**\n     * Wraps types of the `source` object and its deep members with type definitions\n     * of Jest mock function. Pass `{shallow: true}` option to disable the deeply\n     * mocked behavior.\n     */\n    mocked: ModuleMocker['mocked'];\n    /**\n     * Returns the current time in ms of the fake timer clock.\n     */\n    now(): number;\n    /**\n     * Registers a callback function that is invoked whenever a mock is generated for a module.\n     * This callback is passed the module path and the newly created mock object, and must return\n     * the (potentially modified) mock object.\n     *\n     * If multiple callbacks are registered, they will be called in the order they were added.\n     * Each callback receives the result of the previous callback as the `moduleMock` parameter,\n     * making it possible to apply sequential transformations.\n     */\n    onGenerateMock<T>(cb: (modulePath: string, moduleMock: T) => T): Jest;\n    /**\n     * Replaces property on an object with another value.\n     *\n     * @remarks\n     * For mocking functions or 'get' or 'set' accessors, use `jest.spyOn()` instead.\n     */\n    replaceProperty: ModuleMocker['replaceProperty'];\n    /**\n     * Returns the actual module instead of a mock, bypassing all checks on\n     * whether the module should receive a mock implementation or not.\n     *\n     * @example\n     * ```js\n     * jest.mock('../myModule', () => {\n     *   // Require the original module to not be mocked...\n     *   const originalModule = jest.requireActual('../myModule');\n     *\n     *   return {\n     *     __esModule: true, // Use it when dealing with esModules\n     *     ...originalModule,\n     *     getRandom: jest.fn().mockReturnValue(10),\n     *   };\n     * });\n     *\n     * const getRandom = require('../myModule').getRandom;\n     *\n     * getRandom(); // Always returns 10\n     * ```\n     */\n    requireActual<T = unknown>(moduleName: string): T;\n    /**\n     * Returns a mock module instead of the actual module, bypassing all checks\n     * on whether the module should be required normally or not.\n     */\n    requireMock<T = unknown>(moduleName: string): T;\n    /**\n     * Resets the state of all mocks. Equivalent to calling `.mockReset()` on\n     * every mocked function.\n     */\n    resetAllMocks(): Jest;\n    /**\n     * Resets the module registry - the cache of all required modules. This is\n     * useful to isolate modules where local state might conflict between tests.\n     */\n    resetModules(): Jest;\n    /**\n     * Restores all mocks and replaced properties back to their original value.\n     * Equivalent to calling `.mockRestore()` on every mocked function\n     * and `.restore()` on every replaced property.\n     *\n     * Beware that `jest.restoreAllMocks()` only works when the mock was created\n     * with `jest.spyOn()`; other mocks will require you to manually restore them.\n     */\n    restoreAllMocks(): Jest;\n    /**\n     * Runs failed tests n-times until they pass or until the max number of\n     * retries is exhausted.\n     *\n     * If `logErrorsBeforeRetry` is enabled, Jest will log the error(s) that caused\n     * the test to fail to the console, providing visibility on why a retry occurred.\n     * retries is exhausted.\n     *\n     * `waitBeforeRetry` is the number of milliseconds to wait before retrying\n     *\n     * `retryImmediately` is the flag to retry the failed test immediately after\n     *  failure\n     *\n     * @remarks\n     * Only available with `jest-circus` runner.\n     */\n    retryTimes(numRetries: number, options?: {\n        logErrorsBeforeRetry?: boolean;\n        retryImmediately?: boolean;\n        waitBeforeRetry?: number;\n    }): Jest;\n    /**\n     * Exhausts tasks queued by `setImmediate()`.\n     *\n     * @remarks\n     * Only available when using legacy fake timers implementation.\n     */\n    runAllImmediates(): void;\n    /**\n     * Exhausts the micro-task queue (usually interfaced in node via\n     * `process.nextTick()`).\n     */\n    runAllTicks(): void;\n    /**\n     * Exhausts the macro-task queue (i.e., all tasks queued by `setTimeout()`\n     * and `setInterval()`).\n     */\n    runAllTimers(): void;\n    /**\n     * Exhausts the macro-task queue (i.e., all tasks queued by `setTimeout()`\n     * and `setInterval()`).\n     *\n     * @remarks\n     * If new timers are added while it is executing they will be run as well.\n     * @remarks\n     * Not available when using legacy fake timers implementation.\n     */\n    runAllTimersAsync(): Promise<void>;\n    /**\n     * Executes only the macro-tasks that are currently pending (i.e., only the\n     * tasks that have been queued by `setTimeout()` or `setInterval()` up to this\n     * point). If any of the currently pending macro-tasks schedule new\n     * macro-tasks, those new tasks will not be executed by this call.\n     */\n    runOnlyPendingTimers(): void;\n    /**\n     * Executes only the macro-tasks that are currently pending (i.e., only the\n     * tasks that have been queued by `setTimeout()` or `setInterval()` up to this\n     * point). If any of the currently pending macro-tasks schedule new\n     * macro-tasks, those new tasks will not be executed by this call.\n     *\n     * @remarks\n     * Not available when using legacy fake timers implementation.\n     */\n    runOnlyPendingTimersAsync(): Promise<void>;\n    /**\n     * Explicitly supplies the mock object that the module system should return\n     * for the specified module.\n     *\n     * @remarks\n     * It is recommended to use `jest.mock()` instead. The `jest.mock()` API's second\n     * argument is a module factory instead of the expected exported module object.\n     */\n    setMock(moduleName: string, moduleExports: unknown): Jest;\n    /**\n     * Set the current system time used by fake timers. Simulates a user changing\n     * the system clock while your program is running. It affects the current time,\n     * but it does not in itself cause e.g. timers to fire; they will fire exactly\n     * as they would have done without the call to `jest.setSystemTime()`.\n     *\n     * @remarks\n     * Not available when using legacy fake timers implementation.\n     */\n    setSystemTime(now?: number | Date): void;\n    /**\n     * Set the default timeout interval for tests and before/after hooks in\n     * milliseconds.\n     *\n     * @remarks\n     * The default timeout interval is 5 seconds if this method is not called.\n     */\n    setTimeout(timeout: number): Jest;\n    /**\n     * Creates a mock function similar to `jest.fn()` but also tracks calls to\n     * `object[methodName]`.\n     *\n     * Optional third argument of `accessType` can be either 'get' or 'set', which\n     * proves to be useful when you want to spy on a getter or a setter, respectively.\n     *\n     * @remarks\n     * By default, `jest.spyOn()` also calls the spied method. This is different\n     * behavior from most other test libraries.\n     */\n    spyOn: ModuleMocker['spyOn'];\n    /**\n     * Indicates that the module system should never return a mocked version of\n     * the specified module from `require()` (e.g. that it should always return the\n     * real module).\n     */\n    unmock(moduleName: string): Jest;\n    /**\n     * Indicates that the module system should never return a mocked version of\n     * the specified module when it is being imported (e.g. that it should always\n     * return the real module).\n     */\n    unstable_unmockModule(moduleName: string): Jest;\n    /**\n     * Instructs Jest to use fake versions of the global date, performance,\n     * time and timer APIs. Fake timers implementation is backed by\n     * [`@sinonjs/fake-timers`](https://github.com/sinonjs/fake-timers).\n     *\n     * @remarks\n     * Calling `jest.useFakeTimers()` once again in the same test file would reinstall\n     * fake timers using the provided options.\n     */\n    useFakeTimers(fakeTimersConfig?: Config.FakeTimersConfig | Config.LegacyFakeTimersConfig): Jest;\n    /**\n     * Instructs Jest to restore the original implementations of the global date,\n     * performance, time and timer APIs.\n     */\n    useRealTimers(): Jest;\n}\n",
  "packages/jest-each/src/validation.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport chalk from 'chalk';\nimport type {Global} from '@jest/types';\nimport {format as pretty} from 'pretty-format';\n\ntype TemplateData = Global.TemplateData;\n\nconst EXPECTED_COLOR = chalk.green;\nconst RECEIVED_COLOR = chalk.red;\n\nexport const validateArrayTable = (table: unknown): void => {\n  if (!Array.isArray(table)) {\n    throw new TypeError(\n      '`.each` must be called with an Array or Tagged Template Literal.\\n\\n' +\n        `Instead was called with: ${pretty(table, {\n          maxDepth: 1,\n          min: true,\n        })}\\n`,\n    );\n  }\n\n  if (isTaggedTemplateLiteral(table)) {\n    if (isEmptyString(table[0])) {\n      throw new Error(\n        'Error: `.each` called with an empty Tagged Template Literal of table data.\\n',\n      );\n    }\n\n    throw new Error(\n      'Error: `.each` called with a Tagged Template Literal with no data, remember to interpolate with ${expression} syntax.\\n',\n    );\n  }\n\n  if (isEmptyTable(table)) {\n    throw new Error(\n      'Error: `.each` called with an empty Array of table data.\\n',\n    );\n  }\n};\n\nconst isTaggedTemplateLiteral = (array: any) => array.raw !== undefined;\nconst isEmptyTable = (table: Array<unknown>) => table.length === 0;\nconst isEmptyString = (str: string | unknown) =>\n  typeof str === 'string' && str.trim() === '';\n\nexport const validateTemplateTableArguments = (\n  headings: Array<string>,\n  data: TemplateData,\n): void => {\n  const incompleteData = data.length % headings.length;\n  const missingData = headings.length - incompleteData;\n\n  if (incompleteData > 0) {\n    throw new Error(\n      `Not enough arguments supplied for given headings:\\n${EXPECTED_COLOR(\n        headings.join(' | '),\n      )}\\n\\n` +\n        `Received:\\n${RECEIVED_COLOR(pretty(data))}\\n\\n` +\n        `Missing ${RECEIVED_COLOR(missingData.toString())} ${pluralize(\n          'argument',\n          missingData,\n        )}`,\n    );\n  }\n};\n\nconst pluralize = (word: string, count: number) =>\n  word + (count === 1 ? '' : 's');\n\nconst START_OF_LINE = '^';\nconst NEWLINE = '\\\\n';\nconst HEADING = '\\\\s*[^\\\\s]+\\\\s*';\nconst PIPE = '\\\\|';\nconst REPEATABLE_HEADING = `(${PIPE}${HEADING})*`;\nconst HEADINGS_FORMAT = new RegExp(\n  START_OF_LINE + NEWLINE + HEADING + REPEATABLE_HEADING + NEWLINE,\n  'g',\n);\n\nexport const extractValidTemplateHeadings = (headings: string): string => {\n  const matches = headings.match(HEADINGS_FORMAT);\n  if (matches === null) {\n    throw new Error(\n      `Table headings do not conform to expected format:\\n\\n${EXPECTED_COLOR(\n        'heading1 | headingN',\n      )}\\n\\nReceived:\\n\\n${RECEIVED_COLOR(pretty(headings))}`,\n    );\n  }\n\n  return matches[0];\n};\n",
  "packages/jest-each/src/validation.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport type { Global } from '@jest/types';\ntype TemplateData = Global.TemplateData;\nexport declare const validateArrayTable: (table: unknown) => void;\nexport declare const validateTemplateTableArguments: (headings: Array<string>, data: TemplateData) => void;\nexport declare const extractValidTemplateHeadings: (headings: string) => string;\nexport {};\n",
  "packages/jest-each/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {Global} from '@jest/types';\nimport bind from './bind';\n\ntype Global = Global.Global;\nconst install = (\n  g: Global,\n  table: Global.EachTable,\n  ...data: Global.TemplateData\n) => {\n  const bindingWithArray = data.length === 0;\n  const bindingWithTemplate = Array.isArray(table) && !!(table as any).raw;\n  if (!bindingWithArray && !bindingWithTemplate) {\n    throw new Error(\n      '`.each` must only be called with an Array or Tagged Template Literal.',\n    );\n  }\n  const test = (\n    title: string,\n    test: Global.EachTestFn<Global.TestFn>,\n    timeout?: number,\n  ) => bind(g.test)(table, ...data)(title, test, timeout);\n  test.skip = bind(g.test.skip)(table, ...data);\n  test.only = bind(g.test.only)(table, ...data);\n\n  const testConcurrent = (\n    title: string,\n    test: Global.EachTestFn<Global.TestFn>,\n    timeout?: number,\n  ) => bind(g.test.concurrent)(table, ...data)(title, test, timeout);\n\n  test.concurrent = testConcurrent;\n  testConcurrent.only = bind(g.test.concurrent.only)(table, ...data);\n  testConcurrent.skip = bind(g.test.concurrent.skip)(table, ...data);\n\n  const it = (\n    title: string,\n    test: Global.EachTestFn<Global.TestFn>,\n    timeout?: number,\n  ) => bind(g.it)(table, ...data)(title, test, timeout);\n  it.skip = bind(g.it.skip)(table, ...data);\n  it.only = bind(g.it.only)(table, ...data);\n  it.concurrent = testConcurrent;\n\n  const xit = bind(g.xit)(table, ...data);\n  const fit = bind(g.fit)(table, ...data);\n  const xtest = bind(g.xtest)(table, ...data);\n\n  const describe = (\n    title: string,\n    suite: Global.EachTestFn<Global.BlockFn>,\n    timeout?: number,\n  ) => bind(g.describe, false)(table, ...data)(title, suite, timeout);\n  describe.skip = bind(g.describe.skip, false)(table, ...data);\n  describe.only = bind(g.describe.only, false)(table, ...data);\n  const fdescribe = bind(g.fdescribe, false)(table, ...data);\n  const xdescribe = bind(g.xdescribe, false)(table, ...data);\n\n  return {describe, fdescribe, fit, it, test, xdescribe, xit, xtest};\n};\n\nconst each = (\n  table: Global.EachTable,\n  ...data: Global.TemplateData\n): ReturnType<typeof install> =>\n  install(globalThis as unknown as Global, table, ...data);\n\neach.withGlobal =\n  (g: Global) =>\n  (table: Global.EachTable, ...data: Global.TemplateData) =>\n    install(g, table, ...data);\n\nexport {bind};\n\nexport default each;\n",
  "packages/jest-each/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport type { Global } from '@jest/types';\nimport bind from './bind';\ntype Global = Global.Global;\ndeclare const install: (g: Global, table: Global.EachTable, ...data: Global.TemplateData) => {\n    describe: {\n        (title: string, suite: Global.EachTestFn<Global.BlockFn>, timeout?: number): any;\n        skip: any;\n        only: any;\n    };\n    fdescribe: any;\n    fit: any;\n    it: {\n        (title: string, test: Global.EachTestFn<Global.TestFn>, timeout?: number): any;\n        skip: any;\n        only: any;\n        concurrent: {\n            (title: string, test: Global.EachTestFn<Global.TestFn>, timeout?: number): any;\n            only: any;\n            skip: any;\n        };\n    };\n    test: {\n        (title: string, test: Global.EachTestFn<Global.TestFn>, timeout?: number): any;\n        skip: any;\n        only: any;\n        concurrent: {\n            (title: string, test: Global.EachTestFn<Global.TestFn>, timeout?: number): any;\n            only: any;\n            skip: any;\n        };\n    };\n    xdescribe: any;\n    xit: any;\n    xtest: any;\n};\ndeclare const each: {\n    (table: Global.EachTable, ...data: Global.TemplateData): ReturnType<typeof install>;\n    withGlobal(g: Global): (table: Global.EachTable, ...data: Global.TemplateData) => {\n        describe: {\n            (title: string, suite: Global.EachTestFn<Global.BlockFn>, timeout?: number): any;\n            skip: any;\n            only: any;\n        };\n        fdescribe: any;\n        fit: any;\n        it: {\n            (title: string, test: Global.EachTestFn<Global.TestFn>, timeout?: number): any;\n            skip: any;\n            only: any;\n            concurrent: {\n                (title: string, test: Global.EachTestFn<Global.TestFn>, timeout?: number): any;\n                only: any;\n                skip: any;\n            };\n        };\n        test: {\n            (title: string, test: Global.EachTestFn<Global.TestFn>, timeout?: number): any;\n            skip: any;\n            only: any;\n            concurrent: {\n                (title: string, test: Global.EachTestFn<Global.TestFn>, timeout?: number): any;\n                only: any;\n                skip: any;\n            };\n        };\n        xdescribe: any;\n        xit: any;\n        xtest: any;\n    };\n};\nexport { bind };\nexport default each;\n",
  "packages/jest-each/src/bind.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {Global} from '@jest/types';\nimport {ErrorWithStack, convertDescriptorToString} from 'jest-util';\nimport convertArrayTable from './table/array';\nimport convertTemplateTable from './table/template';\nimport {\n  extractValidTemplateHeadings,\n  validateArrayTable,\n  validateTemplateTableArguments,\n} from './validation';\n\nexport type EachTests = ReadonlyArray<{\n  title: string;\n  arguments: ReadonlyArray<unknown>;\n}>;\n\n// type TestFn = (done?: Global.DoneFn) => Promise<any> | void | undefined;\ntype GlobalCallback = (\n  testName: string,\n  fn: Global.ConcurrentTestFn,\n  timeout?: number,\n  eachError?: Error,\n) => void;\n\nexport default function bind<EachCallback extends Global.TestCallback>(\n  cb: GlobalCallback,\n  supportsDone = true,\n  needsEachError = false,\n): Global.EachTestFn<any> {\n  const bindWrap = (\n    table: Global.EachTable,\n    ...taggedTemplateData: Global.TemplateData\n  ) => {\n    const errorWithStack = new ErrorWithStack(undefined, bindWrap);\n\n    return function eachBind(\n      title: Global.BlockNameLike,\n      test: Global.EachTestFn<EachCallback>,\n      timeout?: number,\n    ): void {\n      title = convertDescriptorToString(title);\n      try {\n        const tests = isArrayTable(taggedTemplateData)\n          ? buildArrayTests(title, table)\n          : buildTemplateTests(title, table, taggedTemplateData);\n\n        for (const row of tests) {\n          if (needsEachError) {\n            cb(\n              row.title,\n              applyArguments(supportsDone, row.arguments, test),\n              timeout,\n              errorWithStack,\n            );\n          } else {\n            cb(\n              row.title,\n              applyArguments(supportsDone, row.arguments, test),\n              timeout,\n            );\n          }\n        }\n\n        return;\n      } catch (error: any) {\n        const err = new Error(error.message);\n        err.stack = errorWithStack.stack?.replace(\n          /^Error: /s,\n          `Error: ${error.message}`,\n        );\n\n        return cb(title, () => {\n          throw err;\n        });\n      }\n    };\n  };\n  return bindWrap;\n}\n\nconst isArrayTable = (data: Global.TemplateData) => data.length === 0;\n\nconst buildArrayTests = (title: string, table: Global.EachTable): EachTests => {\n  validateArrayTable(table);\n  return convertArrayTable(title, table as Global.ArrayTable);\n};\n\nconst buildTemplateTests = (\n  title: string,\n  table: Global.EachTable,\n  taggedTemplateData: Global.TemplateData,\n): EachTests => {\n  const headings = getHeadingKeys(table[0] as string);\n  validateTemplateTableArguments(headings, taggedTemplateData);\n  return convertTemplateTable(title, headings, taggedTemplateData);\n};\n\nconst getHeadingKeys = (headings: string): Array<string> =>\n  extractValidTemplateHeadings(headings).replaceAll(/\\s/g, '').split('|');\n\nconst applyArguments = <EachCallback extends Global.TestCallback>(\n  supportsDone: boolean,\n  params: ReadonlyArray<unknown>,\n  test: Global.EachTestFn<EachCallback>,\n): Global.EachTestFn<any> =>\n  supportsDone && params.length < test.length\n    ? (done: Global.DoneFn) => test(...params, done)\n    : () => test(...params);\n",
  "packages/jest-each/src/bind.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport type { Global } from '@jest/types';\nexport type EachTests = ReadonlyArray<{\n    title: string;\n    arguments: ReadonlyArray<unknown>;\n}>;\ntype GlobalCallback = (testName: string, fn: Global.ConcurrentTestFn, timeout?: number, eachError?: Error) => void;\nexport default function bind<EachCallback extends Global.TestCallback>(cb: GlobalCallback, supportsDone?: boolean, needsEachError?: boolean): Global.EachTestFn<any>;\nexport {};\n",
  "packages/jest-each/src/table/template.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {Global} from '@jest/types';\nimport type {EachTests} from '../bind';\nimport {\n  type Headings,\n  type Templates,\n  interpolateVariables,\n} from './interpolation';\n\nexport default function template(\n  title: string,\n  headings: Headings,\n  row: Global.Row,\n): EachTests {\n  const table = convertRowToTable(row, headings);\n  const templates = convertTableToTemplates(table, headings);\n  return templates.map((template, index) => ({\n    arguments: [template],\n    title: interpolateVariables(title, template, index),\n  }));\n}\n\nconst convertRowToTable = (row: Global.Row, headings: Headings): Global.Table =>\n  Array.from({length: row.length / headings.length}, (_, index) =>\n    row.slice(\n      index * headings.length,\n      index * headings.length + headings.length,\n    ),\n  );\n\nconst convertTableToTemplates = (\n  table: Global.Table,\n  headings: Headings,\n): Templates =>\n  table.map(row =>\n    Object.fromEntries(row.map((value, index) => [headings[index], value])),\n  );\n",
  "packages/jest-each/src/table/template.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport type { Global } from '@jest/types';\nimport type { EachTests } from '../bind';\nimport { type Headings } from './interpolation';\nexport default function template(title: string, headings: Headings, row: Global.Row): EachTests;\n",
  "packages/jest-each/src/table/interpolation.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {isPrimitive} from '@jest/get-type';\nimport {format as pretty} from 'pretty-format';\n\nexport type Template = Record<string, unknown>;\nexport type Templates = Array<Template>;\nexport type Headings = Array<string>;\n\nexport const interpolateVariables = (\n  title: string,\n  template: Template,\n  index: number,\n): string =>\n  title\n    .replaceAll(\n      new RegExp(`\\\\$(${Object.keys(template).join('|')})[.\\\\w]*`, 'g'),\n      match => {\n        const keyPath = match.slice(1).split('.');\n        const value = getPath(template, keyPath);\n\n        return isPrimitive(value)\n          ? String(value)\n          : pretty(value, {maxDepth: 1, min: true});\n      },\n    )\n    .replace('$#', `${index}`);\n\n/* eslint import-x/export: 0*/\nexport function getPath<\n  Obj extends Template,\n  A extends keyof Obj,\n  B extends keyof Obj[A],\n  C extends keyof Obj[A][B],\n  D extends keyof Obj[A][B][C],\n  E extends keyof Obj[A][B][C][D],\n>(obj: Obj, path: [A, B, C, D, E]): Obj[A][B][C][D][E];\nexport function getPath<\n  Obj extends Template,\n  A extends keyof Obj,\n  B extends keyof Obj[A],\n  C extends keyof Obj[A][B],\n  D extends keyof Obj[A][B][C],\n>(obj: Obj, path: [A, B, C, D]): Obj[A][B][C][D];\nexport function getPath<\n  Obj extends Template,\n  A extends keyof Obj,\n  B extends keyof Obj[A],\n  C extends keyof Obj[A][B],\n>(obj: Obj, path: [A, B, C]): Obj[A][B][C];\nexport function getPath<\n  Obj extends Template,\n  A extends keyof Obj,\n  B extends keyof Obj[A],\n>(obj: Obj, path: [A, B]): Obj[A][B];\nexport function getPath<Obj extends Template, A extends keyof Obj>(\n  obj: Obj,\n  path: [A],\n): Obj[A];\nexport function getPath<Obj extends Template>(\n  obj: Obj,\n  path: Array<string>,\n): unknown;\nexport function getPath(\n  template: Template,\n  [head, ...tail]: Array<string>,\n): unknown {\n  if (template === null) return 'null';\n  if (template === undefined) return 'undefined';\n  if (!head || !Object.prototype.hasOwnProperty.call(template, head))\n    return template;\n  return getPath(template[head] as Template, tail);\n}\n",
  "packages/jest-each/src/table/interpolation.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport type Template = Record<string, unknown>;\nexport type Templates = Array<Template>;\nexport type Headings = Array<string>;\nexport declare const interpolateVariables: (title: string, template: Template, index: number) => string;\nexport declare function getPath<Obj extends Template, A extends keyof Obj, B extends keyof Obj[A], C extends keyof Obj[A][B], D extends keyof Obj[A][B][C], E extends keyof Obj[A][B][C][D]>(obj: Obj, path: [A, B, C, D, E]): Obj[A][B][C][D][E];\nexport declare function getPath<Obj extends Template, A extends keyof Obj, B extends keyof Obj[A], C extends keyof Obj[A][B], D extends keyof Obj[A][B][C]>(obj: Obj, path: [A, B, C, D]): Obj[A][B][C][D];\nexport declare function getPath<Obj extends Template, A extends keyof Obj, B extends keyof Obj[A], C extends keyof Obj[A][B]>(obj: Obj, path: [A, B, C]): Obj[A][B][C];\nexport declare function getPath<Obj extends Template, A extends keyof Obj, B extends keyof Obj[A]>(obj: Obj, path: [A, B]): Obj[A][B];\nexport declare function getPath<Obj extends Template, A extends keyof Obj>(obj: Obj, path: [A]): Obj[A];\nexport declare function getPath<Obj extends Template>(obj: Obj, path: Array<string>): unknown;\n",
  "packages/jest-each/src/table/array.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport * as util from 'util';\nimport type {Global} from '@jest/types';\nimport {format as pretty} from 'pretty-format';\nimport type {EachTests} from '../bind';\nimport {type Templates, interpolateVariables} from './interpolation';\n\nconst SUPPORTED_PLACEHOLDERS = /%[#Odfijops]/g;\nconst PRETTY_PLACEHOLDER = '%p';\nconst INDEX_PLACEHOLDER = '%#';\nconst NUMBER_PLACEHOLDER = '%$';\nconst PLACEHOLDER_PREFIX = '%';\nconst ESCAPED_PLACEHOLDER_PREFIX = '%%';\nconst JEST_EACH_PLACEHOLDER_ESCAPE = '@@__JEST_EACH_PLACEHOLDER_ESCAPE__@@';\n\nexport default function array(\n  title: string,\n  arrayTable: Global.ArrayTable,\n): EachTests {\n  if (isTemplates(title, arrayTable)) {\n    return arrayTable.map((template, index) => ({\n      arguments: [template],\n      title: interpolateVariables(title, template, index).replaceAll(\n        ESCAPED_PLACEHOLDER_PREFIX,\n        PLACEHOLDER_PREFIX,\n      ),\n    }));\n  }\n  return normaliseTable(arrayTable).map((row, index) => ({\n    arguments: row,\n    title: formatTitle(title, row, index),\n  }));\n}\n\nconst isTemplates = (\n  title: string,\n  arrayTable: Global.ArrayTable,\n): arrayTable is Templates =>\n  !SUPPORTED_PLACEHOLDERS.test(interpolateEscapedPlaceholders(title)) &&\n  !isTable(arrayTable) &&\n  arrayTable.every(col => col != null && typeof col === 'object');\n\nconst normaliseTable = (table: Global.ArrayTable): Global.Table =>\n  isTable(table) ? table : table.map(colToRow);\n\nconst isTable = (table: Global.ArrayTable): table is Global.Table =>\n  table.every(Array.isArray);\n\nconst colToRow = (col: Global.Col): Global.Row => [col];\n\nconst formatTitle = (\n  title: string,\n  row: Global.Row,\n  rowIndex: number,\n): string =>\n  row\n    .reduce<string>(\n      (formattedTitle, value) => {\n        const [placeholder] = getMatchingPlaceholders(formattedTitle);\n        const normalisedValue = normalisePlaceholderValue(value);\n        if (!placeholder) return formattedTitle;\n\n        if (placeholder === PRETTY_PLACEHOLDER)\n          return interpolatePrettyPlaceholder(formattedTitle, normalisedValue);\n\n        return util.format(formattedTitle, normalisedValue);\n      },\n      interpolateTitleIndexAndNumber(\n        interpolateEscapedPlaceholders(title),\n        rowIndex,\n      ),\n    )\n    .replaceAll(JEST_EACH_PLACEHOLDER_ESCAPE, PLACEHOLDER_PREFIX);\n\nconst normalisePlaceholderValue = (value: unknown) =>\n  typeof value === 'string'\n    ? value.replaceAll(PLACEHOLDER_PREFIX, JEST_EACH_PLACEHOLDER_ESCAPE)\n    : value;\n\nconst getMatchingPlaceholders = (title: string) =>\n  title.match(SUPPORTED_PLACEHOLDERS) || [];\n\nconst interpolateEscapedPlaceholders = (title: string) =>\n  title.replaceAll(ESCAPED_PLACEHOLDER_PREFIX, JEST_EACH_PLACEHOLDER_ESCAPE);\n\nconst interpolateTitleIndexAndNumber = (title: string, index: number) =>\n  title\n    .replace(INDEX_PLACEHOLDER, index.toString())\n    .replace(NUMBER_PLACEHOLDER, (index + 1).toString());\n\nconst interpolatePrettyPlaceholder = (title: string, value: unknown) =>\n  title.replace(PRETTY_PLACEHOLDER, pretty(value, {maxDepth: 1, min: true}));\n",
  "packages/jest-each/src/table/array.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport type { Global } from '@jest/types';\nimport type { EachTests } from '../bind';\nexport default function array(title: string, arrayTable: Global.ArrayTable): EachTests;\n",
  "packages/jest-each/src/__tests__/template.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {Global} from '@jest/types';\nimport each from '../';\n\nconst noop = () => {};\nconst expectFunction = expect.any(Function);\n\nconst get = <T>(\n  object: T,\n  lensPath: Array<string>,\n): ((...args: Array<unknown>) => unknown) =>\n  lensPath.reduce((acc, key) => acc[key], object);\n\nconst getGlobalTestMocks =\n  (): jest.MockedObject<Global.TestFrameworkGlobals> => {\n    const globals: any = {\n      describe: jest.fn(),\n      fdescribe: jest.fn(),\n      fit: jest.fn(),\n      it: jest.fn(),\n      test: jest.fn(),\n      xdescribe: jest.fn(),\n      xit: jest.fn(),\n      xtest: jest.fn(),\n    };\n    globals.test.only = jest.fn();\n    globals.test.skip = jest.fn();\n    globals.test.concurrent = jest.fn();\n    globals.test.concurrent.only = jest.fn();\n    globals.test.concurrent.skip = jest.fn();\n    globals.it.only = jest.fn();\n    globals.it.skip = jest.fn();\n    globals.describe.only = jest.fn();\n    globals.describe.skip = jest.fn();\n    return globals;\n  };\n\ndescribe('jest-each', () => {\n  for (const keyPath of [\n    ['test'],\n    ['test', 'concurrent'],\n    ['test', 'concurrent', 'only'],\n    ['test', 'concurrent', 'skip'],\n    ['test', 'only'],\n    ['it'],\n    ['fit'],\n    ['it', 'only'],\n    ['describe'],\n    ['fdescribe'],\n    ['describe', 'only'],\n  ]) {\n    describe(`.${keyPath.join('.')}`, () => {\n      test('throws error when there are additional words in first column heading', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n          a is the left | b    | expected\n          ${1}          | ${1} | ${2}\n        `;\n        const testFunction = get(eachObject, keyPath);\n        const testCallBack = jest.fn();\n        testFunction('this will blow up :(', testCallBack);\n\n        const globalMock = get(globalTestMocks, keyPath);\n\n        expect(() =>\n          jest.mocked(globalMock).mock.calls[0][1](),\n        ).toThrowErrorMatchingSnapshot();\n        expect(testCallBack).not.toHaveBeenCalled();\n      });\n\n      test('does not throw error when there are multibyte characters in first column headings', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n         ʅ(ツ)ʃ  | b    | expected\n          ${1}          | ${1} | ${2}\n        `;\n        const testFunction = get(eachObject, keyPath);\n        const testCallBack = jest.fn();\n        testFunction('accept multibyte characters', testCallBack);\n\n        const globalMock = get(globalTestMocks, keyPath);\n\n        expect(() => jest.mocked(globalMock).mock.calls[0][1]()).not.toThrow();\n        expect(testCallBack).toHaveBeenCalledWith({\n          b: 1,\n          expected: 2,\n          'ʅ(ツ)ʃ': 1,\n        });\n      });\n\n      test('throws error when there are additional words in second column heading', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n          a    | b is the right | expected\n          ${1}          | ${1} | ${2}\n        `;\n        const testFunction = get(eachObject, keyPath);\n        const testCallBack = jest.fn();\n        testFunction('this will blow up :(', testCallBack);\n\n        const globalMock = get(globalTestMocks, keyPath);\n\n        expect(() =>\n          jest.mocked(globalMock).mock.calls[0][1](),\n        ).toThrowErrorMatchingSnapshot();\n        expect(testCallBack).not.toHaveBeenCalled();\n      });\n\n      test('does not throw error when there are multibyte characters in second column headings', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n          a    | ☝(ʕ⊙ḕ⊙ʔ)☝  | expected\n          ${1} | ${1}           | ${2}\n        `;\n        const testFunction = get(eachObject, keyPath);\n        const testCallBack = jest.fn();\n        testFunction('accept multibyte characters', testCallBack);\n\n        const globalMock = get(globalTestMocks, keyPath);\n\n        expect(() => jest.mocked(globalMock).mock.calls[0][1]()).not.toThrow();\n        expect(testCallBack).toHaveBeenCalledWith({\n          a: 1,\n          expected: 2,\n          '☝(ʕ⊙ḕ⊙ʔ)☝': 1,\n        });\n      });\n\n      test('throws error when there are additional words in last column heading', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n          a    | b    | expected value\n          ${1}          | ${1} | ${2}\n        `;\n        const testFunction = get(eachObject, keyPath);\n        const testCallBack = jest.fn();\n        testFunction('this will blow up :(', testCallBack);\n\n        const globalMock = get(globalTestMocks, keyPath);\n\n        expect(() =>\n          jest.mocked(globalMock).mock.calls[0][1](),\n        ).toThrowErrorMatchingSnapshot();\n        expect(testCallBack).not.toHaveBeenCalled();\n      });\n\n      test('does not throw error when there are multibyte characters in last column headings', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n          a    | b    | (๑ఠ‿ఠ๑)＜expected\n          ${1} | ${1} | ${2}\n        `;\n        const testFunction = get(eachObject, keyPath);\n        const testCallBack = jest.fn();\n        testFunction('accept multibyte characters', testCallBack);\n\n        const globalMock = get(globalTestMocks, keyPath);\n\n        expect(() => jest.mocked(globalMock).mock.calls[0][1]()).not.toThrow();\n        expect(testCallBack).toHaveBeenCalledWith({\n          '(๑ఠ‿ఠ๑)＜expected': 2,\n          a: 1,\n          b: 1,\n        });\n      });\n\n      test('does not throw error when there is additional words in template after heading row', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n          a    | b    | expected\n          foo\n          bar\n          ${1} | ${1} | ${2}\n        `;\n        const testFunction = get(eachObject, keyPath);\n        const testCallBack = jest.fn();\n        testFunction('test title', testCallBack);\n\n        const globalMock = get(globalTestMocks, keyPath);\n\n        expect(globalMock).toHaveBeenCalledTimes(1);\n        expect(globalMock).toHaveBeenCalledWith(\n          'test title',\n          expectFunction,\n          undefined,\n        );\n      });\n\n      test('does not throw error when there is only one column', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n          a\n          ${1}\n        `;\n        const testFunction = get(eachObject, keyPath);\n        const testCallBack = jest.fn();\n        testFunction('test title', testCallBack);\n\n        const globalMock = get(globalTestMocks, keyPath);\n\n        expect(globalMock).toHaveBeenCalledTimes(1);\n        expect(globalMock).toHaveBeenCalledWith(\n          'test title',\n          expectFunction,\n          undefined,\n        );\n      });\n\n      test('does not throw error when there is only one column with additional words in template after heading', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n          a\n          hello world\n          ${1}\n        `;\n        const testFunction = get(eachObject, keyPath);\n        const testCallBack = jest.fn();\n        testFunction('test title $a', testCallBack);\n\n        const globalMock = get(globalTestMocks, keyPath);\n\n        expect(globalMock).toHaveBeenCalledTimes(1);\n        expect(globalMock).toHaveBeenCalledWith(\n          'test title 1',\n          expectFunction,\n          undefined,\n        );\n      });\n\n      test('throws error when there are no arguments for given headings', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n          a    | b    | expected\n        `;\n        const testFunction = get(eachObject, keyPath);\n        const testCallBack = jest.fn();\n        testFunction('this will blow up :(', testCallBack);\n\n        const globalMock = get(globalTestMocks, keyPath);\n\n        expect(() =>\n          jest.mocked(globalMock).mock.calls[0][1](),\n        ).toThrowErrorMatchingSnapshot();\n        expect(testCallBack).not.toHaveBeenCalled();\n      });\n\n      test('throws error when there are fewer arguments than headings when given one row', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n          a    | b    | expected\n          ${0} | ${1} |\n        `;\n        const testFunction = get(eachObject, keyPath);\n        const testCallBack = jest.fn();\n        testFunction('this will blow up :(', testCallBack);\n\n        const globalMock = get(globalTestMocks, keyPath);\n\n        expect(() =>\n          jest.mocked(globalMock).mock.calls[0][1](),\n        ).toThrowErrorMatchingSnapshot();\n        expect(testCallBack).not.toHaveBeenCalled();\n      });\n\n      test('throws error when there are fewer arguments than headings over multiple rows', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n          a    | b    | expected\n          ${0} | ${1} | ${1}\n          ${1} | ${1} |\n        `;\n        const testFunction = get(eachObject, keyPath);\n        const testCallBack = jest.fn();\n        testFunction('this will blow up :(', testCallBack);\n\n        const globalMock = get(globalTestMocks, keyPath);\n\n        expect(() =>\n          jest.mocked(globalMock).mock.calls[0][1](),\n        ).toThrowErrorMatchingSnapshot();\n        expect(testCallBack).not.toHaveBeenCalled();\n      });\n\n      test('throws an error when called with an empty string', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`   `;\n        const testFunction = get(eachObject, keyPath);\n        const testCallBack = jest.fn();\n        testFunction('this will blow up :(', testCallBack);\n\n        const globalMock = get(globalTestMocks, keyPath);\n\n        expect(() =>\n          jest.mocked(globalMock).mock.calls[0][1](),\n        ).toThrowErrorMatchingSnapshot();\n        expect(testCallBack).not.toHaveBeenCalled();\n      });\n\n      test('calls global with given title', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n          a    | b    | expected\n          ${0} | ${1} | ${1}\n        `;\n        const testFunction = get(eachObject, keyPath);\n        testFunction('expected string', noop);\n\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledTimes(1);\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string',\n          expectFunction,\n          undefined,\n        );\n      });\n\n      test('calls global with given title when multiple tests cases exist', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n          a    | b    | expected\n          ${0} | ${1} | ${1}\n          ${1} | ${1} | ${2}\n        `;\n        const testFunction = get(eachObject, keyPath);\n        testFunction('expected string', noop);\n\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledTimes(2);\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string',\n          expectFunction,\n          undefined,\n        );\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string',\n          expectFunction,\n          undefined,\n        );\n      });\n\n      test('calls global with title containing param values when using $variable format', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n          a    | b    | expected\n          ${0} | ${1} | ${1}\n          ${1} | ${1} | ${2}\n        `;\n        const testFunction = get(eachObject, keyPath);\n        testFunction(\n          'expected string: a=$a, b=$b, expected=$expected index=$#',\n          noop,\n        );\n\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledTimes(2);\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string: a=0, b=1, expected=1 index=0',\n          expectFunction,\n          undefined,\n        );\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string: a=1, b=1, expected=2 index=1',\n          expectFunction,\n          undefined,\n        );\n      });\n\n      test('calls global with title containing $key in multiple positions', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n          a    | b    | expected\n          ${0} | ${1} | ${1}\n          ${1} | ${1} | ${2}\n        `;\n        const testFunction = get(eachObject, keyPath);\n        testFunction(\n          'add($a, $b) expected string: a=$a, b=$b, expected=$expected index=$#',\n          noop,\n        );\n\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledTimes(2);\n        expect(globalMock).toHaveBeenCalledWith(\n          'add(0, 1) expected string: a=0, b=1, expected=1 index=0',\n          expectFunction,\n          undefined,\n        );\n        expect(globalMock).toHaveBeenCalledWith(\n          'add(1, 1) expected string: a=1, b=1, expected=2 index=1',\n          expectFunction,\n          undefined,\n        );\n      });\n\n      test('calls global with title containing $key.path', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n          a\n          ${{foo: {bar: 'baz'}}}\n        `;\n        const testFunction = get(eachObject, keyPath);\n        testFunction('interpolates object keyPath to value: $a.foo.bar', noop);\n\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledTimes(1);\n        expect(globalMock).toHaveBeenCalledWith(\n          'interpolates object keyPath to value: baz',\n          expectFunction,\n          undefined,\n        );\n      });\n\n      test.each([null, undefined])(\n        'calls global with title containing $key.path for %s',\n        value => {\n          const globalTestMocks = getGlobalTestMocks();\n          const eachObject = each.withGlobal(globalTestMocks)`\n          a\n          ${{foo: value}}\n        `;\n          const testFunction = get(eachObject, keyPath);\n          testFunction(\n            'interpolates object keyPath to value: $a.foo.bar',\n            noop,\n          );\n\n          const globalMock = get(globalTestMocks, keyPath);\n          expect(globalMock).toHaveBeenCalledTimes(1);\n          expect(globalMock).toHaveBeenCalledWith(\n            `interpolates object keyPath to value: ${value}`,\n            expectFunction,\n            undefined,\n          );\n        },\n      );\n\n      test('calls global with title containing last seen object when $key.path is invalid', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n          a\n          ${{foo: {bar: 'baz'}}}\n        `;\n        const testFunction = get(eachObject, keyPath);\n        testFunction('interpolates object keyPath to value: $a.foo.qux', noop);\n\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledTimes(1);\n        expect(globalMock).toHaveBeenCalledWith(\n          'interpolates object keyPath to value: {\"bar\": \"baz\"}',\n          expectFunction,\n          undefined,\n        );\n      });\n\n      test('calls global with cb function with object built from table headings and values', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const testCallBack = jest.fn();\n        const eachObject = each.withGlobal(globalTestMocks)`\n          a    | b    | expected\n          ${0} | ${1} | ${1}\n          ${1} | ${1} | ${2}\n        `;\n        const testFunction = get(eachObject, keyPath);\n        testFunction('expected string', testCallBack);\n\n        const globalMock = get(globalTestMocks, keyPath);\n\n        jest.mocked(globalMock).mock.calls[0][1]();\n        expect(testCallBack).toHaveBeenCalledTimes(1);\n        expect(testCallBack).toHaveBeenCalledWith({a: 0, b: 1, expected: 1});\n\n        jest.mocked(globalMock).mock.calls[1][1]();\n        expect(testCallBack).toHaveBeenCalledTimes(2);\n        expect(testCallBack).toHaveBeenCalledWith({a: 1, b: 1, expected: 2});\n      });\n\n      test('calls global with given timeout', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n          a    | b    | expected\n          ${0} | ${1} | ${1}\n        `;\n\n        const testFunction = get(eachObject, keyPath);\n        testFunction('some test', noop, 10_000);\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledWith(\n          'some test',\n          expect.any(Function),\n          10_000,\n        );\n      });\n\n      test('formats primitive values using .toString()', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const number = 1;\n        const string = 'hello';\n        const boolean = true;\n        const symbol = Symbol('world');\n        const nullValue = null;\n        const undefinedValue = undefined;\n        const eachObject = each.withGlobal(globalTestMocks)`\n          number | string | boolean | symbol | nullValue | undefinedValue\n          ${number} | ${string} | ${boolean} | ${symbol} | ${nullValue} | ${undefinedValue}\n        `;\n\n        const testFunction = get(eachObject, keyPath);\n        testFunction(\n          'number: $number | string: $string | boolean: $boolean | symbol: $symbol | null: $nullValue | undefined: $undefinedValue',\n          noop,\n        );\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledWith(\n          'number: 1 | string: hello | boolean: true | symbol: Symbol(world) | null: null | undefined: undefined',\n          expect.any(Function),\n          undefined,\n        );\n      });\n    });\n  }\n\n  describe('done callback', () => {\n    test.each([\n      [['test']],\n      [['test', 'only']],\n      [['test', 'concurrent', 'only']],\n      [['it']],\n      [['fit']],\n      [['it', 'only']],\n    ])(\n      'calls %O with done when cb function has more args than params of given test row',\n      keyPath => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n        a    | b    | expected\n        ${0} | ${1} | ${1}\n      `;\n        const testFunction = get(eachObject, keyPath);\n        testFunction('expected string', ({a, b, expected}, done) => {\n          expect(a).toBe(0);\n          expect(b).toBe(1);\n          expect(expected).toBe(1);\n          expect(done).toBe('DONE');\n        });\n        get(globalTestMocks, keyPath).mock.calls[0][1]('DONE');\n      },\n    );\n\n    test.each([[['describe']], [['fdescribe']], [['describe', 'only']]])(\n      'does not call %O with done when test function has more args than params of given test row',\n      keyPath => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n        a    | b    | expected\n        ${0} | ${1} | ${1}\n      `;\n        const testFunction = get(eachObject, keyPath);\n        testFunction('expected string', function ({a, b, expected}, done) {\n          expect(a).toBe(0);\n          expect(b).toBe(1);\n          expect(expected).toBe(1);\n          expect(done).toBeUndefined();\n          // eslint-disable-next-line prefer-rest-params\n          expect(arguments).toHaveLength(1);\n        });\n        get(globalTestMocks, keyPath).mock.calls[0][1]('DONE');\n      },\n    );\n  });\n\n  for (const keyPath of [\n    ['xtest'],\n    ['test', 'skip'],\n    ['test', 'concurrent'],\n    ['test', 'concurrent', 'skip'],\n    ['xit'],\n    ['it', 'skip'],\n    ['xdescribe'],\n    ['describe', 'skip'],\n  ]) {\n    describe(`.${keyPath.join('.')}`, () => {\n      test('calls global with given title', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n          a    | b    | expected\n          ${0} | ${1} | ${1}\n        `;\n        const testFunction = get(eachObject, keyPath);\n        testFunction('expected string', noop);\n\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledTimes(1);\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string',\n          expectFunction,\n          undefined,\n        );\n      });\n\n      test('calls global with given title when multiple tests cases exist', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n          a    | b    | expected\n          ${0} | ${1} | ${1}\n          ${1} | ${1} | ${2}\n        `;\n        const testFunction = get(eachObject, keyPath);\n        testFunction('expected string', noop);\n\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledTimes(2);\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string',\n          expectFunction,\n          undefined,\n        );\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string',\n          expectFunction,\n          undefined,\n        );\n      });\n\n      test('calls global with title containing param values when using $variable format', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n          a    | b    | expected\n          ${0} | ${1} | ${1}\n          ${1} | ${1} | ${2}\n        `;\n        const testFunction = get(eachObject, keyPath);\n        testFunction(\n          'expected string: a=$a, b=$b, expected=$expected index=$#',\n          noop,\n        );\n\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledTimes(2);\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string: a=0, b=1, expected=1 index=0',\n          expectFunction,\n          undefined,\n        );\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string: a=1, b=1, expected=2 index=1',\n          expectFunction,\n          undefined,\n        );\n      });\n\n      test('calls global with title containing param values when using fake $variable', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n          a    | b    | expected\n          ${0} | ${1} | ${1}\n          ${1} | ${1} | ${2}\n        `;\n        const testFunction = get(eachObject, keyPath);\n        testFunction(\n          'expected string: a=$a, b=$b, b=$b, b=$b.b, b=$fake, expected=$expected index=$#',\n          noop,\n        );\n\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledTimes(2);\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string: a=0, b=1, b=1, b=1, b=$fake, expected=1 index=0',\n          expectFunction,\n          undefined,\n        );\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string: a=1, b=1, b=1, b=1, b=$fake, expected=2 index=1',\n          expectFunction,\n          undefined,\n        );\n      });\n    });\n  }\n});\n",
  "packages/jest-each/src/__tests__/template.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport {};\n",
  "packages/jest-each/src/__tests__/index.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport each from '../';\n\ndescribe('array', () => {\n  describe('.add', () => {\n    each([\n      [0, 0, 0],\n      [0, 1, 1],\n      [1, 1, 2],\n    ]).test('returns the result of adding %s to %s', (a, b, expected) => {\n      expect(a + b).toBe(expected);\n    });\n  });\n});\n\ndescribe('concurrent', () => {\n  describe('.add', () => {\n    each([\n      [0, 0, 0],\n      [0, 1, 1],\n      [1, 1, 2],\n    ]).test.concurrent(\n      'returns the result of adding %s to %s',\n      async (a, b, expected) => {\n        expect(a + b).toBe(expected);\n      },\n    );\n  });\n});\n\ndescribe('template', () => {\n  describe('.add', () => {\n    each`\n      a    | b    | expected\n      ${0} | ${0} | ${0}\n      ${0} | ${1} | ${1}\n      ${1} | ${1} | ${2}\n    `.test('returns $expected when given $a and $b', ({a, b, expected}) => {\n      expect(a + b).toBe(expected);\n    });\n  });\n});\n\ntest('throws an error when not called with the right number of arguments', () => {\n  expect(() =>\n    each(\n      [\n        [1, 1, 2],\n        [1, 2, 3],\n        [2, 1, 3],\n      ],\n      'seems like a title but should not be here',\n      () => {},\n    ),\n  ).toThrowErrorMatchingSnapshot();\n});\n",
  "packages/jest-each/src/__tests__/index.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport {};\n",
  "packages/jest-each/src/__tests__/array.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport pretty from 'pretty-format';\nimport each from '../';\n\nconst noop = () => {};\nconst expectFunction = expect.any(Function);\n\nconst get = <T>(object: T, lensPath: Array<string>): T =>\n  lensPath.reduce((acc, key) => acc[key], object);\n\nconst getGlobalTestMocks = () => {\n  const globals: any = {\n    describe: jest.fn(),\n    fdescribe: jest.fn(),\n    fit: jest.fn(),\n    it: jest.fn(),\n    test: jest.fn(),\n    xdescribe: jest.fn(),\n    xit: jest.fn(),\n    xtest: jest.fn(),\n  };\n  globals.test.only = jest.fn();\n  globals.test.skip = jest.fn();\n  globals.test.concurrent = jest.fn();\n  globals.test.concurrent.only = jest.fn();\n  globals.test.concurrent.skip = jest.fn();\n  globals.it.only = jest.fn();\n  globals.it.skip = jest.fn();\n  globals.describe.only = jest.fn();\n  globals.describe.skip = jest.fn();\n  return globals;\n};\n\ndescribe('jest-each', () => {\n  for (const keyPath of [\n    ['test'],\n    ['test', 'concurrent'],\n    ['test', 'concurrent', 'only'],\n    ['test', 'concurrent', 'skip'],\n    ['test', 'only'],\n    ['it'],\n    ['fit'],\n    ['it', 'only'],\n    ['describe'],\n    ['fdescribe'],\n    ['describe', 'only'],\n  ]) {\n    describe(`.${keyPath.join('.')}`, () => {\n      test('throws an error when not called with an array', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)(undefined);\n        const testFunction = get(eachObject, keyPath);\n\n        testFunction('expected string', noop);\n        const globalMock = get(globalTestMocks, keyPath);\n\n        expect(() =>\n          globalMock.mock.calls[0][1](),\n        ).toThrowErrorMatchingSnapshot();\n      });\n\n      test('throws an error when called with an empty array', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)([]);\n        const testFunction = get(eachObject, keyPath);\n\n        testFunction('expected string', noop);\n        const globalMock = get(globalTestMocks, keyPath);\n\n        expect(() =>\n          globalMock.mock.calls[0][1](),\n        ).toThrowErrorMatchingSnapshot();\n      });\n\n      test('calls global with given title', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)([[]]);\n        const testFunction = get(eachObject, keyPath);\n        testFunction('expected string', noop);\n\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledTimes(1);\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string',\n          expectFunction,\n          undefined,\n        );\n      });\n\n      test('calls global with given title when multiple tests cases exist', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)([[], []]);\n        const testFunction = get(eachObject, keyPath);\n        testFunction('expected string', noop);\n\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledTimes(2);\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string',\n          expectFunction,\n          undefined,\n        );\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string',\n          expectFunction,\n          undefined,\n        );\n      });\n\n      test('calls global with title containing param values when using printf format', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)([\n          [\n            'hello',\n            1,\n            null,\n            undefined,\n            1.2,\n            {foo: 'bar'},\n            () => {},\n            [],\n            Number.POSITIVE_INFINITY,\n            Number.NaN,\n          ],\n          [\n            'world',\n            1,\n            null,\n            undefined,\n            1.2,\n            {baz: 'qux'},\n            () => {},\n            [],\n            Number.POSITIVE_INFINITY,\n            Number.NaN,\n          ],\n        ]);\n        const testFunction = get(eachObject, keyPath);\n        testFunction(\n          'expected string: %% %%s %s %d %s %s %d %j %s %j %d %d %# %$',\n          noop,\n        );\n\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledTimes(2);\n        expect(globalMock).toHaveBeenCalledWith(\n          `expected string: % %s hello 1 null undefined 1.2 ${JSON.stringify({\n            foo: 'bar',\n          })} () => {} [] Infinity NaN 0 1`,\n          expectFunction,\n          undefined,\n        );\n        expect(globalMock).toHaveBeenCalledWith(\n          `expected string: % %s world 1 null undefined 1.2 ${JSON.stringify({\n            baz: 'qux',\n          })} () => {} [] Infinity NaN 1 2`,\n          expectFunction,\n          undefined,\n        );\n      });\n\n      test('does not call global test with title containing more param values than sprintf placeholders', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)([\n          ['hello', 1, 2, 3, 4, 5],\n          ['world', 1, 2, 3, 4, 5],\n        ]);\n        const testFunction = get(eachObject, keyPath);\n        testFunction('expected string: %s', noop);\n\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledTimes(2);\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string: hello',\n          expectFunction,\n          undefined,\n        );\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string: world',\n          expectFunction,\n          undefined,\n        );\n      });\n\n      test('calls global test title with %p placeholder injected at the correct positions', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)([\n          ['string1', 'pretty1', 'string2', 'pretty2'],\n          ['string1', 'pretty1', 'string2', 'pretty2'],\n        ]);\n        const testFunction = get(eachObject, keyPath);\n        testFunction('expected string: %s %p %s %p', noop);\n\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledTimes(2);\n        expect(globalMock).toHaveBeenCalledWith(\n          `expected string: string1 ${pretty('pretty1')} string2 ${pretty(\n            'pretty2',\n          )}`,\n          expectFunction,\n          undefined,\n        );\n        expect(globalMock).toHaveBeenCalledWith(\n          `expected string: string1 ${pretty('pretty1')} string2 ${pretty(\n            'pretty2',\n          )}`,\n          expectFunction,\n          undefined,\n        );\n      });\n\n      test('does not calls global test title with %p placeholder when no data is supplied at given position', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)([\n          ['string1', 'pretty1', 'string2'],\n          ['string1', 'pretty1', 'string2'],\n        ]);\n        const testFunction = get(eachObject, keyPath);\n        testFunction('expected string: %s %p %s %p', noop);\n\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledTimes(2);\n        expect(globalMock).toHaveBeenCalledWith(\n          `expected string: string1 ${pretty('pretty1')} string2 %p`,\n          expectFunction,\n          undefined,\n        );\n        expect(globalMock).toHaveBeenCalledWith(\n          `expected string: string1 ${pretty('pretty1')} string2 %p`,\n          expectFunction,\n          undefined,\n        );\n      });\n\n      test('calls global with cb function containing all parameters of each test case when given 1d array', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const testCallBack = jest.fn();\n        const eachObject = each.withGlobal(globalTestMocks)(['hello', 'world']);\n        const testFunction = get(eachObject, keyPath);\n        testFunction('expected string', testCallBack);\n\n        const globalMock = get(globalTestMocks, keyPath);\n\n        globalMock.mock.calls[0][1]();\n        expect(testCallBack).toHaveBeenCalledTimes(1);\n        expect(testCallBack).toHaveBeenCalledWith('hello');\n\n        globalMock.mock.calls[1][1]();\n        expect(testCallBack).toHaveBeenCalledTimes(2);\n        expect(testCallBack).toHaveBeenCalledWith('world');\n      });\n\n      test('calls global with cb function containing all parameters of each test case 2d array', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const testCallBack = jest.fn();\n        const eachObject = each.withGlobal(globalTestMocks)([\n          ['hello', 'world'],\n          ['joe', 'bloggs'],\n        ]);\n        const testFunction = get(eachObject, keyPath);\n        testFunction('expected string', testCallBack);\n\n        const globalMock = get(globalTestMocks, keyPath);\n\n        globalMock.mock.calls[0][1]();\n        expect(testCallBack).toHaveBeenCalledTimes(1);\n        expect(testCallBack).toHaveBeenCalledWith('hello', 'world');\n\n        globalMock.mock.calls[1][1]();\n        expect(testCallBack).toHaveBeenCalledTimes(2);\n        expect(testCallBack).toHaveBeenCalledWith('joe', 'bloggs');\n      });\n\n      test('calls global with given timeout', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)([['hello']]);\n\n        const testFunction = get(eachObject, keyPath);\n        testFunction('some test', noop, 10_000);\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledWith(\n          'some test',\n          expect.any(Function),\n          10_000,\n        );\n      });\n\n      test('calls global with title containing object property when using $variable', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)([\n          {\n            a: 'hello',\n            b: 1,\n            c: null,\n            d: undefined,\n            e: 1.2,\n            f: {key: 'foo'},\n            g: () => {},\n            h: [],\n            i: Number.POSITIVE_INFINITY,\n            j: Number.NaN,\n          },\n          {\n            a: 'world',\n            b: 1,\n            c: null,\n            d: undefined,\n            e: 1.2,\n            f: {key: 'bar'},\n            g: () => {},\n            h: [],\n            i: Number.POSITIVE_INFINITY,\n            j: Number.NaN,\n          },\n        ]);\n        const testFunction = get(eachObject, keyPath);\n        testFunction(\n          'expected string: %% %%s $a $b $c $d $e $f $f.key $g $h $i $j $#',\n          noop,\n        );\n\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledTimes(2);\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string: % %s hello 1 null undefined 1.2 {\"key\": \"foo\"} foo [Function g] [] Infinity NaN 0',\n          expectFunction,\n          undefined,\n        );\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string: % %s world 1 null undefined 1.2 {\"key\": \"bar\"} bar [Function g] [] Infinity NaN 1',\n          expectFunction,\n          undefined,\n        );\n      });\n\n      test('calls global with title containing param values when using both % placeholder and $variable', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)([\n          {\n            a: 'hello',\n            b: 1,\n          },\n          {\n            a: 'world',\n            b: 1,\n          },\n        ]);\n        const testFunction = get(eachObject, keyPath);\n        testFunction('expected string: %p %# $a $b $#', noop);\n\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledTimes(2);\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string: {\"a\": \"hello\", \"b\": 1} 0 $a $b $#',\n          expectFunction,\n          undefined,\n        );\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string: {\"a\": \"world\", \"b\": 1} 1 $a $b $#',\n          expectFunction,\n          undefined,\n        );\n      });\n\n      test('calls global with title containing param values when using %#', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)([\n          {name: 'foo'},\n          {name: 'bar'},\n        ]);\n        const testFunction = get(eachObject, keyPath);\n        testFunction('expected index: %#', () => {});\n\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledTimes(2);\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected index: 0',\n          expectFunction,\n          undefined,\n        );\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected index: 1',\n          expectFunction,\n          undefined,\n        );\n      });\n\n      test('calls global with title containing param values when using $#', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)([\n          {name: 'foo'},\n          {name: 'bar'},\n        ]);\n        const testFunction = get(eachObject, keyPath);\n        testFunction('expected index: $#', () => {});\n\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledTimes(2);\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected index: 0',\n          expectFunction,\n          undefined,\n        );\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected index: 1',\n          expectFunction,\n          undefined,\n        );\n      });\n    });\n  }\n\n  describe('done callback', () => {\n    test.each([\n      [['test']],\n      [['test', 'only']],\n      [['test', 'concurrent']],\n      [['test', 'concurrent', 'only']],\n      [['it']],\n      [['fit']],\n      [['it', 'only']],\n    ])(\n      'calls %O with done when cb function has more args than params of given test row',\n      keyPath => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)([['hello']]);\n\n        const testFunction = get(eachObject, keyPath);\n        testFunction('expected string', (hello, done) => {\n          expect(hello).toBe('hello');\n          expect(done).toBe('DONE');\n        });\n        get(globalTestMocks, keyPath).mock.calls[0][1]('DONE');\n      },\n    );\n\n    test.each([[['describe']], [['fdescribe']], [['describe', 'only']]])(\n      'does not call %O with done when test function has more args than params of given test row',\n      keyPath => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)([['hello']]);\n\n        const testFunction = get(eachObject, keyPath);\n        testFunction('expected string', function (hello, done) {\n          expect(hello).toBe('hello');\n          // eslint-disable-next-line prefer-rest-params\n          expect(arguments).toHaveLength(1);\n          expect(done).toBeUndefined();\n        });\n        get(globalTestMocks, keyPath).mock.calls[0][1]('DONE');\n      },\n    );\n  });\n\n  for (const keyPath of [\n    ['xtest'],\n    ['test', 'skip'],\n    ['test', 'concurrent', 'skip'],\n    ['xit'],\n    ['it', 'skip'],\n    ['xdescribe'],\n    ['describe', 'skip'],\n  ]) {\n    describe(`.${keyPath.join('.')}`, () => {\n      test('calls global with given title', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)([[]]);\n        const testFunction = get(eachObject, keyPath);\n        testFunction('expected string', noop);\n\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledTimes(1);\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string',\n          expectFunction,\n          undefined,\n        );\n      });\n\n      test('calls global with given title when multiple tests cases exist', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)([[], []]);\n        const testFunction = get(eachObject, keyPath);\n        testFunction('expected string', noop);\n\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledTimes(2);\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string',\n          expectFunction,\n          undefined,\n        );\n      });\n\n      test('calls global with title containing param values when using sprintf format', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)([\n          ['hello', 1],\n          ['world', 2],\n        ]);\n        const testFunction = get(eachObject, keyPath);\n        testFunction('expected string: %s %s', () => {});\n\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledTimes(2);\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string: hello 1',\n          expectFunction,\n          undefined,\n        );\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string: world 2',\n          expectFunction,\n          undefined,\n        );\n      });\n\n      test('calls global with title with placeholder values correctly interpolated', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)([\n          ['hello', '%d', 10, '%s', {foo: 'bar'}],\n          ['world', '%i', 1991, '%p', {foo: 'bar'}],\n          ['joe', '%d %d', 10, '%%s', {foo: 'bar'}],\n        ]);\n        const testFunction = get(eachObject, keyPath);\n        testFunction('expected string: %s %s %d %s %p', () => {});\n\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledTimes(3);\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string: hello %d 10 %s {\"foo\": \"bar\"}',\n          expectFunction,\n          undefined,\n        );\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string: world %i 1991 %p {\"foo\": \"bar\"}',\n          expectFunction,\n          undefined,\n        );\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string: joe %d %d 10 %%s {\"foo\": \"bar\"}',\n          expectFunction,\n          undefined,\n        );\n      });\n    });\n  }\n});\n",
  "packages/jest-each/src/__tests__/array.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport {};\n",
  "packages/jest-docblock/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {EOL} from 'os';\nimport detectNewline from 'detect-newline';\n\ntype Pragmas = Record<string, string | Array<string>>;\n\nconst commentEndRe = /\\*\\/$/;\nconst commentStartRe = /^\\/\\*\\*?/;\nconst docblockRe = /^\\s*(\\/\\*\\*?(.|\\r?\\n)*?\\*\\/)/;\nconst lineCommentRe = /(^|\\s+)\\/\\/([^\\n\\r]*)/g;\nconst ltrimNewlineRe = /^(\\r?\\n)+/;\nconst multilineRe =\n  /(?:^|\\r?\\n) *(@[^\\n\\r]*?) *\\r?\\n *(?![^\\n\\r@]*\\/\\/[^]*)([^\\s@][^\\n\\r@]+?) *\\r?\\n/g;\nconst propertyRe = /(?:^|\\r?\\n) *@(\\S+) *([^\\n\\r]*)/g;\nconst stringStartRe = /(\\r?\\n|^) *\\* ?/g;\nconst STRING_ARRAY: ReadonlyArray<string> = [];\n\nexport function extract(contents: string): string {\n  const match = contents.match(docblockRe);\n  return match ? match[0].trimStart() : '';\n}\n\nexport function strip(contents: string): string {\n  const matchResult = contents.match(docblockRe);\n  const match = matchResult?.[0];\n  return match == null ? contents : contents.slice(match.length);\n}\n\nexport function parse(docblock: string): Pragmas {\n  return parseWithComments(docblock).pragmas;\n}\n\nexport function parseWithComments(docblock: string): {\n  comments: string;\n  pragmas: Pragmas;\n} {\n  const line = detectNewline(docblock) ?? EOL;\n\n  docblock = docblock\n    .replace(commentStartRe, '')\n    .replace(commentEndRe, '')\n    .replaceAll(stringStartRe, '$1');\n\n  // Normalize multi-line directives\n  let prev = '';\n  while (prev !== docblock) {\n    prev = docblock;\n    docblock = docblock.replaceAll(multilineRe, `${line}$1 $2${line}`);\n  }\n  docblock = docblock.replace(ltrimNewlineRe, '').trimEnd();\n\n  const result = Object.create(null) as Pragmas;\n  const comments = docblock\n    .replaceAll(propertyRe, '')\n    .replace(ltrimNewlineRe, '')\n    .trimEnd();\n\n  let match;\n  while ((match = propertyRe.exec(docblock))) {\n    // strip linecomments from pragmas\n    const nextPragma = match[2].replaceAll(lineCommentRe, '');\n    if (\n      typeof result[match[1]] === 'string' ||\n      Array.isArray(result[match[1]])\n    ) {\n      const resultElement = result[match[1]];\n      result[match[1]] = [\n        ...STRING_ARRAY,\n        ...(Array.isArray(resultElement) ? resultElement : [resultElement]),\n        nextPragma,\n      ];\n    } else {\n      result[match[1]] = nextPragma;\n    }\n  }\n  return {comments, pragmas: result};\n}\n\nexport function print({\n  comments = '',\n  pragmas = {},\n}: {\n  comments?: string;\n  pragmas?: Pragmas;\n}): string {\n  const line = detectNewline(comments) ?? EOL;\n  const head = '/**';\n  const start = ' *';\n  const tail = ' */';\n\n  const keys = Object.keys(pragmas);\n\n  const printedObject = keys\n    .flatMap(key => printKeyValues(key, pragmas[key]))\n    .map(keyValue => `${start} ${keyValue}${line}`)\n    .join('');\n\n  if (!comments) {\n    if (keys.length === 0) {\n      return '';\n    }\n    if (keys.length === 1 && !Array.isArray(pragmas[keys[0]])) {\n      const value = pragmas[keys[0]];\n      return `${head} ${printKeyValues(keys[0], value)[0]}${tail}`;\n    }\n  }\n\n  const printedComments =\n    comments\n      .split(line)\n      .map(textLine => `${start} ${textLine}`)\n      .join(line) + line;\n\n  return (\n    head +\n    line +\n    (comments ? printedComments : '') +\n    (comments && keys.length > 0 ? start + line : '') +\n    printedObject +\n    tail\n  );\n}\n\nfunction printKeyValues(key: string, valueOrArray: string | Array<string>) {\n  return [\n    ...STRING_ARRAY,\n    ...(Array.isArray(valueOrArray) ? valueOrArray : [valueOrArray]),\n  ].map(value => `@${key} ${value}`.trim());\n}\n",
  "packages/jest-docblock/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\ntype Pragmas = Record<string, string | Array<string>>;\nexport declare function extract(contents: string): string;\nexport declare function strip(contents: string): string;\nexport declare function parse(docblock: string): Pragmas;\nexport declare function parseWithComments(docblock: string): {\n    comments: string;\n    pragmas: Pragmas;\n};\nexport declare function print({ comments, pragmas, }: {\n    comments?: string;\n    pragmas?: Pragmas;\n}): string;\nexport {};\n",
  "packages/jest-docblock/src/__tests__/index.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {EOL} from 'os';\nimport * as docblock from '..';\n\ndescribe('docblock', () => {\n  it('extracts valid docblock with line comment', () => {\n    const code = `/**${EOL} * @team foo${EOL}* // TODO: test${EOL}*/${EOL}const x = foo;`;\n    expect(docblock.extract(code)).toBe(\n      `/**${EOL} * @team foo${EOL}* // TODO: test${EOL}*/`,\n    );\n  });\n\n  it('extracts valid docblock', () => {\n    const code = `/**${EOL} * @team foo${EOL}*/${EOL}const x = foo;`;\n    expect(docblock.extract(code)).toBe(`/**${EOL} * @team foo${EOL}*/`);\n  });\n\n  it('extracts valid docblock with more comments', () => {\n    const code = `/**${EOL} * @team foo${EOL}*/${EOL}const x = foo;${EOL}/**foo*/`;\n    expect(docblock.extract(code)).toBe(`/**${EOL} * @team foo${EOL}*/`);\n  });\n\n  it('extracts from invalid docblock', () => {\n    const code = `/*${EOL} * @team foo${EOL}*/${EOL}const x = foo;`;\n    expect(docblock.extract(code)).toBe(`/*${EOL} * @team foo${EOL}*/`);\n  });\n\n  it('extracts from invalid docblock singleline', () => {\n    const code = `/* some comment @team foo */${EOL}const x = foo;`;\n    expect(docblock.extract(code)).toBe('/* some comment @team foo */');\n  });\n\n  it('returns extract and parsedocblock', () => {\n    const code = `/** @provides module-name */${EOL}${EOL}.dummy {}${EOL}`;\n\n    expect(docblock.parse(docblock.extract(code))).toEqual({\n      provides: 'module-name',\n    });\n  });\n\n  it('parses directives out of a docblock', () => {\n    const code =\n      `/**${EOL}` +\n      ` * @team foo${EOL}` +\n      ` * @css a b${EOL}` +\n      ` * @preserve-whitespace${EOL}` +\n      ' */';\n    expect(docblock.parse(code)).toEqual({\n      css: 'a b',\n      'preserve-whitespace': '',\n      team: 'foo',\n    });\n  });\n\n  it('parses multiple of the same directives out of a docblock', () => {\n    const code =\n      `/**${EOL}` +\n      ` * @x foo${EOL}` +\n      ` * @x bar${EOL}` +\n      ` * @y${EOL}` +\n      ' */';\n    expect(docblock.parse(code)).toEqual({\n      x: ['foo', 'bar'],\n      y: '',\n    });\n  });\n\n  it('parses >=3 of the same directives out of a docblock', () => {\n    const code =\n      `/**${EOL}` +\n      ` * @x foo${EOL}` +\n      ` * @x bar${EOL}` +\n      ` * @x baz${EOL}` +\n      ' */';\n    expect(docblock.parse(code)).toEqual({\n      x: ['foo', 'bar', 'baz'],\n    });\n  });\n\n  it('parses directives out of a docblock with comments', () => {\n    const code =\n      `/**${EOL}` +\n      ` * Copyright (c) Meta Platforms, Inc. and affiliates.${EOL}` +\n      ` * @team foo${EOL}` +\n      ` * @css a b${EOL}` +\n      ` *${EOL}` +\n      ` * And some license here${EOL}` +\n      ` * @preserve-whitespace${EOL}` +\n      ' */';\n    expect(docblock.parse(code)).toEqual({\n      css: 'a b',\n      'preserve-whitespace': '',\n      team: 'foo',\n    });\n  });\n\n  it('parses directives out of a docblock with line comments', () => {\n    const code = `/**${EOL} * @team foo${EOL} * // TODO: test${EOL} */`;\n    expect(docblock.parseWithComments(code)).toEqual({\n      comments: '// TODO: test',\n      pragmas: {team: 'foo'},\n    });\n  });\n\n  it('parses multiline directives', () => {\n    const code =\n      `/**${EOL}` +\n      ` * Copyright (c) Meta Platforms, Inc. and affiliates.${EOL}` +\n      ` * @class A long declaration of a class${EOL}` +\n      ` *        goes here, so we can read it and enjoy${EOL}` +\n      ` *${EOL}` +\n      ` * And some license here${EOL}` +\n      ` * @preserve-whitespace${EOL}` +\n      ' */';\n    expect(docblock.parse(code)).toEqual({\n      class:\n        'A long declaration of a class goes here, ' +\n        'so we can read it and enjoy',\n      'preserve-whitespace': '',\n    });\n  });\n\n  it('parses multiline directives even if there are linecomments within the docblock', () => {\n    const code =\n      `/**${EOL}` +\n      ` * Copyright (c) Meta Platforms, Inc. and affiliates.${EOL}` +\n      ` * @class A long declaration of a class${EOL}` +\n      ` *        goes here, so we can read it and enjoy${EOL}` +\n      ` *${EOL}` +\n      ` * And some license here${EOL}` +\n      ` * @preserve-whitespace${EOL}` +\n      '// heres a comment' +\n      ' */';\n    expect(docblock.parseWithComments(code)).toEqual({\n      comments: `Copyright (c) Meta Platforms, Inc. and affiliates.${EOL}${EOL}And some license here${EOL}// heres a comment`,\n      pragmas: {\n        class:\n          'A long declaration of a class goes here, ' +\n          'so we can read it and enjoy',\n        'preserve-whitespace': '',\n      },\n    });\n  });\n\n  it('supports slashes in @team directive', () => {\n    const code = `/**${EOL} * @team apple/banana${EOL} */`;\n    expect(docblock.parse(code)).toEqual({\n      team: 'apple/banana',\n    });\n  });\n\n  it('extracts comments from docblock', () => {\n    const code = `/**${EOL} * hello world${EOL} * @flow yes${EOL} */`;\n    expect(docblock.parseWithComments(code)).toEqual({\n      comments: 'hello world',\n      pragmas: {flow: 'yes'},\n    });\n  });\n\n  it('extracts multiline comments from docblock', () => {\n    const code = `/**${EOL} * hello${EOL} * world${EOL} * @flow yes${EOL} */`;\n    expect(docblock.parseWithComments(code)).toEqual({\n      comments: `hello${EOL}world`,\n      pragmas: {flow: 'yes'},\n    });\n  });\n\n  it('preserves leading whitespace in multiline comments from docblock', () => {\n    const code = `/**${EOL} *  hello${EOL} *   world${EOL} */`;\n\n    expect(docblock.parseWithComments(code).comments).toBe(\n      ` hello${EOL}  world`,\n    );\n  });\n\n  it('removes leading newlines in multiline comments from docblock', () => {\n    const code = `/**${EOL} * @snailcode${EOL} *${EOL} *  hello world${EOL} */`;\n\n    expect(docblock.parseWithComments(code).comments).toBe(' hello world');\n  });\n\n  it('extracts comments from beginning and end of docblock', () => {\n    const code = `/**${EOL} * hello${EOL} * @flow yes${EOL} * ${EOL} * world${EOL} */`;\n    expect(docblock.parseWithComments(code)).toEqual({\n      comments: `hello${EOL}${EOL}world`,\n      pragmas: {flow: 'yes'},\n    });\n  });\n\n  it(\"preserve urls within a pragma's values\", () => {\n    const code = `/**${EOL} * @see: https://example.com${EOL} */`;\n    expect(docblock.parseWithComments(code)).toEqual({\n      comments: '',\n      pragmas: {'see:': 'https://example.com'},\n    });\n  });\n\n  it('strip linecomments from pragmas but preserve for comments', () => {\n    const code = `/**${EOL} * @format: everything${EOL}// keep me */`;\n    expect(docblock.parseWithComments(code)).toEqual({\n      comments: '// keep me',\n      pragmas: {'format:': 'everything'},\n    });\n  });\n\n  it('extract from invalid docblock', () => {\n    const code = `/* @format: everything${EOL}// keep me */`;\n    expect(docblock.parseWithComments(code)).toEqual({\n      comments: '// keep me',\n      pragmas: {'format:': 'everything'},\n    });\n  });\n\n  it('extract from invalid docblock singleline', () => {\n    const code = '/* some test */';\n    expect(docblock.parseWithComments(code)).toEqual({\n      comments: ' some test',\n      pragmas: {},\n    });\n  });\n\n  it('extracts docblock comments as CRLF when docblock contains CRLF', () => {\n    const code = '/**\\r\\n * foo\\r\\n * bar\\r\\n*/';\n    expect(docblock.parseWithComments(code)).toEqual({\n      comments: 'foo\\r\\nbar',\n      pragmas: {},\n    });\n  });\n\n  it('extracts docblock comments as LF when docblock contains LF', () => {\n    const code = '/**\\n * foo\\n * bar\\n*/';\n    expect(docblock.parseWithComments(code)).toEqual({\n      comments: 'foo\\nbar',\n      pragmas: {},\n    });\n  });\n\n  it('strips the docblock out of a file that contains a top docblock', () => {\n    const code = '/**\\n * foo\\n * bar\\n*/\\nthe rest';\n    expect(docblock.strip(code)).toBe('\\nthe rest');\n  });\n\n  it('returns a file unchanged if there is no top docblock to strip', () => {\n    const code = 'someCodeAtTheTop();\\n/** docblock */';\n    expect(docblock.strip(code)).toEqual(code);\n  });\n\n  it('prints docblocks with no pragmas as empty string', () => {\n    const pragmas = {};\n    expect(docblock.print({pragmas})).toBe('');\n  });\n\n  it('prints docblocks with one pragma on one line', () => {\n    const pragmas = {flow: ''};\n    expect(docblock.print({pragmas})).toBe('/** @flow */');\n  });\n\n  it('prints docblocks with multiple pragmas on multiple lines', () => {\n    const pragmas = {\n      flow: '',\n      format: '',\n    };\n    expect(docblock.print({pragmas})).toBe(\n      `/**${EOL} * @flow${EOL} * @format${EOL} */`,\n    );\n  });\n\n  it('prints docblocks with multiple of the same pragma', () => {\n    const pragmas = {\n      x: ['a', 'b'],\n      y: 'c',\n    };\n    expect(docblock.print({pragmas})).toBe(\n      `/**${EOL} * @x a${EOL} * @x b${EOL} * @y c${EOL} */`,\n    );\n  });\n  it('prints docblocks with pragmas', () => {\n    const pragmas = {\n      flow: 'foo',\n      team: 'x/y/z',\n    };\n    expect(docblock.print({pragmas})).toBe(\n      `/**${EOL} * @flow foo${EOL} * @team x/y/z${EOL} */`,\n    );\n  });\n\n  it('prints docblocks with comments', () => {\n    const pragmas = {flow: 'foo'};\n    const comments = 'hello';\n    expect(docblock.print({comments, pragmas})).toBe(\n      `/**${EOL} * hello${EOL} *${EOL} * @flow foo${EOL} */`,\n    );\n  });\n\n  it('prints docblocks with comments and no keys', () => {\n    const pragmas = {};\n    const comments = 'Copyright (c) Meta Platforms, Inc. and affiliates.';\n    expect(docblock.print({comments, pragmas})).toBe(\n      `/**${EOL} * ${comments}${EOL} */`,\n    );\n  });\n\n  it('prints docblocks with multiline comments', () => {\n    const pragmas = {};\n    const comments = `hello${EOL}world`;\n    expect(docblock.print({comments, pragmas})).toBe(\n      `/**${EOL} * hello${EOL} * world${EOL} */`,\n    );\n  });\n\n  it('prints docblocks that are parseable', () => {\n    const pragmas = {a: 'b', c: ''};\n    const comments = 'hello world!';\n    const formatted = docblock.print({comments, pragmas});\n    const parsed = docblock.parse(formatted);\n    expect(parsed).toEqual(pragmas);\n  });\n\n  it('can augment existing docblocks with comments', () => {\n    const before = `/**${EOL} * Legalese${EOL} * @flow${EOL} */`;\n    const {comments, pragmas} = docblock.parseWithComments(before);\n    pragmas.format = '';\n    const after = docblock.print({comments, pragmas});\n    expect(after).toBe(\n      `/**${EOL} * Legalese${EOL} *${EOL} * @flow${EOL} * @format${EOL} */`,\n    );\n  });\n\n  it('prints docblocks using CRLF if comments contains CRLF', () => {\n    const pragmas = {};\n    const comments = 'hello\\r\\nworld';\n    const formatted = docblock.print({comments, pragmas});\n    expect(formatted).toBe('/**\\r\\n * hello\\r\\n * world\\r\\n */');\n  });\n\n  it('prints docblocks using LF if comments contains LF', () => {\n    const pragmas = {};\n    const comments = 'hello\\nworld';\n    const formatted = docblock.print({comments, pragmas});\n    expect(formatted).toBe('/**\\n * hello\\n * world\\n */');\n  });\n});\n",
  "packages/jest-docblock/src/__tests__/index.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-diff/src/types.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type {CompareKeys} from 'pretty-format';\n\nexport type DiffOptionsColor = (arg: string) => string; // subset of Chalk type\n\nexport type DiffOptions = {\n  aAnnotation?: string;\n  aColor?: DiffOptionsColor;\n  aIndicator?: string;\n  bAnnotation?: string;\n  bColor?: DiffOptionsColor;\n  bIndicator?: string;\n  changeColor?: DiffOptionsColor;\n  changeLineTrailingSpaceColor?: DiffOptionsColor;\n  commonColor?: DiffOptionsColor;\n  commonIndicator?: string;\n  commonLineTrailingSpaceColor?: DiffOptionsColor;\n  contextLines?: number;\n  emptyFirstOrLastLinePlaceholder?: string;\n  expand?: boolean;\n  includeChangeCounts?: boolean;\n  omitAnnotationLines?: boolean;\n  patchColor?: DiffOptionsColor;\n  compareKeys?: CompareKeys;\n};\n\nexport type DiffOptionsNormalized = {\n  aAnnotation: string;\n  aColor: DiffOptionsColor;\n  aIndicator: string;\n  bAnnotation: string;\n  bColor: DiffOptionsColor;\n  bIndicator: string;\n  changeColor: DiffOptionsColor;\n  changeLineTrailingSpaceColor: DiffOptionsColor;\n  commonColor: DiffOptionsColor;\n  commonIndicator: string;\n  commonLineTrailingSpaceColor: DiffOptionsColor;\n  compareKeys: CompareKeys;\n  contextLines: number;\n  emptyFirstOrLastLinePlaceholder: string;\n  expand: boolean;\n  includeChangeCounts: boolean;\n  omitAnnotationLines: boolean;\n  patchColor: DiffOptionsColor;\n};\n",
  "packages/jest-diff/src/types.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { CompareKeys } from 'pretty-format';\nexport type DiffOptionsColor = (arg: string) => string;\nexport type DiffOptions = {\n    aAnnotation?: string;\n    aColor?: DiffOptionsColor;\n    aIndicator?: string;\n    bAnnotation?: string;\n    bColor?: DiffOptionsColor;\n    bIndicator?: string;\n    changeColor?: DiffOptionsColor;\n    changeLineTrailingSpaceColor?: DiffOptionsColor;\n    commonColor?: DiffOptionsColor;\n    commonIndicator?: string;\n    commonLineTrailingSpaceColor?: DiffOptionsColor;\n    contextLines?: number;\n    emptyFirstOrLastLinePlaceholder?: string;\n    expand?: boolean;\n    includeChangeCounts?: boolean;\n    omitAnnotationLines?: boolean;\n    patchColor?: DiffOptionsColor;\n    compareKeys?: CompareKeys;\n};\nexport type DiffOptionsNormalized = {\n    aAnnotation: string;\n    aColor: DiffOptionsColor;\n    aIndicator: string;\n    bAnnotation: string;\n    bColor: DiffOptionsColor;\n    bIndicator: string;\n    changeColor: DiffOptionsColor;\n    changeLineTrailingSpaceColor: DiffOptionsColor;\n    commonColor: DiffOptionsColor;\n    commonIndicator: string;\n    commonLineTrailingSpaceColor: DiffOptionsColor;\n    compareKeys: CompareKeys;\n    contextLines: number;\n    emptyFirstOrLastLinePlaceholder: string;\n    expand: boolean;\n    includeChangeCounts: boolean;\n    omitAnnotationLines: boolean;\n    patchColor: DiffOptionsColor;\n};\n",
  "packages/jest-diff/src/printDiffs.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {DIFF_EQUAL, type Diff, cleanupSemantic} from './cleanupSemantic';\nimport {diffLinesUnified, printDiffLines} from './diffLines';\nimport diffStrings from './diffStrings';\nimport getAlignedDiffs from './getAlignedDiffs';\nimport {normalizeDiffOptions} from './normalizeDiffOptions';\nimport type {DiffOptions} from './types';\n\nconst hasCommonDiff = (diffs: Array<Diff>, isMultiline: boolean): boolean => {\n  if (isMultiline) {\n    // Important: Ignore common newline that was appended to multiline strings!\n    const iLast = diffs.length - 1;\n    return diffs.some(\n      (diff, i) => diff[0] === DIFF_EQUAL && (i !== iLast || diff[1] !== '\\n'),\n    );\n  }\n\n  return diffs.some(diff => diff[0] === DIFF_EQUAL);\n};\n\n// Compare two strings character-by-character.\n// Format as comparison lines in which changed substrings have inverse colors.\nexport const diffStringsUnified = (\n  a: string,\n  b: string,\n  options?: DiffOptions,\n): string => {\n  if (a !== b && a.length > 0 && b.length > 0) {\n    const isMultiline = a.includes('\\n') || b.includes('\\n');\n\n    // getAlignedDiffs assumes that a newline was appended to the strings.\n    const diffs = diffStringsRaw(\n      isMultiline ? `${a}\\n` : a,\n      isMultiline ? `${b}\\n` : b,\n      true, // cleanupSemantic\n    );\n\n    if (hasCommonDiff(diffs, isMultiline)) {\n      const optionsNormalized = normalizeDiffOptions(options);\n      const lines = getAlignedDiffs(diffs, optionsNormalized.changeColor);\n      return printDiffLines(lines, optionsNormalized);\n    }\n  }\n\n  // Fall back to line-by-line diff.\n  return diffLinesUnified(a.split('\\n'), b.split('\\n'), options);\n};\n\n// Compare two strings character-by-character.\n// Optionally clean up small common substrings, also known as chaff.\nexport const diffStringsRaw = (\n  a: string,\n  b: string,\n  cleanup: boolean,\n): Array<Diff> => {\n  const diffs = diffStrings(a, b);\n\n  if (cleanup) {\n    cleanupSemantic(diffs); // impure function\n  }\n\n  return diffs;\n};\n",
  "packages/jest-diff/src/printDiffs.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { type Diff } from './cleanupSemantic';\nimport type { DiffOptions } from './types';\nexport declare const diffStringsUnified: (a: string, b: string, options?: DiffOptions) => string;\nexport declare const diffStringsRaw: (a: string, b: string, cleanup: boolean) => Array<Diff>;\n",
  "packages/jest-diff/src/normalizeDiffOptions.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk from 'chalk';\nimport type {CompareKeys} from 'pretty-format';\nimport type {DiffOptions, DiffOptionsNormalized} from './types';\n\nexport const noColor = (string: string): string => string;\n\nconst DIFF_CONTEXT_DEFAULT = 5;\n\nconst OPTIONS_DEFAULT: DiffOptionsNormalized = {\n  aAnnotation: 'Expected',\n  aColor: chalk.green,\n  aIndicator: '-',\n  bAnnotation: 'Received',\n  bColor: chalk.red,\n  bIndicator: '+',\n  changeColor: chalk.inverse,\n  changeLineTrailingSpaceColor: noColor,\n  commonColor: chalk.dim,\n  commonIndicator: ' ',\n  commonLineTrailingSpaceColor: noColor,\n  compareKeys: undefined,\n  contextLines: DIFF_CONTEXT_DEFAULT,\n  emptyFirstOrLastLinePlaceholder: '',\n  expand: true,\n  includeChangeCounts: false,\n  omitAnnotationLines: false,\n  patchColor: chalk.yellow,\n};\n\nconst getCompareKeys = (compareKeys?: CompareKeys): CompareKeys =>\n  compareKeys && typeof compareKeys === 'function'\n    ? compareKeys\n    : OPTIONS_DEFAULT.compareKeys;\n\nconst getContextLines = (contextLines?: number): number =>\n  typeof contextLines === 'number' &&\n  Number.isSafeInteger(contextLines) &&\n  contextLines >= 0\n    ? contextLines\n    : DIFF_CONTEXT_DEFAULT;\n\n// Pure function returns options with all properties.\nexport const normalizeDiffOptions = (\n  options: DiffOptions = {},\n): DiffOptionsNormalized => ({\n  ...OPTIONS_DEFAULT,\n  ...options,\n  compareKeys: getCompareKeys(options.compareKeys),\n  contextLines: getContextLines(options.contextLines),\n});\n",
  "packages/jest-diff/src/normalizeDiffOptions.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { DiffOptions, DiffOptionsNormalized } from './types';\nexport declare const noColor: (string: string) => string;\nexport declare const normalizeDiffOptions: (options?: DiffOptions) => DiffOptionsNormalized;\n",
  "packages/jest-diff/src/joinAlignedDiffs.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {\n  DIFF_DELETE,\n  DIFF_EQUAL,\n  DIFF_INSERT,\n  type Diff,\n} from './cleanupSemantic';\nimport type {DiffOptionsColor, DiffOptionsNormalized} from './types';\n\nconst formatTrailingSpaces = (\n  line: string,\n  trailingSpaceFormatter: DiffOptionsColor,\n): string => line.replace(/\\s+$/, match => trailingSpaceFormatter(match));\n\nconst printDiffLine = (\n  line: string,\n  isFirstOrLast: boolean,\n  color: DiffOptionsColor,\n  indicator: string,\n  trailingSpaceFormatter: DiffOptionsColor,\n  emptyFirstOrLastLinePlaceholder: string,\n): string =>\n  line.length === 0\n    ? indicator === ' '\n      ? isFirstOrLast && emptyFirstOrLastLinePlaceholder.length > 0\n        ? color(`${indicator} ${emptyFirstOrLastLinePlaceholder}`)\n        : ''\n      : color(indicator)\n    : color(\n        `${indicator} ${formatTrailingSpaces(line, trailingSpaceFormatter)}`,\n      );\n\nconst printDeleteLine = (\n  line: string,\n  isFirstOrLast: boolean,\n  {\n    aColor,\n    aIndicator,\n    changeLineTrailingSpaceColor,\n    emptyFirstOrLastLinePlaceholder,\n  }: DiffOptionsNormalized,\n): string =>\n  printDiffLine(\n    line,\n    isFirstOrLast,\n    aColor,\n    aIndicator,\n    changeLineTrailingSpaceColor,\n    emptyFirstOrLastLinePlaceholder,\n  );\n\nconst printInsertLine = (\n  line: string,\n  isFirstOrLast: boolean,\n  {\n    bColor,\n    bIndicator,\n    changeLineTrailingSpaceColor,\n    emptyFirstOrLastLinePlaceholder,\n  }: DiffOptionsNormalized,\n): string =>\n  printDiffLine(\n    line,\n    isFirstOrLast,\n    bColor,\n    bIndicator,\n    changeLineTrailingSpaceColor,\n    emptyFirstOrLastLinePlaceholder,\n  );\n\nconst printCommonLine = (\n  line: string,\n  isFirstOrLast: boolean,\n  {\n    commonColor,\n    commonIndicator,\n    commonLineTrailingSpaceColor,\n    emptyFirstOrLastLinePlaceholder,\n  }: DiffOptionsNormalized,\n): string =>\n  printDiffLine(\n    line,\n    isFirstOrLast,\n    commonColor,\n    commonIndicator,\n    commonLineTrailingSpaceColor,\n    emptyFirstOrLastLinePlaceholder,\n  );\n\n// In GNU diff format, indexes are one-based instead of zero-based.\nconst createPatchMark = (\n  aStart: number,\n  aEnd: number,\n  bStart: number,\n  bEnd: number,\n  {patchColor}: DiffOptionsNormalized,\n): string =>\n  patchColor(\n    `@@ -${aStart + 1},${aEnd - aStart} +${bStart + 1},${bEnd - bStart} @@`,\n  );\n\n// jest --no-expand\n//\n// Given array of aligned strings with inverse highlight formatting,\n// return joined lines with diff formatting (and patch marks, if needed).\nexport const joinAlignedDiffsNoExpand = (\n  diffs: Array<Diff>,\n  options: DiffOptionsNormalized,\n): string => {\n  const iLength = diffs.length;\n  const nContextLines = options.contextLines;\n  const nContextLines2 = nContextLines + nContextLines;\n\n  // First pass: count output lines and see if it has patches.\n  let jLength = iLength;\n  let hasExcessAtStartOrEnd = false;\n  let nExcessesBetweenChanges = 0;\n  let i = 0;\n  while (i !== iLength) {\n    const iStart = i;\n    while (i !== iLength && diffs[i][0] === DIFF_EQUAL) {\n      i += 1;\n    }\n\n    if (iStart !== i) {\n      if (iStart === 0) {\n        // at start\n        if (i > nContextLines) {\n          jLength -= i - nContextLines; // subtract excess common lines\n          hasExcessAtStartOrEnd = true;\n        }\n      } else if (i === iLength) {\n        // at end\n        const n = i - iStart;\n        if (n > nContextLines) {\n          jLength -= n - nContextLines; // subtract excess common lines\n          hasExcessAtStartOrEnd = true;\n        }\n      } else {\n        // between changes\n        const n = i - iStart;\n        if (n > nContextLines2) {\n          jLength -= n - nContextLines2; // subtract excess common lines\n          nExcessesBetweenChanges += 1;\n        }\n      }\n    }\n\n    while (i !== iLength && diffs[i][0] !== DIFF_EQUAL) {\n      i += 1;\n    }\n  }\n\n  const hasPatch = nExcessesBetweenChanges !== 0 || hasExcessAtStartOrEnd;\n  if (nExcessesBetweenChanges !== 0) {\n    jLength += nExcessesBetweenChanges + 1; // add patch lines\n  } else if (hasExcessAtStartOrEnd) {\n    jLength += 1; // add patch line\n  }\n  const jLast = jLength - 1;\n\n  const lines: Array<string> = [];\n\n  let jPatchMark = 0; // index of placeholder line for current patch mark\n  if (hasPatch) {\n    lines.push(''); // placeholder line for first patch mark\n  }\n\n  // Indexes of expected or received lines in current patch:\n  let aStart = 0;\n  let bStart = 0;\n  let aEnd = 0;\n  let bEnd = 0;\n\n  const pushCommonLine = (line: string): void => {\n    const j = lines.length;\n    lines.push(printCommonLine(line, j === 0 || j === jLast, options));\n    aEnd += 1;\n    bEnd += 1;\n  };\n\n  const pushDeleteLine = (line: string): void => {\n    const j = lines.length;\n    lines.push(printDeleteLine(line, j === 0 || j === jLast, options));\n    aEnd += 1;\n  };\n\n  const pushInsertLine = (line: string): void => {\n    const j = lines.length;\n    lines.push(printInsertLine(line, j === 0 || j === jLast, options));\n    bEnd += 1;\n  };\n\n  // Second pass: push lines with diff formatting (and patch marks, if needed).\n  i = 0;\n  while (i !== iLength) {\n    let iStart = i;\n    while (i !== iLength && diffs[i][0] === DIFF_EQUAL) {\n      i += 1;\n    }\n\n    if (iStart !== i) {\n      if (iStart === 0) {\n        // at beginning\n        if (i > nContextLines) {\n          iStart = i - nContextLines;\n          aStart = iStart;\n          bStart = iStart;\n          aEnd = aStart;\n          bEnd = bStart;\n        }\n\n        for (let iCommon = iStart; iCommon !== i; iCommon += 1) {\n          pushCommonLine(diffs[iCommon][1]);\n        }\n      } else if (i === iLength) {\n        // at end\n        const iEnd = i - iStart > nContextLines ? iStart + nContextLines : i;\n\n        for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1) {\n          pushCommonLine(diffs[iCommon][1]);\n        }\n      } else {\n        // between changes\n        const nCommon = i - iStart;\n\n        if (nCommon > nContextLines2) {\n          const iEnd = iStart + nContextLines;\n\n          for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1) {\n            pushCommonLine(diffs[iCommon][1]);\n          }\n\n          lines[jPatchMark] = createPatchMark(\n            aStart,\n            aEnd,\n            bStart,\n            bEnd,\n            options,\n          );\n          jPatchMark = lines.length;\n          lines.push(''); // placeholder line for next patch mark\n\n          const nOmit = nCommon - nContextLines2;\n          aStart = aEnd + nOmit;\n          bStart = bEnd + nOmit;\n          aEnd = aStart;\n          bEnd = bStart;\n\n          for (let iCommon = i - nContextLines; iCommon !== i; iCommon += 1) {\n            pushCommonLine(diffs[iCommon][1]);\n          }\n        } else {\n          for (let iCommon = iStart; iCommon !== i; iCommon += 1) {\n            pushCommonLine(diffs[iCommon][1]);\n          }\n        }\n      }\n    }\n\n    while (i !== iLength && diffs[i][0] === DIFF_DELETE) {\n      pushDeleteLine(diffs[i][1]);\n      i += 1;\n    }\n\n    while (i !== iLength && diffs[i][0] === DIFF_INSERT) {\n      pushInsertLine(diffs[i][1]);\n      i += 1;\n    }\n  }\n\n  if (hasPatch) {\n    lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options);\n  }\n\n  return lines.join('\\n');\n};\n\n// jest --expand\n//\n// Given array of aligned strings with inverse highlight formatting,\n// return joined lines with diff formatting.\nexport const joinAlignedDiffsExpand = (\n  diffs: Array<Diff>,\n  options: DiffOptionsNormalized,\n): string =>\n  diffs\n    .map((diff: Diff, i: number, diffs: Array<Diff>): string => {\n      const line = diff[1];\n      const isFirstOrLast = i === 0 || i === diffs.length - 1;\n\n      switch (diff[0]) {\n        case DIFF_DELETE:\n          return printDeleteLine(line, isFirstOrLast, options);\n\n        case DIFF_INSERT:\n          return printInsertLine(line, isFirstOrLast, options);\n\n        default:\n          return printCommonLine(line, isFirstOrLast, options);\n      }\n    })\n    .join('\\n');\n",
  "packages/jest-diff/src/joinAlignedDiffs.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { type Diff } from './cleanupSemantic';\nimport type { DiffOptionsNormalized } from './types';\nexport declare const joinAlignedDiffsNoExpand: (diffs: Array<Diff>, options: DiffOptionsNormalized) => string;\nexport declare const joinAlignedDiffsExpand: (diffs: Array<Diff>, options: DiffOptionsNormalized) => string;\n",
  "packages/jest-diff/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk from 'chalk';\nimport {getType} from '@jest/get-type';\nimport {\n  type PrettyFormatOptions,\n  format as prettyFormat,\n  plugins as prettyFormatPlugins,\n} from 'pretty-format';\nimport {DIFF_DELETE, DIFF_EQUAL, DIFF_INSERT, Diff} from './cleanupSemantic';\nimport {NO_DIFF_MESSAGE, SIMILAR_MESSAGE} from './constants';\nimport {diffLinesRaw, diffLinesUnified, diffLinesUnified2} from './diffLines';\nimport {escapeControlCharacters} from './escapeControlCharacters';\nimport {normalizeDiffOptions} from './normalizeDiffOptions';\nimport {diffStringsRaw, diffStringsUnified} from './printDiffs';\nimport type {DiffOptions} from './types';\n\nexport type {DiffOptions, DiffOptionsColor} from './types';\n\nexport {diffLinesRaw, diffLinesUnified, diffLinesUnified2};\nexport {diffStringsRaw, diffStringsUnified};\nexport {DIFF_DELETE, DIFF_EQUAL, DIFF_INSERT, Diff};\n\nconst getCommonMessage = (message: string, options?: DiffOptions) => {\n  const {commonColor} = normalizeDiffOptions(options);\n  return commonColor(message);\n};\n\nconst {\n  AsymmetricMatcher,\n  DOMCollection,\n  DOMElement,\n  Immutable,\n  ReactElement,\n  ReactTestComponent,\n} = prettyFormatPlugins;\n\nconst PLUGINS = [\n  ReactTestComponent,\n  ReactElement,\n  DOMElement,\n  DOMCollection,\n  Immutable,\n  AsymmetricMatcher,\n];\nconst FORMAT_OPTIONS = {\n  plugins: PLUGINS,\n};\nconst FALLBACK_FORMAT_OPTIONS = {\n  callToJSON: false,\n  maxDepth: 10,\n  plugins: PLUGINS,\n};\n\n// Generate a string that will highlight the difference between two values\n// with green and red. (similar to how github does code diffing)\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function diff(a: any, b: any, options?: DiffOptions): string | null {\n  if (Object.is(a, b)) {\n    return getCommonMessage(NO_DIFF_MESSAGE, options);\n  }\n\n  const aType = getType(a);\n  let expectedType = aType;\n  let omitDifference = false;\n  if (aType === 'object' && typeof a.asymmetricMatch === 'function') {\n    if (a.$$typeof !== Symbol.for('jest.asymmetricMatcher')) {\n      // Do not know expected type of user-defined asymmetric matcher.\n      return null;\n    }\n    if (typeof a.getExpectedType !== 'function') {\n      // For example, expect.anything() matches either null or undefined\n      return null;\n    }\n    expectedType = a.getExpectedType();\n    // Primitive types boolean and number omit difference below.\n    // For example, omit difference for expect.stringMatching(regexp)\n    omitDifference = expectedType === 'string';\n  }\n\n  if (expectedType !== getType(b)) {\n    return (\n      '  Comparing two different types of values.' +\n      ` Expected ${chalk.green(expectedType)} but ` +\n      `received ${chalk.red(getType(b))}.`\n    );\n  }\n\n  if (omitDifference) {\n    return null;\n  }\n\n  switch (aType) {\n    case 'string':\n      return diffLinesUnified(\n        escapeControlCharacters(a).split('\\n'),\n        escapeControlCharacters(b).split('\\n'),\n        options,\n      );\n    case 'boolean':\n    case 'number':\n      return comparePrimitive(a, b, options);\n    case 'map':\n      return compareObjects(sortMap(a), sortMap(b), options);\n    case 'set':\n      return compareObjects(sortSet(a), sortSet(b), options);\n    default:\n      return compareObjects(a, b, options);\n  }\n}\n\nfunction comparePrimitive(\n  a: number | boolean,\n  b: number | boolean,\n  options?: DiffOptions,\n) {\n  const aFormat = prettyFormat(a, FORMAT_OPTIONS);\n  const bFormat = prettyFormat(b, FORMAT_OPTIONS);\n  return aFormat === bFormat\n    ? getCommonMessage(NO_DIFF_MESSAGE, options)\n    : diffLinesUnified(aFormat.split('\\n'), bFormat.split('\\n'), options);\n}\n\nfunction sortMap(map: Map<unknown, unknown>) {\n  return new Map([...map].sort());\n}\n\nfunction sortSet(set: Set<unknown>) {\n  return new Set([...set].sort());\n}\n\nfunction compareObjects(\n  a: Record<string, any>,\n  b: Record<string, any>,\n  options?: DiffOptions,\n) {\n  let difference;\n  let hasThrown = false;\n\n  try {\n    const formatOptions = getFormatOptions(FORMAT_OPTIONS, options);\n    difference = getObjectsDifference(a, b, formatOptions, options);\n  } catch {\n    hasThrown = true;\n  }\n\n  const noDiffMessage = getCommonMessage(NO_DIFF_MESSAGE, options);\n  // If the comparison yields no results, compare again but this time\n  // without calling `toJSON`. It's also possible that toJSON might throw.\n  if (difference === undefined || difference === noDiffMessage) {\n    const formatOptions = getFormatOptions(FALLBACK_FORMAT_OPTIONS, options);\n    difference = getObjectsDifference(a, b, formatOptions, options);\n\n    if (difference !== noDiffMessage && !hasThrown) {\n      difference = `${getCommonMessage(\n        SIMILAR_MESSAGE,\n        options,\n      )}\\n\\n${difference}`;\n    }\n  }\n\n  return difference;\n}\n\nfunction getFormatOptions(\n  formatOptions: PrettyFormatOptions,\n  options?: DiffOptions,\n): PrettyFormatOptions {\n  const {compareKeys} = normalizeDiffOptions(options);\n\n  return {\n    ...formatOptions,\n    compareKeys,\n  };\n}\n\nfunction getObjectsDifference(\n  a: Record<string, any>,\n  b: Record<string, any>,\n  formatOptions: PrettyFormatOptions,\n  options?: DiffOptions,\n): string {\n  const formatOptionsZeroIndent = {...formatOptions, indent: 0};\n  const aCompare = prettyFormat(a, formatOptionsZeroIndent);\n  const bCompare = prettyFormat(b, formatOptionsZeroIndent);\n\n  if (aCompare === bCompare) {\n    return getCommonMessage(NO_DIFF_MESSAGE, options);\n  } else {\n    const aDisplay = prettyFormat(a, formatOptions);\n    const bDisplay = prettyFormat(b, formatOptions);\n\n    return diffLinesUnified2(\n      aDisplay.split('\\n'),\n      bDisplay.split('\\n'),\n      aCompare.split('\\n'),\n      bCompare.split('\\n'),\n      options,\n    );\n  }\n}\n",
  "packages/jest-diff/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { DIFF_DELETE, DIFF_EQUAL, DIFF_INSERT, Diff } from './cleanupSemantic';\nimport { diffLinesRaw, diffLinesUnified, diffLinesUnified2 } from './diffLines';\nimport { diffStringsRaw, diffStringsUnified } from './printDiffs';\nimport type { DiffOptions } from './types';\nexport type { DiffOptions, DiffOptionsColor } from './types';\nexport { diffLinesRaw, diffLinesUnified, diffLinesUnified2 };\nexport { diffStringsRaw, diffStringsUnified };\nexport { DIFF_DELETE, DIFF_EQUAL, DIFF_INSERT, Diff };\nexport declare function diff(a: any, b: any, options?: DiffOptions): string | null;\n",
  "packages/jest-diff/src/getAlignedDiffs.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {DIFF_DELETE, DIFF_EQUAL, DIFF_INSERT, Diff} from './cleanupSemantic';\nimport type {DiffOptionsColor} from './types';\n\n// Given change op and array of diffs, return concatenated string:\n// * include common strings\n// * include change strings which have argument op with changeColor\n// * exclude change strings which have opposite op\nconst concatenateRelevantDiffs = (\n  op: number,\n  diffs: Array<Diff>,\n  changeColor: DiffOptionsColor,\n): string =>\n  diffs.reduce(\n    (reduced: string, diff: Diff): string =>\n      reduced +\n      (diff[0] === DIFF_EQUAL\n        ? diff[1]\n        : diff[0] === op && diff[1].length > 0 // empty if change is newline\n          ? changeColor(diff[1])\n          : ''),\n    '',\n  );\n\n// Encapsulate change lines until either a common newline or the end.\nclass ChangeBuffer {\n  private readonly op: number;\n  private readonly line: Array<Diff>; // incomplete line\n  private readonly lines: Array<Diff>; // complete lines\n  private readonly changeColor: DiffOptionsColor;\n\n  constructor(op: number, changeColor: DiffOptionsColor) {\n    this.op = op;\n    this.line = [];\n    this.lines = [];\n    this.changeColor = changeColor;\n  }\n\n  private pushSubstring(substring: string): void {\n    this.pushDiff(new Diff(this.op, substring));\n  }\n\n  private pushLine(): void {\n    // Assume call only if line has at least one diff,\n    // therefore an empty line must have a diff which has an empty string.\n\n    // If line has multiple diffs, then assume it has a common diff,\n    // therefore change diffs have change color;\n    // otherwise then it has line color only.\n    this.lines.push(\n      this.line.length === 1\n        ? this.line[0][0] === this.op\n          ? this.line[0] // can use instance\n          : new Diff(this.op, this.line[0][1])\n        : new Diff(\n            this.op,\n            concatenateRelevantDiffs(this.op, this.line, this.changeColor),\n          ), // was common diff\n    );\n    this.line.length = 0;\n  }\n\n  isLineEmpty() {\n    return this.line.length === 0;\n  }\n\n  // Minor input to buffer.\n  pushDiff(diff: Diff): void {\n    this.line.push(diff);\n  }\n\n  // Main input to buffer.\n  align(diff: Diff): void {\n    const string = diff[1];\n\n    if (string.includes('\\n')) {\n      const substrings = string.split('\\n');\n      const iLast = substrings.length - 1;\n      for (const [i, substring] of substrings.entries()) {\n        if (i < iLast) {\n          // The first substring completes the current change line.\n          // A middle substring is a change line.\n          this.pushSubstring(substring);\n          this.pushLine();\n        } else if (substring.length > 0) {\n          // The last substring starts a change line, if it is not empty.\n          // Important: This non-empty condition also automatically omits\n          // the newline appended to the end of expected and received strings.\n          this.pushSubstring(substring);\n        }\n      }\n    } else {\n      // Append non-multiline string to current change line.\n      this.pushDiff(diff);\n    }\n  }\n\n  // Output from buffer.\n  moveLinesTo(lines: Array<Diff>): void {\n    if (!this.isLineEmpty()) {\n      this.pushLine();\n    }\n\n    lines.push(...this.lines);\n    this.lines.length = 0;\n  }\n}\n\n// Encapsulate common and change lines.\nclass CommonBuffer {\n  private readonly deleteBuffer: ChangeBuffer;\n  private readonly insertBuffer: ChangeBuffer;\n  private readonly lines: Array<Diff>;\n\n  constructor(deleteBuffer: ChangeBuffer, insertBuffer: ChangeBuffer) {\n    this.deleteBuffer = deleteBuffer;\n    this.insertBuffer = insertBuffer;\n    this.lines = [];\n  }\n\n  private pushDiffCommonLine(diff: Diff): void {\n    this.lines.push(diff);\n  }\n\n  private pushDiffChangeLines(diff: Diff): void {\n    const isDiffEmpty = diff[1].length === 0;\n\n    // An empty diff string is redundant, unless a change line is empty.\n    if (!isDiffEmpty || this.deleteBuffer.isLineEmpty()) {\n      this.deleteBuffer.pushDiff(diff);\n    }\n    if (!isDiffEmpty || this.insertBuffer.isLineEmpty()) {\n      this.insertBuffer.pushDiff(diff);\n    }\n  }\n\n  private flushChangeLines(): void {\n    this.deleteBuffer.moveLinesTo(this.lines);\n    this.insertBuffer.moveLinesTo(this.lines);\n  }\n\n  // Input to buffer.\n  align(diff: Diff): void {\n    const op = diff[0];\n    const string = diff[1];\n\n    if (string.includes('\\n')) {\n      const substrings = string.split('\\n');\n      const iLast = substrings.length - 1;\n      for (const [i, substring] of substrings.entries()) {\n        if (i === 0) {\n          const subdiff = new Diff(op, substring);\n          if (\n            this.deleteBuffer.isLineEmpty() &&\n            this.insertBuffer.isLineEmpty()\n          ) {\n            // If both current change lines are empty,\n            // then the first substring is a common line.\n            this.flushChangeLines();\n            this.pushDiffCommonLine(subdiff);\n          } else {\n            // If either current change line is non-empty,\n            // then the first substring completes the change lines.\n            this.pushDiffChangeLines(subdiff);\n            this.flushChangeLines();\n          }\n        } else if (i < iLast) {\n          // A middle substring is a common line.\n          this.pushDiffCommonLine(new Diff(op, substring));\n        } else if (substring.length > 0) {\n          // The last substring starts a change line, if it is not empty.\n          // Important: This non-empty condition also automatically omits\n          // the newline appended to the end of expected and received strings.\n          this.pushDiffChangeLines(new Diff(op, substring));\n        }\n      }\n    } else {\n      // Append non-multiline string to current change lines.\n      // Important: It cannot be at the end following empty change lines,\n      // because newline appended to the end of expected and received strings.\n      this.pushDiffChangeLines(diff);\n    }\n  }\n\n  // Output from buffer.\n  getLines(): Array<Diff> {\n    this.flushChangeLines();\n    return this.lines;\n  }\n}\n\n// Given diffs from expected and received strings,\n// return new array of diffs split or joined into lines.\n//\n// To correctly align a change line at the end, the algorithm:\n// * assumes that a newline was appended to the strings\n// * omits the last newline from the output array\n//\n// Assume the function is not called:\n// * if either expected or received is empty string\n// * if neither expected nor received is multiline string\nconst getAlignedDiffs = (\n  diffs: Array<Diff>,\n  changeColor: DiffOptionsColor,\n): Array<Diff> => {\n  const deleteBuffer = new ChangeBuffer(DIFF_DELETE, changeColor);\n  const insertBuffer = new ChangeBuffer(DIFF_INSERT, changeColor);\n  const commonBuffer = new CommonBuffer(deleteBuffer, insertBuffer);\n\n  for (const diff of diffs) {\n    switch (diff[0]) {\n      case DIFF_DELETE:\n        deleteBuffer.align(diff);\n        break;\n\n      case DIFF_INSERT:\n        insertBuffer.align(diff);\n        break;\n\n      default:\n        commonBuffer.align(diff);\n    }\n  }\n\n  return commonBuffer.getLines();\n};\n\nexport default getAlignedDiffs;\n",
  "packages/jest-diff/src/getAlignedDiffs.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { Diff } from './cleanupSemantic';\nimport type { DiffOptionsColor } from './types';\ndeclare const getAlignedDiffs: (diffs: Array<Diff>, changeColor: DiffOptionsColor) => Array<Diff>;\nexport default getAlignedDiffs;\n",
  "packages/jest-diff/src/escapeControlCharacters.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// Escape control characters to make them visible in diffs\nexport const escapeControlCharacters = (str: string): string =>\n  str.replaceAll(\n    /[\\u0000-\\u0008\\u000B\\u000C\\u000E-\\u001F\\u007F-\\u009F]/g,\n    (match: string) => {\n      switch (match) {\n        case '\\b':\n          return '\\\\b';\n        case '\\f':\n          return '\\\\f';\n        case '\\v':\n          return '\\\\v';\n        default: {\n          const code = match.codePointAt(0);\n          return `\\\\x${code!.toString(16).padStart(2, '0')}`;\n        }\n      }\n    },\n  );\n",
  "packages/jest-diff/src/escapeControlCharacters.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport declare const escapeControlCharacters: (str: string) => string;\n",
  "packages/jest-diff/src/diffStrings.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport diffSequences from '@jest/diff-sequences';\nimport {DIFF_DELETE, DIFF_EQUAL, DIFF_INSERT, Diff} from './cleanupSemantic';\n\nconst diffStrings = (a: string, b: string): Array<Diff> => {\n  const isCommon = (aIndex: number, bIndex: number) => a[aIndex] === b[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const diffs: Array<Diff> = [];\n\n  const foundSubsequence = (\n    nCommon: number,\n    aCommon: number,\n    bCommon: number,\n  ) => {\n    if (aIndex !== aCommon) {\n      diffs.push(new Diff(DIFF_DELETE, a.slice(aIndex, aCommon)));\n    }\n    if (bIndex !== bCommon) {\n      diffs.push(new Diff(DIFF_INSERT, b.slice(bIndex, bCommon)));\n    }\n\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    diffs.push(new Diff(DIFF_EQUAL, b.slice(bCommon, bIndex)));\n  };\n\n  diffSequences(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    diffs.push(new Diff(DIFF_DELETE, a.slice(aIndex)));\n  }\n  if (bIndex !== b.length) {\n    diffs.push(new Diff(DIFF_INSERT, b.slice(bIndex)));\n  }\n\n  return diffs;\n};\n\nexport default diffStrings;\n",
  "packages/jest-diff/src/diffStrings.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { Diff } from './cleanupSemantic';\ndeclare const diffStrings: (a: string, b: string) => Array<Diff>;\nexport default diffStrings;\n",
  "packages/jest-diff/src/diffLines.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport diff from '@jest/diff-sequences';\nimport {DIFF_DELETE, DIFF_EQUAL, DIFF_INSERT, Diff} from './cleanupSemantic';\nimport {escapeControlCharacters} from './escapeControlCharacters';\nimport {\n  joinAlignedDiffsExpand,\n  joinAlignedDiffsNoExpand,\n} from './joinAlignedDiffs';\nimport {normalizeDiffOptions} from './normalizeDiffOptions';\nimport type {DiffOptions, DiffOptionsNormalized} from './types';\n\nconst isEmptyString = (lines: Array<string>) =>\n  lines.length === 1 && lines[0].length === 0;\n\ntype ChangeCounts = {\n  a: number;\n  b: number;\n};\n\nconst countChanges = (diffs: Array<Diff>): ChangeCounts => {\n  let a = 0;\n  let b = 0;\n\n  for (const diff of diffs) {\n    switch (diff[0]) {\n      case DIFF_DELETE:\n        a += 1;\n        break;\n\n      case DIFF_INSERT:\n        b += 1;\n        break;\n    }\n  }\n\n  return {a, b};\n};\n\nconst printAnnotation = (\n  {\n    aAnnotation,\n    aColor,\n    aIndicator,\n    bAnnotation,\n    bColor,\n    bIndicator,\n    includeChangeCounts,\n    omitAnnotationLines,\n  }: DiffOptionsNormalized,\n  changeCounts: ChangeCounts,\n): string => {\n  if (omitAnnotationLines) {\n    return '';\n  }\n\n  let aRest = '';\n  let bRest = '';\n\n  if (includeChangeCounts) {\n    const aCount = String(changeCounts.a);\n    const bCount = String(changeCounts.b);\n\n    // Padding right aligns the ends of the annotations.\n    const baAnnotationLengthDiff = bAnnotation.length - aAnnotation.length;\n    const aAnnotationPadding = ' '.repeat(Math.max(0, baAnnotationLengthDiff));\n    const bAnnotationPadding = ' '.repeat(Math.max(0, -baAnnotationLengthDiff));\n\n    // Padding left aligns the ends of the counts.\n    const baCountLengthDiff = bCount.length - aCount.length;\n    const aCountPadding = ' '.repeat(Math.max(0, baCountLengthDiff));\n    const bCountPadding = ' '.repeat(Math.max(0, -baCountLengthDiff));\n\n    aRest = `${aAnnotationPadding}  ${aIndicator} ${aCountPadding}${aCount}`;\n    bRest = `${bAnnotationPadding}  ${bIndicator} ${bCountPadding}${bCount}`;\n  }\n\n  const a = `${aIndicator} ${aAnnotation}${aRest}`;\n  const b = `${bIndicator} ${bAnnotation}${bRest}`;\n  return `${aColor(a)}\\n${bColor(b)}\\n\\n`;\n};\n\nexport const printDiffLines = (\n  diffs: Array<Diff>,\n  options: DiffOptionsNormalized,\n): string =>\n  printAnnotation(options, countChanges(diffs)) +\n  (options.expand\n    ? joinAlignedDiffsExpand(diffs, options)\n    : joinAlignedDiffsNoExpand(diffs, options));\n\n// Compare two arrays of strings line-by-line. Format as comparison lines.\nexport const diffLinesUnified = (\n  aLines: Array<string>,\n  bLines: Array<string>,\n  options?: DiffOptions,\n): string =>\n  printDiffLines(\n    diffLinesRaw(\n      isEmptyString(aLines) ? [] : aLines.map(escapeControlCharacters),\n      isEmptyString(bLines) ? [] : bLines.map(escapeControlCharacters),\n    ),\n    normalizeDiffOptions(options),\n  );\n\n// Given two pairs of arrays of strings:\n// Compare the pair of comparison arrays line-by-line.\n// Format the corresponding lines in the pair of displayable arrays.\nexport const diffLinesUnified2 = (\n  aLinesDisplay: Array<string>,\n  bLinesDisplay: Array<string>,\n  aLinesCompare: Array<string>,\n  bLinesCompare: Array<string>,\n  options?: DiffOptions,\n): string => {\n  if (isEmptyString(aLinesDisplay) && isEmptyString(aLinesCompare)) {\n    aLinesDisplay = [];\n    aLinesCompare = [];\n  }\n  if (isEmptyString(bLinesDisplay) && isEmptyString(bLinesCompare)) {\n    bLinesDisplay = [];\n    bLinesCompare = [];\n  }\n\n  if (\n    aLinesDisplay.length !== aLinesCompare.length ||\n    bLinesDisplay.length !== bLinesCompare.length\n  ) {\n    // Fall back to diff of display lines.\n    return diffLinesUnified(aLinesDisplay, bLinesDisplay, options);\n  }\n\n  const diffs = diffLinesRaw(aLinesCompare, bLinesCompare);\n\n  // Replace comparison lines with displayable lines.\n  let aIndex = 0;\n  let bIndex = 0;\n  for (const diff of diffs) {\n    switch (diff[0]) {\n      case DIFF_DELETE:\n        diff[1] = aLinesDisplay[aIndex];\n        aIndex += 1;\n        break;\n\n      case DIFF_INSERT:\n        diff[1] = bLinesDisplay[bIndex];\n        bIndex += 1;\n        break;\n\n      default:\n        diff[1] = bLinesDisplay[bIndex];\n        aIndex += 1;\n        bIndex += 1;\n    }\n  }\n\n  return printDiffLines(diffs, normalizeDiffOptions(options));\n};\n\n// Compare two arrays of strings line-by-line.\nexport const diffLinesRaw = (\n  aLines: Array<string>,\n  bLines: Array<string>,\n): Array<Diff> => {\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex: number, bIndex: number) =>\n    aLines[aIndex] === bLines[bIndex];\n\n  const diffs: Array<Diff> = [];\n  let aIndex = 0;\n  let bIndex = 0;\n\n  const foundSubsequence = (\n    nCommon: number,\n    aCommon: number,\n    bCommon: number,\n  ) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      diffs.push(new Diff(DIFF_DELETE, aLines[aIndex]));\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      diffs.push(new Diff(DIFF_INSERT, bLines[bIndex]));\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      diffs.push(new Diff(DIFF_EQUAL, bLines[bIndex]));\n    }\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  for (; aIndex !== aLength; aIndex += 1) {\n    diffs.push(new Diff(DIFF_DELETE, aLines[aIndex]));\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    diffs.push(new Diff(DIFF_INSERT, bLines[bIndex]));\n  }\n\n  return diffs;\n};\n",
  "packages/jest-diff/src/diffLines.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { Diff } from './cleanupSemantic';\nimport type { DiffOptions, DiffOptionsNormalized } from './types';\nexport declare const printDiffLines: (diffs: Array<Diff>, options: DiffOptionsNormalized) => string;\nexport declare const diffLinesUnified: (aLines: Array<string>, bLines: Array<string>, options?: DiffOptions) => string;\nexport declare const diffLinesUnified2: (aLinesDisplay: Array<string>, bLinesDisplay: Array<string>, aLinesCompare: Array<string>, bLinesCompare: Array<string>, options?: DiffOptions) => string;\nexport declare const diffLinesRaw: (aLines: Array<string>, bLines: Array<string>) => Array<Diff>;\n",
  "packages/jest-diff/src/constants.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nexport const NO_DIFF_MESSAGE = 'Compared values have no visual difference.';\n\nexport const SIMILAR_MESSAGE =\n  'Compared values serialize to the same structure.\\n' +\n  'Printing internal object structure without calling `toJSON` instead.';\n",
  "packages/jest-diff/src/constants.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport declare const NO_DIFF_MESSAGE = \"Compared values have no visual difference.\";\nexport declare const SIMILAR_MESSAGE: string;\n",
  "packages/jest-diff/src/cleanupSemantic.ts": "/**\n * Diff Match and Patch\n * Copyright 2018 The diff-match-patch Authors.\n * https://github.com/google/diff-match-patch\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Computes the difference between two texts to create a patch.\n * Applies the patch onto another text, allowing for errors.\n * @author fraser@google.com (Neil Fraser)\n */\n\n/**\n * CHANGES by pedrottimark to diff_match_patch_uncompressed.ts file:\n *\n * 1. Delete anything not needed to use diff_cleanupSemantic method\n * 2. Convert from prototype properties to var declarations\n * 3. Convert Diff to class from constructor and prototype\n * 4. Add type annotations for arguments and return values\n * 5. Add exports\n */\n\n/**\n * The data structure representing a diff is an array of tuples:\n * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n */\nvar DIFF_DELETE = -1;\nvar DIFF_INSERT = 1;\nvar DIFF_EQUAL = 0;\n\n/**\n * Class representing one diff tuple.\n * Attempts to look like a two-element array (which is what this used to be).\n * @param {number} op Operation, one of: DIFF_DELETE, DIFF_INSERT, DIFF_EQUAL.\n * @param {string} text Text to be deleted, inserted, or retained.\n * @constructor\n */\nclass Diff {\n  0: number;\n  1: string;\n\n  constructor(op: number, text: string) {\n    this[0] = op;\n    this[1] = text;\n  }\n}\n\n\n/**\n * Determine the common prefix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the start of each\n *     string.\n */\nvar diff_commonPrefix = function(text1: string, text2: string): number {\n  // Quick check for common null cases.\n  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: https://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerstart = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(pointerstart, pointermid) ==\n        text2.substring(pointerstart, pointermid)) {\n      pointermin = pointermid;\n      pointerstart = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n};\n\n\n/**\n * Determine the common suffix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of each string.\n */\nvar diff_commonSuffix = function(text1: string, text2: string): number {\n  // Quick check for common null cases.\n  if (!text1 || !text2 ||\n      text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: https://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerend = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==\n        text2.substring(text2.length - pointermid, text2.length - pointerend)) {\n      pointermin = pointermid;\n      pointerend = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n};\n\n\n/**\n * Determine if the suffix of one string is the prefix of another.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of the first\n *     string and the start of the second string.\n * @private\n */\nvar diff_commonOverlap_ = function(text1: string, text2: string): number {\n  // Cache the text lengths to prevent multiple calls.\n  var text1_length = text1.length;\n  var text2_length = text2.length;\n  // Eliminate the null case.\n  if (text1_length == 0 || text2_length == 0) {\n    return 0;\n  }\n  // Truncate the longer string.\n  if (text1_length > text2_length) {\n    text1 = text1.substring(text1_length - text2_length);\n  } else if (text1_length < text2_length) {\n    text2 = text2.substring(0, text1_length);\n  }\n  var text_length = Math.min(text1_length, text2_length);\n  // Quick check for the worst case.\n  if (text1 == text2) {\n    return text_length;\n  }\n\n  // Start by looking for a single character match\n  // and increase length until no match is found.\n  // Performance analysis: https://neil.fraser.name/news/2010/11/04/\n  var best = 0;\n  var length = 1;\n  while (true) {\n    var pattern = text1.substring(text_length - length);\n    var found = text2.indexOf(pattern);\n    if (found == -1) {\n      return best;\n    }\n    length += found;\n    if (found == 0 || text1.substring(text_length - length) ==\n        text2.substring(0, length)) {\n      best = length;\n      length++;\n    }\n  }\n};\n\n\n/**\n * Reduce the number of edits by eliminating semantically trivial equalities.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\n var diff_cleanupSemantic = function(diffs: Array<Diff>) {\n  var changes = false;\n  var equalities = [];  // Stack of indices where equalities are found.\n  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\n  /** @type {?string} */\n  var lastEquality = null;\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n  var pointer = 0;  // Index of current position.\n  // Number of characters that changed prior to the equality.\n  var length_insertions1 = 0;\n  var length_deletions1 = 0;\n  // Number of characters that changed after the equality.\n  var length_insertions2 = 0;\n  var length_deletions2 = 0;\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\n      equalities[equalitiesLength++] = pointer;\n      length_insertions1 = length_insertions2;\n      length_deletions1 = length_deletions2;\n      length_insertions2 = 0;\n      length_deletions2 = 0;\n      lastEquality = diffs[pointer][1];\n    } else {  // An insertion or deletion.\n      if (diffs[pointer][0] == DIFF_INSERT) {\n        length_insertions2 += diffs[pointer][1].length;\n      } else {\n        length_deletions2 += diffs[pointer][1].length;\n      }\n      // Eliminate an equality that is smaller or equal to the edits on both\n      // sides of it.\n      if (lastEquality && (lastEquality.length <=\n          Math.max(length_insertions1, length_deletions1)) &&\n          (lastEquality.length <= Math.max(length_insertions2,\n                                           length_deletions2))) {\n        // Duplicate record.\n        diffs.splice(equalities[equalitiesLength - 1], 0,\n                     new Diff(DIFF_DELETE, lastEquality));\n        // Change second copy to insert.\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n        // Throw away the equality we just deleted.\n        equalitiesLength--;\n        // Throw away the previous equality (it needs to be reevaluated).\n        equalitiesLength--;\n        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n        length_insertions1 = 0;  // Reset the counters.\n        length_deletions1 = 0;\n        length_insertions2 = 0;\n        length_deletions2 = 0;\n        lastEquality = null;\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n\n  // Normalize the diff.\n  if (changes) {\n    diff_cleanupMerge(diffs);\n  }\n  diff_cleanupSemanticLossless(diffs);\n\n  // Find any overlaps between deletions and insertions.\n  // e.g: <del>abcxxx</del><ins>xxxdef</ins>\n  //   -> <del>abc</del>xxx<ins>def</ins>\n  // e.g: <del>xxxabc</del><ins>defxxx</ins>\n  //   -> <ins>def</ins>xxx<del>abc</del>\n  // Only extract an overlap if it is as big as the edit ahead or behind it.\n  pointer = 1;\n  while (pointer < diffs.length) {\n    if (diffs[pointer - 1][0] == DIFF_DELETE &&\n        diffs[pointer][0] == DIFF_INSERT) {\n      var deletion = diffs[pointer - 1][1];\n      var insertion = diffs[pointer][1];\n      var overlap_length1 = diff_commonOverlap_(deletion, insertion);\n      var overlap_length2 = diff_commonOverlap_(insertion, deletion);\n      if (overlap_length1 >= overlap_length2) {\n        if (overlap_length1 >= deletion.length / 2 ||\n            overlap_length1 >= insertion.length / 2) {\n          // Overlap found.  Insert an equality and trim the surrounding edits.\n          diffs.splice(pointer, 0, new Diff(DIFF_EQUAL,\n              insertion.substring(0, overlap_length1)));\n          diffs[pointer - 1][1] =\n              deletion.substring(0, deletion.length - overlap_length1);\n          diffs[pointer + 1][1] = insertion.substring(overlap_length1);\n          pointer++;\n        }\n      } else {\n        if (overlap_length2 >= deletion.length / 2 ||\n            overlap_length2 >= insertion.length / 2) {\n          // Reverse overlap found.\n          // Insert an equality and swap and trim the surrounding edits.\n          diffs.splice(pointer, 0, new Diff(DIFF_EQUAL,\n              deletion.substring(0, overlap_length2)));\n          diffs[pointer - 1][0] = DIFF_INSERT;\n          diffs[pointer - 1][1] =\n              insertion.substring(0, insertion.length - overlap_length2);\n          diffs[pointer + 1][0] = DIFF_DELETE;\n          diffs[pointer + 1][1] =\n              deletion.substring(overlap_length2);\n          pointer++;\n        }\n      }\n      pointer++;\n    }\n    pointer++;\n  }\n};\n\n\n/**\n * Look for single edits surrounded on both sides by equalities\n * which can be shifted sideways to align the edit to a word boundary.\n * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\nvar diff_cleanupSemanticLossless = function(diffs: Array<Diff>) {\n  /**\n   * Given two strings, compute a score representing whether the internal\n   * boundary falls on logical boundaries.\n   * Scores range from 6 (best) to 0 (worst).\n   * Closure, but does not reference any external variables.\n   * @param {string} one First string.\n   * @param {string} two Second string.\n   * @return {number} The score.\n   * @private\n   */\n  function diff_cleanupSemanticScore_(one: string, two: string): number {\n    if (!one || !two) {\n      // Edges are the best.\n      return 6;\n    }\n\n    // Each port of this function behaves slightly differently due to\n    // subtle differences in each language's definition of things like\n    // 'whitespace'.  Since this function's purpose is largely cosmetic,\n    // the choice has been made to use each language's native features\n    // rather than force total conformity.\n    var char1 = one.charAt(one.length - 1);\n    var char2 = two.charAt(0);\n    var nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_);\n    var nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_);\n    var whitespace1 = nonAlphaNumeric1 &&\n        char1.match(whitespaceRegex_);\n    var whitespace2 = nonAlphaNumeric2 &&\n        char2.match(whitespaceRegex_);\n    var lineBreak1 = whitespace1 &&\n        char1.match(linebreakRegex_);\n    var lineBreak2 = whitespace2 &&\n        char2.match(linebreakRegex_);\n    var blankLine1 = lineBreak1 &&\n        one.match(blanklineEndRegex_);\n    var blankLine2 = lineBreak2 &&\n        two.match(blanklineStartRegex_);\n\n    if (blankLine1 || blankLine2) {\n      // Five points for blank lines.\n      return 5;\n    } else if (lineBreak1 || lineBreak2) {\n      // Four points for line breaks.\n      return 4;\n    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {\n      // Three points for end of sentences.\n      return 3;\n    } else if (whitespace1 || whitespace2) {\n      // Two points for whitespace.\n      return 2;\n    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {\n      // One point for non-alphanumeric.\n      return 1;\n    }\n    return 0;\n  }\n\n  var pointer = 1;\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\n        diffs[pointer + 1][0] == DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      var equality1 = diffs[pointer - 1][1];\n      var edit = diffs[pointer][1];\n      var equality2 = diffs[pointer + 1][1];\n\n      // First, shift the edit as far left as possible.\n      var commonOffset = diff_commonSuffix(equality1, edit);\n      if (commonOffset) {\n        var commonString = edit.substring(edit.length - commonOffset);\n        equality1 = equality1.substring(0, equality1.length - commonOffset);\n        edit = commonString + edit.substring(0, edit.length - commonOffset);\n        equality2 = commonString + equality2;\n      }\n\n      // Second, step character by character right, looking for the best fit.\n      var bestEquality1 = equality1;\n      var bestEdit = edit;\n      var bestEquality2 = equality2;\n      var bestScore = diff_cleanupSemanticScore_(equality1, edit) +\n          diff_cleanupSemanticScore_(edit, equality2);\n      while (edit.charAt(0) === equality2.charAt(0)) {\n        equality1 += edit.charAt(0);\n        edit = edit.substring(1) + equality2.charAt(0);\n        equality2 = equality2.substring(1);\n        var score = diff_cleanupSemanticScore_(equality1, edit) +\n            diff_cleanupSemanticScore_(edit, equality2);\n        // The >= encourages trailing rather than leading whitespace on edits.\n        if (score >= bestScore) {\n          bestScore = score;\n          bestEquality1 = equality1;\n          bestEdit = edit;\n          bestEquality2 = equality2;\n        }\n      }\n\n      if (diffs[pointer - 1][1] != bestEquality1) {\n        // We have an improvement, save it back to the diff.\n        if (bestEquality1) {\n          diffs[pointer - 1][1] = bestEquality1;\n        } else {\n          diffs.splice(pointer - 1, 1);\n          pointer--;\n        }\n        diffs[pointer][1] = bestEdit;\n        if (bestEquality2) {\n          diffs[pointer + 1][1] = bestEquality2;\n        } else {\n          diffs.splice(pointer + 1, 1);\n          pointer--;\n        }\n      }\n    }\n    pointer++;\n  }\n};\n\n\n// Define some regex patterns for matching boundaries.\nvar nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;\nvar whitespaceRegex_ = /\\s/;\nvar linebreakRegex_ = /[\\r\\n]/;\nvar blanklineEndRegex_ = /\\n\\r?\\n$/;\nvar blanklineStartRegex_ = /^\\r?\\n\\r?\\n/;\n\n\n/**\n * Reorder and merge like edit sections.  Merge equalities.\n * Any edit section can move as long as it doesn't cross an equality.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\nvar diff_cleanupMerge = function(diffs: Array<Diff>) {\n  // Add a dummy entry at the end.\n  diffs.push(new Diff(DIFF_EQUAL, ''));\n  var pointer = 0;\n  var count_delete = 0;\n  var count_insert = 0;\n  var text_delete = '';\n  var text_insert = '';\n  var commonlength;\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_EQUAL:\n        // Upon reaching an equality, check for prior redundancies.\n        if (count_delete + count_insert > 1) {\n          if (count_delete !== 0 && count_insert !== 0) {\n            // Factor out any common prefixies.\n            commonlength = diff_commonPrefix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              if ((pointer - count_delete - count_insert) > 0 &&\n                  diffs[pointer - count_delete - count_insert - 1][0] ==\n                  DIFF_EQUAL) {\n                diffs[pointer - count_delete - count_insert - 1][1] +=\n                    text_insert.substring(0, commonlength);\n              } else {\n                diffs.splice(0, 0, new Diff(DIFF_EQUAL,\n                    text_insert.substring(0, commonlength)));\n                pointer++;\n              }\n              text_insert = text_insert.substring(commonlength);\n              text_delete = text_delete.substring(commonlength);\n            }\n            // Factor out any common suffixies.\n            commonlength = diff_commonSuffix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              diffs[pointer][1] = text_insert.substring(text_insert.length -\n                  commonlength) + diffs[pointer][1];\n              text_insert = text_insert.substring(0, text_insert.length -\n                  commonlength);\n              text_delete = text_delete.substring(0, text_delete.length -\n                  commonlength);\n            }\n          }\n          // Delete the offending records and add the merged ones.\n          pointer -= count_delete + count_insert;\n          diffs.splice(pointer, count_delete + count_insert);\n          if (text_delete.length) {\n            diffs.splice(pointer, 0,\n                new Diff(DIFF_DELETE, text_delete));\n            pointer++;\n          }\n          if (text_insert.length) {\n            diffs.splice(pointer, 0,\n                new Diff(DIFF_INSERT, text_insert));\n            pointer++;\n          }\n          pointer++;\n        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {\n          // Merge this equality with the previous one.\n          diffs[pointer - 1][1] += diffs[pointer][1];\n          diffs.splice(pointer, 1);\n        } else {\n          pointer++;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = '';\n        text_insert = '';\n        break;\n    }\n  }\n  if (diffs[diffs.length - 1][1] === '') {\n    diffs.pop();  // Remove the dummy entry at the end.\n  }\n\n  // Second pass: look for single edits surrounded on both sides by equalities\n  // which can be shifted sideways to eliminate an equality.\n  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n  var changes = false;\n  pointer = 1;\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\n        diffs[pointer + 1][0] == DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      if (diffs[pointer][1].substring(diffs[pointer][1].length -\n          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {\n        // Shift the edit over the previous equality.\n        diffs[pointer][1] = diffs[pointer - 1][1] +\n            diffs[pointer][1].substring(0, diffs[pointer][1].length -\n                                        diffs[pointer - 1][1].length);\n        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n        diffs.splice(pointer - 1, 1);\n        changes = true;\n      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==\n          diffs[pointer + 1][1]) {\n        // Shift the edit over the next equality.\n        diffs[pointer - 1][1] += diffs[pointer + 1][1];\n        diffs[pointer][1] =\n            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +\n            diffs[pointer + 1][1];\n        diffs.splice(pointer + 1, 1);\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n  // If shifts were made, the diff needs reordering and another shift sweep.\n  if (changes) {\n    diff_cleanupMerge(diffs);\n  }\n};\n\n\nexport {\n  Diff,\n  DIFF_EQUAL,\n  DIFF_DELETE,\n  DIFF_INSERT,\n  diff_cleanupSemantic as cleanupSemantic,\n};\n",
  "packages/jest-diff/src/cleanupSemantic.d.ts": "/**\n * Diff Match and Patch\n * Copyright 2018 The diff-match-patch Authors.\n * https://github.com/google/diff-match-patch\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @fileoverview Computes the difference between two texts to create a patch.\n * Applies the patch onto another text, allowing for errors.\n * @author fraser@google.com (Neil Fraser)\n */\n/**\n * CHANGES by pedrottimark to diff_match_patch_uncompressed.ts file:\n *\n * 1. Delete anything not needed to use diff_cleanupSemantic method\n * 2. Convert from prototype properties to var declarations\n * 3. Convert Diff to class from constructor and prototype\n * 4. Add type annotations for arguments and return values\n * 5. Add exports\n */\n/**\n * The data structure representing a diff is an array of tuples:\n * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n */\ndeclare var DIFF_DELETE: number;\ndeclare var DIFF_INSERT: number;\ndeclare var DIFF_EQUAL: number;\n/**\n * Class representing one diff tuple.\n * Attempts to look like a two-element array (which is what this used to be).\n * @param {number} op Operation, one of: DIFF_DELETE, DIFF_INSERT, DIFF_EQUAL.\n * @param {string} text Text to be deleted, inserted, or retained.\n * @constructor\n */\ndeclare class Diff {\n    0: number;\n    1: string;\n    constructor(op: number, text: string);\n}\n/**\n * Reduce the number of edits by eliminating semantically trivial equalities.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndeclare var diff_cleanupSemantic: (diffs: Array<Diff>) => void;\nexport { Diff, DIFF_EQUAL, DIFF_DELETE, DIFF_INSERT, diff_cleanupSemantic as cleanupSemantic, };\n",
  "packages/jest-diff/src/__tests__/joinAlignedDiffs.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {DIFF_DELETE, DIFF_EQUAL, DIFF_INSERT, Diff} from '../cleanupSemantic';\nimport {\n  joinAlignedDiffsExpand,\n  joinAlignedDiffsNoExpand,\n} from '../joinAlignedDiffs';\nimport {noColor, normalizeDiffOptions} from '../normalizeDiffOptions';\n\n// To align columns so people can review snapshots confidently:\n\n// 1. Use options to omit line colors.\nconst changeColor = (string: string) => `<i>${string}</i>`;\nconst optionsNoColor = {\n  aColor: noColor,\n  bColor: noColor,\n  changeColor,\n  commonColor: noColor,\n  emptyFirstOrLastLinePlaceholder: '↵', // U+21B5\n  patchColor: noColor,\n};\n\n// 2. Add string serializer to omit double quote marks.\nexpect.addSnapshotSerializer({\n  serialize: (val: string) => val,\n  test: (val: unknown) => typeof val === 'string',\n});\n\nconst diffsCommonStartEnd = [\n  new Diff(DIFF_EQUAL, ''),\n  new Diff(DIFF_EQUAL, 'common 2 preceding A'),\n  new Diff(DIFF_EQUAL, 'common 1 preceding A'),\n  new Diff(DIFF_DELETE, 'delete line'),\n  new Diff(DIFF_DELETE, ['change ', changeColor('expect'), 'ed A'].join('')),\n  new Diff(DIFF_INSERT, ['change ', changeColor('receiv'), 'ed A'].join('')),\n  new Diff(DIFF_EQUAL, 'common 1 following A'),\n  new Diff(DIFF_EQUAL, 'common 2 following A'),\n  new Diff(DIFF_EQUAL, 'common 3 following A'),\n  new Diff(DIFF_EQUAL, 'common 4 following A'),\n  new Diff(DIFF_EQUAL, 'common 4 preceding B'),\n  new Diff(DIFF_EQUAL, 'common 3 preceding B'),\n  new Diff(DIFF_EQUAL, 'common 2 preceding B'),\n  new Diff(DIFF_EQUAL, 'common 1 preceding B'),\n  new Diff(DIFF_DELETE, ['change ', changeColor('expect'), 'ed B'].join('')),\n  new Diff(DIFF_INSERT, ['change ', changeColor('receiv'), 'ed B'].join('')),\n  new Diff(DIFF_INSERT, 'insert line'),\n  new Diff(DIFF_EQUAL, 'common 1 following B'),\n  new Diff(DIFF_EQUAL, 'common 2 following B'),\n  new Diff(DIFF_EQUAL, 'common 3 between B and C'),\n  new Diff(DIFF_EQUAL, 'common 2 preceding C'),\n  new Diff(DIFF_EQUAL, 'common 1 preceding C'),\n  new Diff(DIFF_DELETE, ['change ', changeColor('expect'), 'ed C'].join('')),\n  new Diff(DIFF_INSERT, ['change ', changeColor('receiv'), 'ed C'].join('')),\n  new Diff(DIFF_EQUAL, 'common 1 following C'),\n  new Diff(DIFF_EQUAL, 'common 2 following C'),\n  new Diff(DIFF_EQUAL, 'common 3 following C'),\n  new Diff(DIFF_EQUAL, ''),\n  new Diff(DIFF_EQUAL, 'common 5 following C'),\n];\n\nconst diffsChangeStartEnd = [\n  new Diff(DIFF_DELETE, 'delete'),\n  new Diff(DIFF_EQUAL, 'common following delete'),\n  new Diff(DIFF_EQUAL, 'common preceding insert'),\n  new Diff(DIFF_INSERT, 'insert'),\n];\n\ndescribe('joinAlignedDiffsExpand', () => {\n  test('first line is empty common', () => {\n    const options = normalizeDiffOptions(optionsNoColor);\n\n    expect(\n      joinAlignedDiffsExpand(diffsCommonStartEnd, options),\n    ).toMatchSnapshot();\n  });\n});\n\ndescribe('joinAlignedDiffsNoExpand', () => {\n  test('patch 0 with context 1 and change at start and end', () => {\n    const options = normalizeDiffOptions({\n      ...optionsNoColor,\n      contextLines: 1,\n      expand: false,\n    });\n\n    expect(\n      joinAlignedDiffsNoExpand(diffsChangeStartEnd, options),\n    ).toMatchSnapshot();\n  });\n\n  test('patch 0 with context 5 and first line is empty common', () => {\n    const options = normalizeDiffOptions({...optionsNoColor, expand: false});\n\n    expect(\n      joinAlignedDiffsNoExpand(diffsCommonStartEnd, options),\n    ).toMatchSnapshot();\n  });\n\n  test('patch 1 with context 4 and last line is empty common', () => {\n    const options = normalizeDiffOptions({\n      ...optionsNoColor,\n      contextLines: 4,\n      expand: false,\n    });\n\n    expect(\n      joinAlignedDiffsNoExpand(diffsCommonStartEnd, options),\n    ).toMatchSnapshot();\n  });\n\n  test('patch 2 with context 3', () => {\n    const options = normalizeDiffOptions({\n      ...optionsNoColor,\n      contextLines: 3,\n      expand: false,\n    });\n\n    expect(\n      joinAlignedDiffsNoExpand(diffsCommonStartEnd, options),\n    ).toMatchSnapshot();\n  });\n\n  test('patch 3 with context 2 and omit excess common at start', () => {\n    const options = normalizeDiffOptions({\n      ...optionsNoColor,\n      contextLines: 2,\n      expand: false,\n    });\n\n    expect(\n      joinAlignedDiffsNoExpand(diffsCommonStartEnd, options),\n    ).toMatchSnapshot();\n  });\n});\n",
  "packages/jest-diff/src/__tests__/joinAlignedDiffs.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-diff/src/__tests__/getAlignedDiffs.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {diffStringsUnified} from '../printDiffs';\n\n// To align columns so people can review snapshots confidently:\n\n// 1. Use options to omit line colors.\nconst identity = (string: string) => string;\nconst changeColor = (string: string) => `<i>${string}</i>`;\nconst options = {\n  aColor: identity,\n  bColor: identity,\n  changeColor,\n  commonColor: identity,\n  omitAnnotationLines: true,\n  patchColor: identity,\n};\n\nconst testAlignedDiffs = (a: string, b: string): string =>\n  diffStringsUnified(a, b, options);\n\n// 2. Add string serializer to omit double quote marks.\nexpect.addSnapshotSerializer({\n  serialize: (val: string) => val,\n  test: (val: unknown) => typeof val === 'string',\n});\n\ndescribe('getAlignedDiffs', () => {\n  describe('lines', () => {\n    test('change preceding and following common', () => {\n      const a = 'delete\\ncommon between changes\\nprev';\n      const b = 'insert\\ncommon between changes\\nnext';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });\n\n    test('common preceding and following change', () => {\n      const a = 'common preceding\\ndelete\\ncommon following';\n      const b = 'common preceding\\ninsert\\ncommon following';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });\n\n    test('common at end when both current change lines are empty', () => {\n      const a = 'delete\\ncommon at end';\n      const b = 'common at end';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });\n\n    test('common between delete and insert', () => {\n      const a = 'delete\\ncommon between changes';\n      const b = 'common between changes\\ninsert';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });\n\n    test('common between insert and delete', () => {\n      const a = 'common between changes\\ndelete';\n      const b = 'insert\\ncommon between changes';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });\n  });\n\n  describe('newline', () => {\n    test('delete only', () => {\n      const a = 'preceding\\nfollowing';\n      const b = 'precedingfollowing';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });\n\n    test('insert only', () => {\n      const a = 'precedingfollowing';\n      const b = 'preceding\\nfollowing';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });\n\n    test('delete with adjacent change', () => {\n      const a = 'preceding\\nfollowing';\n      const b = 'precededfollowing';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });\n\n    test('insert with adjacent changes', () => {\n      const a = 'precededfollowing';\n      const b = 'preceding\\nFollowing';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });\n\n    test('change from space', () => {\n      const a = 'preceding following';\n      const b = 'preceding\\nfollowing';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });\n\n    test('change to space', () => {\n      const a = 'preceding\\nfollowing';\n      const b = 'preceding following';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });\n  });\n\n  describe('substrings first', () => {\n    test('common when both current change lines are empty', () => {\n      const a = 'first\\nmiddle\\nlast prev';\n      const b = 'insert\\nfirst\\nmiddle\\nlast next';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });\n\n    test('common when either current change line is non-empty', () => {\n      const a = 'expected first\\n\\nlast';\n      const b = 'first\\n\\nlast';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });\n\n    test('delete completes the current line', () => {\n      const a = 'common preceding first\\nmiddle\\nlast and following';\n      const b = 'common preceding and following';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });\n\n    test('insert completes the current line', () => {\n      const a = 'common preceding';\n      const b = 'common preceding first\\nmiddle\\n';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });\n  });\n\n  describe('substrings middle', () => {\n    test('is empty in delete between common', () => {\n      const a = 'common at start precedes delete\\n\\nexpected common at end';\n      const b = 'common at start precedes received common at end';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });\n\n    test('is empty in insert at start', () => {\n      const a = 'expected common at end';\n      const b = 'insert line\\n\\nreceived common at end';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });\n\n    test('is non-empty in delete at end', () => {\n      const a = 'common at start precedes delete\\nnon-empty line\\nnext';\n      const b = 'common at start precedes prev';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });\n\n    test('is non-empty in insert between common', () => {\n      const a = 'common at start precedes delete expected';\n      const b = 'common at start precedes insert\\nnon-empty\\nreceived';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });\n  });\n\n  describe('substrings last', () => {\n    test('is empty in delete at end', () => {\n      const a = 'common string preceding prev\\n';\n      const b = 'common string preceding next';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });\n\n    test('is empty in insert at end', () => {\n      const a = 'common string preceding prev';\n      const b = 'common string preceding next\\n';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });\n\n    test('is non-empty in common not at end', () => {\n      const a = 'common first\\nlast expected';\n      const b = 'common first\\nlast received';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });\n  });\n\n  describe('strings', () => {\n    test('change at start and delete or insert at end', () => {\n      const a = 'prev change common delete\\nunchanged\\nexpected change common';\n      const b = 'next change common\\nunchanged\\nreceived change common insert';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });\n\n    test('delete or insert at start and change at end', () => {\n      const a = 'common change prev\\nunchanged\\ndelete common change this';\n      const b = 'insert common change next\\nunchanged\\ncommon change that';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });\n  });\n});\n",
  "packages/jest-diff/src/__tests__/getAlignedDiffs.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-diff/src/__tests__/escapeControlCharacters.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {escapeControlCharacters} from '../escapeControlCharacters';\n\ndescribe('escapeControlCharacters', () => {\n  test('preserves regular printable characters', () => {\n    const input = 'Jest 123!@#$%^&*()';\n    expect(escapeControlCharacters(input)).toBe(input);\n  });\n\n  test('preserves whitespace characters that are meaningful for formatting', () => {\n    const input = 'line1\\nline2\\tindented\\rcarriage';\n    expect(escapeControlCharacters(input)).toBe(input);\n  });\n\n  test('escapes NULL character', () => {\n    const input = 'before\\u0000after';\n    expect(escapeControlCharacters(input)).toBe('before\\\\x00after');\n  });\n\n  test('escapes SOH (Start of Heading) character', () => {\n    const input = 'before\\u0001after';\n    expect(escapeControlCharacters(input)).toBe('before\\\\x01after');\n  });\n\n  test('escapes backspace character to \\\\b', () => {\n    const input = 'before\\u0008after';\n    expect(escapeControlCharacters(input)).toBe('before\\\\bafter');\n  });\n\n  test('escapes vertical tab character to \\\\v', () => {\n    const input = 'before\\u000Bafter';\n    expect(escapeControlCharacters(input)).toBe('before\\\\vafter');\n  });\n\n  test('escapes form feed character to \\\\f', () => {\n    const input = 'before\\u000Cafter';\n    expect(escapeControlCharacters(input)).toBe('before\\\\fafter');\n  });\n\n  test('escapes ESC (Escape) character', () => {\n    const input = 'before\\u001Bafter';\n    expect(escapeControlCharacters(input)).toBe('before\\\\x1bafter');\n  });\n\n  test('escapes DEL character', () => {\n    const input = 'before\\u007Fafter';\n    expect(escapeControlCharacters(input)).toBe('before\\\\x7fafter');\n  });\n\n  test('escapes C1 control characters', () => {\n    const input = 'before\\u0080\\u0081\\u009Fafter';\n    expect(escapeControlCharacters(input)).toBe('before\\\\x80\\\\x81\\\\x9fafter');\n  });\n\n  test('handles mixed control characters and regular text', () => {\n    const input = 'FIX\\u00014.4\\u00019=68\\u00135=A\\u0001MSG_TYPE=D';\n    expect(escapeControlCharacters(input)).toBe(\n      'FIX\\\\x014.4\\\\x019=68\\\\x135=A\\\\x01MSG_TYPE=D',\n    );\n  });\n\n  test('handles financial message protocol string with control characters', () => {\n    const input = '8=FIXT.1.1\\u00019=68\\u00135=A\\u00134=1\\u00149=ISLD';\n    expect(escapeControlCharacters(input)).toBe(\n      '8=FIXT.1.1\\\\x019=68\\\\x135=A\\\\x134=1\\\\x149=ISLD',\n    );\n  });\n\n  test('preserves empty string', () => {\n    expect(escapeControlCharacters('')).toBe('');\n  });\n\n  test('handles string with only control characters', () => {\n    const input = '\\u0000\\u0001\\u0002\\u0003';\n    expect(escapeControlCharacters(input)).toBe('\\\\x00\\\\x01\\\\x02\\\\x03');\n  });\n\n  test('preserves Unicode characters that are not control characters', () => {\n    const input = 'café 中文 🚀 αβγ';\n    expect(escapeControlCharacters(input)).toBe(input);\n  });\n\n  test('handles BEL (Bell) character', () => {\n    const input = 'alert\\u0007sound';\n    expect(escapeControlCharacters(input)).toBe('alert\\\\x07sound');\n  });\n\n  test('preserves newlines in multiline strings', () => {\n    const input = 'line 1\\nline 2\\nline 3';\n    expect(escapeControlCharacters(input)).toBe(input);\n  });\n\n  test('preserves tabs for code formatting', () => {\n    const input = 'function() {\\n\\treturn true;\\n}';\n    expect(escapeControlCharacters(input)).toBe(input);\n  });\n\n  test('escapes multiple consecutive control characters', () => {\n    const input = 'data\\u0001\\u0002\\u0003separator';\n    expect(escapeControlCharacters(input)).toBe('data\\\\x01\\\\x02\\\\x03separator');\n  });\n\n  test('handles control characters at string boundaries', () => {\n    const startControl = '\\u0001start';\n    const endControl = 'end\\u0001';\n    expect(escapeControlCharacters(startControl)).toBe('\\\\x01start');\n    expect(escapeControlCharacters(endControl)).toBe('end\\\\x01');\n  });\n});\n",
  "packages/jest-diff/src/__tests__/escapeControlCharacters.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-diff/src/__tests__/diffStringsRaw.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {DIFF_DELETE, DIFF_EQUAL, DIFF_INSERT, Diff, diffStringsRaw} from '../';\n\ndescribe('diffStringsRaw', () => {\n  test('one-line with cleanup', () => {\n    const expected: Array<Diff> = [\n      new Diff(DIFF_EQUAL, 'change '),\n      new Diff(DIFF_DELETE, 'from'),\n      new Diff(DIFF_INSERT, 'to'),\n    ];\n    const received = diffStringsRaw('change from', 'change to', true);\n\n    expect(received).toEqual(expected);\n  });\n\n  test('one-line without cleanup', () => {\n    const expected: Array<Diff> = [\n      new Diff(DIFF_EQUAL, 'change '),\n      new Diff(DIFF_DELETE, 'fr'),\n      new Diff(DIFF_INSERT, 't'),\n      new Diff(DIFF_EQUAL, 'o'),\n      new Diff(DIFF_DELETE, 'm'),\n    ];\n    const received = diffStringsRaw('change from', 'change to', false);\n\n    expect(received).toEqual(expected);\n  });\n});\n",
  "packages/jest-diff/src/__tests__/diffStringsRaw.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-diff/src/__tests__/diff.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {stripVTControlCharacters as stripAnsi} from 'util';\nimport chalk from 'chalk';\nimport {alignedAnsiStyleSerializer} from '@jest/test-utils';\nimport {diff} from '../';\nimport {NO_DIFF_MESSAGE} from '../constants';\nimport {diffLinesUnified, diffLinesUnified2} from '../diffLines';\nimport {noColor} from '../normalizeDiffOptions';\nimport {diffStringsUnified} from '../printDiffs';\nimport type {DiffOptions} from '../types';\n\nconst optionsCounts: DiffOptions = {\n  includeChangeCounts: true,\n};\n\n// Use only in toBe assertions for edge case messages.\nconst stripped = (a: unknown, b: unknown) => stripAnsi(diff(a, b) ?? '');\n\n// Use in toBe assertions for comparison lines.\nconst optionsBe: DiffOptions = {\n  aColor: noColor,\n  bColor: noColor,\n  commonColor: noColor,\n  omitAnnotationLines: true,\n};\nconst unexpandedBe: DiffOptions = {\n  ...optionsBe,\n  expand: false,\n};\nconst expandedBe: DiffOptions = {\n  ...optionsBe,\n  expand: true,\n};\n\n// Use for toMatchSnapshot assertions.\nconst unexpanded = {expand: false};\nconst expanded = {expand: true};\n\nconst elementSymbol = Symbol.for('react.element');\n\nexpect.addSnapshotSerializer(alignedAnsiStyleSerializer);\n\ndescribe('different types', () => {\n  for (const values of [\n    [1, 'a', 'number', 'string'],\n    [{}, 'a', 'object', 'string'],\n    [[], 2, 'array', 'number'],\n    [null, undefined, 'null', 'undefined'],\n    [() => {}, 3, 'function', 'number'],\n  ]) {\n    const a = values[0];\n    const b = values[1];\n    const typeA = values[2];\n    const typeB = values[3];\n\n    test(`'${String(a)}' and '${String(b)}'`, () => {\n      expect(stripped(a, b)).toBe(\n        '  Comparing two different types of values. ' +\n          `Expected ${String(typeA)} but received ${String(typeB)}.`,\n      );\n    });\n  }\n});\n\ndescribe('no visual difference', () => {\n  for (const values of [\n    ['a', 'a'],\n    [{}, {}],\n    [[], []],\n    [\n      [1, 2],\n      [1, 2],\n    ],\n    [11, 11],\n    /* eslint-disable unicorn/prefer-number-properties */\n    [NaN, NaN],\n    [Number.NaN, NaN],\n    /* eslint-enable */\n    [() => {}, () => {}],\n    [null, null],\n    [undefined, undefined],\n    [false, false],\n    [{a: 1}, {a: 1}],\n    [{a: {b: 5}}, {a: {b: 5}}],\n  ]) {\n    test(`'${JSON.stringify(values[0])}' and '${JSON.stringify(\n      values[1],\n    )}'`, () => {\n      expect(stripped(values[0], values[1])).toBe(NO_DIFF_MESSAGE);\n    });\n  }\n\n  test('Map key order should be irrelevant', () => {\n    const arg1 = new Map([\n      [1, 'foo'],\n      [2, 'bar'],\n    ]);\n    const arg2 = new Map([\n      [2, 'bar'],\n      [1, 'foo'],\n    ]);\n\n    expect(stripped(arg1, arg2)).toBe(NO_DIFF_MESSAGE);\n  });\n\n  test('Set value order should be irrelevant', () => {\n    const arg1 = new Set([1, 2]);\n    const arg2 = new Set([2, 1]);\n\n    expect(stripped(arg1, arg2)).toBe(NO_DIFF_MESSAGE);\n  });\n});\n\ntest('oneline strings', () => {\n  expect(diff('ab', 'aa', optionsCounts)).toMatchSnapshot();\n  expect(diff('123456789', '234567890', optionsCounts)).toMatchSnapshot();\n  expect(diff('oneline', 'multi\\nline', optionsCounts)).toMatchSnapshot();\n  expect(diff('multi\\nline', 'oneline', optionsCounts)).toMatchSnapshot();\n});\n\ndescribe('falls back to not call toJSON', () => {\n  describe('if serialization has no differences', () => {\n    const toJSON = function toJSON() {\n      return 'it’s all the same to me';\n    };\n\n    test('but then objects have differences', () => {\n      const a = {line: 1, toJSON};\n      const b = {line: 2, toJSON};\n      expect(diff(a, b, optionsCounts)).toMatchSnapshot();\n    });\n    test('and then objects have no differences', () => {\n      const a = {line: 2, toJSON};\n      const b = {line: 2, toJSON};\n      expect(stripped(a, b)).toBe(NO_DIFF_MESSAGE);\n    });\n  });\n  describe('if it throws', () => {\n    const toJSON = function toJSON() {\n      throw new Error('catch me if you can');\n    };\n\n    test('and then objects have differences', () => {\n      const a = {line: 1, toJSON};\n      const b = {line: 2, toJSON};\n      expect(diff(a, b, optionsCounts)).toMatchSnapshot();\n    });\n    test('and then objects have no differences', () => {\n      const a = {line: 2, toJSON};\n      const b = {line: 2, toJSON};\n      expect(stripped(a, b)).toBe(NO_DIFF_MESSAGE);\n    });\n  });\n});\n\n// Some of the following assertions seem complex, but compare to alternatives:\n// * toBe instead of toMatchSnapshot:\n//   * to avoid visual complexity of escaped quotes in expected string\n//   * to omit Expected/Received heading which is an irrelevant detail\n// * join lines of expected string instead of multiline string:\n//   * to avoid ambiguity about indentation in diff lines\n\ndescribe('multiline strings', () => {\n  const a = `line 1\nline 2\nline 3\nline 4`;\n  const b = `line 1\nline  2\nline 3\nline 4`;\n  const expected = [\n    '  line 1',\n    '- line 2',\n    '+ line  2',\n    '  line 3',\n    '  line 4',\n  ].join('\\n');\n\n  test('(unexpanded)', () => {\n    expect(diff(a, b, unexpandedBe)).toBe(expected);\n  });\n  test('(expanded)', () => {\n    expect(diff(a, b, expandedBe)).toBe(expected);\n  });\n});\n\ndescribe('objects', () => {\n  const a = {a: {b: {c: 5}}};\n  const b = {a: {b: {c: 6}}};\n  const expected = [\n    '  Object {',\n    '    \"a\": Object {',\n    '      \"b\": Object {',\n    '-       \"c\": 5,',\n    '+       \"c\": 6,',\n    '      },',\n    '    },',\n    '  }',\n  ].join('\\n');\n\n  test('(unexpanded)', () => {\n    expect(diff(a, b, unexpandedBe)).toBe(expected);\n  });\n  test('(expanded)', () => {\n    expect(diff(a, b, expandedBe)).toBe(expected);\n  });\n});\n\ntest('numbers', () => {\n  expect(diff(1, 2, optionsBe)).toBe('- 1\\n+ 2');\n});\n\ntest('-0 and 0', () => {\n  expect(diff(-0, 0, optionsBe)).toBe('- -0\\n+ 0');\n});\n\ntest('booleans', () => {\n  expect(diff(false, true, optionsBe)).toBe('- false\\n+ true');\n});\n\ndescribe('multiline string non-snapshot', () => {\n  // For example, CLI output\n  // toBe or toEqual for a string isn’t enclosed in double quotes.\n  const a = `Options:\n--help, -h  Show help                            [boolean]\n--bail, -b  Exit the test suite immediately upon the first\n            failing test.                        [boolean]`;\n  const b = `Options:\n  --help, -h  Show help                            [boolean]\n  --bail, -b  Exit the test suite immediately upon the first\n              failing test.                        [boolean]`;\n  const expected = [\n    '  Options:',\n    '- --help, -h  Show help                            [boolean]',\n    '- --bail, -b  Exit the test suite immediately upon the first',\n    '-             failing test.                        [boolean]',\n    '+   --help, -h  Show help                            [boolean]',\n    '+   --bail, -b  Exit the test suite immediately upon the first',\n    '+               failing test.                        [boolean]',\n  ].join('\\n');\n\n  test('(unexpanded)', () => {\n    expect(diff(a, b, unexpandedBe)).toBe(expected);\n  });\n  test('(expanded)', () => {\n    expect(diff(a, b, expandedBe)).toBe(expected);\n  });\n});\n\ndescribe('multiline string snapshot', () => {\n  // For example, CLI output\n  // A snapshot of a string is enclosed in double quotes.\n  const a = `\"\nOptions:\n--help, -h  Show help                            [boolean]\n--bail, -b  Exit the test suite immediately upon the first\n            failing test.                        [boolean]\"`;\n  const b = `\"\nOptions:\n  --help, -h  Show help                            [boolean]\n  --bail, -b  Exit the test suite immediately upon the first\n              failing test.                        [boolean]\"`;\n  const expected = [\n    '  \"',\n    '  Options:',\n    '- --help, -h  Show help                            [boolean]',\n    '- --bail, -b  Exit the test suite immediately upon the first',\n    '-             failing test.                        [boolean]\"',\n    '+   --help, -h  Show help                            [boolean]',\n    '+   --bail, -b  Exit the test suite immediately upon the first',\n    '+               failing test.                        [boolean]\"',\n  ].join('\\n');\n\n  test('(unexpanded)', () => {\n    expect(diff(a, b, unexpandedBe)).toBe(expected);\n  });\n  test('(expanded)', () => {\n    expect(diff(a, b, expandedBe)).toBe(expected);\n  });\n});\n\ndescribe('React elements', () => {\n  const a = {\n    $$typeof: elementSymbol,\n    props: {\n      children: 'Hello',\n      className: 'fun',\n    },\n    type: 'div',\n  };\n  const b = {\n    $$typeof: elementSymbol,\n    props: {\n      children: 'Goodbye',\n      className: 'fun',\n    },\n    type: 'div',\n  };\n  const expected = [\n    '  <div',\n    '    className=\"fun\"',\n    '  >',\n    '-   Hello',\n    '+   Goodbye',\n    '  </div>',\n  ].join('\\n');\n\n  test('(unexpanded)', () => {\n    expect(diff(a, b, unexpandedBe)).toBe(expected);\n  });\n  test('(expanded)', () => {\n    expect(diff(a, b, expandedBe)).toBe(expected);\n  });\n});\n\ndescribe('multiline string as value of object property', () => {\n  const expected = [\n    '  Object {',\n    '    \"id\": \"J\",',\n    '    \"points\": \"0.5,0.460',\n    '+ 0.5,0.875',\n    '  0.25,0.875\",',\n    '  }',\n  ].join('\\n');\n\n  describe('(non-snapshot)', () => {\n    const a = {\n      id: 'J',\n      points: '0.5,0.460\\n0.25,0.875',\n    };\n    const b = {\n      id: 'J',\n      points: '0.5,0.460\\n0.5,0.875\\n0.25,0.875',\n    };\n    test('(unexpanded)', () => {\n      expect(diff(a, b, unexpandedBe)).toBe(expected);\n    });\n    test('(expanded)', () => {\n      expect(diff(a, b, expandedBe)).toBe(expected);\n    });\n  });\n\n  describe('(snapshot)', () => {\n    const a = [\n      'Object {',\n      '  \"id\": \"J\",',\n      '  \"points\": \"0.5,0.460',\n      '0.25,0.875\",',\n      '}',\n    ].join('\\n');\n    const b = [\n      'Object {',\n      '  \"id\": \"J\",',\n      '  \"points\": \"0.5,0.460',\n      '0.5,0.875',\n      '0.25,0.875\",',\n      '}',\n    ].join('\\n');\n    test('(unexpanded)', () => {\n      expect(diff(a, b, unexpandedBe)).toBe(expected);\n    });\n    test('(expanded)', () => {\n      expect(diff(a, b, expandedBe)).toBe(expected);\n    });\n  });\n});\n\ndescribe('indentation in JavaScript structures', () => {\n  const searching = '';\n  const object = {\n    descending: false,\n    fieldKey: 'what',\n  };\n  const a = {\n    searching,\n    sorting: object,\n  };\n  const b = {\n    searching,\n    sorting: [object],\n  };\n\n  describe('from less to more', () => {\n    const expected = [\n      '  Object {',\n      '    \"searching\": \"\",',\n      '-   \"sorting\": Object {',\n      '+   \"sorting\": Array [',\n      '+     Object {',\n      // following 3 lines are unchanged, except for more indentation\n      '        \"descending\": false,',\n      '        \"fieldKey\": \"what\",',\n      '      },',\n      '+   ],',\n      '  }',\n    ].join('\\n');\n\n    test('(unexpanded)', () => {\n      expect(diff(a, b, unexpandedBe)).toBe(expected);\n    });\n    test('(expanded)', () => {\n      expect(diff(a, b, expandedBe)).toBe(expected);\n    });\n  });\n\n  describe('from more to less', () => {\n    const expected = [\n      '  Object {',\n      '    \"searching\": \"\",',\n      '-   \"sorting\": Array [',\n      '-     Object {',\n      '+   \"sorting\": Object {',\n      // following 3 lines are unchanged, except for less indentation\n      '      \"descending\": false,',\n      '      \"fieldKey\": \"what\",',\n      '    },',\n      '-   ],',\n      '  }',\n    ].join('\\n');\n\n    test('(unexpanded)', () => {\n      expect(diff(b, a, unexpandedBe)).toBe(expected);\n    });\n    test('(expanded)', () => {\n      expect(diff(b, a, expandedBe)).toBe(expected);\n    });\n  });\n});\n\ndescribe('color of text', () => {\n  const searching = '';\n  const object = {\n    descending: false,\n    fieldKey: 'what',\n  };\n  const a = {\n    searching,\n    sorting: object,\n  };\n  const b = {\n    searching,\n    sorting: [object],\n  };\n  const received = diff(a, b, expanded);\n\n  test('(expanded)', () => {\n    expect(received).toMatchSnapshot();\n  });\n  test('(unexpanded)', () => {\n    // Expect same result, unless diff is long enough to require patch marks.\n    expect(diff(a, b, unexpanded)).toBe(received);\n  });\n});\n\ndescribe('indentation in React elements (non-snapshot)', () => {\n  const leaf = {\n    $$typeof: elementSymbol,\n    props: {\n      children: ['text'],\n    },\n    type: 'span',\n  };\n  const a = {\n    $$typeof: elementSymbol,\n    props: {\n      children: [leaf],\n    },\n    type: 'span',\n  };\n  const b = {\n    $$typeof: elementSymbol,\n    props: {\n      children: [\n        {\n          $$typeof: elementSymbol,\n          props: {\n            children: [leaf],\n          },\n          type: 'strong',\n        },\n      ],\n    },\n    type: 'span',\n  };\n\n  describe('from less to more', () => {\n    const expected = [\n      '  <span>',\n      '+   <strong>',\n      // following 3 lines are unchanged, except for more indentation\n      '      <span>',\n      '        text',\n      '      </span>',\n      '+   </strong>',\n      '  </span>',\n    ].join('\\n');\n\n    test('(unexpanded)', () => {\n      expect(diff(a, b, unexpandedBe)).toBe(expected);\n    });\n    test('(expanded)', () => {\n      expect(diff(a, b, expandedBe)).toBe(expected);\n    });\n  });\n\n  describe('from more to less', () => {\n    const expected = [\n      '  <span>',\n      '-   <strong>',\n      // following 3 lines are unchanged, except for less indentation\n      '    <span>',\n      '      text',\n      '    </span>',\n      '-   </strong>',\n      '  </span>',\n    ].join('\\n');\n\n    test('(unexpanded)', () => {\n      expect(diff(b, a, unexpandedBe)).toBe(expected);\n    });\n    test('(expanded)', () => {\n      expect(diff(b, a, expandedBe)).toBe(expected);\n    });\n  });\n});\n\ndescribe('indentation in React elements (snapshot)', () => {\n  // prettier-ignore\n  const a = [\n    '<span>',\n    '  <span>',\n    '    text',\n    '  </span>',\n    '</span>',\n  ].join('\\n');\n  const b = [\n    '<span>',\n    '  <strong>',\n    '    <span>',\n    '      text',\n    '    </span>',\n    '  </strong>',\n    '</span>',\n  ].join('\\n');\n\n  describe('from less to more', () => {\n    // We intend to improve snapshot diff in the next version of Jest.\n    const expected = [\n      '  <span>',\n      '-   <span>',\n      '-     text',\n      '-   </span>',\n      '+   <strong>',\n      '+     <span>',\n      '+       text',\n      '+     </span>',\n      '+   </strong>',\n      '  </span>',\n    ].join('\\n');\n\n    test('(unexpanded)', () => {\n      expect(diff(a, b, unexpandedBe)).toBe(expected);\n    });\n    test('(expanded)', () => {\n      expect(diff(a, b, expandedBe)).toBe(expected);\n    });\n  });\n\n  describe('from more to less', () => {\n    // We intend to improve snapshot diff in the next version of Jest.\n    const expected = [\n      '  <span>',\n      '-   <strong>',\n      '-     <span>',\n      '-       text',\n      '-     </span>',\n      '-   </strong>',\n      '+   <span>',\n      '+     text',\n      '+   </span>',\n      '  </span>',\n    ].join('\\n');\n\n    test('(unexpanded)', () => {\n      expect(diff(b, a, unexpandedBe)).toBe(expected);\n    });\n    test('(expanded)', () => {\n      expect(diff(b, a, expandedBe)).toBe(expected);\n    });\n  });\n});\n\ndescribe('outer React element (non-snapshot)', () => {\n  const a = {\n    $$typeof: elementSymbol,\n    props: {\n      children: 'Jest',\n    },\n    type: 'h1',\n  };\n  const b = {\n    $$typeof: elementSymbol,\n    props: {\n      children: [\n        a,\n        {\n          $$typeof: elementSymbol,\n          props: {\n            children: 'Delightful JavaScript Testing',\n          },\n          type: 'h2',\n        },\n      ],\n    },\n    type: 'header',\n  };\n\n  describe('from less to more', () => {\n    const expected = [\n      '+ <header>',\n      // following 3 lines are unchanged, except for more indentation\n      '    <h1>',\n      '      Jest',\n      '    </h1>',\n      '+   <h2>',\n      '+     Delightful JavaScript Testing',\n      '+   </h2>',\n      '+ </header>',\n    ].join('\\n');\n\n    test('(unexpanded)', () => {\n      expect(diff(a, b, unexpandedBe)).toBe(expected);\n    });\n    test('(expanded)', () => {\n      expect(diff(a, b, expandedBe)).toBe(expected);\n    });\n  });\n\n  describe('from more to less', () => {\n    const expected = [\n      '- <header>',\n      // following 3 lines are unchanged, except for less indentation\n      '  <h1>',\n      '    Jest',\n      '  </h1>',\n      '-   <h2>',\n      '-     Delightful JavaScript Testing',\n      '-   </h2>',\n      '- </header>',\n    ].join('\\n');\n\n    test('(unexpanded)', () => {\n      expect(diff(b, a, unexpandedBe)).toBe(expected);\n    });\n    test('(expanded)', () => {\n      expect(diff(b, a, expandedBe)).toBe(expected);\n    });\n  });\n});\n\ndescribe('trailing newline in multiline string not enclosed in quotes', () => {\n  const a = ['line 1', 'line 2', 'line 3'].join('\\n');\n  const b = `${a}\\n`;\n\n  describe('from less to more', () => {\n    const expected = ['  line 1', '  line 2', '  line 3', '+'].join('\\n');\n\n    test('(unexpanded)', () => {\n      expect(diff(a, b, unexpandedBe)).toBe(expected);\n    });\n    test('(expanded)', () => {\n      expect(diff(a, b, expandedBe)).toBe(expected);\n    });\n  });\n\n  describe('from more to less', () => {\n    const expected = ['  line 1', '  line 2', '  line 3', '-'].join('\\n');\n\n    test('(unexpanded)', () => {\n      expect(diff(b, a, unexpandedBe)).toBe(expected);\n    });\n    test('(expanded)', () => {\n      expect(diff(b, a, expandedBe)).toBe(expected);\n    });\n  });\n});\n\ntest('collapses big diffs to patch format', () => {\n  const result = diff(\n    {test: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]},\n    {test: [1, 2, 3, 4, 5, 6, 7, 8, 10, 9]},\n    unexpanded,\n  );\n\n  expect(result).toMatchSnapshot();\n});\n\ndescribe('context', () => {\n  const testDiffContextLines = (contextLines?: number) => {\n    const validContextLines =\n      typeof contextLines === 'number' &&\n      Number.isSafeInteger(contextLines) &&\n      contextLines >= 0;\n\n    test(`number of lines: ${\n      typeof contextLines === 'number' ? contextLines : 'undefined'\n    } ${validContextLines ? '' : '(5 default)'}`, () => {\n      const options = {\n        ...optionsCounts,\n        contextLines,\n        expand: false,\n      };\n      if (!validContextLines) {\n        options.patchColor = chalk.dim;\n      }\n\n      const result = diff(\n        {test: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]},\n        {test: [1, 2, 3, 4, 5, 6, 7, 8, 10, 9]},\n        options,\n      );\n      expect(result).toMatchSnapshot();\n    });\n  };\n\n  testDiffContextLines(-1); // (5 default)\n  testDiffContextLines(0);\n  testDiffContextLines(1);\n  testDiffContextLines(2);\n  testDiffContextLines(3.1); // (5 default)\n  testDiffContextLines(); // (5 default)\n});\n\ndescribe('diffLinesUnified edge cases', () => {\n  test('a empty string b empty string', () => {\n    const a = '';\n    const b = '';\n\n    const received = diffLinesUnified(a.split('\\n'), b.split('\\n'), optionsBe);\n    const expected = '';\n\n    expect(received).toBe(expected);\n  });\n\n  test('a empty string b one line', () => {\n    const a = '';\n    const b = 'line 1';\n\n    const received = diffLinesUnified(a.split('\\n'), b.split('\\n'), optionsBe);\n    const expected = '+ line 1';\n\n    expect(received).toBe(expected);\n  });\n\n  test('a multiple lines b empty string', () => {\n    const a = 'line 1\\n\\nline 3';\n    const b = '';\n\n    const received = diffLinesUnified(a.split('\\n'), b.split('\\n'), optionsBe);\n    const expected = '- line 1\\n-\\n- line 3';\n\n    expect(received).toBe(expected);\n  });\n\n  test('a one line b multiple lines', () => {\n    const a = 'line 2';\n    const b = 'line 1\\nline 2\\nline 3';\n\n    const received = diffLinesUnified(a.split('\\n'), b.split('\\n'), optionsBe);\n    const expected = '+ line 1\\n  line 2\\n+ line 3';\n\n    expect(received).toBe(expected);\n  });\n});\n\ndescribe('diffLinesUnified2 edge cases', () => {\n  test('a empty string b empty string', () => {\n    const a = '';\n    const b = '';\n\n    const received = diffLinesUnified2(\n      a.split('\\n'),\n      b.split('\\n'),\n      a.split('\\n'),\n      b.split('\\n'),\n      optionsBe,\n    );\n    const expected = '';\n\n    expect(received).toBe(expected);\n  });\n\n  test('a empty string b one line', () => {\n    const a = '';\n    const b = 'line 1';\n\n    const received = diffLinesUnified2(\n      a.split('\\n'),\n      b.split('\\n'),\n      a.split('\\n'),\n      b.split('\\n'),\n      optionsBe,\n    );\n    const expected = '+ line 1';\n\n    expect(received).toBe(expected);\n  });\n\n  test('a multiple lines b empty string', () => {\n    const a = 'line 1\\n\\nline 3';\n    const b = '';\n\n    const received = diffLinesUnified2(\n      a.split('\\n'),\n      b.split('\\n'),\n      a.split('\\n'),\n      b.split('\\n'),\n      optionsBe,\n    );\n    const expected = '- line 1\\n-\\n- line 3';\n\n    expect(received).toBe(expected);\n  });\n\n  test('a one line b multiple lines', () => {\n    const aDisplay = 'LINE 2';\n    const bDisplay = 'Line 1\\nLine 2\\nLine 3';\n    const aCompare = aDisplay.toLowerCase();\n    const bCompare = bDisplay.toLowerCase();\n\n    const received = diffLinesUnified2(\n      aDisplay.split('\\n'),\n      bDisplay.split('\\n'),\n      aCompare.split('\\n'),\n      bCompare.split('\\n'),\n      optionsBe,\n    );\n    const expected = '+ Line 1\\n  Line 2\\n+ Line 3';\n\n    expect(received).toBe(expected);\n  });\n\n  describe('lengths not equal', () => {\n    // Fall back to diff of display lines.\n\n    test('a', () => {\n      const aDisplay = 'MiXeD cAsE';\n      const bDisplay = 'Mixed case\\nUPPER CASE';\n      const aCompare = `${aDisplay.toLowerCase()}\\nlower case`;\n      const bCompare = bDisplay.toLowerCase();\n\n      const received = diffLinesUnified2(\n        aDisplay.split('\\n'),\n        bDisplay.split('\\n'),\n        aCompare.split('\\n'),\n        bCompare.split('\\n'),\n        optionsBe,\n      );\n      const expected = '- MiXeD cAsE\\n+ Mixed case\\n+ UPPER CASE';\n\n      expect(received).toBe(expected);\n    });\n\n    test('b', () => {\n      const aDisplay = '{\\n  \"key\": \"value\",\\n}';\n      const bDisplay = '{\\n}';\n      const aCompare = '{\\n\"key\": \"value\",\\n}';\n      const bCompare = '{}';\n\n      const expected = '  {\\n-   \"key\": \"value\",\\n  }';\n      const received = diffLinesUnified2(\n        aDisplay.split('\\n'),\n        bDisplay.split('\\n'),\n        aCompare.split('\\n'),\n        bCompare.split('\\n'),\n        optionsBe,\n      );\n\n      expect(received).toBe(expected);\n    });\n  });\n});\n\ndescribe('diffStringsUnified edge cases', () => {\n  test('empty both a and b', () => {\n    const a = '';\n    const b = '';\n\n    expect(diffStringsUnified(a, b, optionsCounts)).toMatchSnapshot();\n  });\n\n  test('empty only a', () => {\n    const a = '';\n    const b = 'one-line string';\n\n    expect(diffStringsUnified(a, b, optionsCounts)).toMatchSnapshot();\n  });\n\n  test('empty only b', () => {\n    const a = 'one-line string';\n    const b = '';\n\n    expect(diffStringsUnified(a, b, optionsCounts)).toMatchSnapshot();\n  });\n\n  test('equal both non-empty', () => {\n    const a = 'one-line string';\n    const b = 'one-line string';\n\n    expect(diffStringsUnified(a, b, optionsCounts)).toMatchSnapshot();\n  });\n\n  test('multiline has no common after clean up chaff', () => {\n    const a = 'delete\\ntwo';\n    const b = 'insert\\n2';\n\n    expect(diffStringsUnified(a, b, optionsCounts)).toMatchSnapshot();\n  });\n\n  test('one-line has no common after clean up chaff', () => {\n    const a = 'delete';\n    const b = 'insert';\n\n    expect(diffStringsUnified(a, b, optionsCounts)).toMatchSnapshot();\n  });\n});\n\ndescribe('options 7980', () => {\n  const a =\n    '`${Ti.App.name} ${Ti.App.version} ${Ti.Platform.name} ${Ti.Platform.version}`';\n  const b =\n    '`${Ti.App.getName()} ${Ti.App.getVersion()} ${Ti.Platform.getName()} ${Ti.Platform.getVersion()}`';\n\n  const options = {\n    aAnnotation: 'Original',\n    aColor: chalk.red,\n    bAnnotation: 'Modified',\n    bColor: chalk.green,\n  };\n\n  test('diff', () => {\n    expect(diff(a, b, options)).toMatchSnapshot();\n  });\n\n  test('diffStringsUnified', () => {\n    expect(diffStringsUnified(a, b, options)).toMatchSnapshot();\n  });\n});\n\ndescribe('options', () => {\n  const a = ['delete', 'change from', 'common'];\n  const b = ['change to', 'insert', 'common'];\n\n  const aString = 'change from\\ncommon'; // without delete\n  const bString = 'change to\\ncommon'; // without insert\n\n  describe('change indicators', () => {\n    const options = {\n      aIndicator: '<',\n      bIndicator: '>',\n    };\n\n    test('diff', () => {\n      expect(diff(a, b, options)).toMatchSnapshot();\n    });\n  });\n\n  describe('change color', () => {\n    const options = {\n      changeColor: chalk.bold,\n      commonColor: chalk.yellow,\n    };\n\n    test('diffStringsUnified', () => {\n      const aChanged = a.join('\\n').replace('change', 'changed');\n      const bChanged = b.join('\\n').replace('change', 'changed');\n      expect(diffStringsUnified(aChanged, bChanged, options)).toMatchSnapshot();\n    });\n\n    test('no diff', () => {\n      expect(diff(a, a, options)).toMatchSnapshot();\n    });\n  });\n\n  describe('common', () => {\n    const options = {\n      commonColor: noColor,\n      commonIndicator: '=',\n    };\n\n    test('diff', () => {\n      expect(diff(a, b, options)).toMatchSnapshot();\n    });\n\n    test('no diff', () => {\n      expect(diff(a, a, options)).toBe(NO_DIFF_MESSAGE);\n    });\n  });\n\n  describe('includeChangeCounts false', () => {\n    const options = {\n      includeChangeCounts: false,\n    };\n\n    test('diffLinesUnified', () => {\n      expect(diff(a, b, options)).toMatchSnapshot();\n    });\n\n    test('diffStringsUnified', () => {\n      expect(diffStringsUnified(aString, bString, options)).toMatchSnapshot();\n    });\n  });\n\n  describe('includeChangeCounts true padding', () => {\n    const options = {\n      aAnnotation: 'Before',\n      bAnnotation: 'After',\n      includeChangeCounts: true,\n    };\n\n    test('diffLinesUnified a has 2 digits', () => {\n      const has2 = 'common\\na\\na\\na\\na\\na\\na\\na\\na\\na\\na';\n      const has1 = 'common\\nb';\n      expect(diff(has2, has1, options)).toMatchSnapshot();\n    });\n\n    test('diffLinesUnified b has 2 digits', () => {\n      const has1 = 'common\\na';\n      const has2 = 'common\\nb\\nb\\nb\\nb\\nb\\nb\\nb\\nb\\nb\\nb';\n      expect(diff(has1, has2, options)).toMatchSnapshot();\n    });\n\n    test('diffStringsUnified', () => {\n      expect(diffStringsUnified(aString, bString, options)).toMatchSnapshot();\n    });\n  });\n\n  describe('omitAnnotationLines true', () => {\n    const options = {\n      omitAnnotationLines: true,\n    };\n\n    test('diff', () => {\n      expect(diff(a, b, options)).toMatchSnapshot();\n    });\n\n    test('diffStringsUnified and includeChangeCounts true', () => {\n      const options2 = {...options, includeChangeCounts: true};\n\n      expect(diffStringsUnified(aString, bString, options2)).toMatchSnapshot();\n    });\n\n    test('diffStringsUnified empty strings', () => {\n      expect(diffStringsUnified('', '', options)).toMatchSnapshot();\n    });\n  });\n\n  describe('trailingSpaceFormatter', () => {\n    const aTrailingSpaces = [\n      'delete 1 trailing space: ',\n      'common 2 trailing spaces:  ',\n      'insert 1 trailing space:',\n    ].join('\\n');\n    const bTrailingSpaces = [\n      'delete 1 trailing space:',\n      'common 2 trailing spaces:  ',\n      'insert 1 trailing space: ',\n    ].join('\\n');\n\n    test('diff default no color', () => {\n      expect(diff(aTrailingSpaces, bTrailingSpaces)).toMatchSnapshot();\n    });\n\n    test('diff middle dot', () => {\n      const replaceSpacesWithMiddleDot = (string: string) =>\n        '·'.repeat(string.length);\n      const options = {\n        changeLineTrailingSpaceColor: replaceSpacesWithMiddleDot,\n        commonLineTrailingSpaceColor: replaceSpacesWithMiddleDot,\n      };\n\n      expect(diff(aTrailingSpaces, bTrailingSpaces, options)).toMatchSnapshot();\n    });\n\n    test('diff yellowish common', () => {\n      const options = {\n        commonLineTrailingSpaceColor: chalk.bgYellow,\n      };\n\n      expect(diff(aTrailingSpaces, bTrailingSpaces, options)).toMatchSnapshot();\n    });\n  });\n\n  describe('emptyFirstOrLastLinePlaceholder default empty string', () => {\n    const options = {\n      ...optionsBe,\n      changeColor: noColor,\n    };\n\n    const aEmpty = '\\ncommon\\nchanged from\\n';\n    const bEmpty = '\\ncommon\\nchanged to\\n';\n\n    const expected = [\n      '',\n      '  common',\n      '- changed from',\n      '+ changed to',\n      '',\n    ].join('\\n');\n\n    test('diff', () => {\n      expect(diff(aEmpty, bEmpty, options)).toBe(expected);\n    });\n\n    test('diffStringsUnified', () => {\n      expect(diffStringsUnified(aEmpty, bEmpty, options)).toBe(expected);\n    });\n  });\n\n  describe('compare keys', () => {\n    const a = {a: {d: 1, e: 1, f: 1}, b: 1, c: 1};\n    const b = {a: {d: 1, e: 2, f: 1}, b: 1, c: 1};\n\n    test('keeps the object keys in their original order', () => {\n      const compareKeys = () => 0;\n      const expected = [\n        '  Object {',\n        '    \"a\": Object {',\n        '      \"d\": 1,',\n        '-     \"e\": 1,',\n        '+     \"e\": 2,',\n        '      \"f\": 1,',\n        '    },',\n        '    \"b\": 1,',\n        '    \"c\": 1,',\n        '  }',\n      ].join('\\n');\n      expect(diff(a, b, {...optionsBe, compareKeys})).toBe(expected);\n    });\n\n    test('sorts the object keys in reverse order', () => {\n      const compareKeys = (a: string, b: string) => (a > b ? -1 : 1);\n      const expected = [\n        '  Object {',\n        '    \"c\": 1,',\n        '    \"b\": 1,',\n        '    \"a\": Object {',\n        '      \"f\": 1,',\n        '-     \"e\": 1,',\n        '+     \"e\": 2,',\n        '      \"d\": 1,',\n        '    },',\n        '  }',\n      ].join('\\n');\n      expect(diff(a, b, {...optionsBe, compareKeys})).toBe(expected);\n    });\n  });\n});\n",
  "packages/jest-diff/src/__tests__/diff.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-create-cache-key-function/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {createHash} from 'crypto';\n// eslint-disable-next-line no-restricted-imports\nimport {readFileSync} from 'fs';\nimport {relative} from 'path';\nimport type {Config} from '@jest/types';\n\ntype OldCacheKeyOptions = {\n  config: Config.ProjectConfig;\n  instrument: boolean;\n};\n\n// Should mirror `import('@jest/transform').TransformOptions`\ntype NewCacheKeyOptions = {\n  config: Config.ProjectConfig;\n  configString: string;\n  instrument: boolean;\n};\n\ntype OldGetCacheKeyFunction = (\n  fileData: string,\n  filePath: string,\n  configStr: string,\n  options: OldCacheKeyOptions,\n) => string;\n\n// Should mirror `import('@jest/transform').Transformer['getCacheKey']`\ntype NewGetCacheKeyFunction = (\n  sourceText: string,\n  sourcePath: string,\n  options: NewCacheKeyOptions,\n) => string;\n\ntype GetCacheKeyFunction = OldGetCacheKeyFunction & NewGetCacheKeyFunction;\n\nconst {NODE_ENV, BABEL_ENV} = process.env;\n\nfunction getGlobalCacheKey(\n  files: Array<string>,\n  values: Array<string>,\n  length: number,\n) {\n  return [\n    NODE_ENV,\n    BABEL_ENV,\n    ...values,\n    ...files.map((file: string) => readFileSync(file)),\n  ]\n    .reduce(\n      (hash, chunk) => hash.update('\\0', 'utf8').update(chunk || ''),\n      createHash('sha1'),\n    )\n    .digest('hex')\n    .slice(0, length);\n}\n\nfunction getCacheKeyFunction(\n  globalCacheKey: string,\n  length: number,\n): GetCacheKeyFunction {\n  return ((sourceText, sourcePath, configString, options) => {\n    // Jest 27 passes a single options bag which contains `configString` rather than as a separate argument.\n    // We can hide that API difference, though, so this module is usable for both jest@<27 and jest@>=27\n    const inferredOptions = options || configString;\n    const {config, instrument} = inferredOptions;\n\n    return createHash('sha1')\n      .update(globalCacheKey)\n      .update('\\0', 'utf8')\n      .update(sourceText)\n      .update('\\0', 'utf8')\n      .update(config.rootDir ? relative(config.rootDir, sourcePath) : '')\n      .update('\\0', 'utf8')\n      .update(instrument ? 'instrument' : '')\n      .digest('hex')\n      .slice(0, length);\n  }) as GetCacheKeyFunction;\n}\n\n/**\n * Returns a function that can be used to generate cache keys based on source code of provided files and provided values.\n *\n * @param files - Array of absolute paths to files whose code should be accounted for when generating cache key\n * @param values - Array of string values that should be accounted for when generating cache key\n * @param length - Length of the resulting key. The default is `32`, or `16` on Windows.\n * @returns A function that can be used to generate cache keys.\n */\nexport default function createCacheKey(\n  files: Array<string> = [],\n  values: Array<string> = [],\n  length = process.platform === 'win32' ? 16 : 32,\n): GetCacheKeyFunction {\n  return getCacheKeyFunction(getGlobalCacheKey(files, values, length), length);\n}\n",
  "packages/jest-create-cache-key-function/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport type { Config } from '@jest/types';\ntype OldCacheKeyOptions = {\n    config: Config.ProjectConfig;\n    instrument: boolean;\n};\ntype NewCacheKeyOptions = {\n    config: Config.ProjectConfig;\n    configString: string;\n    instrument: boolean;\n};\ntype OldGetCacheKeyFunction = (fileData: string, filePath: string, configStr: string, options: OldCacheKeyOptions) => string;\ntype NewGetCacheKeyFunction = (sourceText: string, sourcePath: string, options: NewCacheKeyOptions) => string;\ntype GetCacheKeyFunction = OldGetCacheKeyFunction & NewGetCacheKeyFunction;\n/**\n * Returns a function that can be used to generate cache keys based on source code of provided files and provided values.\n *\n * @param files - Array of absolute paths to files whose code should be accounted for when generating cache key\n * @param values - Array of string values that should be accounted for when generating cache key\n * @param length - Length of the resulting key. The default is `32`, or `16` on Windows.\n * @returns A function that can be used to generate cache keys.\n */\nexport default function createCacheKey(files?: Array<string>, values?: Array<string>, length?: number): GetCacheKeyFunction;\nexport {};\n",
  "packages/jest-create-cache-key-function/src/__tests__/index.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {interopRequireDefault} from 'jest-util';\n\nlet NODE_ENV: string;\nlet BABEL_ENV: string;\n\nbeforeEach(() => {\n  NODE_ENV = process.env.NODE_ENV;\n  process.env.NODE_ENV = 'test';\n  BABEL_ENV = process.env.BABEL_ENV;\n  process.env.BABEL_ENV = 'test';\n  Object.defineProperty(process, 'platform', {\n    value: 'linux',\n  });\n});\n\nafterEach(() => {\n  process.env.NODE_ENV = NODE_ENV;\n  process.env.BABEL_ENV = BABEL_ENV;\n});\n\ntest('creation of a cache key', () => {\n  const createCacheKeyFunction = interopRequireDefault(\n    require('../index'),\n  ).default;\n  const createCacheKey = createCacheKeyFunction([], ['value']);\n  const hashA = createCacheKey('test', 'test.js', null, {\n    config: {},\n    instrument: false,\n  });\n  const hashB = createCacheKey('test code;', 'test.js', null, {\n    config: {},\n    instrument: false,\n  });\n  const hashC = createCacheKey('test', 'test.js', null, {\n    config: {},\n    instrument: true,\n  });\n\n  expect(hashA).toHaveLength(32);\n  expect(hashA).not.toEqual(hashB);\n  expect(hashA).not.toEqual(hashC);\n});\n\ntest('creation of a cache key on win32', () => {\n  Object.defineProperty(process, 'platform', {\n    value: 'win32',\n  });\n  const createCacheKeyFunction = interopRequireDefault(\n    require('../index'),\n  ).default;\n  const createCacheKey = createCacheKeyFunction([], ['value']);\n  const hashA = createCacheKey('test', 'test.js', null, {\n    config: {},\n    instrument: false,\n  });\n\n  expect(hashA).toHaveLength(16);\n});\n",
  "packages/jest-create-cache-key-function/src/__tests__/index.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-core/src/watch.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport type {WriteStream} from 'tty';\nimport ansiEscapes from 'ansi-escapes';\nimport chalk from 'chalk';\nimport exit from 'exit-x';\nimport slash from 'slash';\nimport {TestPathPatterns} from '@jest/pattern';\nimport type {TestContext} from '@jest/test-result';\nimport type {Config} from '@jest/types';\nimport type {IHasteMap as HasteMap} from 'jest-haste-map';\nimport {formatExecError} from 'jest-message-util';\nimport {\n  isInteractive,\n  preRunMessage,\n  requireOrImportModule,\n  specialChars,\n} from 'jest-util';\nimport {ValidationError} from 'jest-validate';\nimport {\n  type AllowedConfigOptions,\n  JestHook,\n  KEYS,\n  TestWatcher,\n  type WatchPlugin,\n  type WatchPluginClass,\n} from 'jest-watcher';\nimport FailedTestsCache from './FailedTestsCache';\nimport SearchSource from './SearchSource';\nimport getChangedFilesPromise from './getChangedFilesPromise';\nimport activeFilters from './lib/activeFiltersMessage';\nimport createContext from './lib/createContext';\nimport isValidPath from './lib/isValidPath';\nimport updateGlobalConfig from './lib/updateGlobalConfig';\nimport {\n  filterInteractivePlugins,\n  getSortedUsageRows,\n} from './lib/watchPluginsHelpers';\nimport FailedTestsInteractivePlugin from './plugins/FailedTestsInteractive';\nimport QuitPlugin from './plugins/Quit';\nimport TestNamePatternPlugin from './plugins/TestNamePattern';\nimport TestPathPatternPlugin from './plugins/TestPathPattern';\nimport UpdateSnapshotsPlugin from './plugins/UpdateSnapshots';\nimport UpdateSnapshotsInteractivePlugin from './plugins/UpdateSnapshotsInteractive';\nimport runJest from './runJest';\nimport type {Filter} from './types';\n\ntype ReservedInfo = {\n  forbiddenOverwriteMessage?: string;\n  key?: string;\n  overwritable: boolean;\n  plugin: WatchPlugin;\n};\n\ntype WatchPluginKeysMap = Map<string, ReservedInfo>;\n\nconst {print: preRunMessagePrint} = preRunMessage;\n\nlet hasExitListener = false;\n\nconst INTERNAL_PLUGINS = [\n  FailedTestsInteractivePlugin,\n  TestPathPatternPlugin,\n  TestNamePatternPlugin,\n  UpdateSnapshotsPlugin,\n  UpdateSnapshotsInteractivePlugin,\n  QuitPlugin,\n];\n\nconst RESERVED_KEY_PLUGINS = new Map<\n  WatchPluginClass,\n  Pick<ReservedInfo, 'forbiddenOverwriteMessage' | 'key'>\n>([\n  [\n    UpdateSnapshotsPlugin,\n    {forbiddenOverwriteMessage: 'updating snapshots', key: 'u'},\n  ],\n  [\n    UpdateSnapshotsInteractivePlugin,\n    {forbiddenOverwriteMessage: 'updating snapshots interactively', key: 'i'},\n  ],\n  [QuitPlugin, {forbiddenOverwriteMessage: 'quitting watch mode'}],\n]);\n\nexport default async function watch(\n  initialGlobalConfig: Config.GlobalConfig,\n  contexts: Array<TestContext>,\n  outputStream: WriteStream,\n  hasteMapInstances: Array<HasteMap>,\n  stdin: NodeJS.ReadStream = process.stdin,\n  hooks: JestHook = new JestHook(),\n  filter?: Filter,\n): Promise<void> {\n  // `globalConfig` will be constantly updated and reassigned as a result of\n  // watch mode interactions.\n  let globalConfig = initialGlobalConfig;\n  let activePlugin: WatchPlugin | null;\n\n  globalConfig = updateGlobalConfig(globalConfig, {\n    mode: globalConfig.watch ? 'watch' : 'watchAll',\n    passWithNoTests: true,\n  });\n\n  const updateConfigAndRun = async ({\n    bail,\n    changedSince,\n    collectCoverage,\n    collectCoverageFrom,\n    coverageDirectory,\n    coverageReporters,\n    findRelatedTests,\n    mode,\n    nonFlagArgs,\n    notify,\n    notifyMode,\n    onlyFailures,\n    reporters,\n    testNamePattern,\n    testPathPatterns,\n    updateSnapshot,\n    verbose,\n  }: AllowedConfigOptions = {}) => {\n    const previousUpdateSnapshot = globalConfig.updateSnapshot;\n    globalConfig = updateGlobalConfig(globalConfig, {\n      bail,\n      changedSince,\n      collectCoverage,\n      collectCoverageFrom,\n      coverageDirectory,\n      coverageReporters,\n      findRelatedTests,\n      mode,\n      nonFlagArgs,\n      notify,\n      notifyMode,\n      onlyFailures,\n      reporters,\n      testNamePattern,\n      testPathPatterns,\n      updateSnapshot,\n      verbose,\n    });\n\n    startRun(globalConfig);\n    globalConfig = updateGlobalConfig(globalConfig, {\n      // updateSnapshot is not sticky after a run.\n      updateSnapshot:\n        previousUpdateSnapshot === 'all' ? 'none' : previousUpdateSnapshot,\n    });\n  };\n\n  const watchPlugins: Array<WatchPlugin> = INTERNAL_PLUGINS.map(\n    InternalPlugin => new InternalPlugin({stdin, stdout: outputStream}),\n  );\n  for (const plugin of watchPlugins) {\n    const hookSubscriber = hooks.getSubscriber();\n    if (plugin.apply) {\n      plugin.apply(hookSubscriber);\n    }\n  }\n\n  if (globalConfig.watchPlugins != null) {\n    const watchPluginKeys: WatchPluginKeysMap = new Map();\n    for (const plugin of watchPlugins) {\n      const reservedInfo: Pick<\n        ReservedInfo,\n        'forbiddenOverwriteMessage' | 'key'\n      > =\n        RESERVED_KEY_PLUGINS.get(plugin.constructor as WatchPluginClass) || {};\n      const key = reservedInfo.key || getPluginKey(plugin, globalConfig);\n      if (!key) {\n        continue;\n      }\n      const {forbiddenOverwriteMessage} = reservedInfo;\n      watchPluginKeys.set(key, {\n        forbiddenOverwriteMessage,\n        overwritable: forbiddenOverwriteMessage == null,\n        plugin,\n      });\n    }\n\n    for (const pluginWithConfig of globalConfig.watchPlugins) {\n      let plugin: WatchPlugin;\n      try {\n        const ThirdPartyPlugin = await requireOrImportModule<WatchPluginClass>(\n          pluginWithConfig.path,\n        );\n        plugin = new ThirdPartyPlugin({\n          config: pluginWithConfig.config,\n          stdin,\n          stdout: outputStream,\n        });\n      } catch (error: any) {\n        const errorWithContext = new Error(\n          `Failed to initialize watch plugin \"${chalk.bold(\n            slash(path.relative(process.cwd(), pluginWithConfig.path)),\n          )}\":\\n\\n${formatExecError(error, contexts[0].config, {\n            noStackTrace: false,\n          })}`,\n        );\n        delete errorWithContext.stack;\n\n        throw errorWithContext;\n      }\n      checkForConflicts(watchPluginKeys, plugin, globalConfig);\n\n      const hookSubscriber = hooks.getSubscriber();\n      if (plugin.apply) {\n        plugin.apply(hookSubscriber);\n      }\n      watchPlugins.push(plugin);\n    }\n  }\n\n  const failedTestsCache = new FailedTestsCache();\n  let searchSources = contexts.map(context => ({\n    context,\n    searchSource: new SearchSource(context),\n  }));\n  let isRunning = false;\n  let testWatcher: TestWatcher;\n  let shouldDisplayWatchUsage = true;\n  let isWatchUsageDisplayed = false;\n\n  const emitFileChange = () => {\n    if (hooks.isUsed('onFileChange')) {\n      const projects = searchSources.map(({context, searchSource}) => ({\n        config: context.config,\n        testPaths: searchSource\n          .findMatchingTests(\n            new TestPathPatterns([]).toExecutor({\n              rootDir: context.config.rootDir,\n            }),\n          )\n          .tests.map(t => t.path),\n      }));\n      hooks.getEmitter().onFileChange({projects});\n    }\n  };\n\n  emitFileChange();\n\n  for (const [index, hasteMapInstance] of hasteMapInstances.entries()) {\n    hasteMapInstance.on('change', ({eventsQueue, hasteFS, moduleMap}) => {\n      const validPaths = eventsQueue.filter(({filePath}) =>\n        isValidPath(globalConfig, filePath),\n      );\n\n      if (validPaths.length > 0) {\n        const context = (contexts[index] = createContext(\n          contexts[index].config,\n          {hasteFS, moduleMap},\n        ));\n\n        activePlugin = null;\n\n        searchSources = [...searchSources];\n        searchSources[index] = {\n          context,\n          searchSource: new SearchSource(context),\n        };\n        emitFileChange();\n        startRun(globalConfig);\n      }\n    });\n  }\n\n  if (!hasExitListener) {\n    hasExitListener = true;\n    process.on('exit', () => {\n      if (activePlugin) {\n        outputStream.write(ansiEscapes.cursorDown());\n        outputStream.write(ansiEscapes.eraseDown);\n      }\n    });\n  }\n\n  const startRun = async (globalConfig: Config.GlobalConfig): Promise<void> => {\n    if (isRunning) {\n      return;\n    }\n\n    testWatcher = new TestWatcher({isWatchMode: true});\n    if (isInteractive) {\n      outputStream.write(specialChars.CLEAR);\n    }\n    preRunMessagePrint(outputStream);\n    isRunning = true;\n    const configs = contexts.map(context => context.config);\n    const changedFilesPromise = getChangedFilesPromise(globalConfig, configs);\n\n    try {\n      await runJest({\n        changedFilesPromise,\n        contexts,\n        failedTestsCache,\n        filter,\n        globalConfig,\n        jestHooks: hooks.getEmitter(),\n        onComplete: results => {\n          isRunning = false;\n          hooks.getEmitter().onTestRunComplete(results);\n\n          // Create a new testWatcher instance so that re-runs won't be blocked.\n          // The old instance that was passed to Jest will still be interrupted\n          // and prevent test runs from the previous run.\n          testWatcher = new TestWatcher({isWatchMode: true});\n\n          // Do not show any Watch Usage related stuff when running in a\n          // non-interactive environment\n          if (isInteractive) {\n            if (shouldDisplayWatchUsage) {\n              outputStream.write(usage(globalConfig, watchPlugins));\n              shouldDisplayWatchUsage = false; // hide Watch Usage after first run\n              isWatchUsageDisplayed = true;\n            } else {\n              outputStream.write(showToggleUsagePrompt());\n              shouldDisplayWatchUsage = false;\n              isWatchUsageDisplayed = false;\n            }\n          } else {\n            outputStream.write('\\n');\n          }\n          failedTestsCache.setTestResults(results.testResults);\n        },\n        outputStream,\n        startRun,\n        testWatcher,\n      });\n    } catch (error) {\n      // Errors thrown inside `runJest`, e.g. by resolvers, are caught here for\n      // continuous watch mode execution. We need to reprint them to the\n      // terminal and give just a little bit of extra space so they fit below\n      // `preRunMessagePrint` message nicely.\n      console.error(\n        `\\n\\n${formatExecError(error as any, contexts[0].config, {\n          noStackTrace: false,\n        })}`,\n      );\n    }\n  };\n\n  const onKeypress = (key: string) => {\n    if (key === KEYS.CONTROL_C || key === KEYS.CONTROL_D) {\n      if (typeof stdin.setRawMode === 'function') {\n        stdin.setRawMode(false);\n      }\n      outputStream.write('\\n');\n      exit(0);\n      return;\n    }\n\n    if (activePlugin != null && activePlugin.onKey) {\n      // if a plugin is activate, Jest should let it handle keystrokes, so ignore\n      // them here\n      activePlugin.onKey(key);\n      return;\n    }\n\n    // Abort test run\n    const pluginKeys = getSortedUsageRows(watchPlugins, globalConfig).map(\n      usage => Number(usage.key).toString(16),\n    );\n    if (\n      isRunning &&\n      testWatcher &&\n      ['q', KEYS.ENTER, 'a', 'o', 'f', ...pluginKeys].includes(key)\n    ) {\n      testWatcher.setState({interrupted: true});\n      return;\n    }\n\n    const matchingWatchPlugin = filterInteractivePlugins(\n      watchPlugins,\n      globalConfig,\n    ).find(plugin => getPluginKey(plugin, globalConfig) === key);\n\n    if (matchingWatchPlugin != null) {\n      if (isRunning) {\n        testWatcher.setState({interrupted: true});\n        return;\n      }\n      // \"activate\" the plugin, which has jest ignore keystrokes so the plugin\n      // can handle them\n      activePlugin = matchingWatchPlugin;\n      if (activePlugin.run) {\n        activePlugin.run(globalConfig, updateConfigAndRun).then(\n          async shouldRerun => {\n            activePlugin = null;\n            if (shouldRerun) {\n              await updateConfigAndRun();\n            }\n          },\n          () => {\n            activePlugin = null;\n            onCancelPatternPrompt();\n          },\n        );\n      } else {\n        activePlugin = null;\n      }\n    }\n\n    switch (key) {\n      case KEYS.ENTER:\n        startRun(globalConfig);\n        break;\n      case 'a':\n        globalConfig = updateGlobalConfig(globalConfig, {\n          mode: 'watchAll',\n          testNamePattern: '',\n          testPathPatterns: [],\n        });\n        startRun(globalConfig);\n        break;\n      case 'c':\n        updateConfigAndRun({\n          mode: 'watch',\n          testNamePattern: '',\n          testPathPatterns: [],\n        });\n        break;\n      case 'f':\n        globalConfig = updateGlobalConfig(globalConfig, {\n          onlyFailures: !globalConfig.onlyFailures,\n        });\n        startRun(globalConfig);\n        break;\n      case 'o':\n        globalConfig = updateGlobalConfig(globalConfig, {\n          mode: 'watch',\n          testNamePattern: '',\n          testPathPatterns: [],\n        });\n        startRun(globalConfig);\n        break;\n      case '?':\n        break;\n      case 'w':\n        if (!shouldDisplayWatchUsage && !isWatchUsageDisplayed) {\n          outputStream.write(ansiEscapes.cursorUp());\n          outputStream.write(ansiEscapes.eraseDown);\n          outputStream.write(usage(globalConfig, watchPlugins));\n          isWatchUsageDisplayed = true;\n          shouldDisplayWatchUsage = false;\n        }\n        break;\n    }\n  };\n\n  const onCancelPatternPrompt = () => {\n    outputStream.write(ansiEscapes.cursorHide);\n    outputStream.write(specialChars.CLEAR);\n    outputStream.write(usage(globalConfig, watchPlugins));\n    outputStream.write(ansiEscapes.cursorShow);\n  };\n\n  if (typeof stdin.setRawMode === 'function') {\n    stdin.setRawMode(true);\n    stdin.resume();\n    stdin.setEncoding('utf8');\n    stdin.on('data', onKeypress);\n  }\n\n  startRun(globalConfig);\n}\n\nconst checkForConflicts = (\n  watchPluginKeys: WatchPluginKeysMap,\n  plugin: WatchPlugin,\n  globalConfig: Config.GlobalConfig,\n) => {\n  const key = getPluginKey(plugin, globalConfig);\n  if (!key) {\n    return;\n  }\n\n  const conflictor = watchPluginKeys.get(key);\n  if (!conflictor || conflictor.overwritable) {\n    watchPluginKeys.set(key, {\n      overwritable: false,\n      plugin,\n    });\n    return;\n  }\n\n  let error;\n  if (conflictor.forbiddenOverwriteMessage) {\n    error = `\n  Watch plugin ${chalk.bold.red(\n    getPluginIdentifier(plugin),\n  )} attempted to register key ${chalk.bold.red(`<${key}>`)},\n  that is reserved internally for ${chalk.bold.red(\n    conflictor.forbiddenOverwriteMessage,\n  )}.\n  Please change the configuration key for this plugin.`.trim();\n  } else {\n    const plugins = [conflictor.plugin, plugin]\n      .map(p => chalk.bold.red(getPluginIdentifier(p)))\n      .join(' and ');\n    error = `\n  Watch plugins ${plugins} both attempted to register key ${chalk.bold.red(\n    `<${key}>`,\n  )}.\n  Please change the key configuration for one of the conflicting plugins to avoid overlap.`.trim();\n  }\n\n  throw new ValidationError('Watch plugin configuration error', error);\n};\n\nconst getPluginIdentifier = (plugin: WatchPlugin) =>\n  // This breaks as `displayName` is not defined as a static, but since\n  // WatchPlugin is an interface, and it is my understanding interface\n  // static fields are not definable anymore, no idea how to circumvent\n  // this :-(\n  // @ts-expect-error: leave `displayName` be.\n  plugin.constructor.displayName || plugin.constructor.name;\n\nconst getPluginKey = (\n  plugin: WatchPlugin,\n  globalConfig: Config.GlobalConfig,\n) => {\n  if (typeof plugin.getUsageInfo === 'function') {\n    return (plugin.getUsageInfo(globalConfig) || {key: null}).key;\n  }\n\n  return null;\n};\n\nconst usage = (\n  globalConfig: Config.GlobalConfig,\n  watchPlugins: Array<WatchPlugin>,\n  delimiter = '\\n',\n) => {\n  const testPathPatterns = globalConfig.testPathPatterns;\n  const messages = [\n    activeFilters(globalConfig),\n\n    testPathPatterns.isSet() || globalConfig.testNamePattern\n      ? `${chalk.dim(' \\u203A Press ')}c${chalk.dim(' to clear filters.')}`\n      : null,\n    `\\n${chalk.bold('Watch Usage')}`,\n\n    globalConfig.watch\n      ? `${chalk.dim(' \\u203A Press ')}a${chalk.dim(' to run all tests.')}`\n      : null,\n\n    globalConfig.onlyFailures\n      ? `${chalk.dim(' \\u203A Press ')}f${chalk.dim(\n          ' to quit \"only failed tests\" mode.',\n        )}`\n      : `${chalk.dim(' \\u203A Press ')}f${chalk.dim(\n          ' to run only failed tests.',\n        )}`,\n\n    (globalConfig.watchAll ||\n      testPathPatterns.isSet() ||\n      globalConfig.testNamePattern) &&\n    !globalConfig.noSCM\n      ? `${chalk.dim(' \\u203A Press ')}o${chalk.dim(\n          ' to only run tests related to changed files.',\n        )}`\n      : null,\n\n    ...getSortedUsageRows(watchPlugins, globalConfig).map(\n      plugin =>\n        `${chalk.dim(' \\u203A Press')} ${plugin.key} ${chalk.dim(\n          `to ${plugin.prompt}.`,\n        )}`,\n    ),\n\n    `${chalk.dim(' \\u203A Press ')}Enter${chalk.dim(\n      ' to trigger a test run.',\n    )}`,\n  ];\n\n  return `${messages.filter(message => !!message).join(delimiter)}\\n`;\n};\n\nconst showToggleUsagePrompt = () =>\n  '\\n' +\n  `${chalk.bold('Watch Usage: ')}${chalk.dim('Press ')}w${chalk.dim(\n    ' to show more.',\n  )}`;\n",
  "packages/jest-core/src/watch.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { WriteStream } from 'tty';\nimport type { TestContext } from '@jest/test-result';\nimport type { Config } from '@jest/types';\nimport type { IHasteMap as HasteMap } from 'jest-haste-map';\nimport { JestHook } from 'jest-watcher';\nimport type { Filter } from './types';\nexport default function watch(initialGlobalConfig: Config.GlobalConfig, contexts: Array<TestContext>, outputStream: WriteStream, hasteMapInstances: Array<HasteMap>, stdin?: NodeJS.ReadStream, hooks?: JestHook, filter?: Filter): Promise<void>;\n",
  "packages/jest-core/src/version.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// Cannot be `import` as it's not under TS root dir\nconst {version: VERSION} = require('../package.json');\n\nexport default function getVersion(): string {\n  return VERSION;\n}\n",
  "packages/jest-core/src/version.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport default function getVersion(): string;\n",
  "packages/jest-core/src/types.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {Test, TestContext} from '@jest/test-result';\n\nexport type Stats = {\n  roots: number;\n  testMatch: number;\n  testPathIgnorePatterns: number;\n  testRegex: number;\n  testPathPatterns?: number;\n};\n\nexport type TestRunData = Array<{\n  context: TestContext;\n  matches: {\n    allTests: number;\n    tests: Array<Test>;\n    total?: number;\n    stats?: Stats;\n  };\n}>;\n\nexport type TestPathCases = Array<{\n  stat: keyof Stats;\n  isMatch: (path: string) => boolean;\n}>;\n\nexport type TestPathCasesWithPathPattern = TestPathCases & {\n  testPathPatterns: (path: string) => boolean;\n};\n\nexport type Filter = (testPaths: Array<string>) => Promise<{\n  filtered: Array<string>;\n}>;\n",
  "packages/jest-core/src/types.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Test, TestContext } from '@jest/test-result';\nexport type Stats = {\n    roots: number;\n    testMatch: number;\n    testPathIgnorePatterns: number;\n    testRegex: number;\n    testPathPatterns?: number;\n};\nexport type TestRunData = Array<{\n    context: TestContext;\n    matches: {\n        allTests: number;\n        tests: Array<Test>;\n        total?: number;\n        stats?: Stats;\n    };\n}>;\nexport type TestPathCases = Array<{\n    stat: keyof Stats;\n    isMatch: (path: string) => boolean;\n}>;\nexport type TestPathCasesWithPathPattern = TestPathCases & {\n    testPathPatterns: (path: string) => boolean;\n};\nexport type Filter = (testPaths: Array<string>) => Promise<{\n    filtered: Array<string>;\n}>;\n",
  "packages/jest-core/src/testSchedulerHelper.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {Test} from '@jest/test-result';\nimport type {Config} from '@jest/types';\n\nconst SLOW_TEST_TIME = 1000;\n\nexport function shouldRunInBand(\n  tests: Array<Test>,\n  timings: Array<number>,\n  {\n    detectOpenHandles,\n    maxWorkers,\n    runInBand,\n    watch,\n    watchAll,\n    workerIdleMemoryLimit,\n  }: Config.GlobalConfig,\n): boolean {\n  // If user asked for run in band, respect that.\n  // detectOpenHandles makes no sense without runInBand, because it cannot detect leaks in workers\n  if (runInBand || detectOpenHandles) {\n    return true;\n  }\n\n  /*\n   * If we are using watch/watchAll mode, don't schedule anything in the main\n   * thread to keep the TTY responsive and to prevent watch mode crashes caused\n   * by leaks (improper test teardown).\n   */\n  if (watch || watchAll) {\n    return false;\n  }\n\n  /*\n   * Otherwise, run in band if we only have one test or one worker available.\n   * Also, if we are confident from previous runs that the tests will finish\n   * quickly we also run in band to reduce the overhead of spawning workers.\n   */\n  const areFastTests = timings.every(timing => timing < SLOW_TEST_TIME);\n  const oneWorkerOrLess = maxWorkers <= 1;\n  const oneTestOrLess = tests.length <= 1;\n\n  return (\n    // When specifying a memory limit, workers should be used\n    workerIdleMemoryLimit === undefined &&\n    (oneWorkerOrLess ||\n      oneTestOrLess ||\n      (tests.length <= 20 && timings.length > 0 && areFastTests))\n  );\n}\n",
  "packages/jest-core/src/testSchedulerHelper.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Test } from '@jest/test-result';\nimport type { Config } from '@jest/types';\nexport declare function shouldRunInBand(tests: Array<Test>, timings: Array<number>, { detectOpenHandles, maxWorkers, runInBand, watch, watchAll, workerIdleMemoryLimit, }: Config.GlobalConfig): boolean;\n",
  "packages/jest-core/src/runJest.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {performance} from 'perf_hooks';\nimport type {WriteStream} from 'tty';\nimport chalk from 'chalk';\nimport exit from 'exit-x';\nimport * as fs from 'graceful-fs';\nimport {CustomConsole} from '@jest/console';\nimport {\n  type AggregatedResult,\n  type Test,\n  type TestContext,\n  type TestResultsProcessor,\n  formatTestResults,\n  makeEmptyAggregatedTestResult,\n} from '@jest/test-result';\nimport type TestSequencer from '@jest/test-sequencer';\nimport type {Config} from '@jest/types';\nimport type {ChangedFiles, ChangedFilesPromise} from 'jest-changed-files';\nimport Resolver from 'jest-resolve';\nimport {requireOrImportModule, tryRealpath} from 'jest-util';\nimport {JestHook, type JestHookEmitter, type TestWatcher} from 'jest-watcher';\nimport type FailedTestsCache from './FailedTestsCache';\nimport SearchSource from './SearchSource';\nimport {type TestSchedulerContext, createTestScheduler} from './TestScheduler';\nimport collectNodeHandles, {\n  type HandleCollectionResult,\n} from './collectHandles';\nimport getNoTestsFoundMessage from './getNoTestsFoundMessage';\nimport serializeToJSON from './lib/serializeToJSON';\nimport runGlobalHook from './runGlobalHook';\nimport type {Filter, TestRunData} from './types';\n\nconst getTestPaths = async (\n  globalConfig: Config.GlobalConfig,\n  projectConfig: Config.ProjectConfig,\n  source: SearchSource,\n  outputStream: WriteStream,\n  changedFiles: ChangedFiles | undefined,\n  jestHooks: JestHookEmitter,\n  filter?: Filter,\n) => {\n  const data = await source.getTestPaths(\n    globalConfig,\n    projectConfig,\n    changedFiles,\n    filter,\n  );\n\n  if (data.tests.length === 0 && globalConfig.onlyChanged && data.noSCM) {\n    new CustomConsole(outputStream, outputStream).log(\n      'Jest can only find uncommitted changed files in a git or hg ' +\n        'repository. If you make your project a git or hg ' +\n        'repository (`git init` or `hg init`), Jest will be able ' +\n        'to only run tests related to files changed since the last ' +\n        'commit.',\n    );\n  }\n\n  const shouldTestArray = await Promise.all(\n    data.tests.map(test =>\n      jestHooks.shouldRunTestSuite({\n        config: test.context.config,\n        duration: test.duration,\n        testPath: test.path,\n      }),\n    ),\n  );\n\n  const filteredTests = data.tests.filter((_test, i) => shouldTestArray[i]);\n\n  return {...data, allTests: filteredTests.length, tests: filteredTests};\n};\n\ntype ProcessResultOptions = Pick<\n  Config.GlobalConfig,\n  'json' | 'outputFile' | 'testResultsProcessor'\n> & {\n  collectHandles?: HandleCollectionResult;\n  onComplete?: (result: AggregatedResult) => void;\n  outputStream: WriteStream;\n};\n\nconst processResults = async (\n  runResults: AggregatedResult,\n  options: ProcessResultOptions,\n) => {\n  const {\n    outputFile,\n    json: isJSON,\n    onComplete,\n    outputStream,\n    testResultsProcessor,\n    collectHandles,\n  } = options;\n\n  if (collectHandles) {\n    runResults.openHandles = await collectHandles();\n  } else {\n    runResults.openHandles = [];\n  }\n\n  if (testResultsProcessor) {\n    const processor =\n      await requireOrImportModule<TestResultsProcessor>(testResultsProcessor);\n    runResults = await processor(runResults);\n  }\n  if (isJSON) {\n    const jsonString = serializeToJSON(formatTestResults(runResults));\n    if (outputFile) {\n      const cwd = tryRealpath(process.cwd());\n      const filePath = path.resolve(cwd, outputFile);\n\n      fs.writeFileSync(filePath, `${jsonString}\\n`);\n      outputStream.write(\n        `Test results written to: ${path.relative(cwd, filePath)}\\n`,\n      );\n    } else {\n      process.stdout.write(`${jsonString}\\n`);\n    }\n  }\n\n  onComplete?.(runResults);\n};\n\nconst testSchedulerContext: TestSchedulerContext = {\n  firstRun: true,\n  previousSuccess: true,\n};\n\nexport default async function runJest({\n  contexts,\n  globalConfig,\n  outputStream,\n  testWatcher,\n  jestHooks = new JestHook().getEmitter(),\n  startRun,\n  changedFilesPromise,\n  onComplete,\n  failedTestsCache,\n  filter,\n}: {\n  globalConfig: Config.GlobalConfig;\n  contexts: Array<TestContext>;\n  outputStream: WriteStream;\n  testWatcher: TestWatcher;\n  jestHooks?: JestHookEmitter;\n  startRun: (globalConfig: Config.GlobalConfig) => void;\n  changedFilesPromise?: ChangedFilesPromise;\n  onComplete: (testResults: AggregatedResult) => void;\n  failedTestsCache?: FailedTestsCache;\n  filter?: Filter;\n}): Promise<void> {\n  // Clear cache for required modules - there might be different resolutions\n  // from Jest's config loading to running the tests\n  Resolver.clearDefaultResolverCache();\n\n  const Sequencer: typeof TestSequencer = await requireOrImportModule(\n    globalConfig.testSequencer,\n  );\n  const sequencer = new Sequencer({contexts, globalConfig});\n  let allTests: Array<Test> = [];\n\n  if (changedFilesPromise && globalConfig.watch) {\n    const {repos} = await changedFilesPromise;\n\n    const noSCM = (\n      Object.keys(repos) as Array<keyof ChangedFiles['repos']>\n    ).every(scm => repos[scm].size === 0);\n    if (noSCM) {\n      process.stderr.write(\n        `\\n${chalk.bold(\n          '--watch',\n        )} is not supported without git/hg, please use --watchAll\\n`,\n      );\n      exit(1);\n    }\n  }\n\n  const searchSources = contexts.map(context => new SearchSource(context));\n\n  performance.mark('jest/getTestPaths:start');\n  const testRunData: TestRunData = await Promise.all(\n    contexts.map(async (context, index) => {\n      const searchSource = searchSources[index];\n      const matches = await getTestPaths(\n        globalConfig,\n        context.config,\n        searchSource,\n        outputStream,\n        changedFilesPromise && (await changedFilesPromise),\n        jestHooks,\n        filter,\n      );\n      allTests = [...allTests, ...matches.tests];\n\n      return {context, matches};\n    }),\n  );\n  performance.mark('jest/getTestPaths:end');\n\n  if (globalConfig.shard) {\n    if (typeof sequencer.shard !== 'function') {\n      throw new TypeError(\n        `Shard ${globalConfig.shard.shardIndex}/${globalConfig.shard.shardCount} requested, but test sequencer ${Sequencer.name} in ${globalConfig.testSequencer} has no shard method.`,\n      );\n    }\n    allTests = await sequencer.shard(allTests, globalConfig.shard);\n  }\n\n  allTests = await sequencer.sort(allTests);\n\n  if (globalConfig.onlyFailures) {\n    if (failedTestsCache) {\n      allTests = failedTestsCache.filterTests(allTests);\n    } else {\n      allTests = await sequencer.allFailedTests(allTests);\n    }\n  }\n\n  if (globalConfig.listTests) {\n    const testsPaths = [...new Set(allTests.map(test => test.path))];\n    let testsListOutput;\n\n    if (globalConfig.json) {\n      testsListOutput = JSON.stringify(testsPaths);\n    } else {\n      testsListOutput = testsPaths.join('\\n');\n    }\n\n    if (globalConfig.outputFile) {\n      const outputFile = path.resolve(process.cwd(), globalConfig.outputFile);\n      fs.writeFileSync(outputFile, testsListOutput, 'utf8');\n    } else {\n      // eslint-disable-next-line no-console\n      console.log(testsListOutput);\n    }\n\n    onComplete?.(makeEmptyAggregatedTestResult());\n    return;\n  }\n\n  const hasTests = allTests.length > 0;\n\n  if (!hasTests) {\n    const {exitWith0, message: noTestsFoundMessage} = getNoTestsFoundMessage(\n      testRunData,\n      globalConfig,\n    );\n\n    if (exitWith0) {\n      new CustomConsole(outputStream, outputStream).log(noTestsFoundMessage);\n    } else {\n      new CustomConsole(outputStream, outputStream).error(noTestsFoundMessage);\n\n      exit(1);\n    }\n  } else if (\n    allTests.length === 1 &&\n    globalConfig.silent !== true &&\n    globalConfig.verbose !== false\n  ) {\n    const newConfig: Config.GlobalConfig = {...globalConfig, verbose: true};\n    globalConfig = Object.freeze(newConfig);\n  }\n\n  let collectHandles;\n\n  if (globalConfig.detectOpenHandles) {\n    collectHandles = collectNodeHandles();\n  }\n\n  if (hasTests) {\n    performance.mark('jest/globalSetup:start');\n    await runGlobalHook({allTests, globalConfig, moduleName: 'globalSetup'});\n    performance.mark('jest/globalSetup:end');\n  }\n\n  if (changedFilesPromise) {\n    const changedFilesInfo = await changedFilesPromise;\n    if (changedFilesInfo.changedFiles) {\n      testSchedulerContext.changedFiles = changedFilesInfo.changedFiles;\n      const relatedFiles = await Promise.all(\n        contexts.map(async (_, index) => {\n          const searchSource = searchSources[index];\n\n          return searchSource.findRelatedSourcesFromTestsInChangedFiles(\n            changedFilesInfo,\n          );\n        }),\n      );\n      const sourcesRelatedToTestsInChangedFilesArray = relatedFiles.flat();\n      testSchedulerContext.sourcesRelatedToTestsInChangedFiles = new Set(\n        sourcesRelatedToTestsInChangedFilesArray,\n      );\n    }\n  }\n\n  const scheduler = await createTestScheduler(globalConfig, {\n    startRun,\n    ...testSchedulerContext,\n  });\n\n  performance.mark('jest/scheduleAndRun:start', {\n    detail: {numTests: allTests.length},\n  });\n  const results = await scheduler.scheduleTests(allTests, testWatcher);\n  performance.mark('jest/scheduleAndRun:end');\n\n  performance.mark('jest/cacheResults:start');\n  sequencer.cacheResults(allTests, results);\n  performance.mark('jest/cacheResults:end');\n\n  if (hasTests) {\n    performance.mark('jest/globalTeardown:start');\n    await runGlobalHook({allTests, globalConfig, moduleName: 'globalTeardown'});\n    performance.mark('jest/globalTeardown:end');\n  }\n\n  performance.mark('jest/processResults:start');\n  await processResults(results, {\n    collectHandles,\n    json: globalConfig.json,\n    onComplete,\n    outputFile: globalConfig.outputFile,\n    outputStream,\n    testResultsProcessor: globalConfig.testResultsProcessor,\n  });\n  performance.mark('jest/processResults:end');\n}\n",
  "packages/jest-core/src/runJest.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { WriteStream } from 'tty';\nimport { type AggregatedResult, type TestContext } from '@jest/test-result';\nimport type { Config } from '@jest/types';\nimport type { ChangedFilesPromise } from 'jest-changed-files';\nimport { type JestHookEmitter, type TestWatcher } from 'jest-watcher';\nimport type FailedTestsCache from './FailedTestsCache';\nimport type { Filter } from './types';\nexport default function runJest({ contexts, globalConfig, outputStream, testWatcher, jestHooks, startRun, changedFilesPromise, onComplete, failedTestsCache, filter, }: {\n    globalConfig: Config.GlobalConfig;\n    contexts: Array<TestContext>;\n    outputStream: WriteStream;\n    testWatcher: TestWatcher;\n    jestHooks?: JestHookEmitter;\n    startRun: (globalConfig: Config.GlobalConfig) => void;\n    changedFilesPromise?: ChangedFilesPromise;\n    onComplete: (testResults: AggregatedResult) => void;\n    failedTestsCache?: FailedTestsCache;\n    filter?: Filter;\n}): Promise<void>;\n",
  "packages/jest-core/src/runGlobalHook.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as util from 'util';\nimport type {Test} from '@jest/test-result';\nimport {createScriptTransformer} from '@jest/transform';\nimport type {Config} from '@jest/types';\nimport prettyFormat from 'pretty-format';\n\nexport default async function runGlobalHook({\n  allTests,\n  globalConfig,\n  moduleName,\n}: {\n  allTests: Array<Test>;\n  globalConfig: Config.GlobalConfig;\n  moduleName: 'globalSetup' | 'globalTeardown';\n}): Promise<void> {\n  const globalModulePaths = new Set(\n    allTests.map(test => test.context.config[moduleName]),\n  );\n\n  if (globalConfig[moduleName]) {\n    globalModulePaths.add(globalConfig[moduleName]);\n  }\n\n  if (globalModulePaths.size > 0) {\n    for (const modulePath of globalModulePaths) {\n      if (!modulePath) {\n        continue;\n      }\n\n      const correctConfig = allTests.find(\n        t => t.context.config[moduleName] === modulePath,\n      );\n\n      const projectConfig = correctConfig\n        ? correctConfig.context.config\n        : // Fallback to first config\n          allTests[0].context.config;\n\n      const transformer = await createScriptTransformer(projectConfig);\n\n      try {\n        await transformer.requireAndTranspileModule(\n          modulePath,\n          async globalModule => {\n            if (typeof globalModule !== 'function') {\n              throw new TypeError(\n                `${moduleName} file must export a function at ${modulePath}`,\n              );\n            }\n\n            await globalModule(globalConfig, projectConfig);\n          },\n        );\n      } catch (error) {\n        if (\n          util.types.isNativeError(error) &&\n          (Object.getOwnPropertyDescriptor(error, 'message')?.writable ||\n            Object.getOwnPropertyDescriptor(\n              Object.getPrototypeOf(error),\n              'message',\n            )?.writable)\n        ) {\n          error.message = `Jest: Got error running ${moduleName} - ${modulePath}, reason: ${error.message}`;\n\n          throw error;\n        }\n\n        throw new Error(\n          `Jest: Got error running ${moduleName} - ${modulePath}, reason: ${prettyFormat(\n            error,\n            {maxDepth: 3},\n          )}`,\n        );\n      }\n    }\n  }\n}\n",
  "packages/jest-core/src/runGlobalHook.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Test } from '@jest/test-result';\nimport type { Config } from '@jest/types';\nexport default function runGlobalHook({ allTests, globalConfig, moduleName, }: {\n    allTests: Array<Test>;\n    globalConfig: Config.GlobalConfig;\n    moduleName: 'globalSetup' | 'globalTeardown';\n}): Promise<void>;\n",
  "packages/jest-core/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nexport {default as SearchSource} from './SearchSource';\nexport {createTestScheduler} from './TestScheduler';\nexport {runCLI} from './cli';\nexport {default as getVersion} from './version';\n",
  "packages/jest-core/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport { default as SearchSource } from './SearchSource';\nexport { createTestScheduler } from './TestScheduler';\nexport { runCLI } from './cli';\nexport { default as getVersion } from './version';\n",
  "packages/jest-core/src/getSelectProjectsMessage.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk from 'chalk';\nimport type {Config} from '@jest/types';\nimport getProjectDisplayName from './getProjectDisplayName';\n\nexport default function getSelectProjectsMessage(\n  projectConfigs: Array<Config.ProjectConfig>,\n  opts: {\n    ignoreProjects: Array<string> | undefined;\n    selectProjects: Array<string> | undefined;\n  },\n): string {\n  if (projectConfigs.length === 0) {\n    return getNoSelectionWarning(opts);\n  }\n  return getProjectsRunningMessage(projectConfigs);\n}\n\nfunction getNoSelectionWarning(opts: {\n  ignoreProjects: Array<string> | undefined;\n  selectProjects: Array<string> | undefined;\n}): string {\n  if (opts.ignoreProjects && opts.selectProjects) {\n    return chalk.yellow(\n      'You provided values for --selectProjects and --ignoreProjects, but no projects were found matching the selection.\\n' +\n        'Are you ignoring all the selected projects?\\n',\n    );\n  } else if (opts.ignoreProjects) {\n    return chalk.yellow(\n      'You provided values for --ignoreProjects, but no projects were found matching the selection.\\n' +\n        'Are you ignoring all projects?\\n',\n    );\n  } else if (opts.selectProjects) {\n    return chalk.yellow(\n      'You provided values for --selectProjects but no projects were found matching the selection.\\n',\n    );\n  } else {\n    return chalk.yellow('No projects were found.\\n');\n  }\n}\n\nfunction getProjectsRunningMessage(\n  projectConfigs: Array<Config.ProjectConfig>,\n): string {\n  if (projectConfigs.length === 1) {\n    const name =\n      getProjectDisplayName(projectConfigs[0]) ?? '<unnamed project>';\n    return `Running one project: ${chalk.bold(name)}\\n`;\n  }\n  const projectsList = projectConfigs\n    .map(getProjectNameListElement)\n    .sort()\n    .join('\\n');\n  return `Running ${projectConfigs.length} projects:\\n${projectsList}\\n`;\n}\n\nfunction getProjectNameListElement(\n  projectConfig: Config.ProjectConfig,\n): string {\n  const name = getProjectDisplayName(projectConfig);\n  const elementContent = name ? chalk.bold(name) : '<unnamed project>';\n  return `- ${elementContent}`;\n}\n",
  "packages/jest-core/src/getSelectProjectsMessage.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config } from '@jest/types';\nexport default function getSelectProjectsMessage(projectConfigs: Array<Config.ProjectConfig>, opts: {\n    ignoreProjects: Array<string> | undefined;\n    selectProjects: Array<string> | undefined;\n}): string;\n",
  "packages/jest-core/src/getProjectNamesMissingWarning.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk from 'chalk';\nimport type {Config} from '@jest/types';\nimport getProjectDisplayName from './getProjectDisplayName';\n\nexport default function getProjectNamesMissingWarning(\n  projectConfigs: Array<Config.ProjectConfig>,\n  opts: {\n    ignoreProjects: Array<string> | undefined;\n    selectProjects: Array<string> | undefined;\n  },\n): string | undefined {\n  const numberOfProjectsWithoutAName = projectConfigs.filter(\n    config => !getProjectDisplayName(config),\n  ).length;\n  if (numberOfProjectsWithoutAName === 0) {\n    return undefined;\n  }\n  const args: Array<string> = [];\n  if (opts.selectProjects) {\n    args.push('--selectProjects');\n  }\n  if (opts.ignoreProjects) {\n    args.push('--ignoreProjects');\n  }\n  return chalk.yellow(\n    `You provided values for ${args.join(' and ')} but ${\n      numberOfProjectsWithoutAName === 1\n        ? 'a project does not have a name'\n        : `${numberOfProjectsWithoutAName} projects do not have a name`\n    }.\\n` +\n      'Set displayName in the config of all projects in order to disable this warning.\\n',\n  );\n}\n",
  "packages/jest-core/src/getProjectNamesMissingWarning.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config } from '@jest/types';\nexport default function getProjectNamesMissingWarning(projectConfigs: Array<Config.ProjectConfig>, opts: {\n    ignoreProjects: Array<string> | undefined;\n    selectProjects: Array<string> | undefined;\n}): string | undefined;\n",
  "packages/jest-core/src/getProjectDisplayName.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {Config} from '@jest/types';\n\nexport default function getProjectDisplayName(\n  projectConfig: Config.ProjectConfig,\n): string | undefined {\n  return projectConfig.displayName?.name || undefined;\n}\n",
  "packages/jest-core/src/getProjectDisplayName.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config } from '@jest/types';\nexport default function getProjectDisplayName(projectConfig: Config.ProjectConfig): string | undefined;\n",
  "packages/jest-core/src/getNoTestsFoundMessage.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {Config} from '@jest/types';\nimport getNoTestFound from './getNoTestFound';\nimport getNoTestFoundFailed from './getNoTestFoundFailed';\nimport getNoTestFoundPassWithNoTests from './getNoTestFoundPassWithNoTests';\nimport getNoTestFoundRelatedToChangedFiles from './getNoTestFoundRelatedToChangedFiles';\nimport getNoTestFoundVerbose from './getNoTestFoundVerbose';\nimport type {TestRunData} from './types';\n\nexport default function getNoTestsFoundMessage(\n  testRunData: TestRunData,\n  globalConfig: Config.GlobalConfig,\n): {exitWith0: boolean; message: string} {\n  const exitWith0 =\n    globalConfig.passWithNoTests ||\n    globalConfig.lastCommit ||\n    globalConfig.onlyChanged;\n\n  if (globalConfig.onlyFailures) {\n    return {exitWith0, message: getNoTestFoundFailed(globalConfig)};\n  }\n  if (globalConfig.onlyChanged) {\n    return {\n      exitWith0,\n      message: getNoTestFoundRelatedToChangedFiles(globalConfig),\n    };\n  }\n  if (globalConfig.passWithNoTests) {\n    return {exitWith0, message: getNoTestFoundPassWithNoTests()};\n  }\n  return {\n    exitWith0,\n    message:\n      testRunData.length === 1 || globalConfig.verbose\n        ? getNoTestFoundVerbose(testRunData, globalConfig, exitWith0)\n        : getNoTestFound(testRunData, globalConfig, exitWith0),\n  };\n}\n",
  "packages/jest-core/src/getNoTestsFoundMessage.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config } from '@jest/types';\nimport type { TestRunData } from './types';\nexport default function getNoTestsFoundMessage(testRunData: TestRunData, globalConfig: Config.GlobalConfig): {\n    exitWith0: boolean;\n    message: string;\n};\n",
  "packages/jest-core/src/getNoTestFoundVerbose.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk from 'chalk';\nimport type {Config} from '@jest/types';\nimport {pluralize} from 'jest-util';\nimport type {Stats, TestRunData} from './types';\n\nexport default function getNoTestFoundVerbose(\n  testRunData: TestRunData,\n  globalConfig: Config.GlobalConfig,\n  willExitWith0: boolean,\n): string {\n  const individualResults = testRunData.map(testRun => {\n    const stats = testRun.matches.stats || ({} as Stats);\n    const config = testRun.context.config;\n    const statsMessage = (Object.keys(stats) as Array<keyof Stats>)\n      .map(key => {\n        if (key === 'roots' && config.roots.length === 1) {\n          return null;\n        }\n        const value = (config as Record<string, unknown>)[key];\n        if (value) {\n          const valueAsString = Array.isArray(value)\n            ? value.join(', ')\n            : String(value);\n          const matches = pluralize('match', stats[key] || 0, 'es');\n          return `  ${key}: ${chalk.yellow(valueAsString)} - ${matches}`;\n        }\n        return null;\n      })\n      .filter(Boolean)\n      .join('\\n');\n\n    return testRun.matches.total\n      ? `In ${chalk.bold(config.rootDir)}\\n` +\n          `  ${pluralize(\n            'file',\n            testRun.matches.total || 0,\n            's',\n          )} checked.\\n${statsMessage}`\n      : `No files found in ${config.rootDir}.\\n` +\n          \"Make sure Jest's configuration does not exclude this directory.\" +\n          '\\nTo set up Jest, make sure a package.json file exists.\\n' +\n          'Jest Documentation: ' +\n          'https://jestjs.io/docs/configuration';\n  });\n  let dataMessage;\n\n  if (globalConfig.runTestsByPath) {\n    dataMessage = `Files: ${globalConfig.nonFlagArgs\n      .map(p => `\"${p}\"`)\n      .join(', ')}`;\n  } else {\n    dataMessage = `Pattern: ${chalk.yellow(\n      globalConfig.testPathPatterns.toPretty(),\n    )} - 0 matches`;\n  }\n\n  if (willExitWith0) {\n    return `${chalk.bold(\n      'No tests found, exiting with code 0',\n    )}\\n${individualResults.join('\\n')}\\n${dataMessage}`;\n  }\n\n  return (\n    `${chalk.bold('No tests found, exiting with code 1')}\\n` +\n    'Run with `--passWithNoTests` to exit with code 0' +\n    `\\n${individualResults.join('\\n')}\\n${dataMessage}`\n  );\n}\n",
  "packages/jest-core/src/getNoTestFoundVerbose.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config } from '@jest/types';\nimport type { TestRunData } from './types';\nexport default function getNoTestFoundVerbose(testRunData: TestRunData, globalConfig: Config.GlobalConfig, willExitWith0: boolean): string;\n",
  "packages/jest-core/src/getNoTestFoundRelatedToChangedFiles.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk from 'chalk';\nimport type {Config} from '@jest/types';\nimport {isInteractive} from 'jest-util';\n\nexport default function getNoTestFoundRelatedToChangedFiles(\n  globalConfig: Config.GlobalConfig,\n): string {\n  const ref = globalConfig.changedSince\n    ? `\"${globalConfig.changedSince}\"`\n    : 'last commit';\n  let msg = chalk.bold(`No tests found related to files changed since ${ref}.`);\n\n  if (isInteractive) {\n    msg += chalk.dim(\n      `\\n${\n        globalConfig.watch\n          ? 'Press `a` to run all tests, or run Jest with `--watchAll`.'\n          : 'Run Jest without `-o` or with `--all` to run all tests.'\n      }`,\n    );\n  }\n\n  return msg;\n}\n",
  "packages/jest-core/src/getNoTestFoundRelatedToChangedFiles.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config } from '@jest/types';\nexport default function getNoTestFoundRelatedToChangedFiles(globalConfig: Config.GlobalConfig): string;\n",
  "packages/jest-core/src/getNoTestFoundPassWithNoTests.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk from 'chalk';\n\nexport default function getNoTestFoundPassWithNoTests(): string {\n  return chalk.bold('No tests found, exiting with code 0');\n}\n",
  "packages/jest-core/src/getNoTestFoundPassWithNoTests.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport default function getNoTestFoundPassWithNoTests(): string;\n",
  "packages/jest-core/src/getNoTestFoundFailed.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk from 'chalk';\nimport type {Config} from '@jest/types';\nimport {isInteractive} from 'jest-util';\n\nexport default function getNoTestFoundFailed(\n  globalConfig: Config.GlobalConfig,\n): string {\n  let msg = chalk.bold('No failed test found.');\n  if (isInteractive) {\n    msg += chalk.dim(\n      `\\n${\n        globalConfig.watch\n          ? 'Press `f` to quit \"only failed tests\" mode.'\n          : 'Run Jest without `--onlyFailures` or with `--all` to run all tests.'\n      }`,\n    );\n  }\n  return msg;\n}\n",
  "packages/jest-core/src/getNoTestFoundFailed.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config } from '@jest/types';\nexport default function getNoTestFoundFailed(globalConfig: Config.GlobalConfig): string;\n",
  "packages/jest-core/src/getNoTestFound.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk from 'chalk';\nimport type {Config} from '@jest/types';\nimport {pluralize} from 'jest-util';\nimport type {TestRunData} from './types';\n\nexport default function getNoTestFound(\n  testRunData: TestRunData,\n  globalConfig: Config.GlobalConfig,\n  willExitWith0: boolean,\n): string {\n  const testFiles = testRunData.reduce(\n    (current, testRun) => current + (testRun.matches.total || 0),\n    0,\n  );\n  let dataMessage;\n\n  if (globalConfig.runTestsByPath) {\n    dataMessage = `Files: ${globalConfig.nonFlagArgs\n      .map(p => `\"${p}\"`)\n      .join(', ')}`;\n  } else {\n    dataMessage = `Pattern: ${chalk.yellow(\n      globalConfig.testPathPatterns.toPretty(),\n    )} - 0 matches`;\n  }\n\n  if (willExitWith0) {\n    return (\n      `${chalk.bold('No tests found, exiting with code 0')}\\n` +\n      `In ${chalk.bold(globalConfig.rootDir)}` +\n      '\\n' +\n      `  ${pluralize('file', testFiles, 's')} checked across ${pluralize(\n        'project',\n        testRunData.length,\n        's',\n      )}. Run with \\`--verbose\\` for more details.` +\n      `\\n${dataMessage}`\n    );\n  }\n\n  return (\n    `${chalk.bold('No tests found, exiting with code 1')}\\n` +\n    'Run with `--passWithNoTests` to exit with code 0' +\n    '\\n' +\n    `In ${chalk.bold(globalConfig.rootDir)}` +\n    '\\n' +\n    `  ${pluralize('file', testFiles, 's')} checked across ${pluralize(\n      'project',\n      testRunData.length,\n      's',\n    )}. Run with \\`--verbose\\` for more details.` +\n    `\\n${dataMessage}`\n  );\n}\n",
  "packages/jest-core/src/getNoTestFound.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config } from '@jest/types';\nimport type { TestRunData } from './types';\nexport default function getNoTestFound(testRunData: TestRunData, globalConfig: Config.GlobalConfig, willExitWith0: boolean): string;\n",
  "packages/jest-core/src/getConfigsOfProjectsToRun.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {Config} from '@jest/types';\nimport getProjectDisplayName from './getProjectDisplayName';\n\nexport default function getConfigsOfProjectsToRun(\n  projectConfigs: Array<Config.ProjectConfig>,\n  opts: {\n    ignoreProjects: Array<string> | undefined;\n    selectProjects: Array<string> | undefined;\n  },\n): Array<Config.ProjectConfig> {\n  const projectFilter = createProjectFilter(opts);\n  return projectConfigs.filter(config => {\n    const name = getProjectDisplayName(config);\n    return projectFilter(name);\n  });\n}\n\nconst always = () => true;\n\nfunction createProjectFilter(opts: {\n  ignoreProjects: Array<string> | undefined;\n  selectProjects: Array<string> | undefined;\n}) {\n  const {selectProjects, ignoreProjects} = opts;\n\n  const selected = selectProjects\n    ? (name: string | undefined) => name && selectProjects.includes(name)\n    : always;\n\n  const notIgnore = ignoreProjects\n    ? (name: string | undefined) => !(name && ignoreProjects.includes(name))\n    : always;\n\n  function test(name: string | undefined) {\n    return selected(name) && notIgnore(name);\n  }\n\n  return test;\n}\n",
  "packages/jest-core/src/getConfigsOfProjectsToRun.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config } from '@jest/types';\nexport default function getConfigsOfProjectsToRun(projectConfigs: Array<Config.ProjectConfig>, opts: {\n    ignoreProjects: Array<string> | undefined;\n    selectProjects: Array<string> | undefined;\n}): Array<Config.ProjectConfig>;\n",
  "packages/jest-core/src/getChangedFilesPromise.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk from 'chalk';\nimport type {Config} from '@jest/types';\nimport {\n  type ChangedFilesPromise,\n  getChangedFilesForRoots,\n} from 'jest-changed-files';\nimport {formatExecError} from 'jest-message-util';\n\nexport default function getChangedFilesPromise(\n  globalConfig: Config.GlobalConfig,\n  configs: Array<Config.ProjectConfig>,\n): ChangedFilesPromise | undefined {\n  if (globalConfig.onlyChanged) {\n    const allRootsForAllProjects = new Set(\n      configs.flatMap(config => config.roots || []),\n    );\n    return getChangedFilesForRoots([...allRootsForAllProjects], {\n      changedSince: globalConfig.changedSince,\n      lastCommit: globalConfig.lastCommit,\n      withAncestor: globalConfig.changedFilesWithAncestor,\n    }).catch(error => {\n      const message = formatExecError(error, configs[0], {noStackTrace: true})\n        .split('\\n')\n        .filter(line => !line.includes('Command failed:'))\n        .join('\\n');\n\n      console.error(chalk.red(`\\n\\n${message}`));\n\n      process.exit(1);\n    });\n  }\n\n  return undefined;\n}\n",
  "packages/jest-core/src/getChangedFilesPromise.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config } from '@jest/types';\nimport { type ChangedFilesPromise } from 'jest-changed-files';\nexport default function getChangedFilesPromise(globalConfig: Config.GlobalConfig, configs: Array<Config.ProjectConfig>): ChangedFilesPromise | undefined;\n",
  "packages/jest-core/src/collectHandles.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as asyncHooks from 'async_hooks';\nimport {promisify, stripVTControlCharacters as stripAnsi} from 'util';\nimport * as v8 from 'v8';\nimport * as vm from 'vm';\nimport type {Config} from '@jest/types';\nimport {formatExecError} from 'jest-message-util';\nimport {ErrorWithStack} from 'jest-util';\n\nexport type HandleCollectionResult = () => Promise<Array<Error>>;\n\nfunction stackIsFromUser(stack: string) {\n  // Either the test file, or something required by it\n  if (stack.includes('Runtime.requireModule')) {\n    return true;\n  }\n\n  // jest-jasmine it or describe call\n  if (stack.includes('asyncJestTest') || stack.includes('asyncJestLifecycle')) {\n    return true;\n  }\n\n  // An async function call from within circus\n  if (stack.includes('callAsyncCircusFn')) {\n    // jest-circus it or describe call\n    return (\n      stack.includes('_callCircusTest') || stack.includes('_callCircusHook')\n    );\n  }\n\n  return false;\n}\n\nconst alwaysActive = () => true;\n\nconst hasWeakRef = typeof WeakRef === 'function';\n\nconst asyncSleep = promisify(setTimeout);\n\nlet gcFunc: (() => void) | undefined = (globalThis as any).gc;\nfunction runGC() {\n  if (!gcFunc) {\n    v8.setFlagsFromString('--expose-gc');\n    gcFunc = vm.runInNewContext('gc');\n    v8.setFlagsFromString('--no-expose-gc');\n    if (!gcFunc) {\n      throw new Error(\n        'Cannot find `global.gc` function. Please run node with `--expose-gc` and report this issue in jest repo.',\n      );\n    }\n  }\n\n  gcFunc();\n}\n\n// Inspired by https://github.com/mafintosh/why-is-node-running/blob/master/index.js\n// Extracted as we want to format the result ourselves\nexport default function collectHandles(): HandleCollectionResult {\n  const activeHandles = new Map<\n    number,\n    {error: Error; isActive: () => boolean}\n  >();\n  const hook = asyncHooks.createHook({\n    destroy(asyncId) {\n      activeHandles.delete(asyncId);\n    },\n    init: function initHook(\n      asyncId,\n      type,\n      triggerAsyncId,\n      // eslint-disable-next-line @typescript-eslint/no-empty-object-type\n      resource: {} | NodeJS.Timeout,\n    ) {\n      // Skip resources that should not generally prevent the process from\n      // exiting, not last a meaningfully long time, or otherwise shouldn't be\n      // tracked.\n      if (\n        [\n          'PROMISE',\n          'TIMERWRAP',\n          'ELDHISTOGRAM',\n          'PerformanceObserver',\n          'RANDOMBYTESREQUEST',\n          'DNSCHANNEL',\n          'ZLIB',\n          'SIGNREQUEST',\n          'TLSWRAP',\n          'TCPWRAP',\n        ].includes(type)\n      ) {\n        return;\n      }\n      const error = new ErrorWithStack(type, initHook, 100);\n      let fromUser = stackIsFromUser(error.stack || '');\n\n      // If the async resource was not directly created by user code, but was\n      // triggered by another async resource from user code, track it and use\n      // the original triggering resource's stack.\n      if (!fromUser) {\n        const triggeringHandle = activeHandles.get(triggerAsyncId);\n        if (triggeringHandle) {\n          fromUser = true;\n          error.stack = triggeringHandle.error.stack;\n        }\n      }\n\n      if (fromUser) {\n        let isActive: () => boolean;\n\n        // Handle that supports hasRef\n        if ('hasRef' in resource) {\n          if (hasWeakRef) {\n            const ref = new WeakRef(resource);\n            isActive = () => {\n              return ref.deref()?.hasRef() ?? false;\n            };\n          } else {\n            isActive = resource.hasRef.bind(resource);\n          }\n        } else {\n          // Handle that doesn't support hasRef\n          isActive = alwaysActive;\n        }\n\n        activeHandles.set(asyncId, {error, isActive});\n      }\n    },\n  });\n\n  hook.enable();\n\n  return async () => {\n    // Wait briefly for any async resources that have been queued for\n    // destruction to actually be destroyed.\n    // For example, Node.js TCP Servers are not destroyed until *after* their\n    // `close` callback runs. If someone finishes a test from the `close`\n    // callback, we will not yet have seen the resource be destroyed here.\n    await asyncSleep(0);\n\n    if (activeHandles.size > 0) {\n      await asyncSleep(30);\n\n      if (activeHandles.size > 0) {\n        runGC();\n\n        await asyncSleep(0);\n      }\n    }\n\n    hook.disable();\n\n    // Get errors for every async resource still referenced at this moment\n    const result = [...activeHandles.values()]\n      .filter(({isActive}) => isActive())\n      .map(({error}) => error);\n\n    activeHandles.clear();\n    return result;\n  };\n}\n\nexport function formatHandleErrors(\n  errors: Array<Error>,\n  config: Config.ProjectConfig,\n): Array<string> {\n  const stacks = new Map<string, {stack: string; names: Set<string>}>();\n\n  for (const err of errors) {\n    const formatted = formatExecError(\n      err,\n      config,\n      {noStackTrace: false},\n      undefined,\n      true,\n    );\n\n    // E.g. timeouts might give multiple traces to the same line of code\n    // This hairy filtering tries to remove entries with duplicate stack traces\n\n    const ansiFree: string = stripAnsi(formatted);\n    const match = ansiFree.match(/\\s+at(.*)/);\n    if (!match || match.length < 2) {\n      continue;\n    }\n\n    const stackText = ansiFree.slice(ansiFree.indexOf(match[1])).trim();\n\n    const name = ansiFree.match(/(?<=● {2}).*$/m);\n    if (name == null || name.length === 0) {\n      continue;\n    }\n\n    const stack = stacks.get(stackText) || {\n      names: new Set(),\n      stack: formatted.replace(name[0], '%%OBJECT_NAME%%'),\n    };\n\n    stack.names.add(name[0]);\n\n    stacks.set(stackText, stack);\n  }\n\n  return [...stacks.values()].map(({stack, names}) =>\n    stack.replace('%%OBJECT_NAME%%', [...names].join(',')),\n  );\n}\n",
  "packages/jest-core/src/collectHandles.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config } from '@jest/types';\nexport type HandleCollectionResult = () => Promise<Array<Error>>;\nexport default function collectHandles(): HandleCollectionResult;\nexport declare function formatHandleErrors(errors: Array<Error>, config: Config.ProjectConfig): Array<string>;\n",
  "packages/jest-core/src/TestScheduler.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk from 'chalk';\nimport {GITHUB_ACTIONS} from 'ci-info';\nimport exit from 'exit-x';\nimport {\n  CoverageReporter,\n  DefaultReporter,\n  GitHubActionsReporter,\n  type BaseReporter as JestReporter,\n  NotifyReporter,\n  type Reporter,\n  type ReporterContext,\n  SummaryReporter,\n  type SummaryReporterOptions,\n  VerboseReporter,\n} from '@jest/reporters';\nimport {\n  type AggregatedResult,\n  type SerializableError,\n  type Test,\n  type TestContext,\n  type TestResult,\n  addResult,\n  buildFailureTestResult,\n  makeEmptyAggregatedTestResult,\n} from '@jest/test-result';\nimport {createScriptTransformer} from '@jest/transform';\nimport type {Config} from '@jest/types';\nimport {formatExecError, separateMessageFromStack} from 'jest-message-util';\nimport type {JestTestRunner, TestRunnerContext} from 'jest-runner';\nimport {\n  buildSnapshotResolver,\n  cleanup as cleanupSnapshots,\n} from 'jest-snapshot';\nimport {ErrorWithStack, invariant, requireOrImportModule} from 'jest-util';\nimport type {TestWatcher} from 'jest-watcher';\nimport ReporterDispatcher from './ReporterDispatcher';\nimport {shouldRunInBand} from './testSchedulerHelper';\n\nexport type ReporterConstructor = new (\n  globalConfig: Config.GlobalConfig,\n  reporterConfig: Record<string, unknown>,\n  reporterContext: ReporterContext,\n) => JestReporter;\n\ntype TestRunnerConstructor = new (\n  globalConfig: Config.GlobalConfig,\n  testRunnerContext: TestRunnerContext,\n) => JestTestRunner;\n\nexport type TestSchedulerContext = ReporterContext & TestRunnerContext;\n\nexport async function createTestScheduler(\n  globalConfig: Config.GlobalConfig,\n  context: TestSchedulerContext,\n): Promise<TestScheduler> {\n  const scheduler = new TestScheduler(globalConfig, context);\n\n  await scheduler._setupReporters();\n\n  return scheduler;\n}\n\nclass TestScheduler {\n  private readonly _context: TestSchedulerContext;\n  private readonly _dispatcher: ReporterDispatcher;\n  private readonly _globalConfig: Config.GlobalConfig;\n\n  constructor(\n    globalConfig: Config.GlobalConfig,\n    context: TestSchedulerContext,\n  ) {\n    this._context = context;\n    this._dispatcher = new ReporterDispatcher();\n    this._globalConfig = globalConfig;\n  }\n\n  addReporter(reporter: Reporter): void {\n    this._dispatcher.register(reporter);\n  }\n\n  removeReporter(reporterConstructor: ReporterConstructor): void {\n    this._dispatcher.unregister(reporterConstructor);\n  }\n\n  async scheduleTests(\n    tests: Array<Test>,\n    watcher: TestWatcher,\n  ): Promise<AggregatedResult> {\n    const onTestFileStart = this._dispatcher.onTestFileStart.bind(\n      this._dispatcher,\n    );\n    const timings: Array<number> = [];\n    const testContexts = new Set<TestContext>();\n    for (const test of tests) {\n      testContexts.add(test.context);\n      if (test.duration) {\n        timings.push(test.duration);\n      }\n    }\n\n    const aggregatedResults = createAggregatedResults(tests.length);\n    const estimatedTime = Math.ceil(\n      getEstimatedTime(timings, this._globalConfig.maxWorkers) / 1000,\n    );\n\n    const runInBand = shouldRunInBand(tests, timings, this._globalConfig);\n\n    const onResult = async (test: Test, testResult: TestResult) => {\n      if (watcher.isInterrupted()) {\n        return;\n      }\n\n      if (testResult.testResults.length === 0) {\n        const message = 'Your test suite must contain at least one test.';\n\n        return onFailure(test, {\n          message,\n          stack: new Error(message).stack,\n        });\n      }\n\n      // Throws when the context is leaked after executing a test.\n      if (testResult.leaks) {\n        const message =\n          `${chalk.red.bold(\n            'EXPERIMENTAL FEATURE!\\n',\n          )}Your test suite is leaking memory. Please ensure all references are cleaned.\\n` +\n          '\\n' +\n          'There is a number of things that can leak memory:\\n' +\n          '  - Async operations that have not finished (e.g. fs.readFile).\\n' +\n          '  - Timers not properly mocked (e.g. setInterval, setTimeout).\\n' +\n          '  - Keeping references to the global scope.';\n\n        return onFailure(test, {\n          message,\n          stack: new Error(message).stack,\n        });\n      }\n\n      addResult(aggregatedResults, testResult);\n      await this._dispatcher.onTestFileResult(\n        test,\n        testResult,\n        aggregatedResults,\n      );\n      return this._bailIfNeeded(testContexts, aggregatedResults, watcher);\n    };\n\n    const onFailure = async (test: Test, error: SerializableError) => {\n      if (watcher.isInterrupted()) {\n        return;\n      }\n      const testResult = buildFailureTestResult(test.path, error);\n      testResult.failureMessage = formatExecError(\n        testResult.testExecError,\n        test.context.config,\n        this._globalConfig,\n        test.path,\n      );\n      addResult(aggregatedResults, testResult);\n      await this._dispatcher.onTestFileResult(\n        test,\n        testResult,\n        aggregatedResults,\n      );\n    };\n\n    const updateSnapshotState = async () => {\n      const contextsWithSnapshotResolvers = await Promise.all(\n        [...testContexts].map(\n          async context =>\n            [context, await buildSnapshotResolver(context.config)] as const,\n        ),\n      );\n\n      for (const [context, snapshotResolver] of contextsWithSnapshotResolvers) {\n        const status = cleanupSnapshots(\n          context.hasteFS,\n          this._globalConfig.updateSnapshot,\n          snapshotResolver,\n          context.config.testPathIgnorePatterns,\n        );\n\n        aggregatedResults.snapshot.filesRemoved += status.filesRemoved;\n        aggregatedResults.snapshot.filesRemovedList = [\n          ...(aggregatedResults.snapshot.filesRemovedList || []),\n          ...status.filesRemovedList,\n        ];\n      }\n      const updateAll = this._globalConfig.updateSnapshot === 'all';\n      aggregatedResults.snapshot.didUpdate = updateAll;\n      aggregatedResults.snapshot.failure = !!(\n        !updateAll &&\n        (aggregatedResults.snapshot.unchecked ||\n          aggregatedResults.snapshot.unmatched ||\n          aggregatedResults.snapshot.filesRemoved)\n      );\n    };\n\n    await this._dispatcher.onRunStart(aggregatedResults, {\n      estimatedTime,\n      showStatus: !runInBand,\n    });\n\n    const testRunners: Record<string, JestTestRunner> = Object.create(null);\n    const contextsByTestRunner = new WeakMap<JestTestRunner, TestContext>();\n\n    try {\n      await Promise.all(\n        [...testContexts].map(async context => {\n          const {config} = context;\n          if (!testRunners[config.runner]) {\n            const transformer = await createScriptTransformer(config);\n            const Runner: TestRunnerConstructor =\n              await transformer.requireAndTranspileModule(config.runner);\n            const runner = new Runner(this._globalConfig, {\n              changedFiles: this._context.changedFiles,\n              sourcesRelatedToTestsInChangedFiles:\n                this._context.sourcesRelatedToTestsInChangedFiles,\n            });\n            testRunners[config.runner] = runner;\n            contextsByTestRunner.set(runner, context);\n          }\n        }),\n      );\n\n      const testsByRunner = this._partitionTests(testRunners, tests);\n\n      if (testsByRunner) {\n        try {\n          for (const runner of Object.keys(testRunners)) {\n            const testRunner = testRunners[runner];\n            const context = contextsByTestRunner.get(testRunner);\n\n            invariant(context);\n\n            const tests = testsByRunner[runner];\n\n            const testRunnerOptions = {\n              serial: runInBand || Boolean(testRunner.isSerial),\n            };\n\n            if (testRunner.supportsEventEmitters) {\n              const unsubscribes = [\n                testRunner.on('test-file-start', ([test]) =>\n                  onTestFileStart(test),\n                ),\n                testRunner.on('test-file-success', ([test, testResult]) =>\n                  onResult(test, testResult),\n                ),\n                testRunner.on('test-file-failure', ([test, error]) =>\n                  onFailure(test, error),\n                ),\n                testRunner.on(\n                  'test-case-start',\n                  ([testPath, testCaseStartInfo]) => {\n                    const test: Test = {context, path: testPath};\n                    this._dispatcher.onTestCaseStart(test, testCaseStartInfo);\n                  },\n                ),\n                testRunner.on(\n                  'test-case-result',\n                  ([testPath, testCaseResult]) => {\n                    const test: Test = {context, path: testPath};\n                    this._dispatcher.onTestCaseResult(test, testCaseResult);\n                  },\n                ),\n              ];\n\n              await testRunner.runTests(tests, watcher, testRunnerOptions);\n\n              for (const sub of unsubscribes) sub();\n            } else {\n              await testRunner.runTests(\n                tests,\n                watcher,\n                onTestFileStart,\n                onResult,\n                onFailure,\n                testRunnerOptions,\n              );\n            }\n          }\n        } catch (error) {\n          if (!watcher.isInterrupted()) {\n            throw error;\n          }\n        }\n      }\n    } catch (error) {\n      aggregatedResults.runExecError = buildExecError(error);\n      await this._dispatcher.onRunComplete(testContexts, aggregatedResults);\n      throw error;\n    }\n\n    await updateSnapshotState();\n    aggregatedResults.wasInterrupted = watcher.isInterrupted();\n    await this._dispatcher.onRunComplete(testContexts, aggregatedResults);\n\n    const anyTestFailures = !(\n      aggregatedResults.numFailedTests === 0 &&\n      aggregatedResults.numRuntimeErrorTestSuites === 0\n    );\n    const anyReporterErrors = this._dispatcher.hasErrors();\n\n    aggregatedResults.success = !(\n      anyTestFailures ||\n      aggregatedResults.snapshot.failure ||\n      anyReporterErrors\n    );\n\n    return aggregatedResults;\n  }\n\n  private _partitionTests(\n    testRunners: Record<string, JestTestRunner>,\n    tests: Array<Test>,\n  ): Record<string, Array<Test>> | null {\n    if (Object.keys(testRunners).length > 1) {\n      return tests.reduce((testRuns, test) => {\n        const runner = test.context.config.runner;\n        if (!testRuns[runner]) {\n          testRuns[runner] = [];\n        }\n        testRuns[runner].push(test);\n        return testRuns;\n      }, Object.create(null));\n    } else if (tests.length > 0 && tests[0] != null) {\n      // If there is only one runner, don't partition the tests.\n      return Object.assign(Object.create(null), {\n        [tests[0].context.config.runner]: tests,\n      });\n    } else {\n      return null;\n    }\n  }\n\n  async _setupReporters() {\n    const {collectCoverage: coverage, notify, verbose} = this._globalConfig;\n    const reporters = this._globalConfig.reporters || [['default', {}]];\n    let summaryOptions: SummaryReporterOptions | null = null;\n\n    for (const [reporter, options] of reporters) {\n      switch (reporter) {\n        case 'default':\n          summaryOptions = options;\n          this.addReporter(\n            verbose\n              ? new VerboseReporter(this._globalConfig)\n              : new DefaultReporter(this._globalConfig),\n          );\n          break;\n        case 'github-actions':\n          if (GITHUB_ACTIONS) {\n            this.addReporter(\n              new GitHubActionsReporter(this._globalConfig, options),\n            );\n          }\n          break;\n        case 'summary':\n          summaryOptions = options;\n          break;\n        default:\n          await this._addCustomReporter(reporter, options);\n      }\n    }\n\n    if (notify) {\n      this.addReporter(new NotifyReporter(this._globalConfig, this._context));\n    }\n\n    if (coverage) {\n      this.addReporter(new CoverageReporter(this._globalConfig, this._context));\n    }\n\n    if (summaryOptions != null) {\n      this.addReporter(new SummaryReporter(this._globalConfig, summaryOptions));\n    }\n  }\n\n  private async _addCustomReporter(\n    reporter: string,\n    options: Record<string, unknown>,\n  ) {\n    try {\n      const Reporter: ReporterConstructor =\n        await requireOrImportModule(reporter);\n\n      this.addReporter(\n        new Reporter(this._globalConfig, options, this._context),\n      );\n    } catch (error: any) {\n      error.message = `An error occurred while adding the reporter at path \"${chalk.bold(\n        reporter,\n      )}\".\\n${error instanceof Error ? error.message : ''}`;\n      throw error;\n    }\n  }\n\n  private async _bailIfNeeded(\n    testContexts: Set<TestContext>,\n    aggregatedResults: AggregatedResult,\n    watcher: TestWatcher,\n  ): Promise<void> {\n    if (\n      this._globalConfig.bail !== 0 &&\n      aggregatedResults.numFailedTests >= this._globalConfig.bail\n    ) {\n      if (watcher.isWatchMode()) {\n        await watcher.setState({interrupted: true});\n        return;\n      }\n\n      try {\n        await this._dispatcher.onRunComplete(testContexts, aggregatedResults);\n      } finally {\n        const exitCode = this._globalConfig.testFailureExitCode;\n        exit(exitCode);\n      }\n    }\n  }\n}\n\nconst createAggregatedResults = (numTotalTestSuites: number) => {\n  const result = makeEmptyAggregatedTestResult();\n  result.numTotalTestSuites = numTotalTestSuites;\n  result.startTime = Date.now();\n  result.success = false;\n  return result;\n};\n\nconst getEstimatedTime = (timings: Array<number>, workers: number) => {\n  if (timings.length === 0) {\n    return 0;\n  }\n\n  const max = Math.max(...timings);\n  return timings.length <= workers\n    ? max\n    : Math.max(timings.reduce((sum, time) => sum + time) / workers, max);\n};\n\nconst strToError = (errString: string): SerializableError => {\n  const {message, stack} = separateMessageFromStack(errString);\n  if (stack.length > 0) {\n    return {message, stack};\n  }\n  const error = new ErrorWithStack(message, buildExecError);\n  return {message, stack: error.stack || ''};\n};\n\nconst buildExecError = (err: unknown): SerializableError => {\n  if (typeof err === 'string' || err == null) {\n    return strToError(err || 'Error');\n  }\n  const anyErr = err as any;\n  if (typeof anyErr.message === 'string') {\n    if (typeof anyErr.stack === 'string' && anyErr.stack.length > 0) {\n      return anyErr;\n    }\n    return strToError(anyErr.message);\n  }\n  return strToError(JSON.stringify(err));\n};\n",
  "packages/jest-core/src/TestScheduler.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { type BaseReporter as JestReporter, type Reporter, type ReporterContext } from '@jest/reporters';\nimport { type AggregatedResult, type Test } from '@jest/test-result';\nimport type { Config } from '@jest/types';\nimport type { TestRunnerContext } from 'jest-runner';\nimport type { TestWatcher } from 'jest-watcher';\nexport type ReporterConstructor = new (globalConfig: Config.GlobalConfig, reporterConfig: Record<string, unknown>, reporterContext: ReporterContext) => JestReporter;\nexport type TestSchedulerContext = ReporterContext & TestRunnerContext;\nexport declare function createTestScheduler(globalConfig: Config.GlobalConfig, context: TestSchedulerContext): Promise<TestScheduler>;\ndeclare class TestScheduler {\n    private readonly _context;\n    private readonly _dispatcher;\n    private readonly _globalConfig;\n    constructor(globalConfig: Config.GlobalConfig, context: TestSchedulerContext);\n    addReporter(reporter: Reporter): void;\n    removeReporter(reporterConstructor: ReporterConstructor): void;\n    scheduleTests(tests: Array<Test>, watcher: TestWatcher): Promise<AggregatedResult>;\n    private _partitionTests;\n    _setupReporters(): Promise<void>;\n    private _addCustomReporter;\n    private _bailIfNeeded;\n}\nexport {};\n",
  "packages/jest-core/src/TestPathPatternPrompt.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {\n  PatternPrompt,\n  type Prompt,\n  type ScrollOptions,\n  printPatternCaret,\n  printRestoredPatternCaret,\n} from 'jest-watcher';\n\nexport default class TestPathPatternPrompt extends PatternPrompt {\n  constructor(pipe: NodeJS.WritableStream, prompt: Prompt) {\n    super(pipe, prompt, 'filenames');\n  }\n\n  protected override _onChange(pattern: string, options: ScrollOptions): void {\n    super._onChange(pattern, options);\n    this._printPrompt(pattern);\n  }\n\n  private _printPrompt(pattern: string): void {\n    const pipe = this._pipe;\n    printPatternCaret(pattern, pipe);\n    printRestoredPatternCaret(pattern, this._currentUsageRows, pipe);\n  }\n}\n",
  "packages/jest-core/src/TestPathPatternPrompt.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { PatternPrompt, type Prompt, type ScrollOptions } from 'jest-watcher';\nexport default class TestPathPatternPrompt extends PatternPrompt {\n    constructor(pipe: NodeJS.WritableStream, prompt: Prompt);\n    protected _onChange(pattern: string, options: ScrollOptions): void;\n    private _printPrompt;\n}\n",
  "packages/jest-core/src/TestNamePatternPrompt.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {\n  PatternPrompt,\n  type Prompt,\n  type ScrollOptions,\n  printPatternCaret,\n  printRestoredPatternCaret,\n} from 'jest-watcher';\n\nexport default class TestNamePatternPrompt extends PatternPrompt {\n  constructor(pipe: NodeJS.WritableStream, prompt: Prompt) {\n    super(pipe, prompt, 'tests');\n  }\n\n  protected override _onChange(pattern: string, options: ScrollOptions): void {\n    super._onChange(pattern, options);\n    this._printPrompt(pattern);\n  }\n\n  private _printPrompt(pattern: string): void {\n    const pipe = this._pipe;\n    printPatternCaret(pattern, pipe);\n    printRestoredPatternCaret(pattern, this._currentUsageRows, pipe);\n  }\n}\n",
  "packages/jest-core/src/TestNamePatternPrompt.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { PatternPrompt, type Prompt, type ScrollOptions } from 'jest-watcher';\nexport default class TestNamePatternPrompt extends PatternPrompt {\n    constructor(pipe: NodeJS.WritableStream, prompt: Prompt);\n    protected _onChange(pattern: string, options: ScrollOptions): void;\n    private _printPrompt;\n}\n",
  "packages/jest-core/src/SnapshotInteractiveMode.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport ansiEscapes from 'ansi-escapes';\nimport chalk from 'chalk';\nimport type {AggregatedResult, AssertionLocation} from '@jest/test-result';\nimport {pluralize, specialChars} from 'jest-util';\nimport {KEYS} from 'jest-watcher';\n\nconst {ARROW, CLEAR} = specialChars;\n\nexport default class SnapshotInteractiveMode {\n  private readonly _pipe: NodeJS.WritableStream;\n  private _isActive: boolean;\n  private _updateTestRunnerConfig!: (\n    assertion: AssertionLocation | null,\n    shouldUpdateSnapshot: boolean,\n  ) => unknown;\n  private _testAssertions!: Array<AssertionLocation>;\n  private _countPaths!: number;\n  private _skippedNum: number;\n\n  constructor(pipe: NodeJS.WritableStream) {\n    this._pipe = pipe;\n    this._isActive = false;\n    this._skippedNum = 0;\n  }\n\n  isActive(): boolean {\n    return this._isActive;\n  }\n\n  getSkippedNum(): number {\n    return this._skippedNum;\n  }\n\n  private _clearTestSummary() {\n    this._pipe.write(ansiEscapes.cursorUp(6));\n    this._pipe.write(ansiEscapes.eraseDown);\n  }\n\n  private _drawUIProgress() {\n    this._clearTestSummary();\n    const numPass = this._countPaths - this._testAssertions.length;\n    const numRemaining = this._countPaths - numPass - this._skippedNum;\n\n    let stats = chalk.bold.dim(\n      `${pluralize('snapshot', numRemaining)} remaining`,\n    );\n    if (numPass) {\n      stats += `, ${chalk.bold.green(\n        `${pluralize('snapshot', numPass)} updated`,\n      )}`;\n    }\n    if (this._skippedNum) {\n      stats += `, ${chalk.bold.yellow(\n        `${pluralize('snapshot', this._skippedNum)} skipped`,\n      )}`;\n    }\n    const messages = [\n      `\\n${chalk.bold('Interactive Snapshot Progress')}`,\n      ARROW + stats,\n      `\\n${chalk.bold('Watch Usage')}`,\n\n      `${chalk.dim(`${ARROW}Press `)}u${chalk.dim(\n        ' to update failing snapshots for this test.',\n      )}`,\n\n      `${chalk.dim(`${ARROW}Press `)}s${chalk.dim(\n        ' to skip the current test.',\n      )}`,\n\n      `${chalk.dim(`${ARROW}Press `)}q${chalk.dim(\n        ' to quit Interactive Snapshot Mode.',\n      )}`,\n\n      `${chalk.dim(`${ARROW}Press `)}Enter${chalk.dim(\n        ' to trigger a test run.',\n      )}`,\n    ];\n\n    this._pipe.write(`${messages.filter(Boolean).join('\\n')}\\n`);\n  }\n\n  private _drawUIDoneWithSkipped() {\n    this._pipe.write(CLEAR);\n    const numPass = this._countPaths - this._testAssertions.length;\n\n    let stats = chalk.bold.dim(\n      `${pluralize('snapshot', this._countPaths)} reviewed`,\n    );\n    if (numPass) {\n      stats += `, ${chalk.bold.green(\n        `${pluralize('snapshot', numPass)} updated`,\n      )}`;\n    }\n    if (this._skippedNum) {\n      stats += `, ${chalk.bold.yellow(\n        `${pluralize('snapshot', this._skippedNum)} skipped`,\n      )}`;\n    }\n    const messages = [\n      `\\n${chalk.bold('Interactive Snapshot Result')}`,\n      ARROW + stats,\n      `\\n${chalk.bold('Watch Usage')}`,\n\n      `${chalk.dim(`${ARROW}Press `)}r${chalk.dim(\n        ' to restart Interactive Snapshot Mode.',\n      )}`,\n\n      `${chalk.dim(`${ARROW}Press `)}q${chalk.dim(\n        ' to quit Interactive Snapshot Mode.',\n      )}`,\n    ];\n\n    this._pipe.write(`${messages.filter(Boolean).join('\\n')}\\n`);\n  }\n\n  private _drawUIDone() {\n    this._pipe.write(CLEAR);\n    const numPass = this._countPaths - this._testAssertions.length;\n\n    let stats = chalk.bold.dim(\n      `${pluralize('snapshot', this._countPaths)} reviewed`,\n    );\n    if (numPass) {\n      stats += `, ${chalk.bold.green(\n        `${pluralize('snapshot', numPass)} updated`,\n      )}`;\n    }\n    const messages = [\n      `\\n${chalk.bold('Interactive Snapshot Result')}`,\n      ARROW + stats,\n      `\\n${chalk.bold('Watch Usage')}`,\n\n      `${chalk.dim(`${ARROW}Press `)}Enter${chalk.dim(\n        ' to return to watch mode.',\n      )}`,\n    ];\n\n    this._pipe.write(`${messages.filter(Boolean).join('\\n')}\\n`);\n  }\n\n  private _drawUIOverlay() {\n    if (this._testAssertions.length === 0) {\n      return this._drawUIDone();\n    }\n\n    if (this._testAssertions.length - this._skippedNum === 0) {\n      return this._drawUIDoneWithSkipped();\n    }\n\n    return this._drawUIProgress();\n  }\n\n  put(key: string): void {\n    switch (key) {\n      case 's':\n        if (this._skippedNum === this._testAssertions.length) break;\n        this._skippedNum += 1;\n\n        // move skipped test to the end\n        this._testAssertions.push(this._testAssertions.shift()!);\n        if (this._testAssertions.length - this._skippedNum > 0) {\n          this._run(false);\n        } else {\n          this._drawUIDoneWithSkipped();\n        }\n\n        break;\n      case 'u':\n        this._run(true);\n        break;\n      case 'q':\n      case KEYS.ESCAPE:\n        this.abort();\n        break;\n      case 'r':\n        this.restart();\n        break;\n      case KEYS.ENTER:\n        if (this._testAssertions.length === 0) {\n          this.abort();\n        } else {\n          this._run(false);\n        }\n        break;\n      default:\n        break;\n    }\n  }\n\n  abort(): void {\n    this._isActive = false;\n    this._skippedNum = 0;\n    this._updateTestRunnerConfig(null, false);\n  }\n\n  restart(): void {\n    this._skippedNum = 0;\n    this._countPaths = this._testAssertions.length;\n    this._run(false);\n  }\n\n  updateWithResults(results: AggregatedResult): void {\n    const hasSnapshotFailure = !!results.snapshot.failure;\n    if (hasSnapshotFailure) {\n      this._drawUIOverlay();\n      return;\n    }\n\n    this._testAssertions.shift();\n    if (this._testAssertions.length - this._skippedNum === 0) {\n      this._drawUIOverlay();\n      return;\n    }\n\n    // Go to the next test\n    this._run(false);\n  }\n\n  private _run(shouldUpdateSnapshot: boolean) {\n    const testAssertion = this._testAssertions[0];\n    this._updateTestRunnerConfig(testAssertion, shouldUpdateSnapshot);\n  }\n\n  run(\n    failedSnapshotTestAssertions: Array<AssertionLocation>,\n    onConfigChange: (\n      assertion: AssertionLocation | null,\n      shouldUpdateSnapshot: boolean,\n    ) => unknown,\n  ): void {\n    if (failedSnapshotTestAssertions.length === 0) {\n      return;\n    }\n\n    this._testAssertions = [...failedSnapshotTestAssertions];\n    this._countPaths = this._testAssertions.length;\n    this._updateTestRunnerConfig = onConfigChange;\n    this._isActive = true;\n    this._run(false);\n  }\n}\n",
  "packages/jest-core/src/SnapshotInteractiveMode.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { AggregatedResult, AssertionLocation } from '@jest/test-result';\nexport default class SnapshotInteractiveMode {\n    private readonly _pipe;\n    private _isActive;\n    private _updateTestRunnerConfig;\n    private _testAssertions;\n    private _countPaths;\n    private _skippedNum;\n    constructor(pipe: NodeJS.WritableStream);\n    isActive(): boolean;\n    getSkippedNum(): number;\n    private _clearTestSummary;\n    private _drawUIProgress;\n    private _drawUIDoneWithSkipped;\n    private _drawUIDone;\n    private _drawUIOverlay;\n    put(key: string): void;\n    abort(): void;\n    restart(): void;\n    updateWithResults(results: AggregatedResult): void;\n    private _run;\n    run(failedSnapshotTestAssertions: Array<AssertionLocation>, onConfigChange: (assertion: AssertionLocation | null, shouldUpdateSnapshot: boolean) => unknown): void;\n}\n",
  "packages/jest-core/src/SearchSource.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as os from 'os';\nimport * as path from 'path';\nimport micromatch from 'micromatch';\nimport type {TestPathPatternsExecutor} from '@jest/pattern';\nimport type {Test, TestContext} from '@jest/test-result';\nimport type {Config} from '@jest/types';\nimport type {ChangedFiles} from 'jest-changed-files';\nimport {replaceRootDirInPath} from 'jest-config';\nimport {escapePathForRegex} from 'jest-regex-util';\nimport {DependencyResolver} from 'jest-resolve-dependencies';\nimport {buildSnapshotResolver} from 'jest-snapshot';\nimport {globsToMatcher} from 'jest-util';\nimport type {Filter, Stats, TestPathCases} from './types';\n\nexport type SearchResult = {\n  noSCM?: boolean;\n  stats?: Stats;\n  collectCoverageFrom?: Set<string>;\n  tests: Array<Test>;\n  total?: number;\n};\n\nconst regexToMatcher = (testRegex: Config.ProjectConfig['testRegex']) => {\n  const regexes = testRegex.map(testRegex => new RegExp(testRegex));\n\n  return (path: string) =>\n    regexes.some(regex => {\n      const result = regex.test(path);\n\n      // prevent stateful regexes from breaking, just in case\n      regex.lastIndex = 0;\n\n      return result;\n    });\n};\n\nconst toTests = (context: TestContext, tests: Array<string>) =>\n  tests.map(path => ({\n    context,\n    duration: undefined,\n    path,\n  }));\n\nconst hasSCM = (changedFilesInfo: ChangedFiles) => {\n  const {repos} = changedFilesInfo;\n  // no SCM (git/hg/...) is found in any of the roots.\n  const noSCM = Object.values(repos).every(scm => scm.size === 0);\n  return !noSCM;\n};\n\nfunction normalizePosix(filePath: string) {\n  return filePath.replaceAll('\\\\', '/');\n}\n\nexport default class SearchSource {\n  private readonly _context: TestContext;\n  private _dependencyResolver: DependencyResolver | null;\n  private readonly _testPathCases: TestPathCases = [];\n\n  constructor(context: TestContext) {\n    const {config} = context;\n    this._context = context;\n    this._dependencyResolver = null;\n\n    const rootPattern = new RegExp(\n      config.roots.map(dir => escapePathForRegex(dir + path.sep)).join('|'),\n    );\n    this._testPathCases.push({\n      isMatch: path => rootPattern.test(path),\n      stat: 'roots',\n    });\n\n    if (config.testMatch.length > 0) {\n      this._testPathCases.push({\n        isMatch: globsToMatcher(config.testMatch),\n        stat: 'testMatch',\n      });\n    }\n\n    if (config.testPathIgnorePatterns.length > 0) {\n      const testIgnorePatternsRegex = new RegExp(\n        config.testPathIgnorePatterns.join('|'),\n      );\n      this._testPathCases.push({\n        isMatch: path => !testIgnorePatternsRegex.test(path),\n        stat: 'testPathIgnorePatterns',\n      });\n    }\n\n    if (config.testRegex.length > 0) {\n      this._testPathCases.push({\n        isMatch: regexToMatcher(config.testRegex),\n        stat: 'testRegex',\n      });\n    }\n  }\n\n  private async _getOrBuildDependencyResolver(): Promise<DependencyResolver> {\n    if (!this._dependencyResolver) {\n      this._dependencyResolver = new DependencyResolver(\n        this._context.resolver,\n        this._context.hasteFS,\n        await buildSnapshotResolver(this._context.config),\n      );\n    }\n    return this._dependencyResolver;\n  }\n\n  private _filterTestPathsWithStats(\n    allPaths: Array<Test>,\n    testPathPatternsExecutor: TestPathPatternsExecutor,\n  ): SearchResult {\n    const data: {\n      stats: Stats;\n      tests: Array<Test>;\n      total: number;\n    } = {\n      stats: {\n        roots: 0,\n        testMatch: 0,\n        testPathIgnorePatterns: 0,\n        testRegex: 0,\n      },\n      tests: [],\n      total: allPaths.length,\n    };\n\n    const testCases = [...this._testPathCases]; // clone\n    if (testPathPatternsExecutor.isSet()) {\n      testCases.push({\n        isMatch: (path: string) => testPathPatternsExecutor.isMatch(path),\n        stat: 'testPathPatterns',\n      });\n      data.stats.testPathPatterns = 0;\n    }\n\n    data.tests = allPaths.filter(test => {\n      let filterResult = true;\n      for (const {isMatch, stat} of testCases) {\n        if (isMatch(test.path)) {\n          data.stats[stat]!++;\n        } else {\n          filterResult = false;\n        }\n      }\n      return filterResult;\n    });\n\n    return data;\n  }\n\n  private _getAllTestPaths(\n    testPathPatternsExecutor: TestPathPatternsExecutor,\n  ): SearchResult {\n    return this._filterTestPathsWithStats(\n      toTests(this._context, this._context.hasteFS.getAllFiles()),\n      testPathPatternsExecutor,\n    );\n  }\n\n  isTestFilePath(path: string): boolean {\n    return this._testPathCases.every(testCase => testCase.isMatch(path));\n  }\n\n  findMatchingTests(\n    testPathPatternsExecutor: TestPathPatternsExecutor,\n  ): SearchResult {\n    return this._getAllTestPaths(testPathPatternsExecutor);\n  }\n\n  async findRelatedTests(\n    allPaths: Set<string>,\n    collectCoverage: boolean,\n  ): Promise<SearchResult> {\n    const dependencyResolver = await this._getOrBuildDependencyResolver();\n\n    if (!collectCoverage) {\n      return {\n        tests: toTests(\n          this._context,\n          dependencyResolver.resolveInverse(\n            allPaths,\n            this.isTestFilePath.bind(this),\n            {skipNodeResolution: this._context.config.skipNodeResolution},\n          ),\n        ),\n      };\n    }\n\n    const testModulesMap = dependencyResolver.resolveInverseModuleMap(\n      allPaths,\n      this.isTestFilePath.bind(this),\n      {skipNodeResolution: this._context.config.skipNodeResolution},\n    );\n\n    const allPathsAbsolute = new Set([...allPaths].map(p => path.resolve(p)));\n\n    const collectCoverageFrom = new Set<string>();\n\n    for (const testModule of testModulesMap) {\n      if (!testModule.dependencies) {\n        continue;\n      }\n\n      for (const p of testModule.dependencies) {\n        if (!allPathsAbsolute.has(p)) {\n          continue;\n        }\n\n        const filename = replaceRootDirInPath(this._context.config.rootDir, p);\n        collectCoverageFrom.add(\n          path.isAbsolute(filename)\n            ? path.relative(this._context.config.rootDir, filename)\n            : filename,\n        );\n      }\n    }\n\n    return {\n      collectCoverageFrom,\n      tests: toTests(\n        this._context,\n        testModulesMap.map(testModule => testModule.file),\n      ),\n    };\n  }\n\n  findTestsByPaths(paths: Array<string>): SearchResult {\n    return {\n      tests: toTests(\n        this._context,\n        paths\n          .map(p => path.resolve(this._context.config.cwd, p))\n          .filter(this.isTestFilePath.bind(this)),\n      ),\n    };\n  }\n\n  async findRelatedTestsFromPattern(\n    paths: Array<string>,\n    collectCoverage: boolean,\n  ): Promise<SearchResult> {\n    if (Array.isArray(paths) && paths.length > 0) {\n      const resolvedPaths = paths.map(p =>\n        path.resolve(this._context.config.cwd, p),\n      );\n      return this.findRelatedTests(new Set(resolvedPaths), collectCoverage);\n    }\n    return {tests: []};\n  }\n\n  async findTestRelatedToChangedFiles(\n    changedFilesInfo: ChangedFiles,\n    collectCoverage: boolean,\n  ): Promise<SearchResult> {\n    if (!hasSCM(changedFilesInfo)) {\n      return {noSCM: true, tests: []};\n    }\n    const {changedFiles} = changedFilesInfo;\n    return this.findRelatedTests(changedFiles, collectCoverage);\n  }\n\n  private async _getTestPaths(\n    globalConfig: Config.GlobalConfig,\n    projectConfig: Config.ProjectConfig,\n    changedFiles?: ChangedFiles,\n  ): Promise<SearchResult> {\n    if (globalConfig.onlyChanged) {\n      if (!changedFiles) {\n        throw new Error('Changed files must be set when running with -o.');\n      }\n\n      return this.findTestRelatedToChangedFiles(\n        changedFiles,\n        globalConfig.collectCoverage,\n      );\n    }\n\n    let paths = globalConfig.nonFlagArgs;\n\n    if (globalConfig.findRelatedTests && 'win32' === os.platform()) {\n      paths = this.filterPathsWin32(paths);\n    }\n\n    if (globalConfig.runTestsByPath && paths && paths.length > 0) {\n      return this.findTestsByPaths(paths);\n    } else if (globalConfig.findRelatedTests && paths && paths.length > 0) {\n      return this.findRelatedTestsFromPattern(\n        paths,\n        globalConfig.collectCoverage,\n      );\n    } else {\n      return this.findMatchingTests(\n        globalConfig.testPathPatterns.toExecutor({\n          rootDir: projectConfig.rootDir,\n        }),\n      );\n    }\n  }\n\n  public filterPathsWin32(paths: Array<string>): Array<string> {\n    const allFiles = this._context.hasteFS.getAllFiles();\n    const options = {nocase: true, windows: false};\n\n    paths = paths\n      .map(p => {\n        // micromatch works with forward slashes: https://github.com/micromatch/micromatch#backslashes\n        const normalizedPath = normalizePosix(\n          path.resolve(this._context.config.cwd, p),\n        );\n        const match = micromatch(\n          allFiles.map(normalizePosix),\n          normalizedPath,\n          options,\n        );\n        return match[0];\n      })\n      .filter(Boolean)\n      .map(p => path.resolve(p));\n    return paths;\n  }\n\n  async getTestPaths(\n    globalConfig: Config.GlobalConfig,\n    projectConfig: Config.ProjectConfig,\n    changedFiles?: ChangedFiles,\n    filter?: Filter,\n  ): Promise<SearchResult> {\n    const searchResult = await this._getTestPaths(\n      globalConfig,\n      projectConfig,\n      changedFiles,\n    );\n\n    const filterPath = globalConfig.filter;\n\n    if (filter) {\n      const tests = searchResult.tests;\n\n      const filterResult = await filter(tests.map(test => test.path));\n\n      if (!Array.isArray(filterResult.filtered)) {\n        throw new TypeError(\n          `Filter ${filterPath} did not return a valid test list`,\n        );\n      }\n\n      const filteredSet = new Set(filterResult.filtered);\n\n      return {\n        ...searchResult,\n        tests: tests.filter(test => filteredSet.has(test.path)),\n      };\n    }\n\n    return searchResult;\n  }\n\n  async findRelatedSourcesFromTestsInChangedFiles(\n    changedFilesInfo: ChangedFiles,\n  ): Promise<Array<string>> {\n    if (!hasSCM(changedFilesInfo)) {\n      return [];\n    }\n    const {changedFiles} = changedFilesInfo;\n    const dependencyResolver = await this._getOrBuildDependencyResolver();\n    const relatedSourcesSet = new Set<string>();\n    for (const filePath of changedFiles) {\n      if (this.isTestFilePath(filePath)) {\n        const sourcePaths = dependencyResolver.resolve(filePath, {\n          skipNodeResolution: this._context.config.skipNodeResolution,\n        });\n        for (const sourcePath of sourcePaths) relatedSourcesSet.add(sourcePath);\n      }\n    }\n    return [...relatedSourcesSet];\n  }\n}\n",
  "packages/jest-core/src/SearchSource.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { TestPathPatternsExecutor } from '@jest/pattern';\nimport type { Test, TestContext } from '@jest/test-result';\nimport type { Config } from '@jest/types';\nimport type { ChangedFiles } from 'jest-changed-files';\nimport type { Filter, Stats } from './types';\nexport type SearchResult = {\n    noSCM?: boolean;\n    stats?: Stats;\n    collectCoverageFrom?: Set<string>;\n    tests: Array<Test>;\n    total?: number;\n};\nexport default class SearchSource {\n    private readonly _context;\n    private _dependencyResolver;\n    private readonly _testPathCases;\n    constructor(context: TestContext);\n    private _getOrBuildDependencyResolver;\n    private _filterTestPathsWithStats;\n    private _getAllTestPaths;\n    isTestFilePath(path: string): boolean;\n    findMatchingTests(testPathPatternsExecutor: TestPathPatternsExecutor): SearchResult;\n    findRelatedTests(allPaths: Set<string>, collectCoverage: boolean): Promise<SearchResult>;\n    findTestsByPaths(paths: Array<string>): SearchResult;\n    findRelatedTestsFromPattern(paths: Array<string>, collectCoverage: boolean): Promise<SearchResult>;\n    findTestRelatedToChangedFiles(changedFilesInfo: ChangedFiles, collectCoverage: boolean): Promise<SearchResult>;\n    private _getTestPaths;\n    filterPathsWin32(paths: Array<string>): Array<string>;\n    getTestPaths(globalConfig: Config.GlobalConfig, projectConfig: Config.ProjectConfig, changedFiles?: ChangedFiles, filter?: Filter): Promise<SearchResult>;\n    findRelatedSourcesFromTestsInChangedFiles(changedFilesInfo: ChangedFiles): Promise<Array<string>>;\n}\n",
  "packages/jest-core/src/ReporterDispatcher.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {Reporter, ReporterOnStartOptions} from '@jest/reporters';\nimport type {\n  AggregatedResult,\n  Test,\n  TestCaseResult,\n  TestContext,\n  TestResult,\n} from '@jest/test-result';\nimport type {Circus} from '@jest/types';\nimport type {ReporterConstructor} from './TestScheduler';\n\nexport default class ReporterDispatcher {\n  private _reporters: Array<Reporter>;\n\n  constructor() {\n    this._reporters = [];\n  }\n\n  register(reporter: Reporter): void {\n    this._reporters.push(reporter);\n  }\n\n  unregister(reporterConstructor: ReporterConstructor): void {\n    this._reporters = this._reporters.filter(\n      reporter => !(reporter instanceof reporterConstructor),\n    );\n  }\n\n  async onTestFileResult(\n    test: Test,\n    testResult: TestResult,\n    results: AggregatedResult,\n  ): Promise<void> {\n    for (const reporter of this._reporters) {\n      if (reporter.onTestFileResult) {\n        await reporter.onTestFileResult(test, testResult, results);\n      } else if (reporter.onTestResult) {\n        await reporter.onTestResult(test, testResult, results);\n      }\n    }\n\n    // Release memory if unused later.\n    testResult.coverage = undefined;\n    testResult.console = undefined;\n  }\n\n  async onTestFileStart(test: Test): Promise<void> {\n    for (const reporter of this._reporters) {\n      if (reporter.onTestFileStart) {\n        await reporter.onTestFileStart(test);\n      } else if (reporter.onTestStart) {\n        await reporter.onTestStart(test);\n      }\n    }\n  }\n\n  async onRunStart(\n    results: AggregatedResult,\n    options: ReporterOnStartOptions,\n  ): Promise<void> {\n    for (const reporter of this._reporters) {\n      if (reporter.onRunStart) {\n        await reporter.onRunStart(results, options);\n      }\n    }\n  }\n\n  async onTestCaseStart(\n    test: Test,\n    testCaseStartInfo: Circus.TestCaseStartInfo,\n  ): Promise<void> {\n    for (const reporter of this._reporters) {\n      if (reporter.onTestCaseStart) {\n        await reporter.onTestCaseStart(test, testCaseStartInfo);\n      }\n    }\n  }\n\n  async onTestCaseResult(\n    test: Test,\n    testCaseResult: TestCaseResult,\n  ): Promise<void> {\n    for (const reporter of this._reporters) {\n      if (reporter.onTestCaseResult) {\n        await reporter.onTestCaseResult(test, testCaseResult);\n      }\n    }\n  }\n\n  async onRunComplete(\n    testContexts: Set<TestContext>,\n    results: AggregatedResult,\n  ): Promise<void> {\n    for (const reporter of this._reporters) {\n      if (reporter.onRunComplete) {\n        await reporter.onRunComplete(testContexts, results);\n      }\n    }\n  }\n\n  // Return a list of last errors for every reporter\n  getErrors(): Array<Error> {\n    return this._reporters.reduce<Array<Error>>((list, reporter) => {\n      const error = reporter.getLastError?.();\n      return error ? [...list, error] : list;\n    }, []);\n  }\n\n  hasErrors(): boolean {\n    return this.getErrors().length > 0;\n  }\n}\n",
  "packages/jest-core/src/ReporterDispatcher.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Reporter, ReporterOnStartOptions } from '@jest/reporters';\nimport type { AggregatedResult, Test, TestCaseResult, TestContext, TestResult } from '@jest/test-result';\nimport type { Circus } from '@jest/types';\nimport type { ReporterConstructor } from './TestScheduler';\nexport default class ReporterDispatcher {\n    private _reporters;\n    constructor();\n    register(reporter: Reporter): void;\n    unregister(reporterConstructor: ReporterConstructor): void;\n    onTestFileResult(test: Test, testResult: TestResult, results: AggregatedResult): Promise<void>;\n    onTestFileStart(test: Test): Promise<void>;\n    onRunStart(results: AggregatedResult, options: ReporterOnStartOptions): Promise<void>;\n    onTestCaseStart(test: Test, testCaseStartInfo: Circus.TestCaseStartInfo): Promise<void>;\n    onTestCaseResult(test: Test, testCaseResult: TestCaseResult): Promise<void>;\n    onRunComplete(testContexts: Set<TestContext>, results: AggregatedResult): Promise<void>;\n    getErrors(): Array<Error>;\n    hasErrors(): boolean;\n}\n",
  "packages/jest-core/src/FailedTestsInteractiveMode.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport ansiEscapes from 'ansi-escapes';\nimport chalk from 'chalk';\nimport type {AggregatedResult, AssertionLocation} from '@jest/test-result';\nimport {pluralize, specialChars} from 'jest-util';\nimport {KEYS} from 'jest-watcher';\n\ntype RunnerUpdateFunction = (failure?: AssertionLocation) => void;\n\nconst {ARROW, CLEAR} = specialChars;\n\nfunction describeKey(key: string, description: string) {\n  return `${chalk.dim(`${ARROW}Press`)} ${key} ${chalk.dim(description)}`;\n}\n\nconst TestProgressLabel = chalk.bold('Interactive Test Progress');\n\nexport default class FailedTestsInteractiveMode {\n  private _isActive = false;\n  private _countPaths = 0;\n  private _skippedNum = 0;\n  private _testAssertions: Array<AssertionLocation> = [];\n  private _updateTestRunnerConfig?: RunnerUpdateFunction;\n\n  constructor(private readonly _pipe: NodeJS.WritableStream) {}\n\n  isActive(): boolean {\n    return this._isActive;\n  }\n\n  put(key: string): void {\n    switch (key) {\n      case 's':\n        if (this._skippedNum === this._testAssertions.length) {\n          break;\n        }\n\n        this._skippedNum += 1;\n        // move skipped test to the end\n        this._testAssertions.push(this._testAssertions.shift()!);\n        if (this._testAssertions.length - this._skippedNum > 0) {\n          this._run();\n        } else {\n          this._drawUIDoneWithSkipped();\n        }\n\n        break;\n      case 'q':\n      case KEYS.ESCAPE:\n        this.abort();\n        break;\n      case 'r':\n        this.restart();\n        break;\n      case KEYS.ENTER:\n        if (this._testAssertions.length === 0) {\n          this.abort();\n        } else {\n          this._run();\n        }\n        break;\n      default:\n    }\n  }\n\n  run(\n    failedTestAssertions: Array<AssertionLocation>,\n    updateConfig: RunnerUpdateFunction,\n  ): void {\n    if (failedTestAssertions.length === 0) return;\n\n    this._testAssertions = [...failedTestAssertions];\n    this._countPaths = this._testAssertions.length;\n    this._updateTestRunnerConfig = updateConfig;\n    this._isActive = true;\n    this._run();\n  }\n\n  updateWithResults(results: AggregatedResult): void {\n    if (!results.snapshot.failure && results.numFailedTests > 0) {\n      return this._drawUIOverlay();\n    }\n\n    this._testAssertions.shift();\n    if (this._testAssertions.length === 0) {\n      return this._drawUIOverlay();\n    }\n\n    // Go to the next test\n    return this._run();\n  }\n\n  private _clearTestSummary() {\n    this._pipe.write(ansiEscapes.cursorUp(6));\n    this._pipe.write(ansiEscapes.eraseDown);\n  }\n\n  private _drawUIDone() {\n    this._pipe.write(CLEAR);\n\n    const messages: Array<string> = [\n      chalk.bold('Watch Usage'),\n      describeKey('Enter', 'to return to watch mode.'),\n    ];\n\n    this._pipe.write(`${messages.join('\\n')}\\n`);\n  }\n\n  private _drawUIDoneWithSkipped() {\n    this._pipe.write(CLEAR);\n\n    let stats = `${pluralize('test', this._countPaths)} reviewed`;\n\n    if (this._skippedNum > 0) {\n      const skippedText = chalk.bold.yellow(\n        `${pluralize('test', this._skippedNum)} skipped`,\n      );\n\n      stats = `${stats}, ${skippedText}`;\n    }\n\n    const message = [\n      TestProgressLabel,\n      `${ARROW}${stats}`,\n      '\\n',\n      chalk.bold('Watch Usage'),\n      describeKey('r', 'to restart Interactive Mode.'),\n      describeKey('q', 'to quit Interactive Mode.'),\n      describeKey('Enter', 'to return to watch mode.'),\n    ];\n\n    this._pipe.write(`\\n${message.join('\\n')}`);\n  }\n\n  private _drawUIProgress() {\n    this._clearTestSummary();\n\n    const numPass = this._countPaths - this._testAssertions.length;\n    const numRemaining = this._countPaths - numPass - this._skippedNum;\n    let stats = `${pluralize('test', numRemaining)} remaining`;\n\n    if (this._skippedNum > 0) {\n      const skippedText = chalk.bold.yellow(\n        `${pluralize('test', this._skippedNum)} skipped`,\n      );\n\n      stats = `${stats}, ${skippedText}`;\n    }\n\n    const message = [\n      TestProgressLabel,\n      `${ARROW}${stats}`,\n      '\\n',\n      chalk.bold('Watch Usage'),\n      describeKey('s', 'to skip the current test.'),\n      describeKey('q', 'to quit Interactive Mode.'),\n      describeKey('Enter', 'to return to watch mode.'),\n    ];\n\n    this._pipe.write(`\\n${message.join('\\n')}`);\n  }\n\n  private _drawUIOverlay() {\n    if (this._testAssertions.length === 0) return this._drawUIDone();\n\n    return this._drawUIProgress();\n  }\n\n  private _run() {\n    if (this._updateTestRunnerConfig) {\n      this._updateTestRunnerConfig(this._testAssertions[0]);\n    }\n  }\n\n  private abort() {\n    this._isActive = false;\n    this._skippedNum = 0;\n\n    if (this._updateTestRunnerConfig) {\n      this._updateTestRunnerConfig();\n    }\n  }\n\n  private restart(): void {\n    this._skippedNum = 0;\n    this._countPaths = this._testAssertions.length;\n    this._run();\n  }\n}\n",
  "packages/jest-core/src/FailedTestsInteractiveMode.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { AggregatedResult, AssertionLocation } from '@jest/test-result';\ntype RunnerUpdateFunction = (failure?: AssertionLocation) => void;\nexport default class FailedTestsInteractiveMode {\n    private readonly _pipe;\n    private _isActive;\n    private _countPaths;\n    private _skippedNum;\n    private _testAssertions;\n    private _updateTestRunnerConfig?;\n    constructor(_pipe: NodeJS.WritableStream);\n    isActive(): boolean;\n    put(key: string): void;\n    run(failedTestAssertions: Array<AssertionLocation>, updateConfig: RunnerUpdateFunction): void;\n    updateWithResults(results: AggregatedResult): void;\n    private _clearTestSummary;\n    private _drawUIDone;\n    private _drawUIDoneWithSkipped;\n    private _drawUIProgress;\n    private _drawUIOverlay;\n    private _run;\n    private abort;\n    private restart;\n}\nexport {};\n",
  "packages/jest-core/src/FailedTestsCache.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {Test, TestResult} from '@jest/test-result';\n\ntype TestMap = Record<string, Record<string, boolean>>;\n\nexport default class FailedTestsCache {\n  private _enabledTestsMap?: TestMap;\n\n  filterTests(tests: Array<Test>): Array<Test> {\n    const enabledTestsMap = this._enabledTestsMap;\n\n    if (!enabledTestsMap) {\n      return tests;\n    }\n    return tests.filter(testResult => enabledTestsMap[testResult.path]);\n  }\n\n  setTestResults(testResults: Array<TestResult>): void {\n    this._enabledTestsMap = (testResults || []).reduce<TestMap>(\n      (suiteMap, testResult) => {\n        if (!testResult.numFailingTests) {\n          return suiteMap;\n        }\n\n        suiteMap[testResult.testFilePath] = testResult.testResults.reduce<{\n          [name: string]: true;\n        }>((testMap, test) => {\n          if (test.status !== 'failed') {\n            return testMap;\n          }\n\n          testMap[test.fullName] = true;\n          return testMap;\n        }, {});\n        return suiteMap;\n      },\n      {},\n    );\n\n    this._enabledTestsMap = Object.freeze(this._enabledTestsMap);\n  }\n}\n",
  "packages/jest-core/src/FailedTestsCache.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Test, TestResult } from '@jest/test-result';\nexport default class FailedTestsCache {\n    private _enabledTestsMap?;\n    filterTests(tests: Array<Test>): Array<Test>;\n    setTestResults(testResults: Array<TestResult>): void;\n}\n",
  "packages/jest-core/src/plugins/UpdateSnapshotsInteractive.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {AggregatedResult, AssertionLocation} from '@jest/test-result';\nimport type {Config} from '@jest/types';\nimport {\n  BaseWatchPlugin,\n  type JestHookSubscriber,\n  type UsageData,\n} from 'jest-watcher';\nimport SnapshotInteractiveMode from '../SnapshotInteractiveMode';\n\nclass UpdateSnapshotInteractivePlugin extends BaseWatchPlugin {\n  private readonly _snapshotInteractiveMode: SnapshotInteractiveMode =\n    new SnapshotInteractiveMode(this._stdout);\n  private _failedSnapshotTestAssertions: Array<AssertionLocation> = [];\n  isInternal = true as const;\n\n  getFailedSnapshotTestAssertions(\n    testResults: AggregatedResult,\n  ): Array<AssertionLocation> {\n    const failedTestPaths: Array<AssertionLocation> = [];\n    if (testResults.numFailedTests === 0 || !testResults.testResults) {\n      return failedTestPaths;\n    }\n\n    for (const testResult of testResults.testResults) {\n      if (testResult.snapshot && testResult.snapshot.unmatched) {\n        for (const result of testResult.testResults) {\n          if (result.status === 'failed') {\n            failedTestPaths.push({\n              fullName: result.fullName,\n              path: testResult.testFilePath,\n            });\n          }\n        }\n      }\n    }\n\n    return failedTestPaths;\n  }\n\n  override apply(hooks: JestHookSubscriber): void {\n    hooks.onTestRunComplete(results => {\n      this._failedSnapshotTestAssertions =\n        this.getFailedSnapshotTestAssertions(results);\n      if (this._snapshotInteractiveMode.isActive()) {\n        this._snapshotInteractiveMode.updateWithResults(results);\n      }\n    });\n  }\n\n  override onKey(key: string): void {\n    if (this._snapshotInteractiveMode.isActive()) {\n      this._snapshotInteractiveMode.put(key);\n    }\n  }\n\n  override run(\n    _globalConfig: Config.GlobalConfig,\n    updateConfigAndRun: Function,\n  ): Promise<void> {\n    if (this._failedSnapshotTestAssertions.length > 0) {\n      return new Promise(resolve => {\n        this._snapshotInteractiveMode.run(\n          this._failedSnapshotTestAssertions,\n          (assertion, shouldUpdateSnapshot) => {\n            updateConfigAndRun({\n              mode: 'watch',\n              testNamePattern: assertion ? `^${assertion.fullName}$` : '',\n              testPathPatterns: assertion ? [assertion.path] : [],\n\n              updateSnapshot: shouldUpdateSnapshot ? 'all' : 'none',\n            });\n            if (!this._snapshotInteractiveMode.isActive()) {\n              resolve();\n            }\n          },\n        );\n      });\n    } else {\n      return Promise.resolve();\n    }\n  }\n\n  override getUsageInfo(): UsageData | null {\n    if (this._failedSnapshotTestAssertions?.length > 0) {\n      return {\n        key: 'i',\n        prompt: 'update failing snapshots interactively',\n      };\n    }\n\n    return null;\n  }\n}\n\nexport default UpdateSnapshotInteractivePlugin;\n",
  "packages/jest-core/src/plugins/UpdateSnapshotsInteractive.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { AggregatedResult, AssertionLocation } from '@jest/test-result';\nimport type { Config } from '@jest/types';\nimport { BaseWatchPlugin, type JestHookSubscriber, type UsageData } from 'jest-watcher';\ndeclare class UpdateSnapshotInteractivePlugin extends BaseWatchPlugin {\n    private readonly _snapshotInteractiveMode;\n    private _failedSnapshotTestAssertions;\n    isInternal: true;\n    getFailedSnapshotTestAssertions(testResults: AggregatedResult): Array<AssertionLocation>;\n    apply(hooks: JestHookSubscriber): void;\n    onKey(key: string): void;\n    run(_globalConfig: Config.GlobalConfig, updateConfigAndRun: Function): Promise<void>;\n    getUsageInfo(): UsageData | null;\n}\nexport default UpdateSnapshotInteractivePlugin;\n",
  "packages/jest-core/src/plugins/UpdateSnapshots.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {ReadStream, WriteStream} from 'tty';\nimport type {Config} from '@jest/types';\nimport {\n  BaseWatchPlugin,\n  type JestHookSubscriber,\n  type UpdateConfigCallback,\n  type UsageData,\n} from 'jest-watcher';\n\nclass UpdateSnapshotsPlugin extends BaseWatchPlugin {\n  private _hasSnapshotFailure: boolean;\n  isInternal: true;\n\n  constructor(options: {stdin: ReadStream; stdout: WriteStream}) {\n    super(options);\n    this.isInternal = true;\n    this._hasSnapshotFailure = false;\n  }\n\n  override run(\n    _globalConfig: Config.GlobalConfig,\n    updateConfigAndRun: UpdateConfigCallback,\n  ): Promise<boolean> {\n    updateConfigAndRun({updateSnapshot: 'all'});\n    return Promise.resolve(false);\n  }\n\n  override apply(hooks: JestHookSubscriber): void {\n    hooks.onTestRunComplete(results => {\n      this._hasSnapshotFailure = results.snapshot.failure;\n    });\n  }\n\n  override getUsageInfo(): UsageData | null {\n    if (this._hasSnapshotFailure) {\n      return {\n        key: 'u',\n        prompt: 'update failing snapshots',\n      };\n    }\n\n    return null;\n  }\n}\n\nexport default UpdateSnapshotsPlugin;\n",
  "packages/jest-core/src/plugins/UpdateSnapshots.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { ReadStream, WriteStream } from 'tty';\nimport type { Config } from '@jest/types';\nimport { BaseWatchPlugin, type JestHookSubscriber, type UpdateConfigCallback, type UsageData } from 'jest-watcher';\ndeclare class UpdateSnapshotsPlugin extends BaseWatchPlugin {\n    private _hasSnapshotFailure;\n    isInternal: true;\n    constructor(options: {\n        stdin: ReadStream;\n        stdout: WriteStream;\n    });\n    run(_globalConfig: Config.GlobalConfig, updateConfigAndRun: UpdateConfigCallback): Promise<boolean>;\n    apply(hooks: JestHookSubscriber): void;\n    getUsageInfo(): UsageData | null;\n}\nexport default UpdateSnapshotsPlugin;\n",
  "packages/jest-core/src/plugins/TestPathPattern.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {ReadStream, WriteStream} from 'tty';\nimport type {Config} from '@jest/types';\nimport {\n  BaseWatchPlugin,\n  Prompt,\n  type UpdateConfigCallback,\n  type UsageData,\n} from 'jest-watcher';\nimport TestPathPatternPrompt from '../TestPathPatternPrompt';\nimport activeFilters from '../lib/activeFiltersMessage';\n\nclass TestPathPatternPlugin extends BaseWatchPlugin {\n  private readonly _prompt: Prompt;\n  isInternal: true;\n\n  constructor(options: {stdin: ReadStream; stdout: WriteStream}) {\n    super(options);\n    this._prompt = new Prompt();\n    this.isInternal = true;\n  }\n\n  override getUsageInfo(): UsageData {\n    return {\n      key: 'p',\n      prompt: 'filter by a filename regex pattern',\n    };\n  }\n\n  override onKey(key: string): void {\n    this._prompt.put(key);\n  }\n\n  override run(\n    globalConfig: Config.GlobalConfig,\n    updateConfigAndRun: UpdateConfigCallback,\n  ): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const testPathPatternPrompt = new TestPathPatternPrompt(\n        this._stdout,\n        this._prompt,\n      );\n\n      testPathPatternPrompt.run(\n        (value: string) => {\n          updateConfigAndRun({\n            mode: 'watch',\n            testPathPatterns: [value],\n          });\n          resolve();\n        },\n        reject,\n        {\n          header: activeFilters(globalConfig),\n        },\n      );\n    });\n  }\n}\n\nexport default TestPathPatternPlugin;\n",
  "packages/jest-core/src/plugins/TestPathPattern.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { ReadStream, WriteStream } from 'tty';\nimport type { Config } from '@jest/types';\nimport { BaseWatchPlugin, type UpdateConfigCallback, type UsageData } from 'jest-watcher';\ndeclare class TestPathPatternPlugin extends BaseWatchPlugin {\n    private readonly _prompt;\n    isInternal: true;\n    constructor(options: {\n        stdin: ReadStream;\n        stdout: WriteStream;\n    });\n    getUsageInfo(): UsageData;\n    onKey(key: string): void;\n    run(globalConfig: Config.GlobalConfig, updateConfigAndRun: UpdateConfigCallback): Promise<void>;\n}\nexport default TestPathPatternPlugin;\n",
  "packages/jest-core/src/plugins/TestNamePattern.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {ReadStream, WriteStream} from 'tty';\nimport type {Config} from '@jest/types';\nimport {\n  BaseWatchPlugin,\n  Prompt,\n  type UpdateConfigCallback,\n  type UsageData,\n} from 'jest-watcher';\nimport TestNamePatternPrompt from '../TestNamePatternPrompt';\nimport activeFilters from '../lib/activeFiltersMessage';\n\nclass TestNamePatternPlugin extends BaseWatchPlugin {\n  _prompt: Prompt;\n  isInternal: true;\n\n  constructor(options: {stdin: ReadStream; stdout: WriteStream}) {\n    super(options);\n    this._prompt = new Prompt();\n    this.isInternal = true;\n  }\n\n  override getUsageInfo(): UsageData {\n    return {\n      key: 't',\n      prompt: 'filter by a test name regex pattern',\n    };\n  }\n\n  override onKey(key: string): void {\n    this._prompt.put(key);\n  }\n\n  override run(\n    globalConfig: Config.GlobalConfig,\n    updateConfigAndRun: UpdateConfigCallback,\n  ): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const testNamePatternPrompt = new TestNamePatternPrompt(\n        this._stdout,\n        this._prompt,\n      );\n\n      testNamePatternPrompt.run(\n        (value: string) => {\n          updateConfigAndRun({mode: 'watch', testNamePattern: value});\n          resolve();\n        },\n        reject,\n        {\n          header: activeFilters(globalConfig),\n        },\n      );\n    });\n  }\n}\n\nexport default TestNamePatternPlugin;\n",
  "packages/jest-core/src/plugins/TestNamePattern.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { ReadStream, WriteStream } from 'tty';\nimport type { Config } from '@jest/types';\nimport { BaseWatchPlugin, Prompt, type UpdateConfigCallback, type UsageData } from 'jest-watcher';\ndeclare class TestNamePatternPlugin extends BaseWatchPlugin {\n    _prompt: Prompt;\n    isInternal: true;\n    constructor(options: {\n        stdin: ReadStream;\n        stdout: WriteStream;\n    });\n    getUsageInfo(): UsageData;\n    onKey(key: string): void;\n    run(globalConfig: Config.GlobalConfig, updateConfigAndRun: UpdateConfigCallback): Promise<void>;\n}\nexport default TestNamePatternPlugin;\n",
  "packages/jest-core/src/plugins/Quit.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {ReadStream, WriteStream} from 'tty';\nimport {BaseWatchPlugin, type UsageData} from 'jest-watcher';\n\nclass QuitPlugin extends BaseWatchPlugin {\n  isInternal: true;\n\n  constructor(options: {stdin: ReadStream; stdout: WriteStream}) {\n    super(options);\n    this.isInternal = true;\n  }\n\n  override async run(): Promise<void> {\n    if (typeof this._stdin.setRawMode === 'function') {\n      this._stdin.setRawMode(false);\n    }\n    this._stdout.write('\\n');\n    process.exit(0);\n  }\n\n  override getUsageInfo(): UsageData {\n    return {\n      key: 'q',\n      prompt: 'quit watch mode',\n    };\n  }\n}\n\nexport default QuitPlugin;\n",
  "packages/jest-core/src/plugins/Quit.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { ReadStream, WriteStream } from 'tty';\nimport { BaseWatchPlugin, type UsageData } from 'jest-watcher';\ndeclare class QuitPlugin extends BaseWatchPlugin {\n    isInternal: true;\n    constructor(options: {\n        stdin: ReadStream;\n        stdout: WriteStream;\n    });\n    run(): Promise<void>;\n    getUsageInfo(): UsageData;\n}\nexport default QuitPlugin;\n",
  "packages/jest-core/src/plugins/FailedTestsInteractive.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {AggregatedResult, AssertionLocation} from '@jest/test-result';\nimport type {Config} from '@jest/types';\nimport {\n  BaseWatchPlugin,\n  type JestHookSubscriber,\n  type UpdateConfigCallback,\n  type UsageData,\n} from 'jest-watcher';\nimport FailedTestsInteractiveMode from '../FailedTestsInteractiveMode';\n\nexport default class FailedTestsInteractivePlugin extends BaseWatchPlugin {\n  private _failedTestAssertions?: Array<AssertionLocation>;\n  private readonly _manager = new FailedTestsInteractiveMode(this._stdout);\n\n  override apply(hooks: JestHookSubscriber): void {\n    hooks.onTestRunComplete(results => {\n      this._failedTestAssertions = this.getFailedTestAssertions(results);\n\n      if (this._manager.isActive()) this._manager.updateWithResults(results);\n    });\n  }\n\n  override getUsageInfo(): UsageData | null {\n    if (this._failedTestAssertions?.length) {\n      return {key: 'i', prompt: 'run failing tests interactively'};\n    }\n\n    return null;\n  }\n\n  override onKey(key: string): void {\n    if (this._manager.isActive()) {\n      this._manager.put(key);\n    }\n  }\n\n  override run(\n    _: Config.GlobalConfig,\n    updateConfigAndRun: UpdateConfigCallback,\n  ): Promise<void> {\n    return new Promise(resolve => {\n      if (\n        !this._failedTestAssertions ||\n        this._failedTestAssertions.length === 0\n      ) {\n        resolve();\n        return;\n      }\n\n      this._manager.run(this._failedTestAssertions, failure => {\n        updateConfigAndRun({\n          mode: 'watch',\n          testNamePattern: failure ? `^${failure.fullName}$` : '',\n          testPathPatterns: failure ? [failure.path] : [],\n        });\n\n        if (!this._manager.isActive()) {\n          resolve();\n        }\n      });\n    });\n  }\n\n  private getFailedTestAssertions(\n    results: AggregatedResult,\n  ): Array<AssertionLocation> {\n    const failedTestPaths: Array<AssertionLocation> = [];\n\n    if (\n      // skip if no failed tests\n      results.numFailedTests === 0 ||\n      // skip if missing test results\n      !results.testResults ||\n      // skip if unmatched snapshots are present\n      results.snapshot.unmatched\n    ) {\n      return failedTestPaths;\n    }\n\n    for (const testResult of results.testResults) {\n      for (const result of testResult.testResults) {\n        if (result.status === 'failed') {\n          failedTestPaths.push({\n            fullName: result.fullName,\n            path: testResult.testFilePath,\n          });\n        }\n      }\n    }\n\n    return failedTestPaths;\n  }\n}\n",
  "packages/jest-core/src/plugins/FailedTestsInteractive.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config } from '@jest/types';\nimport { BaseWatchPlugin, type JestHookSubscriber, type UpdateConfigCallback, type UsageData } from 'jest-watcher';\nexport default class FailedTestsInteractivePlugin extends BaseWatchPlugin {\n    private _failedTestAssertions?;\n    private readonly _manager;\n    apply(hooks: JestHookSubscriber): void;\n    getUsageInfo(): UsageData | null;\n    onKey(key: string): void;\n    run(_: Config.GlobalConfig, updateConfigAndRun: UpdateConfigCallback): Promise<void>;\n    private getFailedTestAssertions;\n}\n",
  "packages/jest-core/src/lib/watchPluginsHelpers.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {Config} from '@jest/types';\nimport {isNonNullable} from 'jest-util';\nimport type {UsageData, WatchPlugin} from 'jest-watcher';\n\nexport const filterInteractivePlugins = (\n  watchPlugins: Array<WatchPlugin>,\n  globalConfig: Config.GlobalConfig,\n): Array<WatchPlugin> => {\n  const usageInfos = watchPlugins.map(\n    p => p.getUsageInfo && p.getUsageInfo(globalConfig),\n  );\n\n  return watchPlugins.filter((_plugin, i) => {\n    const usageInfo = usageInfos[i];\n    if (usageInfo) {\n      const {key} = usageInfo;\n      return !usageInfos.slice(i + 1).some(u => !!u && key === u.key);\n    }\n\n    return false;\n  });\n};\n\nexport const getSortedUsageRows = (\n  watchPlugins: Array<WatchPlugin>,\n  globalConfig: Config.GlobalConfig,\n): Array<UsageData> =>\n  filterInteractivePlugins(watchPlugins, globalConfig)\n    .sort((a: WatchPlugin, b: WatchPlugin) => {\n      if (a.isInternal && b.isInternal) {\n        // internal plugins in the order we specify them\n        return 0;\n      }\n      if (a.isInternal !== b.isInternal) {\n        // external plugins afterwards\n        return a.isInternal ? -1 : 1;\n      }\n\n      const usageInfoA = a.getUsageInfo && a.getUsageInfo(globalConfig);\n      const usageInfoB = b.getUsageInfo && b.getUsageInfo(globalConfig);\n\n      if (usageInfoA && usageInfoB) {\n        // external plugins in alphabetical order\n        return usageInfoA.key.localeCompare(usageInfoB.key);\n      }\n      return 0;\n    })\n    .map(p => p.getUsageInfo && p.getUsageInfo(globalConfig))\n    .filter(isNonNullable);\n",
  "packages/jest-core/src/lib/watchPluginsHelpers.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config } from '@jest/types';\nimport type { UsageData, WatchPlugin } from 'jest-watcher';\nexport declare const filterInteractivePlugins: (watchPlugins: Array<WatchPlugin>, globalConfig: Config.GlobalConfig) => Array<WatchPlugin>;\nexport declare const getSortedUsageRows: (watchPlugins: Array<WatchPlugin>, globalConfig: Config.GlobalConfig) => Array<UsageData>;\n",
  "packages/jest-core/src/lib/updateGlobalConfig.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {TestPathPatterns} from '@jest/pattern';\nimport type {Config} from '@jest/types';\nimport type {AllowedConfigOptions} from 'jest-watcher';\n\ntype ExtraConfigOptions = Partial<\n  Pick<Config.GlobalConfig, 'noSCM' | 'passWithNoTests'>\n>;\n\nexport default function updateGlobalConfig(\n  globalConfig: Config.GlobalConfig,\n  options: AllowedConfigOptions & ExtraConfigOptions = {},\n): Config.GlobalConfig {\n  const newConfig: Config.GlobalConfig = {...globalConfig};\n\n  if (options.mode === 'watch') {\n    newConfig.watch = true;\n    newConfig.watchAll = false;\n  } else if (options.mode === 'watchAll') {\n    newConfig.watch = false;\n    newConfig.watchAll = true;\n  }\n\n  if (options.testNamePattern !== undefined) {\n    newConfig.testNamePattern = options.testNamePattern || '';\n  }\n\n  if (options.testPathPatterns !== undefined) {\n    newConfig.testPathPatterns = new TestPathPatterns(options.testPathPatterns);\n  }\n\n  newConfig.onlyChanged =\n    !newConfig.watchAll &&\n    !newConfig.testNamePattern &&\n    !newConfig.testPathPatterns.isSet();\n\n  if (typeof options.bail === 'boolean') {\n    newConfig.bail = options.bail ? 1 : 0;\n  } else if (options.bail !== undefined) {\n    newConfig.bail = options.bail;\n  }\n\n  if (options.changedSince !== undefined) {\n    newConfig.changedSince = options.changedSince;\n  }\n\n  if (options.collectCoverage !== undefined) {\n    newConfig.collectCoverage = options.collectCoverage || false;\n  }\n\n  if (options.collectCoverageFrom !== undefined) {\n    newConfig.collectCoverageFrom = options.collectCoverageFrom;\n  }\n\n  if (options.coverageDirectory !== undefined) {\n    newConfig.coverageDirectory = options.coverageDirectory;\n  }\n\n  if (options.coverageReporters !== undefined) {\n    newConfig.coverageReporters = options.coverageReporters;\n  }\n\n  if (options.findRelatedTests !== undefined) {\n    newConfig.findRelatedTests = options.findRelatedTests;\n  }\n\n  if (options.nonFlagArgs !== undefined) {\n    newConfig.nonFlagArgs = options.nonFlagArgs;\n  }\n\n  if (options.noSCM) {\n    newConfig.noSCM = true;\n  }\n\n  if (options.notify !== undefined) {\n    newConfig.notify = options.notify || false;\n  }\n\n  if (options.notifyMode !== undefined) {\n    newConfig.notifyMode = options.notifyMode;\n  }\n\n  if (options.onlyFailures !== undefined) {\n    newConfig.onlyFailures = options.onlyFailures || false;\n  }\n\n  if (options.passWithNoTests !== undefined) {\n    newConfig.passWithNoTests = true;\n  }\n\n  if (options.reporters !== undefined) {\n    newConfig.reporters = options.reporters;\n  }\n\n  if (options.updateSnapshot !== undefined) {\n    newConfig.updateSnapshot = options.updateSnapshot;\n  }\n\n  if (options.verbose !== undefined) {\n    newConfig.verbose = options.verbose || false;\n  }\n\n  return Object.freeze(newConfig);\n}\n",
  "packages/jest-core/src/lib/updateGlobalConfig.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config } from '@jest/types';\nimport type { AllowedConfigOptions } from 'jest-watcher';\ntype ExtraConfigOptions = Partial<Pick<Config.GlobalConfig, 'noSCM' | 'passWithNoTests'>>;\nexport default function updateGlobalConfig(globalConfig: Config.GlobalConfig, options?: AllowedConfigOptions & ExtraConfigOptions): Config.GlobalConfig;\nexport {};\n",
  "packages/jest-core/src/lib/serializeToJSON.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {isNativeError} from 'node:util/types';\n\n/**\n * When we're asked to give a JSON output with the --json flag or otherwise,\n * some data we need to return don't serialize well with a basic\n * `JSON.stringify`, particularly Errors returned in `.openHandles`.\n *\n * This function handles the extended serialization wanted above.\n */\nexport default function serializeToJSON(\n  value: unknown,\n  space?: string | number,\n): string {\n  return JSON.stringify(\n    value,\n    (_, value) => {\n      // There might be more in Error, but pulling out just the message, name,\n      // and stack should be good enough\n      if (isNativeError(value)) {\n        return {\n          message: value.message,\n          name: value.name,\n          stack: value.stack,\n        };\n      }\n      return value;\n    },\n    space,\n  );\n}\n",
  "packages/jest-core/src/lib/serializeToJSON.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n/**\n * When we're asked to give a JSON output with the --json flag or otherwise,\n * some data we need to return don't serialize well with a basic\n * `JSON.stringify`, particularly Errors returned in `.openHandles`.\n *\n * This function handles the extended serialization wanted above.\n */\nexport default function serializeToJSON(value: unknown, space?: string | number): string;\n",
  "packages/jest-core/src/lib/logDebugMessages.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {WriteStream} from 'tty';\nimport type {Config} from '@jest/types';\nconst VERSION = require('../../package.json').version;\n\n// if the output here changes, update `getConfig` in e2e/runJest.ts\nexport default function logDebugMessages(\n  globalConfig: Config.GlobalConfig,\n  configs: Array<Config.ProjectConfig> | Config.ProjectConfig,\n  outputStream: WriteStream,\n): void {\n  const output = {\n    configs,\n    globalConfig: {\n      ...globalConfig,\n      testPathPatterns: globalConfig.testPathPatterns.patterns,\n    },\n    version: VERSION,\n  };\n  outputStream.write(`${JSON.stringify(output, null, '  ')}\\n`);\n}\n",
  "packages/jest-core/src/lib/logDebugMessages.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { WriteStream } from 'tty';\nimport type { Config } from '@jest/types';\nexport default function logDebugMessages(globalConfig: Config.GlobalConfig, configs: Array<Config.ProjectConfig> | Config.ProjectConfig, outputStream: WriteStream): void;\n",
  "packages/jest-core/src/lib/isValidPath.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {Config} from '@jest/types';\nimport {isSnapshotPath} from 'jest-snapshot';\n\nexport default function isValidPath(\n  globalConfig: Config.GlobalConfig,\n  filePath: string,\n): boolean {\n  return (\n    !filePath.includes(globalConfig.coverageDirectory) &&\n    !isSnapshotPath(filePath)\n  );\n}\n",
  "packages/jest-core/src/lib/isValidPath.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config } from '@jest/types';\nexport default function isValidPath(globalConfig: Config.GlobalConfig, filePath: string): boolean;\n",
  "packages/jest-core/src/lib/handleDeprecationWarnings.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {ReadStream, WriteStream} from 'tty';\nimport chalk from 'chalk';\nimport {KEYS} from 'jest-watcher';\n\nexport default function handleDeprecationWarnings(\n  pipe: WriteStream,\n  stdin: ReadStream = process.stdin,\n): Promise<void> {\n  return new Promise((resolve, reject) => {\n    if (typeof stdin.setRawMode === 'function') {\n      const messages = [\n        chalk.red('There are deprecation warnings.\\n'),\n        `${chalk.dim(' \\u203A Press ')}Enter${chalk.dim(' to continue.')}`,\n        `${chalk.dim(' \\u203A Press ')}Esc${chalk.dim(' to exit.')}`,\n      ];\n\n      pipe.write(messages.join('\\n'));\n\n      stdin.setRawMode(true);\n      stdin.resume();\n      stdin.setEncoding('utf8');\n      // this is a string since we set encoding above\n      stdin.on('data', (key: string) => {\n        if (key === KEYS.ENTER) {\n          resolve();\n        } else if (\n          [KEYS.ESCAPE, KEYS.CONTROL_C, KEYS.CONTROL_D].includes(key)\n        ) {\n          reject();\n        }\n      });\n    } else {\n      resolve();\n    }\n  });\n}\n",
  "packages/jest-core/src/lib/handleDeprecationWarnings.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { ReadStream, WriteStream } from 'tty';\nexport default function handleDeprecationWarnings(pipe: WriteStream, stdin?: ReadStream): Promise<void>;\n",
  "packages/jest-core/src/lib/createContext.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {TestContext} from '@jest/test-result';\nimport type {Config} from '@jest/types';\nimport type {IHasteFS, IModuleMap} from 'jest-haste-map';\nimport Runtime from 'jest-runtime';\n\ntype HasteContext = {hasteFS: IHasteFS; moduleMap: IModuleMap};\n\nexport default function createContext(\n  config: Config.ProjectConfig,\n  {hasteFS, moduleMap}: HasteContext,\n): TestContext {\n  return {\n    config,\n    hasteFS,\n    moduleMap,\n    resolver: Runtime.createResolver(config, moduleMap),\n  };\n}\n",
  "packages/jest-core/src/lib/createContext.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { TestContext } from '@jest/test-result';\nimport type { Config } from '@jest/types';\nimport type { IHasteFS, IModuleMap } from 'jest-haste-map';\ntype HasteContext = {\n    hasteFS: IHasteFS;\n    moduleMap: IModuleMap;\n};\nexport default function createContext(config: Config.ProjectConfig, { hasteFS, moduleMap }: HasteContext): TestContext;\nexport {};\n",
  "packages/jest-core/src/lib/activeFiltersMessage.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk from 'chalk';\nimport type {Config} from '@jest/types';\nimport {isNonNullable} from 'jest-util';\n\nconst activeFilters = (globalConfig: Config.GlobalConfig): string => {\n  const {testNamePattern} = globalConfig;\n  const testPathPatterns = globalConfig.testPathPatterns;\n  if (testNamePattern || testPathPatterns.isSet()) {\n    const filters = [\n      testPathPatterns.isSet()\n        ? chalk.dim('filename ') + chalk.yellow(testPathPatterns.toPretty())\n        : null,\n      testNamePattern\n        ? chalk.dim('test name ') + chalk.yellow(`/${testNamePattern}/`)\n        : null,\n    ]\n      .filter(isNonNullable)\n      .join(', ');\n\n    const messages = `\\n${chalk.bold('Active Filters: ')}${filters}`;\n\n    return messages;\n  }\n\n  return '';\n};\n\nexport default activeFilters;\n",
  "packages/jest-core/src/lib/activeFiltersMessage.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config } from '@jest/types';\ndeclare const activeFilters: (globalConfig: Config.GlobalConfig) => string;\nexport default activeFilters;\n",
  "packages/jest-core/src/lib/__tests__/serializeToJSON.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport serializeToJSON from '../serializeToJSON';\n\n// populate an object with all basic JavaScript datatypes\nconst object = {\n  chillness: 100,\n  flaws: null,\n  hopOut: {\n    atThe: 'after party',\n    when: new Date('2000-07-14'),\n  },\n  i: ['pull up'],\n  location: undefined,\n  ok: true,\n  species: 'capybara',\n  weight: 9.5,\n};\n\nit('serializes regular objects like JSON.stringify', () => {\n  expect(serializeToJSON(object)).toEqual(JSON.stringify(object));\n});\n\nit('serializes errors', () => {\n  const objectWithError = {\n    ...object,\n    error: new Error('too cool'),\n  };\n  const withError = serializeToJSON(objectWithError);\n  const withoutError = JSON.stringify(objectWithError);\n\n  expect(withoutError).not.toEqual(withError);\n\n  expect(withError).toContain('\"message\":\"too cool\"');\n  expect(withError).toContain('\"name\":\"Error\"');\n  expect(withError).toContain('\"stack\":\"Error:');\n\n  expect(JSON.parse(withError)).toMatchObject({\n    error: {\n      message: 'too cool',\n      name: 'Error',\n    },\n  });\n});\n",
  "packages/jest-core/src/lib/__tests__/serializeToJSON.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-core/src/lib/__tests__/logDebugMessages.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {WriteStream} from 'tty';\nimport {makeGlobalConfig, makeProjectConfig} from '@jest/test-utils';\nimport logDebugMessages from '../logDebugMessages';\n\njest.mock('../../../package.json', () => ({version: 123}));\n\njest.mock('myRunner', () => ({name: 'My Runner'}), {virtual: true});\n\nconst getOutputStream = (resolve: (message: string) => void) =>\n  ({\n    write(message: string) {\n      resolve(message);\n    },\n  }) as WriteStream;\n\nit('prints the jest version', async () => {\n  expect.assertions(1);\n  const message = await new Promise<string>(resolve => {\n    logDebugMessages(\n      makeGlobalConfig({watch: true}),\n      makeProjectConfig({testRunner: 'myRunner'}),\n      getOutputStream(resolve),\n    );\n  });\n\n  expect(JSON.parse(message).version).toBe(123);\n});\n\nit('prints the test framework name', async () => {\n  expect.assertions(1);\n  const message = await new Promise<string>(resolve => {\n    logDebugMessages(\n      makeGlobalConfig({watch: true}),\n      makeProjectConfig({testRunner: 'myRunner'}),\n      getOutputStream(resolve),\n    );\n  });\n\n  expect(JSON.parse(message).configs.testRunner).toBe('myRunner');\n});\n\nit('prints the config object', async () => {\n  expect.assertions(1);\n  const globalConfig = makeGlobalConfig({\n    watch: true,\n  });\n  const config = makeProjectConfig({\n    automock: false,\n    rootDir: '/path/to/dir',\n    roots: ['path/to/dir/test'],\n    testRunner: 'myRunner',\n  });\n  const message = await new Promise<string>(resolve => {\n    logDebugMessages(globalConfig, config, getOutputStream(resolve));\n  });\n  expect(message).toMatchSnapshot();\n});\n",
  "packages/jest-core/src/lib/__tests__/logDebugMessages.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport {};\n",
  "packages/jest-core/src/lib/__tests__/isValidPath.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {makeGlobalConfig} from '@jest/test-utils';\nimport isValidPath from '../isValidPath';\n\nconst rootDir = path.resolve(path.sep, 'root');\n\nit('is valid when it is a file inside roots', () => {\n  expect(\n    isValidPath(makeGlobalConfig(), path.resolve(rootDir, 'src', 'index.js')),\n  ).toBe(true);\n  expect(\n    isValidPath(\n      makeGlobalConfig(),\n      path.resolve(rootDir, 'src', 'components', 'Link.js'),\n    ),\n  ).toBe(true);\n  expect(\n    isValidPath(\n      makeGlobalConfig(),\n      path.resolve(rootDir, 'src', 'lib', 'something.js'),\n    ),\n  ).toBe(true);\n});\n\nit('is not valid when it is a snapshot file', () => {\n  expect(\n    isValidPath(\n      makeGlobalConfig(),\n      path.resolve(rootDir, 'src', 'index.js.snap'),\n    ),\n  ).toBe(false);\n  expect(\n    isValidPath(\n      makeGlobalConfig(),\n      path.resolve(rootDir, 'src', 'components', 'Link.js.snap'),\n    ),\n  ).toBe(false);\n  expect(\n    isValidPath(\n      makeGlobalConfig(),\n      path.resolve(rootDir, 'src', 'lib', 'something.js.snap'),\n    ),\n  ).toBe(false);\n});\n\nit('is not valid when it is a file in the coverage dir', () => {\n  expect(\n    isValidPath(\n      makeGlobalConfig({rootDir}),\n      path.resolve(rootDir, 'coverage', 'lib', 'index.js'),\n    ),\n  ).toBe(false);\n\n  expect(\n    isValidPath(\n      makeGlobalConfig({coverageDirectory: 'cov-dir'}),\n      path.resolve(rootDir, 'src', 'cov-dir', 'lib', 'index.js'),\n    ),\n  ).toBe(false);\n});\n",
  "packages/jest-core/src/lib/__tests__/isValidPath.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-core/src/cli/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {performance} from 'perf_hooks';\nimport type {WriteStream} from 'tty';\nimport chalk from 'chalk';\nimport exit from 'exit-x';\nimport * as fs from 'graceful-fs';\nimport {CustomConsole} from '@jest/console';\nimport type {AggregatedResult, TestContext} from '@jest/test-result';\nimport type {Config} from '@jest/types';\nimport type {ChangedFilesPromise} from 'jest-changed-files';\nimport {readConfigs} from 'jest-config';\nimport type {IHasteMap} from 'jest-haste-map';\nimport Runtime from 'jest-runtime';\nimport {createDirectory, pluralize, preRunMessage} from 'jest-util';\nimport {TestWatcher} from 'jest-watcher';\nimport {formatHandleErrors} from '../collectHandles';\nimport getChangedFilesPromise from '../getChangedFilesPromise';\nimport getConfigsOfProjectsToRun from '../getConfigsOfProjectsToRun';\nimport getProjectNamesMissingWarning from '../getProjectNamesMissingWarning';\nimport getSelectProjectsMessage from '../getSelectProjectsMessage';\nimport createContext from '../lib/createContext';\nimport handleDeprecationWarnings from '../lib/handleDeprecationWarnings';\nimport logDebugMessages from '../lib/logDebugMessages';\nimport runJest from '../runJest';\nimport type {Filter} from '../types';\nimport watch from '../watch';\n\nconst {print: preRunMessagePrint} = preRunMessage;\n\ntype OnCompleteCallback = (results: AggregatedResult) => void | undefined;\n\nexport async function runCLI(\n  argv: Config.Argv,\n  projects: Array<string>,\n): Promise<{\n  results: AggregatedResult;\n  globalConfig: Config.GlobalConfig;\n}> {\n  performance.mark('jest/runCLI:start');\n  let results: AggregatedResult | undefined;\n\n  // If we output a JSON object, we can't write anything to stdout, since\n  // it'll break the JSON structure and it won't be valid.\n  const outputStream =\n    argv.json || argv.useStderr ? process.stderr : process.stdout;\n\n  const {globalConfig, configs, hasDeprecationWarnings} = await readConfigs(\n    argv,\n    projects,\n  );\n\n  if (argv.debug) {\n    logDebugMessages(globalConfig, configs, outputStream);\n  }\n\n  if (argv.showConfig) {\n    logDebugMessages(globalConfig, configs, process.stdout);\n    exit(0);\n  }\n\n  if (argv.clearCache) {\n    // stick in a Set to dedupe the deletions\n    const uniqueConfigDirectories = new Set(\n      configs.map(config => config.cacheDirectory),\n    );\n    for (const cacheDirectory of uniqueConfigDirectories) {\n      fs.rmSync(cacheDirectory, {force: true, recursive: true});\n      process.stdout.write(`Cleared ${cacheDirectory}\\n`);\n    }\n\n    exit(0);\n  }\n\n  const configsOfProjectsToRun = getConfigsOfProjectsToRun(configs, {\n    ignoreProjects: argv.ignoreProjects,\n    selectProjects: argv.selectProjects,\n  });\n  if (argv.selectProjects || argv.ignoreProjects) {\n    const namesMissingWarning = getProjectNamesMissingWarning(configs, {\n      ignoreProjects: argv.ignoreProjects,\n      selectProjects: argv.selectProjects,\n    });\n    if (namesMissingWarning) {\n      outputStream.write(namesMissingWarning);\n    }\n    outputStream.write(\n      getSelectProjectsMessage(configsOfProjectsToRun, {\n        ignoreProjects: argv.ignoreProjects,\n        selectProjects: argv.selectProjects,\n      }),\n    );\n  }\n\n  await _run10000(\n    globalConfig,\n    configsOfProjectsToRun,\n    hasDeprecationWarnings,\n    outputStream,\n    r => {\n      results = r;\n    },\n  );\n\n  if (argv.watch || argv.watchAll) {\n    // If in watch mode, return the promise that will never resolve.\n    // If the watch mode is interrupted, watch should handle the process\n    // shutdown.\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    return new Promise(() => {});\n  }\n\n  if (!results) {\n    throw new Error(\n      'AggregatedResult must be present after test run is complete',\n    );\n  }\n\n  const {openHandles} = results;\n\n  if (openHandles && openHandles.length > 0) {\n    const formatted = formatHandleErrors(openHandles, configs[0]);\n\n    const openHandlesString = pluralize('open handle', formatted.length, 's');\n\n    const message =\n      chalk.red(\n        `\\nJest has detected the following ${openHandlesString} potentially keeping Jest from exiting:\\n\\n`,\n      ) + formatted.join('\\n\\n');\n\n    console.error(message);\n  }\n\n  performance.mark('jest/runCLI:end');\n  return {globalConfig, results};\n}\n\nconst buildContextsAndHasteMaps = async (\n  configs: Array<Config.ProjectConfig>,\n  globalConfig: Config.GlobalConfig,\n  outputStream: WriteStream,\n) => {\n  const hasteMapInstances = Array.from<IHasteMap>({\n    length: configs.length,\n  });\n  const contexts = await Promise.all(\n    configs.map(async (config, index) => {\n      createDirectory(config.cacheDirectory);\n      const hasteMapInstance = await Runtime.createHasteMap(config, {\n        console: new CustomConsole(outputStream, outputStream),\n        maxWorkers: Math.max(\n          1,\n          Math.floor(globalConfig.maxWorkers / configs.length),\n        ),\n        resetCache: !config.cache,\n        watch: globalConfig.watch || globalConfig.watchAll,\n        watchman: globalConfig.watchman,\n        workerThreads: globalConfig.workerThreads,\n      });\n      hasteMapInstances[index] = hasteMapInstance;\n      return createContext(config, await hasteMapInstance.build());\n    }),\n  );\n\n  return {contexts, hasteMapInstances};\n};\n\nconst _run10000 = async (\n  globalConfig: Config.GlobalConfig,\n  configs: Array<Config.ProjectConfig>,\n  hasDeprecationWarnings: boolean,\n  outputStream: WriteStream,\n  onComplete: OnCompleteCallback,\n) => {\n  // Queries to hg/git can take a while, so we need to start the process\n  // as soon as possible, so by the time we need the result it's already there.\n  const changedFilesPromise = getChangedFilesPromise(globalConfig, configs);\n  if (changedFilesPromise) {\n    performance.mark('jest/getChangedFiles:start');\n    changedFilesPromise.finally(() => {\n      performance.mark('jest/getChangedFiles:end');\n    });\n  }\n\n  // Filter may need to do an HTTP call or something similar to setup.\n  // We will wait on an async response from this before using the filter.\n  let filter: Filter | undefined;\n  if (globalConfig.filter && !globalConfig.skipFilter) {\n    const rawFilter = require(globalConfig.filter);\n    let filterSetupPromise: Promise<unknown | undefined> | undefined;\n    if (rawFilter.setup) {\n      // Wrap filter setup Promise to avoid \"uncaught Promise\" error.\n      // If an error is returned, we surface it in the return value.\n      filterSetupPromise = (async () => {\n        try {\n          await rawFilter.setup();\n        } catch (error) {\n          return error;\n        }\n        return undefined;\n      })();\n    }\n    filter = async (testPaths: Array<string>) => {\n      if (filterSetupPromise) {\n        // Expect an undefined return value unless there was an error.\n        const err = await filterSetupPromise;\n        if (err) {\n          throw err;\n        }\n      }\n      return rawFilter(testPaths);\n    };\n  }\n\n  performance.mark('jest/buildContextsAndHasteMaps:start');\n  const {contexts, hasteMapInstances} = await buildContextsAndHasteMaps(\n    configs,\n    globalConfig,\n    outputStream,\n  );\n  performance.mark('jest/buildContextsAndHasteMaps:end');\n\n  if (globalConfig.watch || globalConfig.watchAll) {\n    await runWatch(\n      contexts,\n      configs,\n      hasDeprecationWarnings,\n      globalConfig,\n      outputStream,\n      hasteMapInstances,\n      filter,\n    );\n  } else {\n    await runWithoutWatch(\n      globalConfig,\n      contexts,\n      outputStream,\n      onComplete,\n      changedFilesPromise,\n      filter,\n    );\n  }\n};\n\nconst runWatch = async (\n  contexts: Array<TestContext>,\n  _configs: Array<Config.ProjectConfig>,\n  hasDeprecationWarnings: boolean,\n  globalConfig: Config.GlobalConfig,\n  outputStream: WriteStream,\n  hasteMapInstances: Array<IHasteMap>,\n  filter?: Filter,\n) => {\n  if (hasDeprecationWarnings) {\n    try {\n      await handleDeprecationWarnings(outputStream, process.stdin);\n      return await watch(\n        globalConfig,\n        contexts,\n        outputStream,\n        hasteMapInstances,\n        undefined,\n        undefined,\n        filter,\n      );\n    } catch {\n      exit(0);\n    }\n  }\n\n  return watch(\n    globalConfig,\n    contexts,\n    outputStream,\n    hasteMapInstances,\n    undefined,\n    undefined,\n    filter,\n  );\n};\n\nconst runWithoutWatch = async (\n  globalConfig: Config.GlobalConfig,\n  contexts: Array<TestContext>,\n  outputStream: WriteStream,\n  onComplete: OnCompleteCallback,\n  changedFilesPromise?: ChangedFilesPromise,\n  filter?: Filter,\n) => {\n  const startRun = async (): Promise<void | null> => {\n    if (!globalConfig.listTests) {\n      preRunMessagePrint(outputStream);\n    }\n    return runJest({\n      changedFilesPromise,\n      contexts,\n      failedTestsCache: undefined,\n      filter,\n      globalConfig,\n      onComplete,\n      outputStream,\n      startRun,\n      testWatcher: new TestWatcher({isWatchMode: false}),\n    });\n  };\n  return startRun();\n};\n",
  "packages/jest-core/src/cli/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { AggregatedResult } from '@jest/test-result';\nimport type { Config } from '@jest/types';\nexport declare function runCLI(argv: Config.Argv, projects: Array<string>): Promise<{\n    results: AggregatedResult;\n    globalConfig: Config.GlobalConfig;\n}>;\n",
  "packages/jest-core/src/__tests__/watchFileChanges.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport type {WriteStream} from 'tty';\nimport * as fs from 'graceful-fs';\nimport type {AggregatedResult} from '@jest/test-result';\nimport {normalize} from 'jest-config';\nimport type {IHasteMap} from 'jest-haste-map';\nimport Runtime from 'jest-runtime';\nimport {interopRequireDefault} from 'jest-util';\nimport {JestHook} from 'jest-watcher';\n\ndescribe('Watch mode flows with changed files', () => {\n  jest.resetModules();\n\n  let watch: typeof import('../watch').default;\n  let pipe: WriteStream;\n  let stdin: MockStdin;\n  const testDirectory = path.resolve(tmpdir(), 'jest-tmp');\n  const fileTargetPath = path.resolve(testDirectory, 'lost-file.js');\n  const fileTargetPath2 = path.resolve(\n    testDirectory,\n    'watch-test-fake.test.js',\n  );\n  const cacheDirectory = path.resolve(tmpdir(), `tmp${Math.random()}`);\n  let hasteMapInstance: IHasteMap;\n\n  beforeEach(() => {\n    watch = interopRequireDefault(require('../watch')).default;\n    pipe = {write: jest.fn()} as unknown;\n    stdin = new MockStdin();\n    fs.rmSync(cacheDirectory, {force: true, recursive: true});\n    fs.rmSync(testDirectory, {force: true, recursive: true});\n    fs.mkdirSync(testDirectory);\n    fs.mkdirSync(cacheDirectory);\n  });\n\n  afterEach(() => {\n    jest.resetModules();\n    if (hasteMapInstance) {\n      hasteMapInstance.end();\n    }\n    fs.rmSync(cacheDirectory, {force: true, recursive: true});\n    fs.rmSync(testDirectory, {force: true, recursive: true});\n  });\n\n  it('should correct require new files without legacy cache', async () => {\n    fs.writeFileSync(\n      fileTargetPath2,\n      `\n        require('./lost-file.js');\n        describe('Fake test', () => {\n            it('Hey', () => {\n\n            });\n        });\n      `,\n    );\n\n    const config = (\n      await normalize(\n        {\n          cache: false,\n          cacheDirectory,\n          coverageReporters: [],\n          maxConcurrency: 1,\n          maxWorkers: 1,\n          moduleDirectories: ['node_modules'],\n          onlyChanged: false,\n          reporters: [],\n          rootDir: testDirectory,\n          silent: true,\n          testRegex: ['watch-test-fake\\\\.test\\\\.js$'],\n          watch: false,\n          watchman: false,\n        },\n        {} as unknown,\n      )\n    ).options;\n\n    hasteMapInstance = await Runtime.createHasteMap(config, {\n      maxWorkers: 1,\n      resetCache: true,\n      watch: true,\n      watchman: false,\n    });\n\n    const realContext = await hasteMapInstance.build().then(hasteMap => ({\n      config,\n      hasteFS: hasteMap.hasteFS,\n      moduleMap: hasteMap.moduleMap,\n      resolver: Runtime.createResolver(config, hasteMap.moduleMap),\n    }));\n\n    const hook = new JestHook();\n    const firstErrorPromise = new Promise(resolve => {\n      hook.getSubscriber().onTestRunComplete(resolve);\n    });\n    await watch(\n      {\n        ...config,\n        watchPlugins: [],\n      },\n      [realContext],\n      pipe,\n      [hasteMapInstance],\n      stdin,\n      hook,\n    );\n\n    await firstErrorPromise;\n\n    const successPromise = new Promise<AggregatedResult>(resolve => {\n      hook.getSubscriber().onTestRunComplete(resolve);\n    });\n\n    // Create lost file\n    fs.writeFileSync(\n      fileTargetPath,\n      `\n        describe('Fake group', () => {\n            it('Fake 1', () => {});\n            it('Fake 2', () => {});\n            it('Fake 3', () => {});\n        });\n      `,\n    );\n\n    const resultSuccessReport = await successPromise;\n\n    expect(resultSuccessReport).toMatchObject({\n      numFailedTestSuites: 0,\n      numFailedTests: 0,\n      numPassedTests: 4,\n      numRuntimeErrorTestSuites: 0,\n      success: true,\n      wasInterrupted: false,\n    });\n    expect(resultSuccessReport.testResults[0]).toMatchObject({\n      failureMessage: null,\n    });\n\n    const errorPromise = new Promise<AggregatedResult>(resolve => {\n      hook.getSubscriber().onTestRunComplete(resolve);\n    });\n\n    // Remove again to ensure about no legacy cache\n    fs.unlinkSync(fileTargetPath);\n\n    const resultErrorReport = await errorPromise;\n\n    // After remove file we have to fail tests\n    expect(resultErrorReport).toMatchObject({\n      numFailedTestSuites: 1,\n      numPassedTests: 0,\n      numRuntimeErrorTestSuites: 1,\n      success: false,\n      wasInterrupted: false,\n    });\n  });\n});\n\nclass MockStdin {\n  private readonly _callbacks: Array<unknown>;\n\n  constructor() {\n    this._callbacks = [];\n  }\n\n  resume() {}\n\n  setEncoding() {}\n\n  on(_: unknown, callback: unknown) {\n    this._callbacks.push(callback);\n  }\n\n  emit(key: string) {\n    for (const cb of this._callbacks) cb(key);\n  }\n}\n",
  "packages/jest-core/src/__tests__/watchFileChanges.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport {};\n",
  "packages/jest-core/src/__tests__/globals.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ndescribe('Common globals', () => {\n  it('check process', () => {\n    if (Symbol && Symbol.toStringTag) {\n      expect(Object.prototype.toString.call(process)).toBe('[object process]');\n    }\n  });\n});\n",
  "packages/jest-core/src/__tests__/globals.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n",
  "packages/jest-core/src/__tests__/getNoTestsFoundMessage.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {TestPathPatterns} from '@jest/pattern';\nimport {makeGlobalConfig} from '@jest/test-utils';\nimport type {Config} from '@jest/types';\nimport getNoTestsFoundMessage from '../getNoTestsFoundMessage';\n\njest.mock('jest-util', () => ({\n  ...jest.requireActual<typeof import('jest-util')>('jest-util'),\n  isInteractive: true,\n}));\n\ndescribe('getNoTestsFoundMessage', () => {\n  function createGlobalConfig(options?: Partial<Config.GlobalConfig>) {\n    return makeGlobalConfig({\n      rootDir: '/root/dir',\n      testPathPatterns: new TestPathPatterns(['/path/pattern']),\n      ...options,\n    });\n  }\n\n  test('returns correct message when monitoring only failures', () => {\n    const config = createGlobalConfig({onlyFailures: true});\n    expect(getNoTestsFoundMessage([], config)).toMatchSnapshot();\n  });\n\n  test('returns correct message when monitoring only changed', () => {\n    const config = createGlobalConfig({onlyChanged: true});\n    expect(getNoTestsFoundMessage([], config)).toMatchSnapshot();\n  });\n\n  test('returns correct message with verbose option', () => {\n    const config = createGlobalConfig({verbose: true});\n    expect(getNoTestsFoundMessage([], config)).toMatchSnapshot();\n  });\n\n  test('returns correct message without options', () => {\n    const config = createGlobalConfig();\n    expect(getNoTestsFoundMessage([], config)).toMatchSnapshot();\n  });\n\n  test('returns correct message with passWithNoTests', () => {\n    const config = createGlobalConfig({passWithNoTests: true});\n    expect(getNoTestsFoundMessage([], config)).toMatchSnapshot();\n  });\n\n  test('returns correct message with findRelatedTests', () => {\n    const config = createGlobalConfig({findRelatedTests: true});\n    expect(getNoTestsFoundMessage([], config)).toMatchSnapshot();\n    expect(\n      getNoTestsFoundMessage([], {...config, passWithNoTests: true}),\n    ).toMatchSnapshot();\n  });\n});\n",
  "packages/jest-core/src/__tests__/getNoTestsFoundMessage.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-core/src/__tests__/SearchSource.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport * as path from 'path';\nimport {TestPathPatterns} from '@jest/pattern';\nimport type {Test} from '@jest/test-result';\nimport type {Config} from '@jest/types';\nimport {normalize} from 'jest-config';\nimport Runtime from 'jest-runtime';\nimport SearchSource from '../SearchSource';\nimport type {Filter} from '../types';\n\njest.setTimeout(15_000);\n\njest.mock('graceful-fs', () => {\n  const realFs = jest.requireActual<typeof import('fs')>('fs');\n\n  const mockedFs: typeof import('fs') = {\n    ...realFs,\n    statSync: path => {\n      if (path === '/foo/bar/prefix') {\n        return {isDirectory: () => true};\n      }\n\n      return realFs.statSync(path);\n    },\n  };\n\n  return mockedFs;\n});\n\nconst rootDir = path.resolve(__dirname, 'test_root');\nconst testRegex = `${path.sep}__testtests__${path.sep}`;\nconst testMatch = ['**/__testtests__/**/*'];\nconst maxWorkers = 1;\n\nconst toPaths = (tests: Array<Test>) => tests.map(({path}) => path);\n\nconst initSearchSource = async (\n  initialOptions: Config.InitialOptions,\n  options: {\n    contextFiles?: Array<string>;\n  } = {},\n) => {\n  const {options: config} = await normalize(initialOptions, {} as Config.Argv);\n  const context = await Runtime.createContext(config, {\n    maxWorkers,\n    watchman: false,\n  });\n  if (options.contextFiles) {\n    jest\n      .spyOn(context.hasteFS, 'getAllFiles')\n      .mockReturnValue(options.contextFiles);\n  }\n  return {config, searchSource: new SearchSource(context)};\n};\n\ndescribe('SearchSource', () => {\n  const id = 'SearchSource';\n  let searchSource: SearchSource;\n\n  describe('isTestFilePath', () => {\n    beforeEach(async () => {\n      ({searchSource} = await initSearchSource({\n        id,\n        rootDir: '.',\n        roots: [],\n      }));\n    });\n\n    // micromatch doesn't support '..' through the globstar ('**') to avoid\n    // infinite recursion.\n    it('supports ../ paths and unix separators via testRegex', async () => {\n      if (process.platform === 'win32') {\n        return;\n      }\n      const {searchSource} = await initSearchSource({\n        id,\n        rootDir: '.',\n        roots: [],\n        testMatch: undefined,\n        testRegex: '(/__tests__/.*|(\\\\.|/)(test|spec))\\\\.jsx?$',\n      });\n\n      const path = '/path/to/__tests__/foo/bar/baz/../../../test.js';\n      expect(searchSource.isTestFilePath(path)).toBe(true);\n    });\n\n    it('supports unix separators', () => {\n      if (process.platform !== 'win32') {\n        const path = '/path/to/__tests__/test.js';\n        expect(searchSource.isTestFilePath(path)).toBe(true);\n      }\n    });\n\n    it('supports win32 separators', () => {\n      if (process.platform === 'win32') {\n        const path = '\\\\path\\\\to\\\\__tests__\\\\test.js';\n        expect(searchSource.isTestFilePath(path)).toBe(true);\n      }\n    });\n  });\n\n  describe('getTestPaths', () => {\n    const getTestPaths = async (\n      initialOptions: Config.InitialOptions,\n      filter?: Filter,\n    ) => {\n      const {searchSource, config} = await initSearchSource(initialOptions);\n      const allConfig = {\n        ...config,\n        ...initialOptions,\n        testPathPatterns: new TestPathPatterns([]),\n      };\n      const {tests: paths} = await searchSource.getTestPaths(\n        allConfig,\n        allConfig,\n        null,\n        filter,\n      );\n      return paths.map(({path: p}) => path.relative(rootDir, p)).sort();\n    };\n\n    it('finds tests matching a pattern via testRegex', async () => {\n      const paths = await getTestPaths({\n        id,\n        moduleFileExtensions: ['js', 'jsx', 'txt'],\n        rootDir,\n        testMatch: undefined,\n        testRegex: 'not-really-a-test',\n      });\n      expect(paths).toEqual([\n        path.normalize('.hiddenFolder/not-really-a-test.txt'),\n        path.normalize('__testtests__/not-really-a-test.txt'),\n      ]);\n    });\n\n    it('finds tests matching a pattern via testMatch', async () => {\n      const paths = await getTestPaths({\n        id,\n        moduleFileExtensions: ['js', 'jsx', 'txt'],\n        rootDir,\n        testMatch: ['**/not-really-a-test.txt', '!**/do-not-match-me.txt'],\n        testRegex: '',\n      });\n      expect(paths).toEqual([\n        path.normalize('.hiddenFolder/not-really-a-test.txt'),\n        path.normalize('__testtests__/not-really-a-test.txt'),\n      ]);\n    });\n\n    it('finds tests matching a JS regex pattern', async () => {\n      const paths = await getTestPaths({\n        id,\n        moduleFileExtensions: ['js', 'jsx'],\n        rootDir,\n        testMatch: undefined,\n        testRegex: 'test.jsx?',\n      });\n      expect(paths).toEqual([\n        path.normalize('__testtests__/test.js'),\n        path.normalize('__testtests__/test.jsx'),\n      ]);\n    });\n\n    it('finds tests matching a JS glob pattern', async () => {\n      const paths = await getTestPaths({\n        id,\n        moduleFileExtensions: ['js', 'jsx'],\n        rootDir,\n        testMatch: ['**/test.js?(x)'],\n        testRegex: '',\n      });\n      expect(paths).toEqual([\n        path.normalize('__testtests__/test.js'),\n        path.normalize('__testtests__/test.jsx'),\n      ]);\n    });\n\n    it('finds tests matching a JS with overriding glob patterns', async () => {\n      const paths = await getTestPaths({\n        id,\n        moduleFileExtensions: ['js', 'jsx'],\n        rootDir,\n        testMatch: [\n          '**/*.js?(x)',\n          '!**/test.js?(x)',\n          '**/test.js',\n          '!**/test.js',\n        ],\n        testRegex: '',\n      });\n      expect(paths).toEqual([\n        path.normalize('module.jsx'),\n        path.normalize('noTests.js'),\n      ]);\n    });\n\n    it('finds tests with default file extensions using testRegex', async () => {\n      const paths = await getTestPaths({\n        id,\n        rootDir,\n        testMatch: undefined,\n        testRegex,\n      });\n      expect(paths).toEqual([\n        path.normalize('__testtests__/test.js'),\n        path.normalize('__testtests__/test.jsx'),\n      ]);\n    });\n\n    it('finds tests with default file extensions using testMatch', async () => {\n      const paths = await getTestPaths({\n        id,\n        rootDir,\n        testMatch,\n        testRegex: '',\n      });\n      expect(paths).toEqual([\n        path.normalize('__testtests__/test.js'),\n        path.normalize('__testtests__/test.jsx'),\n      ]);\n    });\n\n    it('finds tests with parentheses in their rootDir when using testMatch', async () => {\n      const paths = await getTestPaths({\n        id,\n        rootDir: path.resolve(__dirname, 'test_root_with_(parentheses)'),\n        testMatch: ['<rootDir>**/__testtests__/**/*'],\n        testRegex: undefined,\n      });\n      expect(paths).toEqual([\n        expect.stringContaining(path.normalize('__testtests__/test.js')),\n      ]);\n    });\n\n    it('finds tests with similar but custom file extensions', async () => {\n      const paths = await getTestPaths({\n        id,\n        moduleFileExtensions: ['js', 'jsx'],\n        rootDir,\n        testMatch,\n      });\n      expect(paths).toEqual([\n        path.normalize('__testtests__/test.js'),\n        path.normalize('__testtests__/test.jsx'),\n      ]);\n    });\n\n    it('finds tests with totally custom foobar file extensions', async () => {\n      const paths = await getTestPaths({\n        id,\n        moduleFileExtensions: ['js', 'foobar'],\n        rootDir,\n        testMatch,\n      });\n      expect(paths).toEqual([\n        path.normalize('__testtests__/test.foobar'),\n        path.normalize('__testtests__/test.js'),\n      ]);\n    });\n\n    it('finds tests with many kinds of file extensions', async () => {\n      const paths = await getTestPaths({\n        id,\n        moduleFileExtensions: ['js', 'jsx'],\n        rootDir,\n        testMatch,\n      });\n      expect(paths).toEqual([\n        path.normalize('__testtests__/test.js'),\n        path.normalize('__testtests__/test.jsx'),\n      ]);\n    });\n\n    it('finds tests using a regex only', async () => {\n      const paths = await getTestPaths({\n        id,\n        rootDir,\n        testMatch: undefined,\n        testRegex,\n      });\n      expect(paths).toEqual([\n        path.normalize('__testtests__/test.js'),\n        path.normalize('__testtests__/test.jsx'),\n      ]);\n    });\n\n    it('finds tests using a glob only', async () => {\n      const paths = await getTestPaths({\n        id,\n        rootDir,\n        testMatch,\n        testRegex: '',\n      });\n      expect(paths).toEqual([\n        path.normalize('__testtests__/test.js'),\n        path.normalize('__testtests__/test.jsx'),\n      ]);\n    });\n\n    it('filter tests based on an optional filter method', async () => {\n      const filterFunction = (testPaths: Array<string>) =>\n        Promise.resolve({\n          filtered: testPaths.filter(testPath => testPath.includes('test.jsx')),\n        });\n      const paths = await getTestPaths(\n        {\n          id,\n          rootDir,\n        },\n        filterFunction,\n      );\n\n      expect(paths).toHaveLength(1);\n      expect(paths[0]).toStrictEqual(path.normalize('__testtests__/test.jsx'));\n    });\n  });\n\n  describe('filterPathsWin32', () => {\n    beforeEach(async () => {\n      ({searchSource} = await initSearchSource(\n        {\n          id,\n          rootDir: '.',\n          roots: [],\n        },\n        {\n          contextFiles: [\n            path.resolve('packages/lib/my-lib.ts'),\n            path.resolve('packages/@core/my-app.ts'),\n            path.resolve('packages/+cli/my-cli.ts'),\n            path.resolve('packages/.hidden/my-app-hidden.ts'),\n            path.resolve('packages/programs (x86)/my-program.ts'),\n          ],\n        },\n      ));\n    });\n\n    it('should allow a simple match', async () => {\n      const result = searchSource.filterPathsWin32(['packages/lib/my-lib.ts']);\n      expect(result).toEqual([path.resolve('packages/lib/my-lib.ts')]);\n    });\n    it('should allow to match a file inside a hidden directory', async () => {\n      const result = searchSource.filterPathsWin32([\n        'packages/.hidden/my-app-hidden.ts',\n      ]);\n      expect(result).toEqual([\n        path.resolve('packages/.hidden/my-app-hidden.ts'),\n      ]);\n    });\n    it('should allow to match a file inside a directory prefixed with a \"@\"', async () => {\n      const result = searchSource.filterPathsWin32([\n        'packages/@core/my-app.ts',\n      ]);\n      expect(result).toEqual([path.resolve('packages/@core/my-app.ts')]);\n    });\n    it('should allow to match a file inside a directory prefixed with a \"+\"', async () => {\n      const result = searchSource.filterPathsWin32(['packages/+cli/my-cli.ts']);\n      expect(result).toEqual([path.resolve('packages/+cli/my-cli.ts')]);\n    });\n    it('should allow an @(pattern)', () => {\n      const result = searchSource.filterPathsWin32([\n        'packages/@(@core)/my-app.ts',\n      ]);\n      expect(result).toEqual([path.resolve('packages/@core/my-app.ts')]);\n    });\n    it('should allow a +(pattern)', () => {\n      const result = searchSource.filterPathsWin32([\n        'packages/+(@core)/my-app.ts',\n      ]);\n      expect(result).toEqual([path.resolve('packages/@core/my-app.ts')]);\n    });\n    it('should allow for (pattern) in file path', () => {\n      const result = searchSource.filterPathsWin32([\n        'packages/programs (x86)/my-program.ts',\n      ]);\n      expect(result).toEqual([\n        path.resolve('packages/programs (x86)/my-program.ts'),\n      ]);\n    });\n    it('should allow no results found', () => {\n      const result = searchSource.filterPathsWin32(['not/exists']);\n      expect(result).toHaveLength(0);\n    });\n  });\n\n  describe('findRelatedTests', () => {\n    const rootDir = path.join(\n      __dirname,\n      '..',\n      '..',\n      '..',\n      'jest-runtime',\n      'src',\n      '__tests__',\n      'test_root',\n    );\n    const rootPath = path.join(rootDir, 'root.js');\n\n    beforeEach(async () => {\n      ({searchSource} = await initSearchSource({\n        haste: {\n          hasteImplModulePath: path.join(\n            __dirname,\n            '..',\n            '..',\n            '..',\n            'jest-haste-map',\n            'src',\n            '__tests__',\n            'haste_impl.js',\n          ),\n        },\n        id: 'SearchSource-findRelatedTests-tests',\n        rootDir,\n      }));\n    });\n\n    it('makes sure a file is related to itself', async () => {\n      const data = await searchSource.findRelatedTests(\n        new Set([rootPath]),\n        false,\n      );\n      expect(toPaths(data.tests)).toEqual([rootPath]);\n    });\n\n    it('finds tests that depend directly on the path', async () => {\n      const filePath = path.join(rootDir, 'RegularModule.js');\n      const file2Path = path.join(rootDir, 'RequireRegularModule.js');\n      const parentDep = path.join(rootDir, 'ModuleWithSideEffects.js');\n      const data = await searchSource.findRelatedTests(\n        new Set([filePath]),\n        false,\n      );\n      expect(toPaths(data.tests).sort()).toEqual([\n        parentDep,\n        filePath,\n        file2Path,\n        rootPath,\n      ]);\n    });\n\n    it('excludes untested files from coverage', async () => {\n      const unrelatedFile = path.join(rootDir, 'JSONFile.json');\n      const regular = path.join(rootDir, 'RegularModule.js');\n      const requireRegular = path.join(rootDir, 'RequireRegularMode.js');\n\n      const data = await searchSource.findRelatedTests(\n        new Set([regular, requireRegular, unrelatedFile]),\n        true,\n      );\n      expect([...(data.collectCoverageFrom || [])]).toEqual([\n        'RegularModule.js',\n      ]);\n    });\n  });\n\n  describe('findRelatedTestsFromPattern', () => {\n    beforeEach(async () => {\n      ({searchSource} = await initSearchSource({\n        id,\n        moduleFileExtensions: ['js', 'jsx', 'foobar'],\n        rootDir,\n        testMatch,\n      }));\n    });\n\n    it('returns empty search result for empty input', async () => {\n      const input: Array<string> = [];\n      const data = await searchSource.findRelatedTestsFromPattern(input, false);\n      expect(data.tests).toEqual([]);\n    });\n\n    it('returns empty search result for invalid input', async () => {\n      const input = ['non-existend.js'];\n      const data = await searchSource.findRelatedTestsFromPattern(input, false);\n      expect(data.tests).toEqual([]);\n    });\n\n    it('returns empty search result if no related tests were found', async () => {\n      const input = ['no_tests.js'];\n      const data = await searchSource.findRelatedTestsFromPattern(input, false);\n      expect(data.tests).toEqual([]);\n    });\n\n    it('finds tests for a single file', async () => {\n      const input = ['packages/jest-core/src/__tests__/test_root/module.jsx'];\n      const data = await searchSource.findRelatedTestsFromPattern(input, false);\n      expect(toPaths(data.tests).sort()).toEqual([\n        path.join(rootDir, '__testtests__', 'test.js'),\n        path.join(rootDir, '__testtests__', 'test.jsx'),\n      ]);\n    });\n\n    it('finds tests for multiple files', async () => {\n      const input = [\n        'packages/jest-core/src/__tests__/test_root/module.jsx',\n        'packages/jest-core/src/__tests__/test_root/module.foobar',\n      ];\n      const data = await searchSource.findRelatedTestsFromPattern(input, false);\n      expect(toPaths(data.tests).sort()).toEqual([\n        path.join(rootDir, '__testtests__', 'test.foobar'),\n        path.join(rootDir, '__testtests__', 'test.js'),\n        path.join(rootDir, '__testtests__', 'test.jsx'),\n      ]);\n    });\n\n    it('does not mistake roots folders with prefix names', async () => {\n      if (process.platform === 'win32') {\n        return;\n      }\n      ({searchSource} = await initSearchSource({\n        id,\n        rootDir: '.',\n        roots: ['/foo/bar/prefix'],\n      }));\n\n      const input = ['/foo/bar/prefix-suffix/__tests__/my-test.test.js'];\n      const data = searchSource.findTestsByPaths(input);\n      expect(data.tests).toEqual([]);\n    });\n  });\n\n  describe('findRelatedSourcesFromTestsInChangedFiles', () => {\n    const rootDir = path.resolve(\n      __dirname,\n      '../../../jest-runtime/src/__tests__/test_root',\n    );\n\n    beforeEach(async () => {\n      ({searchSource} = await initSearchSource({\n        haste: {\n          hasteImplModulePath: path.resolve(\n            __dirname,\n            '../../../jest-haste-map/src/__tests__/haste_impl.js',\n          ),\n        },\n        id: 'SearchSource-findRelatedSourcesFromTestsInChangedFiles-tests',\n        rootDir,\n      }));\n    });\n\n    it('return empty set if no SCM', async () => {\n      const requireRegularModule = path.join(\n        rootDir,\n        'RequireRegularModule.js',\n      );\n      const sources =\n        await searchSource.findRelatedSourcesFromTestsInChangedFiles({\n          changedFiles: new Set([requireRegularModule]),\n          repos: {\n            git: new Set(),\n            hg: new Set(),\n          },\n        });\n      expect(sources).toEqual([]);\n    });\n\n    it('return sources required by tests', async () => {\n      const regularModule = path.join(rootDir, 'RegularModule.js');\n      const requireRegularModule = path.join(\n        rootDir,\n        'RequireRegularModule.js',\n      );\n      const sources =\n        await searchSource.findRelatedSourcesFromTestsInChangedFiles({\n          changedFiles: new Set([requireRegularModule]),\n          repos: {\n            git: new Set('/path/to/git'),\n            hg: new Set(),\n          },\n        });\n      expect(sources).toEqual([regularModule]);\n    });\n  });\n});\n",
  "packages/jest-core/src/__tests__/SearchSource.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport {};\n",
  "packages/jest-console/src/types.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nexport type LogMessage = string;\n\nexport type LogEntry = {\n  message: LogMessage;\n  origin: string;\n  type: LogType;\n};\n\nexport type LogCounters = {\n  [label: string]: number;\n};\n\nexport type LogTimers = {\n  [label: string]: Date;\n};\n\nexport type LogType =\n  | 'assert'\n  | 'count'\n  | 'debug'\n  | 'dir'\n  | 'dirxml'\n  | 'error'\n  | 'group'\n  | 'groupCollapsed'\n  | 'info'\n  | 'log'\n  | 'time'\n  | 'warn';\n\nexport type ConsoleBuffer = Array<LogEntry>;\n",
  "packages/jest-console/src/types.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport type LogMessage = string;\nexport type LogEntry = {\n    message: LogMessage;\n    origin: string;\n    type: LogType;\n};\nexport type LogCounters = {\n    [label: string]: number;\n};\nexport type LogTimers = {\n    [label: string]: Date;\n};\nexport type LogType = 'assert' | 'count' | 'debug' | 'dir' | 'dirxml' | 'error' | 'group' | 'groupCollapsed' | 'info' | 'log' | 'time' | 'warn';\nexport type ConsoleBuffer = Array<LogEntry>;\n",
  "packages/jest-console/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nexport {default as BufferedConsole} from './BufferedConsole';\nexport {default as CustomConsole} from './CustomConsole';\nexport {default as NullConsole} from './NullConsole';\nexport {default as getConsoleOutput} from './getConsoleOutput';\nexport type {ConsoleBuffer, LogMessage, LogType, LogEntry} from './types';\n",
  "packages/jest-console/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport { default as BufferedConsole } from './BufferedConsole';\nexport { default as CustomConsole } from './CustomConsole';\nexport { default as NullConsole } from './NullConsole';\nexport { default as getConsoleOutput } from './getConsoleOutput';\nexport type { ConsoleBuffer, LogMessage, LogType, LogEntry } from './types';\n",
  "packages/jest-console/src/getConsoleOutput.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk from 'chalk';\nimport type {Config} from '@jest/types';\nimport {\n  type StackTraceConfig,\n  type StackTraceOptions,\n  formatStackTrace,\n} from 'jest-message-util';\nimport type {ConsoleBuffer} from './types';\n\nexport default function getConsoleOutput(\n  buffer: ConsoleBuffer,\n  config: StackTraceConfig,\n  globalConfig: Config.GlobalConfig,\n): string {\n  const TITLE_INDENT =\n    globalConfig.verbose === true ? ' '.repeat(2) : ' '.repeat(4);\n  const CONSOLE_INDENT = TITLE_INDENT + ' '.repeat(2);\n\n  const logEntries = buffer.reduce((output, {type, message, origin}) => {\n    message = message\n      .split(/\\n/)\n      .map(line => CONSOLE_INDENT + line)\n      .join('\\n');\n\n    let typeMessage = `console.${type}`;\n    let noStackTrace = true;\n    let noCodeFrame = true;\n\n    if (type === 'warn') {\n      message = chalk.yellow(message);\n      typeMessage = chalk.yellow(typeMessage);\n      noStackTrace = globalConfig?.noStackTrace ?? false;\n      noCodeFrame = false;\n    } else if (type === 'error') {\n      message = chalk.red(message);\n      typeMessage = chalk.red(typeMessage);\n      noStackTrace = globalConfig?.noStackTrace ?? false;\n      noCodeFrame = false;\n    }\n\n    const options: StackTraceOptions = {\n      noCodeFrame,\n      noStackTrace,\n    };\n\n    const formattedStackTrace = formatStackTrace(origin, config, options);\n\n    return `${\n      output + TITLE_INDENT + chalk.dim(typeMessage)\n    }\\n${message.trimEnd()}\\n${chalk.dim(formattedStackTrace.trimEnd())}\\n\\n`;\n  }, '');\n\n  return `${logEntries.trimEnd()}\\n`;\n}\n",
  "packages/jest-console/src/getConsoleOutput.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config } from '@jest/types';\nimport { type StackTraceConfig } from 'jest-message-util';\nimport type { ConsoleBuffer } from './types';\nexport default function getConsoleOutput(buffer: ConsoleBuffer, config: StackTraceConfig, globalConfig: Config.GlobalConfig): string;\n",
  "packages/jest-console/src/NullConsole.ts": "/* eslint-disable @typescript-eslint/no-empty-function */\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport CustomConsole from './CustomConsole';\n\nexport default class NullConsole extends CustomConsole {\n  override assert(): void {}\n  override debug(): void {}\n  override dir(): void {}\n  override error(): void {}\n  override info(): void {}\n  override log(): void {}\n  override time(): void {}\n  override timeEnd(): void {}\n  override timeLog(): void {}\n  override trace(): void {}\n  override warn(): void {}\n  override group(): void {}\n  override groupCollapsed(): void {}\n  override groupEnd(): void {}\n}\n",
  "packages/jest-console/src/NullConsole.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport CustomConsole from './CustomConsole';\nexport default class NullConsole extends CustomConsole {\n    assert(): void;\n    debug(): void;\n    dir(): void;\n    error(): void;\n    info(): void;\n    log(): void;\n    time(): void;\n    timeEnd(): void;\n    timeLog(): void;\n    trace(): void;\n    warn(): void;\n    group(): void;\n    groupCollapsed(): void;\n    groupEnd(): void;\n}\n",
  "packages/jest-console/src/CustomConsole.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {AssertionError, strict as assert} from 'assert';\nimport {Console} from 'console';\nimport type {WriteStream} from 'tty';\nimport {type InspectOptions, format, formatWithOptions, inspect} from 'util';\nimport chalk from 'chalk';\nimport {clearLine, formatTime} from 'jest-util';\nimport type {LogCounters, LogMessage, LogTimers, LogType} from './types';\n\ntype Formatter = (type: LogType, message: LogMessage) => string;\n\nexport default class CustomConsole extends Console {\n  private readonly _stdout: WriteStream;\n  private readonly _stderr: WriteStream;\n  private readonly _formatBuffer: Formatter;\n  private _counters: LogCounters = {};\n  private _timers: LogTimers = {};\n  private _groupDepth = 0;\n\n  override Console: typeof Console = Console;\n\n  constructor(\n    stdout: WriteStream,\n    stderr: WriteStream,\n    formatBuffer: Formatter = (_type, message) => message,\n  ) {\n    super(stdout, stderr);\n    this._stdout = stdout;\n    this._stderr = stderr;\n    this._formatBuffer = formatBuffer;\n  }\n\n  private _log(type: LogType, message: string) {\n    clearLine(this._stdout);\n    super.log(\n      this._formatBuffer(type, '  '.repeat(this._groupDepth) + message),\n    );\n  }\n\n  private _logError(type: LogType, message: string) {\n    clearLine(this._stderr);\n    super.error(\n      this._formatBuffer(type, '  '.repeat(this._groupDepth) + message),\n    );\n  }\n\n  override assert(value: unknown, message?: string | Error): asserts value {\n    try {\n      assert.ok(value, message);\n    } catch (error) {\n      if (!(error instanceof AssertionError)) {\n        throw error;\n      }\n      // https://github.com/jestjs/jest/pull/13422#issuecomment-1273396392\n      this._logError('assert', error.toString().replaceAll(/:\\n\\n.*\\n/gs, ''));\n    }\n  }\n\n  override count(label = 'default'): void {\n    if (!this._counters[label]) {\n      this._counters[label] = 0;\n    }\n\n    this._log('count', format(`${label}: ${++this._counters[label]}`));\n  }\n\n  override countReset(label = 'default'): void {\n    this._counters[label] = 0;\n  }\n\n  override debug(firstArg: unknown, ...args: Array<unknown>): void {\n    this._log('debug', format(firstArg, ...args));\n  }\n\n  override dir(firstArg: unknown, options: InspectOptions = {}): void {\n    const representation = inspect(firstArg, options);\n    this._log('dir', formatWithOptions(options, representation));\n  }\n\n  override dirxml(firstArg: unknown, ...args: Array<unknown>): void {\n    this._log('dirxml', format(firstArg, ...args));\n  }\n\n  override error(firstArg: unknown, ...args: Array<unknown>): void {\n    this._logError('error', format(firstArg, ...args));\n  }\n\n  override group(title?: string, ...args: Array<unknown>): void {\n    this._groupDepth++;\n\n    if (title != null || args.length > 0) {\n      this._log('group', chalk.bold(format(title, ...args)));\n    }\n  }\n\n  override groupCollapsed(title?: string, ...args: Array<unknown>): void {\n    this._groupDepth++;\n\n    if (title != null || args.length > 0) {\n      this._log('groupCollapsed', chalk.bold(format(title, ...args)));\n    }\n  }\n\n  override groupEnd(): void {\n    if (this._groupDepth > 0) {\n      this._groupDepth--;\n    }\n  }\n\n  override info(firstArg: unknown, ...args: Array<unknown>): void {\n    this._log('info', format(firstArg, ...args));\n  }\n\n  override log(firstArg: unknown, ...args: Array<unknown>): void {\n    this._log('log', format(firstArg, ...args));\n  }\n\n  override time(label = 'default'): void {\n    if (this._timers[label] != null) {\n      return;\n    }\n\n    this._timers[label] = new Date();\n  }\n\n  override timeEnd(label = 'default'): void {\n    const startTime = this._timers[label];\n\n    if (startTime != null) {\n      const endTime = Date.now();\n      const time = endTime - startTime.getTime();\n      this._log('time', format(`${label}: ${formatTime(time)}`));\n      delete this._timers[label];\n    }\n  }\n\n  override timeLog(label = 'default', ...data: Array<unknown>): void {\n    const startTime = this._timers[label];\n\n    if (startTime != null) {\n      const endTime = new Date();\n      const time = endTime.getTime() - startTime.getTime();\n      this._log('time', format(`${label}: ${formatTime(time)}`, ...data));\n    }\n  }\n\n  override warn(firstArg: unknown, ...args: Array<unknown>): void {\n    this._logError('warn', format(firstArg, ...args));\n  }\n\n  getBuffer(): undefined {\n    return undefined;\n  }\n}\n",
  "packages/jest-console/src/CustomConsole.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { Console } from 'console';\nimport type { WriteStream } from 'tty';\nimport { type InspectOptions } from 'util';\nimport type { LogMessage, LogType } from './types';\ntype Formatter = (type: LogType, message: LogMessage) => string;\nexport default class CustomConsole extends Console {\n    private readonly _stdout;\n    private readonly _stderr;\n    private readonly _formatBuffer;\n    private _counters;\n    private _timers;\n    private _groupDepth;\n    Console: typeof Console;\n    constructor(stdout: WriteStream, stderr: WriteStream, formatBuffer?: Formatter);\n    private _log;\n    private _logError;\n    assert(value: unknown, message?: string | Error): asserts value;\n    count(label?: string): void;\n    countReset(label?: string): void;\n    debug(firstArg: unknown, ...args: Array<unknown>): void;\n    dir(firstArg: unknown, options?: InspectOptions): void;\n    dirxml(firstArg: unknown, ...args: Array<unknown>): void;\n    error(firstArg: unknown, ...args: Array<unknown>): void;\n    group(title?: string, ...args: Array<unknown>): void;\n    groupCollapsed(title?: string, ...args: Array<unknown>): void;\n    groupEnd(): void;\n    info(firstArg: unknown, ...args: Array<unknown>): void;\n    log(firstArg: unknown, ...args: Array<unknown>): void;\n    time(label?: string): void;\n    timeEnd(label?: string): void;\n    timeLog(label?: string, ...data: Array<unknown>): void;\n    warn(firstArg: unknown, ...args: Array<unknown>): void;\n    getBuffer(): undefined;\n}\nexport {};\n",
  "packages/jest-console/src/BufferedConsole.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {AssertionError, strict as assert} from 'assert';\nimport {Console} from 'console';\nimport {type InspectOptions, format, formatWithOptions, inspect} from 'util';\nimport chalk from 'chalk';\nimport {ErrorWithStack, formatTime, invariant} from 'jest-util';\nimport type {\n  ConsoleBuffer,\n  LogCounters,\n  LogMessage,\n  LogTimers,\n  LogType,\n} from './types';\n\nexport default class BufferedConsole extends Console {\n  private readonly _buffer: ConsoleBuffer = [];\n  private _counters: LogCounters = {};\n  private _timers: LogTimers = {};\n  private _groupDepth = 0;\n\n  override Console: typeof Console = Console;\n\n  constructor() {\n    super({\n      write: (message: string) => {\n        BufferedConsole.write(this._buffer, 'log', message);\n\n        return true;\n      },\n    } as NodeJS.WritableStream);\n  }\n\n  static write(\n    this: void,\n    buffer: ConsoleBuffer,\n    type: LogType,\n    message: LogMessage,\n    stackLevel = 2,\n  ): ConsoleBuffer {\n    const rawStack = new ErrorWithStack(undefined, BufferedConsole.write).stack;\n\n    invariant(rawStack != null, 'always have a stack trace');\n\n    const origin = rawStack\n      .split('\\n')\n      .slice(stackLevel)\n      .filter(Boolean)\n      .join('\\n');\n\n    buffer.push({\n      message,\n      origin,\n      type,\n    });\n\n    return buffer;\n  }\n\n  private _log(type: LogType, message: LogMessage) {\n    BufferedConsole.write(\n      this._buffer,\n      type,\n      '  '.repeat(this._groupDepth) + message,\n      3,\n    );\n  }\n\n  override assert(value: unknown, message?: string | Error): void {\n    try {\n      assert.ok(value, message);\n    } catch (error) {\n      if (!(error instanceof AssertionError)) {\n        throw error;\n      }\n      // https://github.com/jestjs/jest/pull/13422#issuecomment-1273396392\n      this._log('assert', error.toString().replaceAll(/:\\n\\n.*\\n/gs, ''));\n    }\n  }\n\n  override count(label = 'default'): void {\n    if (!this._counters[label]) {\n      this._counters[label] = 0;\n    }\n\n    this._log('count', format(`${label}: ${++this._counters[label]}`));\n  }\n\n  override countReset(label = 'default'): void {\n    this._counters[label] = 0;\n  }\n\n  override debug(firstArg: unknown, ...rest: Array<unknown>): void {\n    this._log('debug', format(firstArg, ...rest));\n  }\n\n  override dir(firstArg: unknown, options: InspectOptions = {}): void {\n    const representation = inspect(firstArg, options);\n    this._log('dir', formatWithOptions(options, representation));\n  }\n\n  override dirxml(firstArg: unknown, ...rest: Array<unknown>): void {\n    this._log('dirxml', format(firstArg, ...rest));\n  }\n\n  override error(firstArg: unknown, ...rest: Array<unknown>): void {\n    this._log('error', format(firstArg, ...rest));\n  }\n\n  override group(title?: string, ...rest: Array<unknown>): void {\n    this._groupDepth++;\n\n    if (title != null || rest.length > 0) {\n      this._log('group', chalk.bold(format(title, ...rest)));\n    }\n  }\n\n  override groupCollapsed(title?: string, ...rest: Array<unknown>): void {\n    this._groupDepth++;\n\n    if (title != null || rest.length > 0) {\n      this._log('groupCollapsed', chalk.bold(format(title, ...rest)));\n    }\n  }\n\n  override groupEnd(): void {\n    if (this._groupDepth > 0) {\n      this._groupDepth--;\n    }\n  }\n\n  override info(firstArg: unknown, ...rest: Array<unknown>): void {\n    this._log('info', format(firstArg, ...rest));\n  }\n\n  override log(firstArg: unknown, ...rest: Array<unknown>): void {\n    this._log('log', format(firstArg, ...rest));\n  }\n\n  override time(label = 'default'): void {\n    if (this._timers[label] != null) {\n      return;\n    }\n\n    this._timers[label] = new Date();\n  }\n\n  override timeEnd(label = 'default'): void {\n    const startTime = this._timers[label];\n\n    if (startTime != null) {\n      const endTime = new Date();\n      const time = endTime.getTime() - startTime.getTime();\n      this._log('time', format(`${label}: ${formatTime(time)}`));\n      delete this._timers[label];\n    }\n  }\n\n  override timeLog(label = 'default', ...data: Array<unknown>): void {\n    const startTime = this._timers[label];\n\n    if (startTime != null) {\n      const endTime = new Date();\n      const time = endTime.getTime() - startTime.getTime();\n      this._log('time', format(`${label}: ${formatTime(time)}`, ...data));\n    }\n  }\n\n  override warn(firstArg: unknown, ...rest: Array<unknown>): void {\n    this._log('warn', format(firstArg, ...rest));\n  }\n\n  getBuffer(): ConsoleBuffer | undefined {\n    return this._buffer.length > 0 ? this._buffer : undefined;\n  }\n}\n",
  "packages/jest-console/src/BufferedConsole.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { Console } from 'console';\nimport { type InspectOptions } from 'util';\nimport type { ConsoleBuffer, LogMessage, LogType } from './types';\nexport default class BufferedConsole extends Console {\n    private readonly _buffer;\n    private _counters;\n    private _timers;\n    private _groupDepth;\n    Console: typeof Console;\n    constructor();\n    static write(this: void, buffer: ConsoleBuffer, type: LogType, message: LogMessage, stackLevel?: number): ConsoleBuffer;\n    private _log;\n    assert(value: unknown, message?: string | Error): void;\n    count(label?: string): void;\n    countReset(label?: string): void;\n    debug(firstArg: unknown, ...rest: Array<unknown>): void;\n    dir(firstArg: unknown, options?: InspectOptions): void;\n    dirxml(firstArg: unknown, ...rest: Array<unknown>): void;\n    error(firstArg: unknown, ...rest: Array<unknown>): void;\n    group(title?: string, ...rest: Array<unknown>): void;\n    groupCollapsed(title?: string, ...rest: Array<unknown>): void;\n    groupEnd(): void;\n    info(firstArg: unknown, ...rest: Array<unknown>): void;\n    log(firstArg: unknown, ...rest: Array<unknown>): void;\n    time(label?: string): void;\n    timeEnd(label?: string): void;\n    timeLog(label?: string, ...data: Array<unknown>): void;\n    warn(firstArg: unknown, ...rest: Array<unknown>): void;\n    getBuffer(): ConsoleBuffer | undefined;\n}\n",
  "packages/jest-console/src/__tests__/getConsoleOutput.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {makeGlobalConfig} from '@jest/test-utils';\nimport {formatStackTrace} from 'jest-message-util';\nimport BufferedConsole from '../BufferedConsole';\nimport getConsoleOutput from '../getConsoleOutput';\n\njest.mock('jest-message-util', () => ({\n  formatStackTrace: jest.fn(),\n}));\n\ndescribe('getConsoleOutput', () => {\n  const globalConfig = makeGlobalConfig({noStackTrace: true});\n  jest\n    .mocked(formatStackTrace)\n    .mockImplementation(() => 'throw new Error(\"Whoops!\");');\n\n  it.each([\n    'assert',\n    'count',\n    'debug',\n    'dir',\n    'dirxml',\n    'error',\n    'group',\n    'groupCollapsed',\n    'info',\n    'log',\n    'time',\n    'warn',\n  ] as const)('takes noStackTrace and pass it on for %s', logType => {\n    getConsoleOutput(\n      BufferedConsole.write([], logType, 'message', 4),\n      {\n        rootDir: 'root',\n        testMatch: [],\n      },\n      globalConfig,\n    );\n    expect(formatStackTrace).toHaveBeenCalled();\n    expect(formatStackTrace).toHaveBeenCalledWith(\n      expect.anything(),\n      expect.anything(),\n      expect.objectContaining({\n        noCodeFrame: expect.anything(),\n        noStackTrace: true,\n      }),\n    );\n  });\n});\n",
  "packages/jest-console/src/__tests__/getConsoleOutput.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-console/src/__tests__/bufferedConsole.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk from 'chalk';\nimport BufferedConsole from '../BufferedConsole';\n\ndescribe('CustomConsole', () => {\n  let _console: BufferedConsole;\n  const stdout = () => {\n    const buffer = _console.getBuffer();\n    if (!buffer) {\n      return '';\n    }\n\n    return buffer.map(log => log.message).join('\\n');\n  };\n\n  beforeEach(() => {\n    _console = new BufferedConsole();\n  });\n\n  describe('assert', () => {\n    test('do not log when the assertion is truthy', () => {\n      _console.assert(true);\n\n      expect(stdout()).toMatch('');\n    });\n\n    test('do not log when the assertion is truthy and there is a message', () => {\n      _console.assert(true, 'ok');\n\n      expect(stdout()).toMatch('');\n    });\n\n    test('log the assertion error when the assertion is falsy', () => {\n      _console.assert(false);\n\n      expect(stdout()).toMatch('AssertionError');\n      expect(stdout()).toMatch(\n        /false == true|The expression evaluated to a falsy value/,\n      );\n    });\n\n    test('log the assertion error when the assertion is falsy with another message argument', () => {\n      _console.assert(false, 'ok');\n\n      expect(stdout()).toMatch('AssertionError');\n      expect(stdout()).toMatch('ok');\n    });\n  });\n\n  describe('count', () => {\n    test('count using the default counter', () => {\n      _console.count();\n      _console.count();\n      _console.count();\n\n      expect(stdout()).toBe('default: 1\\ndefault: 2\\ndefault: 3');\n    });\n\n    test('count using the a labeled counter', () => {\n      _console.count('custom');\n      _console.count('custom');\n      _console.count('custom');\n\n      expect(stdout()).toBe('custom: 1\\ncustom: 2\\ncustom: 3');\n    });\n\n    test('countReset restarts default counter', () => {\n      _console.count();\n      _console.count();\n      _console.countReset();\n      _console.count();\n      expect(stdout()).toBe('default: 1\\ndefault: 2\\ndefault: 1');\n    });\n\n    test('countReset restarts custom counter', () => {\n      _console.count('custom');\n      _console.count('custom');\n      _console.countReset('custom');\n      _console.count('custom');\n\n      expect(stdout()).toBe('custom: 1\\ncustom: 2\\ncustom: 1');\n    });\n  });\n\n  describe('group', () => {\n    test('group without label', () => {\n      _console.group();\n      _console.log('hey');\n      _console.group();\n      _console.log('there');\n\n      expect(stdout()).toBe('  hey\\n    there');\n    });\n\n    test('group with label', () => {\n      _console.group('first');\n      _console.log('hey');\n      _console.group('second');\n      _console.log('there');\n\n      expect(stdout()).toBe(`  ${chalk.bold('first')}\n  hey\n    ${chalk.bold('second')}\n    there`);\n    });\n\n    test('groupEnd remove the indentation of the current group', () => {\n      _console.group();\n      _console.log('hey');\n      _console.groupEnd();\n      _console.log('there');\n\n      expect(stdout()).toBe('  hey\\nthere');\n    });\n\n    test('groupEnd can not remove the indentation below the starting point', () => {\n      _console.groupEnd();\n      _console.groupEnd();\n      _console.group();\n      _console.log('hey');\n      _console.groupEnd();\n      _console.log('there');\n\n      expect(stdout()).toBe('  hey\\nthere');\n    });\n  });\n\n  describe('time', () => {\n    test('should return the time between time() and timeEnd() on default timer', () => {\n      _console.time();\n      _console.timeEnd();\n\n      expect(stdout()).toMatch('default: ');\n      expect(stdout()).toMatch('ms');\n    });\n\n    test('should return the time between time() and timeEnd() on custom timer', () => {\n      _console.time('custom');\n      _console.timeEnd('custom');\n\n      expect(stdout()).toMatch('custom: ');\n      expect(stdout()).toMatch('ms');\n    });\n  });\n\n  describe('dir', () => {\n    test('should print the deepest value', () => {\n      const deepObject = {1: {2: {3: {4: {5: {6: 'value'}}}}}};\n      _console.dir(deepObject, {depth: 6});\n\n      expect(stdout()).toMatch('value');\n      expect(stdout()).not.toMatch('depth');\n    });\n  });\n\n  describe('timeLog', () => {\n    test('should return the time between time() and timeEnd() on default timer', () => {\n      _console.time();\n      _console.timeLog();\n\n      expect(stdout()).toMatch('default: ');\n      expect(stdout()).toMatch('ms');\n      _console.timeEnd();\n    });\n\n    test('should return the time between time() and timeEnd() on custom timer', () => {\n      _console.time('custom');\n      _console.timeLog('custom');\n\n      expect(stdout()).toMatch('custom: ');\n      expect(stdout()).toMatch('ms');\n      _console.timeEnd('custom');\n    });\n\n    test('default timer with data', () => {\n      _console.time();\n      _console.timeLog(undefined, 'foo', 5);\n\n      expect(stdout()).toMatch('default: ');\n      expect(stdout()).toMatch('ms foo 5');\n      _console.timeEnd();\n    });\n\n    test('custom timer with data', () => {\n      _console.time('custom');\n      _console.timeLog('custom', 'foo', 5);\n\n      expect(stdout()).toMatch('custom: ');\n      expect(stdout()).toMatch('ms foo 5');\n      _console.timeEnd('custom');\n    });\n  });\n\n  describe('console', () => {\n    test('should be able to initialize console instance', () => {\n      expect(_console.Console).toBeDefined();\n    });\n  });\n});\n",
  "packages/jest-console/src/__tests__/bufferedConsole.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-console/src/__tests__/CustomConsole.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {Writable} from 'stream';\nimport type {WriteStream} from 'tty';\nimport chalk from 'chalk';\nimport CustomConsole from '../CustomConsole';\n\ndescribe('CustomConsole', () => {\n  let _console: CustomConsole;\n  let _stdout: string;\n  let _stderr: string;\n\n  beforeEach(() => {\n    _stdout = '';\n    _stderr = '';\n\n    const stdout = new Writable({\n      write(chunk: string, _encoding, callback) {\n        _stdout += chunk.toString();\n        callback();\n      },\n    }) as WriteStream;\n\n    const stderr = new Writable({\n      write(chunk: string, _encoding, callback) {\n        _stderr += chunk.toString();\n        callback();\n      },\n    }) as WriteStream;\n\n    _console = new CustomConsole(stdout, stderr);\n  });\n\n  describe('log', () => {\n    test('should print to stdout', () => {\n      _console.log('Hello world!');\n\n      expect(_stdout).toBe('Hello world!\\n');\n    });\n  });\n\n  describe('error', () => {\n    test('should print to stderr', () => {\n      _console.error('Found some error!');\n\n      expect(_stderr).toBe('Found some error!\\n');\n    });\n  });\n\n  describe('warn', () => {\n    test('should print to stderr', () => {\n      _console.warn('Found some warning!');\n\n      expect(_stderr).toBe('Found some warning!\\n');\n    });\n  });\n\n  describe('assert', () => {\n    test('do not log when the assertion is truthy', () => {\n      _console.assert(true);\n\n      expect(_stderr).toMatch('');\n    });\n\n    test('do not log when the assertion is truthy and there is a message', () => {\n      _console.assert(true, 'ok');\n\n      expect(_stderr).toMatch('');\n    });\n\n    test('log the assertion error when the assertion is falsy', () => {\n      _console.assert(false);\n\n      expect(_stderr).toMatch('AssertionError');\n      expect(_stderr).toMatch(\n        // The message may differ across Node versions\n        /(false == true)|(The expression evaluated to a falsy value:)/,\n      );\n    });\n\n    test('log the assertion error when the assertion is falsy with another message argument', () => {\n      _console.assert(false, 'this should not happen');\n\n      expect(_stderr).toMatch('AssertionError');\n      expect(_stderr).toMatch('this should not happen');\n    });\n  });\n\n  describe('count', () => {\n    test('count using the default counter', () => {\n      _console.count();\n      _console.count();\n      _console.count();\n\n      expect(_stdout).toBe('default: 1\\ndefault: 2\\ndefault: 3\\n');\n    });\n\n    test('count using the a labeled counter', () => {\n      _console.count('custom');\n      _console.count('custom');\n      _console.count('custom');\n\n      expect(_stdout).toBe('custom: 1\\ncustom: 2\\ncustom: 3\\n');\n    });\n\n    test('countReset restarts default counter', () => {\n      _console.count();\n      _console.count();\n      _console.countReset();\n      _console.count();\n      expect(_stdout).toBe('default: 1\\ndefault: 2\\ndefault: 1\\n');\n    });\n\n    test('countReset restarts custom counter', () => {\n      _console.count('custom');\n      _console.count('custom');\n      _console.countReset('custom');\n      _console.count('custom');\n\n      expect(_stdout).toBe('custom: 1\\ncustom: 2\\ncustom: 1\\n');\n    });\n  });\n\n  describe('group', () => {\n    test('group without label', () => {\n      _console.group();\n      _console.log('hey');\n      _console.group();\n      _console.log('there');\n\n      expect(_stdout).toBe('  hey\\n    there\\n');\n    });\n\n    test('group with label', () => {\n      _console.group('first');\n      _console.log('hey');\n      _console.group('second');\n      _console.log('there');\n\n      expect(_stdout).toBe(`  ${chalk.bold('first')}\n  hey\n    ${chalk.bold('second')}\n    there\n`);\n    });\n\n    test('groupEnd remove the indentation of the current group', () => {\n      _console.group();\n      _console.log('hey');\n      _console.groupEnd();\n      _console.log('there');\n\n      expect(_stdout).toBe('  hey\\nthere\\n');\n    });\n\n    test('groupEnd can not remove the indentation below the starting point', () => {\n      _console.groupEnd();\n      _console.groupEnd();\n      _console.group();\n      _console.log('hey');\n      _console.groupEnd();\n      _console.log('there');\n\n      expect(_stdout).toBe('  hey\\nthere\\n');\n    });\n  });\n\n  describe('time', () => {\n    test('should return the time between time() and timeEnd() on default timer', () => {\n      _console.time();\n      _console.timeEnd();\n\n      expect(_stdout).toMatch('default: ');\n      expect(_stdout).toMatch('ms');\n    });\n\n    test('should return the time between time() and timeEnd() on custom timer', () => {\n      _console.time('custom');\n      _console.timeEnd('custom');\n\n      expect(_stdout).toMatch('custom: ');\n      expect(_stdout).toMatch('ms');\n    });\n  });\n\n  describe('dir', () => {\n    test('should print the deepest value', () => {\n      const deepObject = {1: {2: {3: {4: {5: {6: 'value'}}}}}};\n      _console.dir(deepObject, {depth: 6});\n\n      expect(_stdout).toMatch('value');\n      expect(_stdout).not.toMatch('depth');\n    });\n  });\n\n  describe('timeLog', () => {\n    test('should return the time between time() and timeEnd() on default timer', () => {\n      _console.time();\n      _console.timeLog();\n\n      expect(_stdout).toMatch('default: ');\n      expect(_stdout).toMatch('ms');\n      _console.timeEnd();\n    });\n\n    test('should return the time between time() and timeEnd() on custom timer', () => {\n      _console.time('custom');\n      _console.timeLog('custom');\n\n      expect(_stdout).toMatch('custom: ');\n      expect(_stdout).toMatch('ms');\n      _console.timeEnd('custom');\n    });\n\n    test('default timer with data', () => {\n      _console.time();\n      _console.timeLog(undefined, 'foo', 5);\n\n      expect(_stdout).toMatch('default: ');\n      expect(_stdout).toMatch('ms foo 5');\n      _console.timeEnd();\n    });\n\n    test('custom timer with data', () => {\n      _console.time('custom');\n      _console.timeLog('custom', 'foo', 5);\n\n      expect(_stdout).toMatch('custom: ');\n      expect(_stdout).toMatch('ms foo 5');\n      _console.timeEnd('custom');\n    });\n  });\n\n  describe('console', () => {\n    test('should be able to initialize console instance', () => {\n      expect(_console.Console).toBeDefined();\n    });\n  });\n});\n",
  "packages/jest-console/src/__tests__/CustomConsole.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-config/src/utils.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport chalk from 'chalk';\nimport Resolver from 'jest-resolve';\nimport {ValidationError} from 'jest-validate';\n\ntype ResolveOptions = {\n  rootDir: string;\n  key: string;\n  filePath: string;\n  optional?: boolean;\n};\n\nexport const BULLET: string = chalk.bold('\\u25CF ');\nexport const DOCUMENTATION_NOTE = `  ${chalk.bold(\n  'Configuration Documentation:',\n)}\n  https://jestjs.io/docs/configuration\n`;\n\nconst createValidationError = (message: string) =>\n  new ValidationError(`${BULLET}Validation Error`, message, DOCUMENTATION_NOTE);\n\nexport const resolve = (\n  resolver: string | null | undefined,\n  {key, filePath, rootDir, optional}: ResolveOptions,\n): string => {\n  const module = Resolver.findNodeModule(\n    replaceRootDirInPath(rootDir, filePath),\n    {\n      basedir: rootDir,\n      resolver: resolver || undefined,\n    },\n  );\n\n  if (!module && !optional) {\n    throw createValidationError(\n      `  Module ${chalk.bold(filePath)} in the ${chalk.bold(\n        key,\n      )} option was not found.\n         ${chalk.bold('<rootDir>')} is: ${rootDir}`,\n    );\n  }\n  /// can cast as string since nulls will be thrown\n  return module!;\n};\n\nexport const escapeGlobCharacters = (path: string): string =>\n  path.replaceAll(/([!()*?[\\\\\\]{}])/g, '\\\\$1');\n\nexport const replaceRootDirInPath = (\n  rootDir: string,\n  filePath: string,\n): string => {\n  if (!filePath.startsWith('<rootDir>')) {\n    return filePath;\n  }\n\n  return path.resolve(\n    rootDir,\n    path.normalize(`./${filePath.slice('<rootDir>'.length)}`),\n  );\n};\n\nconst _replaceRootDirInObject = <T extends ReplaceRootDirConfigObj>(\n  rootDir: string,\n  config: T,\n): T => {\n  const newConfig = {} as T;\n  for (const configKey in config) {\n    newConfig[configKey] =\n      configKey === 'rootDir'\n        ? config[configKey]\n        : _replaceRootDirTags(rootDir, config[configKey]);\n  }\n  return newConfig;\n};\n\ntype OrArray<T> = T | Array<T>;\ntype ReplaceRootDirConfigObj = Record<string, string>;\ntype ReplaceRootDirConfigValues =\n  | OrArray<ReplaceRootDirConfigObj>\n  | OrArray<RegExp>\n  | OrArray<string>;\n\nexport const _replaceRootDirTags = <T extends ReplaceRootDirConfigValues>(\n  rootDir: string,\n  config: T,\n): T => {\n  if (config == null) {\n    return config;\n  }\n  switch (typeof config) {\n    case 'object':\n      if (Array.isArray(config)) {\n        /// can be string[] or {}[]\n        return config.map(item => _replaceRootDirTags(rootDir, item)) as T;\n      }\n      if (config instanceof RegExp) {\n        return config;\n      }\n\n      return _replaceRootDirInObject(rootDir, config) as T;\n    case 'string':\n      return replaceRootDirInPath(rootDir, config) as T;\n  }\n  return config;\n};\n\ntype JSONString = string & {readonly $$type: never}; // newtype\nexport const isJSONString = (text?: JSONString | string): text is JSONString =>\n  text != null &&\n  typeof text === 'string' &&\n  text.startsWith('{') &&\n  text.endsWith('}');\n",
  "packages/jest-config/src/utils.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\ntype ResolveOptions = {\n    rootDir: string;\n    key: string;\n    filePath: string;\n    optional?: boolean;\n};\nexport declare const BULLET: string;\nexport declare const DOCUMENTATION_NOTE: string;\nexport declare const resolve: (resolver: string | null | undefined, { key, filePath, rootDir, optional }: ResolveOptions) => string;\nexport declare const escapeGlobCharacters: (path: string) => string;\nexport declare const replaceRootDirInPath: (rootDir: string, filePath: string) => string;\ntype OrArray<T> = T | Array<T>;\ntype ReplaceRootDirConfigObj = Record<string, string>;\ntype ReplaceRootDirConfigValues = OrArray<ReplaceRootDirConfigObj> | OrArray<RegExp> | OrArray<string>;\nexport declare const _replaceRootDirTags: <T extends ReplaceRootDirConfigValues>(rootDir: string, config: T) => T;\ntype JSONString = string & {\n    readonly $$type: never;\n};\nexport declare const isJSONString: (text?: JSONString | string) => text is JSONString;\nexport {};\n",
  "packages/jest-config/src/stringToBytes.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nfunction stringToBytes(\n  input: undefined,\n  percentageReference?: number,\n): undefined;\nfunction stringToBytes(input: null, percentageReference?: number): null;\nfunction stringToBytes(\n  input: string | number,\n  percentageReference?: number,\n): number;\n\n/**\n * Converts a string representing an amount of memory to bytes.\n *\n * @param input The value to convert to bytes.\n * @param percentageReference The reference value to use when a '%' value is supplied.\n */\nfunction stringToBytes(\n  input: string | number | null | undefined,\n  percentageReference?: number,\n): number | null | undefined {\n  if (input === null || input === undefined) {\n    return input;\n  }\n\n  if (typeof input === 'string') {\n    if (Number.isNaN(Number.parseFloat(input.slice(-1)))) {\n      // eslint-disable-next-line prefer-const\n      let [, numericString, trailingChars] =\n        input.match(/(.*?)([^\\d.-]+)$/i) || [];\n\n      if (trailingChars && numericString) {\n        const numericValue = Number.parseFloat(numericString);\n        trailingChars = trailingChars.toLowerCase();\n\n        switch (trailingChars) {\n          case '%':\n            input = numericValue / 100;\n            break;\n          case 'kb':\n          case 'k':\n            return numericValue * 1000;\n          case 'kib':\n            return numericValue * 1024;\n          case 'mb':\n          case 'm':\n            return numericValue * 1000 * 1000;\n          case 'mib':\n            return numericValue * 1024 * 1024;\n          case 'gb':\n          case 'g':\n            return numericValue * 1000 * 1000 * 1000;\n          case 'gib':\n            return numericValue * 1024 * 1024 * 1024;\n        }\n      }\n\n      // It ends in some kind of char so we need to do some parsing\n    } else {\n      input = Number.parseFloat(input);\n    }\n  }\n\n  if (typeof input === 'number') {\n    if (input === 0) {\n      return 0;\n    } else if (input <= 1 && input > 0) {\n      if (percentageReference) {\n        return Math.floor(input * percentageReference);\n      } else {\n        throw new Error(\n          'For a percentage based memory limit a percentageReference must be supplied',\n        );\n      }\n    } else if (input > 1) {\n      return Math.floor(input);\n    } else {\n      throw new Error('Unexpected numerical input');\n    }\n  }\n\n  throw new Error('Unexpected input');\n}\n\n// https://github.com/import-js/eslint-plugin-import/issues/1590\nexport default stringToBytes;\n",
  "packages/jest-config/src/stringToBytes.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\ndeclare function stringToBytes(input: undefined, percentageReference?: number): undefined;\ndeclare function stringToBytes(input: null, percentageReference?: number): null;\ndeclare function stringToBytes(input: string | number, percentageReference?: number): number;\nexport default stringToBytes;\n",
  "packages/jest-config/src/setFromArgv.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {Config} from '@jest/types';\nimport {isJSONString} from './utils';\n\nconst specialArgs = new Set(['_', '$0', 'h', 'help', 'config']);\n\nexport default function setFromArgv(\n  options: Config.InitialOptions,\n  argv: Config.Argv,\n): Config.InitialOptions {\n  const argvToOptions = Object.keys(argv).reduce(\n    (options: Record<string, unknown>, key) => {\n      if (argv[key] === undefined || specialArgs.has(key)) {\n        return options;\n      }\n\n      switch (key) {\n        case 'coverage':\n          options.collectCoverage = argv[key];\n          break;\n        case 'json':\n          options.useStderr = argv[key];\n          break;\n        case 'watchAll':\n          options.watch = false;\n          options.watchAll = argv[key];\n          break;\n        case 'env':\n          options.testEnvironment = argv[key];\n          break;\n        case 'config':\n          break;\n        case 'coverageThreshold':\n        case 'globals':\n        case 'haste':\n        case 'moduleNameMapper':\n        case 'testEnvironmentOptions':\n        case 'transform':\n          const str = argv[key];\n          if (isJSONString(str)) {\n            options[key] = JSON.parse(str);\n          }\n          break;\n        default:\n          options[key] = argv[key];\n      }\n      return options;\n    },\n    {},\n  );\n\n  return {\n    ...options,\n    ...(isJSONString(argv.config) ? JSON.parse(argv.config) : null),\n    ...argvToOptions,\n  };\n}\n",
  "packages/jest-config/src/setFromArgv.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config } from '@jest/types';\nexport default function setFromArgv(options: Config.InitialOptions, argv: Config.Argv): Config.InitialOptions;\n",
  "packages/jest-config/src/resolveConfigPath.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport chalk from 'chalk';\nimport * as fs from 'graceful-fs';\nimport slash from 'slash';\nimport {ValidationError} from 'jest-validate';\nimport {\n  JEST_CONFIG_BASE_NAME,\n  JEST_CONFIG_EXT_ORDER,\n  PACKAGE_JSON,\n} from './constants';\nimport {BULLET, DOCUMENTATION_NOTE} from './utils';\n\nconst isFile = (filePath: string) =>\n  fs.existsSync(filePath) && !fs.lstatSync(filePath).isDirectory();\n\nconst getConfigFilename = (ext: string) => JEST_CONFIG_BASE_NAME + ext;\n\nexport default function resolveConfigPath(\n  pathToResolve: string,\n  cwd: string,\n  skipMultipleConfigError = false,\n): string {\n  if (!path.isAbsolute(cwd)) {\n    throw new Error(`\"cwd\" must be an absolute path. cwd: ${cwd}`);\n  }\n  const absolutePath = path.isAbsolute(pathToResolve)\n    ? pathToResolve\n    : path.resolve(cwd, pathToResolve);\n\n  if (isFile(absolutePath)) {\n    return absolutePath;\n  }\n\n  // This is a guard against passing non existing path as a project/config,\n  // that will otherwise result in a very confusing situation.\n  // e.g.\n  // With a directory structure like this:\n  //   my_project/\n  //     package.json\n  //\n  // Passing a `my_project/some_directory_that_doesnt_exist` as a project\n  // name will resolve into a (possibly empty) `my_project/package.json` and\n  // try to run all tests it finds under `my_project` directory.\n  if (!fs.existsSync(absolutePath)) {\n    throw new Error(\n      \"Can't find a root directory while resolving a config file path.\\n\" +\n        `Provided path to resolve: ${pathToResolve}\\n` +\n        `cwd: ${cwd}`,\n    );\n  }\n\n  return resolveConfigPathByTraversing(\n    absolutePath,\n    pathToResolve,\n    cwd,\n    skipMultipleConfigError,\n  );\n}\n\nconst resolveConfigPathByTraversing = (\n  pathToResolve: string,\n  initialPath: string,\n  cwd: string,\n  skipMultipleConfigError: boolean,\n): string => {\n  const configFiles = JEST_CONFIG_EXT_ORDER.map(ext =>\n    path.resolve(pathToResolve, getConfigFilename(ext)),\n  ).filter(isFile);\n\n  const packageJson = findPackageJson(pathToResolve);\n\n  if (packageJson) {\n    const jestKey = getPackageJsonJestKey(packageJson);\n\n    if (jestKey) {\n      if (typeof jestKey === 'string') {\n        const absolutePath = path.isAbsolute(jestKey)\n          ? jestKey\n          : path.resolve(pathToResolve, jestKey);\n\n        if (!isFile(absolutePath)) {\n          throw new ValidationError(\n            `${BULLET}Validation Error`,\n            `  Configuration in ${chalk.bold(packageJson)} is not valid. ` +\n              `Jest expects the string configuration to point to a file, but ${absolutePath} is not. ` +\n              `Please check your Jest configuration in ${chalk.bold(\n                packageJson,\n              )}.`,\n            DOCUMENTATION_NOTE,\n          );\n        }\n\n        configFiles.push(absolutePath);\n      } else {\n        configFiles.push(packageJson);\n      }\n    }\n  }\n\n  if (!skipMultipleConfigError && configFiles.length > 1) {\n    throw new ValidationError(...makeMultipleConfigsErrorMessage(configFiles));\n  }\n\n  if (configFiles.length > 0 || packageJson) {\n    return configFiles[0] ?? packageJson;\n  }\n\n  // This is the system root.\n  // We tried everything, config is nowhere to be found ¯\\_(ツ)_/¯\n  if (pathToResolve === path.dirname(pathToResolve)) {\n    throw new Error(makeResolutionErrorMessage(initialPath, cwd));\n  }\n\n  // go up a level and try it again\n  return resolveConfigPathByTraversing(\n    path.dirname(pathToResolve),\n    initialPath,\n    cwd,\n    skipMultipleConfigError,\n  );\n};\n\nconst findPackageJson = (pathToResolve: string) => {\n  const packagePath = path.resolve(pathToResolve, PACKAGE_JSON);\n  if (isFile(packagePath)) {\n    return packagePath;\n  }\n\n  return undefined;\n};\n\nconst getPackageJsonJestKey = (\n  packagePath: string,\n): Record<string, unknown> | string | undefined => {\n  try {\n    const content = fs.readFileSync(packagePath, 'utf8');\n    const parsedContent = JSON.parse(content);\n\n    if ('jest' in parsedContent) {\n      return parsedContent.jest;\n    }\n  } catch {}\n  return undefined;\n};\n\nconst makeResolutionErrorMessage = (initialPath: string, cwd: string) =>\n  'Could not find a config file based on provided values:\\n' +\n  `path: \"${initialPath}\"\\n` +\n  `cwd: \"${cwd}\"\\n` +\n  'Config paths must be specified by either a direct path to a config\\n' +\n  'file, or a path to a directory. If directory is given, Jest will try to\\n' +\n  `traverse directory tree up, until it finds one of those files in exact order: ${JEST_CONFIG_EXT_ORDER.map(\n    ext => `\"${getConfigFilename(ext)}\"`,\n  ).join(' or ')}.`;\n\nfunction extraIfPackageJson(configPath: string) {\n  if (configPath.endsWith(PACKAGE_JSON)) {\n    return '`jest` key in ';\n  }\n\n  return '';\n}\n\nconst makeMultipleConfigsErrorMessage = (\n  configPaths: Array<string>,\n): [string, string, string] => [\n  `${BULLET}${chalk.bold('Multiple configurations found')}`,\n  [\n    ...configPaths.map(\n      configPath =>\n        `    * ${extraIfPackageJson(configPath)}${slash(configPath)}`,\n    ),\n    '',\n    '  Implicit config resolution does not allow multiple configuration files.',\n    '  Either remove unused config files or select one explicitly with `--config`.',\n  ].join('\\n'),\n  DOCUMENTATION_NOTE,\n];\n",
  "packages/jest-config/src/resolveConfigPath.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport default function resolveConfigPath(pathToResolve: string, cwd: string, skipMultipleConfigError?: boolean): string;\n",
  "packages/jest-config/src/readConfigFileAndSetRootDir.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {isNativeError} from 'util/types';\nimport * as fs from 'graceful-fs';\nimport parseJson from 'parse-json';\nimport stripJsonComments from 'strip-json-comments';\nimport type {Config} from '@jest/types';\nimport {extract, parse} from 'jest-docblock';\nimport {interopRequireDefault, requireOrImportModule} from 'jest-util';\nimport {\n  JEST_CONFIG_EXT_CTS,\n  JEST_CONFIG_EXT_JSON,\n  JEST_CONFIG_EXT_TS,\n  PACKAGE_JSON,\n} from './constants';\n\ninterface TsLoader {\n  enabled: (bool: boolean) => void;\n}\ntype TsLoaderModule = 'ts-node' | 'esbuild-register';\n// Read the configuration and set its `rootDir`\n// 1. If it's a `package.json` file, we look into its \"jest\" property\n// 2. If it's a `jest.config.ts` file, we use `ts-node` to transpile & require it\n// 3. For any other file, we just require it. If we receive an 'ERR_REQUIRE_ESM'\n//    from node, perform a dynamic import instead.\nexport default async function readConfigFileAndSetRootDir(\n  configPath: string,\n): Promise<Config.InitialOptions> {\n  const isTS =\n    configPath.endsWith(JEST_CONFIG_EXT_TS) ||\n    configPath.endsWith(JEST_CONFIG_EXT_CTS);\n  const isJSON = configPath.endsWith(JEST_CONFIG_EXT_JSON);\n  let configObject;\n\n  try {\n    if (isTS) {\n      // @ts-expect-error: Type assertion can be removed once @types/node is updated to 23 https://nodejs.org/api/process.html#processfeaturestypescript\n      if (process.features.typescript) {\n        try {\n          // Try native node TypeScript support first.\n          configObject = await requireOrImportModule<any>(configPath);\n        } catch (requireOrImportModuleError) {\n          if (!(requireOrImportModuleError instanceof SyntaxError)) {\n            throw requireOrImportModuleError;\n          }\n          try {\n            // Likely ESM in a file interpreted as CJS, which means it needs to be\n            // compiled. We ignore the error and try to load it with a loader.\n            configObject = await loadTSConfigFile(configPath);\n          } catch (loadTSConfigFileError) {\n            // If we still encounter an error, we throw both messages combined.\n            // This string is caught further down and merged into a new error message.\n            // eslint-disable-next-line no-throw-literal\n            throw (\n              // Preamble text is added further down:\n              // Jest: Failed to parse the TypeScript config file ${configPath}\\n\n              '  both with the native node TypeScript support and configured TypeScript loaders.\\n' +\n              '    Errors were:\\n' +\n              `    - ${requireOrImportModuleError}\\n` +\n              `    - ${loadTSConfigFileError}`\n            );\n          }\n        }\n      } else {\n        configObject = await loadTSConfigFile(configPath);\n      }\n    } else if (isJSON) {\n      const fileContent = fs.readFileSync(configPath, 'utf8');\n      configObject = parseJson(stripJsonComments(fileContent), configPath);\n    } else {\n      configObject = await requireOrImportModule<any>(configPath);\n    }\n  } catch (error) {\n    if (isTS) {\n      throw new Error(\n        `Jest: Failed to parse the TypeScript config file ${configPath}\\n` +\n          `  ${error}`,\n      );\n    }\n\n    throw error;\n  }\n\n  if (configPath.endsWith(PACKAGE_JSON)) {\n    // Event if there's no \"jest\" property in package.json we will still use\n    // an empty object.\n    configObject = configObject.jest || {};\n  }\n\n  if (typeof configObject === 'function') {\n    configObject = await configObject();\n  }\n\n  if (configObject.rootDir) {\n    // We don't touch it if it has an absolute path specified\n    if (!path.isAbsolute(configObject.rootDir)) {\n      // otherwise, we'll resolve it relative to the file's __dirname\n      configObject = {\n        ...configObject,\n        rootDir: path.resolve(path.dirname(configPath), configObject.rootDir),\n      };\n    }\n  } else {\n    // If rootDir is not there, we'll set it to this file's __dirname\n    configObject = {\n      ...configObject,\n      rootDir: path.dirname(configPath),\n    };\n  }\n\n  return configObject;\n}\n\n// Load the TypeScript configuration\nlet extraTSLoaderOptions: Record<string, unknown>;\n\nconst loadTSConfigFile = async (\n  configPath: string,\n): Promise<Config.InitialOptions> => {\n  // Get registered TypeScript compiler instance\n  const docblockPragmas = parse(extract(fs.readFileSync(configPath, 'utf8')));\n  const tsLoader = docblockPragmas['jest-config-loader'] || 'ts-node';\n  const docblockTSLoaderOptions = docblockPragmas['jest-config-loader-options'];\n\n  if (typeof docblockTSLoaderOptions === 'string') {\n    extraTSLoaderOptions = JSON.parse(docblockTSLoaderOptions);\n  }\n  if (Array.isArray(tsLoader)) {\n    throw new TypeError(\n      `Jest: You can only define a single loader through docblocks, got \"${tsLoader.join(\n        ', ',\n      )}\"`,\n    );\n  }\n\n  const registeredCompiler = await getRegisteredCompiler(\n    tsLoader as TsLoaderModule,\n  );\n  registeredCompiler.enabled(true);\n\n  let configObject = interopRequireDefault(require(configPath)).default;\n\n  // In case the config is a function which imports more Typescript code\n  if (typeof configObject === 'function') {\n    configObject = await configObject();\n  }\n\n  registeredCompiler.enabled(false);\n\n  return configObject;\n};\n\nlet registeredCompilerPromise: Promise<TsLoader>;\n\nfunction getRegisteredCompiler(loader: TsLoaderModule) {\n  // Cache the promise to avoid multiple registrations\n  registeredCompilerPromise =\n    registeredCompilerPromise ?? registerTsLoader(loader);\n  return registeredCompilerPromise;\n}\n\nasync function registerTsLoader(loader: TsLoaderModule): Promise<TsLoader> {\n  try {\n    // Register TypeScript compiler instance\n    if (loader === 'ts-node') {\n      const tsLoader = await import(/* webpackIgnore: true */ 'ts-node');\n\n      return tsLoader.register({\n        compilerOptions: {\n          module: 'CommonJS',\n        },\n        moduleTypes: {\n          '**': 'cjs',\n        },\n        ...extraTSLoaderOptions,\n      });\n    } else if (loader === 'esbuild-register') {\n      const tsLoader = await import(\n        /* webpackIgnore: true */ 'esbuild-register/dist/node'\n      );\n\n      let instance: {unregister: () => void} | undefined;\n\n      return {\n        enabled: (bool: boolean) => {\n          if (bool) {\n            instance = tsLoader.register({\n              target: `node${process.version.slice(1)}`,\n              ...extraTSLoaderOptions,\n            });\n          } else {\n            instance?.unregister();\n          }\n        },\n      };\n    }\n\n    throw new Error(\n      `Jest: '${loader}' is not a valid TypeScript configuration loader.`,\n    );\n  } catch (error) {\n    if (\n      isNativeError(error) &&\n      (error as NodeJS.ErrnoException).code === 'ERR_MODULE_NOT_FOUND'\n    ) {\n      throw new Error(\n        `Jest: '${loader}' is required for the TypeScript configuration files. Make sure it is installed\\nError: ${error.message}`,\n      );\n    }\n\n    throw error;\n  }\n}\n",
  "packages/jest-config/src/readConfigFileAndSetRootDir.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config } from '@jest/types';\nexport default function readConfigFileAndSetRootDir(configPath: string): Promise<Config.InitialOptions>;\n",
  "packages/jest-config/src/parseShardPair.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport interface ShardPair {\n  shardCount: number;\n  shardIndex: number;\n}\n\nexport const parseShardPair = (pair: string): ShardPair => {\n  const shardPair = pair\n    .split('/')\n    .filter(d => /^\\d+$/.test(d))\n    .map(d => Number.parseInt(d, 10));\n\n  const [shardIndex, shardCount] = shardPair;\n\n  if (shardPair.length !== 2) {\n    throw new Error(\n      'The shard option requires a string in the format of <n>/<m>.',\n    );\n  }\n\n  if (shardIndex === 0 || shardCount === 0) {\n    throw new Error(\n      'The shard option requires 1-based values, received 0 or lower in the pair.',\n    );\n  }\n\n  if (shardIndex > shardCount) {\n    throw new Error(\n      'The shard option <n>/<m> requires <n> to be lower or equal than <m>.',\n    );\n  }\n\n  return {\n    shardCount,\n    shardIndex,\n  };\n};\n",
  "packages/jest-config/src/parseShardPair.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport interface ShardPair {\n    shardCount: number;\n    shardIndex: number;\n}\nexport declare const parseShardPair: (pair: string) => ShardPair;\n",
  "packages/jest-config/src/normalize.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {createHash} from 'crypto';\nimport {totalmem} from 'os';\nimport * as path from 'path';\nimport chalk from 'chalk';\nimport merge from 'deepmerge';\nimport {glob} from 'glob';\nimport {statSync} from 'graceful-fs';\nimport micromatch from 'micromatch';\nimport {TestPathPatterns} from '@jest/pattern';\nimport type {Config} from '@jest/types';\nimport {replacePathSepForRegex} from 'jest-regex-util';\nimport Resolver, {\n  resolveRunner,\n  resolveSequencer,\n  resolveTestEnvironment,\n  resolveWatchPlugin,\n} from 'jest-resolve';\nimport {\n  clearLine,\n  replacePathSepForGlob,\n  requireOrImportModule,\n  tryRealpath,\n} from 'jest-util';\nimport {ValidationError, validate} from 'jest-validate';\nimport DEFAULT_CONFIG from './Defaults';\nimport DEPRECATED_CONFIG from './Deprecated';\nimport {validateReporters} from './ReporterValidationErrors';\nimport {\n  initialOptions as VALID_CONFIG,\n  initialProjectOptions as VALID_PROJECT_CONFIG,\n} from './ValidConfig';\nimport {getDisplayNameColor} from './color';\nimport {DEFAULT_JS_PATTERN} from './constants';\nimport getMaxWorkers from './getMaxWorkers';\nimport {parseShardPair} from './parseShardPair';\nimport setFromArgv from './setFromArgv';\nimport stringToBytes from './stringToBytes';\nimport {\n  BULLET,\n  DOCUMENTATION_NOTE,\n  _replaceRootDirTags,\n  escapeGlobCharacters,\n  replaceRootDirInPath,\n  resolve,\n} from './utils';\n\nconst ERROR = `${BULLET}Validation Error`;\nconst PRESET_EXTENSIONS = ['.json', '.js', '.cjs', '.mjs'];\nconst PRESET_NAME = 'jest-preset';\n\nexport type AllOptions = Config.ProjectConfig & Config.GlobalConfig;\n\nconst createConfigError = (message: string) =>\n  new ValidationError(ERROR, message, DOCUMENTATION_NOTE);\n\n// we wanna avoid webpack trying to be clever\nconst requireResolve = (module: string) => require.resolve(module);\n\nfunction verifyDirectoryExists(path: string, key: string) {\n  try {\n    const rootStat = statSync(path);\n\n    if (!rootStat.isDirectory()) {\n      throw createConfigError(\n        `  ${chalk.bold(path)} in the ${chalk.bold(\n          key,\n        )} option is not a directory.`,\n      );\n    }\n  } catch (error: any) {\n    if (error instanceof ValidationError) {\n      throw error;\n    }\n\n    if (error.code === 'ENOENT') {\n      throw createConfigError(\n        `  Directory ${chalk.bold(path)} in the ${chalk.bold(\n          key,\n        )} option was not found.`,\n      );\n    }\n\n    // Not sure in which cases `statSync` can throw, so let's just show the underlying error to the user\n    throw createConfigError(\n      `  Got an error trying to find ${chalk.bold(path)} in the ${chalk.bold(\n        key,\n      )} option.\\n\\n  Error was: ${error.message}`,\n    );\n  }\n}\n\nconst mergeOptionWithPreset = <T extends 'moduleNameMapper' | 'transform'>(\n  options: Config.InitialOptions,\n  preset: Config.InitialOptions,\n  optionName: T,\n) => {\n  if (options[optionName] && preset[optionName]) {\n    options[optionName] = {\n      ...options[optionName],\n      ...preset[optionName],\n      ...options[optionName],\n    };\n  }\n};\n\nconst mergeGlobalsWithPreset = (\n  options: Config.InitialOptions,\n  preset: Config.InitialOptions,\n) => {\n  if (options.globals && preset.globals) {\n    options.globals = merge(preset.globals, options.globals);\n  }\n};\n\nconst setupPreset = async (\n  options: Config.InitialOptionsWithRootDir,\n  optionsPreset: string,\n): Promise<Config.InitialOptionsWithRootDir> => {\n  let preset: Config.InitialOptions;\n  const presetPath = replaceRootDirInPath(options.rootDir, optionsPreset);\n  const presetModule = Resolver.findNodeModule(\n    presetPath.startsWith('.')\n      ? presetPath\n      : path.join(presetPath, PRESET_NAME),\n    {\n      basedir: options.rootDir,\n      extensions: PRESET_EXTENSIONS,\n    },\n  );\n\n  try {\n    if (!presetModule) {\n      throw new Error(`Cannot find module '${presetPath}'`);\n    }\n\n    // Force re-evaluation to support multiple projects\n    try {\n      delete require.cache[require.resolve(presetModule)];\n    } catch {}\n\n    preset = await requireOrImportModule(presetModule);\n  } catch (error: any) {\n    if (error instanceof SyntaxError || error instanceof TypeError) {\n      throw createConfigError(\n        `  Preset ${chalk.bold(presetPath)} is invalid:\\n\\n  ${\n          error.message\n        }\\n  ${error.stack}`,\n      );\n    }\n\n    if (error.message.includes('Cannot find module')) {\n      if (error.message.includes(presetPath)) {\n        const preset = Resolver.findNodeModule(presetPath, {\n          basedir: options.rootDir,\n        });\n\n        if (preset) {\n          throw createConfigError(\n            `  Module ${chalk.bold(\n              presetPath,\n            )} should have \"jest-preset.js\" or \"jest-preset.json\" file at the root.`,\n          );\n        }\n        throw createConfigError(\n          `  Preset ${chalk.bold(presetPath)} not found relative to rootDir ${chalk.bold(options.rootDir)}.`,\n        );\n      }\n      throw createConfigError(\n        `  Missing dependency in ${chalk.bold(presetPath)}:\\n\\n  ${\n          error.message\n        }\\n  ${error.stack}`,\n      );\n    }\n\n    throw createConfigError(\n      `  An unknown error occurred in ${chalk.bold(presetPath)}:\\n\\n  ${\n        error.message\n      }\\n  ${error.stack}`,\n    );\n  }\n\n  if (options.setupFiles) {\n    options.setupFiles = [...(preset.setupFiles || []), ...options.setupFiles];\n  }\n  if (options.setupFilesAfterEnv) {\n    options.setupFilesAfterEnv = [\n      ...(preset.setupFilesAfterEnv || []),\n      ...options.setupFilesAfterEnv,\n    ];\n  }\n  if (options.modulePathIgnorePatterns && preset.modulePathIgnorePatterns) {\n    options.modulePathIgnorePatterns = [\n      ...preset.modulePathIgnorePatterns,\n      ...options.modulePathIgnorePatterns,\n    ];\n  }\n  mergeOptionWithPreset(options, preset, 'moduleNameMapper');\n  mergeOptionWithPreset(options, preset, 'transform');\n  mergeGlobalsWithPreset(options, preset);\n\n  return {...preset, ...options};\n};\n\nconst setupBabelJest = (options: Config.InitialOptionsWithRootDir) => {\n  const transform = options.transform;\n  let babelJest;\n  if (transform) {\n    const customJSPattern = Object.keys(transform).find(pattern => {\n      const regex = new RegExp(pattern);\n      return regex.test('a.js') || regex.test('a.jsx');\n    });\n    const customTSPattern = Object.keys(transform).find(pattern => {\n      const regex = new RegExp(pattern);\n      return regex.test('a.ts') || regex.test('a.tsx');\n    });\n\n    for (const pattern of [customJSPattern, customTSPattern]) {\n      if (pattern) {\n        const customTransformer = transform[pattern];\n        if (Array.isArray(customTransformer)) {\n          if (customTransformer[0] === 'babel-jest') {\n            babelJest = require.resolve('babel-jest');\n            customTransformer[0] = babelJest;\n          } else if (customTransformer[0].includes('babel-jest')) {\n            babelJest = customTransformer[0];\n          }\n        } else {\n          if (customTransformer === 'babel-jest') {\n            babelJest = require.resolve('babel-jest');\n            transform[pattern] = babelJest;\n          } else if (customTransformer.includes('babel-jest')) {\n            babelJest = customTransformer;\n          }\n        }\n      }\n    }\n  } else {\n    babelJest = require.resolve('babel-jest');\n    options.transform = {\n      [DEFAULT_JS_PATTERN]: babelJest,\n    };\n  }\n};\n\nconst normalizeCollectCoverageFrom = (\n  options: Config.InitialOptions &\n    Required<Pick<Config.InitialOptions, 'collectCoverageFrom'>>,\n  key: keyof Pick<Config.InitialOptions, 'collectCoverageFrom'>,\n) => {\n  const initialCollectCoverageFrom = options[key];\n  let value: Array<string> | undefined;\n  if (!initialCollectCoverageFrom) {\n    value = [];\n  }\n\n  if (Array.isArray(initialCollectCoverageFrom)) {\n    value = initialCollectCoverageFrom;\n  } else {\n    try {\n      value = JSON.parse(initialCollectCoverageFrom);\n    } catch {}\n\n    if (options[key] && !Array.isArray(value)) {\n      value = [initialCollectCoverageFrom];\n    }\n  }\n\n  if (value) {\n    value = value.map(filePath =>\n      filePath.replace(/^(!?)(<rootDir>\\/)(.*)/, '$1$3'),\n    );\n  }\n\n  return value;\n};\n\nconst normalizeUnmockedModulePathPatterns = (\n  options: Config.InitialOptionsWithRootDir,\n  key: keyof Pick<\n    Config.InitialOptions,\n    | 'coveragePathIgnorePatterns'\n    | 'modulePathIgnorePatterns'\n    | 'testPathIgnorePatterns'\n    | 'transformIgnorePatterns'\n    | 'watchPathIgnorePatterns'\n    | 'unmockedModulePathPatterns'\n  >,\n) =>\n  // _replaceRootDirTags is specifically well-suited for substituting\n  // <rootDir> in paths (it deals with properly interpreting relative path\n  // separators, etc).\n  //\n  // For patterns, direct global substitution is far more ideal, so we\n  // special case substitutions for patterns here.\n  options[key]!.map(pattern =>\n    replacePathSepForRegex(pattern.replaceAll('<rootDir>', options.rootDir)),\n  );\n\nconst normalizeMissingOptions = (\n  options: Config.InitialOptionsWithRootDir,\n  configPath: string | null | undefined,\n  projectIndex: number,\n): Config.InitialOptionsWithRootDir => {\n  if (!options.id) {\n    options.id = createHash('sha1')\n      .update(options.rootDir)\n      // In case we load config from some path that has the same root dir\n      .update(configPath || '')\n      .update(String(projectIndex))\n      .digest('hex')\n      .slice(0, 32);\n  }\n\n  if (!options.setupFiles) {\n    options.setupFiles = [];\n  }\n\n  return options;\n};\n\nconst normalizeRootDir = (\n  options: Config.InitialOptions,\n): Config.InitialOptionsWithRootDir => {\n  // Assert that there *is* a rootDir\n  if (!options.rootDir) {\n    throw createConfigError(\n      `  Configuration option ${chalk.bold('rootDir')} must be specified.`,\n    );\n  }\n  options.rootDir = path.normalize(options.rootDir);\n\n  try {\n    // try to resolve windows short paths, ignoring errors (permission errors, mostly)\n    options.rootDir = tryRealpath(options.rootDir);\n  } catch {\n    // ignored\n  }\n\n  verifyDirectoryExists(options.rootDir, 'rootDir');\n\n  return {\n    ...options,\n    rootDir: options.rootDir,\n  };\n};\n\nconst normalizeReporters = ({\n  reporters,\n  rootDir,\n}: Config.InitialOptionsWithRootDir):\n  | Array<Config.ReporterConfig>\n  | undefined => {\n  if (!reporters || !Array.isArray(reporters)) {\n    return undefined;\n  }\n\n  validateReporters(reporters);\n\n  return reporters.map(reporterConfig => {\n    const normalizedReporterConfig: Config.ReporterConfig =\n      typeof reporterConfig === 'string'\n        ? // if reporter config is a string, we wrap it in an array\n          // and pass an empty object for options argument, to normalize\n          // the shape.\n          [reporterConfig, {}]\n        : reporterConfig;\n\n    const reporterPath = replaceRootDirInPath(\n      rootDir,\n      normalizedReporterConfig[0],\n    );\n\n    if (!['default', 'github-actions', 'summary'].includes(reporterPath)) {\n      const reporter = Resolver.findNodeModule(reporterPath, {\n        basedir: rootDir,\n      });\n      if (!reporter) {\n        throw new Resolver.ModuleNotFoundError(\n          'Could not resolve a module for a custom reporter.\\n' +\n            `  Module name: ${reporterPath}`,\n        );\n      }\n      normalizedReporterConfig[0] = reporter;\n    }\n    return normalizedReporterConfig;\n  });\n};\n\nconst buildTestPathPatterns = (argv: Config.Argv): TestPathPatterns => {\n  const patterns = [];\n\n  if (argv._) {\n    patterns.push(...argv._.map(x => x.toString()));\n  }\n  if (argv.testPathPatterns) {\n    patterns.push(...argv.testPathPatterns);\n  }\n\n  const testPathPatterns = new TestPathPatterns(patterns);\n\n  if (!testPathPatterns.isValid()) {\n    clearLine(process.stdout);\n\n    // eslint-disable-next-line no-console\n    console.log(\n      chalk.red(\n        `  Invalid testPattern ${testPathPatterns.toPretty()} supplied. ` +\n          'Running all tests instead.',\n      ),\n    );\n\n    return new TestPathPatterns([]);\n  }\n\n  return testPathPatterns;\n};\n\nfunction printConfig(opts: Array<string>) {\n  const string = opts.map(ext => `'${ext}'`).join(', ');\n\n  return chalk.bold(`extensionsToTreatAsEsm: [${string}]`);\n}\n\nfunction validateExtensionsToTreatAsEsm(\n  extensionsToTreatAsEsm: Config.InitialOptions['extensionsToTreatAsEsm'],\n) {\n  if (!extensionsToTreatAsEsm || extensionsToTreatAsEsm.length === 0) {\n    return;\n  }\n\n  const extensionWithoutDot = extensionsToTreatAsEsm.some(\n    ext => !ext.startsWith('.'),\n  );\n\n  if (extensionWithoutDot) {\n    throw createConfigError(\n      `  Option: ${printConfig(\n        extensionsToTreatAsEsm,\n      )} includes a string that does not start with a period (${chalk.bold(\n        '.',\n      )}).\n  Please change your configuration to ${printConfig(\n    extensionsToTreatAsEsm.map(ext => (ext.startsWith('.') ? ext : `.${ext}`)),\n  )}.`,\n    );\n  }\n\n  if (extensionsToTreatAsEsm.includes('.js')) {\n    throw createConfigError(\n      `  Option: ${printConfig(extensionsToTreatAsEsm)} includes ${chalk.bold(\n        \"'.js'\",\n      )} which is always inferred based on ${chalk.bold(\n        'type',\n      )} in its nearest ${chalk.bold('package.json')}.`,\n    );\n  }\n\n  if (extensionsToTreatAsEsm.includes('.cjs')) {\n    throw createConfigError(\n      `  Option: ${printConfig(extensionsToTreatAsEsm)} includes ${chalk.bold(\n        \"'.cjs'\",\n      )} which is always treated as CommonJS.`,\n    );\n  }\n\n  if (extensionsToTreatAsEsm.includes('.mjs')) {\n    throw createConfigError(\n      `  Option: ${printConfig(extensionsToTreatAsEsm)} includes ${chalk.bold(\n        \"'.mjs'\",\n      )} which is always treated as an ECMAScript Module.`,\n    );\n  }\n}\n\nexport default async function normalize(\n  initialOptions: Config.InitialOptions,\n  argv: Config.Argv,\n  configPath?: string | null,\n  projectIndex = Number.POSITIVE_INFINITY,\n  isProjectOptions?: boolean,\n): Promise<{\n  hasDeprecationWarnings: boolean;\n  options: AllOptions;\n}> {\n  const {hasDeprecationWarnings} = validate(initialOptions, {\n    comment: DOCUMENTATION_NOTE,\n    deprecatedConfig: DEPRECATED_CONFIG,\n    exampleConfig: isProjectOptions ? VALID_PROJECT_CONFIG : VALID_CONFIG,\n    recursiveDenylist: [\n      // 'coverageThreshold' allows to use 'global' and glob strings on the same\n      // level, there's currently no way we can deal with such config\n      'coverageThreshold',\n      'globals',\n      'moduleNameMapper',\n      'testEnvironmentOptions',\n      'transform',\n    ],\n  });\n\n  let options = normalizeMissingOptions(\n    normalizeRootDir(setFromArgv(initialOptions, argv)),\n    configPath,\n    projectIndex,\n  );\n\n  if (options.preset) {\n    options = await setupPreset(options, options.preset);\n  }\n\n  if (!options.setupFilesAfterEnv) {\n    options.setupFilesAfterEnv = [];\n  }\n\n  options.testEnvironment = resolveTestEnvironment({\n    requireResolveFunction: requireResolve,\n    rootDir: options.rootDir,\n    testEnvironment:\n      options.testEnvironment ||\n      require.resolve(DEFAULT_CONFIG.testEnvironment),\n  });\n\n  if (!options.roots) {\n    options.roots = [options.rootDir];\n  }\n\n  if (\n    !options.testRunner ||\n    options.testRunner === 'circus' ||\n    options.testRunner === 'jest-circus' ||\n    options.testRunner === 'jest-circus/runner'\n  ) {\n    options.testRunner = require.resolve('jest-circus/runner');\n  } else if (options.testRunner === 'jasmine2') {\n    try {\n      options.testRunner = require.resolve('jest-jasmine2');\n    } catch (error: any) {\n      if (error.code === 'MODULE_NOT_FOUND') {\n        throw createConfigError(\n          'jest-jasmine is no longer shipped by default with Jest, you need to install it explicitly or provide an absolute path to Jest',\n        );\n      }\n\n      throw error;\n    }\n  }\n\n  if (!options.coverageDirectory) {\n    options.coverageDirectory = path.resolve(options.rootDir, 'coverage');\n  }\n\n  setupBabelJest(options);\n  // TODO: Type this properly\n  const newOptions = {\n    ...DEFAULT_CONFIG,\n  } as unknown as AllOptions;\n\n  if (options.resolver) {\n    newOptions.resolver = resolve(null, {\n      filePath: options.resolver,\n      key: 'resolver',\n      rootDir: options.rootDir,\n    });\n  }\n\n  validateExtensionsToTreatAsEsm(options.extensionsToTreatAsEsm);\n\n  if (options.watchman == null) {\n    options.watchman = DEFAULT_CONFIG.watchman;\n  }\n\n  const optionKeys = Object.keys(options) as Array<keyof Config.InitialOptions>;\n\n  optionKeys.reduce((newOptions, key: keyof Config.InitialOptions) => {\n    // The resolver has been resolved separately; skip it\n    if (key === 'resolver') {\n      return newOptions;\n    }\n\n    // This is cheating, because it claims that all keys of InitialOptions are Required.\n    // We only really know it's Required for oldOptions[key], not for oldOptions.someOtherKey,\n    // so oldOptions[key] is the only way it should be used.\n    const oldOptions = options as Config.InitialOptions &\n      Required<Pick<Config.InitialOptions, typeof key>>;\n    let value;\n    switch (key) {\n      case 'setupFiles':\n      case 'setupFilesAfterEnv':\n      case 'snapshotSerializers':\n        {\n          const option = oldOptions[key];\n          value =\n            option &&\n            option.map(filePath =>\n              resolve(newOptions.resolver, {\n                filePath,\n                key,\n                rootDir: options.rootDir,\n              }),\n            );\n        }\n        break;\n      case 'modulePaths':\n      case 'roots':\n        {\n          const option = oldOptions[key];\n          value =\n            option &&\n            option.map(filePath =>\n              path.resolve(\n                options.rootDir,\n                replaceRootDirInPath(options.rootDir, filePath),\n              ),\n            );\n        }\n        break;\n      case 'collectCoverageFrom':\n        value = normalizeCollectCoverageFrom(oldOptions, key);\n        break;\n      case 'cacheDirectory':\n      case 'coverageDirectory':\n        {\n          const option = oldOptions[key];\n          value =\n            option &&\n            path.resolve(\n              options.rootDir,\n              replaceRootDirInPath(options.rootDir, option),\n            );\n        }\n        break;\n      case 'dependencyExtractor':\n      case 'globalSetup':\n      case 'globalTeardown':\n      case 'runtime':\n      case 'snapshotResolver':\n      case 'testResultsProcessor':\n      case 'testRunner':\n      case 'filter':\n        {\n          const option = oldOptions[key];\n          value =\n            option &&\n            resolve(newOptions.resolver, {\n              filePath: option,\n              key,\n              rootDir: options.rootDir,\n            });\n        }\n        break;\n      case 'runner':\n        {\n          const option = oldOptions[key];\n          value =\n            option &&\n            resolveRunner(newOptions.resolver, {\n              filePath: option,\n              requireResolveFunction: requireResolve,\n              rootDir: options.rootDir,\n            });\n        }\n        break;\n      case 'prettierPath':\n        {\n          // We only want this to throw if \"prettierPath\" is explicitly passed\n          // from config or CLI, and the requested path isn't found. Otherwise we\n          // set it to null and throw an error lazily when it is used.\n\n          const option = oldOptions[key];\n\n          value =\n            option &&\n            resolve(newOptions.resolver, {\n              filePath: option,\n              key,\n              optional: option === DEFAULT_CONFIG[key],\n              rootDir: options.rootDir,\n            });\n        }\n        break;\n      case 'moduleNameMapper':\n        const moduleNameMapper = oldOptions[key];\n        value =\n          moduleNameMapper &&\n          Object.keys(moduleNameMapper).map(regex => {\n            const item = moduleNameMapper && moduleNameMapper[regex];\n            return item && [regex, _replaceRootDirTags(options.rootDir, item)];\n          });\n        break;\n      case 'transform':\n        const transform = oldOptions[key];\n        value =\n          transform &&\n          Object.keys(transform).map(regex => {\n            const transformElement = transform[regex];\n            return [\n              regex,\n              resolve(newOptions.resolver, {\n                filePath: Array.isArray(transformElement)\n                  ? transformElement[0]\n                  : transformElement,\n                key,\n                rootDir: options.rootDir,\n              }),\n              Array.isArray(transformElement) ? transformElement[1] : {},\n            ];\n          });\n        break;\n      case 'reporters':\n        value = normalizeReporters(oldOptions);\n        break;\n      case 'coveragePathIgnorePatterns':\n      case 'modulePathIgnorePatterns':\n      case 'testPathIgnorePatterns':\n      case 'transformIgnorePatterns':\n      case 'watchPathIgnorePatterns':\n      case 'unmockedModulePathPatterns':\n        value = normalizeUnmockedModulePathPatterns(oldOptions, key);\n        break;\n      case 'haste':\n        value = {...oldOptions[key]};\n        if (value.hasteImplModulePath != null) {\n          const resolvedHasteImpl = resolve(newOptions.resolver, {\n            filePath: replaceRootDirInPath(\n              options.rootDir,\n              value.hasteImplModulePath,\n            ),\n            key: 'haste.hasteImplModulePath',\n            rootDir: options.rootDir,\n          });\n\n          value.hasteImplModulePath = resolvedHasteImpl || undefined;\n        }\n        break;\n      case 'projects':\n        value = (oldOptions[key] || [])\n          .map(project =>\n            typeof project === 'string'\n              ? _replaceRootDirTags(options.rootDir, project)\n              : project,\n          )\n          .reduce<Array<string | Config.InitialProjectOptions>>(\n            (projects, project) => {\n              // Project can be specified as globs. If a glob matches any files,\n              // We expand it to these paths. If not, we keep the original path\n              // for the future resolution.\n              const globMatches =\n                typeof project === 'string'\n                  ? glob.sync(project, {windowsPathsNoEscape: true})\n                  : [];\n              const projectEntry =\n                globMatches.length > 0 ? globMatches : project;\n              return [\n                ...projects,\n                ...(Array.isArray(projectEntry)\n                  ? projectEntry\n                  : [projectEntry]),\n              ];\n            },\n            [],\n          );\n        break;\n      case 'moduleDirectories':\n      case 'testMatch':\n        {\n          const option = oldOptions[key];\n          const rawValue =\n            Array.isArray(option) || option == null ? option : [option];\n          const replacedRootDirTags = _replaceRootDirTags(\n            escapeGlobCharacters(options.rootDir),\n            rawValue,\n          );\n\n          if (replacedRootDirTags) {\n            value = Array.isArray(replacedRootDirTags)\n              ? replacedRootDirTags.map(replacePathSepForGlob)\n              : replacePathSepForGlob(replacedRootDirTags);\n          } else {\n            value = replacedRootDirTags;\n          }\n        }\n        break;\n      case 'testRegex':\n        {\n          const option = oldOptions[key];\n          value = option\n            ? (Array.isArray(option) ? option : [option]).map(\n                replacePathSepForRegex,\n              )\n            : [];\n        }\n        break;\n      case 'moduleFileExtensions': {\n        value = oldOptions[key];\n\n        if (\n          Array.isArray(value) && // If it's the wrong type, it can throw at a later time\n          (options.runner === undefined ||\n            options.runner === DEFAULT_CONFIG.runner) && // Only require 'js' for the default jest-runner\n          !value.includes('js')\n        ) {\n          const errorMessage =\n            \"  moduleFileExtensions must include 'js':\\n\" +\n            '  but instead received:\\n' +\n            `    ${chalk.bold.red(JSON.stringify(value))}`;\n\n          // If `js` is not included, any dependency Jest itself injects into\n          // the environment, like jasmine or sourcemap-support, will need to\n          // `require` its modules with a file extension. This is not plausible\n          // in the long run, so it's way easier to just fail hard early.\n          // We might consider throwing if `json` is missing as well, as it's a\n          // fair assumption from modules that they can do\n          // `require('some-package/package') without the trailing `.json` as it\n          // works in Node normally.\n          throw createConfigError(\n            `${errorMessage}\\n  Please change your configuration to include 'js'.`,\n          );\n        }\n\n        break;\n      }\n      case 'bail': {\n        const bail = oldOptions[key];\n        if (typeof bail === 'boolean') {\n          value = bail ? 1 : 0;\n        } else if (typeof bail === 'string') {\n          value = 1;\n          // If Jest is invoked as `jest --bail someTestPattern` then need to\n          // move the pattern from the `bail` configuration and into `argv._`\n          // to be processed as an extra parameter\n          argv._.push(bail);\n        } else {\n          value = oldOptions[key];\n        }\n        break;\n      }\n      case 'displayName': {\n        const displayName = oldOptions[key] as Config.DisplayName;\n        /**\n         * Ensuring that displayName shape is correct here so that the\n         * reporters can trust the shape of the data\n         */\n        if (typeof displayName === 'object') {\n          const {name, color} = displayName;\n          if (\n            !name ||\n            !color ||\n            typeof name !== 'string' ||\n            typeof color !== 'string'\n          ) {\n            const errorMessage =\n              `  Option \"${chalk.bold('displayName')}\" must be of type:\\n\\n` +\n              '  {\\n' +\n              '    name: string;\\n' +\n              '    color: string;\\n' +\n              '  }\\n';\n            throw createConfigError(errorMessage);\n          }\n          value = oldOptions[key];\n        } else {\n          value = {\n            color: getDisplayNameColor(options.runner),\n            name: displayName,\n          };\n        }\n        break;\n      }\n      case 'testTimeout': {\n        if (oldOptions[key] < 0) {\n          throw createConfigError(\n            `  Option \"${chalk.bold('testTimeout')}\" must be a natural number.`,\n          );\n        }\n\n        value = oldOptions[key];\n        break;\n      }\n      case 'snapshotFormat': {\n        value = {...DEFAULT_CONFIG.snapshotFormat, ...oldOptions[key]};\n\n        break;\n      }\n      case 'automock':\n      case 'cache':\n      case 'changedSince':\n      case 'changedFilesWithAncestor':\n      case 'clearMocks':\n      case 'collectCoverage':\n      case 'coverageProvider':\n      case 'coverageReporters':\n      case 'coverageThreshold':\n      case 'detectLeaks':\n      case 'detectOpenHandles':\n      case 'errorOnDeprecated':\n      case 'expand':\n      case 'extensionsToTreatAsEsm':\n      case 'globals':\n      case 'fakeTimers':\n      case 'findRelatedTests':\n      case 'forceCoverageMatch':\n      case 'forceExit':\n      case 'injectGlobals':\n      case 'lastCommit':\n      case 'listTests':\n      case 'logHeapUsage':\n      case 'maxConcurrency':\n      case 'id':\n      case 'noStackTrace':\n      case 'notify':\n      case 'notifyMode':\n      case 'onlyChanged':\n      case 'onlyFailures':\n      case 'openHandlesTimeout':\n      case 'outputFile':\n      case 'passWithNoTests':\n      case 'randomize':\n      case 'replname':\n      case 'resetMocks':\n      case 'resetModules':\n      case 'restoreMocks':\n      case 'rootDir':\n      case 'runTestsByPath':\n      case 'sandboxInjectedGlobals':\n      case 'silent':\n      case 'showSeed':\n      case 'skipFilter':\n      case 'skipNodeResolution':\n      case 'slowTestThreshold':\n      case 'testEnvironment':\n      case 'testEnvironmentOptions':\n      case 'testFailureExitCode':\n      case 'testLocationInResults':\n      case 'testNamePattern':\n      case 'useStderr':\n      case 'verbose':\n      case 'waitForUnhandledRejections':\n      case 'watch':\n      case 'watchAll':\n      case 'watchman':\n      case 'workerThreads':\n        value = oldOptions[key];\n        break;\n      case 'workerIdleMemoryLimit':\n        value = stringToBytes(oldOptions[key], totalmem());\n        break;\n      case 'watchPlugins':\n        value = (oldOptions[key] || []).map(watchPlugin => {\n          if (typeof watchPlugin === 'string') {\n            return {\n              config: {},\n              path: resolveWatchPlugin(newOptions.resolver, {\n                filePath: watchPlugin,\n                requireResolveFunction: requireResolve,\n                rootDir: options.rootDir,\n              }),\n            };\n          } else {\n            return {\n              config: watchPlugin[1] || {},\n              path: resolveWatchPlugin(newOptions.resolver, {\n                filePath: watchPlugin[0],\n                requireResolveFunction: requireResolve,\n                rootDir: options.rootDir,\n              }),\n            };\n          }\n        });\n        break;\n    }\n    // @ts-expect-error: automock is missing in GlobalConfig, so what\n    newOptions[key] = value;\n    return newOptions;\n  }, newOptions);\n\n  if (options.watchman && options.haste?.enableSymlinks) {\n    throw new ValidationError(\n      'Validation Error',\n      'haste.enableSymlinks is incompatible with watchman',\n      'Either set haste.enableSymlinks to false or do not use watchman',\n    );\n  }\n\n  for (const [i, root] of newOptions.roots.entries()) {\n    verifyDirectoryExists(root, `roots[${i}]`);\n  }\n\n  try {\n    // try to resolve windows short paths, ignoring errors (permission errors, mostly)\n    newOptions.cwd = tryRealpath(process.cwd());\n  } catch {\n    // ignored\n  }\n\n  newOptions.testSequencer = resolveSequencer(newOptions.resolver, {\n    filePath:\n      options.testSequencer || require.resolve(DEFAULT_CONFIG.testSequencer),\n    requireResolveFunction: requireResolve,\n    rootDir: options.rootDir,\n  });\n\n  if (newOptions.runner === DEFAULT_CONFIG.runner) {\n    newOptions.runner = require.resolve(newOptions.runner);\n  }\n\n  newOptions.nonFlagArgs = argv._?.map(arg => `${arg}`);\n  const testPathPatterns = buildTestPathPatterns(argv);\n  newOptions.testPathPatterns = testPathPatterns;\n  newOptions.json = !!argv.json;\n\n  newOptions.testFailureExitCode = Number.parseInt(\n    newOptions.testFailureExitCode as unknown as string,\n    10,\n  );\n\n  if (\n    newOptions.lastCommit ||\n    newOptions.changedFilesWithAncestor ||\n    newOptions.changedSince\n  ) {\n    newOptions.onlyChanged = true;\n  }\n\n  if (argv.all) {\n    newOptions.onlyChanged = false;\n    newOptions.onlyFailures = false;\n  } else if (testPathPatterns.isSet()) {\n    // When passing a test path pattern we don't want to only monitor changed\n    // files unless `--watch` is also passed.\n    newOptions.onlyChanged = newOptions.watch;\n  }\n\n  newOptions.randomize = newOptions.randomize || argv.randomize;\n\n  newOptions.showSeed =\n    newOptions.randomize || newOptions.showSeed || argv.showSeed;\n\n  const upperBoundSeedValue = 2 ** 31;\n\n  // bounds are determined by xoroshiro128plus which is used in v8 and is used here (at time of writing)\n  newOptions.seed =\n    argv.seed ??\n    Math.floor((2 ** 32 - 1) * Math.random() - upperBoundSeedValue);\n  if (\n    newOptions.seed < -upperBoundSeedValue ||\n    newOptions.seed > upperBoundSeedValue - 1\n  ) {\n    throw new ValidationError(\n      'Validation Error',\n      `seed value must be between \\`-0x80000000\\` and \\`0x7fffffff\\` inclusive - instead it is ${newOptions.seed}`,\n    );\n  }\n\n  if (!newOptions.onlyChanged) {\n    newOptions.onlyChanged = false;\n  }\n\n  if (!newOptions.lastCommit) {\n    newOptions.lastCommit = false;\n  }\n\n  if (!newOptions.onlyFailures) {\n    newOptions.onlyFailures = false;\n  }\n\n  if (!newOptions.watchAll) {\n    newOptions.watchAll = false;\n  }\n\n  // as unknown since it can happen. We really need to fix the types here\n  if (\n    newOptions.moduleNameMapper === (DEFAULT_CONFIG.moduleNameMapper as unknown)\n  ) {\n    newOptions.moduleNameMapper = [];\n  }\n\n  if (argv.ci != null) {\n    newOptions.ci = argv.ci;\n  }\n\n  newOptions.updateSnapshot =\n    newOptions.ci && !argv.updateSnapshot\n      ? 'none'\n      : argv.updateSnapshot\n        ? 'all'\n        : 'new';\n\n  newOptions.maxConcurrency = Number.parseInt(\n    newOptions.maxConcurrency as unknown as string,\n    10,\n  );\n  newOptions.maxWorkers = getMaxWorkers(argv, options);\n  newOptions.runInBand = argv.runInBand || false;\n\n  if (newOptions.testRegex.length > 0 && options.testMatch) {\n    throw createConfigError(\n      `  Configuration options ${chalk.bold('testMatch')} and` +\n        ` ${chalk.bold('testRegex')} cannot be used together.`,\n    );\n  }\n\n  if (newOptions.testRegex.length > 0 && !options.testMatch) {\n    // Prevent the default testMatch conflicting with any explicitly\n    // configured `testRegex` value\n    newOptions.testMatch = [];\n  }\n\n  // If argv.json is set, coverageReporters shouldn't print a text report.\n  if (argv.json) {\n    newOptions.coverageReporters = (newOptions.coverageReporters || []).filter(\n      reporter => reporter !== 'text',\n    );\n  }\n\n  // If collectCoverage is enabled while using --findRelatedTests we need to\n  // avoid having false negatives in the generated coverage report.\n  // The following: `--findRelatedTests '/rootDir/file1.js' --coverage`\n  // Is transformed to: `--findRelatedTests '/rootDir/file1.js' --coverage --collectCoverageFrom 'file1.js'`\n  // where arguments to `--collectCoverageFrom` should be globs (or relative\n  // paths to the rootDir)\n  if (newOptions.collectCoverage && argv.findRelatedTests) {\n    let collectCoverageFrom = newOptions.nonFlagArgs.map(filename => {\n      filename = replaceRootDirInPath(options.rootDir, filename);\n      return path.isAbsolute(filename)\n        ? path.relative(options.rootDir, filename)\n        : filename;\n    });\n\n    // Don't override existing collectCoverageFrom options\n    if (newOptions.collectCoverageFrom) {\n      collectCoverageFrom = collectCoverageFrom.reduce((patterns, filename) => {\n        if (\n          micromatch(\n            [replacePathSepForGlob(path.relative(options.rootDir, filename))],\n            newOptions.collectCoverageFrom,\n          ).length === 0\n        ) {\n          return patterns;\n        }\n        return [...patterns, filename];\n      }, newOptions.collectCoverageFrom);\n    }\n\n    newOptions.collectCoverageFrom = collectCoverageFrom;\n  } else if (!newOptions.collectCoverageFrom) {\n    newOptions.collectCoverageFrom = [];\n  }\n\n  if (!newOptions.findRelatedTests) {\n    newOptions.findRelatedTests = false;\n  }\n\n  if (!newOptions.projects) {\n    newOptions.projects = [];\n  }\n\n  if (!newOptions.sandboxInjectedGlobals) {\n    newOptions.sandboxInjectedGlobals = [];\n  }\n\n  if (!newOptions.forceExit) {\n    newOptions.forceExit = false;\n  }\n\n  if (!newOptions.logHeapUsage) {\n    newOptions.logHeapUsage = false;\n  }\n\n  if (argv.shard) {\n    newOptions.shard = parseShardPair(argv.shard);\n  }\n\n  return {\n    hasDeprecationWarnings,\n    options: newOptions,\n  };\n}\n",
  "packages/jest-config/src/normalize.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config } from '@jest/types';\nexport type AllOptions = Config.ProjectConfig & Config.GlobalConfig;\nexport default function normalize(initialOptions: Config.InitialOptions, argv: Config.Argv, configPath?: string | null, projectIndex?: number, isProjectOptions?: boolean): Promise<{\n    hasDeprecationWarnings: boolean;\n    options: AllOptions;\n}>;\n",
  "packages/jest-config/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport chalk from 'chalk';\nimport * as fs from 'graceful-fs';\nimport type {Config} from '@jest/types';\nimport {tryRealpath} from 'jest-util';\nimport * as constants from './constants';\nimport normalize from './normalize';\nimport readConfigFileAndSetRootDir from './readConfigFileAndSetRootDir';\nimport resolveConfigPath from './resolveConfigPath';\nimport {isJSONString, replaceRootDirInPath} from './utils';\n\nexport {isJSONString} from './utils';\nexport {default as normalize} from './normalize';\nexport {default as deprecationEntries} from './Deprecated';\nexport {replaceRootDirInPath} from './utils';\nexport {default as defaults} from './Defaults';\nexport {default as descriptions} from './Descriptions';\nexport {constants};\n\ntype ReadConfig = {\n  configPath: string | null | undefined;\n  globalConfig: Config.GlobalConfig;\n  hasDeprecationWarnings: boolean;\n  projectConfig: Config.ProjectConfig;\n};\n\nexport async function readConfig(\n  argv: Config.Argv,\n  packageRootOrConfig: string | Config.InitialOptions,\n  // Whether it needs to look into `--config` arg passed to CLI.\n  // It only used to read initial config. If the initial config contains\n  // `project` property, we don't want to read `--config` value and rather\n  // read individual configs for every project.\n  skipArgvConfigOption?: boolean,\n  parentConfigDirname?: string | null,\n  projectIndex = Number.POSITIVE_INFINITY,\n  skipMultipleConfigError = false,\n): Promise<ReadConfig> {\n  const {config: initialOptions, configPath} = await readInitialOptions(\n    argv.config,\n    {\n      packageRootOrConfig,\n      parentConfigDirname,\n      readFromCwd: skipArgvConfigOption,\n      skipMultipleConfigError,\n    },\n  );\n\n  const packageRoot =\n    typeof packageRootOrConfig === 'string'\n      ? path.resolve(packageRootOrConfig)\n      : undefined;\n  const {options, hasDeprecationWarnings} = await normalize(\n    initialOptions,\n    argv,\n    configPath,\n    projectIndex,\n    skipArgvConfigOption && !(packageRoot === parentConfigDirname),\n  );\n\n  const {globalConfig, projectConfig} = groupOptions(options);\n  return {\n    configPath,\n    globalConfig,\n    hasDeprecationWarnings,\n    projectConfig,\n  };\n}\n\nconst groupOptions = (\n  options: Config.ProjectConfig & Config.GlobalConfig,\n): {\n  globalConfig: Config.GlobalConfig;\n  projectConfig: Config.ProjectConfig;\n} => ({\n  globalConfig: Object.freeze({\n    bail: options.bail,\n    changedFilesWithAncestor: options.changedFilesWithAncestor,\n    changedSince: options.changedSince,\n    ci: options.ci,\n    collectCoverage: options.collectCoverage,\n    collectCoverageFrom: options.collectCoverageFrom,\n    coverageDirectory: options.coverageDirectory,\n    coverageProvider: options.coverageProvider,\n    coverageReporters: options.coverageReporters,\n    coverageThreshold: options.coverageThreshold,\n    detectLeaks: options.detectLeaks,\n    detectOpenHandles: options.detectOpenHandles,\n    errorOnDeprecated: options.errorOnDeprecated,\n    expand: options.expand,\n    filter: options.filter,\n    findRelatedTests: options.findRelatedTests,\n    forceExit: options.forceExit,\n    globalSetup: options.globalSetup,\n    globalTeardown: options.globalTeardown,\n    json: options.json,\n    lastCommit: options.lastCommit,\n    listTests: options.listTests,\n    logHeapUsage: options.logHeapUsage,\n    maxConcurrency: options.maxConcurrency,\n    maxWorkers: options.maxWorkers,\n    noSCM: undefined,\n    noStackTrace: options.noStackTrace,\n    nonFlagArgs: options.nonFlagArgs,\n    notify: options.notify,\n    notifyMode: options.notifyMode,\n    onlyChanged: options.onlyChanged,\n    onlyFailures: options.onlyFailures,\n    openHandlesTimeout: options.openHandlesTimeout,\n    outputFile: options.outputFile,\n    passWithNoTests: options.passWithNoTests,\n    projects: options.projects,\n    randomize: options.randomize,\n    replname: options.replname,\n    reporters: options.reporters,\n    rootDir: options.rootDir,\n    runInBand: options.runInBand,\n    runTestsByPath: options.runTestsByPath,\n    seed: options.seed,\n    shard: options.shard,\n    showSeed: options.showSeed,\n    silent: options.silent,\n    skipFilter: options.skipFilter,\n    snapshotFormat: options.snapshotFormat,\n    testFailureExitCode: options.testFailureExitCode,\n    testNamePattern: options.testNamePattern,\n    testPathPatterns: options.testPathPatterns,\n    testResultsProcessor: options.testResultsProcessor,\n    testSequencer: options.testSequencer,\n    testTimeout: options.testTimeout,\n    updateSnapshot: options.updateSnapshot,\n    useStderr: options.useStderr,\n    verbose: options.verbose,\n    waitForUnhandledRejections: options.waitForUnhandledRejections,\n    watch: options.watch,\n    watchAll: options.watchAll,\n    watchPlugins: options.watchPlugins,\n    watchman: options.watchman,\n    workerIdleMemoryLimit: options.workerIdleMemoryLimit,\n    workerThreads: options.workerThreads,\n  }),\n  projectConfig: Object.freeze({\n    automock: options.automock,\n    cache: options.cache,\n    cacheDirectory: options.cacheDirectory,\n    clearMocks: options.clearMocks,\n    collectCoverageFrom: options.collectCoverageFrom,\n    coverageDirectory: options.coverageDirectory,\n    coveragePathIgnorePatterns: options.coveragePathIgnorePatterns,\n    coverageReporters: options.coverageReporters,\n    cwd: options.cwd,\n    dependencyExtractor: options.dependencyExtractor,\n    detectLeaks: options.detectLeaks,\n    detectOpenHandles: options.detectOpenHandles,\n    displayName: options.displayName,\n    errorOnDeprecated: options.errorOnDeprecated,\n    extensionsToTreatAsEsm: options.extensionsToTreatAsEsm,\n    fakeTimers: options.fakeTimers,\n    filter: options.filter,\n    forceCoverageMatch: options.forceCoverageMatch,\n    globalSetup: options.globalSetup,\n    globalTeardown: options.globalTeardown,\n    globals: options.globals,\n    haste: options.haste,\n    id: options.id,\n    injectGlobals: options.injectGlobals,\n    moduleDirectories: options.moduleDirectories,\n    moduleFileExtensions: options.moduleFileExtensions,\n    moduleNameMapper: options.moduleNameMapper,\n    modulePathIgnorePatterns: options.modulePathIgnorePatterns,\n    modulePaths: options.modulePaths,\n    openHandlesTimeout: options.openHandlesTimeout,\n    prettierPath: options.prettierPath,\n    reporters: options.reporters,\n    resetMocks: options.resetMocks,\n    resetModules: options.resetModules,\n    resolver: options.resolver,\n    restoreMocks: options.restoreMocks,\n    rootDir: options.rootDir,\n    roots: options.roots,\n    runner: options.runner,\n    runtime: options.runtime,\n    sandboxInjectedGlobals: options.sandboxInjectedGlobals,\n    setupFiles: options.setupFiles,\n    setupFilesAfterEnv: options.setupFilesAfterEnv,\n    skipFilter: options.skipFilter,\n    skipNodeResolution: options.skipNodeResolution,\n    slowTestThreshold: options.slowTestThreshold,\n    snapshotFormat: options.snapshotFormat,\n    snapshotResolver: options.snapshotResolver,\n    snapshotSerializers: options.snapshotSerializers,\n    testEnvironment: options.testEnvironment,\n    testEnvironmentOptions: options.testEnvironmentOptions,\n    testLocationInResults: options.testLocationInResults,\n    testMatch: options.testMatch,\n    testPathIgnorePatterns: options.testPathIgnorePatterns,\n    testRegex: options.testRegex,\n    testRunner: options.testRunner,\n    testTimeout: options.testTimeout,\n    transform: options.transform,\n    transformIgnorePatterns: options.transformIgnorePatterns,\n    unmockedModulePathPatterns: options.unmockedModulePathPatterns,\n    waitForUnhandledRejections: options.waitForUnhandledRejections,\n    watchPathIgnorePatterns: options.watchPathIgnorePatterns,\n  }),\n});\n\nconst ensureNoDuplicateConfigs = (\n  parsedConfigs: Array<ReadConfig>,\n  projects: Config.GlobalConfig['projects'],\n) => {\n  if (projects.length <= 1) {\n    return;\n  }\n\n  const configPathMap = new Map();\n\n  for (const config of parsedConfigs) {\n    const {configPath} = config;\n\n    if (configPathMap.has(configPath)) {\n      const message = `Whoops! Two projects resolved to the same config path: ${chalk.bold(\n        String(configPath),\n      )}:\n\n  Project 1: ${chalk.bold(projects[parsedConfigs.indexOf(config)])}\n  Project 2: ${chalk.bold(\n    projects[parsedConfigs.indexOf(configPathMap.get(configPath))],\n  )}\n\nThis usually means that your ${chalk.bold(\n        '\"projects\"',\n      )} config includes a directory that doesn't have any configuration recognizable by Jest. Please fix it.\n`;\n\n      throw new Error(message);\n    }\n    if (configPath !== null) {\n      configPathMap.set(configPath, config);\n    }\n  }\n};\n\nexport interface ReadJestConfigOptions {\n  /**\n   * The package root or deserialized config (default is cwd)\n   */\n  packageRootOrConfig?: string | Config.InitialOptions;\n  /**\n   * When the `packageRootOrConfig` contains config, this parameter should\n   * contain the dirname of the parent config\n   */\n  parentConfigDirname?: null | string;\n  /**\n   * Indicates whether or not to read the specified config file from disk.\n   * When true, jest will read try to read config from the current working directory.\n   * (default is false)\n   */\n  readFromCwd?: boolean;\n  /**\n   * Indicates whether or not to ignore the error of jest finding multiple config files.\n   * (default is false)\n   */\n  skipMultipleConfigError?: boolean;\n}\n\n/**\n * Reads the jest config, without validating them or filling it out with defaults.\n * @param config The path to the file or serialized config.\n * @param param1 Additional options\n * @returns The raw initial config (not validated)\n */\nexport async function readInitialOptions(\n  config?: string,\n  {\n    packageRootOrConfig = process.cwd(),\n    parentConfigDirname = null,\n    readFromCwd = false,\n    skipMultipleConfigError = false,\n  }: ReadJestConfigOptions = {},\n): Promise<{config: Config.InitialOptions; configPath: string | null}> {\n  if (typeof packageRootOrConfig !== 'string') {\n    if (parentConfigDirname) {\n      const rawOptions = packageRootOrConfig;\n      rawOptions.rootDir = rawOptions.rootDir\n        ? replaceRootDirInPath(parentConfigDirname, rawOptions.rootDir)\n        : parentConfigDirname;\n      return {config: rawOptions, configPath: null};\n    } else {\n      throw new Error(\n        'Jest: Cannot use configuration as an object without a file path.',\n      );\n    }\n  }\n  if (isJSONString(config)) {\n    try {\n      // A JSON string was passed to `--config` argument and we can parse it\n      // and use as is.\n      const initialOptions = JSON.parse(config);\n      // NOTE: we might need to resolve this dir to an absolute path in the future\n      initialOptions.rootDir = initialOptions.rootDir || packageRootOrConfig;\n      return {config: initialOptions, configPath: null};\n    } catch {\n      throw new Error(\n        'There was an error while parsing the `--config` argument as a JSON string.',\n      );\n    }\n  }\n  if (!readFromCwd && typeof config == 'string') {\n    // A string passed to `--config`, which is either a direct path to the config\n    // or a path to directory containing `package.json`, `jest.config.js` or `jest.config.ts`\n    const configPath = resolveConfigPath(\n      config,\n      process.cwd(),\n      skipMultipleConfigError,\n    );\n    return {config: await readConfigFileAndSetRootDir(configPath), configPath};\n  }\n  // Otherwise just try to find config in the current rootDir.\n  const configPath = resolveConfigPath(\n    packageRootOrConfig,\n    process.cwd(),\n    skipMultipleConfigError,\n  );\n  return {config: await readConfigFileAndSetRootDir(configPath), configPath};\n}\n\n// Possible scenarios:\n//  1. jest --config config.json\n//  2. jest --projects p1 p2\n//  3. jest --projects p1 p2 --config config.json\n//  4. jest --projects p1\n//  5. jest\n//\n// If no projects are specified, process.cwd() will be used as the default\n// (and only) project.\nexport async function readConfigs(\n  argv: Config.Argv,\n  projectPaths: Array<string>,\n): Promise<{\n  globalConfig: Config.GlobalConfig;\n  configs: Array<Config.ProjectConfig>;\n  hasDeprecationWarnings: boolean;\n}> {\n  let globalConfig;\n  let hasDeprecationWarnings;\n  let configs: Array<Config.ProjectConfig> = [];\n  let projects = projectPaths;\n  let configPath: string | null | undefined;\n\n  if (projectPaths.length === 1) {\n    const parsedConfig = await readConfig(argv, projects[0]);\n    configPath = parsedConfig.configPath;\n\n    hasDeprecationWarnings = parsedConfig.hasDeprecationWarnings;\n    globalConfig = parsedConfig.globalConfig;\n    configs = [parsedConfig.projectConfig];\n    if (globalConfig.projects && globalConfig.projects.length > 0) {\n      // Even though we had one project in CLI args, there might be more\n      // projects defined in the config.\n      // In other words, if this was a single project,\n      // and its config has `projects` settings, use that value instead.\n      projects = globalConfig.projects;\n    }\n  }\n\n  if (projects.length > 0) {\n    const cwd =\n      process.platform === 'win32' ? tryRealpath(process.cwd()) : process.cwd();\n    const projectIsCwd = projects[0] === cwd;\n\n    const parsedConfigs = await Promise.all(\n      projects\n        .filter(root => {\n          // Ignore globbed files that cannot be `require`d.\n          if (\n            typeof root === 'string' &&\n            fs.existsSync(root) &&\n            !fs.lstatSync(root).isDirectory() &&\n            !constants.JEST_CONFIG_EXT_ORDER.some(ext => root.endsWith(ext))\n          ) {\n            return false;\n          }\n\n          return true;\n        })\n        .map((root, projectIndex) => {\n          const projectIsTheOnlyProject =\n            projectIndex === 0 && projects.length === 1;\n          const skipArgvConfigOption = !(\n            projectIsTheOnlyProject && projectIsCwd\n          );\n\n          return readConfig(\n            argv,\n            root,\n            skipArgvConfigOption,\n            configPath ? path.dirname(configPath) : cwd,\n            projectIndex,\n            // we wanna skip the warning if this is the \"main\" project\n            projectIsCwd,\n          );\n        }),\n    );\n\n    ensureNoDuplicateConfigs(parsedConfigs, projects);\n    configs = parsedConfigs.map(({projectConfig}) => projectConfig);\n    if (!hasDeprecationWarnings) {\n      hasDeprecationWarnings = parsedConfigs.some(\n        ({hasDeprecationWarnings}) => !!hasDeprecationWarnings,\n      );\n    }\n    // If no config was passed initially, use the one from the first project\n    if (!globalConfig) {\n      globalConfig = parsedConfigs[0].globalConfig;\n    }\n  }\n\n  if (!globalConfig || configs.length === 0) {\n    throw new Error('jest: No configuration found for any project.');\n  }\n\n  return {\n    configs,\n    globalConfig,\n    hasDeprecationWarnings: !!hasDeprecationWarnings,\n  };\n}\n",
  "packages/jest-config/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config } from '@jest/types';\nimport * as constants from './constants';\nexport { isJSONString } from './utils';\nexport { default as normalize } from './normalize';\nexport { default as deprecationEntries } from './Deprecated';\nexport { replaceRootDirInPath } from './utils';\nexport { default as defaults } from './Defaults';\nexport { default as descriptions } from './Descriptions';\nexport { constants };\ntype ReadConfig = {\n    configPath: string | null | undefined;\n    globalConfig: Config.GlobalConfig;\n    hasDeprecationWarnings: boolean;\n    projectConfig: Config.ProjectConfig;\n};\nexport declare function readConfig(argv: Config.Argv, packageRootOrConfig: string | Config.InitialOptions, skipArgvConfigOption?: boolean, parentConfigDirname?: string | null, projectIndex?: number, skipMultipleConfigError?: boolean): Promise<ReadConfig>;\nexport interface ReadJestConfigOptions {\n    /**\n     * The package root or deserialized config (default is cwd)\n     */\n    packageRootOrConfig?: string | Config.InitialOptions;\n    /**\n     * When the `packageRootOrConfig` contains config, this parameter should\n     * contain the dirname of the parent config\n     */\n    parentConfigDirname?: null | string;\n    /**\n     * Indicates whether or not to read the specified config file from disk.\n     * When true, jest will read try to read config from the current working directory.\n     * (default is false)\n     */\n    readFromCwd?: boolean;\n    /**\n     * Indicates whether or not to ignore the error of jest finding multiple config files.\n     * (default is false)\n     */\n    skipMultipleConfigError?: boolean;\n}\n/**\n * Reads the jest config, without validating them or filling it out with defaults.\n * @param config The path to the file or serialized config.\n * @param param1 Additional options\n * @returns The raw initial config (not validated)\n */\nexport declare function readInitialOptions(config?: string, { packageRootOrConfig, parentConfigDirname, readFromCwd, skipMultipleConfigError, }?: ReadJestConfigOptions): Promise<{\n    config: Config.InitialOptions;\n    configPath: string | null;\n}>;\nexport declare function readConfigs(argv: Config.Argv, projectPaths: Array<string>): Promise<{\n    globalConfig: Config.GlobalConfig;\n    configs: Array<Config.ProjectConfig>;\n    hasDeprecationWarnings: boolean;\n}>;\n",
  "packages/jest-config/src/getMaxWorkers.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {availableParallelism} from 'os';\nimport type {Config} from '@jest/types';\n\nexport default function getMaxWorkers(\n  argv: Partial<\n    Pick<Config.Argv, 'maxWorkers' | 'runInBand' | 'watch' | 'watchAll'>\n  >,\n  defaultOptions?: Partial<Pick<Config.Argv, 'maxWorkers'>>,\n): number {\n  if (argv.runInBand) {\n    return 1;\n  } else if (argv.maxWorkers) {\n    return parseWorkers(argv.maxWorkers);\n  } else if (defaultOptions && defaultOptions.maxWorkers) {\n    return parseWorkers(defaultOptions.maxWorkers);\n  } else {\n    // In watch mode, Jest should be unobtrusive and not use all available CPUs.\n    const numCpus = availableParallelism();\n    const isWatchModeEnabled = argv.watch || argv.watchAll;\n    return Math.max(\n      isWatchModeEnabled ? Math.floor(numCpus / 2) : numCpus - 1,\n      1,\n    );\n  }\n}\n\nconst parseWorkers = (maxWorkers: string | number): number => {\n  const parsed = Number.parseInt(maxWorkers.toString(), 10);\n\n  if (\n    typeof maxWorkers === 'string' &&\n    maxWorkers.trim().endsWith('%') &&\n    parsed > 0 &&\n    parsed <= 100\n  ) {\n    const numCpus = availableParallelism();\n    const workers = Math.floor((parsed / 100) * numCpus);\n    return Math.max(workers, 1);\n  }\n\n  return parsed > 0 ? parsed : 1;\n};\n",
  "packages/jest-config/src/getMaxWorkers.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config } from '@jest/types';\nexport default function getMaxWorkers(argv: Partial<Pick<Config.Argv, 'maxWorkers' | 'runInBand' | 'watch' | 'watchAll'>>, defaultOptions?: Partial<Pick<Config.Argv, 'maxWorkers'>>): number;\n",
  "packages/jest-config/src/getCacheDirectory.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport {tryRealpath} from 'jest-util';\n\nconst getCacheDirectory: () => string = () => {\n  const {getuid} = process;\n  const tmpdirPath = path.join(tryRealpath(tmpdir()), 'jest');\n  if (getuid == null) {\n    return tmpdirPath;\n  } else {\n    // On some platforms tmpdir() is `/tmp`, causing conflicts between different\n    // users and permission issues. Adding an additional subdivision by UID can\n    // help.\n    return `${tmpdirPath}_${getuid.call(process).toString(36)}`;\n  }\n};\n\nexport default getCacheDirectory;\n",
  "packages/jest-config/src/getCacheDirectory.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\ndeclare const getCacheDirectory: () => string;\nexport default getCacheDirectory;\n",
  "packages/jest-config/src/constants.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\n\nexport const NODE_MODULES = `${path.sep}node_modules${path.sep}`;\nexport const DEFAULT_JS_PATTERN = '\\\\.[jt]sx?$';\nexport const PACKAGE_JSON = 'package.json';\nexport const JEST_CONFIG_BASE_NAME = 'jest.config';\nexport const JEST_CONFIG_EXT_CJS = '.cjs';\nexport const JEST_CONFIG_EXT_MJS = '.mjs';\nexport const JEST_CONFIG_EXT_JS = '.js';\nexport const JEST_CONFIG_EXT_TS = '.ts';\nexport const JEST_CONFIG_EXT_CTS = '.cts';\nexport const JEST_CONFIG_EXT_JSON = '.json';\nexport const JEST_CONFIG_EXT_ORDER = Object.freeze([\n  JEST_CONFIG_EXT_JS,\n  JEST_CONFIG_EXT_TS,\n  JEST_CONFIG_EXT_MJS,\n  JEST_CONFIG_EXT_CJS,\n  JEST_CONFIG_EXT_CTS,\n  JEST_CONFIG_EXT_JSON,\n]);\n",
  "packages/jest-config/src/constants.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport declare const NODE_MODULES: string;\nexport declare const DEFAULT_JS_PATTERN = \"\\\\.[jt]sx?$\";\nexport declare const PACKAGE_JSON = \"package.json\";\nexport declare const JEST_CONFIG_BASE_NAME = \"jest.config\";\nexport declare const JEST_CONFIG_EXT_CJS = \".cjs\";\nexport declare const JEST_CONFIG_EXT_MJS = \".mjs\";\nexport declare const JEST_CONFIG_EXT_JS = \".js\";\nexport declare const JEST_CONFIG_EXT_TS = \".ts\";\nexport declare const JEST_CONFIG_EXT_CTS = \".cts\";\nexport declare const JEST_CONFIG_EXT_JSON = \".json\";\nexport declare const JEST_CONFIG_EXT_ORDER: readonly string[];\n",
  "packages/jest-config/src/color.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {createHash} from 'crypto';\nimport type {ForegroundColor} from 'chalk';\n\ntype Color = typeof ForegroundColor;\n\nconst colors: Array<Color> = [\n  'red',\n  'green',\n  'yellow',\n  'blue',\n  'magenta',\n  'cyan',\n  'white',\n];\n\nexport const getDisplayNameColor = (seed?: string): Color => {\n  if (seed === undefined) {\n    return 'white';\n  }\n\n  const hash = createHash('sha256');\n  hash.update(seed);\n  const num = hash.digest().readUInt32LE(0);\n  return colors[num % colors.length];\n};\n",
  "packages/jest-config/src/color.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { ForegroundColor } from 'chalk';\ntype Color = typeof ForegroundColor;\nexport declare const getDisplayNameColor: (seed?: string) => Color;\nexport {};\n",
  "packages/jest-config/src/ValidConfig.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {Config} from '@jest/types';\nimport {replacePathSepForRegex} from 'jest-regex-util';\nimport {multipleValidOptions} from 'jest-validate';\nimport {DEFAULT_OPTIONS as PRETTY_FORMAT_DEFAULTS} from 'pretty-format';\nimport {NODE_MODULES} from './constants';\n\nconst NODE_MODULES_REGEXP = replacePathSepForRegex(NODE_MODULES);\n\nexport const initialOptions: Config.InitialOptions = {\n  automock: false,\n  bail: multipleValidOptions(false, 0),\n  cache: true,\n  cacheDirectory: '/tmp/user/jest',\n  changedFilesWithAncestor: false,\n  changedSince: 'master',\n  ci: false,\n  clearMocks: false,\n  collectCoverage: true,\n  collectCoverageFrom: ['src', '!public'],\n  coverageDirectory: 'coverage',\n  coveragePathIgnorePatterns: [NODE_MODULES_REGEXP],\n  coverageProvider: 'v8',\n  coverageReporters: ['json', 'text', 'lcov', 'clover'],\n  coverageThreshold: {\n    global: {\n      branches: 50,\n      functions: 100,\n      lines: 100,\n      statements: 100,\n    },\n  },\n  dependencyExtractor: '<rootDir>/dependencyExtractor.js',\n  detectLeaks: false,\n  detectOpenHandles: false,\n  displayName: multipleValidOptions('test-config', {\n    color: 'blue',\n    name: 'test-config',\n  } as const),\n  errorOnDeprecated: false,\n  expand: false,\n  extensionsToTreatAsEsm: [],\n  fakeTimers: {\n    advanceTimers: multipleValidOptions(40, true),\n    doNotFake: [\n      'Date',\n      'hrtime',\n      'nextTick',\n      'performance',\n      'queueMicrotask',\n      'requestAnimationFrame',\n      'cancelAnimationFrame',\n      'requestIdleCallback',\n      'cancelIdleCallback',\n      'setImmediate',\n      'clearImmediate',\n      'setInterval',\n      'clearInterval',\n      'setTimeout',\n      'clearTimeout',\n    ],\n    enableGlobally: true,\n    legacyFakeTimers: false,\n    now: 1_483_228_800_000,\n    timerLimit: 1000,\n  },\n  filter: '<rootDir>/filter.js',\n  forceCoverageMatch: ['**/*.t.js'],\n  forceExit: false,\n  globalSetup: 'setup.js',\n  globalTeardown: 'teardown.js',\n  globals: {__DEV__: true},\n  haste: {\n    computeSha1: true,\n    defaultPlatform: 'ios',\n    enableSymlinks: false,\n    forceNodeFilesystemAPI: true,\n    hasteImplModulePath: '<rootDir>/haste_impl.js',\n    hasteMapModulePath: '',\n    platforms: ['ios', 'android'],\n    retainAllFiles: false,\n    throwOnModuleCollision: false,\n  },\n  id: 'string',\n  injectGlobals: true,\n  json: false,\n  lastCommit: false,\n  listTests: false,\n  logHeapUsage: true,\n  maxConcurrency: 5,\n  maxWorkers: '50%',\n  moduleDirectories: ['node_modules'],\n  moduleFileExtensions: [\n    'js',\n    'mjs',\n    'cjs',\n    'json',\n    'jsx',\n    'ts',\n    'mts',\n    'cts',\n    'tsx',\n    'node',\n  ],\n  moduleNameMapper: {\n    '^React$': '<rootDir>/node_modules/react',\n  },\n  modulePathIgnorePatterns: ['<rootDir>/build/'],\n  modulePaths: ['/shared/vendor/modules'],\n  noStackTrace: false,\n  notify: false,\n  notifyMode: 'failure-change',\n  onlyChanged: false,\n  onlyFailures: false,\n  openHandlesTimeout: 1000,\n  passWithNoTests: false,\n  preset: 'react-native',\n  prettierPath: '<rootDir>/node_modules/prettier',\n  projects: ['project-a', 'project-b/'],\n  randomize: false,\n  reporters: [\n    'default',\n    'custom-reporter-1',\n    ['custom-reporter-2', {configValue: true}],\n  ],\n  resetMocks: false,\n  resetModules: false,\n  resolver: '<rootDir>/resolver.js',\n  restoreMocks: false,\n  rootDir: '/',\n  roots: ['<rootDir>'],\n  runTestsByPath: false,\n  runner: 'jest-runner',\n  runtime: '<rootDir>',\n  sandboxInjectedGlobals: [],\n  setupFiles: ['<rootDir>/setup.js'],\n  setupFilesAfterEnv: ['<rootDir>/testSetupFile.js'],\n  showSeed: false,\n  silent: true,\n  skipFilter: false,\n  skipNodeResolution: false,\n  slowTestThreshold: 5,\n  snapshotFormat: PRETTY_FORMAT_DEFAULTS,\n  snapshotResolver: '<rootDir>/snapshotResolver.js',\n  snapshotSerializers: ['my-serializer-module'],\n  testEnvironment: 'jest-environment-node',\n  testEnvironmentOptions: {\n    url: 'http://localhost',\n    userAgent: 'Agent/007',\n  },\n  testFailureExitCode: 1,\n  testLocationInResults: false,\n  testMatch: multipleValidOptions(\n    '**/__tests__/**/?(*.)+(spec|test).?([mc])[jt]s?(x)',\n    [\n      '**/__tests__/**/*.?([mc])[jt]s?(x)',\n      '**/?(*.)+(spec|test).?([mc])[jt]s?(x)',\n    ],\n  ),\n  testNamePattern: 'test signature',\n  testPathIgnorePatterns: [NODE_MODULES_REGEXP],\n  testRegex: multipleValidOptions(\n    '(/__tests__/.*|(\\\\.|/)(test|spec))\\\\.[mc]?[jt]sx?$',\n    [\n      '/__tests__/\\\\.test\\\\.[mc]?[jt]sx?$',\n      '/__tests__/\\\\.spec\\\\.[mc]?[jt]sx?$',\n    ],\n  ),\n  testResultsProcessor: 'processor-node-module',\n  testRunner: 'circus',\n  testSequencer: '@jest/test-sequencer',\n  testTimeout: 5000,\n  transform: {\n    '\\\\.js$': '<rootDir>/preprocessor.js',\n  },\n  transformIgnorePatterns: [NODE_MODULES_REGEXP],\n  unmockedModulePathPatterns: ['mock'],\n  updateSnapshot: true,\n  useStderr: false,\n  verbose: false,\n  waitForUnhandledRejections: false,\n  watch: false,\n  watchAll: false,\n  watchPathIgnorePatterns: ['<rootDir>/e2e/'],\n  watchPlugins: [\n    'path/to/yourWatchPlugin',\n    [\n      'jest-watch-typeahead/filename',\n      {\n        key: 'k',\n        prompt: 'do something with my custom prompt',\n      },\n    ],\n  ],\n  watchman: true,\n  workerIdleMemoryLimit: multipleValidOptions(0.2, '50%'),\n  workerThreads: true,\n};\n\nexport const initialProjectOptions: Config.InitialProjectOptions = {\n  automock: false,\n  cache: true,\n  cacheDirectory: '/tmp/user/jest',\n  clearMocks: false,\n  collectCoverageFrom: ['src', '!public'],\n  coverageDirectory: 'coverage',\n  coveragePathIgnorePatterns: [NODE_MODULES_REGEXP],\n  coverageReporters: ['json', 'text', 'lcov', 'clover'],\n  dependencyExtractor: '<rootDir>/dependencyExtractor.js',\n  detectLeaks: false,\n  detectOpenHandles: false,\n  displayName: multipleValidOptions('test-config', {\n    color: 'blue',\n    name: 'test-config',\n  } as const),\n  errorOnDeprecated: false,\n  extensionsToTreatAsEsm: [],\n  fakeTimers: {\n    advanceTimers: multipleValidOptions(40, true),\n    doNotFake: [\n      'Date',\n      'hrtime',\n      'nextTick',\n      'performance',\n      'queueMicrotask',\n      'requestAnimationFrame',\n      'cancelAnimationFrame',\n      'requestIdleCallback',\n      'cancelIdleCallback',\n      'setImmediate',\n      'clearImmediate',\n      'setInterval',\n      'clearInterval',\n      'setTimeout',\n      'clearTimeout',\n    ],\n    enableGlobally: true,\n    legacyFakeTimers: false,\n    now: 1_483_228_800_000,\n    timerLimit: 1000,\n  },\n  filter: '<rootDir>/filter.js',\n  forceCoverageMatch: ['**/*.t.js'],\n  globalSetup: 'setup.js',\n  globalTeardown: 'teardown.js',\n  globals: {__DEV__: true},\n  haste: {\n    computeSha1: true,\n    defaultPlatform: 'ios',\n    enableSymlinks: false,\n    forceNodeFilesystemAPI: true,\n    hasteImplModulePath: '<rootDir>/haste_impl.js',\n    hasteMapModulePath: '',\n    platforms: ['ios', 'android'],\n    retainAllFiles: false,\n    throwOnModuleCollision: false,\n  },\n  id: 'string',\n  injectGlobals: true,\n  moduleDirectories: ['node_modules'],\n  moduleFileExtensions: [\n    'js',\n    'mjs',\n    'cjs',\n    'json',\n    'jsx',\n    'ts',\n    'mts',\n    'cts',\n    'tsx',\n    'node',\n  ],\n  moduleNameMapper: {\n    '^React$': '<rootDir>/node_modules/react',\n  },\n  modulePathIgnorePatterns: ['<rootDir>/build/'],\n  modulePaths: ['/shared/vendor/modules'],\n  openHandlesTimeout: 1000,\n  preset: 'react-native',\n  prettierPath: '<rootDir>/node_modules/prettier',\n  reporters: [\n    'default',\n    'custom-reporter-1',\n    ['custom-reporter-2', {configValue: true}],\n  ],\n  resetMocks: false,\n  resetModules: false,\n  resolver: '<rootDir>/resolver.js',\n  restoreMocks: false,\n  rootDir: '/',\n  roots: ['<rootDir>'],\n  runner: 'jest-runner',\n  runtime: '<rootDir>',\n  sandboxInjectedGlobals: [],\n  setupFiles: ['<rootDir>/setup.js'],\n  setupFilesAfterEnv: ['<rootDir>/testSetupFile.js'],\n  skipFilter: false,\n  skipNodeResolution: false,\n  slowTestThreshold: 5,\n  snapshotFormat: PRETTY_FORMAT_DEFAULTS,\n  snapshotResolver: '<rootDir>/snapshotResolver.js',\n  snapshotSerializers: ['my-serializer-module'],\n  testEnvironment: 'jest-environment-node',\n  testEnvironmentOptions: {\n    url: 'http://localhost',\n    userAgent: 'Agent/007',\n  },\n  testLocationInResults: false,\n  testMatch: [\n    '**/__tests__/**/*.?([mc])[jt]s?(x)',\n    '**/?(*.)+(spec|test).?([mc])[jt]s?(x)',\n  ],\n  testPathIgnorePatterns: [NODE_MODULES_REGEXP],\n  testRegex: multipleValidOptions(\n    '(/__tests__/.*|(\\\\.|/)(test|spec))\\\\.[mc]?[jt]sx?$',\n    [\n      '/__tests__/\\\\.test\\\\.[mc]?[jt]sx?$',\n      '/__tests__/\\\\.spec\\\\.[mc]?[jt]sx?$',\n    ],\n  ),\n  testRunner: 'circus',\n  testTimeout: 5000,\n  transform: {\n    '\\\\.js$': '<rootDir>/preprocessor.js',\n  },\n  transformIgnorePatterns: [NODE_MODULES_REGEXP],\n  unmockedModulePathPatterns: ['mock'],\n  waitForUnhandledRejections: false,\n  watchPathIgnorePatterns: ['<rootDir>/e2e/'],\n  workerIdleMemoryLimit: multipleValidOptions(0.2, '50%'),\n};\n",
  "packages/jest-config/src/ValidConfig.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config } from '@jest/types';\nexport declare const initialOptions: Config.InitialOptions;\nexport declare const initialProjectOptions: Config.InitialProjectOptions;\n",
  "packages/jest-config/src/ReporterValidationErrors.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk from 'chalk';\nimport {getType} from '@jest/get-type';\nimport type {Config} from '@jest/types';\nimport {ValidationError} from 'jest-validate';\nimport {BULLET, DOCUMENTATION_NOTE} from './utils';\n\nconst validReporterTypes = ['array', 'string'];\nconst ERROR = `${BULLET}Reporter Validation Error`;\n\n/**\n * Reporter Validation Error is thrown if the given arguments\n * within the reporter are not valid.\n *\n * This is a highly specific reporter error and in the future will be\n * merged with jest-validate. Till then, we can make use of it. It works\n * and that's what counts most at this time.\n */\nexport function createReporterError(\n  reporterIndex: number,\n  reporterValue: Array<Config.ReporterConfig> | string,\n): ValidationError {\n  const errorMessage =\n    `  Reporter at index ${reporterIndex} must be of type:\\n` +\n    `    ${chalk.bold.green(validReporterTypes.join(' or '))}\\n` +\n    '  but instead received:\\n' +\n    `    ${chalk.bold.red(getType(reporterValue))}`;\n\n  return new ValidationError(ERROR, errorMessage, DOCUMENTATION_NOTE);\n}\n\nexport function createArrayReporterError(\n  arrayReporter: Config.ReporterConfig,\n  reporterIndex: number,\n  valueIndex: number,\n  value: string | Record<string, unknown>,\n  expectedType: string,\n  valueName: string,\n): ValidationError {\n  const errorMessage =\n    `  Unexpected value for ${valueName} ` +\n    `at index ${valueIndex} of reporter at index ${reporterIndex}\\n` +\n    '  Expected:\\n' +\n    `    ${chalk.bold.red(expectedType)}\\n` +\n    '  Got:\\n' +\n    `    ${chalk.bold.green(getType(value))}\\n` +\n    '  Reporter configuration:\\n' +\n    `    ${chalk.bold.green(\n      JSON.stringify(arrayReporter, null, 2).split('\\n').join('\\n    '),\n    )}`;\n\n  return new ValidationError(ERROR, errorMessage, DOCUMENTATION_NOTE);\n}\n\nexport function validateReporters(\n  reporterConfig: Array<Config.ReporterConfig | string>,\n): boolean {\n  return reporterConfig.every((reporter, index) => {\n    if (Array.isArray(reporter)) {\n      validateArrayReporter(reporter, index);\n    } else if (typeof reporter !== 'string') {\n      throw createReporterError(index, reporter);\n    }\n\n    return true;\n  });\n}\n\nfunction validateArrayReporter(\n  arrayReporter: Config.ReporterConfig,\n  reporterIndex: number,\n) {\n  const [path, options] = arrayReporter;\n  if (typeof path !== 'string') {\n    throw createArrayReporterError(\n      arrayReporter,\n      reporterIndex,\n      0,\n      path,\n      'string',\n      'Path',\n    );\n  } else if (typeof options !== 'object') {\n    throw createArrayReporterError(\n      arrayReporter,\n      reporterIndex,\n      1,\n      options,\n      'object',\n      'Reporter Configuration',\n    );\n  }\n}\n",
  "packages/jest-config/src/ReporterValidationErrors.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config } from '@jest/types';\nimport { ValidationError } from 'jest-validate';\n/**\n * Reporter Validation Error is thrown if the given arguments\n * within the reporter are not valid.\n *\n * This is a highly specific reporter error and in the future will be\n * merged with jest-validate. Till then, we can make use of it. It works\n * and that's what counts most at this time.\n */\nexport declare function createReporterError(reporterIndex: number, reporterValue: Array<Config.ReporterConfig> | string): ValidationError;\nexport declare function createArrayReporterError(arrayReporter: Config.ReporterConfig, reporterIndex: number, valueIndex: number, value: string | Record<string, unknown>, expectedType: string, valueName: string): ValidationError;\nexport declare function validateReporters(reporterConfig: Array<Config.ReporterConfig | string>): boolean;\n",
  "packages/jest-config/src/Descriptions.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {Config} from '@jest/types';\n\nconst descriptions: {[key in keyof Config.InitialOptions]: string} = {\n  automock: 'All imported modules in your tests should be mocked automatically',\n  bail: 'Stop running tests after `n` failures',\n  cacheDirectory:\n    'The directory where Jest should store its cached dependency information',\n  clearMocks:\n    'Automatically clear mock calls, instances, contexts and results before every test',\n  collectCoverage:\n    'Indicates whether the coverage information should be collected while executing the test',\n  collectCoverageFrom:\n    'An array of glob patterns indicating a set of files for which coverage information should be collected',\n  coverageDirectory:\n    'The directory where Jest should output its coverage files',\n  coveragePathIgnorePatterns:\n    'An array of regexp pattern strings used to skip coverage collection',\n  coverageProvider:\n    'Indicates which provider should be used to instrument code for coverage',\n  coverageReporters:\n    'A list of reporter names that Jest uses when writing coverage reports',\n  coverageThreshold:\n    'An object that configures minimum threshold enforcement for coverage results',\n  dependencyExtractor: 'A path to a custom dependency extractor',\n  errorOnDeprecated:\n    'Make calling deprecated APIs throw helpful error messages',\n  fakeTimers: 'The default configuration for fake timers',\n  forceCoverageMatch:\n    'Force coverage collection from ignored files using an array of glob patterns',\n  globalSetup:\n    'A path to a module which exports an async function that is triggered once before all test suites',\n  globalTeardown:\n    'A path to a module which exports an async function that is triggered once after all test suites',\n  globals:\n    'A set of global variables that need to be available in all test environments',\n  maxWorkers:\n    'The maximum amount of workers used to run your tests. Can be specified as % or a number. E.g. maxWorkers: 10% will use 10% of your CPU amount + 1 as the maximum worker number. maxWorkers: 2 will use a maximum of 2 workers.',\n  moduleDirectories:\n    \"An array of directory names to be searched recursively up from the requiring module's location\",\n  moduleFileExtensions: 'An array of file extensions your modules use',\n  moduleNameMapper:\n    'A map from regular expressions to module names or to arrays of module names that allow to stub out resources with a single module',\n  modulePathIgnorePatterns:\n    \"An array of regexp pattern strings, matched against all module paths before considered 'visible' to the module loader\",\n  notify: 'Activates notifications for test results',\n  notifyMode:\n    'An enum that specifies notification mode. Requires { notify: true }',\n  preset: \"A preset that is used as a base for Jest's configuration\",\n  projects: 'Run tests from one or more projects',\n  reporters: 'Use this configuration option to add custom reporters to Jest',\n  resetMocks: 'Automatically reset mock state before every test',\n  resetModules: 'Reset the module registry before running each individual test',\n  resolver: 'A path to a custom resolver',\n  restoreMocks:\n    'Automatically restore mock state and implementation before every test',\n  rootDir:\n    'The root directory that Jest should scan for tests and modules within',\n  roots:\n    'A list of paths to directories that Jest should use to search for files in',\n  runner:\n    \"Allows you to use a custom runner instead of Jest's default test runner\",\n  setupFiles:\n    'The paths to modules that run some code to configure or set up the testing environment before each test',\n  setupFilesAfterEnv:\n    'A list of paths to modules that run some code to configure or set up the testing framework before each test',\n  slowTestThreshold:\n    'The number of seconds after which a test is considered as slow and reported as such in the results.',\n  snapshotSerializers:\n    'A list of paths to snapshot serializer modules Jest should use for snapshot testing',\n  testEnvironment: 'The test environment that will be used for testing',\n  testEnvironmentOptions: 'Options that will be passed to the testEnvironment',\n  testLocationInResults: 'Adds a location field to test results',\n  testMatch: 'The glob patterns Jest uses to detect test files',\n  testPathIgnorePatterns:\n    'An array of regexp pattern strings that are matched against all test paths, matched tests are skipped',\n  testRegex:\n    'The regexp pattern or array of patterns that Jest uses to detect test files',\n  testResultsProcessor:\n    'This option allows the use of a custom results processor',\n  testRunner: 'This option allows use of a custom test runner',\n  transform: 'A map from regular expressions to paths to transformers',\n  transformIgnorePatterns:\n    'An array of regexp pattern strings that are matched against all source file paths, matched files will skip transformation',\n  unmockedModulePathPatterns:\n    'An array of regexp pattern strings that are matched against all modules before the module loader will automatically return a mock for them',\n  verbose:\n    'Indicates whether each individual test should be reported during the run',\n  watchPathIgnorePatterns:\n    'An array of regexp patterns that are matched against all source file paths before re-running tests in watch mode',\n  watchman: 'Whether to use watchman for file crawling',\n};\n\nexport default descriptions;\n",
  "packages/jest-config/src/Descriptions.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config } from '@jest/types';\ndeclare const descriptions: {\n    [key in keyof Config.InitialOptions]: string;\n};\nexport default descriptions;\n",
  "packages/jest-config/src/Deprecated.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk from 'chalk';\nimport type {DeprecatedOptions} from 'jest-validate';\n\nfunction formatDeprecation(message: string): string {\n  const lines = [\n    message.replaceAll(/\\*(.+?)\\*/g, (_, s) => chalk.bold(`\"${s}\"`)),\n    '',\n    'Please update your configuration.',\n  ];\n  return lines.map(s => `  ${s}`).join('\\n');\n}\n\nconst deprecatedOptions: DeprecatedOptions = {\n  browser: () =>\n    `  Option ${chalk.bold(\n      '\"browser\"',\n    )} has been deprecated. Please install \"browser-resolve\" and use the \"resolver\" option in Jest configuration as shown in the documentation: https://jestjs.io/docs/configuration#resolver-string`,\n\n  collectCoverageOnlyFrom: (_options: {\n    collectCoverageOnlyFrom?: Record<string, boolean>;\n  }) => `  Option ${chalk.bold(\n    '\"collectCoverageOnlyFrom\"',\n  )} was replaced by ${chalk.bold('\"collectCoverageFrom\"')}.\n\n    Please update your configuration.`,\n\n  extraGlobals: (_options: {extraGlobals?: string}) => `  Option ${chalk.bold(\n    '\"extraGlobals\"',\n  )} was replaced by ${chalk.bold('\"sandboxInjectedGlobals\"')}.\n\n  Please update your configuration.`,\n\n  init: () =>\n    `  Option ${chalk.bold(\n      '\"init\"',\n    )} has been deprecated. Please use \"create-jest\" package as shown in the documentation: https://jestjs.io/docs/getting-started#generate-a-basic-configuration-file`,\n\n  moduleLoader: (_options: {moduleLoader?: string}) => `  Option ${chalk.bold(\n    '\"moduleLoader\"',\n  )} was replaced by ${chalk.bold('\"runtime\"')}.\n\n  Please update your configuration.`,\n\n  preprocessorIgnorePatterns: (_options: {\n    preprocessorIgnorePatterns?: Array<string>;\n  }) => `  Option ${chalk.bold(\n    '\"preprocessorIgnorePatterns\"',\n  )} was replaced by ${chalk.bold(\n    '\"transformIgnorePatterns\"',\n  )}, which support multiple preprocessors.\n\n  Please update your configuration.`,\n\n  scriptPreprocessor: (_options: {\n    scriptPreprocessor?: string;\n  }) => `  Option ${chalk.bold(\n    '\"scriptPreprocessor\"',\n  )} was replaced by ${chalk.bold(\n    '\"transform\"',\n  )}, which support multiple preprocessors.\n\n  Please update your configuration.`,\n\n  setupTestFrameworkScriptFile: (_options: {\n    setupTestFrameworkScriptFile?: string;\n  }) => `  Option ${chalk.bold(\n    '\"setupTestFrameworkScriptFile\"',\n  )} was replaced by configuration ${chalk.bold(\n    '\"setupFilesAfterEnv\"',\n  )}, which supports multiple paths.\n\n  Please update your configuration.`,\n\n  testPathDirs: (_options: {\n    testPathDirs?: Array<string>;\n  }) => `  Option ${chalk.bold('\"testPathDirs\"')} was replaced by ${chalk.bold(\n    '\"roots\"',\n  )}.\n\n  Please update your configuration.\n  `,\n\n  testPathPattern: () =>\n    formatDeprecation(\n      'Option *testPathPattern* was replaced by *--testPathPatterns*. *--testPathPatterns* is only available as a command-line option.',\n    ),\n\n  testURL: (_options: {testURL?: string}) => `  Option ${chalk.bold(\n    '\"testURL\"',\n  )} was replaced by passing the URL via ${chalk.bold(\n    '\"testEnvironmentOptions.url\"',\n  )}.\n\n  Please update your configuration.`,\n\n  timers: (_options: {timers?: string}) => `  Option ${chalk.bold(\n    '\"timers\"',\n  )} was replaced by ${chalk.bold('\"fakeTimers\"')}.\n\n  Please update your configuration.`,\n};\n\nexport default deprecatedOptions;\n",
  "packages/jest-config/src/Deprecated.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { DeprecatedOptions } from 'jest-validate';\ndeclare const deprecatedOptions: DeprecatedOptions;\nexport default deprecatedOptions;\n",
  "packages/jest-config/src/Defaults.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {sep} from 'path';\nimport {isCI} from 'ci-info';\nimport type {Config} from '@jest/types';\nimport {replacePathSepForRegex} from 'jest-regex-util';\nimport {NODE_MODULES} from './constants';\nimport getCacheDirectory from './getCacheDirectory';\n\nconst NODE_MODULES_REGEXP = replacePathSepForRegex(NODE_MODULES);\n\nconst defaultOptions: Config.DefaultOptions = {\n  automock: false,\n  bail: 0,\n  cache: true,\n  cacheDirectory: getCacheDirectory(),\n  changedFilesWithAncestor: false,\n  ci: isCI,\n  clearMocks: false,\n  collectCoverage: false,\n  coveragePathIgnorePatterns: [NODE_MODULES_REGEXP],\n  coverageProvider: 'babel',\n  coverageReporters: ['json', 'text', 'lcov', 'clover'],\n  detectLeaks: false,\n  detectOpenHandles: false,\n  errorOnDeprecated: false,\n  expand: false,\n  extensionsToTreatAsEsm: [],\n  fakeTimers: {enableGlobally: false},\n  forceCoverageMatch: [],\n  globals: {},\n  haste: {\n    computeSha1: false,\n    enableSymlinks: false,\n    forceNodeFilesystemAPI: true,\n    throwOnModuleCollision: false,\n  },\n  injectGlobals: true,\n  listTests: false,\n  maxConcurrency: 5,\n  maxWorkers: '50%',\n  moduleDirectories: ['node_modules'],\n  moduleFileExtensions: [\n    'js',\n    'mjs',\n    'cjs',\n    'jsx',\n    'ts',\n    'mts',\n    'cts',\n    'tsx',\n    'json',\n    'node',\n  ],\n  moduleNameMapper: {},\n  modulePathIgnorePatterns: [],\n  noStackTrace: false,\n  notify: false,\n  notifyMode: 'failure-change',\n  openHandlesTimeout: 1000,\n  passWithNoTests: false,\n  prettierPath: 'prettier',\n  resetMocks: false,\n  resetModules: false,\n  restoreMocks: false,\n  roots: ['<rootDir>'],\n  runTestsByPath: false,\n  runner: 'jest-runner',\n  setupFiles: [],\n  setupFilesAfterEnv: [],\n  skipFilter: false,\n  slowTestThreshold: 5,\n  snapshotFormat: {escapeString: false, printBasicPrototype: false},\n  snapshotSerializers: [],\n  testEnvironment: 'jest-environment-node',\n  testEnvironmentOptions: {},\n  testFailureExitCode: 1,\n  testLocationInResults: false,\n  testMatch: [\n    '**/__tests__/**/*.?([mc])[jt]s?(x)',\n    '**/?(*.)+(spec|test).?([mc])[jt]s?(x)',\n  ],\n  testPathIgnorePatterns: [NODE_MODULES_REGEXP],\n  testRegex: [],\n  testRunner: 'jest-circus/runner',\n  testSequencer: '@jest/test-sequencer',\n  transformIgnorePatterns: [NODE_MODULES_REGEXP, `\\\\.pnp\\\\.[^\\\\${sep}]+$`],\n  useStderr: false,\n  waitForUnhandledRejections: false,\n  watch: false,\n  watchPathIgnorePatterns: [],\n  watchman: true,\n  workerThreads: false,\n};\n\nexport default defaultOptions;\n",
  "packages/jest-config/src/Defaults.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config } from '@jest/types';\ndeclare const defaultOptions: Config.DefaultOptions;\nexport default defaultOptions;\n",
  "packages/jest-config/src/__tests__/stringToBytes.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport stringToBytes from '../stringToBytes';\n\ndescribe('numeric input', () => {\n  test('0 should be 0', () => {\n    expect(stringToBytes(0)).toBe(0);\n  });\n\n  test('> 1 represents bytes', () => {\n    expect(stringToBytes(50.8)).toBe(50);\n  });\n\n  test('1.1 should be a 1', () => {\n    expect(stringToBytes(1.1, 54)).toBe(1);\n  });\n\n  test('< 1 represents a %', () => {\n    expect(stringToBytes(0.3, 51)).toBe(15);\n  });\n\n  test('should throw when no reference supplied', () => {\n    expect(() => stringToBytes(0.3)).toThrow(\n      'For a percentage based memory limit a percentageReference must be supplied',\n    );\n  });\n\n  test('should throw on a bad input', () => {\n    expect(() => stringToBytes(-0.3, 51)).toThrow('Unexpected numerical input');\n  });\n});\n\ndescribe('string input', () => {\n  describe('numeric passthrough', () => {\n    test('0 should be 0', () => {\n      expect(stringToBytes('0')).toBe(0);\n    });\n\n    test('> 1 represents bytes', () => {\n      expect(stringToBytes('50.8')).toBe(50);\n    });\n\n    test('< 1 represents a %', () => {\n      expect(stringToBytes('0.3', 51)).toBe(15);\n    });\n\n    test('should throw when no reference supplied', () => {\n      expect(() => stringToBytes('0.3')).toThrow(\n        'For a percentage based memory limit a percentageReference must be supplied',\n      );\n    });\n\n    test('should throw on a bad input', () => {\n      expect(() => stringToBytes('-0.3', 51)).toThrow(\n        'Unexpected numerical input',\n      );\n    });\n  });\n\n  describe('parsing', () => {\n    test('0%', () => {\n      expect(stringToBytes('0%', 51)).toBe(0);\n    });\n\n    test('30%', () => {\n      expect(stringToBytes('30%', 51)).toBe(15);\n    });\n\n    test('80%', () => {\n      expect(stringToBytes('80%', 51)).toBe(40);\n    });\n\n    test('100%', () => {\n      expect(stringToBytes('100%', 51)).toBe(51);\n    });\n\n    // The units caps is intentionally janky to test for forgiving string parsing.\n    describe('k', () => {\n      test('30k', () => {\n        expect(stringToBytes('30K')).toBe(30_000);\n      });\n\n      test('30KB', () => {\n        expect(stringToBytes('30kB')).toBe(30_000);\n      });\n\n      test('30KiB', () => {\n        expect(stringToBytes('30kIb')).toBe(30_720);\n      });\n    });\n\n    describe('m', () => {\n      test('30M', () => {\n        expect(stringToBytes('30M')).toBe(30_000_000);\n      });\n\n      test('30MB', () => {\n        expect(stringToBytes('30MB')).toBe(30_000_000);\n      });\n\n      test('30MiB', () => {\n        expect(stringToBytes('30MiB')).toBe(31_457_280);\n      });\n    });\n\n    describe('g', () => {\n      test('30G', () => {\n        expect(stringToBytes('30G')).toBe(30_000_000_000);\n      });\n\n      test('30GB', () => {\n        expect(stringToBytes('30gB')).toBe(30_000_000_000);\n      });\n\n      test('30GiB', () => {\n        expect(stringToBytes('30GIB')).toBe(32_212_254_720);\n      });\n    });\n\n    test('unknown unit', () => {\n      expect(() => stringToBytes('50XX')).toThrow('Unexpected input');\n    });\n  });\n});\n\ntest('nesting', () => {\n  expect(stringToBytes(stringToBytes(stringToBytes('30%', 51)))).toBe(15);\n});\n\ntest('null', () => {\n  expect(stringToBytes(null)).toBeNull();\n});\n\ntest('undefined', () => {\n  expect(stringToBytes(undefined)).toBeUndefined();\n});\n",
  "packages/jest-config/src/__tests__/stringToBytes.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-config/src/__tests__/setFromArgv.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {Config} from '@jest/types';\nimport setFromArgv from '../setFromArgv';\n\ntest('maps special values to valid options', () => {\n  const options = {} as Config.InitialOptions;\n  const argv = {\n    coverage: true,\n    env: 'node',\n    json: true,\n    watchAll: true,\n  } as Config.Argv;\n\n  expect(setFromArgv(options, argv)).toMatchObject({\n    collectCoverage: true,\n    testEnvironment: 'node',\n    useStderr: true,\n    watch: false,\n    watchAll: true,\n  });\n});\n\ntest('maps regular values to themselves', () => {\n  const options = {} as Config.InitialOptions;\n  const argv = {\n    collectCoverageFrom: '**/*.{js,jsx}',\n    coverageDirectory: 'covDir',\n    watchman: true,\n  } as Config.Argv;\n\n  expect(setFromArgv(options, argv)).toMatchObject({\n    collectCoverageFrom: '**/*.{js,jsx}',\n    coverageDirectory: 'covDir',\n    watchman: true,\n  });\n});\n\ntest('works with string objects', () => {\n  const options = {} as Config.InitialOptions;\n  const argv = {\n    moduleNameMapper:\n      '{\"types/(.*)\": \"<rootDir>/src/types/$1\", \"types2/(.*)\": [\"<rootDir>/src/types2/$1\", \"<rootDir>/src/types3/$1\"]}',\n    testEnvironmentOptions: '{\"userAgent\": \"Agent/007\"}',\n    transform: '{\"*.js\": \"<rootDir>/transformer\"}',\n  } as Config.Argv;\n  expect(setFromArgv(options, argv)).toMatchObject({\n    moduleNameMapper: {\n      'types/(.*)': '<rootDir>/src/types/$1',\n      'types2/(.*)': ['<rootDir>/src/types2/$1', '<rootDir>/src/types3/$1'],\n    },\n    testEnvironmentOptions: {\n      userAgent: 'Agent/007',\n    },\n    transform: {\n      '*.js': '<rootDir>/transformer',\n    },\n  });\n});\n\ntest('explicit flags override those from --config', () => {\n  const options = {} as Config.InitialOptions;\n  const argv = {\n    config: '{\"watch\": false}',\n    watch: true,\n  } as Config.Argv;\n  expect(setFromArgv(options, argv)).toMatchObject({watch: true});\n});\n",
  "packages/jest-config/src/__tests__/setFromArgv.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport {};\n",
  "packages/jest-config/src/__tests__/resolveConfigPath.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport {cleanup, writeFiles} from '../../../../e2e/Utils';\nimport {JEST_CONFIG_EXT_ORDER} from '../constants';\nimport resolveConfigPath from '../resolveConfigPath';\n\nconst DIR = path.resolve(tmpdir(), 'resolve_config_path_test');\nconst ERROR_PATTERN = /Could not find a config file based on provided values/;\nconst NO_ROOT_DIR_ERROR_PATTERN = /Can't find a root directory/;\nconst MULTIPLE_CONFIGS_ERROR_PATTERN = /Multiple configurations found/;\n\nbeforeEach(() => cleanup(DIR));\nafterEach(() => cleanup(DIR));\n\ndescribe.each([...JEST_CONFIG_EXT_ORDER])(\n  'Resolve config path %s',\n  extension => {\n    test(`file path with \"${extension}\"`, () => {\n      const relativeConfigPath = `a/b/c/my_config${extension}`;\n      const absoluteConfigPath = path.resolve(DIR, relativeConfigPath);\n\n      writeFiles(DIR, {[relativeConfigPath]: ''});\n\n      // absolute\n      expect(resolveConfigPath(absoluteConfigPath, DIR)).toBe(\n        absoluteConfigPath,\n      );\n      expect(() => resolveConfigPath('/does_not_exist', DIR)).toThrow(\n        NO_ROOT_DIR_ERROR_PATTERN,\n      );\n\n      // relative\n      expect(resolveConfigPath(relativeConfigPath, DIR)).toBe(\n        absoluteConfigPath,\n      );\n      expect(() => resolveConfigPath('does_not_exist', DIR)).toThrow(\n        NO_ROOT_DIR_ERROR_PATTERN,\n      );\n    });\n\n    test(`directory path with \"${extension}\"`, () => {\n      const relativePackageJsonPath = 'a/b/c/package.json';\n      const absolutePackageJsonPath = path.resolve(\n        DIR,\n        relativePackageJsonPath,\n      );\n      const relativeJestConfigPath = `a/b/c/jest.config${extension}`;\n      const absoluteJestConfigPath = path.resolve(DIR, relativeJestConfigPath);\n\n      // no configs yet. should throw\n      writeFiles(DIR, {[`a/b/c/some_random_file${extension}`]: ''});\n\n      expect(() =>\n        // absolute\n        resolveConfigPath(path.dirname(absoluteJestConfigPath), DIR),\n      ).toThrow(ERROR_PATTERN);\n\n      expect(() =>\n        // relative\n        resolveConfigPath(path.dirname(relativeJestConfigPath), DIR),\n      ).toThrow(ERROR_PATTERN);\n\n      writeFiles(DIR, {[relativePackageJsonPath]: ''});\n\n      // absolute\n      expect(\n        resolveConfigPath(path.dirname(absolutePackageJsonPath), DIR),\n      ).toBe(absolutePackageJsonPath);\n\n      // relative\n      expect(\n        resolveConfigPath(path.dirname(relativePackageJsonPath), DIR),\n      ).toBe(absolutePackageJsonPath);\n\n      // jest.config.js takes precedence\n      writeFiles(DIR, {[relativeJestConfigPath]: ''});\n\n      // absolute\n      expect(\n        resolveConfigPath(path.dirname(absolutePackageJsonPath), DIR),\n      ).toBe(absoluteJestConfigPath);\n\n      // relative\n      expect(\n        resolveConfigPath(path.dirname(relativePackageJsonPath), DIR),\n      ).toBe(absoluteJestConfigPath);\n\n      // jest.config.js and package.json with 'jest' cannot be used together\n      writeFiles(DIR, {[relativePackageJsonPath]: JSON.stringify({jest: {}})});\n\n      // absolute\n      expect(() =>\n        resolveConfigPath(path.dirname(absolutePackageJsonPath), DIR),\n      ).toThrow(MULTIPLE_CONFIGS_ERROR_PATTERN);\n\n      // relative\n      expect(() =>\n        resolveConfigPath(path.dirname(relativePackageJsonPath), DIR),\n      ).toThrow(MULTIPLE_CONFIGS_ERROR_PATTERN);\n\n      expect(() => {\n        resolveConfigPath(\n          path.join(path.dirname(relativePackageJsonPath), 'j/x/b/m/'),\n          DIR,\n        );\n      }).toThrow(NO_ROOT_DIR_ERROR_PATTERN);\n    });\n\n    test('file path from \"jest\" key', () => {\n      const anyFileName = `anyJestConfigfile${extension}`;\n      const relativePackageJsonPath = 'a/b/c/package.json';\n      const relativeAnyFilePath = `a/b/c/conf/${anyFileName}`;\n      const absolutePackageJsonPath = path.resolve(\n        DIR,\n        relativePackageJsonPath,\n      );\n      const absoluteAnyFilePath = path.resolve(DIR, relativeAnyFilePath);\n\n      writeFiles(DIR, {\n        'a/b/c/package.json': `{ \"jest\": \"conf/${anyFileName}\" }`,\n      });\n      writeFiles(DIR, {[relativeAnyFilePath]: ''});\n\n      const result = resolveConfigPath(\n        path.dirname(absolutePackageJsonPath),\n        DIR,\n      );\n\n      expect(result).toBe(absoluteAnyFilePath);\n    });\n\n    test('not a file path from \"jest\" key', () => {\n      const anyFileName = `anyJestConfigfile${extension}`;\n      const relativePackageJsonPath = 'a/b/c/package.json';\n      const relativeAnyFilePath = `a/b/c/conf/${anyFileName}`;\n      const absolutePackageJsonPath = path.resolve(\n        DIR,\n        relativePackageJsonPath,\n      );\n\n      writeFiles(DIR, {\n        'a/b/c/package.json': '{ \"jest\": {\"verbose\": true} }',\n      });\n      writeFiles(DIR, {[relativeAnyFilePath]: ''});\n\n      const result = resolveConfigPath(\n        path.dirname(absolutePackageJsonPath),\n        DIR,\n      );\n\n      expect(result).toBe(absolutePackageJsonPath);\n    });\n\n    test('not a valid file when \"jest\" key is a path', () => {\n      const anyFileName = `anyJestConfigfile${extension}`;\n      const relativePackageJsonPath = 'a/b/c/package.json';\n      const relativeAnyFilePath = `a/b/c/conf/${anyFileName}`;\n      const absolutePackageJsonPath = path.resolve(\n        DIR,\n        relativePackageJsonPath,\n      );\n\n      writeFiles(DIR, {\n        'a/b/c/package.json': '{ \"jest\": \"conf/nonExistentConfigfile.json\" }',\n      });\n      writeFiles(DIR, {[relativeAnyFilePath]: ''});\n\n      expect(() =>\n        resolveConfigPath(path.dirname(absolutePackageJsonPath), DIR),\n      ).toThrow(\n        /Jest expects the string configuration to point to a file, but .* not\\./,\n      );\n    });\n  },\n);\n\nconst pickPairsWithSameOrder = <T>(array: ReadonlyArray<T>) =>\n  array.flatMap((value1, idx, arr) =>\n    arr.slice(idx + 1).map(value2 => [value1, value2]),\n  );\n\ntest('pickPairsWithSameOrder', () => {\n  expect(pickPairsWithSameOrder([1, 2, 3])).toStrictEqual([\n    [1, 2],\n    [1, 3],\n    [2, 3],\n  ]);\n});\n\ndescribe.each(pickPairsWithSameOrder(JEST_CONFIG_EXT_ORDER))(\n  'Using multiple configs shows error',\n  (extension1, extension2) => {\n    test(`Using jest.config${extension1} and jest.config${extension2} shows error`, () => {\n      const relativeJestConfigPaths = [\n        `a/b/c/jest.config${extension1}`,\n        `a/b/c/jest.config${extension2}`,\n      ];\n\n      writeFiles(DIR, {\n        [relativeJestConfigPaths[0]]: '',\n        [relativeJestConfigPaths[1]]: '',\n      });\n\n      expect(() =>\n        resolveConfigPath(path.dirname(relativeJestConfigPaths[0]), DIR),\n      ).toThrow(MULTIPLE_CONFIGS_ERROR_PATTERN);\n    });\n  },\n);\n",
  "packages/jest-config/src/__tests__/resolveConfigPath.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-config/src/__tests__/readInitialOptions.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type {Config} from '@jest/types';\nimport {readInitialOptions} from '../';\n\ndescribe(readInitialOptions, () => {\n  test('should be able to use serialized jest config', async () => {\n    const inputConfig = {jestConfig: 'serialized'};\n    const {config, configPath} = await readInitialOptions(\n      JSON.stringify(inputConfig),\n    );\n    expect(config).toEqual({...inputConfig, rootDir: process.cwd()});\n    expect(configPath).toBeNull();\n  });\n\n  test('should allow deserialized options', async () => {\n    const inputConfig = {jestConfig: 'deserialized'};\n    const {config, configPath} = await readInitialOptions(undefined, {\n      packageRootOrConfig: inputConfig as Config.InitialOptions,\n      parentConfigDirname: process.cwd(),\n    });\n    expect(config).toEqual({...inputConfig, rootDir: process.cwd()});\n    expect(configPath).toBeNull();\n  });\n  // Note: actual file reading is tested in e2e test\n});\n",
  "packages/jest-config/src/__tests__/readInitialOptions.test.d.ts": "export {};\n",
  "packages/jest-config/src/__tests__/readConfigs.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport {readConfigs} from '../';\n\njest.mock('graceful-fs', () => ({\n  ...jest.requireActual<typeof import('fs')>('fs'),\n  existsSync: jest.fn(() => true),\n  lstatSync: jest.fn(() => ({\n    isDirectory: () => false,\n  })),\n}));\n\ntest('readConfigs() throws when called without project paths', async () => {\n  await expect(\n    // @ts-expect-error\n    readConfigs(null /* argv */, [] /* projectPaths */),\n  ).rejects.toThrow('jest: No configuration found for any project.');\n});\n",
  "packages/jest-config/src/__tests__/readConfigs.test.d.ts": "export {};\n",
  "packages/jest-config/src/__tests__/readConfigFileAndSetRootDir.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport path from 'path';\nimport * as fs from 'graceful-fs';\nimport {requireOrImportModule} from 'jest-util';\nimport readConfigFileAndSetRootDir from '../readConfigFileAndSetRootDir';\n\njest.mock('graceful-fs').mock('jest-util');\n\ndescribe('readConfigFileAndSetRootDir', () => {\n  describe('JavaScript file', () => {\n    test('reads config and sets `rootDir`', async () => {\n      jest.mocked(requireOrImportModule).mockResolvedValueOnce({notify: true});\n\n      const rootDir = path.resolve('some', 'path', 'to');\n      const config = await readConfigFileAndSetRootDir(\n        path.join(rootDir, 'jest.config.js'),\n      );\n\n      expect(config).toEqual({notify: true, rootDir});\n    });\n\n    test('handles exported function', async () => {\n      jest\n        .mocked(requireOrImportModule)\n        .mockResolvedValueOnce(() => ({bail: 1}));\n\n      const rootDir = path.resolve('some', 'path', 'to');\n      const config = await readConfigFileAndSetRootDir(\n        path.join(rootDir, 'jest.config.js'),\n      );\n\n      expect(config).toEqual({bail: 1, rootDir});\n    });\n\n    test('handles exported async function', async () => {\n      jest\n        .mocked(requireOrImportModule)\n        .mockResolvedValueOnce(async () => ({testTimeout: 10_000}));\n\n      const rootDir = path.resolve('some', 'path', 'to');\n      const config = await readConfigFileAndSetRootDir(\n        path.join(rootDir, 'jest.config.js'),\n      );\n\n      expect(config).toEqual({rootDir, testTimeout: 10_000});\n    });\n  });\n\n  describe('JSON file', () => {\n    test('reads config and sets `rootDir`', async () => {\n      jest.mocked(fs.readFileSync).mockReturnValueOnce('{ \"verbose\": true }');\n\n      const rootDir = path.resolve('some', 'path', 'to');\n      const config = await readConfigFileAndSetRootDir(\n        path.join(rootDir, 'jest.config.json'),\n      );\n\n      expect(config).toEqual({rootDir, verbose: true});\n    });\n\n    test('supports comments in JSON', async () => {\n      jest\n        .mocked(fs.readFileSync)\n        .mockReturnValueOnce('{ // test comment\\n \"bail\": true }');\n\n      const rootDir = path.resolve('some', 'path', 'to');\n      const config = await readConfigFileAndSetRootDir(\n        path.join(rootDir, 'jest.config.json'),\n      );\n\n      expect(config).toEqual({bail: true, rootDir});\n    });\n  });\n\n  describe('package.json file', () => {\n    test('reads config from \"jest\" key and sets `rootDir`', async () => {\n      jest\n        .mocked(fs.readFileSync)\n        .mockReturnValueOnce('{ \"jest\": { \"coverage\": true } }');\n\n      const rootDir = path.resolve('some', 'path', 'to');\n      const config = await readConfigFileAndSetRootDir(\n        path.join(rootDir, 'package.json'),\n      );\n\n      expect(config).toEqual({coverage: true, rootDir});\n    });\n\n    test('sets rootDir if \"jest\" is absent', async () => {\n      jest.mocked(fs.readFileSync).mockReturnValueOnce('{ \"name\": \"test\" }');\n\n      const rootDir = path.resolve('some', 'path', 'to');\n      const config = await readConfigFileAndSetRootDir(\n        path.join(rootDir, 'package.json'),\n      );\n\n      expect(config).toEqual({rootDir});\n    });\n  });\n\n  describe('sets `rootDir`', () => {\n    test('handles frozen config object', async () => {\n      jest\n        .mocked(requireOrImportModule)\n        .mockResolvedValueOnce(Object.freeze({preset: 'some-preset'}));\n\n      const rootDir = path.resolve('some', 'path', 'to');\n      const config = await readConfigFileAndSetRootDir(\n        path.join(rootDir, 'jest.config.js'),\n      );\n\n      expect(config).toEqual({preset: 'some-preset', rootDir});\n    });\n\n    test('keeps the path if it is absolute', async () => {\n      const rootDir = path.resolve('some', 'path', 'to');\n      jest.mocked(requireOrImportModule).mockResolvedValueOnce({\n        rootDir,\n        testEnvironment: 'node',\n      });\n\n      const config = await readConfigFileAndSetRootDir(\n        path.join(path.resolve('other', 'path', 'to'), 'jest.config.js'),\n      );\n\n      expect(config).toEqual({rootDir, testEnvironment: 'node'});\n    });\n\n    test('resolves the path relative to dirname of the config file', async () => {\n      jest.mocked(requireOrImportModule).mockResolvedValueOnce({\n        restoreMocks: true,\n        rootDir: path.join('path', 'to'),\n      });\n\n      const config = await readConfigFileAndSetRootDir(\n        path.join(path.resolve('some'), 'jest.config.js'),\n      );\n\n      expect(config).toEqual({\n        restoreMocks: true,\n        rootDir: path.resolve('some', 'path', 'to'),\n      });\n    });\n\n    test('resolves relative path when the read config object if frozen', async () => {\n      jest.mocked(requireOrImportModule).mockResolvedValueOnce(\n        Object.freeze({\n          resetModules: true,\n          rootDir: path.join('path', 'to'),\n        }),\n      );\n\n      const config = await readConfigFileAndSetRootDir(\n        path.join(path.resolve('some'), 'jest.config.js'),\n      );\n\n      expect(config).toEqual({\n        resetModules: true,\n        rootDir: path.resolve('some', 'path', 'to'),\n      });\n    });\n  });\n});\n",
  "packages/jest-config/src/__tests__/readConfigFileAndSetRootDir.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-config/src/__tests__/readConfig.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {readConfig} from '../';\n\ntest('readConfig() throws when an object is passed without a file path', async () => {\n  await expect(\n    readConfig(\n      {$0: '', _: []},\n      {} /* packageRootOrConfig */,\n      false /* skipArgvConfigOption */,\n      null /* parentConfigPath */,\n    ),\n  ).rejects.toThrow(\n    'Jest: Cannot use configuration as an object without a file path',\n  );\n});\n",
  "packages/jest-config/src/__tests__/readConfig.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-config/src/__tests__/parseShardPair.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport {parseShardPair} from '../parseShardPair';\n\nit('raises an exception if shard has wrong format', () => {\n  expect(() => parseShardPair('mumble')).toThrow(\n    'string in the format of <n>/<m>',\n  );\n});\n\nit('raises an exception if shard pair has to many items', () => {\n  expect(() => parseShardPair('1/2/3')).toThrow(\n    'string in the format of <n>/<m>',\n  );\n});\n\nit('raises an exception if shard has floating points', () => {\n  expect(() => parseShardPair('1.0/1')).toThrow(\n    'string in the format of <n>/<m>',\n  );\n});\n\nit('raises an exception if first item in shard pair is no number', () => {\n  expect(() => parseShardPair('a/1')).toThrow(\n    'string in the format of <n>/<m>',\n  );\n});\n\nit('raises an exception if second item in shard pair is no number', () => {\n  expect(() => parseShardPair('1/a')).toThrow(\n    'string in the format of <n>/<m>',\n  );\n});\n\nit('raises an exception if shard contains negative number', () => {\n  expect(() => parseShardPair('1/-1')).toThrow(\n    'string in the format of <n>/<m>',\n  );\n});\n\nit('raises an exception if shard is zero-indexed', () => {\n  expect(() => parseShardPair('0/1')).toThrow(\n    'requires 1-based values, received 0',\n  );\n});\n\nit('raises an exception if shard index is larger than shard count', () => {\n  expect(() => parseShardPair('2/1')).toThrow(\n    'requires <n> to be lower or equal than <m>',\n  );\n});\n\nit('allows valid shard format', () => {\n  expect(() => parseShardPair('1/2')).not.toThrow();\n});\n",
  "packages/jest-config/src/__tests__/parseShardPair.test.d.ts": "export {};\n",
  "packages/jest-config/src/__tests__/normalize.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {createHash} from 'crypto';\nimport * as path from 'path';\nimport * as semver from 'semver';\nimport type {Config} from '@jest/types';\nimport {escapeStrForRegex} from 'jest-regex-util';\nimport Defaults from '../Defaults';\nimport {DEFAULT_JS_PATTERN} from '../constants';\nimport normalize, {type AllOptions} from '../normalize';\n\nconst DEFAULT_CSS_PATTERN = '\\\\.(css)$';\n\njest\n  .mock('path', () => jest.requireActual<typeof import('path')>('path').posix)\n  .mock('graceful-fs', () => {\n    const realFs = jest.requireActual<typeof import('fs')>('fs');\n\n    return {\n      ...realFs,\n      statSync: () => ({isDirectory: () => true}),\n    };\n  })\n  .mock('jest-util', () => {\n    const realUtil =\n      jest.requireActual<typeof import('jest-util')>('jest-util');\n\n    return {\n      ...realUtil,\n      requireOrImportModule: (filePath: string, interop = true) => {\n        const result = require(filePath);\n\n        if (interop) {\n          return realUtil.interopRequireDefault(result).default;\n        }\n\n        return result;\n      },\n    };\n  });\n\nlet root: string;\nlet expectedPathFooBar: string;\nlet expectedPathFooQux: string;\nlet expectedPathAbs: string;\nlet expectedPathAbsAnother: string;\n\nlet virtualModuleRegexes: Array<RegExp>;\nbeforeEach(() => {\n  virtualModuleRegexes = [/jest-circus/, /babel-jest/];\n});\nconst findNodeModule = jest.fn((name: string) => {\n  if (virtualModuleRegexes.some(regex => regex.test(name))) {\n    return name;\n  }\n  return null;\n});\n\n// Windows uses backslashes for path separators, which need to be escaped in\n// regular expressions. This little helper function helps us generate the\n// expected strings for checking path patterns.\nfunction joinForPattern(...args: Array<string>) {\n  return args.join(escapeStrForRegex(path.sep));\n}\n\nbeforeEach(() => {\n  root = path.resolve('/');\n  expectedPathFooBar = path.join(root, 'root', 'path', 'foo', 'bar', 'baz');\n  expectedPathFooQux = path.join(root, 'root', 'path', 'foo', 'qux', 'quux');\n  expectedPathAbs = path.join(root, 'an', 'abs', 'path');\n  expectedPathAbsAnother = path.join(root, 'another', 'abs', 'path');\n\n  (\n    require('jest-resolve') as typeof import('jest-resolve')\n  ).default.findNodeModule = findNodeModule;\n\n  jest.spyOn(console, 'warn');\n});\n\nafterEach(() => {\n  jest.mocked(console.warn).mockRestore();\n});\n\nit('picks an id based on the rootDir', async () => {\n  const rootDir = '/root/path/foo';\n  const expected = createHash('sha1')\n    .update('/root/path/foo')\n    .update(String(Number.POSITIVE_INFINITY))\n    .digest('hex')\n    .slice(0, 32);\n  const {options} = await normalize(\n    {\n      rootDir,\n    },\n    {} as Config.Argv,\n  );\n  expect(options.id).toBe(expected);\n});\n\nit('keeps custom project id based on the projects rootDir', async () => {\n  const id = 'test';\n  const {options} = await normalize(\n    {\n      projects: [{id, rootDir: '/path/to/foo'}],\n      rootDir: '/root/path/baz',\n    },\n    {} as Config.Argv,\n  );\n\n  expect((options.projects as Array<Config.InitialProjectOptions>)[0].id).toBe(\n    id,\n  );\n});\n\nit('validation warning occurs when options not for projects is set', async () => {\n  const mockWarn = jest.mocked(console.warn).mockImplementation(() => {});\n  const rootDir = '/root/path/foo';\n  await normalize(\n    {\n      bail: true, // an option not for projects\n      rootDir,\n    },\n    {} as Config.Argv,\n    rootDir,\n    1,\n    true, // isProjectOptions\n  );\n\n  expect(mockWarn).toHaveBeenCalledTimes(1);\n});\n\nit('keeps custom ids based on the rootDir', async () => {\n  const {options} = await normalize(\n    {\n      id: 'custom-id',\n      rootDir: '/root/path/foo',\n    },\n    {} as Config.Argv,\n  );\n\n  expect(options.id).toBe('custom-id');\n});\n\nit('minimal config is stable across runs', async () => {\n  const firstNormalization = await normalize({rootDir: '/root/path/foo'}, {\n    seed: 55_555,\n  } as Config.Argv);\n  const secondNormalization = await normalize({rootDir: '/root/path/foo'}, {\n    seed: 55_555,\n  } as Config.Argv);\n\n  expect(firstNormalization).toEqual(secondNormalization);\n  expect(JSON.stringify(firstNormalization)).toBe(\n    JSON.stringify(secondNormalization),\n  );\n});\n\nit('sets coverageReporters correctly when argv.json is set', async () => {\n  const {options} = await normalize(\n    {\n      rootDir: '/root/path/foo',\n    },\n    {\n      json: true,\n    } as Config.Argv,\n  );\n\n  expect(options.coverageReporters).toEqual(['json', 'lcov', 'clover']);\n});\n\ndescribe('rootDir', () => {\n  it('throws if the options is missing a rootDir property', async () => {\n    expect.assertions(1);\n\n    await expect(\n      normalize({}, {} as Config.Argv),\n    ).rejects.toThrowErrorMatchingSnapshot();\n  });\n});\n\ndescribe('automock', () => {\n  it('falsy automock is not overwritten', async () => {\n    jest.mocked(console.warn).mockImplementation(() => {});\n    const {options} = await normalize(\n      {\n        automock: false,\n        rootDir: '/root/path/foo',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.automock).toBe(false);\n  });\n});\n\ndescribe('collectCoverageFrom', () => {\n  it('ignores <rootDir> tokens', async () => {\n    const barBaz = 'bar/baz';\n    const quxQuux = 'qux/quux/';\n    const notQuxQuux = `!${quxQuux}`;\n\n    const {options} = await normalize(\n      {\n        collectCoverageFrom: [\n          barBaz,\n          notQuxQuux,\n          `<rootDir>/${barBaz}`,\n          `!<rootDir>/${quxQuux}`,\n        ],\n        rootDir: '/root/path/foo/',\n      },\n      {} as Config.Argv,\n    );\n\n    const expected = [barBaz, notQuxQuux, barBaz, notQuxQuux];\n\n    expect(options.collectCoverageFrom).toEqual(expected);\n  });\n});\n\ndescribe('findRelatedTests', () => {\n  it('it generates --coverageCoverageFrom patterns when needed', async () => {\n    const sourceFile = 'file1.js';\n\n    const {options} = await normalize(\n      {\n        collectCoverage: true,\n        rootDir: '/root/path/foo/',\n      },\n      {\n        _: [\n          `/root/path/${sourceFile}`,\n          sourceFile,\n          `<rootDir>/bar/${sourceFile}`,\n        ],\n        findRelatedTests: true,\n      } as Config.Argv,\n    );\n\n    const expected = [`../${sourceFile}`, `${sourceFile}`, `bar/${sourceFile}`];\n\n    expect(options.collectCoverageFrom).toEqual(expected);\n  });\n});\n\nfunction testPathArray(key: keyof AllOptions) {\n  it('normalizes all paths relative to rootDir', async () => {\n    const {options} = await normalize(\n      {\n        [key]: ['bar/baz', 'qux/quux/'],\n        rootDir: '/root/path/foo',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options[key]).toEqual([expectedPathFooBar, expectedPathFooQux]);\n  });\n\n  it('does not change absolute paths', async () => {\n    const {options} = await normalize(\n      {\n        [key]: ['/an/abs/path', '/another/abs/path'],\n        rootDir: '/root/path/foo',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options[key]).toEqual([expectedPathAbs, expectedPathAbsAnother]);\n  });\n\n  it('substitutes <rootDir> tokens', async () => {\n    const {options} = await normalize(\n      {\n        [key]: ['<rootDir>/bar/baz'],\n        rootDir: '/root/path/foo',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options[key]).toEqual([expectedPathFooBar]);\n  });\n}\n\ndescribe('roots', () => {\n  testPathArray('roots');\n});\n\ndescribe('reporters', () => {\n  let Resolver: typeof import('jest-resolve').default;\n  beforeEach(() => {\n    Resolver = (require('jest-resolve') as typeof import('jest-resolve'))\n      .default;\n    Resolver.findNodeModule = jest.fn((name: string) => name);\n  });\n\n  it('allows empty list', async () => {\n    const {options} = await normalize(\n      {\n        reporters: [],\n        rootDir: '/root/',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.reporters).toEqual([]);\n  });\n\n  it('normalizes the path and options object', async () => {\n    const {options} = await normalize(\n      {\n        reporters: [\n          'default',\n          'github-actions',\n          '<rootDir>/custom-reporter.js',\n          ['<rootDir>/custom-reporter.js', {banana: 'yes', pineapple: 'no'}],\n          ['jest-junit', {outputName: 'report.xml'}],\n        ],\n        rootDir: '/root/',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.reporters).toEqual([\n      ['default', {}],\n      ['github-actions', {}],\n      ['/root/custom-reporter.js', {}],\n      ['/root/custom-reporter.js', {banana: 'yes', pineapple: 'no'}],\n      ['jest-junit', {outputName: 'report.xml'}],\n    ]);\n  });\n\n  it('throws an error if value is neither string nor array', async () => {\n    expect.assertions(1);\n    await expect(\n      normalize(\n        {\n          // @ts-expect-error: Testing runtime error\n          reporters: [123],\n          rootDir: '/root/',\n        },\n        {} as Config.Argv,\n      ),\n    ).rejects.toThrowErrorMatchingSnapshot();\n  });\n\n  it('throws an error if first value in the tuple is not a string', async () => {\n    expect.assertions(1);\n    await expect(\n      normalize(\n        {\n          // @ts-expect-error: Testing runtime error\n          reporters: [[123]],\n          rootDir: '/root/',\n        },\n        {} as Config.Argv,\n      ),\n    ).rejects.toThrowErrorMatchingSnapshot();\n  });\n\n  it('throws an error if second value is missing in the tuple', async () => {\n    expect.assertions(1);\n    await expect(\n      normalize(\n        {\n          // @ts-expect-error: Testing runtime error\n          reporters: [['some-reporter']],\n          rootDir: '/root/',\n        },\n        {} as Config.Argv,\n      ),\n    ).rejects.toThrowErrorMatchingSnapshot();\n  });\n\n  it('throws an error if second value in the tuple is not an object', async () => {\n    expect.assertions(1);\n    await expect(\n      normalize(\n        {\n          // @ts-expect-error: Testing runtime error\n          reporters: [['some-reporter', true]],\n          rootDir: '/root/',\n        },\n        {} as Config.Argv,\n      ),\n    ).rejects.toThrowErrorMatchingSnapshot();\n  });\n});\n\ndescribe('transform', () => {\n  let Resolver: typeof import('jest-resolve').default;\n  beforeEach(() => {\n    Resolver = (require('jest-resolve') as typeof import('jest-resolve'))\n      .default;\n    Resolver.findNodeModule = jest.fn((name: string) => name);\n  });\n\n  it('normalizes the path', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root/',\n        transform: {\n          [DEFAULT_CSS_PATTERN]: '<rootDir>/node_modules/jest-regex-util',\n          [DEFAULT_JS_PATTERN]: 'babel-jest',\n          'abs-path': '/qux/quux',\n        },\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.transform).toEqual([\n      [DEFAULT_CSS_PATTERN, '/root/node_modules/jest-regex-util', {}],\n      [DEFAULT_JS_PATTERN, require.resolve('babel-jest'), {}],\n      ['abs-path', '/qux/quux', {}],\n    ]);\n  });\n  it(\"pulls in config if it's passed as an array, and defaults to empty object\", async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root/',\n        transform: {\n          [DEFAULT_CSS_PATTERN]: '<rootDir>/node_modules/jest-regex-util',\n          [DEFAULT_JS_PATTERN]: ['babel-jest', {rootMode: 'upward'}],\n          'abs-path': '/qux/quux',\n        },\n      },\n      {} as Config.Argv,\n    );\n    expect(options.transform).toEqual([\n      [DEFAULT_CSS_PATTERN, '/root/node_modules/jest-regex-util', {}],\n      [DEFAULT_JS_PATTERN, require.resolve('babel-jest'), {rootMode: 'upward'}],\n      ['abs-path', '/qux/quux', {}],\n    ]);\n  });\n});\n\ndescribe('haste', () => {\n  let Resolver: typeof import('jest-resolve').default;\n  beforeEach(() => {\n    Resolver = (require('jest-resolve') as typeof import('jest-resolve'))\n      .default;\n    Resolver.findNodeModule = jest.fn((name: string) => name);\n  });\n\n  it('normalizes the path for hasteImplModulePath', async () => {\n    const {options} = await normalize(\n      {\n        haste: {\n          hasteImplModulePath: '<rootDir>/haste_impl.js',\n        },\n        rootDir: '/root/',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.haste).toEqual({\n      hasteImplModulePath: '/root/haste_impl.js',\n    });\n  });\n});\n\ndescribe('setupFilesAfterEnv', () => {\n  let Resolver: typeof import('jest-resolve').default;\n  beforeEach(() => {\n    Resolver = (require('jest-resolve') as typeof import('jest-resolve'))\n      .default;\n    Resolver.findNodeModule = jest.fn((name: string) =>\n      name.startsWith('/') ? name : `/root/path/foo${path.sep}${name}`,\n    );\n  });\n\n  it('normalizes the path according to rootDir', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root/path/foo',\n        setupFilesAfterEnv: ['bar/baz'],\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.setupFilesAfterEnv).toEqual([expectedPathFooBar]);\n  });\n\n  it('does not change absolute paths', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root/path/foo',\n        setupFilesAfterEnv: ['/an/abs/path'],\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.setupFilesAfterEnv).toEqual([expectedPathAbs]);\n  });\n\n  it('substitutes <rootDir> tokens', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root/path/foo',\n        setupFilesAfterEnv: ['<rootDir>/bar/baz'],\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.setupFilesAfterEnv).toEqual([expectedPathFooBar]);\n  });\n});\n\ndescribe('coveragePathIgnorePatterns', () => {\n  it('does not normalize paths relative to rootDir', async () => {\n    // This is a list of patterns, so we can't assume any of them are\n    // directories\n    const {options} = await normalize(\n      {\n        coveragePathIgnorePatterns: ['bar/baz', 'qux/quux'],\n        rootDir: '/root/path/foo',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.coveragePathIgnorePatterns).toEqual([\n      joinForPattern('bar', 'baz'),\n      joinForPattern('qux', 'quux'),\n    ]);\n  });\n\n  it('does not normalize trailing slashes', async () => {\n    // This is a list of patterns, so we can't assume any of them are\n    // directories\n    const {options} = await normalize(\n      {\n        coveragePathIgnorePatterns: ['bar/baz', 'qux/quux/'],\n        rootDir: '/root/path/foo',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.coveragePathIgnorePatterns).toEqual([\n      joinForPattern('bar', 'baz'),\n      joinForPattern('qux', 'quux', ''),\n    ]);\n  });\n\n  it('substitutes <rootDir> tokens', async () => {\n    const {options} = await normalize(\n      {\n        coveragePathIgnorePatterns: ['hasNoToken', '<rootDir>/hasAToken'],\n        rootDir: '/root/path/foo',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.coveragePathIgnorePatterns).toEqual([\n      'hasNoToken',\n      joinForPattern('', 'root', 'path', 'foo', 'hasAToken'),\n    ]);\n  });\n});\n\ndescribe('watchPathIgnorePatterns', () => {\n  it('does not normalize paths relative to rootDir', async () => {\n    // This is a list of patterns, so we can't assume any of them are\n    // directories\n    const {options} = await normalize(\n      {\n        rootDir: '/root/path/foo',\n        watchPathIgnorePatterns: ['bar/baz', 'qux/quux'],\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.watchPathIgnorePatterns).toEqual([\n      joinForPattern('bar', 'baz'),\n      joinForPattern('qux', 'quux'),\n    ]);\n  });\n\n  it('does not normalize trailing slashes', async () => {\n    // This is a list of patterns, so we can't assume any of them are\n    // directories\n    const {options} = await normalize(\n      {\n        rootDir: '/root/path/foo',\n        watchPathIgnorePatterns: ['bar/baz', 'qux/quux/'],\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.watchPathIgnorePatterns).toEqual([\n      joinForPattern('bar', 'baz'),\n      joinForPattern('qux', 'quux', ''),\n    ]);\n  });\n\n  it('substitutes <rootDir> tokens', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root/path/foo',\n        watchPathIgnorePatterns: ['hasNoToken', '<rootDir>/hasAToken'],\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.watchPathIgnorePatterns).toEqual([\n      'hasNoToken',\n      joinForPattern('', 'root', 'path', 'foo', 'hasAToken'),\n    ]);\n  });\n});\n\ndescribe('testPathIgnorePatterns', () => {\n  it('does not normalize paths relative to rootDir', async () => {\n    // This is a list of patterns, so we can't assume any of them are\n    // directories\n    const {options} = await normalize(\n      {\n        rootDir: '/root/path/foo',\n        testPathIgnorePatterns: ['bar/baz', 'qux/quux'],\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.testPathIgnorePatterns).toEqual([\n      joinForPattern('bar', 'baz'),\n      joinForPattern('qux', 'quux'),\n    ]);\n  });\n\n  it('does not normalize trailing slashes', async () => {\n    // This is a list of patterns, so we can't assume any of them are\n    // directories\n    const {options} = await normalize(\n      {\n        rootDir: '/root/path/foo',\n        testPathIgnorePatterns: ['bar/baz', 'qux/quux/'],\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.testPathIgnorePatterns).toEqual([\n      joinForPattern('bar', 'baz'),\n      joinForPattern('qux', 'quux', ''),\n    ]);\n  });\n\n  it('substitutes <rootDir> tokens', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root/path/foo',\n        testPathIgnorePatterns: ['hasNoToken', '<rootDir>/hasAToken'],\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.testPathIgnorePatterns).toEqual([\n      'hasNoToken',\n      joinForPattern('', 'root', 'path', 'foo', 'hasAToken'),\n    ]);\n  });\n});\n\ndescribe('modulePathIgnorePatterns', () => {\n  it('does not normalize paths relative to rootDir', async () => {\n    // This is a list of patterns, so we can't assume any of them are\n    // directories\n    const {options} = await normalize(\n      {\n        modulePathIgnorePatterns: ['bar/baz', 'qux/quux'],\n        rootDir: '/root/path/foo',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.modulePathIgnorePatterns).toEqual([\n      joinForPattern('bar', 'baz'),\n      joinForPattern('qux', 'quux'),\n    ]);\n  });\n\n  it('does not normalize trailing slashes', async () => {\n    // This is a list of patterns, so we can't assume any of them are\n    // directories\n    const {options} = await normalize(\n      {\n        modulePathIgnorePatterns: ['bar/baz', 'qux/quux/'],\n        rootDir: '/root/path/foo',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.modulePathIgnorePatterns).toEqual([\n      joinForPattern('bar', 'baz'),\n      joinForPattern('qux', 'quux', ''),\n    ]);\n  });\n\n  it('substitutes <rootDir> tokens', async () => {\n    const {options} = await normalize(\n      {\n        modulePathIgnorePatterns: ['hasNoToken', '<rootDir>/hasAToken'],\n        rootDir: '/root/path/foo',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.modulePathIgnorePatterns).toEqual([\n      'hasNoToken',\n      joinForPattern('', 'root', 'path', 'foo', 'hasAToken'),\n    ]);\n  });\n});\n\ndescribe('testRunner', () => {\n  it('defaults to Circus', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root/path/foo',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.testRunner).toMatch('jest-circus');\n  });\n\n  it('resolves jasmine', async () => {\n    const Resolver = (require('jest-resolve') as typeof import('jest-resolve'))\n      .default;\n    Resolver.findNodeModule = jest.fn((name: string) => name);\n    const {options} = await normalize(\n      {\n        rootDir: '/root/path/foo',\n      },\n      {\n        testRunner: 'jasmine2',\n      } as Config.Argv,\n    );\n\n    expect(options.testRunner).toMatch('jest-jasmine2');\n  });\n\n  it('is overwritten by argv', async () => {\n    const Resolver = (require('jest-resolve') as typeof import('jest-resolve'))\n      .default;\n    Resolver.findNodeModule = jest.fn((name: string) => name);\n    const {options} = await normalize(\n      {\n        rootDir: '/root/path/foo',\n      },\n      {\n        testRunner: 'mocha',\n      } as Config.Argv,\n    );\n\n    expect(options.testRunner).toBe('mocha');\n  });\n});\n\ndescribe('coverageDirectory', () => {\n  it('defaults to <rootDir>/coverage', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root/path/foo',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.coverageDirectory).toBe('/root/path/foo/coverage');\n  });\n});\n\ndescribe('testEnvironment', () => {\n  let Resolver: typeof import('jest-resolve').default;\n  beforeEach(() => {\n    Resolver = (require('jest-resolve') as typeof import('jest-resolve'))\n      .default;\n    Resolver.findNodeModule = jest.fn((name: string) => {\n      if (['jsdom', 'jest-environment-jsdom'].includes(name)) {\n        return `node_modules/${name}`;\n      }\n      if (name.startsWith('/root')) {\n        return name;\n      }\n      return findNodeModule(name);\n    });\n  });\n\n  it('resolves to an environment and prefers jest-environment-`name`', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root',\n        testEnvironment: 'jsdom',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.testEnvironment).toBe('node_modules/jest-environment-jsdom');\n  });\n\n  it('resolves to node environment by default', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.testEnvironment).toEqual(\n      require.resolve('jest-environment-node'),\n    );\n  });\n\n  it('throws on invalid environment names', async () => {\n    await expect(\n      normalize(\n        {\n          rootDir: '/root',\n          testEnvironment: 'phantom',\n        },\n        {} as Config.Argv,\n      ),\n    ).rejects.toThrowErrorMatchingSnapshot();\n  });\n\n  it('works with rootDir', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root',\n        testEnvironment: '<rootDir>/testEnvironment.js',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.testEnvironment).toBe('/root/testEnvironment.js');\n  });\n});\n\ndescribe('babel-jest', () => {\n  let Resolver: typeof import('jest-resolve').default;\n  beforeEach(() => {\n    Resolver = (require('jest-resolve') as typeof import('jest-resolve'))\n      .default;\n    Resolver.findNodeModule = jest.fn((name: string) =>\n      name.includes('babel-jest')\n        ? name\n        : `${path.sep}node_modules${path.sep}${name}`,\n    );\n  });\n\n  it('correctly identifies and uses babel-jest', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.transform[0][0]).toBe(DEFAULT_JS_PATTERN);\n    expect(options.transform[0][1]).toEqual(require.resolve('babel-jest'));\n  });\n\n  it('uses babel-jest if babel-jest is explicitly specified in a custom transform options', async () => {\n    const customJSPattern = '\\\\.js$';\n    const {options} = await normalize(\n      {\n        rootDir: '/root',\n        transform: {\n          [customJSPattern]: 'babel-jest',\n        },\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.transform[0][0]).toBe(customJSPattern);\n    expect(options.transform[0][1]).toEqual(require.resolve('babel-jest'));\n  });\n});\n\ndescribe('testRegex', () => {\n  it('testRegex empty string is mapped to empty array', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root',\n        testRegex: '',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.testRegex).toEqual([]);\n  });\n  it('testRegex string is mapped to an array', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root',\n        testRegex: '.*',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.testRegex).toEqual(['.*']);\n  });\n  it('testRegex array is preserved', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root',\n        testRegex: ['.*', 'foo\\\\.bar'],\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.testRegex).toEqual(['.*', 'foo\\\\.bar']);\n  });\n});\n\ndescribe('testMatch', () => {\n  it('testMatch default not applied if testRegex is set', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root',\n        testRegex: '.*',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.testMatch).toHaveLength(0);\n  });\n\n  it('testRegex default not applied if testMatch is set', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root',\n        testMatch: ['**/*.js'],\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.testRegex).toEqual([]);\n  });\n\n  it('throws if testRegex and testMatch are both specified', async () => {\n    await expect(\n      normalize(\n        {\n          rootDir: '/root',\n          testMatch: ['**/*.js'],\n          testRegex: '.*',\n        },\n        {} as Config.Argv,\n      ),\n    ).rejects.toThrowErrorMatchingSnapshot();\n  });\n\n  it('normalizes testMatch root directory', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root',\n        testMatch: ['<rootDir>/**/*.js'],\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.testMatch).toEqual(['/root/**/*.js']);\n  });\n\n  it('normalizes testMatch to array', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root',\n        testMatch: '**/*.js',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.testMatch).toEqual(['**/*.js']);\n  });\n});\n\ndescribe('moduleDirectories', () => {\n  it('defaults to node_modules', async () => {\n    const {options} = await normalize({rootDir: '/root'}, {} as Config.Argv);\n\n    expect(options.moduleDirectories).toEqual(['node_modules']);\n  });\n\n  it('normalizes moduleDirectories', async () => {\n    const {options} = await normalize(\n      {\n        moduleDirectories: ['<rootDir>/src', '<rootDir>/node_modules'],\n        rootDir: '/root',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.moduleDirectories).toEqual([\n      '/root/src',\n      '/root/node_modules',\n    ]);\n  });\n});\n\ndescribe('preset', () => {\n  beforeEach(() => {\n    const Resolver = (require('jest-resolve') as typeof import('jest-resolve'))\n      .default;\n    Resolver.findNodeModule = jest.fn((name: string) => {\n      if (name === 'react-native/jest-preset') {\n        return '/node_modules/react-native/jest-preset.json';\n      }\n\n      if (name === 'react-native-js-preset/jest-preset') {\n        return '/node_modules/react-native-js-preset/jest-preset.js';\n      }\n\n      if (name === 'cjs-preset/jest-preset') {\n        return '/node_modules/cjs-preset/jest-preset.cjs';\n      }\n\n      if (name === 'mjs-preset/jest-preset') {\n        return '/node_modules/mjs-preset/jest-preset.mjs';\n      }\n\n      if (name.includes('doesnt-exist')) {\n        return null;\n      }\n\n      return `/node_modules/${name}`;\n    });\n    jest.doMock(\n      '/node_modules/react-native/jest-preset.json',\n      () => ({\n        moduleNameMapper: {b: 'b'},\n        modulePathIgnorePatterns: ['b'],\n        setupFiles: ['b'],\n        setupFilesAfterEnv: ['b'],\n        transform: {b: 'b'},\n      }),\n      {virtual: true},\n    );\n    jest.doMock(\n      '/node_modules/react-native-js-preset/jest-preset.js',\n      () => ({\n        moduleNameMapper: {\n          json: true,\n        },\n      }),\n      {virtual: true},\n    );\n    jest.doMock(\n      '/node_modules/cjs-preset/jest-preset.cjs',\n      () => ({\n        moduleNameMapper: {\n          cjs: true,\n        },\n      }),\n      {virtual: true},\n    );\n    jest.doMock(\n      '/node_modules/mjs-preset/jest-preset.mjs',\n      () => ({\n        moduleNameMapper: {\n          mjs: true,\n        },\n      }),\n      {virtual: true},\n    );\n  });\n\n  afterEach(() => {\n    jest.dontMock('/node_modules/react-native/jest-preset.json');\n    jest.dontMock('/node_modules/react-native-js-preset/jest-preset.js');\n    jest.dontMock('/node_modules/cjs-preset/jest-preset.cjs');\n    jest.dontMock('/node_modules/mjs-preset/jest-preset.mjs');\n  });\n\n  test('throws when preset not found', async () => {\n    await expect(\n      normalize(\n        {\n          preset: 'doesnt-exist',\n          rootDir: '/root/path/foo',\n        },\n        {} as Config.Argv,\n      ),\n    ).rejects.toThrowErrorMatchingSnapshot();\n  });\n\n  test('throws when module was found but no \"jest-preset.js\" or \"jest-preset.json\" files', async () => {\n    await expect(\n      normalize(\n        {\n          preset: 'exist-but-no-jest-preset',\n          rootDir: '/root/path/foo',\n        },\n        {} as Config.Argv,\n      ),\n    ).rejects.toThrowErrorMatchingSnapshot();\n  });\n\n  test('throws when a dependency is missing in the preset', async () => {\n    jest.doMock(\n      '/node_modules/react-native-js-preset/jest-preset.js',\n      () => {\n        require('library-that-is-not-installed');\n        return {\n          transform: {} as Config.Argv,\n        };\n      },\n      {virtual: true},\n    );\n\n    await expect(\n      normalize(\n        {\n          preset: 'react-native-js-preset',\n          rootDir: '/root/path/foo',\n        },\n        {} as Config.Argv,\n      ),\n    ).rejects.toThrow(/Cannot find module 'library-that-is-not-installed'/);\n  });\n\n  test('throws when preset is invalid', async () => {\n    jest.doMock('/node_modules/react-native/jest-preset.json', () =>\n      jest.requireActual('./jest-preset.json'),\n    );\n\n    const errorMessage = semver.satisfies(process.versions.node, '<19.0.0')\n      ? /Unexpected token } in JSON at position (104|110)[\\S\\s]* at /\n      : 'SyntaxError: Expected double-quoted property name in JSON at position 104';\n\n    await expect(\n      normalize(\n        {\n          preset: 'react-native',\n          rootDir: '/root/path/foo',\n        },\n        {} as Config.Argv,\n      ),\n    ).rejects.toThrow(errorMessage);\n  });\n\n  test('throws when preset evaluation throws type error', async () => {\n    jest.doMock(\n      '/node_modules/react-native-js-preset/jest-preset.js',\n      () => ({\n        // @ts-expect-error: Testing runtime error\n        // eslint-disable-next-line unicorn/prefer-prototype-methods\n        transform: {}.nonExistingProp.call(),\n      }),\n      {virtual: true},\n    );\n\n    const errorMessage =\n      \"TypeError: Cannot read properties of undefined (reading 'call')\";\n\n    await expect(\n      normalize(\n        {\n          preset: 'react-native-js-preset',\n          rootDir: '/root/path/foo',\n        },\n        {} as Config.Argv,\n      ),\n    ).rejects.toThrow(errorMessage);\n  });\n\n  test('works with \"react-native\"', async () => {\n    await expect(\n      normalize(\n        {\n          preset: 'react-native',\n          rootDir: '/root/path/foo',\n        },\n        {} as Config.Argv,\n      ),\n    ).resolves.not.toThrow();\n  });\n\n  test.each(['react-native-js-preset', 'cjs-preset'])(\n    'works with cjs preset',\n    async preset => {\n      await expect(\n        normalize(\n          {\n            preset,\n            rootDir: '/root/path/foo',\n          },\n          {} as Config.Argv,\n        ),\n      ).resolves.not.toThrow();\n    },\n  );\n\n  test('works with esm preset', async () => {\n    await expect(\n      normalize(\n        {\n          preset: 'mjs-preset',\n          rootDir: '/root/path/foo',\n        },\n        {} as Config.Argv,\n      ),\n    ).resolves.not.toThrow();\n  });\n\n  test('searches for .json, .js, .cjs, .mjs preset files', async () => {\n    const Resolver = (require('jest-resolve') as typeof import('jest-resolve'))\n      .default;\n\n    await normalize(\n      {\n        preset: 'react-native',\n        rootDir: '/root/path/foo',\n      },\n      {} as Config.Argv,\n    );\n\n    const options = jest.mocked(Resolver.findNodeModule).mock.calls[0][1];\n    expect(options.extensions).toEqual(['.json', '.js', '.cjs', '.mjs']);\n  });\n\n  test('merges with options', async () => {\n    const {options} = await normalize(\n      {\n        moduleNameMapper: {a: 'a'},\n        modulePathIgnorePatterns: ['a'],\n        preset: 'react-native',\n        rootDir: '/root/path/foo',\n        setupFiles: ['a'],\n        setupFilesAfterEnv: ['a'],\n        transform: {a: 'a'},\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.moduleNameMapper).toEqual([\n      ['a', 'a'],\n      ['b', 'b'],\n    ]);\n    expect(options.modulePathIgnorePatterns).toEqual(['b', 'a']);\n    expect(options.setupFiles.sort()).toEqual([\n      '/node_modules/a',\n      '/node_modules/b',\n    ]);\n    expect(options.setupFilesAfterEnv.sort()).toEqual([\n      '/node_modules/a',\n      '/node_modules/b',\n    ]);\n    expect(options.transform).toEqual([\n      ['a', '/node_modules/a', {}],\n      ['b', '/node_modules/b', {}],\n    ]);\n  });\n\n  test('merges with options and moduleNameMapper preset is overridden by options', async () => {\n    // Object initializer not used for properties as a workaround for\n    //  sort-keys eslint rule while specifying properties in\n    //  non-alphabetical order for a better test\n    const moduleNameMapper = {} as Record<string, string>;\n    moduleNameMapper.e = 'ee';\n    moduleNameMapper.b = 'bb';\n    moduleNameMapper.c = 'cc';\n    moduleNameMapper.a = 'aa';\n    const {options} = await normalize(\n      {\n        moduleNameMapper,\n        preset: 'react-native',\n        rootDir: '/root/path/foo',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.moduleNameMapper).toEqual([\n      ['e', 'ee'],\n      ['b', 'bb'],\n      ['c', 'cc'],\n      ['a', 'aa'],\n    ]);\n  });\n\n  test('merges with options and transform preset is overridden by options', async () => {\n    /* eslint-disable sort-keys */\n    const transform = {\n      e: 'ee',\n      b: 'bb',\n      c: 'cc',\n      a: 'aa',\n    };\n    /* eslint-enable */\n    const {options} = await normalize(\n      {\n        preset: 'react-native',\n        rootDir: '/root/path/foo',\n        transform,\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.transform).toEqual([\n      ['e', '/node_modules/ee', {}],\n      ['b', '/node_modules/bb', {}],\n      ['c', '/node_modules/cc', {}],\n      ['a', '/node_modules/aa', {}],\n    ]);\n  });\n\n  test('extracts setupFilesAfterEnv from preset', async () => {\n    const {options} = await normalize(\n      {\n        preset: 'react-native',\n        rootDir: '/root/path/foo',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.setupFilesAfterEnv).toEqual(['/node_modules/b']);\n  });\n});\n\ndescribe('preset with globals', () => {\n  beforeEach(() => {\n    const Resolver = (require('jest-resolve') as typeof import('jest-resolve'))\n      .default;\n    Resolver.findNodeModule = jest.fn((name: string) => {\n      if (name === 'global-foo/jest-preset') {\n        return '/node_modules/global-foo/jest-preset.json';\n      }\n\n      return `/node_modules/${name}`;\n    });\n    jest.doMock(\n      '/node_modules/global-foo/jest-preset.json',\n      () => ({\n        globals: {\n          __DEV__: false,\n          config: {\n            hereToStay: 'This should stay here',\n          },\n          myString: 'hello world',\n        },\n      }),\n      {virtual: true},\n    );\n  });\n\n  afterEach(() => {\n    jest.dontMock('/node_modules/global-foo/jest-preset.json');\n  });\n\n  test('should merge the globals preset correctly', async () => {\n    const {options} = await normalize(\n      {\n        globals: {\n          __DEV__: true,\n          config: {\n            sideBySide: 'This should also live another day',\n          },\n          myString: 'hello sunshine',\n          textValue: 'This is just text',\n        },\n        preset: 'global-foo',\n        rootDir: '/root/path/foo',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.globals).toEqual({\n      __DEV__: true,\n      config: {\n        hereToStay: 'This should stay here',\n        sideBySide: 'This should also live another day',\n      },\n      myString: 'hello sunshine',\n      textValue: 'This is just text',\n    });\n  });\n});\n\ndescribe.each(['setupFiles', 'setupFilesAfterEnv'] as const)(\n  'preset without %s',\n  configKey => {\n    let Resolver;\n    beforeEach(() => {\n      Resolver = (require('jest-resolve') as typeof import('jest-resolve'))\n        .default;\n      Resolver.findNodeModule = jest.fn(\n        name => `${path.sep}node_modules${path.sep}${name}`,\n      );\n    });\n\n    beforeAll(() => {\n      jest.doMock(\n        '/node_modules/react-foo/jest-preset',\n        () => ({\n          moduleNameMapper: {b: 'b'},\n          modulePathIgnorePatterns: ['b'],\n        }),\n        {virtual: true},\n      );\n    });\n\n    afterAll(() => {\n      jest.dontMock('/node_modules/react-foo/jest-preset');\n    });\n\n    it(`should normalize ${configKey} correctly`, async () => {\n      const {options} = await normalize(\n        {\n          [configKey]: ['a'],\n          preset: 'react-foo',\n          rootDir: '/root/path/foo',\n        },\n        {} as Config.Argv,\n      );\n\n      expect(options).toEqual(\n        expect.objectContaining({[configKey]: ['/node_modules/a']}),\n      );\n    });\n  },\n);\n\ndescribe(\"preset with 'reporters' option\", () => {\n  beforeEach(() => {\n    const Resolver = (require('jest-resolve') as typeof import('jest-resolve'))\n      .default;\n    Resolver.findNodeModule = jest.fn((name: string) => {\n      if (name === 'with-reporters/jest-preset') {\n        return '/node_modules/with-reporters/jest-preset.json';\n      }\n\n      return `/node_modules/${name}`;\n    });\n    jest.doMock(\n      '/node_modules/with-reporters/jest-preset.json',\n      () => ({\n        reporters: ['default'],\n      }),\n      {virtual: true},\n    );\n  });\n\n  afterEach(() => {\n    jest.dontMock('/node_modules/with-reporters/jest-preset.json');\n  });\n\n  test(\"normalizes 'reporters' option defined in preset\", async () => {\n    const {options} = await normalize(\n      {\n        preset: 'with-reporters',\n        rootDir: '/root/',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.reporters).toEqual([['default', {}]]);\n  });\n\n  test(\"overrides 'reporters' option defined in preset\", async () => {\n    const {options} = await normalize(\n      {\n        preset: 'with-reporters',\n        reporters: ['summary'],\n        rootDir: '/root/',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.reporters).toEqual([['summary', {}]]);\n  });\n});\n\ndescribe('runner', () => {\n  let Resolver: typeof import('jest-resolve').default;\n  beforeEach(() => {\n    Resolver = (require('jest-resolve') as typeof import('jest-resolve'))\n      .default;\n    Resolver.findNodeModule = jest.fn((name: string) => {\n      if (['eslint', 'jest-runner-eslint', 'my-runner-foo'].includes(name)) {\n        return `node_modules/${name}`;\n      }\n      if (name.startsWith('/root')) {\n        return name;\n      }\n      return findNodeModule(name);\n    });\n  });\n\n  it('defaults to `jest-runner`', async () => {\n    const {options} = await normalize({rootDir: '/root'}, {} as Config.Argv);\n\n    expect(options.runner).toBe(require.resolve('jest-runner'));\n  });\n\n  it('resolves to runners that do not have the prefix', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root/',\n        runner: 'my-runner-foo',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.runner).toBe('node_modules/my-runner-foo');\n  });\n\n  it('resolves to runners and prefers jest-runner-`name`', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root/',\n        runner: 'eslint',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.runner).toBe('node_modules/jest-runner-eslint');\n  });\n\n  it('throw error when a runner is not found', async () => {\n    await expect(\n      normalize(\n        {\n          rootDir: '/root/',\n          runner: 'missing-runner',\n        },\n        {} as Config.Argv,\n      ),\n    ).rejects.toThrowErrorMatchingSnapshot();\n  });\n});\n\ndescribe('watchPlugins', () => {\n  let Resolver: typeof import('jest-resolve').default;\n  beforeEach(() => {\n    Resolver = (require('jest-resolve') as typeof import('jest-resolve'))\n      .default;\n    Resolver.findNodeModule = jest.fn((name: string) => {\n      if (\n        ['typeahead', 'jest-watch-typeahead', 'my-watch-plugin'].includes(name)\n      ) {\n        return `node_modules/${name}`;\n      }\n\n      if (name.startsWith('/root')) {\n        return name;\n      }\n      return findNodeModule(name);\n    });\n  });\n\n  it('defaults to undefined', async () => {\n    const {options} = await normalize({rootDir: '/root'}, {} as Config.Argv);\n\n    expect(options.watchPlugins).toBeUndefined();\n  });\n\n  it('resolves to watch plugins and prefers jest-watch-`name`', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root/',\n        watchPlugins: ['typeahead'],\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.watchPlugins).toEqual([\n      {config: {} as Config.Argv, path: 'node_modules/jest-watch-typeahead'},\n    ]);\n  });\n\n  it('resolves watch plugins that do not have the prefix', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root/',\n        watchPlugins: ['my-watch-plugin'],\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.watchPlugins).toEqual([\n      {config: {} as Config.Argv, path: 'node_modules/my-watch-plugin'},\n    ]);\n  });\n\n  it('normalizes multiple watchPlugins', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root/',\n        watchPlugins: ['jest-watch-typeahead', '<rootDir>/path/to/plugin'],\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.watchPlugins).toEqual([\n      {config: {} as Config.Argv, path: 'node_modules/jest-watch-typeahead'},\n      {config: {} as Config.Argv, path: '/root/path/to/plugin'},\n    ]);\n  });\n\n  it('throw error when a watch plugin is not found', async () => {\n    await expect(\n      normalize(\n        {\n          rootDir: '/root/',\n          watchPlugins: ['missing-plugin'],\n        },\n        {} as Config.Argv,\n      ),\n    ).rejects.toThrowErrorMatchingSnapshot();\n  });\n});\n\ndescribe('testPathPatterns', () => {\n  const initialOptions = {rootDir: '/root'};\n  const consoleLog = console.log;\n\n  beforeEach(() => {\n    console.log = jest.fn();\n  });\n\n  afterEach(() => {\n    console.log = consoleLog;\n  });\n\n  it('defaults to empty', async () => {\n    const {options} = await normalize(initialOptions, {} as Config.Argv);\n\n    expect(options.testPathPatterns.patterns).toEqual([]);\n  });\n\n  const cliOptions = [\n    {name: '--testPathPatterns', property: 'testPathPatterns'},\n    {name: '<regexForTestFiles>', property: '_'},\n  ];\n  for (const opt of cliOptions) {\n    describe(opt.name, () => {\n      it(`uses ${opt.name} if set`, async () => {\n        const argv = {[opt.property]: ['a/b']} as Config.Argv;\n        const {options} = await normalize(initialOptions, argv);\n\n        expect(options.testPathPatterns.patterns).toEqual(['a/b']);\n      });\n\n      it('ignores invalid regular expressions and logs a warning', async () => {\n        const argv = {[opt.property]: ['a(']} as Config.Argv;\n        const {options} = await normalize(initialOptions, argv);\n\n        expect(options.testPathPatterns.patterns).toEqual([]);\n        expect(jest.mocked(console.log).mock.calls[0][0]).toMatchSnapshot();\n      });\n\n      it(`joins multiple ${opt.name} if set`, async () => {\n        const argv = {[opt.property]: ['a/b', 'c/d']} as Config.Argv;\n        const {options} = await normalize(initialOptions, argv);\n\n        expect(options.testPathPatterns.patterns).toEqual(['a/b', 'c/d']);\n      });\n    });\n  }\n\n  it('coerces <regexForTestFiles> patterns to strings', async () => {\n    const argv = {_: [1]} as Config.Argv;\n    const {options} = await normalize(initialOptions, argv);\n\n    expect(options.testPathPatterns.patterns).toEqual(['1']);\n  });\n\n  it('joins multiple --testPathPatterns and <regexForTestFiles>', async () => {\n    const {options} = await normalize(initialOptions, {\n      _: ['a', 'b'],\n      testPathPatterns: ['c', 'd'],\n    } as Config.Argv);\n    expect(options.testPathPatterns.patterns).toEqual(['a', 'b', 'c', 'd']);\n  });\n\n  it('gives precedence to --all', async () => {\n    const {options} = await normalize(initialOptions, {\n      all: true,\n      onlyChanged: true,\n    } as Config.Argv);\n\n    expect(options.onlyChanged).toBe(false);\n  });\n});\n\ndescribe('moduleFileExtensions', () => {\n  it('defaults to something useful', async () => {\n    const {options} = await normalize({rootDir: '/root'}, {} as Config.Argv);\n\n    expect(options.moduleFileExtensions).toEqual([\n      'js',\n      'mjs',\n      'cjs',\n      'jsx',\n      'ts',\n      'mts',\n      'cts',\n      'tsx',\n      'json',\n      'node',\n    ]);\n  });\n\n  it.each([undefined, 'jest-runner'] as const)(\n    'throws if missing `js` but using jest-runner',\n    async runner => {\n      await expect(\n        normalize(\n          {\n            moduleFileExtensions: ['json', 'jsx'],\n            rootDir: '/root/',\n            runner,\n          },\n          {} as Config.Argv,\n        ),\n      ).rejects.toThrow(\"moduleFileExtensions must include 'js'\");\n    },\n  );\n\n  it('does not throw if missing `js` with a custom runner', async () => {\n    await expect(\n      normalize(\n        {\n          moduleFileExtensions: ['json', 'jsx'],\n          rootDir: '/root/',\n          runner: './', // does not need to be a valid runner for this validation\n        },\n        {} as Config.Argv,\n      ),\n    ).resolves.not.toThrow();\n  });\n});\n\ndescribe('cwd', () => {\n  it('is set to process.cwd', async () => {\n    const {options} = await normalize({rootDir: '/root/'}, {} as Config.Argv);\n    expect(options.cwd).toBe(process.cwd());\n  });\n\n  it('is not lost if the config has its own cwd property', async () => {\n    jest.mocked(console.warn).mockImplementation(() => {});\n    const {options} = await normalize(\n      {\n        cwd: '/tmp/config-sets-cwd-itself',\n        rootDir: '/root/',\n      } as Config.InitialOptions,\n      {} as Config.Argv,\n    );\n    expect(options.cwd).toBe(process.cwd());\n    expect(console.warn).toHaveBeenCalled();\n  });\n});\n\ndescribe('Defaults', () => {\n  it('should be accepted by normalize', async () => {\n    await normalize({...Defaults, rootDir: '/root'}, {} as Config.Argv);\n\n    expect(console.warn).not.toHaveBeenCalled();\n  });\n});\n\ndescribe('displayName', () => {\n  test.each<{displayName: Config.DisplayName; description: string}>`\n    displayName             | description\n    ${{}}                   | ${'is an empty object'}\n    ${{name: 'hello'}}      | ${'missing color'}\n    ${{color: 'green'}}     | ${'missing name'}\n    ${{color: 2, name: []}} | ${'using invalid values'}\n  `(\n    'should throw an error when displayName is $description',\n    async ({displayName}) => {\n      await expect(\n        normalize(\n          {\n            displayName,\n            rootDir: '/root/',\n          },\n          {} as Config.Argv,\n        ),\n      ).rejects.toThrowErrorMatchingSnapshot();\n    },\n  );\n\n  it.each([\n    undefined,\n    'jest-runner',\n    'jest-runner-eslint',\n    'jest-runner-tslint',\n    'jest-runner-tsc',\n  ])('generates a default color for the runner %s', async runner => {\n    virtualModuleRegexes.push(/jest-runner-.+/);\n    const {\n      options: {displayName},\n    } = await normalize(\n      {\n        displayName: 'project',\n        rootDir: '/root/',\n        runner,\n      },\n      {} as Config.Argv,\n    );\n    expect(displayName!.name).toBe('project');\n    expect(displayName!.color).toMatchSnapshot();\n  });\n});\n\ndescribe('testTimeout', () => {\n  it('should return timeout value if defined', async () => {\n    jest.mocked(console.warn).mockImplementation(() => {});\n    const {options} = await normalize(\n      {rootDir: '/root/', testTimeout: 1000},\n      {} as Config.Argv,\n    );\n\n    expect(options.testTimeout).toBe(1000);\n    expect(console.warn).not.toHaveBeenCalled();\n  });\n\n  it('should throw an error if timeout is a negative number', async () => {\n    await expect(\n      normalize({rootDir: '/root/', testTimeout: -1}, {} as Config.Argv),\n    ).rejects.toThrowErrorMatchingSnapshot();\n  });\n});\n\ndescribe('extensionsToTreatAsEsm', () => {\n  async function matchErrorSnapshot(callback: {\n    (): Promise<{\n      hasDeprecationWarnings: boolean;\n      options: Config.ProjectConfig & Config.GlobalConfig;\n    }>;\n    (): Promise<{\n      hasDeprecationWarnings: boolean;\n      options: Config.ProjectConfig & Config.GlobalConfig;\n    }>;\n    (): any;\n  }) {\n    await expect(callback()).rejects.toThrowErrorMatchingSnapshot();\n  }\n\n  it('should pass valid config through', async () => {\n    const {options} = await normalize(\n      {extensionsToTreatAsEsm: ['.ts'], rootDir: '/root/'},\n      {} as Config.Argv,\n    );\n\n    expect(options.extensionsToTreatAsEsm).toEqual(['.ts']);\n  });\n\n  it('should enforce leading dots', async () => {\n    await matchErrorSnapshot(async () =>\n      normalize(\n        {extensionsToTreatAsEsm: ['ts'], rootDir: '/root/'},\n        {} as Config.Argv,\n      ),\n    );\n  });\n\n  it.each(['.js', '.mjs', '.cjs'])('throws on %s', async ext => {\n    await matchErrorSnapshot(async () =>\n      normalize(\n        {extensionsToTreatAsEsm: [ext], rootDir: '/root/'},\n        {} as Config.Argv,\n      ),\n    );\n  });\n});\n\ndescribe('haste.enableSymlinks', () => {\n  it('should throw if watchman is not disabled', async () => {\n    await expect(\n      normalize(\n        {haste: {enableSymlinks: true}, rootDir: '/root/'},\n        {} as Config.Argv,\n      ),\n    ).rejects.toThrow('haste.enableSymlinks is incompatible with watchman');\n\n    await expect(\n      normalize(\n        {haste: {enableSymlinks: true}, rootDir: '/root/', watchman: true},\n        {} as Config.Argv,\n      ),\n    ).rejects.toThrow('haste.enableSymlinks is incompatible with watchman');\n\n    const {options} = await normalize(\n      {haste: {enableSymlinks: true}, rootDir: '/root/', watchman: false},\n      {} as Config.Argv,\n    );\n\n    expect(options.haste.enableSymlinks).toBe(true);\n    expect(options.watchman).toBe(false);\n  });\n});\n\ndescribe('haste.forceNodeFilesystemAPI', () => {\n  it('should pass option through', async () => {\n    const {options} = await normalize(\n      {haste: {forceNodeFilesystemAPI: true}, rootDir: '/root/'},\n      {} as Config.Argv,\n    );\n\n    expect(options.haste.forceNodeFilesystemAPI).toBe(true);\n    expect(console.warn).not.toHaveBeenCalled();\n  });\n});\n\ndescribe('updateSnapshot', () => {\n  it('should be all if updateSnapshot is true', async () => {\n    const {options} = await normalize({rootDir: '/root/'}, {\n      updateSnapshot: true,\n    } as Config.Argv);\n    expect(options.updateSnapshot).toBe('all');\n  });\n  it('should be new if updateSnapshot is falsy', async () => {\n    {\n      const {options} = await normalize(\n        {ci: false, rootDir: '/root/'},\n        {} as Config.Argv,\n      );\n      expect(options.updateSnapshot).toBe('new');\n    }\n    {\n      const {options} = await normalize({ci: false, rootDir: '/root/'}, {\n        updateSnapshot: false,\n      } as Config.Argv);\n      expect(options.updateSnapshot).toBe('new');\n    }\n  });\n  it('should be none if updateSnapshot is falsy and ci mode is true', async () => {\n    const defaultCiConfig = Defaults.ci;\n    {\n      Defaults.ci = false;\n      const {options} = await normalize({rootDir: '/root/'}, {\n        ci: true,\n      } as Config.Argv);\n      expect(options.updateSnapshot).toBe('none');\n    }\n    {\n      Defaults.ci = true;\n      const {options} = await normalize({rootDir: '/root/'}, {} as Config.Argv);\n      expect(options.updateSnapshot).toBe('none');\n    }\n    Defaults.ci = defaultCiConfig;\n  });\n});\n\ndescribe('shards', () => {\n  it('should be object if defined', async () => {\n    const {options} = await normalize({rootDir: '/root/'}, {\n      shard: '1/2',\n    } as Config.Argv);\n\n    expect(options.shard).toEqual({shardCount: 2, shardIndex: 1});\n  });\n});\n\ndescribe('logs a deprecation warning', () => {\n  beforeEach(() => {\n    jest.mocked(console.warn).mockImplementation(() => {});\n  });\n\n  test(\"when 'browser' option is passed\", async () => {\n    await normalize(\n      {\n        // @ts-expect-error: Testing deprecated option\n        browser: true,\n        rootDir: '/root/',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(console.warn).toMatchSnapshot();\n  });\n\n  test(\"when 'collectCoverageOnlyFrom' option is passed\", async () => {\n    await normalize(\n      {\n        // @ts-expect-error: Testing deprecated option\n        collectCoverageOnlyFrom: {\n          '<rootDir>/this-directory-is-covered/Covered.js': true,\n        },\n        rootDir: '/root/',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(console.warn).toMatchSnapshot();\n  });\n\n  test(\"when 'extraGlobals' option is passed\", async () => {\n    await normalize(\n      {\n        // @ts-expect-error: Testing deprecated option\n        extraGlobals: ['Math'],\n        rootDir: '/root/',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(console.warn).toMatchSnapshot();\n  });\n\n  test(\"when 'moduleLoader' option is passed\", async () => {\n    await normalize(\n      {\n        // @ts-expect-error: Testing deprecated option\n        moduleLoader: '<rootDir>/runtime.js',\n        rootDir: '/root/',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(console.warn).toMatchSnapshot();\n  });\n\n  test(\"when 'preprocessorIgnorePatterns' option is passed\", async () => {\n    await normalize(\n      {\n        // @ts-expect-error: Testing deprecated option\n        preprocessorIgnorePatterns: ['/node_modules/'],\n        rootDir: '/root/',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(console.warn).toMatchSnapshot();\n  });\n\n  test(\"when 'scriptPreprocessor' option is passed\", async () => {\n    await normalize(\n      {\n        rootDir: '/root/',\n        // @ts-expect-error: Testing deprecated option\n        scriptPreprocessor: 'preprocessor.js',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(console.warn).toMatchSnapshot();\n  });\n\n  test(\"when 'setupTestFrameworkScriptFile' option is passed\", async () => {\n    await normalize(\n      {\n        rootDir: '/root/',\n        // @ts-expect-error: Testing deprecated option\n        setupTestFrameworkScriptFile: 'setup.js',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(console.warn).toMatchSnapshot();\n  });\n\n  test(\"when 'testPathDirs' option is passed\", async () => {\n    await normalize(\n      {\n        rootDir: '/root/',\n        // @ts-expect-error: Testing deprecated option\n        testPathDirs: ['<rootDir>'],\n      },\n      {} as Config.Argv,\n    );\n\n    expect(console.warn).toMatchSnapshot();\n  });\n\n  test(\"when 'testURL' option is passed\", async () => {\n    await normalize(\n      {\n        rootDir: '/root/',\n        // @ts-expect-error: Testing deprecated option\n        testURL: 'https://jestjs.io',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(console.warn).toMatchSnapshot();\n  });\n\n  test(\"when 'timers' option is passed\", async () => {\n    await normalize(\n      {\n        rootDir: '/root/',\n        // @ts-expect-error: Testing deprecated option\n        timers: 'real',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(console.warn).toMatchSnapshot();\n  });\n});\n\nit('parses workerIdleMemoryLimit', async () => {\n  const {options} = await normalize(\n    {\n      rootDir: '/root/',\n      workerIdleMemoryLimit: '45MiB',\n    },\n    {} as Config.Argv,\n  );\n\n  expect(options.workerIdleMemoryLimit).toBe(47_185_920);\n});\n\ndescribe('seed', () => {\n  it('generates seed when not specified', async () => {\n    const {options} = await normalize({rootDir: '/root/'}, {} as Config.Argv);\n    expect(options.seed).toEqual(expect.any(Number));\n  });\n\n  it('uses seed specified', async () => {\n    const {options} = await normalize({rootDir: '/root/'}, {\n      seed: 4321,\n    } as Config.Argv);\n    expect(options.seed).toBe(4321);\n  });\n\n  it('throws if seed is too large or too small', async () => {\n    await expect(\n      normalize({rootDir: '/root/'}, {\n        seed: 2 ** 33,\n      } as Config.Argv),\n    ).rejects.toThrow(\n      'seed value must be between `-0x80000000` and `0x7fffffff` inclusive - instead it is 8589934592',\n    );\n    await expect(\n      normalize({rootDir: '/root/'}, {\n        seed: -(2 ** 33),\n      } as Config.Argv),\n    ).rejects.toThrow(\n      'seed value must be between `-0x80000000` and `0x7fffffff` inclusive - instead it is -8589934592',\n    );\n  });\n});\n\ndescribe('showSeed', () => {\n  test('showSeed is set when argv flag is set', async () => {\n    const {options} = await normalize({rootDir: '/root/'}, {\n      showSeed: true,\n    } as Config.Argv);\n    expect(options.showSeed).toBe(true);\n  });\n\n  test('showSeed is set when the config is set', async () => {\n    const {options} = await normalize(\n      {rootDir: '/root/', showSeed: true},\n      {} as Config.Argv,\n    );\n    expect(options.showSeed).toBe(true);\n  });\n\n  test('showSeed is false when neither is set', async () => {\n    const {options} = await normalize({rootDir: '/root/'}, {} as Config.Argv);\n    expect(options.showSeed).toBeFalsy();\n  });\n\n  test('showSeed is true when randomize is set', async () => {\n    const {options} = await normalize(\n      {randomize: true, rootDir: '/root/'},\n      {} as Config.Argv,\n    );\n    expect(options.showSeed).toBe(true);\n  });\n});\n\ndescribe('randomize', () => {\n  test('randomize is set when argv flag is set', async () => {\n    const {options} = await normalize({rootDir: '/root/'}, {\n      randomize: true,\n    } as Config.Argv);\n    expect(options.randomize).toBe(true);\n  });\n\n  test('randomize is set when the config is set', async () => {\n    const {options} = await normalize(\n      {randomize: true, rootDir: '/root/'},\n      {} as Config.Argv,\n    );\n    expect(options.randomize).toBe(true);\n  });\n\n  test('randomize is false when neither is set', async () => {\n    const {options} = await normalize({rootDir: '/root/'}, {} as Config.Argv);\n    expect(options.randomize).toBeFalsy();\n  });\n});\n\ndescribe('runInBand', () => {\n  test('always set it', async () => {\n    const {options} = await normalize({rootDir: '/root/'}, {} as Config.Argv);\n    expect(options.runInBand).toBe(false);\n  });\n\n  test('respect argv', async () => {\n    const {options} = await normalize({rootDir: '/root/'}, {\n      runInBand: true,\n    } as Config.Argv);\n    expect(options.runInBand).toBe(true);\n  });\n});\n",
  "packages/jest-config/src/__tests__/normalize.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport {};\n",
  "packages/jest-config/src/__tests__/getMaxWorkers.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport getMaxWorkers from '../getMaxWorkers';\n\njest.mock('os');\n\ndescribe('getMaxWorkers', () => {\n  beforeEach(() => {\n    require('os').__setCpus({length: 4});\n  });\n\n  it('Returns 1 when runInBand', () => {\n    const argv = {runInBand: true};\n    expect(getMaxWorkers(argv)).toBe(1);\n  });\n\n  it('Returns 1 when the OS CPUs are not available', () => {\n    require('os').__setCpus(undefined);\n    expect(getMaxWorkers({})).toBe(1);\n  });\n\n  it('Returns the `maxWorkers` when specified', () => {\n    const argv = {maxWorkers: 8};\n    expect(getMaxWorkers(argv)).toBe(8);\n  });\n\n  it('Returns based on the number of cpus', () => {\n    expect(getMaxWorkers({})).toBe(3);\n    expect(getMaxWorkers({watch: true})).toBe(2);\n    expect(getMaxWorkers({watchAll: true})).toBe(2);\n  });\n\n  describe('% based', () => {\n    it('50% = 2 workers', () => {\n      const argv = {maxWorkers: '50%'};\n      expect(getMaxWorkers(argv)).toBe(2);\n    });\n\n    it('< 0 workers should become 1', () => {\n      const argv = {maxWorkers: '1%'};\n      expect(getMaxWorkers(argv)).toBe(1);\n    });\n\n    it(\"0% shouldn't break\", () => {\n      const argv = {maxWorkers: '0%'};\n      expect(getMaxWorkers(argv)).toBe(1);\n    });\n  });\n});\n",
  "packages/jest-config/src/__tests__/getMaxWorkers.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport {};\n",
  "packages/jest-config/src/__tests__/Defaults.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {defaults} from '../';\n\ntest('get configuration defaults', () => {\n  expect(defaults).toBeDefined();\n});\n",
  "packages/jest-config/src/__tests__/Defaults.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-cli/src/run.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport chalk from 'chalk';\nimport exit from 'exit-x';\nimport yargs from 'yargs';\nimport {getVersion, runCLI} from '@jest/core';\nimport type {AggregatedResult} from '@jest/test-result';\nimport type {Config} from '@jest/types';\nimport {deprecationEntries} from 'jest-config';\nimport {clearLine, tryRealpath} from 'jest-util';\nimport {validateCLIOptions} from 'jest-validate';\nimport * as args from './args';\n\nexport async function run(\n  maybeArgv?: Array<string>,\n  project?: string,\n): Promise<void> {\n  try {\n    const argv = await buildArgv(maybeArgv);\n    const projects = getProjectListFromCLIArgs(argv, project);\n\n    const {results, globalConfig} = await runCLI(argv, projects);\n    readResultsAndExit(results, globalConfig);\n  } catch (error: any) {\n    clearLine(process.stderr);\n    clearLine(process.stdout);\n    if (error?.stack) {\n      console.error(chalk.red(error.stack));\n    } else {\n      console.error(chalk.red(error));\n    }\n\n    exit(1);\n    throw error;\n  }\n}\n\nexport async function buildArgv(\n  maybeArgv?: Array<string>,\n): Promise<Config.Argv> {\n  const version =\n    getVersion() +\n    (__dirname.includes(`packages${path.sep}jest-cli`) ? '-dev' : '');\n\n  const rawArgv: Array<string> = maybeArgv || process.argv.slice(2);\n  const argv: Config.Argv = await yargs(rawArgv)\n    .usage(args.usage)\n    .version(version)\n    .alias('help', 'h')\n    .options(args.options)\n    .epilogue(args.docs)\n    .check(args.check).argv;\n\n  validateCLIOptions(\n    argv,\n    {...args.options, deprecationEntries},\n    // strip leading dashes\n    Array.isArray(rawArgv)\n      ? rawArgv.map(rawArgv => rawArgv.replace(/^--?/, ''))\n      : Object.keys(rawArgv),\n  );\n\n  // strip dashed args\n  return Object.keys(argv).reduce<Config.Argv>(\n    (result, key) => {\n      if (!key.includes('-')) {\n        result[key] = argv[key];\n      }\n      return result;\n    },\n    {$0: argv.$0, _: argv._},\n  );\n}\n\nconst getProjectListFromCLIArgs = (argv: Config.Argv, project?: string) => {\n  const projects = argv.projects ?? [];\n\n  if (project) {\n    projects.push(project);\n  }\n\n  if (projects.length === 0 && process.platform === 'win32') {\n    try {\n      projects.push(tryRealpath(process.cwd()));\n    } catch {\n      // do nothing, just catch error\n      // process.binding('fs').realpath can throw, e.g. on mapped drives\n    }\n  }\n\n  if (projects.length === 0) {\n    projects.push(process.cwd());\n  }\n\n  return projects;\n};\n\nconst readResultsAndExit = (\n  result: AggregatedResult | null,\n  globalConfig: Config.GlobalConfig,\n) => {\n  const code = !result || result.success ? 0 : globalConfig.testFailureExitCode;\n\n  // Only exit if needed\n  process.on('exit', () => {\n    if (typeof code === 'number' && code !== 0) {\n      process.exitCode = code;\n    }\n  });\n\n  if (globalConfig.forceExit) {\n    if (!globalConfig.detectOpenHandles) {\n      console.warn(\n        `${chalk.bold(\n          'Force exiting Jest: ',\n        )}Have you considered using \\`--detectOpenHandles\\` to detect ` +\n          'async operations that kept running after all tests finished?',\n      );\n    }\n\n    exit(code);\n  } else if (\n    !globalConfig.detectOpenHandles &&\n    globalConfig.openHandlesTimeout !== 0\n  ) {\n    const timeout = globalConfig.openHandlesTimeout;\n    setTimeout(() => {\n      console.warn(\n        chalk.yellow.bold(\n          `Jest did not exit ${\n            timeout === 1000 ? 'one second' : `${timeout / 1000} seconds`\n          } after the test run has completed.\\n\\n'`,\n        ) +\n          chalk.yellow(\n            'This usually means that there are asynchronous operations that ' +\n              \"weren't stopped in your tests. Consider running Jest with \" +\n              '`--detectOpenHandles` to troubleshoot this issue.',\n          ),\n      );\n    }, timeout).unref();\n  }\n};\n",
  "packages/jest-cli/src/run.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config } from '@jest/types';\nexport declare function run(maybeArgv?: Array<string>, project?: string): Promise<void>;\nexport declare function buildArgv(maybeArgv?: Array<string>): Promise<Config.Argv>;\n",
  "packages/jest-cli/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nexport {run, buildArgv} from './run';\nexport {options as yargsOptions} from './args';\n",
  "packages/jest-cli/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport { run, buildArgv } from './run';\nexport { options as yargsOptions } from './args';\n",
  "packages/jest-cli/src/args.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {Options} from 'yargs';\nimport type {Config} from '@jest/types';\nimport {constants, isJSONString} from 'jest-config';\n\nexport function check(argv: Config.Argv): true {\n  if (\n    argv.runInBand &&\n    Object.prototype.hasOwnProperty.call(argv, 'maxWorkers')\n  ) {\n    throw new Error(\n      'Both --runInBand and --maxWorkers were specified, only one is allowed.',\n    );\n  }\n\n  for (const key of [\n    'onlyChanged',\n    'lastCommit',\n    'changedFilesWithAncestor',\n    'changedSince',\n  ]) {\n    if (argv[key] && argv.watchAll) {\n      throw new Error(\n        `Both --${key} and --watchAll were specified, but cannot be used ` +\n          'together. Try the --watch option which reruns only tests ' +\n          'related to changed files.',\n      );\n    }\n  }\n\n  if (argv.onlyFailures && argv.watchAll) {\n    throw new Error(\n      'Both --onlyFailures and --watchAll were specified, only one is allowed.',\n    );\n  }\n\n  if (argv.findRelatedTests && argv._.length === 0) {\n    throw new Error(\n      'The --findRelatedTests option requires file paths to be specified.\\n' +\n        'Example usage: jest --findRelatedTests ./src/source.js ' +\n        './src/index.js.',\n    );\n  }\n\n  if (\n    Object.prototype.hasOwnProperty.call(argv, 'maxWorkers') &&\n    argv.maxWorkers === undefined\n  ) {\n    throw new Error(\n      'The --maxWorkers (-w) option requires a number or string to be specified.\\n' +\n        'Example usage: jest --maxWorkers 2\\n' +\n        'Example usage: jest --maxWorkers 50%\\n' +\n        'Or did you mean --watch?',\n    );\n  }\n\n  if (argv.selectProjects && argv.selectProjects.length === 0) {\n    throw new Error(\n      'The --selectProjects option requires the name of at least one project to be specified.\\n' +\n        'Example usage: jest --selectProjects my-first-project my-second-project',\n    );\n  }\n\n  if (argv.ignoreProjects && argv.ignoreProjects.length === 0) {\n    throw new Error(\n      'The --ignoreProjects option requires the name of at least one project to be specified.\\n' +\n        'Example usage: jest --ignoreProjects my-first-project my-second-project',\n    );\n  }\n\n  if (\n    argv.config &&\n    !isJSONString(argv.config) &&\n    !new RegExp(\n      `\\\\.(${constants.JEST_CONFIG_EXT_ORDER.map(e => e.slice(1)).join('|')})$`,\n      'i',\n    ).test(argv.config)\n  ) {\n    throw new Error(\n      `The --config option requires a JSON string literal, or a file path with one of these extensions: ${constants.JEST_CONFIG_EXT_ORDER.join(\n        ', ',\n      )}.\\nExample usage: jest --config ./jest.config.js`,\n    );\n  }\n\n  return true;\n}\n\nexport const usage =\n  'Usage: $0 [--config=<pathToConfigFile>] [TestPathPatterns]';\nexport const docs = 'Documentation: https://jestjs.io/docs/cli';\n\n// The default values are all set in jest-config\nexport const options: {[key: string]: Options} = {\n  all: {\n    description:\n      'The opposite of `onlyChanged`. If `onlyChanged` is set by ' +\n      'default, running jest with `--all` will force Jest to run all tests ' +\n      'instead of running only tests related to changed files.',\n    type: 'boolean',\n  },\n  automock: {\n    description: 'Automock all files by default.',\n    type: 'boolean',\n  },\n  bail: {\n    alias: 'b',\n    description:\n      'Exit the test suite immediately after `n` number of failing tests.',\n    type: 'boolean',\n  },\n  cache: {\n    description:\n      'Whether to use the transform cache. Disable the cache ' +\n      'using --no-cache.',\n    type: 'boolean',\n  },\n  cacheDirectory: {\n    description:\n      'The directory where Jest should store its cached ' +\n      ' dependency information.',\n    requiresArg: true,\n    type: 'string',\n  },\n  changedFilesWithAncestor: {\n    description:\n      'Runs tests related to the current changes and the changes made in the ' +\n      'last commit. Behaves similarly to `--onlyChanged`.',\n    type: 'boolean',\n  },\n  changedSince: {\n    description:\n      'Runs tests related to the changes since the provided branch. If the ' +\n      'current branch has diverged from the given branch, then only changes ' +\n      'made locally will be tested. Behaves similarly to `--onlyChanged`.',\n    requiresArg: true,\n    type: 'string',\n  },\n  ci: {\n    description:\n      'Whether to run Jest in continuous integration (CI) mode. ' +\n      'This option is on by default in most popular CI environments. It will ' +\n      'prevent snapshots from being written unless explicitly requested.',\n    type: 'boolean',\n  },\n  clearCache: {\n    description:\n      'Clears the configured Jest cache directory and then exits. ' +\n      'Default directory can be found by calling jest --showConfig',\n    type: 'boolean',\n  },\n  clearMocks: {\n    description:\n      'Automatically clear mock calls, instances, contexts and results before every test. ' +\n      'Equivalent to calling jest.clearAllMocks() before each test.',\n    type: 'boolean',\n  },\n  collectCoverage: {\n    description: 'Alias for --coverage.',\n    type: 'boolean',\n  },\n  collectCoverageFrom: {\n    description:\n      'A glob pattern relative to <rootDir> matching the files that coverage ' +\n      'info needs to be collected from.',\n    requiresArg: true,\n    type: 'string',\n  },\n  color: {\n    description:\n      'Forces test results output color highlighting (even if ' +\n      'stdout is not a TTY). Set to false if you would like to have no colors.',\n    type: 'boolean',\n  },\n  colors: {\n    description: 'Alias for `--color`.',\n    type: 'boolean',\n  },\n  config: {\n    alias: 'c',\n    description:\n      'The path to a jest config file specifying how to find ' +\n      'and execute tests. If no rootDir is set in the config, the directory ' +\n      'containing the config file is assumed to be the rootDir for the project. ' +\n      'This can also be a JSON encoded value which Jest will use as configuration.',\n    requiresArg: true,\n    type: 'string',\n  },\n  coverage: {\n    description:\n      'Indicates that test coverage information should be ' +\n      'collected and reported in the output.',\n    type: 'boolean',\n  },\n  coverageDirectory: {\n    description: 'The directory where Jest should output its coverage files.',\n    requiresArg: true,\n    type: 'string',\n  },\n  coveragePathIgnorePatterns: {\n    description:\n      'An array of regexp pattern strings that are matched ' +\n      'against all file paths before executing the test. If the file path ' +\n      'matches any of the patterns, coverage information will be skipped.',\n    requiresArg: true,\n    string: true,\n    type: 'array',\n  },\n  coverageProvider: {\n    choices: ['babel', 'v8'],\n    description: 'Select between Babel and V8 to collect coverage',\n    requiresArg: true,\n  },\n  coverageReporters: {\n    description:\n      'A list of reporter names that Jest uses when writing ' +\n      'coverage reports. Any istanbul reporter can be used.',\n    requiresArg: true,\n    string: true,\n    type: 'array',\n  },\n  coverageThreshold: {\n    description:\n      'A JSON string with which will be used to configure ' +\n      'minimum threshold enforcement for coverage results',\n    requiresArg: true,\n    type: 'string',\n  },\n  debug: {\n    description: 'Print debugging info about your jest config.',\n    type: 'boolean',\n  },\n  detectLeaks: {\n    description:\n      '**EXPERIMENTAL**: Detect memory leaks in tests. After executing a ' +\n      'test, it will try to garbage collect the global object used, and fail ' +\n      'if it was leaked',\n    type: 'boolean',\n  },\n  detectOpenHandles: {\n    description:\n      'Print out remaining open handles preventing Jest from exiting at the ' +\n      'end of a test run. Implies `runInBand`.',\n    type: 'boolean',\n  },\n  errorOnDeprecated: {\n    description: 'Make calling deprecated APIs throw helpful error messages.',\n    type: 'boolean',\n  },\n  expand: {\n    alias: 'e',\n    description: 'Use this flag to show full diffs instead of a patch.',\n    type: 'boolean',\n  },\n  filter: {\n    description:\n      'Path to a module exporting a filtering function. This method receives ' +\n      'a list of tests which can be manipulated to exclude tests from ' +\n      'running. Especially useful when used in conjunction with a testing ' +\n      'infrastructure to filter known broken tests.',\n    requiresArg: true,\n    type: 'string',\n  },\n  findRelatedTests: {\n    description:\n      'Find related tests for a list of source files that were ' +\n      'passed in as arguments. Useful for pre-commit hook integration to run ' +\n      'the minimal amount of tests necessary.',\n    type: 'boolean',\n  },\n  forceExit: {\n    description:\n      'Force Jest to exit after all tests have completed running. ' +\n      'This is useful when resources set up by test code cannot be ' +\n      'adequately cleaned up.',\n    type: 'boolean',\n  },\n  globalSetup: {\n    description: 'The path to a module that runs before All Tests.',\n    requiresArg: true,\n    type: 'string',\n  },\n  globalTeardown: {\n    description: 'The path to a module that runs after All Tests.',\n    requiresArg: true,\n    type: 'string',\n  },\n  globals: {\n    description:\n      'A JSON string with map of global variables that need ' +\n      'to be available in all test environments.',\n    requiresArg: true,\n    type: 'string',\n  },\n  haste: {\n    description:\n      'A JSON string with map of variables for the haste module system',\n    requiresArg: true,\n    type: 'string',\n  },\n  ignoreProjects: {\n    description:\n      'Ignore the tests of the specified projects. ' +\n      'Jest uses the attribute `displayName` in the configuration to identify each project.',\n    requiresArg: true,\n    string: true,\n    type: 'array',\n  },\n  injectGlobals: {\n    description: 'Should Jest inject global variables or not',\n    type: 'boolean',\n  },\n  json: {\n    description:\n      'Prints the test results in JSON. This mode will send all ' +\n      'other test output and user messages to stderr.',\n    type: 'boolean',\n  },\n  lastCommit: {\n    description:\n      'Run all tests affected by file changes in the last commit made. ' +\n      'Behaves similarly to `--onlyChanged`.',\n    type: 'boolean',\n  },\n  listTests: {\n    description:\n      'Lists all tests Jest will run given the arguments and ' +\n      'exits. Most useful in a CI system together with `--findRelatedTests` ' +\n      'to determine the tests Jest will run based on specific files',\n    type: 'boolean',\n  },\n  logHeapUsage: {\n    description:\n      'Logs the heap usage after every test. Useful to debug ' +\n      'memory leaks. Use together with `--runInBand` and `--expose-gc` in ' +\n      'node.',\n    type: 'boolean',\n  },\n  maxConcurrency: {\n    description:\n      'Specifies the maximum number of tests that are allowed to run ' +\n      'concurrently. This only affects tests using `test.concurrent`.',\n    requiresArg: true,\n    type: 'number',\n  },\n  maxWorkers: {\n    alias: 'w',\n    description:\n      'Specifies the maximum number of workers the worker-pool ' +\n      'will spawn for running tests. This defaults to the number of the ' +\n      'cores available on your machine. (its usually best not to override ' +\n      'this default)',\n    requiresArg: true,\n    type: 'string',\n  },\n  moduleDirectories: {\n    description:\n      'An array of directory names to be searched recursively ' +\n      \"up from the requiring module's location.\",\n    requiresArg: true,\n    string: true,\n    type: 'array',\n  },\n  moduleFileExtensions: {\n    description:\n      'An array of file extensions your modules use. If you ' +\n      'require modules without specifying a file extension, these are the ' +\n      'extensions Jest will look for.',\n    requiresArg: true,\n    string: true,\n    type: 'array',\n  },\n  moduleNameMapper: {\n    description:\n      'A JSON string with a map from regular expressions to ' +\n      'module names or to arrays of module names that allow to stub ' +\n      'out resources, like images or styles with a single module',\n    requiresArg: true,\n    type: 'string',\n  },\n  modulePathIgnorePatterns: {\n    description:\n      'An array of regexp pattern strings that are matched ' +\n      'against all module paths before those paths are to be considered ' +\n      '\"visible\" to the module loader.',\n    requiresArg: true,\n    string: true,\n    type: 'array',\n  },\n  modulePaths: {\n    description:\n      'An alternative API to setting the NODE_PATH env variable, ' +\n      'modulePaths is an array of absolute paths to additional locations to ' +\n      'search when resolving modules.',\n    requiresArg: true,\n    string: true,\n    type: 'array',\n  },\n  noStackTrace: {\n    description: 'Disables stack trace in test results output',\n    type: 'boolean',\n  },\n  notify: {\n    description: 'Activates notifications for test results.',\n    type: 'boolean',\n  },\n  notifyMode: {\n    choices: [\n      'always',\n      'failure',\n      'success',\n      'change',\n      'success-change',\n      'failure-change',\n    ],\n    description: 'Specifies when notifications will appear for test results.',\n    requiresArg: true,\n  },\n  onlyChanged: {\n    alias: 'o',\n    description:\n      'Attempts to identify which tests to run based on which ' +\n      \"files have changed in the current repository. Only works if you're \" +\n      'running tests in a git or hg repository at the moment.',\n    type: 'boolean',\n  },\n  onlyFailures: {\n    alias: 'f',\n    description: 'Run tests that failed in the previous execution.',\n    type: 'boolean',\n  },\n  openHandlesTimeout: {\n    description:\n      'Print a warning about probable open handles if Jest does not exit ' +\n      'cleanly after this number of milliseconds. `0` to disable.',\n    requiresArg: true,\n    type: 'number',\n  },\n  outputFile: {\n    description:\n      'Write test results to a file when the --json option is ' +\n      'also specified.',\n    requiresArg: true,\n    type: 'string',\n  },\n  passWithNoTests: {\n    description:\n      'Will not fail if no tests are found (for example while using `--testPathPatterns`.)',\n    type: 'boolean',\n  },\n  preset: {\n    description: \"A preset that is used as a base for Jest's configuration.\",\n    requiresArg: true,\n    type: 'string',\n  },\n  prettierPath: {\n    description: 'The path to the \"prettier\" module used for inline snapshots.',\n    requiresArg: true,\n    type: 'string',\n  },\n  projects: {\n    description:\n      'A list of projects that use Jest to run all tests of all ' +\n      'projects in a single instance of Jest.',\n    requiresArg: true,\n    string: true,\n    type: 'array',\n  },\n  randomize: {\n    description:\n      'Shuffle the order of the tests within a file. In order to choose the seed refer to the `--seed` CLI option.',\n    type: 'boolean',\n  },\n  reporters: {\n    description: 'A list of custom reporters for the test suite.',\n    requiresArg: true,\n    string: true,\n    type: 'array',\n  },\n  resetMocks: {\n    description:\n      'Automatically reset mock state before every test. ' +\n      'Equivalent to calling jest.resetAllMocks() before each test.',\n    type: 'boolean',\n  },\n  resetModules: {\n    description:\n      'If enabled, the module registry for every test file will ' +\n      'be reset before running each individual test.',\n    type: 'boolean',\n  },\n  resolver: {\n    description: 'A JSON string which allows the use of a custom resolver.',\n    requiresArg: true,\n    type: 'string',\n  },\n  restoreMocks: {\n    description:\n      'Automatically restore mock state and implementation before every test. ' +\n      'Equivalent to calling jest.restoreAllMocks() before each test.',\n    type: 'boolean',\n  },\n  rootDir: {\n    description:\n      'The root directory that Jest should scan for tests and ' +\n      'modules within.',\n    requiresArg: true,\n    type: 'string',\n  },\n  roots: {\n    description:\n      'A list of paths to directories that Jest should use to ' +\n      'search for files in.',\n    requiresArg: true,\n    string: true,\n    type: 'array',\n  },\n  runInBand: {\n    alias: 'i',\n    description:\n      'Run all tests serially in the current process (rather than ' +\n      'creating a worker pool of child processes that run tests). This ' +\n      'is sometimes useful for debugging, but such use cases are pretty ' +\n      'rare.',\n    type: 'boolean',\n  },\n  runTestsByPath: {\n    description:\n      'Used when provided patterns are exact file paths. This avoids ' +\n      'converting them into a regular expression and matching it against ' +\n      'every single file.',\n    type: 'boolean',\n  },\n  runner: {\n    description:\n      \"Allows to use a custom runner instead of Jest's default test runner.\",\n    requiresArg: true,\n    type: 'string',\n  },\n  seed: {\n    description:\n      'Sets a seed value that can be retrieved in a tests file via `jest.getSeed()`. If this option is not specified Jest will randomly generate the value. The seed value must be between `-0x80000000` and `0x7fffffff` inclusive.',\n    requiresArg: true,\n    type: 'number',\n  },\n  selectProjects: {\n    description:\n      'Run the tests of the specified projects. ' +\n      'Jest uses the attribute `displayName` in the configuration to identify each project.',\n    requiresArg: true,\n    string: true,\n    type: 'array',\n  },\n  setupFiles: {\n    description:\n      'A list of paths to modules that run some code to configure or ' +\n      'set up the testing environment before each test.',\n    requiresArg: true,\n    string: true,\n    type: 'array',\n  },\n  setupFilesAfterEnv: {\n    description:\n      'A list of paths to modules that run some code to configure or ' +\n      'set up the testing framework before each test',\n    requiresArg: true,\n    string: true,\n    type: 'array',\n  },\n  shard: {\n    description:\n      'Shard tests and execute only the selected shard, specify in ' +\n      'the form \"current/all\". 1-based, for example \"3/5\".',\n    requiresArg: true,\n    type: 'string',\n  },\n  showConfig: {\n    description: 'Print your jest config and then exits.',\n    type: 'boolean',\n  },\n  showSeed: {\n    description:\n      'Prints the seed value in the test report summary. See `--seed` for how to set this value',\n    type: 'boolean',\n  },\n  silent: {\n    description: 'Prevent tests from printing messages through the console.',\n    type: 'boolean',\n  },\n  skipFilter: {\n    description:\n      'Disables the filter provided by --filter. Useful for CI jobs, or ' +\n      'local enforcement when fixing tests.',\n    type: 'boolean',\n  },\n  snapshotSerializers: {\n    description:\n      'A list of paths to snapshot serializer modules Jest should ' +\n      'use for snapshot testing.',\n    requiresArg: true,\n    string: true,\n    type: 'array',\n  },\n  testEnvironment: {\n    alias: 'env',\n    description:\n      'The test environment used for all tests. This can point to ' +\n      'any file or node module. Examples: `jsdom`, `node` or ' +\n      '`path/to/my-environment.js`',\n    requiresArg: true,\n    type: 'string',\n  },\n  testEnvironmentOptions: {\n    description:\n      'A JSON string with options that will be passed to the `testEnvironment`. ' +\n      'The relevant options depend on the environment.',\n    requiresArg: true,\n    type: 'string',\n  },\n  testFailureExitCode: {\n    description: 'Exit code of `jest` command if the test run failed',\n    requiresArg: true,\n    type: 'string', // number\n  },\n  testLocationInResults: {\n    description: 'Add `location` information to the test results',\n    type: 'boolean',\n  },\n  testMatch: {\n    description: 'The glob patterns Jest uses to detect test files.',\n    requiresArg: true,\n    string: true,\n    type: 'array',\n  },\n  testNamePattern: {\n    alias: 't',\n    description: 'Run only tests with a name that matches the regex pattern.',\n    requiresArg: true,\n    type: 'string',\n  },\n  testPathIgnorePatterns: {\n    description:\n      'An array of regexp pattern strings that are matched ' +\n      'against all test paths before executing the test. If the test path ' +\n      'matches any of the patterns, it will be skipped.',\n    requiresArg: true,\n    string: true,\n    type: 'array',\n  },\n  testPathPatterns: {\n    description:\n      'An array of regexp pattern strings that are matched against all tests ' +\n      'paths before executing the test.',\n    requiresArg: true,\n    string: true,\n    type: 'array',\n  },\n  testRegex: {\n    description:\n      'A string or array of string regexp patterns that Jest uses to detect test files.',\n    requiresArg: true,\n    string: true,\n    type: 'array',\n  },\n  testResultsProcessor: {\n    description:\n      'Allows the use of a custom results processor. ' +\n      'This processor must be a node module that exports ' +\n      'a function expecting as the first argument the result object.',\n    requiresArg: true,\n    type: 'string',\n  },\n  testRunner: {\n    description:\n      'Allows to specify a custom test runner. The default is' +\n      ' `jest-circus/runner`. A path to a custom test runner can be provided:' +\n      ' `<rootDir>/path/to/testRunner.js`.',\n    requiresArg: true,\n    type: 'string',\n  },\n  testSequencer: {\n    description:\n      'Allows to specify a custom test sequencer. The default is ' +\n      '`@jest/test-sequencer`. A path to a custom test sequencer can be ' +\n      'provided: `<rootDir>/path/to/testSequencer.js`',\n    requiresArg: true,\n    type: 'string',\n  },\n  testTimeout: {\n    description: 'This option sets the default timeouts of test cases.',\n    requiresArg: true,\n    type: 'number',\n  },\n  transform: {\n    description:\n      'A JSON string which maps from regular expressions to paths ' +\n      'to transformers.',\n    requiresArg: true,\n    type: 'string',\n  },\n  transformIgnorePatterns: {\n    description:\n      'An array of regexp pattern strings that are matched ' +\n      'against all source file paths before transformation.',\n    requiresArg: true,\n    string: true,\n    type: 'array',\n  },\n  unmockedModulePathPatterns: {\n    description:\n      'An array of regexp pattern strings that are matched ' +\n      'against all modules before the module loader will automatically ' +\n      'return a mock for them.',\n    requiresArg: true,\n    string: true,\n    type: 'array',\n  },\n  updateSnapshot: {\n    alias: 'u',\n    description:\n      'Use this flag to re-record snapshots. ' +\n      'Can be used together with a test suite pattern or with ' +\n      '`--testNamePattern` to re-record snapshot for test matching ' +\n      'the pattern',\n    type: 'boolean',\n  },\n  useStderr: {\n    description: 'Divert all output to stderr.',\n    type: 'boolean',\n  },\n  verbose: {\n    description:\n      'Display individual test results with the test suite hierarchy.',\n    type: 'boolean',\n  },\n  waitForUnhandledRejections: {\n    description:\n      'Gives one event loop turn to handle `rejectionHandled`, ' +\n      '`uncaughtException` or `unhandledRejection`.',\n    type: 'boolean',\n  },\n  watch: {\n    description:\n      'Watch files for changes and rerun tests related to ' +\n      'changed files. If you want to re-run all tests when a file has ' +\n      'changed, use the `--watchAll` option.',\n    type: 'boolean',\n  },\n  watchAll: {\n    description:\n      'Watch files for changes and rerun all tests. If you want ' +\n      'to re-run only the tests related to the changed files, use the ' +\n      '`--watch` option.',\n    type: 'boolean',\n  },\n  watchPathIgnorePatterns: {\n    description:\n      'An array of regexp pattern strings that are matched ' +\n      'against all paths before trigger test re-run in watch mode. ' +\n      'If the test path matches any of the patterns, it will be skipped.',\n    requiresArg: true,\n    string: true,\n    type: 'array',\n  },\n  watchman: {\n    description:\n      'Whether to use watchman for file crawling. Disable using ' +\n      '--no-watchman.',\n    type: 'boolean',\n  },\n  workerThreads: {\n    description:\n      'Whether to use worker threads for parallelization. Child processes ' +\n      'are used by default.',\n    type: 'boolean',\n  },\n};\n",
  "packages/jest-cli/src/args.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Options } from 'yargs';\nimport type { Config } from '@jest/types';\nexport declare function check(argv: Config.Argv): true;\nexport declare const usage = \"Usage: $0 [--config=<pathToConfigFile>] [TestPathPatterns]\";\nexport declare const docs = \"Documentation: https://jestjs.io/docs/cli\";\nexport declare const options: {\n    [key: string]: Options;\n};\n",
  "packages/jest-cli/src/__tests__/args.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {Config} from '@jest/types';\nimport {constants} from 'jest-config';\nimport {check} from '../args';\nimport {buildArgv} from '../run';\n\nconst argv = (input: Partial<Config.Argv>): Config.Argv => input as Config.Argv;\n\ndescribe('check', () => {\n  it('returns true if the arguments are valid', () => {\n    expect(check(argv({}))).toBe(true);\n  });\n\n  it('raises an exception if runInBand and maxWorkers are both specified', () => {\n    expect(() => check(argv({maxWorkers: 2, runInBand: true}))).toThrow(\n      'Both --runInBand and --maxWorkers were specified',\n    );\n  });\n\n  it('raises an exception if onlyChanged and watchAll are both specified', () => {\n    expect(() => check(argv({onlyChanged: true, watchAll: true}))).toThrow(\n      'Both --onlyChanged and --watchAll were specified',\n    );\n  });\n\n  it('raises an exception if onlyFailures and watchAll are both specified', () => {\n    expect(() => check(argv({onlyFailures: true, watchAll: true}))).toThrow(\n      'Both --onlyFailures and --watchAll were specified',\n    );\n  });\n\n  it('raises an exception when lastCommit and watchAll are both specified', () => {\n    expect(() => check(argv({lastCommit: true, watchAll: true}))).toThrow(\n      'Both --lastCommit and --watchAll were specified',\n    );\n  });\n\n  it('raises an exception if findRelatedTests is specified with no file paths', () => {\n    expect(() =>\n      check(\n        argv({\n          _: [],\n          findRelatedTests: true,\n        }),\n      ),\n    ).toThrow(\n      'The --findRelatedTests option requires file paths to be specified',\n    );\n  });\n\n  it('raises an exception if maxWorkers is specified with no number', () => {\n    expect(() => check(argv({maxWorkers: undefined}))).toThrow(\n      'The --maxWorkers (-w) option requires a number or string to be specified',\n    );\n  });\n\n  it('allows maxWorkers to be a %', () => {\n    expect(() => check(argv({maxWorkers: '50%'}))).not.toThrow();\n  });\n\n  test.each(constants.JEST_CONFIG_EXT_ORDER.map(e => e.slice(1)))(\n    'allows using \"%s\" file for --config option',\n    ext => {\n      expect(() => check(argv({config: `jest.config.${ext}`}))).not.toThrow();\n      expect(() =>\n        check(argv({config: `../test/test/my_conf.${ext}`})),\n      ).not.toThrow();\n    },\n  );\n\n  it('raises an exception if selectProjects is not provided any project names', () => {\n    expect(() => check(argv({selectProjects: []}))).toThrow(\n      'The --selectProjects option requires the name of at least one project to be specified.\\n',\n    );\n  });\n\n  it('raises an exception if ignoreProjects is not provided any project names', () => {\n    expect(() => check(argv({ignoreProjects: []}))).toThrow(\n      'The --ignoreProjects option requires the name of at least one project to be specified.\\n',\n    );\n  });\n\n  it('raises an exception if config is not a valid JSON string', () => {\n    expect(() => check(argv({config: 'x:1'}))).toThrow(\n      'The --config option requires a JSON string literal, or a file path with one of these extensions: .js, .ts, .mjs, .cjs, .cts, .json',\n    );\n  });\n\n  it('raises an exception if config is not a supported file type', () => {\n    const message =\n      'The --config option requires a JSON string literal, or a file path with one of these extensions: .js, .ts, .mjs, .cjs, .cts, .json';\n\n    expect(() => check(argv({config: 'jest.configjs'}))).toThrow(message);\n    expect(() => check(argv({config: 'jest.config.exe'}))).toThrow(message);\n  });\n});\n\ndescribe('buildArgv', () => {\n  it('should return only camelcased args ', async () => {\n    const mockProcessArgv = jest\n      .spyOn(process.argv, 'slice')\n      .mockImplementation(() => ['--clear-mocks']);\n\n    const actual = await buildArgv();\n    expect(actual).not.toHaveProperty('clear-mocks');\n    expect(actual).toHaveProperty('clearMocks', true);\n    mockProcessArgv.mockRestore();\n  });\n});\n",
  "packages/jest-cli/src/__tests__/args.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport {};\n",
  "packages/jest-cli/__typetests__/jest-cli.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {expect, test} from 'tstyche';\nimport type {Options} from 'yargs';\nimport {yargsOptions} from 'jest-cli';\n\ntest('yargsOptions', () => {\n  expect(yargsOptions).type.toBe<{[key: string]: Options}>();\n});\n",
  "packages/jest-cli/__typetests__/jest-cli.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-circus/src/utils.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport co from 'co';\nimport dedent from 'dedent';\nimport isGeneratorFn from 'is-generator-fn';\nimport slash from 'slash';\nimport StackUtils from 'stack-utils';\nimport type {Status, TestCaseResult} from '@jest/test-result';\nimport type {Circus, Global} from '@jest/types';\nimport {\n  ErrorWithStack,\n  convertDescriptorToString,\n  formatTime,\n  invariant,\n  isPromise,\n} from 'jest-util';\nimport {format as prettyFormat} from 'pretty-format';\nimport {ROOT_DESCRIBE_BLOCK_NAME, getState} from './state';\n\nconst stackUtils = new StackUtils({cwd: 'A path that does not exist'});\n\nconst jestEachBuildDir = slash(path.dirname(require.resolve('jest-each')));\n\nfunction takesDoneCallback(fn: Circus.AsyncFn): fn is Global.DoneTakingTestFn {\n  return fn.length > 0;\n}\n\nfunction isGeneratorFunction(\n  fn: Global.PromiseReturningTestFn | Global.GeneratorReturningTestFn,\n): fn is Global.GeneratorReturningTestFn {\n  return isGeneratorFn(fn);\n}\n\nexport const makeDescribe = (\n  name: Circus.BlockName,\n  parent?: Circus.DescribeBlock,\n  mode?: Circus.BlockMode,\n): Circus.DescribeBlock => {\n  let _mode = mode;\n  if (parent && !mode) {\n    // If not set explicitly, inherit from the parent describe.\n    _mode = parent.mode;\n  }\n\n  return {\n    type: 'describeBlock', // eslint-disable-next-line sort-keys\n    children: [],\n    hooks: [],\n    mode: _mode,\n    name: convertDescriptorToString(name),\n    parent,\n    tests: [],\n  };\n};\n\nexport const makeTest = (\n  fn: Circus.TestFn,\n  mode: Circus.TestMode,\n  concurrent: boolean,\n  name: Circus.TestName,\n  parent: Circus.DescribeBlock,\n  timeout: number | undefined,\n  asyncError: Circus.Exception,\n  failing: boolean,\n): Circus.TestEntry => ({\n  type: 'test', // eslint-disable-next-line sort-keys\n  asyncError,\n  concurrent,\n  duration: null,\n  errors: [],\n  failing,\n  fn,\n  invocations: 0,\n  mode,\n  name: convertDescriptorToString(name),\n  numPassingAsserts: 0,\n  parent,\n  retryReasons: [],\n  seenDone: false,\n  startedAt: null,\n  status: null,\n  timeout,\n  unhandledRejectionErrorByPromise: new Map(),\n});\n\n// Traverse the tree of describe blocks and return true if at least one describe\n// block has an enabled test.\nconst hasEnabledTest = (describeBlock: Circus.DescribeBlock): boolean => {\n  const {hasFocusedTests, testNamePattern} = getState();\n  return describeBlock.children.some(child =>\n    child.type === 'describeBlock'\n      ? hasEnabledTest(child)\n      : !(\n          child.mode === 'skip' ||\n          (hasFocusedTests && child.mode !== 'only') ||\n          (testNamePattern && !testNamePattern.test(getTestID(child)))\n        ),\n  );\n};\n\ntype DescribeHooks = {\n  beforeAll: Array<Circus.Hook>;\n  afterAll: Array<Circus.Hook>;\n};\n\nexport const getAllHooksForDescribe = (\n  describe: Circus.DescribeBlock,\n): DescribeHooks => {\n  const result: DescribeHooks = {\n    afterAll: [],\n    beforeAll: [],\n  };\n\n  if (hasEnabledTest(describe)) {\n    for (const hook of describe.hooks) {\n      switch (hook.type) {\n        case 'beforeAll':\n          result.beforeAll.push(hook);\n          break;\n        case 'afterAll':\n          result.afterAll.push(hook);\n          break;\n      }\n    }\n  }\n\n  return result;\n};\n\ntype TestHooks = {\n  beforeEach: Array<Circus.Hook>;\n  afterEach: Array<Circus.Hook>;\n};\n\nexport const getEachHooksForTest = (test: Circus.TestEntry): TestHooks => {\n  const result: TestHooks = {afterEach: [], beforeEach: []};\n  if (test.concurrent) {\n    // *Each hooks are not run for concurrent tests\n    return result;\n  }\n\n  let block: Circus.DescribeBlock | undefined | null = test.parent;\n\n  do {\n    const beforeEachForCurrentBlock = [];\n    for (const hook of block.hooks) {\n      switch (hook.type) {\n        case 'beforeEach':\n          beforeEachForCurrentBlock.push(hook);\n          break;\n        case 'afterEach':\n          result.afterEach.push(hook);\n          break;\n      }\n    }\n    // 'beforeEach' hooks are executed from top to bottom, the opposite of the\n    // way we traversed it.\n    result.beforeEach.unshift(...beforeEachForCurrentBlock);\n  } while ((block = block.parent));\n  return result;\n};\n\nexport const describeBlockHasTests = (\n  describe: Circus.DescribeBlock,\n): boolean =>\n  describe.children.some(\n    child => child.type === 'test' || describeBlockHasTests(child),\n  );\n\nconst _makeTimeoutMessage = (\n  timeout: number,\n  isHook: boolean,\n  takesDoneCallback: boolean,\n) =>\n  `Exceeded timeout of ${formatTime(timeout)} for a ${\n    isHook ? 'hook' : 'test'\n  }${\n    takesDoneCallback ? ' while waiting for `done()` to be called' : ''\n  }.\\nAdd a timeout value to this test to increase the timeout, if this is a long-running test. See https://jestjs.io/docs/api#testname-fn-timeout.`;\n\n// Global values can be overwritten by mocks or tests. We'll capture\n// the original values in the variables before we require any files.\nconst {setTimeout, clearTimeout} = globalThis;\n\nfunction checkIsError(error: unknown): error is Error {\n  return !!(error && (error as Error).message && (error as Error).stack);\n}\n\nexport const callAsyncCircusFn = (\n  testOrHook: Circus.TestEntry | Circus.Hook,\n  testContext: Circus.TestContext,\n  {isHook, timeout}: {isHook: boolean; timeout: number},\n): Promise<unknown> => {\n  let timeoutID: NodeJS.Timeout;\n  let completed = false;\n\n  const {fn, asyncError} = testOrHook;\n  const doneCallback = takesDoneCallback(fn);\n\n  return new Promise<void>((resolve, reject) => {\n    timeoutID = setTimeout(\n      () => reject(_makeTimeoutMessage(timeout, isHook, doneCallback)),\n      timeout,\n    );\n\n    // If this fn accepts `done` callback we return a promise that fulfills as\n    // soon as `done` called.\n    if (doneCallback) {\n      let returnedValue: unknown = undefined;\n\n      const done = (reason?: Error | string): void => {\n        // We need to keep a stack here before the promise tick\n        const errorAtDone = new ErrorWithStack(undefined, done);\n\n        if (!completed && testOrHook.seenDone) {\n          errorAtDone.message =\n            'Expected done to be called once, but it was called multiple times.';\n\n          if (reason) {\n            errorAtDone.message += ` Reason: ${prettyFormat(reason, {\n              maxDepth: 3,\n            })}`;\n          }\n          reject(errorAtDone);\n          throw errorAtDone;\n        } else {\n          testOrHook.seenDone = true;\n        }\n\n        // Use `Promise.resolve` to allow the event loop to go a single tick in case `done` is called synchronously\n        Promise.resolve().then(() => {\n          if (returnedValue !== undefined) {\n            asyncError.message = dedent`\n              Test functions cannot both take a 'done' callback and return something. Either use a 'done' callback, or return a promise.\n              Returned value: ${prettyFormat(returnedValue, {maxDepth: 3})}\n            `;\n            return reject(asyncError);\n          }\n\n          let errorAsErrorObject: Error;\n          if (checkIsError(reason)) {\n            errorAsErrorObject = reason;\n          } else {\n            errorAsErrorObject = errorAtDone;\n            errorAtDone.message = `Failed: ${prettyFormat(reason, {\n              maxDepth: 3,\n            })}`;\n          }\n\n          // Consider always throwing, regardless if `reason` is set or not\n          if (completed && reason) {\n            errorAsErrorObject.message = `Caught error after test environment was torn down\\n\\n${errorAsErrorObject.message}`;\n\n            throw errorAsErrorObject;\n          }\n\n          return reason ? reject(errorAsErrorObject) : resolve();\n        });\n      };\n\n      returnedValue = fn.call(testContext, done);\n\n      return;\n    }\n\n    let returnedValue: Global.TestReturnValue;\n    if (isGeneratorFunction(fn)) {\n      returnedValue = co.wrap(fn).call({});\n    } else {\n      try {\n        returnedValue = fn.call(testContext);\n      } catch (error) {\n        reject(error);\n        return;\n      }\n    }\n\n    if (isPromise(returnedValue)) {\n      returnedValue.then(() => resolve(), reject);\n      return;\n    }\n\n    if (!isHook && returnedValue !== undefined) {\n      reject(\n        new Error(\n          dedent`\n            test functions can only return Promise or undefined.\n            Returned value: ${prettyFormat(returnedValue, {maxDepth: 3})}\n          `,\n        ),\n      );\n      return;\n    }\n\n    // Otherwise this test is synchronous, and if it didn't throw it means\n    // it passed.\n    resolve();\n  }).finally(() => {\n    completed = true;\n    // If timeout is not cleared/unrefed the node process won't exit until\n    // it's resolved.\n    timeoutID.unref?.();\n    clearTimeout(timeoutID);\n  });\n};\n\nexport const getTestDuration = (test: Circus.TestEntry): number | null => {\n  const {startedAt} = test;\n  return typeof startedAt === 'number' ? Date.now() - startedAt : null;\n};\n\nexport const makeRunResult = (\n  describeBlock: Circus.DescribeBlock,\n  unhandledErrors: Array<Error>,\n): Circus.RunResult => ({\n  testResults: makeTestResults(describeBlock),\n  unhandledErrors: unhandledErrors.map(_getError).map(getErrorStack),\n});\n\nconst getTestNamesPath = (test: Circus.TestEntry): Circus.TestNamesPath => {\n  const titles = [];\n  let parent: Circus.TestEntry | Circus.DescribeBlock | undefined = test;\n  do {\n    titles.unshift(parent.name);\n  } while ((parent = parent.parent));\n\n  return titles;\n};\n\nexport const makeSingleTestResult = (\n  test: Circus.TestEntry,\n): Circus.TestResult => {\n  const {includeTestLocationInResult} = getState();\n\n  const {status} = test;\n  invariant(status, 'Status should be present after tests are run.');\n\n  const testPath = getTestNamesPath(test);\n\n  let location = null;\n  if (includeTestLocationInResult) {\n    const stackLines = test.asyncError.stack.split('\\n');\n    const stackLine = stackLines[1];\n    let parsedLine = stackUtils.parseLine(stackLine);\n    if (parsedLine?.file?.startsWith(jestEachBuildDir)) {\n      const stackLine = stackLines[2];\n      parsedLine = stackUtils.parseLine(stackLine);\n    }\n    if (\n      parsedLine &&\n      typeof parsedLine.column === 'number' &&\n      typeof parsedLine.line === 'number'\n    ) {\n      location = {\n        column: parsedLine.column,\n        line: parsedLine.line,\n      };\n    }\n  }\n\n  const errorsDetailed = test.errors.map(_getError);\n\n  return {\n    duration: test.duration,\n    errors: errorsDetailed.map(getErrorStack),\n    errorsDetailed,\n    failing: test.failing,\n    invocations: test.invocations,\n    location,\n    numPassingAsserts: test.numPassingAsserts,\n    retryReasons: test.retryReasons.map(_getError).map(getErrorStack),\n    startedAt: test.startedAt,\n    status,\n    testPath: [...testPath],\n  };\n};\n\nconst makeTestResults = (\n  describeBlock: Circus.DescribeBlock,\n): Circus.TestResults => {\n  const testResults = [];\n  const stack: [[Circus.DescribeBlock, number]] = [[describeBlock, 0]];\n\n  while (stack.length > 0) {\n    const [currentBlock, childIndex] = stack.pop()!;\n\n    for (let i = childIndex; i < currentBlock.children.length; i++) {\n      const child = currentBlock.children[i];\n\n      if (child.type === 'describeBlock') {\n        stack.push([currentBlock, i + 1], [child, 0]);\n        break;\n      }\n      if (child.type === 'test') {\n        testResults.push(makeSingleTestResult(child));\n      }\n    }\n  }\n\n  return testResults;\n};\n\n// Return a string that identifies the test (concat of parent describe block\n// names + test title)\nexport const getTestID = (test: Circus.TestEntry): string => {\n  const testNamesPath = getTestNamesPath(test);\n  testNamesPath.shift(); // remove TOP_DESCRIBE_BLOCK_NAME\n  return testNamesPath.join(' ');\n};\n\nconst _getError = (\n  errors?: Circus.Exception | [Circus.Exception | undefined, Circus.Exception],\n): Error => {\n  let error;\n  let asyncError;\n\n  if (Array.isArray(errors)) {\n    error = errors[0];\n    asyncError = errors[1];\n  } else {\n    error = errors;\n    // eslint-disable-next-line unicorn/error-message\n    asyncError = new Error();\n  }\n\n  if (error && (typeof error.stack === 'string' || error.message)) {\n    return error;\n  }\n\n  asyncError.message = `thrown: ${prettyFormat(error, {maxDepth: 3})}`;\n\n  return asyncError;\n};\n\nconst getErrorStack = (error: Error): string =>\n  typeof error.stack === 'string' ? error.stack : error.message;\n\nexport const addErrorToEachTestUnderDescribe = (\n  describeBlock: Circus.DescribeBlock,\n  error: Circus.Exception,\n  asyncError: Circus.Exception,\n): void => {\n  for (const child of describeBlock.children) {\n    switch (child.type) {\n      case 'describeBlock':\n        addErrorToEachTestUnderDescribe(child, error, asyncError);\n        break;\n      case 'test':\n        child.errors.push([error, asyncError]);\n        break;\n    }\n  }\n};\n\ntype TestDescription = {\n  ancestorTitles: Array<string>;\n  fullName: string;\n  title: string;\n};\n\nconst resolveTestCaseStartInfo = (\n  testNamesPath: Circus.TestNamesPath,\n): TestDescription => {\n  const ancestorTitles = testNamesPath.filter(\n    name => name !== ROOT_DESCRIBE_BLOCK_NAME,\n  );\n  const fullName = ancestorTitles.join(' ');\n  const title = testNamesPath.at(-1)!;\n  // remove title\n  ancestorTitles.pop();\n  return {\n    ancestorTitles,\n    fullName,\n    title,\n  };\n};\n\nexport const parseSingleTestResult = (\n  testResult: Circus.TestResult,\n): TestCaseResult => {\n  let status: Status;\n  if (testResult.status === 'skip') {\n    status = 'pending';\n  } else if (testResult.status === 'todo') {\n    status = 'todo';\n  } else if (testResult.errors.length > 0) {\n    status = 'failed';\n  } else {\n    status = 'passed';\n  }\n\n  const {ancestorTitles, fullName, title} = resolveTestCaseStartInfo(\n    testResult.testPath,\n  );\n\n  return {\n    ancestorTitles,\n    duration: testResult.duration,\n    failing: testResult.failing,\n    failureDetails: testResult.errorsDetailed,\n    failureMessages: [...testResult.errors],\n    fullName,\n    invocations: testResult.invocations,\n    location: testResult.location,\n    numPassingAsserts: testResult.numPassingAsserts,\n    retryReasons: [...testResult.retryReasons],\n    startedAt: testResult.startedAt,\n    status,\n    title,\n  };\n};\n\nexport const createTestCaseStartInfo = (\n  test: Circus.TestEntry,\n): Circus.TestCaseStartInfo => {\n  const testPath = getTestNamesPath(test);\n  const {ancestorTitles, fullName, title} = resolveTestCaseStartInfo(testPath);\n\n  return {\n    ancestorTitles,\n    fullName,\n    mode: test.mode,\n    startedAt: test.startedAt,\n    title,\n  };\n};\n",
  "packages/jest-circus/src/utils.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { TestCaseResult } from '@jest/test-result';\nimport type { Circus } from '@jest/types';\nexport declare const makeDescribe: (name: Circus.BlockName, parent?: Circus.DescribeBlock, mode?: Circus.BlockMode) => Circus.DescribeBlock;\nexport declare const makeTest: (fn: Circus.TestFn, mode: Circus.TestMode, concurrent: boolean, name: Circus.TestName, parent: Circus.DescribeBlock, timeout: number | undefined, asyncError: Circus.Exception, failing: boolean) => Circus.TestEntry;\ntype DescribeHooks = {\n    beforeAll: Array<Circus.Hook>;\n    afterAll: Array<Circus.Hook>;\n};\nexport declare const getAllHooksForDescribe: (describe: Circus.DescribeBlock) => DescribeHooks;\ntype TestHooks = {\n    beforeEach: Array<Circus.Hook>;\n    afterEach: Array<Circus.Hook>;\n};\nexport declare const getEachHooksForTest: (test: Circus.TestEntry) => TestHooks;\nexport declare const describeBlockHasTests: (describe: Circus.DescribeBlock) => boolean;\nexport declare const callAsyncCircusFn: (testOrHook: Circus.TestEntry | Circus.Hook, testContext: Circus.TestContext, { isHook, timeout }: {\n    isHook: boolean;\n    timeout: number;\n}) => Promise<unknown>;\nexport declare const getTestDuration: (test: Circus.TestEntry) => number | null;\nexport declare const makeRunResult: (describeBlock: Circus.DescribeBlock, unhandledErrors: Array<Error>) => Circus.RunResult;\nexport declare const makeSingleTestResult: (test: Circus.TestEntry) => Circus.TestResult;\nexport declare const getTestID: (test: Circus.TestEntry) => string;\nexport declare const addErrorToEachTestUnderDescribe: (describeBlock: Circus.DescribeBlock, error: Circus.Exception, asyncError: Circus.Exception) => void;\nexport declare const parseSingleTestResult: (testResult: Circus.TestResult) => TestCaseResult;\nexport declare const createTestCaseStartInfo: (test: Circus.TestEntry) => Circus.TestCaseStartInfo;\nexport {};\n",
  "packages/jest-circus/src/unhandledRejectionHandler.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {Circus} from '@jest/types';\nimport type Runtime from 'jest-runtime';\nimport {invariant} from 'jest-util';\nimport {addErrorToEachTestUnderDescribe} from './utils';\n\n// Global values can be overwritten by mocks or tests. We'll capture\n// the original values in the variables before we require any files.\nconst {setTimeout} = globalThis;\n\nconst untilNextEventLoopTurn = async () => {\n  return new Promise(resolve => {\n    setTimeout(resolve, 0);\n  });\n};\n\nexport const unhandledRejectionHandler = (\n  runtime: Runtime,\n  waitForUnhandledRejections: boolean,\n): Circus.EventHandler => {\n  return async (event, state) => {\n    if (event.name === 'hook_start') {\n      runtime.enterTestCode();\n    } else if (event.name === 'hook_success' || event.name === 'hook_failure') {\n      runtime.leaveTestCode();\n\n      if (waitForUnhandledRejections) {\n        // We need to give event loop the time to actually execute `rejectionHandled`, `uncaughtException` or `unhandledRejection` events\n        await untilNextEventLoopTurn();\n      }\n\n      const {test, describeBlock, hook} = event;\n      const {asyncError, type} = hook;\n\n      if (type === 'beforeAll') {\n        invariant(describeBlock, 'always present for `*All` hooks');\n        for (const error of state.unhandledRejectionErrorByPromise.values()) {\n          addErrorToEachTestUnderDescribe(describeBlock, error, asyncError);\n        }\n      } else if (type === 'afterAll') {\n        // Attaching `afterAll` errors to each test makes execution flow\n        // too complicated, so we'll consider them to be global.\n        for (const error of state.unhandledRejectionErrorByPromise.values()) {\n          state.unhandledErrors.push([error, asyncError]);\n        }\n      } else {\n        invariant(test, 'always present for `*Each` hooks');\n        for (const error of test.unhandledRejectionErrorByPromise.values()) {\n          test.errors.push([error, asyncError]);\n        }\n      }\n    } else if (event.name === 'test_fn_start') {\n      runtime.enterTestCode();\n    } else if (\n      event.name === 'test_fn_success' ||\n      event.name === 'test_fn_failure'\n    ) {\n      runtime.leaveTestCode();\n\n      if (waitForUnhandledRejections) {\n        // We need to give event loop the time to actually execute `rejectionHandled`, `uncaughtException` or `unhandledRejection` events\n        await untilNextEventLoopTurn();\n      }\n\n      const {test} = event;\n      invariant(test, 'always present for `*Each` hooks');\n\n      for (const error of test.unhandledRejectionErrorByPromise.values()) {\n        test.errors.push([error, event.test.asyncError]);\n      }\n    } else if (event.name === 'teardown') {\n      if (waitForUnhandledRejections) {\n        // We need to give event loop the time to actually execute `rejectionHandled`, `uncaughtException` or `unhandledRejection` events\n        await untilNextEventLoopTurn();\n      }\n\n      state.unhandledErrors.push(\n        ...state.unhandledRejectionErrorByPromise.values(),\n      );\n    }\n  };\n};\n",
  "packages/jest-circus/src/unhandledRejectionHandler.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Circus } from '@jest/types';\nimport type Runtime from 'jest-runtime';\nexport declare const unhandledRejectionHandler: (runtime: Runtime, waitForUnhandledRejections: boolean) => Circus.EventHandler;\n",
  "packages/jest-circus/src/types.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nexport const STATE_SYM = Symbol('JEST_STATE_SYMBOL');\nexport const RETRY_TIMES = Symbol.for('RETRY_TIMES');\nexport const RETRY_IMMEDIATELY = Symbol.for('RETRY_IMMEDIATELY');\nexport const WAIT_BEFORE_RETRY = Symbol.for('WAIT_BEFORE_RETRY');\n// To pass this value from Runtime object to state we need to use global[sym]\nexport const TEST_TIMEOUT_SYMBOL = Symbol.for('TEST_TIMEOUT_SYMBOL');\nexport const EVENT_HANDLERS = Symbol.for('EVENT_HANDLERS');\nexport const LOG_ERRORS_BEFORE_RETRY = Symbol.for('LOG_ERRORS_BEFORE_RETRY');\n",
  "packages/jest-circus/src/types.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport declare const STATE_SYM: unique symbol;\nexport declare const RETRY_TIMES: unique symbol;\nexport declare const RETRY_IMMEDIATELY: unique symbol;\nexport declare const WAIT_BEFORE_RETRY: unique symbol;\nexport declare const TEST_TIMEOUT_SYMBOL: unique symbol;\nexport declare const EVENT_HANDLERS: unique symbol;\nexport declare const LOG_ERRORS_BEFORE_RETRY: unique symbol;\n",
  "packages/jest-circus/src/testCaseReportHandler.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {TestFileEvent} from '@jest/test-result';\nimport type {Circus} from '@jest/types';\nimport {\n  createTestCaseStartInfo,\n  makeSingleTestResult,\n  parseSingleTestResult,\n} from './utils';\n\nconst testCaseReportHandler =\n  (testPath: string, sendMessageToJest: TestFileEvent) =>\n  (event: Circus.Event): void => {\n    switch (event.name) {\n      case 'test_started': {\n        const testCaseStartInfo = createTestCaseStartInfo(event.test);\n        sendMessageToJest('test-case-start', [testPath, testCaseStartInfo]);\n        break;\n      }\n      case 'test_todo':\n      case 'test_done': {\n        const testResult = makeSingleTestResult(event.test);\n        const testCaseResult = parseSingleTestResult(testResult);\n        sendMessageToJest('test-case-result', [testPath, testCaseResult]);\n        break;\n      }\n    }\n  };\n\nexport default testCaseReportHandler;\n",
  "packages/jest-circus/src/testCaseReportHandler.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { TestFileEvent } from '@jest/test-result';\nimport type { Circus } from '@jest/types';\ndeclare const testCaseReportHandler: (testPath: string, sendMessageToJest: TestFileEvent) => (event: Circus.Event) => void;\nexport default testCaseReportHandler;\n",
  "packages/jest-circus/src/state.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {Circus, Global} from '@jest/types';\nimport {protectProperties, setGlobal} from 'jest-util';\nimport eventHandler from './eventHandler';\nimport formatNodeAssertErrors from './formatNodeAssertErrors';\nimport {EVENT_HANDLERS, STATE_SYM} from './types';\nimport {makeDescribe} from './utils';\n\nconst handlers: Array<Circus.EventHandler> = ((globalThis as Global.Global)[\n  EVENT_HANDLERS\n] as Array<Circus.EventHandler>) || [eventHandler, formatNodeAssertErrors];\nsetGlobal(globalThis, EVENT_HANDLERS, handlers, 'retain');\n\nexport const ROOT_DESCRIBE_BLOCK_NAME = 'ROOT_DESCRIBE_BLOCK';\n\nconst createState = (): Circus.State => {\n  const ROOT_DESCRIBE_BLOCK = makeDescribe(ROOT_DESCRIBE_BLOCK_NAME);\n  return {\n    currentDescribeBlock: ROOT_DESCRIBE_BLOCK,\n    currentlyRunningTest: null,\n    expand: undefined,\n    hasFocusedTests: false,\n    hasStarted: false,\n    includeTestLocationInResult: false,\n    maxConcurrency: 5,\n    parentProcess: null,\n    rootDescribeBlock: ROOT_DESCRIBE_BLOCK,\n    seed: 0,\n    testNamePattern: null,\n    testTimeout: 5000,\n    unhandledErrors: [],\n    unhandledRejectionErrorByPromise: new Map(),\n  };\n};\n\nexport const getState = (): Circus.State =>\n  (globalThis as Global.Global)[STATE_SYM] as Circus.State;\nexport const setState = (state: Circus.State): Circus.State => {\n  setGlobal(globalThis, STATE_SYM, state);\n  protectProperties(state, [\n    'hasFocusedTests',\n    'hasStarted',\n    'includeTestLocationInResult',\n    'maxConcurrency',\n    'seed',\n    'testNamePattern',\n    'testTimeout',\n    'unhandledErrors',\n    'unhandledRejectionErrorByPromise',\n  ]);\n  return state;\n};\nexport const resetState = (): void => {\n  setState(createState());\n};\n\nresetState();\n\nexport const dispatch = async (event: Circus.AsyncEvent): Promise<void> => {\n  for (const handler of handlers) {\n    await handler(event, getState());\n  }\n};\n\nexport const dispatchSync = (event: Circus.SyncEvent): void => {\n  for (const handler of handlers) {\n    handler(event, getState());\n  }\n};\n\nexport const addEventHandler = (handler: Circus.EventHandler): void => {\n  handlers.push(handler);\n};\n\nexport const removeEventHandler = (handler: Circus.EventHandler): void => {\n  const index = handlers.lastIndexOf(handler);\n  if (index !== -1) {\n    handlers.splice(index, 1);\n  }\n};\n",
  "packages/jest-circus/src/state.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Circus } from '@jest/types';\nexport declare const ROOT_DESCRIBE_BLOCK_NAME = \"ROOT_DESCRIBE_BLOCK\";\nexport declare const getState: () => Circus.State;\nexport declare const setState: (state: Circus.State) => Circus.State;\nexport declare const resetState: () => void;\nexport declare const dispatch: (event: Circus.AsyncEvent) => Promise<void>;\nexport declare const dispatchSync: (event: Circus.SyncEvent) => void;\nexport declare const addEventHandler: (handler: Circus.EventHandler) => void;\nexport declare const removeEventHandler: (handler: Circus.EventHandler) => void;\n",
  "packages/jest-circus/src/shuffleArray.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {unsafeUniformIntDistribution, xoroshiro128plus} from 'pure-rand';\n\n// Generates [from, to] inclusive\nexport type RandomNumberGenerator = {\n  next: (from: number, to: number) => number;\n};\n\nexport const rngBuilder = (seed: number): RandomNumberGenerator => {\n  const gen = xoroshiro128plus(seed);\n  return {next: (from, to) => unsafeUniformIntDistribution(from, to, gen)};\n};\n\n// Fisher-Yates shuffle\n// This is performed in-place\nexport default function shuffleArray<T>(\n  array: Array<T>,\n  random: RandomNumberGenerator,\n): Array<T> {\n  const length = array.length;\n  if (length === 0) {\n    return [];\n  }\n\n  for (let i = 0; i < length; i++) {\n    const n = random.next(i, length - 1);\n    const value = array[i];\n    array[i] = array[n];\n    array[n] = value;\n  }\n\n  return array;\n}\n",
  "packages/jest-circus/src/shuffleArray.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport type RandomNumberGenerator = {\n    next: (from: number, to: number) => number;\n};\nexport declare const rngBuilder: (seed: number) => RandomNumberGenerator;\nexport default function shuffleArray<T>(array: Array<T>, random: RandomNumberGenerator): Array<T>;\n",
  "packages/jest-circus/src/runner.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// Allow people to use `jest-circus/runner` as a runner.\nimport runner from './legacy-code-todo-rewrite/jestAdapter';\n\nexport default runner;\n",
  "packages/jest-circus/src/runner.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport runner from './legacy-code-todo-rewrite/jestAdapter';\nexport default runner;\n",
  "packages/jest-circus/src/run.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {AsyncLocalStorage} from 'async_hooks';\nimport pLimit from 'p-limit';\nimport {jestExpect} from '@jest/expect';\nimport type {Circus, Global} from '@jest/types';\nimport {invariant} from 'jest-util';\nimport shuffleArray, {\n  type RandomNumberGenerator,\n  rngBuilder,\n} from './shuffleArray';\nimport {dispatch, getState} from './state';\nimport {RETRY_IMMEDIATELY, RETRY_TIMES, WAIT_BEFORE_RETRY} from './types';\nimport {\n  callAsyncCircusFn,\n  getAllHooksForDescribe,\n  getEachHooksForTest,\n  getTestID,\n  makeRunResult,\n} from './utils';\n\n// Global values can be overwritten by mocks or tests. We'll capture\n// the original values in the variables before we require any files.\nconst {setTimeout} = globalThis;\n\ntype ConcurrentTestEntry = Omit<Circus.TestEntry, 'fn'> & {\n  fn: Circus.ConcurrentTestFn;\n  done: Promise<void>;\n};\n\nconst run = async (): Promise<Circus.RunResult> => {\n  const {rootDescribeBlock, seed, randomize} = getState();\n  const rng = randomize ? rngBuilder(seed) : undefined;\n  await dispatch({name: 'run_start'});\n  await _runTestsForDescribeBlock(rootDescribeBlock, rng, true);\n  await dispatch({name: 'run_finish'});\n  return makeRunResult(\n    getState().rootDescribeBlock,\n    getState().unhandledErrors,\n  );\n};\n\nconst _runTestsForDescribeBlock = async (\n  describeBlock: Circus.DescribeBlock,\n  rng: RandomNumberGenerator | undefined,\n  isRootBlock = false,\n) => {\n  await dispatch({describeBlock, name: 'run_describe_start'});\n  const {beforeAll, afterAll} = getAllHooksForDescribe(describeBlock);\n\n  const isSkipped = describeBlock.mode === 'skip';\n\n  if (!isSkipped) {\n    for (const hook of beforeAll) {\n      await _callCircusHook({describeBlock, hook});\n    }\n  }\n\n  if (isRootBlock) {\n    const concurrentTests = collectConcurrentTests(describeBlock);\n    if (concurrentTests.length > 0) {\n      startTestsConcurrently(concurrentTests, isSkipped);\n    }\n  }\n\n  // Tests that fail and are retried we run after other tests\n  const retryTimes =\n    Number.parseInt((globalThis as Global.Global)[RETRY_TIMES] as string, 10) ||\n    0;\n\n  const waitBeforeRetry =\n    Number.parseInt(\n      (globalThis as Global.Global)[WAIT_BEFORE_RETRY] as string,\n      10,\n    ) || 0;\n\n  const retryImmediately: boolean =\n    ((globalThis as Global.Global)[RETRY_IMMEDIATELY] as any) || false;\n\n  const deferredRetryTests: Array<Circus.TestEntry> = [];\n\n  if (rng) {\n    describeBlock.children = shuffleArray(describeBlock.children, rng);\n  }\n\n  const rerunTest = async (test: Circus.TestEntry) => {\n    let numRetriesAvailable = retryTimes;\n\n    while (numRetriesAvailable > 0 && test.errors.length > 0) {\n      // Clear errors so retries occur\n      await dispatch({name: 'test_retry', test});\n\n      if (waitBeforeRetry > 0) {\n        await new Promise(resolve => setTimeout(resolve, waitBeforeRetry));\n      }\n\n      await _runTest(test, isSkipped);\n      numRetriesAvailable--;\n    }\n  };\n\n  const handleRetry = async (\n    test: Circus.TestEntry,\n    hasErrorsBeforeTestRun: boolean,\n    hasRetryTimes: boolean,\n  ) => {\n    // no retry if the test passed or had errors before the test ran\n    if (test.errors.length === 0 || hasErrorsBeforeTestRun || !hasRetryTimes) {\n      return;\n    }\n\n    if (!retryImmediately) {\n      deferredRetryTests.push(test);\n      return;\n    }\n\n    // If immediate retry is set, we retry the test immediately after the first run\n    await rerunTest(test);\n  };\n\n  const concurrentTests = [];\n\n  for (const child of describeBlock.children) {\n    switch (child.type) {\n      case 'describeBlock': {\n        await _runTestsForDescribeBlock(child, rng);\n        break;\n      }\n      case 'test': {\n        const hasErrorsBeforeTestRun = child.errors.length > 0;\n        const hasRetryTimes = retryTimes > 0;\n        if (child.concurrent) {\n          concurrentTests.push(\n            (child as ConcurrentTestEntry).done.then(() =>\n              handleRetry(child, hasErrorsBeforeTestRun, hasRetryTimes),\n            ),\n          );\n        } else {\n          await _runTest(child, isSkipped);\n          await handleRetry(child, hasErrorsBeforeTestRun, hasRetryTimes);\n        }\n        break;\n      }\n    }\n  }\n\n  // wait for concurrent tests to finish\n  await Promise.all(concurrentTests);\n\n  // Re-run failed tests n-times if configured\n  for (const test of deferredRetryTests) {\n    await rerunTest(test);\n  }\n\n  if (!isSkipped) {\n    for (const hook of afterAll) {\n      await _callCircusHook({describeBlock, hook});\n    }\n  }\n\n  await dispatch({describeBlock, name: 'run_describe_finish'});\n};\n\nfunction collectConcurrentTests(\n  describeBlock: Circus.DescribeBlock,\n): Array<ConcurrentTestEntry> {\n  if (describeBlock.mode === 'skip') {\n    return [];\n  }\n  return describeBlock.children.flatMap(child => {\n    switch (child.type) {\n      case 'describeBlock':\n        return collectConcurrentTests(child);\n      case 'test':\n        if (child.concurrent) {\n          return [child as ConcurrentTestEntry];\n        }\n        return [];\n    }\n  });\n}\n\nfunction startTestsConcurrently(\n  concurrentTests: Array<ConcurrentTestEntry>,\n  parentSkipped: boolean,\n) {\n  const mutex = pLimit(getState().maxConcurrency);\n  const testNameStorage = new AsyncLocalStorage<string>();\n  jestExpect.setState({\n    currentConcurrentTestName: () => testNameStorage.getStore(),\n  });\n  for (const test of concurrentTests) {\n    try {\n      const promise = mutex(() =>\n        testNameStorage.run(getTestID(test), () =>\n          _runTest(test, parentSkipped),\n        ),\n      );\n      // Avoid triggering the uncaught promise rejection handler in case the\n      // test fails before being awaited on.\n      // eslint-disable-next-line @typescript-eslint/no-empty-function\n      promise.catch(() => {});\n      test.done = promise;\n    } catch (error) {\n      test.fn = () => {\n        throw error;\n      };\n    }\n  }\n}\n\nconst _runTest = async (\n  test: Circus.TestEntry,\n  parentSkipped: boolean,\n): Promise<void> => {\n  await dispatch({name: 'test_start', test});\n  const testContext = Object.create(null);\n  const {hasFocusedTests, testNamePattern} = getState();\n\n  const isSkipped =\n    parentSkipped ||\n    test.mode === 'skip' ||\n    (hasFocusedTests && test.mode === undefined) ||\n    (testNamePattern && !testNamePattern.test(getTestID(test)));\n\n  if (isSkipped) {\n    await dispatch({name: 'test_skip', test});\n    return;\n  }\n\n  if (test.mode === 'todo') {\n    await dispatch({name: 'test_todo', test});\n    return;\n  }\n\n  await dispatch({name: 'test_started', test});\n\n  const {afterEach, beforeEach} = getEachHooksForTest(test);\n\n  for (const hook of beforeEach) {\n    if (test.errors.length > 0) {\n      // If any of the before hooks failed already, we don't run any\n      // hooks after that.\n      break;\n    }\n    await _callCircusHook({hook, test, testContext});\n  }\n\n  await _callCircusTest(test, testContext);\n\n  for (const hook of afterEach) {\n    await _callCircusHook({hook, test, testContext});\n  }\n\n  // `afterAll` hooks should not affect test status (pass or fail), because if\n  // we had a global `afterAll` hook it would block all existing tests until\n  // this hook is executed. So we dispatch `test_done` right away.\n  await dispatch({name: 'test_done', test});\n};\n\nconst _callCircusHook = async ({\n  hook,\n  test,\n  describeBlock,\n  testContext = {},\n}: {\n  hook: Circus.Hook;\n  describeBlock?: Circus.DescribeBlock;\n  test?: Circus.TestEntry;\n  testContext?: Circus.TestContext;\n}): Promise<void> => {\n  await dispatch({hook, name: 'hook_start'});\n  const timeout = hook.timeout || getState().testTimeout;\n\n  try {\n    await callAsyncCircusFn(hook, testContext, {\n      isHook: true,\n      timeout,\n    });\n    await dispatch({describeBlock, hook, name: 'hook_success', test});\n  } catch (error) {\n    await dispatch({describeBlock, error, hook, name: 'hook_failure', test});\n  }\n};\n\nconst _callCircusTest = async (\n  test: Circus.TestEntry,\n  testContext: Circus.TestContext,\n): Promise<void> => {\n  await dispatch({name: 'test_fn_start', test});\n  const timeout = test.timeout || getState().testTimeout;\n  invariant(test.fn, \"Tests with no 'fn' should have 'mode' set to 'skipped'\");\n\n  if (test.errors.length > 0) {\n    return; // We don't run the test if there's already an error in before hooks.\n  }\n\n  try {\n    await callAsyncCircusFn(test, testContext, {\n      isHook: false,\n      timeout,\n    });\n    if (test.failing) {\n      test.asyncError.message =\n        'Failing test passed even though it was supposed to fail. Remove `.failing` to remove error.';\n      await dispatch({\n        error: test.asyncError,\n        name: 'test_fn_failure',\n        test,\n      });\n    } else {\n      await dispatch({name: 'test_fn_success', test});\n    }\n  } catch (error) {\n    if (test.failing) {\n      await dispatch({name: 'test_fn_success', test});\n    } else {\n      await dispatch({error, name: 'test_fn_failure', test});\n    }\n  }\n};\n\nexport default run;\n",
  "packages/jest-circus/src/run.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Circus } from '@jest/types';\ndeclare const run: () => Promise<Circus.RunResult>;\nexport default run;\n",
  "packages/jest-circus/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {Circus, Global} from '@jest/types';\nimport {bind as bindEach} from 'jest-each';\nimport {ErrorWithStack, convertDescriptorToString, isPromise} from 'jest-util';\nimport {dispatchSync} from './state';\n\nexport {\n  setState,\n  getState,\n  resetState,\n  addEventHandler,\n  removeEventHandler,\n} from './state';\nexport {default as run} from './run';\n\ntype THook = (fn: Circus.HookFn, timeout?: number) => void;\ntype DescribeFn = (\n  blockName: Circus.BlockNameLike,\n  blockFn: Circus.BlockFn,\n) => void;\n\nconst describe = (() => {\n  const describe = (blockName: Circus.BlockNameLike, blockFn: Circus.BlockFn) =>\n    _dispatchDescribe(blockFn, blockName, describe);\n  const only = (blockName: Circus.BlockNameLike, blockFn: Circus.BlockFn) =>\n    _dispatchDescribe(blockFn, blockName, only, 'only');\n  const skip = (blockName: Circus.BlockNameLike, blockFn: Circus.BlockFn) =>\n    _dispatchDescribe(blockFn, blockName, skip, 'skip');\n\n  describe.each = bindEach(describe, false);\n\n  only.each = bindEach(only, false);\n  skip.each = bindEach(skip, false);\n\n  describe.only = only;\n  describe.skip = skip;\n\n  return describe;\n})();\n\nconst _dispatchDescribe = (\n  blockFn: Circus.BlockFn,\n  blockName: Circus.BlockNameLike,\n  describeFn: DescribeFn,\n  mode?: Circus.BlockMode,\n) => {\n  const asyncError = new ErrorWithStack(undefined, describeFn);\n  if (blockFn === undefined) {\n    asyncError.message =\n      'Missing second argument. It must be a callback function.';\n    throw asyncError;\n  }\n  if (typeof blockFn !== 'function') {\n    asyncError.message = `Invalid second argument, ${blockFn}. It must be a callback function.`;\n    throw asyncError;\n  }\n  try {\n    blockName = convertDescriptorToString(blockName);\n  } catch (error) {\n    asyncError.message = (error as Error).message;\n    throw asyncError;\n  }\n\n  dispatchSync({\n    asyncError,\n    blockName,\n    mode,\n    name: 'start_describe_definition',\n  });\n  const describeReturn = blockFn();\n\n  if (isPromise(describeReturn)) {\n    throw new ErrorWithStack(\n      'Returning a Promise from \"describe\" is not supported. Tests must be defined synchronously.',\n      describeFn,\n    );\n  } else if (describeReturn !== undefined) {\n    throw new ErrorWithStack(\n      'A \"describe\" callback must not return a value.',\n      describeFn,\n    );\n  }\n\n  dispatchSync({blockName, mode, name: 'finish_describe_definition'});\n};\n\nconst _addHook = (\n  fn: Circus.HookFn,\n  hookType: Circus.HookType,\n  hookFn: THook,\n  timeout?: number,\n) => {\n  const asyncError = new ErrorWithStack(undefined, hookFn);\n\n  if (typeof fn !== 'function') {\n    asyncError.message =\n      'Invalid first argument. It must be a callback function.';\n\n    throw asyncError;\n  }\n\n  dispatchSync({asyncError, fn, hookType, name: 'add_hook', timeout});\n};\n\n// Hooks have to pass themselves to the HOF in order for us to trim stack traces.\nconst beforeEach: THook = (fn, timeout) =>\n  _addHook(fn, 'beforeEach', beforeEach, timeout);\nconst beforeAll: THook = (fn, timeout) =>\n  _addHook(fn, 'beforeAll', beforeAll, timeout);\nconst afterEach: THook = (fn, timeout) =>\n  _addHook(fn, 'afterEach', afterEach, timeout);\nconst afterAll: THook = (fn, timeout) =>\n  _addHook(fn, 'afterAll', afterAll, timeout);\n\nconst test: Global.It = (() => {\n  const test = (\n    testName: Circus.TestNameLike,\n    fn: Circus.TestFn,\n    timeout?: number,\n  ): void => _addTest(testName, undefined, false, fn, test, timeout);\n  const skip = (\n    testName: Circus.TestNameLike,\n    fn?: Circus.TestFn,\n    timeout?: number,\n  ): void => _addTest(testName, 'skip', false, fn, skip, timeout);\n  const only = (\n    testName: Circus.TestNameLike,\n    fn: Circus.TestFn,\n    timeout?: number,\n  ): void => _addTest(testName, 'only', false, fn, test.only, timeout);\n  const concurrentTest = (\n    testName: Circus.TestNameLike,\n    fn: Circus.TestFn,\n    timeout?: number,\n  ): void => _addTest(testName, undefined, true, fn, concurrentTest, timeout);\n  const concurrentOnly = (\n    testName: Circus.TestNameLike,\n    fn: Circus.TestFn,\n    timeout?: number,\n  ): void => _addTest(testName, 'only', true, fn, concurrentOnly, timeout);\n\n  const bindFailing = (concurrent: boolean, mode: Circus.TestMode) => {\n    type FailingReturn = typeof concurrent extends true\n      ? Global.ConcurrentTestFn\n      : Global.TestFn;\n    const failing: Global.Failing<FailingReturn> = (\n      testName: Circus.TestNameLike,\n      fn?: Circus.TestFn,\n      timeout?: number,\n      eachError?: Error,\n    ): void =>\n      _addTest(\n        testName,\n        mode,\n        concurrent,\n        fn,\n        failing,\n        timeout,\n        true,\n        eachError,\n      );\n    failing.each = bindEach(failing, false, true);\n    return failing;\n  };\n\n  test.todo = (testName: Circus.TestNameLike, ...rest: Array<any>): void => {\n    if (rest.length > 0 || typeof testName !== 'string') {\n      throw new ErrorWithStack(\n        'Todo must be called with only a description.',\n        test.todo,\n      );\n    }\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    return _addTest(testName, 'todo', false, () => {}, test.todo);\n  };\n\n  const _addTest = (\n    testName: Circus.TestNameLike,\n    mode: Circus.TestMode,\n    concurrent: boolean,\n    fn: Circus.TestFn | undefined,\n    testFn: (\n      testName: Circus.TestNameLike,\n      fn: Circus.TestFn,\n      timeout?: number,\n    ) => void,\n    timeout?: number,\n    failing?: boolean,\n    asyncError: Error = new ErrorWithStack(undefined, testFn),\n  ) => {\n    try {\n      testName = convertDescriptorToString(testName);\n    } catch (error) {\n      asyncError.message = (error as Error).message;\n      throw asyncError;\n    }\n\n    if (fn === undefined) {\n      asyncError.message =\n        'Missing second argument. It must be a callback function. Perhaps you want to use `test.todo` for a test placeholder.';\n\n      throw asyncError;\n    }\n    if (typeof fn !== 'function') {\n      asyncError.message = `Invalid second argument, ${fn}. It must be a callback function.`;\n\n      throw asyncError;\n    }\n\n    return dispatchSync({\n      asyncError,\n      concurrent,\n      failing: failing === undefined ? false : failing,\n      fn,\n      mode,\n      name: 'add_test',\n      testName,\n      timeout,\n    });\n  };\n\n  test.each = bindEach(test);\n  only.each = bindEach(only);\n  skip.each = bindEach(skip);\n\n  concurrentTest.each = bindEach(concurrentTest, false);\n  concurrentOnly.each = bindEach(concurrentOnly, false);\n\n  only.failing = bindFailing(false, 'only');\n  skip.failing = bindFailing(false, 'skip');\n\n  test.failing = bindFailing(false);\n  test.only = only;\n  test.skip = skip;\n  test.concurrent = concurrentTest;\n  concurrentTest.only = concurrentOnly;\n  concurrentTest.skip = skip;\n  concurrentTest.failing = bindFailing(true);\n  concurrentOnly.failing = bindFailing(true, 'only');\n\n  return test;\n})();\n\nconst it: Global.It = test;\n\nexport type Event = Circus.Event;\nexport type State = Circus.State;\nexport {afterAll, afterEach, beforeAll, beforeEach, describe, it, test};\nexport default {\n  afterAll,\n  afterEach,\n  beforeAll,\n  beforeEach,\n  describe,\n  it,\n  test,\n};\n",
  "packages/jest-circus/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Circus, Global } from '@jest/types';\nexport { setState, getState, resetState, addEventHandler, removeEventHandler, } from './state';\nexport { default as run } from './run';\ntype THook = (fn: Circus.HookFn, timeout?: number) => void;\ndeclare const describe: {\n    (blockName: Circus.BlockNameLike, blockFn: Circus.BlockFn): void;\n    each: any;\n    only: {\n        (blockName: Circus.BlockNameLike, blockFn: Circus.BlockFn): void;\n        each: any;\n    };\n    skip: {\n        (blockName: Circus.BlockNameLike, blockFn: Circus.BlockFn): void;\n        each: any;\n    };\n};\ndeclare const beforeEach: THook;\ndeclare const beforeAll: THook;\ndeclare const afterEach: THook;\ndeclare const afterAll: THook;\ndeclare const test: Global.It;\ndeclare const it: Global.It;\nexport type Event = Circus.Event;\nexport type State = Circus.State;\nexport { afterAll, afterEach, beforeAll, beforeEach, describe, it, test };\ndeclare const _default: {\n    afterAll: THook;\n    afterEach: THook;\n    beforeAll: THook;\n    beforeEach: THook;\n    describe: {\n        (blockName: Circus.BlockNameLike, blockFn: Circus.BlockFn): void;\n        each: any;\n        only: {\n            (blockName: Circus.BlockNameLike, blockFn: Circus.BlockFn): void;\n            each: any;\n        };\n        skip: {\n            (blockName: Circus.BlockNameLike, blockFn: Circus.BlockFn): void;\n            each: any;\n        };\n    };\n    it: Global.It;\n    test: Global.It;\n};\nexport default _default;\n",
  "packages/jest-circus/src/globalErrorHandlers.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type * as Process from 'process';\nimport type {Circus} from '@jest/types';\nimport {dispatchSync} from './state';\n\nconst uncaughtExceptionListener: NodeJS.UncaughtExceptionListener = (\n  error: unknown,\n) => {\n  dispatchSync({error, name: 'error'});\n};\n\nconst unhandledRejectionListener: NodeJS.UnhandledRejectionListener = (\n  error: unknown,\n  promise: Promise<unknown>,\n) => {\n  dispatchSync({error, name: 'error', promise});\n};\n\nconst rejectionHandledListener: NodeJS.RejectionHandledListener = (\n  promise: Promise<unknown>,\n) => {\n  dispatchSync({name: 'error_handled', promise});\n};\n\nexport const injectGlobalErrorHandlers = (\n  parentProcess: typeof Process,\n): Circus.GlobalErrorHandlers => {\n  const uncaughtException = [...process.listeners('uncaughtException')];\n  const unhandledRejection = [...process.listeners('unhandledRejection')];\n  const rejectionHandled = [...process.listeners('rejectionHandled')];\n  parentProcess.removeAllListeners('uncaughtException');\n  parentProcess.removeAllListeners('unhandledRejection');\n  parentProcess.removeAllListeners('rejectionHandled');\n  parentProcess.on('uncaughtException', uncaughtExceptionListener);\n  parentProcess.on('unhandledRejection', unhandledRejectionListener);\n  parentProcess.on('rejectionHandled', rejectionHandledListener);\n  return {rejectionHandled, uncaughtException, unhandledRejection};\n};\n\nexport const restoreGlobalErrorHandlers = (\n  parentProcess: typeof Process,\n  originalErrorHandlers: Circus.GlobalErrorHandlers,\n): void => {\n  parentProcess.removeListener('uncaughtException', uncaughtExceptionListener);\n  parentProcess.removeListener(\n    'unhandledRejection',\n    unhandledRejectionListener,\n  );\n  parentProcess.removeListener('rejectionHandled', rejectionHandledListener);\n\n  for (const listener of originalErrorHandlers.uncaughtException) {\n    parentProcess.on('uncaughtException', listener);\n  }\n  for (const listener of originalErrorHandlers.unhandledRejection) {\n    parentProcess.on('unhandledRejection', listener);\n  }\n  for (const listener of originalErrorHandlers.rejectionHandled) {\n    parentProcess.on('rejectionHandled', listener);\n  }\n};\n",
  "packages/jest-circus/src/globalErrorHandlers.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type * as Process from 'process';\nimport type { Circus } from '@jest/types';\nexport declare const injectGlobalErrorHandlers: (parentProcess: typeof Process) => Circus.GlobalErrorHandlers;\nexport declare const restoreGlobalErrorHandlers: (parentProcess: typeof Process, originalErrorHandlers: Circus.GlobalErrorHandlers) => void;\n",
  "packages/jest-circus/src/formatNodeAssertErrors.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {AssertionError} from 'assert';\nimport chalk from 'chalk';\nimport type {Circus} from '@jest/types';\nimport {\n  type DiffOptions,\n  diff,\n  printExpected,\n  printReceived,\n} from 'jest-matcher-utils';\nimport {format as prettyFormat} from 'pretty-format';\n\ninterface AssertionErrorWithStack extends AssertionError {\n  stack: string;\n}\n\nconst assertOperatorsMap: Record<string, string> = {\n  '!=': 'notEqual',\n  '!==': 'notStrictEqual',\n  '==': 'equal',\n  '===': 'strictEqual',\n};\n\nconst humanReadableOperators: Record<string, string> = {\n  deepEqual: 'to deeply equal',\n  deepStrictEqual: 'to deeply and strictly equal',\n  equal: 'to be equal',\n  notDeepEqual: 'not to deeply equal',\n  notDeepStrictEqual: 'not to deeply and strictly equal',\n  notEqual: 'to not be equal',\n  notStrictEqual: 'not be strictly equal',\n  strictEqual: 'to strictly be equal',\n};\n\nconst formatNodeAssertErrors = (\n  event: Circus.Event,\n  state: Circus.State,\n): void => {\n  if (event.name === 'test_done') {\n    event.test.errors = event.test.errors.map(errors => {\n      let error;\n      if (Array.isArray(errors)) {\n        const [originalError, asyncError] = errors;\n\n        if (originalError == null) {\n          error = asyncError;\n        } else if (originalError.stack) {\n          error = originalError;\n        } else {\n          error = asyncError;\n\n          error.message =\n            originalError.message ||\n            `thrown: ${prettyFormat(originalError, {maxDepth: 3})}`;\n        }\n      } else {\n        error = errors;\n      }\n      return isAssertionError(error)\n        ? {message: assertionErrorMessage(error, {expand: state.expand})}\n        : errors;\n    });\n  }\n};\n\nconst getOperatorName = (operator: string | undefined, stack: string) => {\n  if (typeof operator === 'string') {\n    return assertOperatorsMap[operator] || operator;\n  }\n  if (stack.match('.doesNotThrow')) {\n    return 'doesNotThrow';\n  }\n  if (stack.match('.throws')) {\n    return 'throws';\n  }\n  return '';\n};\n\nconst operatorMessage = (operator: string | undefined) => {\n  const niceOperatorName = getOperatorName(operator, '');\n  const humanReadableOperator = humanReadableOperators[niceOperatorName];\n\n  return typeof operator === 'string'\n    ? `${humanReadableOperator || niceOperatorName} to:\\n`\n    : '';\n};\n\nconst assertThrowingMatcherHint = (operatorName: string) =>\n  operatorName\n    ? chalk.dim('assert') +\n      chalk.dim(`.${operatorName}(`) +\n      chalk.red('function') +\n      chalk.dim(')')\n    : '';\n\nconst assertMatcherHint = (\n  operator: string | undefined | null,\n  operatorName: string,\n  expected: unknown,\n) => {\n  let message = '';\n\n  if (operator === '==' && expected === true) {\n    message =\n      chalk.dim('assert') +\n      chalk.dim('(') +\n      chalk.red('received') +\n      chalk.dim(')');\n  } else if (operatorName) {\n    message =\n      chalk.dim('assert') +\n      chalk.dim(`.${operatorName}(`) +\n      chalk.red('received') +\n      chalk.dim(', ') +\n      chalk.green('expected') +\n      chalk.dim(')');\n  }\n\n  return message;\n};\n\nfunction assertionErrorMessage(\n  error: AssertionErrorWithStack,\n  options: DiffOptions,\n) {\n  const {expected, actual, generatedMessage, message, operator, stack} = error;\n  const diffString = diff(expected, actual, options);\n  const hasCustomMessage = !generatedMessage;\n  const operatorName = getOperatorName(operator, stack);\n  const trimmedStack = stack\n    .replace(message, '')\n    .replaceAll(/AssertionError(.*)/g, '');\n\n  if (operatorName === 'doesNotThrow') {\n    return (\n      // eslint-disable-next-line prefer-template\n      buildHintString(assertThrowingMatcherHint(operatorName)) +\n      chalk.reset('Expected the function not to throw an error.\\n') +\n      chalk.reset('Instead, it threw:\\n') +\n      `  ${printReceived(actual)}` +\n      chalk.reset(hasCustomMessage ? `\\n\\nMessage:\\n  ${message}` : '') +\n      trimmedStack\n    );\n  }\n\n  if (operatorName === 'throws') {\n    if (error.generatedMessage) {\n      return (\n        buildHintString(assertThrowingMatcherHint(operatorName)) +\n        chalk.reset(error.message) +\n        chalk.reset(hasCustomMessage ? `\\n\\nMessage:\\n  ${message}` : '') +\n        trimmedStack\n      );\n    }\n    return (\n      buildHintString(assertThrowingMatcherHint(operatorName)) +\n      chalk.reset('Expected the function to throw an error.\\n') +\n      chalk.reset(\"But it didn't throw anything.\") +\n      chalk.reset(hasCustomMessage ? `\\n\\nMessage:\\n  ${message}` : '') +\n      trimmedStack\n    );\n  }\n\n  if (operatorName === 'fail') {\n    return (\n      buildHintString(assertMatcherHint(operator, operatorName, expected)) +\n      chalk.reset(hasCustomMessage ? `Message:\\n  ${message}` : '') +\n      trimmedStack\n    );\n  }\n\n  return (\n    // eslint-disable-next-line prefer-template\n    buildHintString(assertMatcherHint(operator, operatorName, expected)) +\n    chalk.reset(`Expected value ${operatorMessage(operator)}`) +\n    `  ${printExpected(expected)}\\n` +\n    chalk.reset('Received:\\n') +\n    `  ${printReceived(actual)}` +\n    chalk.reset(hasCustomMessage ? `\\n\\nMessage:\\n  ${message}` : '') +\n    (diffString ? `\\n\\nDifference:\\n\\n${diffString}` : '') +\n    trimmedStack\n  );\n}\n\nfunction isAssertionError(\n  error: Circus.TestError,\n): error is AssertionErrorWithStack {\n  return (\n    error &&\n    (error instanceof AssertionError ||\n      error.name === AssertionError.name ||\n      error.code === 'ERR_ASSERTION')\n  );\n}\n\nfunction buildHintString(hint: string) {\n  return hint ? `${hint}\\n\\n` : '';\n}\n\nexport default formatNodeAssertErrors;\n",
  "packages/jest-circus/src/formatNodeAssertErrors.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Circus } from '@jest/types';\ndeclare const formatNodeAssertErrors: (event: Circus.Event, state: Circus.State) => void;\nexport default formatNodeAssertErrors;\n",
  "packages/jest-circus/src/eventHandler.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {Circus, Global} from '@jest/types';\nimport {invariant} from 'jest-util';\nimport {\n  injectGlobalErrorHandlers,\n  restoreGlobalErrorHandlers,\n} from './globalErrorHandlers';\nimport {LOG_ERRORS_BEFORE_RETRY, TEST_TIMEOUT_SYMBOL} from './types';\nimport {\n  addErrorToEachTestUnderDescribe,\n  describeBlockHasTests,\n  getTestDuration,\n  makeDescribe,\n  makeTest,\n} from './utils';\n\nconst eventHandler: Circus.EventHandler = (event, state) => {\n  switch (event.name) {\n    case 'include_test_location_in_result': {\n      state.includeTestLocationInResult = true;\n      break;\n    }\n    case 'hook_start': {\n      event.hook.seenDone = false;\n      break;\n    }\n    case 'start_describe_definition': {\n      const {blockName, mode} = event;\n      const {currentDescribeBlock, currentlyRunningTest} = state;\n\n      if (currentlyRunningTest) {\n        currentlyRunningTest.errors.push(\n          new Error(\n            `Cannot nest a describe inside a test. Describe block \"${blockName}\" cannot run because it is nested within \"${currentlyRunningTest.name}\".`,\n          ),\n        );\n        break;\n      }\n\n      const describeBlock = makeDescribe(blockName, currentDescribeBlock, mode);\n      currentDescribeBlock.children.push(describeBlock);\n      state.currentDescribeBlock = describeBlock;\n      break;\n    }\n    case 'finish_describe_definition': {\n      const {currentDescribeBlock} = state;\n      invariant(currentDescribeBlock, 'currentDescribeBlock must be there');\n\n      if (!describeBlockHasTests(currentDescribeBlock)) {\n        for (const hook of currentDescribeBlock.hooks) {\n          hook.asyncError.message = `Invalid: ${hook.type}() may not be used in a describe block containing no tests.`;\n          state.unhandledErrors.push(hook.asyncError);\n        }\n      }\n\n      // pass mode of currentDescribeBlock to tests\n      // but do not when there is already a single test with \"only\" mode\n      const shouldPassMode = !(\n        currentDescribeBlock.mode === 'only' &&\n        currentDescribeBlock.children.some(\n          child => child.type === 'test' && child.mode === 'only',\n        )\n      );\n      if (shouldPassMode) {\n        for (const child of currentDescribeBlock.children) {\n          if (child.type === 'test' && !child.mode) {\n            child.mode = currentDescribeBlock.mode;\n          }\n        }\n      }\n      if (\n        !state.hasFocusedTests &&\n        currentDescribeBlock.mode !== 'skip' &&\n        currentDescribeBlock.children.some(\n          child => child.type === 'test' && child.mode === 'only',\n        )\n      ) {\n        state.hasFocusedTests = true;\n      }\n\n      if (currentDescribeBlock.parent) {\n        state.currentDescribeBlock = currentDescribeBlock.parent;\n      }\n      break;\n    }\n    case 'add_hook': {\n      const {currentDescribeBlock, currentlyRunningTest, hasStarted} = state;\n      const {asyncError, fn, hookType: type, timeout} = event;\n\n      if (currentlyRunningTest) {\n        currentlyRunningTest.errors.push(\n          new Error(\n            `Hooks cannot be defined inside tests. Hook of type \"${type}\" is nested within \"${currentlyRunningTest.name}\".`,\n          ),\n        );\n        break;\n      } else if (hasStarted) {\n        state.unhandledErrors.push(\n          new Error(\n            'Cannot add a hook after tests have started running. Hooks must be defined synchronously.',\n          ),\n        );\n        break;\n      }\n      const parent = currentDescribeBlock;\n\n      currentDescribeBlock.hooks.push({\n        asyncError,\n        fn,\n        parent,\n        seenDone: false,\n        timeout,\n        type,\n      });\n      break;\n    }\n    case 'add_test': {\n      const {currentDescribeBlock, currentlyRunningTest, hasStarted} = state;\n      const {\n        asyncError,\n        fn,\n        mode,\n        testName: name,\n        timeout,\n        concurrent,\n        failing,\n      } = event;\n\n      if (currentlyRunningTest) {\n        currentlyRunningTest.errors.push(\n          new Error(\n            `Tests cannot be nested. Test \"${name}\" cannot run because it is nested within \"${currentlyRunningTest.name}\".`,\n          ),\n        );\n        break;\n      } else if (hasStarted) {\n        state.unhandledErrors.push(\n          new Error(\n            'Cannot add a test after tests have started running. Tests must be defined synchronously.',\n          ),\n        );\n        break;\n      }\n\n      const test = makeTest(\n        fn,\n        mode,\n        concurrent,\n        name,\n        currentDescribeBlock,\n        timeout,\n        asyncError,\n        failing,\n      );\n      if (currentDescribeBlock.mode !== 'skip' && test.mode === 'only') {\n        state.hasFocusedTests = true;\n      }\n      currentDescribeBlock.children.push(test);\n      currentDescribeBlock.tests.push(test);\n      break;\n    }\n    case 'hook_failure': {\n      const {test, describeBlock, error, hook} = event;\n      const {asyncError, type} = hook;\n\n      if (type === 'beforeAll') {\n        invariant(describeBlock, 'always present for `*All` hooks');\n        addErrorToEachTestUnderDescribe(describeBlock, error, asyncError);\n      } else if (type === 'afterAll') {\n        // Attaching `afterAll` errors to each test makes execution flow\n        // too complicated, so we'll consider them to be global.\n        state.unhandledErrors.push([error, asyncError]);\n      } else {\n        invariant(test, 'always present for `*Each` hooks');\n        test.errors.push([error, asyncError]);\n      }\n      break;\n    }\n    case 'test_skip': {\n      event.test.status = 'skip';\n      break;\n    }\n    case 'test_todo': {\n      event.test.status = 'todo';\n      break;\n    }\n    case 'test_done': {\n      event.test.duration = getTestDuration(event.test);\n      event.test.status = 'done';\n      state.currentlyRunningTest = null;\n      break;\n    }\n    case 'test_start': {\n      state.currentlyRunningTest = event.test;\n      event.test.startedAt = Date.now();\n      event.test.invocations += 1;\n      break;\n    }\n    case 'test_fn_start': {\n      event.test.seenDone = false;\n      break;\n    }\n    case 'test_fn_failure': {\n      const {\n        error,\n        test: {asyncError},\n      } = event;\n      event.test.errors.push([error, asyncError]);\n      break;\n    }\n    case 'test_retry': {\n      const logErrorsBeforeRetry: boolean =\n        ((globalThis as Global.Global)[LOG_ERRORS_BEFORE_RETRY] as any) ||\n        false;\n      if (logErrorsBeforeRetry) {\n        event.test.retryReasons.push(...event.test.errors);\n      }\n      event.test.errors = [];\n      break;\n    }\n    case 'run_start': {\n      state.hasStarted = true;\n      if ((globalThis as Global.Global)[TEST_TIMEOUT_SYMBOL]) {\n        state.testTimeout = (globalThis as Global.Global)[\n          TEST_TIMEOUT_SYMBOL\n        ] as number;\n      }\n\n      break;\n    }\n    case 'run_finish': {\n      break;\n    }\n    case 'setup': {\n      // Uncaught exception handlers should be defined on the parent process\n      // object. If defined on the VM's process object they just no op and let\n      // the parent process crash. It might make sense to return a `dispatch`\n      // function to the parent process and register handlers there instead, but\n      // i'm not sure if this is works. For now i just replicated whatever\n      // jasmine was doing -- dabramov\n      state.parentProcess = event.parentProcess;\n      invariant(state.parentProcess);\n      state.originalGlobalErrorHandlers = injectGlobalErrorHandlers(\n        state.parentProcess,\n      );\n      if (event.testNamePattern) {\n        state.testNamePattern = new RegExp(event.testNamePattern, 'i');\n      }\n      break;\n    }\n    case 'teardown': {\n      invariant(state.originalGlobalErrorHandlers);\n      invariant(state.parentProcess);\n      restoreGlobalErrorHandlers(\n        state.parentProcess,\n        state.originalGlobalErrorHandlers,\n      );\n      break;\n    }\n    case 'error': {\n      // It's very likely for long-running async tests to throw errors. In this\n      // case we want to catch them and fail the current test. At the same time\n      // there's a possibility that one test sets a long timeout, that will\n      // eventually throw after this test finishes but during some other test\n      // execution, which will result in one test's error failing another test.\n      // In any way, it should be possible to track where the error was thrown\n      // from.\n      if (state.currentlyRunningTest) {\n        if (event.promise) {\n          state.currentlyRunningTest.unhandledRejectionErrorByPromise.set(\n            event.promise,\n            event.error,\n          );\n        } else {\n          state.currentlyRunningTest.errors.push(event.error);\n        }\n      } else {\n        if (event.promise) {\n          state.unhandledRejectionErrorByPromise.set(\n            event.promise,\n            event.error,\n          );\n        } else {\n          state.unhandledErrors.push(event.error);\n        }\n      }\n      break;\n    }\n    case 'error_handled': {\n      if (state.currentlyRunningTest) {\n        state.currentlyRunningTest.unhandledRejectionErrorByPromise.delete(\n          event.promise,\n        );\n      } else {\n        state.unhandledRejectionErrorByPromise.delete(event.promise);\n      }\n      break;\n    }\n  }\n};\n\nexport default eventHandler;\n",
  "packages/jest-circus/src/eventHandler.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Circus } from '@jest/types';\ndeclare const eventHandler: Circus.EventHandler;\nexport default eventHandler;\n",
  "packages/jest-circus/src/legacy-code-todo-rewrite/jestAdapterInit.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type * as Process from 'process';\nimport type {JestEnvironment} from '@jest/environment';\nimport {type JestExpect, jestExpect} from '@jest/expect';\nimport {\n  type AssertionResult,\n  type Status,\n  type TestFileEvent,\n  type TestResult,\n  createEmptyTestResult,\n} from '@jest/test-result';\nimport type {Circus, Config, Global} from '@jest/types';\nimport {formatExecError, formatResultsErrors} from 'jest-message-util';\nimport type Runtime from 'jest-runtime';\nimport {\n  SnapshotState,\n  addSerializer,\n  buildSnapshotResolver,\n} from 'jest-snapshot';\nimport globals from '..';\nimport run from '../run';\nimport {\n  ROOT_DESCRIBE_BLOCK_NAME,\n  addEventHandler,\n  dispatch,\n  getState as getRunnerState,\n} from '../state';\nimport testCaseReportHandler from '../testCaseReportHandler';\nimport {unhandledRejectionHandler} from '../unhandledRejectionHandler';\nimport {getTestID} from '../utils';\n\ninterface RuntimeGlobals extends Global.TestFrameworkGlobals {\n  expect: JestExpect;\n}\n\nexport const initialize = async ({\n  config,\n  environment,\n  runtime,\n  globalConfig,\n  localRequire,\n  parentProcess,\n  sendMessageToJest,\n  setGlobalsForRuntime,\n  testPath,\n}: {\n  config: Config.ProjectConfig;\n  environment: JestEnvironment;\n  runtime: Runtime;\n  globalConfig: Config.GlobalConfig;\n  localRequire: <T = unknown>(path: string) => T;\n  testPath: string;\n  parentProcess: typeof Process;\n  sendMessageToJest?: TestFileEvent;\n  setGlobalsForRuntime: (globals: RuntimeGlobals) => void;\n}): Promise<{\n  globals: Global.TestFrameworkGlobals;\n  snapshotState: SnapshotState;\n}> => {\n  if (globalConfig.testTimeout) {\n    getRunnerState().testTimeout = globalConfig.testTimeout;\n  }\n  getRunnerState().maxConcurrency = globalConfig.maxConcurrency;\n\n  getRunnerState().randomize = globalConfig.randomize;\n  getRunnerState().seed = globalConfig.seed;\n\n  // @ts-expect-error: missing `concurrent` which is added later\n  const globalsObject: Global.TestFrameworkGlobals = {\n    ...globals,\n    fdescribe: globals.describe.only,\n    fit: globals.it.only,\n    xdescribe: globals.describe.skip,\n    xit: globals.it.skip,\n    xtest: globals.it.skip,\n  };\n\n  addEventHandler(eventHandler);\n\n  if (environment.handleTestEvent) {\n    addEventHandler(environment.handleTestEvent.bind(environment));\n  }\n\n  jestExpect.setState({expand: globalConfig.expand});\n\n  const runtimeGlobals: RuntimeGlobals = {\n    ...globalsObject,\n    expect: jestExpect,\n  };\n  setGlobalsForRuntime(runtimeGlobals);\n\n  if (config.injectGlobals) {\n    Object.assign(environment.global, runtimeGlobals);\n  }\n\n  await dispatch({\n    name: 'setup',\n    parentProcess,\n    runtimeGlobals,\n    testNamePattern: globalConfig.testNamePattern,\n  });\n\n  if (config.testLocationInResults) {\n    await dispatch({name: 'include_test_location_in_result'});\n  }\n\n  // Jest tests snapshotSerializers in order preceding built-in serializers.\n  // Therefore, add in reverse because the last added is the first tested.\n  for (const path of [...config.snapshotSerializers].reverse())\n    addSerializer(localRequire(path));\n\n  const snapshotResolver = await buildSnapshotResolver(config, localRequire);\n  const snapshotPath = snapshotResolver.resolveSnapshotPath(testPath);\n  const snapshotState = new SnapshotState(snapshotPath, {\n    expand: globalConfig.expand,\n    prettierPath: config.prettierPath,\n    rootDir: config.rootDir,\n    snapshotFormat: config.snapshotFormat,\n    updateSnapshot: globalConfig.updateSnapshot,\n  });\n\n  jestExpect.setState({snapshotState, testPath});\n\n  addEventHandler(handleSnapshotStateAfterRetry(snapshotState));\n  if (sendMessageToJest) {\n    addEventHandler(testCaseReportHandler(testPath, sendMessageToJest));\n  }\n\n  addEventHandler(\n    unhandledRejectionHandler(runtime, globalConfig.waitForUnhandledRejections),\n  );\n\n  // Return it back to the outer scope (test runner outside the VM).\n  return {globals: globalsObject, snapshotState};\n};\n\nexport const runAndTransformResultsToJestFormat = async ({\n  config,\n  globalConfig,\n  setupAfterEnvPerfStats,\n  testPath,\n}: {\n  config: Config.ProjectConfig;\n  globalConfig: Config.GlobalConfig;\n  testPath: string;\n  setupAfterEnvPerfStats: Config.SetupAfterEnvPerfStats;\n}): Promise<TestResult> => {\n  const runResult: Circus.RunResult = await run();\n\n  let numFailingTests = 0;\n  let numPassingTests = 0;\n  let numPendingTests = 0;\n  let numTodoTests = 0;\n\n  const assertionResults: Array<AssertionResult> = runResult.testResults.map(\n    testResult => {\n      let status: Status;\n      if (testResult.status === 'skip') {\n        status = 'pending';\n        numPendingTests += 1;\n      } else if (testResult.status === 'todo') {\n        status = 'todo';\n        numTodoTests += 1;\n      } else if (testResult.errors.length > 0) {\n        status = 'failed';\n        numFailingTests += 1;\n      } else {\n        status = 'passed';\n        numPassingTests += 1;\n      }\n\n      const ancestorTitles = testResult.testPath.filter(\n        name => name !== ROOT_DESCRIBE_BLOCK_NAME,\n      );\n      const title = ancestorTitles.pop();\n\n      return {\n        ancestorTitles,\n        duration: testResult.duration,\n        failing: testResult.failing,\n        failureDetails: testResult.errorsDetailed,\n        failureMessages: testResult.errors,\n        fullName: title\n          ? [...ancestorTitles, title].join(' ')\n          : ancestorTitles.join(' '),\n        invocations: testResult.invocations,\n        location: testResult.location,\n        numPassingAsserts: testResult.numPassingAsserts,\n        retryReasons: testResult.retryReasons,\n        startAt: testResult.startedAt,\n        status,\n        title: testResult.testPath.at(-1)!,\n      };\n    },\n  );\n\n  let failureMessage = formatResultsErrors(\n    assertionResults,\n    config,\n    globalConfig,\n    testPath,\n  );\n  let testExecError;\n\n  if (runResult.unhandledErrors.length > 0) {\n    testExecError = {\n      message: '',\n      stack: runResult.unhandledErrors.join('\\n'),\n    };\n    failureMessage = `${failureMessage || ''}\\n\\n${runResult.unhandledErrors\n      .map(err => formatExecError(err, config, globalConfig))\n      .join('\\n')}`;\n  }\n\n  await dispatch({name: 'teardown'});\n\n  const emptyTestResult = createEmptyTestResult();\n\n  return {\n    ...emptyTestResult,\n    console: undefined,\n    displayName: config.displayName,\n    failureMessage,\n    numFailingTests,\n    numPassingTests,\n    numPendingTests,\n    numTodoTests,\n    perfStats: {\n      ...emptyTestResult.perfStats,\n      ...setupAfterEnvPerfStats,\n    },\n    testExecError,\n    testFilePath: testPath,\n    testResults: assertionResults,\n  };\n};\n\nconst handleSnapshotStateAfterRetry =\n  (snapshotState: SnapshotState) => (event: Circus.Event) => {\n    switch (event.name) {\n      case 'test_retry': {\n        // Clear any snapshot data that occurred in previous test run\n        snapshotState.clear();\n      }\n    }\n  };\n\n// Exported for direct access from unit tests.\nexport const eventHandler = async (event: Circus.Event): Promise<void> => {\n  switch (event.name) {\n    case 'test_start': {\n      jestExpect.setState({\n        currentTestName: getTestID(event.test),\n        testFailing: event.test.failing,\n      });\n      break;\n    }\n    case 'test_done': {\n      event.test.numPassingAsserts = jestExpect.getState().numPassingAsserts;\n      _addSuppressedErrors(event.test);\n      _addExpectedAssertionErrors(event.test);\n      break;\n    }\n  }\n};\n\nconst _addExpectedAssertionErrors = (test: Circus.TestEntry) => {\n  const {isExpectingAssertions} = jestExpect.getState();\n  const failures = jestExpect.extractExpectedAssertionsErrors();\n  if (isExpectingAssertions && test.errors.length > 0) {\n    // Only show errors from `expect.hasAssertions()` when no other failure has happened.\n    return;\n  }\n  test.errors.push(...failures.map(failure => failure.error));\n};\n\n// Get suppressed errors from ``jest-matchers`` that weren't throw during\n// test execution and add them to the test result, potentially failing\n// a passing test.\nconst _addSuppressedErrors = (test: Circus.TestEntry) => {\n  const {suppressedErrors} = jestExpect.getState();\n  jestExpect.setState({suppressedErrors: []});\n  if (suppressedErrors.length > 0) {\n    test.errors.push(...suppressedErrors);\n  }\n};\n",
  "packages/jest-circus/src/legacy-code-todo-rewrite/jestAdapterInit.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type * as Process from 'process';\nimport type { JestEnvironment } from '@jest/environment';\nimport { type JestExpect } from '@jest/expect';\nimport { type TestFileEvent, type TestResult } from '@jest/test-result';\nimport type { Circus, Config, Global } from '@jest/types';\nimport type Runtime from 'jest-runtime';\nimport { SnapshotState } from 'jest-snapshot';\ninterface RuntimeGlobals extends Global.TestFrameworkGlobals {\n    expect: JestExpect;\n}\nexport declare const initialize: ({ config, environment, runtime, globalConfig, localRequire, parentProcess, sendMessageToJest, setGlobalsForRuntime, testPath, }: {\n    config: Config.ProjectConfig;\n    environment: JestEnvironment;\n    runtime: Runtime;\n    globalConfig: Config.GlobalConfig;\n    localRequire: <T = unknown>(path: string) => T;\n    testPath: string;\n    parentProcess: typeof Process;\n    sendMessageToJest?: TestFileEvent;\n    setGlobalsForRuntime: (globals: RuntimeGlobals) => void;\n}) => Promise<{\n    globals: Global.TestFrameworkGlobals;\n    snapshotState: SnapshotState;\n}>;\nexport declare const runAndTransformResultsToJestFormat: ({ config, globalConfig, setupAfterEnvPerfStats, testPath, }: {\n    config: Config.ProjectConfig;\n    globalConfig: Config.GlobalConfig;\n    testPath: string;\n    setupAfterEnvPerfStats: Config.SetupAfterEnvPerfStats;\n}) => Promise<TestResult>;\nexport declare const eventHandler: (event: Circus.Event) => Promise<void>;\nexport {};\n",
  "packages/jest-circus/src/legacy-code-todo-rewrite/jestAdapter.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {JestEnvironment} from '@jest/environment';\nimport type {TestFileEvent, TestResult} from '@jest/test-result';\nimport type {Config} from '@jest/types';\nimport type Runtime from 'jest-runtime';\nimport type {SnapshotState} from 'jest-snapshot';\nimport {deepCyclicCopy} from 'jest-util';\n\nconst FRAMEWORK_INITIALIZER = require.resolve('./jestAdapterInit');\n\nconst jestAdapter = async (\n  globalConfig: Config.GlobalConfig,\n  config: Config.ProjectConfig,\n  environment: JestEnvironment,\n  runtime: Runtime,\n  testPath: string,\n  sendMessageToJest?: TestFileEvent,\n): Promise<TestResult> => {\n  const {initialize, runAndTransformResultsToJestFormat} =\n    runtime.requireInternalModule<typeof import('./jestAdapterInit')>(\n      FRAMEWORK_INITIALIZER,\n    );\n\n  const {globals, snapshotState} = await initialize({\n    config,\n    environment,\n    globalConfig,\n    localRequire: runtime.requireModule.bind(runtime),\n    parentProcess: process,\n    runtime,\n    sendMessageToJest,\n    setGlobalsForRuntime: runtime.setGlobalsForRuntime.bind(runtime),\n    testPath,\n  });\n\n  if (config.fakeTimers.enableGlobally) {\n    if (config.fakeTimers.legacyFakeTimers) {\n      // during setup, this cannot be null (and it's fine to explode if it is)\n      environment.fakeTimers!.useFakeTimers();\n    } else {\n      environment.fakeTimersModern!.useFakeTimers();\n    }\n  }\n\n  globals.beforeEach(() => {\n    if (config.resetModules) {\n      runtime.resetModules();\n    }\n\n    if (config.clearMocks) {\n      runtime.clearAllMocks();\n    }\n\n    if (config.resetMocks) {\n      runtime.resetAllMocks();\n\n      if (\n        config.fakeTimers.enableGlobally &&\n        config.fakeTimers.legacyFakeTimers\n      ) {\n        // during setup, this cannot be null (and it's fine to explode if it is)\n        environment.fakeTimers!.useFakeTimers();\n      }\n    }\n\n    if (config.restoreMocks) {\n      runtime.restoreAllMocks();\n    }\n  });\n\n  const setupAfterEnvStart = Date.now();\n  for (const path of config.setupFilesAfterEnv) {\n    const esm = runtime.unstable_shouldLoadAsEsm(path);\n\n    if (esm) {\n      await runtime.unstable_importModule(path);\n    } else {\n      const setupFile = runtime.requireModule(path);\n      if (typeof setupFile === 'function') {\n        await setupFile();\n      }\n    }\n  }\n  const setupAfterEnvEnd = Date.now();\n  const esm = runtime.unstable_shouldLoadAsEsm(testPath);\n\n  if (esm) {\n    await runtime.unstable_importModule(testPath);\n  } else {\n    runtime.requireModule(testPath);\n  }\n\n  const setupAfterEnvPerfStats = {\n    setupAfterEnvEnd,\n    setupAfterEnvStart,\n  };\n\n  const results = await runAndTransformResultsToJestFormat({\n    config,\n    globalConfig,\n    setupAfterEnvPerfStats,\n    testPath,\n  });\n\n  _addSnapshotData(results, snapshotState);\n\n  // We need to copy the results object to ensure we don't leaks the prototypes\n  // from the VM. Jasmine creates the result objects in the parent process, we\n  // should consider doing that for circus as well.\n  return deepCyclicCopy(results, {keepPrototype: false});\n};\n\nconst _addSnapshotData = (\n  results: TestResult,\n  snapshotState: SnapshotState,\n) => {\n  for (const {fullName, status, failing} of results.testResults) {\n    if (\n      status === 'pending' ||\n      status === 'failed' ||\n      (failing && status === 'passed')\n    ) {\n      // If test is skipped or failed, we don't want to mark\n      // its snapshots as obsolete.\n      // When tests called with test.failing pass, they've thrown an exception,\n      // so maintain any snapshots after the error.\n      snapshotState.markSnapshotsAsCheckedForTest(fullName);\n    }\n  }\n\n  const uncheckedCount = snapshotState.getUncheckedCount();\n  const uncheckedKeys = snapshotState.getUncheckedKeys();\n  if (uncheckedCount) {\n    snapshotState.removeUncheckedKeys();\n  }\n\n  const status = snapshotState.save();\n  results.snapshot.fileDeleted = status.deleted;\n  results.snapshot.added = snapshotState.added;\n  results.snapshot.matched = snapshotState.matched;\n  results.snapshot.unmatched = snapshotState.unmatched;\n  results.snapshot.updated = snapshotState.updated;\n  results.snapshot.unchecked = status.deleted ? 0 : uncheckedCount;\n  // Copy the array to prevent memory leaks\n  results.snapshot.uncheckedKeys = [...uncheckedKeys];\n};\n\nexport default jestAdapter;\n",
  "packages/jest-circus/src/legacy-code-todo-rewrite/jestAdapter.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { JestEnvironment } from '@jest/environment';\nimport type { TestFileEvent, TestResult } from '@jest/test-result';\nimport type { Config } from '@jest/types';\nimport type Runtime from 'jest-runtime';\ndeclare const jestAdapter: (globalConfig: Config.GlobalConfig, config: Config.ProjectConfig, environment: JestEnvironment, runtime: Runtime, testPath: string, sendMessageToJest?: TestFileEvent) => Promise<TestResult>;\nexport default jestAdapter;\n",
  "packages/jest-circus/src/legacy-code-todo-rewrite/__tests__/jestAdapterInit.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {beforeEach, it} from '@jest/globals';\nimport type {Circus} from '@jest/types';\nimport {eventHandler} from '../jestAdapterInit';\n\nbeforeEach(() => expect.hasAssertions());\n\nit(\"pushes a hasAssertion() error if there's no assertions/errors\", () => {\n  const event: Circus.Event = {\n    name: 'test_done',\n    test: {errors: []} as unknown as Circus.TestEntry,\n  };\n  const beforeLength = event.test.errors.length;\n\n  eventHandler(event);\n\n  expect(event.test.errors).toHaveLength(beforeLength + 1);\n  expect(event.test.errors).toEqual([\n    expect.getState().isExpectingAssertionsError,\n  ]);\n});\n\nit(\"omits hasAssertion() errors if there's already an error\", () => {\n  const errors = [new Error('ruh roh'), new Error('not good')];\n  const event: Circus.Event = {\n    name: 'test_done',\n    test: {errors} as unknown as Circus.TestEntry,\n  };\n  const beforeLength = event.test.errors.length;\n\n  eventHandler(event);\n\n  expect(event.test.errors).toHaveLength(beforeLength);\n  expect(event.test.errors).not.toContain(\n    expect.getState().isExpectingAssertionsError,\n  );\n\n  // Ensure test state is not accidentally leaked by e.g. not calling extractExpectedAssertionsErrors() at all.\n  expect(expect.getState().isExpectingAssertions).toBe(false);\n});\n",
  "packages/jest-circus/src/legacy-code-todo-rewrite/__tests__/jestAdapterInit.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-circus/src/__tests__/utils.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {runTest} from '../__mocks__/testUtils';\n\ntest('makeTestResults does not thrown a stack overflow exception', () => {\n  let testString = 'describe(\"top level describe\", () => {';\n  const numberOfTestBlocks = 150_000;\n  let currentTestIndex = 0;\n\n  while (currentTestIndex < numberOfTestBlocks) {\n    testString += `test(\"should do something #${currentTestIndex++}\", () => {});`;\n  }\n\n  testString += '})';\n\n  const {stdout} = runTest(testString);\n\n  expect(stdout.split('\\n')).toHaveLength(900_010);\n});\n",
  "packages/jest-circus/src/__tests__/utils.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-circus/src/__tests__/shuffleArray.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport shuffleArray, {rngBuilder} from '../shuffleArray';\n\ndescribe('rngBuilder', () => {\n  // Breaking these orders would be a breaking change\n  // Some people will be using seeds relying on a particular order\n  test.each([1, 2, 4, 8, 16])('creates a randomizer given seed %s', seed => {\n    const rng = rngBuilder(seed);\n    const results = Array.from({length: 10}).map(() => rng.next(0, 10));\n    expect(results).toMatchSnapshot();\n  });\n});\n\ndescribe('shuffleArray', () => {\n  test('empty array is shuffled', () => {\n    const shuffled = shuffleArray([], rngBuilder(seed));\n    expect(shuffled).toEqual([]);\n  });\n\n  // Breaking these orders would be a breaking change\n  // Some people will be using seeds relying on a particular order\n  const seed = 321;\n  test.each([[['a']], [['a', 'b']], [['a', 'b', 'c']], [['a', 'b', 'c', 'd']]])(\n    'shuffles list %p',\n    l => {\n      expect(shuffleArray(l, rngBuilder(seed))).toMatchSnapshot();\n    },\n  );\n});\n",
  "packages/jest-circus/src/__tests__/shuffleArray.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-circus/src/__tests__/randomizeTest.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {runTest} from '../__mocks__/testUtils';\n\ntest('simple test', () => {\n  const {stdout} = runTest(\n    `\n    describe('describe', () => {\n      beforeEach(() => {});\n      afterEach(() => {});\n      test('one', () => {});\n      test('two', () => {});\n    })\n  `,\n    {randomize: true, seed: 3},\n  );\n\n  expect(stdout).toMatchSnapshot();\n});\n\ntest('function descriptors', () => {\n  const {stdout} = runTest(\n    `\n    describe(function describer() {}, () => {\n      test(class One {}, () => {});\n    })\n  `,\n    {randomize: true, seed: 3},\n  );\n\n  expect(stdout).toMatchSnapshot();\n});\n\ntest('failures', () => {\n  const {stdout} = runTest(\n    `\n    describe('describe', () => {\n      beforeEach(() => {});\n      afterEach(() => { throw new Error('banana')});\n      test('one', () => { throw new Error('kentucky')});\n      test('two', () => {});\n    })\n  `,\n    {randomize: true, seed: 3},\n  );\n\n  expect(stdout).toMatchSnapshot();\n});\n",
  "packages/jest-circus/src/__tests__/randomizeTest.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-circus/src/__tests__/hooksError.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport circus from '../';\n\ndescribe.each(['beforeEach', 'beforeAll', 'afterEach', 'afterAll'] as const)(\n  '%s hooks error throwing',\n  fn => {\n    test.each(['String', 1, [], {}, Symbol('hello'), true, null, undefined])(\n      `${fn} throws an error when %p is provided as a first argument to it`,\n      el => {\n        expect(() => {\n          // @ts-expect-error: Testing runtime errors here\n          circus[fn](el);\n        }).toThrow('Invalid first argument. It must be a callback function.');\n      },\n    );\n  },\n);\n",
  "packages/jest-circus/src/__tests__/hooksError.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-circus/src/__tests__/hooks.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {runTest} from '../__mocks__/testUtils';\n\ntest('beforeEach is executed before each test in current/child describe blocks', () => {\n  const {stdout} = runTest(`\n    describe('describe', () => {\n      beforeEach(() => console.log('> describe beforeEach'));\n      test('one', () => {});\n      test('two', () => {});\n      describe('2nd level describe', () => {\n        beforeEach(() => console.log('> 2nd level describe beforeEach'));\n        test('2nd level test', () => {});\n\n        describe('3rd level describe', () => {\n          test('3rd level test', () => {});\n          test('3rd level test#2', () => {});\n        });\n      });\n    })\n\n    describe('2nd describe', () => {\n      beforeEach(() => {\n        console.log('> 2nd describe beforeEach that throws')\n        throw new Error('alabama');\n      });\n      test('2nd describe test', () => {});\n    })\n  `);\n\n  expect(stdout).toMatchSnapshot();\n});\n\ntest('multiple before each hooks in one describe are executed in the right order', () => {\n  const {stdout} = runTest(`\n    describe('describe 1', () => {\n      beforeEach(() => {\n        console.log('before each 1');\n      });\n      beforeEach(() => {\n        console.log('before each 2');\n      });\n\n      describe('2nd level describe', () => {\n        test('test', () => {});\n      });\n    });\n  `);\n\n  expect(stdout).toMatchSnapshot();\n});\n\ntest('beforeAll is executed correctly', () => {\n  const {stdout} = runTest(`\n    describe('describe 1', () => {\n      beforeAll(() => console.log('> beforeAll 1'));\n      test('test 1', () => console.log('> test 1'));\n\n      describe('2nd level describe', () => {\n        beforeAll(() => console.log('> beforeAll 2'));\n        test('test 2', () => console.log('> test 2'));\n        test('test 3', () => console.log('> test 3'));\n      });\n    });\n  `);\n\n  expect(stdout).toMatchSnapshot();\n});\n",
  "packages/jest-circus/src/__tests__/hooks.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-circus/src/__tests__/eventHandler.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// addEventHandler and removeEventHandler are provided in the ./index\nimport {addEventHandler, removeEventHandler} from '../index';\n// dispatch comes from the ./state\nimport {dispatch} from '../state';\n\ntest('addEventHandler and removeEventHandler control handlers', async () => {\n  const spy: any = jest.fn();\n\n  addEventHandler(spy);\n  expect(spy).not.toHaveBeenCalledWith({name: 'unknown1'}, expect.anything());\n  await dispatch({name: 'unknown1' as any});\n  expect(spy).toHaveBeenCalledWith({name: 'unknown1'}, expect.anything());\n\n  removeEventHandler(spy);\n  expect(spy).not.toHaveBeenCalledWith({name: 'unknown2'}, expect.anything());\n  await dispatch({name: 'unknown2' as any});\n  expect(spy).not.toHaveBeenCalledWith({name: 'unknown2'}, expect.anything());\n});\n",
  "packages/jest-circus/src/__tests__/eventHandler.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-circus/src/__tests__/circusItTodoTestError.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {Global} from '@jest/types';\n\n// Alias of `it` to avoid collision with global testing APIs.\nlet circusIt: Global.It;\n\nconst aliasCircusIt = () => {\n  const {it} = require('../') as typeof import('../');\n  circusIt = it;\n};\n\naliasCircusIt();\n\ndescribe('test/it.todo error throwing', () => {\n  it('todo throws error when given no arguments', () => {\n    expect(() => {\n      // @ts-expect-error: Testing runtime errors here\n      circusIt.todo();\n    }).toThrow('Todo must be called with only a description.');\n  });\n  it('todo throws error when given more than one argument', () => {\n    expect(() => {\n      // @ts-expect-error: Testing runtime errors here\n      circusIt.todo('test1', () => {});\n    }).toThrow('Todo must be called with only a description.');\n  });\n  it('todo throws error when given none string description', () => {\n    expect(() => {\n      circusIt.todo(() => {});\n    }).toThrow('Todo must be called with only a description.');\n  });\n});\n",
  "packages/jest-circus/src/__tests__/circusItTodoTestError.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-circus/src/__tests__/circusItTestError.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {Global} from '@jest/types';\n\n// Aliases of `it` and `test` to avoid collision with global testing APIs.\nlet circusIt: Global.It;\nlet circusTest: Global.It;\n\nconst aliasCircusIt = () => {\n  const {it, test} = require('../') as typeof import('../');\n  circusIt = it;\n  circusTest = test;\n};\n\naliasCircusIt();\n\ndescribe('test/it error throwing', () => {\n  it(\"it doesn't throw an error with valid arguments\", () => {\n    expect(() => {\n      circusIt('test1', () => {});\n    }).not.toThrow();\n  });\n  it('it throws error with missing callback function', () => {\n    expect(() => {\n      // @ts-expect-error: Easy, we're testing runtime errors here\n      circusIt('test2');\n    }).toThrow(\n      'Missing second argument. It must be a callback function. Perhaps you want to use `test.todo` for a test placeholder.',\n    );\n  });\n  it(\"it throws an error when first argument isn't valid\", () => {\n    expect(() => {\n      // @ts-expect-error: Easy, we're testing runtime errors here\n      circusIt(() => {});\n    }).toThrow(\n      'Invalid first argument, () => {}. It must be a named class, named function, number, or string.',\n    );\n  });\n  it('it throws an error when callback function is not a function', () => {\n    expect(() => {\n      // @ts-expect-error: Easy, we're testing runtime errors here\n      circusIt('test4', 'test4b');\n    }).toThrow(\n      'Invalid second argument, test4b. It must be a callback function.',\n    );\n  });\n  it(\"test doesn't throw an error with valid arguments\", () => {\n    expect(() => {\n      circusTest('test5', () => {});\n    }).not.toThrow();\n  });\n  it('test throws error with missing callback function', () => {\n    expect(() => {\n      // @ts-expect-error: Easy, we're testing runtime errors here\n      circusTest('test6');\n    }).toThrow(\n      'Missing second argument. It must be a callback function. Perhaps you want to use `test.todo` for a test placeholder.',\n    );\n  });\n  it(\"test throws an error when first argument isn't a string\", () => {\n    expect(() => {\n      // @ts-expect-error: Easy, we're testing runtime errors here\n      circusTest(() => {});\n    }).toThrow(\n      'Invalid first argument, () => {}. It must be a named class, named function, number, or string.',\n    );\n  });\n  it('test throws an error when callback function is not a function', () => {\n    expect(() => {\n      // @ts-expect-error: Easy, we're testing runtime errors here\n      circusTest('test8', 'test8b');\n    }).toThrow(\n      'Invalid second argument, test8b. It must be a callback function.',\n    );\n  });\n});\n",
  "packages/jest-circus/src/__tests__/circusItTestError.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-circus/src/__tests__/circusItFailingTestError.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {Global} from '@jest/types';\n\n// Aliases of `it` and `test` to avoid collision with global testing APIs.\nlet circusIt: Global.It;\nlet circusTest: Global.It;\n\nconst aliasCircusIt = () => {\n  const {it, test} = require('../') as typeof import('../');\n  circusIt = it;\n  circusTest = test;\n};\n\naliasCircusIt();\n\ndescribe('test/it.failing error throwing', () => {\n  it(\"it doesn't throw an error with valid arguments\", () => {\n    expect(() => {\n      circusIt.failing('test1', () => {});\n    }).not.toThrow();\n  });\n  it('it throws error with missing callback function', () => {\n    expect(() => {\n      // @ts-expect-error: Testing runtime errors here\n      circusIt.failing('test2');\n    }).toThrow(\n      'Missing second argument. It must be a callback function. Perhaps you want to use `test.todo` for a test placeholder.',\n    );\n  });\n  it(\"it throws an error when first argument isn't valid\", () => {\n    expect(() => {\n      // @ts-expect-error: Testing runtime errors here\n      circusIt.failing(() => {});\n    }).toThrow(\n      'Invalid first argument, () => {}. It must be a named class, named function, number, or string.',\n    );\n  });\n  it('it throws an error when callback function is not a function', () => {\n    expect(() => {\n      // @ts-expect-error: Testing runtime errors here\n      circusIt.failing('test4', 'test4b');\n    }).toThrow(\n      'Invalid second argument, test4b. It must be a callback function.',\n    );\n  });\n  it('test throws error with missing callback function', () => {\n    expect(() => {\n      // @ts-expect-error: Testing runtime errors here\n      circusTest.failing('test5');\n    }).toThrow(\n      'Missing second argument. It must be a callback function. Perhaps you want to use `test.todo` for a test placeholder.',\n    );\n  });\n  it(\"test throws an error when first argument isn't a string\", () => {\n    expect(() => {\n      // @ts-expect-error: Testing runtime errors here\n      circusTest.failing(() => {});\n    }).toThrow(\n      'Invalid first argument, () => {}. It must be a named class, named function, number, or string.',\n    );\n  });\n  it('test throws an error when callback function is not a function', () => {\n    expect(() => {\n      // @ts-expect-error: Testing runtime errors here\n      circusTest.failing('test7', 'test8b');\n    }).toThrow(\n      'Invalid second argument, test8b. It must be a callback function.',\n    );\n  });\n});\n",
  "packages/jest-circus/src/__tests__/circusItFailingTestError.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-circus/src/__tests__/baseTest.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {runTest} from '../__mocks__/testUtils';\n\ntest('simple test', () => {\n  const {stdout} = runTest(`\n    describe('describe', () => {\n      beforeEach(() => {});\n      afterEach(() => {});\n      test('one', () => {});\n      test('two', () => {});\n    })\n  `);\n\n  expect(stdout).toMatchSnapshot();\n});\n\ntest('function descriptors', () => {\n  const {stdout} = runTest(`\n    describe(function describer() {}, () => {\n      test(class One {}, () => {});\n    })\n  `);\n\n  expect(stdout).toMatchSnapshot();\n});\n\ntest('failures', () => {\n  const {stdout} = runTest(`\n    describe('describe', () => {\n      beforeEach(() => {});\n      afterEach(() => { throw new Error('banana')});\n      test('one', () => { throw new Error('kentucky')});\n      test('two', () => {});\n    })\n  `);\n\n  expect(stdout).toMatchSnapshot();\n});\n\ntest('concurrent', () => {\n  const {stdout} = runTest(`\n    describe('describe', () => {\n      beforeEach(() => {});\n      afterEach(() => { throw new Error('banana')});\n      test.concurrent('one', () => { \n        console.log('hello one');\n        throw new Error('kentucky')\n      });\n      test.concurrent('two', () => {\n        console.log('hello two');\n      });\n      test.concurrent('three', async () => { \n        console.log('hello three');\n        await Promise.resolve(); \n      });\n    })\n  `);\n\n  expect(stdout).toMatchSnapshot();\n});\n\ntest('concurrent.each', () => {\n  const {stdout} = runTest(`\n    describe('describe', () => {\n      beforeEach(() => {});\n      afterEach(() => { throw new Error('banana')});\n      test.concurrent.each([\n        ['one'],\n        ['two'],\n        ['three'],\n      ])('%s', async (name) => {\n        console.log('hello %s', name);\n        await Promise.resolve(); \n      });\n    })\n  `);\n\n  expect(stdout).toMatchSnapshot();\n});\n",
  "packages/jest-circus/src/__tests__/baseTest.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-circus/src/__tests__/afterAll.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {runTest} from '../__mocks__/testUtils';\n\ntest('tests are not marked done until their parent afterAll runs', () => {\n  const {stdout} = runTest(`\n    describe('describe', () => {\n      afterAll(() => {});\n      test('one', () => {});\n      test('two', () => {});\n      describe('2nd level describe', () => {\n        afterAll(() => {});\n        test('2nd level test', () => {});\n\n        describe('3rd level describe', () => {\n          test('3rd level test', () => {});\n          test('3rd level test#2', () => {});\n        });\n      });\n    })\n\n    describe('2nd describe', () => {\n      afterAll(() => { throw new Error('alabama'); });\n      test('2nd describe test', () => {});\n    })\n  `);\n\n  expect(stdout).toMatchSnapshot();\n});\n\ntest('describe block cannot have hooks and no tests', () => {\n  const result = runTest(`\n    describe('describe', () => {\n      afterEach(() => {});\n      beforeEach(() => {});\n      afterAll(() => {});\n      beforeAll(() => {});\n    })\n  `);\n\n  expect(result.stdout).toMatchSnapshot();\n});\n\ntest('describe block _can_ have hooks if a child describe block has tests', () => {\n  const result = runTest(`\n    describe('describe', () => {\n      afterEach(() => console.log('> afterEach'));\n      beforeEach(() => console.log('> beforeEach'));\n      afterAll(() => console.log('> afterAll'));\n      beforeAll(() => console.log('> beforeAll'));\n      describe('child describe', () => {\n        test('my test', () => console.log('> my test'));\n      })\n    })\n  `);\n  expect(result.stdout).toMatchSnapshot();\n});\n\ntest('describe block hooks must not run if describe block is skipped', () => {\n  const result = runTest(`\n    describe.skip('describe', () => {\n      afterAll(() => console.log('> afterAll'));\n      beforeAll(() => console.log('> beforeAll'));\n      test('my test', () => console.log('> my test'));\n    })\n  `);\n  expect(result.stdout).toMatchSnapshot();\n});\n\ntest('child tests marked with todo should not run if describe block is skipped', () => {\n  const result = runTest(`\n    describe.skip('describe', () => {\n      afterAll(() => console.log('> afterAll'));\n      beforeAll(() => console.log('> beforeAll'));\n      test.todo('my test');\n    })\n  `);\n  expect(result.stdout).toMatchSnapshot();\n});\n\ntest('child tests marked with only should not run if describe block is skipped', () => {\n  const result = runTest(`\n    describe.skip('describe', () => {\n      afterAll(() => console.log('> afterAll'));\n      beforeAll(() => console.log('> beforeAll'));\n      test.only('my test', () => console.log('> my test'));\n    })\n  `);\n  expect(result.stdout).toMatchSnapshot();\n});\n",
  "packages/jest-circus/src/__tests__/afterAll.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/jest-circus/src/__mocks__/testUtils.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {sync as spawnSync} from 'execa';\nimport * as fs from 'graceful-fs';\nimport tempy from 'tempy';\n\nconst CIRCUS_PATH = require.resolve('../').replaceAll('\\\\', '\\\\\\\\');\nconst CIRCUS_RUN_PATH = require.resolve('../run').replaceAll('\\\\', '\\\\\\\\');\nconst CIRCUS_STATE_PATH = require.resolve('../state').replaceAll('\\\\', '\\\\\\\\');\nconst TEST_EVENT_HANDLER_PATH = require\n  .resolve('./testEventHandler')\n  .replaceAll('\\\\', '\\\\\\\\');\nconst BABEL_REGISTER_PATH = require\n  .resolve('@babel/register')\n  .replaceAll('\\\\', '\\\\\\\\');\n\nexport const runTest = (\n  source: string,\n  opts?: {seed?: number; randomize?: boolean},\n) => {\n  const tmpFilename = tempy.file();\n\n  const content = `\n    require('${BABEL_REGISTER_PATH}')({extensions: [\".js\", \".ts\"]});\n    const circus = require('${CIRCUS_PATH}');\n    global.test = circus.test;\n    global.describe = circus.describe;\n    global.beforeEach = circus.beforeEach;\n    global.afterEach = circus.afterEach;\n    global.beforeAll = circus.beforeAll;\n    global.afterAll = circus.afterAll;\n\n    const testEventHandler = require('${TEST_EVENT_HANDLER_PATH}').default;\n    const {addEventHandler, removeEventHandler, getState} = require('${CIRCUS_STATE_PATH}');\n    getState().randomize = ${opts?.randomize};\n    getState().seed = ${opts?.seed ?? 0};\n    addEventHandler(testEventHandler);\n\n    ${source};\n\n    const run = require('${CIRCUS_RUN_PATH}').default;\n\n    run();\n  `;\n\n  fs.writeFileSync(tmpFilename, content);\n  const result = spawnSync('node', [tmpFilename], {\n    cwd: process.cwd(),\n  });\n\n  if (result.exitCode !== 0) {\n    const message = `\n      STDOUT: ${result.stdout && result.stdout.toString()}\n      STDERR: ${result.stderr && result.stderr.toString()}\n      STATUS: ${result.exitCode}\n    `;\n    throw new Error(message);\n  }\n\n  fs.rmSync(tmpFilename, {force: true});\n\n  if (result.stderr) {\n    throw new Error(\n      `\n      Unexpected stderr:\n      ${result.stderr}\n    `,\n    );\n  }\n  return result;\n};\n",
  "packages/jest-circus/src/__mocks__/testUtils.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport declare const runTest: (source: string, opts?: {\n    seed?: number;\n    randomize?: boolean;\n}) => import(\"execa\").ExecaSyncReturnValue<string>;\n",
  "packages/jest-circus/src/__mocks__/testEventHandler.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {Circus} from '@jest/types';\n\nconst testEventHandler: Circus.EventHandler = (event, state) => {\n  switch (event.name) {\n    case 'start_describe_definition':\n    case 'finish_describe_definition': {\n      console.log(`${event.name}:`, event.blockName);\n      break;\n    }\n    case 'run_describe_start':\n    case 'run_describe_finish': {\n      console.log(`${event.name}:`, event.describeBlock.name);\n      break;\n    }\n    case 'test_start':\n    case 'test_started':\n    case 'test_retry':\n    case 'test_done': {\n      console.log(`${event.name}:`, event.test.name);\n      break;\n    }\n\n    case 'add_test': {\n      console.log(`${event.name}:`, event.testName);\n      break;\n    }\n\n    case 'test_fn_start':\n    case 'test_fn_success':\n    case 'test_fn_failure': {\n      console.log(`${event.name}:`, event.test.name);\n      break;\n    }\n\n    case 'add_hook': {\n      console.log(`${event.name}:`, event.hookType);\n      break;\n    }\n\n    case 'hook_start':\n    case 'hook_success':\n    case 'hook_failure': {\n      console.log(`${event.name}:`, event.hook.type);\n      break;\n    }\n\n    default:\n      console.log(event.name);\n  }\n\n  if (event.name === 'run_finish') {\n    console.log('');\n    console.log(`unhandledErrors: ${String(state.unhandledErrors.length)}`);\n  }\n};\n\nexport default testEventHandler;\n",
  "packages/jest-circus/src/__mocks__/testEventHandler.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Circus } from '@jest/types';\ndeclare const testEventHandler: Circus.EventHandler;\nexport default testEventHandler;\n",
  "packages/jest-changed-files/src/types.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nexport type Options = {\n  lastCommit?: boolean;\n  withAncestor?: boolean;\n  changedSince?: string;\n  includePaths?: Array<string>;\n};\n\ntype Paths = Set<string>;\nexport type Repos = {git: Paths; hg: Paths; sl: Paths};\nexport type ChangedFiles = {repos: Repos; changedFiles: Paths};\nexport type ChangedFilesPromise = Promise<ChangedFiles>;\n\nexport type SCMAdapter = {\n  findChangedFiles: (cwd: string, options: Options) => Promise<Array<string>>;\n  getRoot: (cwd: string) => Promise<string | null>;\n};\n",
  "packages/jest-changed-files/src/types.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport type Options = {\n    lastCommit?: boolean;\n    withAncestor?: boolean;\n    changedSince?: string;\n    includePaths?: Array<string>;\n};\ntype Paths = Set<string>;\nexport type Repos = {\n    git: Paths;\n    hg: Paths;\n    sl: Paths;\n};\nexport type ChangedFiles = {\n    repos: Repos;\n    changedFiles: Paths;\n};\nexport type ChangedFilesPromise = Promise<ChangedFiles>;\nexport type SCMAdapter = {\n    findChangedFiles: (cwd: string, options: Options) => Promise<Array<string>>;\n    getRoot: (cwd: string) => Promise<string | null>;\n};\nexport {};\n",
  "packages/jest-changed-files/src/sl.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport * as path from 'path';\nimport execa from 'execa';\nimport type {SCMAdapter} from './types';\n\n/**\n * Disable any configuration settings that might change Sapling's default output.\n * More info in `sl help environment`.  _HG_PLAIN is intentional\n */\nconst env = {...process.env, HGPLAIN: '1'};\n\n// Whether `sl` is a steam locomotive or not\nlet isSteamLocomotive = false;\n\nconst adapter: SCMAdapter = {\n  findChangedFiles: async (cwd, options) => {\n    const includePaths = options.includePaths ?? [];\n\n    const args = ['status', '-amnu'];\n    if (options.withAncestor === true) {\n      args.push('--rev', 'first(min(!public() & ::.)^+.^)');\n    } else if (\n      options.changedSince != null &&\n      options.changedSince.length > 0\n    ) {\n      args.push('--rev', `ancestor(., ${options.changedSince})`);\n    } else if (options.lastCommit === true) {\n      args.push('--change', '.');\n    }\n    args.push(...includePaths);\n\n    const result = await execa('sl', args, {cwd, env});\n\n    return result.stdout\n      .split('\\n')\n      .filter(s => s !== '')\n      .map(changedPath => path.resolve(cwd, changedPath));\n  },\n\n  getRoot: async cwd => {\n    if (isSteamLocomotive) {\n      return null;\n    }\n\n    try {\n      const subprocess = execa('sl', ['root'], {cwd, env});\n\n      // Check if we're calling sl (steam locomotive) instead of sl (sapling)\n      // by looking for the escape character in the first chunk of data.\n      if (subprocess.stdout) {\n        subprocess.stdout.once('data', (data: Buffer | string) => {\n          data = Buffer.isBuffer(data) ? data.toString() : data;\n          if (data.codePointAt(0) === 27) {\n            subprocess.cancel();\n            isSteamLocomotive = true;\n          }\n        });\n      }\n\n      const result = await subprocess;\n      if (result.killed && isSteamLocomotive) {\n        return null;\n      }\n\n      return result.stdout;\n    } catch {\n      return null;\n    }\n  },\n};\n\nexport default adapter;\n",
  "packages/jest-changed-files/src/sl.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport type { SCMAdapter } from './types';\ndeclare const adapter: SCMAdapter;\nexport default adapter;\n",
  "packages/jest-changed-files/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport pLimit from 'p-limit';\nimport {isNonNullable} from 'jest-util';\nimport git from './git';\nimport hg from './hg';\nimport sl from './sl';\nimport type {ChangedFilesPromise, Options, Repos} from './types';\n\nexport type {ChangedFiles, ChangedFilesPromise} from './types';\n\n// This is an arbitrary number. The main goal is to prevent projects with\n// many roots (50+) from spawning too many processes at once.\nconst mutex = pLimit(5);\n\nconst findGitRoot = (dir: string) => mutex(() => git.getRoot(dir));\nconst findHgRoot = (dir: string) => mutex(() => hg.getRoot(dir));\nconst findSlRoot = (dir: string) => mutex(() => sl.getRoot(dir));\n\nexport const getChangedFilesForRoots = async (\n  roots: Array<string>,\n  options: Options,\n): ChangedFilesPromise => {\n  const repos = await findRepos(roots);\n\n  const changedFilesOptions = {includePaths: roots, ...options};\n\n  const gitPromises = Array.from(repos.git, repo =>\n    git.findChangedFiles(repo, changedFilesOptions),\n  );\n\n  const hgPromises = Array.from(repos.hg, repo =>\n    hg.findChangedFiles(repo, changedFilesOptions),\n  );\n\n  const slPromises = Array.from(repos.sl, repo =>\n    sl.findChangedFiles(repo, changedFilesOptions),\n  );\n\n  const allVcs = await Promise.all([\n    ...gitPromises,\n    ...hgPromises,\n    ...slPromises,\n  ]);\n  const changedFiles = allVcs.reduce((allFiles, changedFilesInTheRepo) => {\n    for (const file of changedFilesInTheRepo) {\n      allFiles.add(file);\n    }\n\n    return allFiles;\n  }, new Set<string>());\n\n  return {changedFiles, repos};\n};\n\nexport const findRepos = async (roots: Array<string>): Promise<Repos> => {\n  const [gitRepos, hgRepos, slRepos] = await Promise.all([\n    Promise.all(roots.map(findGitRoot)),\n    Promise.all(roots.map(findHgRoot)),\n    Promise.all(roots.map(findSlRoot)),\n  ]);\n\n  return {\n    git: new Set(gitRepos.filter(isNonNullable)),\n    hg: new Set(hgRepos.filter(isNonNullable)),\n    sl: new Set(slRepos.filter(isNonNullable)),\n  };\n};\n",
  "packages/jest-changed-files/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport type { ChangedFilesPromise, Options, Repos } from './types';\nexport type { ChangedFiles, ChangedFilesPromise } from './types';\nexport declare const getChangedFilesForRoots: (roots: Array<string>, options: Options) => ChangedFilesPromise;\nexport declare const findRepos: (roots: Array<string>) => Promise<Repos>;\n",
  "packages/jest-changed-files/src/hg.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport * as path from 'path';\nimport execa from 'execa';\nimport type {SCMAdapter} from './types';\n\nconst env = {...process.env, HGPLAIN: '1'};\n\nconst adapter: SCMAdapter = {\n  findChangedFiles: async (cwd, options) => {\n    const includePaths = options.includePaths ?? [];\n\n    const args = ['status', '-amnu'];\n    if (options.withAncestor === true) {\n      args.push('--rev', 'first(min(!public() & ::.)^+.^)');\n    } else if (\n      options.changedSince != null &&\n      options.changedSince.length > 0\n    ) {\n      args.push('--rev', `ancestor(., ${options.changedSince})`);\n    } else if (options.lastCommit === true) {\n      args.push('--change', '.');\n    }\n    args.push(...includePaths);\n\n    const result = await execa('hg', args, {cwd, env});\n\n    return result.stdout\n      .split('\\n')\n      .filter(s => s !== '')\n      .map(changedPath => path.resolve(cwd, changedPath));\n  },\n\n  getRoot: async cwd => {\n    try {\n      const result = await execa('hg', ['root'], {cwd, env});\n\n      return result.stdout;\n    } catch {\n      return null;\n    }\n  },\n};\n\nexport default adapter;\n",
  "packages/jest-changed-files/src/hg.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport type { SCMAdapter } from './types';\ndeclare const adapter: SCMAdapter;\nexport default adapter;\n",
  "packages/jest-changed-files/src/git.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport * as path from 'path';\nimport execa from 'execa';\nimport type {SCMAdapter} from './types';\n\nconst findChangedFilesUsingCommand = async (\n  args: Array<string>,\n  cwd: string,\n): Promise<Array<string>> => {\n  const result = await execa('git', args, {cwd});\n\n  return result.stdout\n    .split('\\n')\n    .filter(s => s !== '')\n    .map(changedPath => path.resolve(cwd, changedPath));\n};\n\nconst adapter: SCMAdapter = {\n  findChangedFiles: async (cwd, options) => {\n    const changedSince =\n      options.withAncestor === true ? 'HEAD^' : options.changedSince;\n\n    const includePaths = (options.includePaths ?? []).map(absoluteRoot =>\n      path.normalize(path.relative(cwd, absoluteRoot)),\n    );\n\n    if (options.lastCommit === true) {\n      return findChangedFilesUsingCommand(\n        [\n          'show',\n          '--name-only',\n          '--pretty=format:',\n          'HEAD',\n          '--',\n          ...includePaths,\n        ],\n        cwd,\n      );\n    }\n    if (changedSince != null && changedSince.length > 0) {\n      const [committed, staged, unstaged] = await Promise.all([\n        findChangedFilesUsingCommand(\n          [\n            'diff',\n            '--name-only',\n            `${changedSince}...HEAD`,\n            '--',\n            ...includePaths,\n          ],\n          cwd,\n        ),\n        findChangedFilesUsingCommand(\n          ['diff', '--cached', '--name-only', '--', ...includePaths],\n          cwd,\n        ),\n        findChangedFilesUsingCommand(\n          [\n            'ls-files',\n            '--other',\n            '--modified',\n            '--exclude-standard',\n            '--',\n            ...includePaths,\n          ],\n          cwd,\n        ),\n      ]);\n      return [...committed, ...staged, ...unstaged];\n    }\n    const [staged, unstaged] = await Promise.all([\n      findChangedFilesUsingCommand(\n        ['diff', '--cached', '--name-only', '--', ...includePaths],\n        cwd,\n      ),\n      findChangedFilesUsingCommand(\n        [\n          'ls-files',\n          '--other',\n          '--modified',\n          '--exclude-standard',\n          '--',\n          ...includePaths,\n        ],\n        cwd,\n      ),\n    ]);\n    return [...staged, ...unstaged];\n  },\n\n  getRoot: async cwd => {\n    const options = ['rev-parse', '--show-cdup'];\n\n    try {\n      const result = await execa('git', options, {cwd});\n\n      return path.resolve(cwd, result.stdout);\n    } catch {\n      return null;\n    }\n  },\n};\n\nexport default adapter;\n",
  "packages/jest-changed-files/src/git.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport type { SCMAdapter } from './types';\ndeclare const adapter: SCMAdapter;\nexport default adapter;\n",
  "packages/jest/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {Config as ConfigTypes} from '@jest/types';\n\nexport {\n  SearchSource,\n  createTestScheduler,\n  getVersion,\n  runCLI,\n} from '@jest/core';\n\nexport {run, buildArgv} from 'jest-cli';\n\nexport type Config = ConfigTypes.InitialOptions;\n",
  "packages/jest/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config as ConfigTypes } from '@jest/types';\nexport { SearchSource, createTestScheduler, getVersion, runCLI, } from '@jest/core';\nexport { run, buildArgv } from 'jest-cli';\nexport type Config = ConfigTypes.InitialOptions;\n",
  "packages/jest/__typetests__/jest.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {describe, expect, test} from 'tstyche';\nimport type {Config} from 'jest';\n\ndescribe('Config', () => {\n  test('is a reexport of the `InitialOptions`', () => {\n    type InitialOptions = import('@jest/types').Config.InitialOptions;\n\n    expect<Config>().type.toBe<InitialOptions>();\n  });\n});\n",
  "packages/jest/__typetests__/jest.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/expect-utils/src/utils.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {isPrimitive} from '@jest/get-type';\nimport {\n  isImmutableList,\n  isImmutableOrderedKeyed,\n  isImmutableOrderedSet,\n  isImmutableRecord,\n  isImmutableUnorderedKeyed,\n  isImmutableUnorderedSet,\n} from './immutableUtils';\nimport {equals, isA} from './jasmineUtils';\nimport type {Tester} from './types';\n\ntype GetPath = {\n  hasEndProp?: boolean;\n  endPropIsDefined?: boolean;\n  lastTraversedObject: unknown;\n  traversedPath: Array<string>;\n  value?: unknown;\n};\n\n/**\n * Checks if `hasOwnProperty(object, key)` up the prototype chain, stopping at `Object.prototype`.\n */\nconst hasPropertyInObject = (object: object, key: string | symbol): boolean => {\n  const shouldTerminate =\n    !object || typeof object !== 'object' || object === Object.prototype;\n\n  if (shouldTerminate) {\n    return false;\n  }\n\n  return (\n    Object.prototype.hasOwnProperty.call(object, key) ||\n    hasPropertyInObject(Object.getPrototypeOf(object), key)\n  );\n};\n\n// Retrieves an object's keys for evaluation by getObjectSubset.  This evaluates\n// the prototype chain for string keys but not for non-enumerable symbols.\n// (Otherwise, it could find values such as a Set or Map's Symbol.toStringTag,\n// with unexpected results.)\nexport const getObjectKeys = (object: object): Array<string | symbol> => {\n  return [\n    ...Object.keys(object),\n    ...Object.getOwnPropertySymbols(object).filter(\n      s => Object.getOwnPropertyDescriptor(object, s)?.enumerable,\n    ),\n  ];\n};\n\nexport const getPath = (\n  object: Record<string, any>,\n  propertyPath: string | Array<string>,\n): GetPath => {\n  if (!Array.isArray(propertyPath)) {\n    propertyPath = pathAsArray(propertyPath);\n  }\n\n  if (propertyPath.length > 0) {\n    const lastProp = propertyPath.length === 1;\n    const prop = propertyPath[0];\n    const newObject = object[prop];\n\n    if (!lastProp && (newObject === null || newObject === undefined)) {\n      // This is not the last prop in the chain. If we keep recursing it will\n      // hit a `can't access property X of undefined | null`. At this point we\n      // know that the chain has broken and we can return right away.\n      return {\n        hasEndProp: false,\n        lastTraversedObject: object,\n        traversedPath: [],\n      };\n    }\n\n    const result = getPath(newObject, propertyPath.slice(1));\n\n    if (result.lastTraversedObject === null) {\n      result.lastTraversedObject = object;\n    }\n\n    result.traversedPath.unshift(prop);\n\n    if (lastProp) {\n      // Does object have the property with an undefined value?\n      // Although primitive values support bracket notation (above)\n      // they would throw TypeError for in operator (below).\n      result.endPropIsDefined = !isPrimitive(object) && prop in object;\n      result.hasEndProp = newObject !== undefined || result.endPropIsDefined;\n\n      if (!result.hasEndProp) {\n        result.traversedPath.shift();\n      }\n    }\n\n    return result;\n  }\n\n  return {\n    lastTraversedObject: null,\n    traversedPath: [],\n    value: object,\n  };\n};\n\n// Strip properties from object that are not present in the subset. Useful for\n// printing the diff for toMatchObject() without adding unrelated noise.\n/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\nexport const getObjectSubset = (\n  object: any,\n  subset: any,\n  customTesters: Array<Tester> = [],\n  seenReferences: WeakMap<object, boolean> = new WeakMap(),\n): any => {\n  /* eslint-enable @typescript-eslint/explicit-module-boundary-types */\n  if (Array.isArray(object)) {\n    if (Array.isArray(subset) && subset.length === object.length) {\n      // The map method returns correct subclass of subset.\n      return subset.map((sub: any, i: number) =>\n        getObjectSubset(object[i], sub, customTesters),\n      );\n    }\n  } else if (object instanceof Date) {\n    return object;\n  } else if (isObject(object) && isObject(subset)) {\n    if (\n      equals(object, subset, [\n        ...customTesters,\n        iterableEquality,\n        subsetEquality,\n      ])\n    ) {\n      // Avoid unnecessary copy which might return Object instead of subclass.\n      return subset;\n    }\n\n    const trimmed: any = {};\n    seenReferences.set(object, trimmed);\n\n    for (const key of getObjectKeys(object).filter(key =>\n      hasPropertyInObject(subset, key),\n    )) {\n      trimmed[key] = seenReferences.has(object[key])\n        ? seenReferences.get(object[key])\n        : getObjectSubset(\n            object[key],\n            subset[key],\n            customTesters,\n            seenReferences,\n          );\n    }\n\n    if (getObjectKeys(trimmed).length > 0) {\n      return trimmed;\n    }\n  }\n  return object;\n};\n\nconst IteratorSymbol = Symbol.iterator;\n\nconst hasIterator = (object: any) =>\n  !!(object != null && object[IteratorSymbol]);\n\n/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\nexport const iterableEquality = (\n  a: any,\n  b: any,\n  customTesters: Array<Tester> = [],\n  /* eslint-enable @typescript-eslint/explicit-module-boundary-types */\n  aStack: Array<any> = [],\n  bStack: Array<any> = [],\n): boolean | undefined => {\n  if (\n    typeof a !== 'object' ||\n    typeof b !== 'object' ||\n    Array.isArray(a) ||\n    Array.isArray(b) ||\n    ArrayBuffer.isView(a) ||\n    ArrayBuffer.isView(b) ||\n    !hasIterator(a) ||\n    !hasIterator(b)\n  ) {\n    return undefined;\n  }\n  if (a.constructor !== b.constructor) {\n    return false;\n  }\n  let length = aStack.length;\n  while (length--) {\n    // Linear search. Performance is inversely proportional to the number of\n    // unique nested structures.\n    // circular references at same depth are equal\n    // circular reference is not equal to non-circular one\n    if (aStack[length] === a) {\n      return bStack[length] === b;\n    }\n  }\n  aStack.push(a);\n  bStack.push(b);\n\n  const iterableEqualityWithStack = (a: any, b: any) =>\n    iterableEquality(\n      a,\n      b,\n      [...filteredCustomTesters],\n      [...aStack],\n      [...bStack],\n    );\n\n  // Replace any instance of iterableEquality with the new\n  // iterableEqualityWithStack so we can do circular detection\n  const filteredCustomTesters: Array<Tester> = [\n    ...customTesters.filter(t => t !== iterableEquality),\n    iterableEqualityWithStack,\n  ];\n\n  if (a.size !== undefined) {\n    if (a.size !== b.size) {\n      return false;\n    } else if (isA<Set<unknown>>('Set', a) || isImmutableUnorderedSet(a)) {\n      let allFound = true;\n      for (const aValue of a) {\n        if (!b.has(aValue)) {\n          let has = false;\n          for (const bValue of b) {\n            const isEqual = equals(aValue, bValue, filteredCustomTesters);\n            if (isEqual === true) {\n              has = true;\n            }\n          }\n\n          if (has === false) {\n            allFound = false;\n            break;\n          }\n        }\n      }\n      // Remove the first value from the stack of traversed values.\n      aStack.pop();\n      bStack.pop();\n      return allFound;\n    } else if (\n      isA<Map<unknown, unknown>>('Map', a) ||\n      isImmutableUnorderedKeyed(a)\n    ) {\n      let allFound = true;\n      for (const aEntry of a) {\n        if (\n          !b.has(aEntry[0]) ||\n          !equals(aEntry[1], b.get(aEntry[0]), filteredCustomTesters)\n        ) {\n          let has = false;\n          for (const bEntry of b) {\n            const matchedKey = equals(\n              aEntry[0],\n              bEntry[0],\n              filteredCustomTesters,\n            );\n\n            let matchedValue = false;\n            if (matchedKey === true) {\n              matchedValue = equals(\n                aEntry[1],\n                bEntry[1],\n                filteredCustomTesters,\n              );\n            }\n            if (matchedValue === true) {\n              has = true;\n            }\n          }\n\n          if (has === false) {\n            allFound = false;\n            break;\n          }\n        }\n      }\n      // Remove the first value from the stack of traversed values.\n      aStack.pop();\n      bStack.pop();\n      return allFound;\n    }\n  }\n\n  const bIterator = b[IteratorSymbol]();\n\n  for (const aValue of a) {\n    const nextB = bIterator.next();\n    if (nextB.done || !equals(aValue, nextB.value, filteredCustomTesters)) {\n      return false;\n    }\n  }\n  if (!bIterator.next().done) {\n    return false;\n  }\n\n  if (\n    !isImmutableList(a) &&\n    !isImmutableOrderedKeyed(a) &&\n    !isImmutableOrderedSet(a) &&\n    !isImmutableRecord(a)\n  ) {\n    const aEntries = entries(a);\n    const bEntries = entries(b);\n    if (!equals(aEntries, bEntries)) {\n      return false;\n    }\n  }\n\n  // Remove the first value from the stack of traversed values.\n  aStack.pop();\n  bStack.pop();\n  return true;\n};\n\nconst entries = (obj: any) => {\n  if (!isObject(obj)) return [];\n\n  const symbolProperties = Object.getOwnPropertySymbols(obj)\n    .filter(key => key !== Symbol.iterator)\n    .map(key => [key, obj[key]]);\n\n  return [...symbolProperties, ...Object.entries(obj)];\n};\n\nconst isObject = (a: any) => a !== null && typeof a === 'object';\n\nconst isObjectWithKeys = (a: any) =>\n  isObject(a) &&\n  !(a instanceof Error) &&\n  !Array.isArray(a) &&\n  !(a instanceof Date) &&\n  !(a instanceof Set) &&\n  !(a instanceof Map);\n\nexport const subsetEquality = (\n  object: unknown,\n  subset: unknown,\n  customTesters: Array<Tester> = [],\n): boolean | undefined => {\n  const filteredCustomTesters = customTesters.filter(t => t !== subsetEquality);\n\n  // subsetEquality needs to keep track of the references\n  // it has already visited to avoid infinite loops in case\n  // there are circular references in the subset passed to it.\n  const subsetEqualityWithContext =\n    (seenReferences: WeakMap<object, boolean> = new WeakMap()) =>\n    (object: any, subset: any): boolean | undefined => {\n      if (!isObjectWithKeys(subset)) {\n        return undefined;\n      }\n\n      if (seenReferences.has(subset)) return undefined;\n      seenReferences.set(subset, true);\n\n      const matchResult = getObjectKeys(subset).every(key => {\n        if (isObjectWithKeys(subset[key])) {\n          if (seenReferences.has(subset[key])) {\n            return equals(object[key], subset[key], filteredCustomTesters);\n          }\n        }\n        const result =\n          object != null &&\n          hasPropertyInObject(object, key) &&\n          equals(object[key], subset[key], [\n            ...filteredCustomTesters,\n            subsetEqualityWithContext(seenReferences),\n          ]);\n        // The main goal of using seenReference is to avoid circular node on tree.\n        // It will only happen within a parent and its child, not a node and nodes next to it (same level)\n        // We should keep the reference for a parent and its child only\n        // Thus we should delete the reference immediately so that it doesn't interfere\n        // other nodes within the same level on tree.\n        seenReferences.delete(subset[key]);\n        return result;\n      });\n      seenReferences.delete(subset);\n      return matchResult;\n    };\n\n  return subsetEqualityWithContext()(object, subset);\n};\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport const typeEquality = (a: any, b: any): boolean | undefined => {\n  if (\n    a == null ||\n    b == null ||\n    a.constructor === b.constructor ||\n    // Since Jest globals are different from Node globals,\n    // constructors are different even between arrays when comparing properties of mock objects.\n    // Both of them should be able to compare correctly when they are array-to-array.\n    // https://github.com/jestjs/jest/issues/2549\n    (Array.isArray(a) && Array.isArray(b))\n  ) {\n    return undefined;\n  }\n\n  return false;\n};\n\nexport const arrayBufferEquality = (\n  a: unknown,\n  b: unknown,\n): boolean | undefined => {\n  let dataViewA = a;\n  let dataViewB = b;\n\n  if (isArrayBuffer(a) && isArrayBuffer(b)) {\n    dataViewA = new DataView(a);\n    dataViewB = new DataView(b);\n  } else if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {\n    dataViewA = new DataView(a.buffer, a.byteOffset, a.byteLength);\n    dataViewB = new DataView(b.buffer, b.byteOffset, b.byteLength);\n  }\n\n  if (!(dataViewA instanceof DataView && dataViewB instanceof DataView)) {\n    return undefined;\n  }\n\n  // Buffers are not equal when they do not have the same byte length\n  if (dataViewA.byteLength !== dataViewB.byteLength) {\n    return false;\n  }\n\n  // Check if every byte value is equal to each other\n  for (let i = 0; i < dataViewA.byteLength; i++) {\n    if (dataViewA.getUint8(i) !== dataViewB.getUint8(i)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nfunction isArrayBuffer(obj: unknown): obj is ArrayBuffer {\n  return Object.prototype.toString.call(obj) === '[object ArrayBuffer]';\n}\n\nexport const sparseArrayEquality = (\n  a: unknown,\n  b: unknown,\n  customTesters: Array<Tester> = [],\n): boolean | undefined => {\n  if (!Array.isArray(a) || !Array.isArray(b)) {\n    return undefined;\n  }\n\n  // A sparse array [, , 1] will have keys [\"2\"] whereas [undefined, undefined, 1] will have keys [\"0\", \"1\", \"2\"]\n  const aKeys = Object.keys(a);\n  const bKeys = Object.keys(b);\n  return (\n    equals(\n      a,\n      b,\n      customTesters.filter(t => t !== sparseArrayEquality),\n      true,\n    ) && equals(aKeys, bKeys)\n  );\n};\n\nexport const partition = <T>(\n  items: Array<T>,\n  predicate: (arg: T) => boolean,\n): [Array<T>, Array<T>] => {\n  const result: [Array<T>, Array<T>] = [[], []];\n\n  for (const item of items) result[predicate(item) ? 0 : 1].push(item);\n\n  return result;\n};\n\nexport const pathAsArray = (propertyPath: string): Array<any> => {\n  const properties: Array<string> = [];\n\n  if (propertyPath === '') {\n    properties.push('');\n    return properties;\n  }\n\n  // will match everything that's not a dot or a bracket, and \"\" for consecutive dots.\n  const pattern = new RegExp('[^.[\\\\]]+|(?=(?:\\\\.)(?:\\\\.|$))', 'g');\n\n  // Because the regex won't match a dot in the beginning of the path, if present.\n  if (propertyPath[0] === '.') {\n    properties.push('');\n  }\n\n  propertyPath.replaceAll(pattern, match => {\n    properties.push(match);\n    return match;\n  });\n\n  return properties;\n};\n\n// Copied from https://github.com/graingert/angular.js/blob/a43574052e9775cbc1d7dd8a086752c979b0f020/src/Angular.js#L685-L693\nexport const isError = (value: unknown): value is Error => {\n  switch (Object.prototype.toString.call(value)) {\n    case '[object Error]':\n    case '[object Exception]':\n    case '[object DOMException]':\n      return true;\n    default:\n      return value instanceof Error;\n  }\n};\n\nexport function emptyObject(obj: unknown): boolean {\n  return obj && typeof obj === 'object' ? Object.keys(obj).length === 0 : false;\n}\n\nconst MULTILINE_REGEXP = /[\\n\\r]/;\n\nexport const isOneline = (expected: unknown, received: unknown): boolean =>\n  typeof expected === 'string' &&\n  typeof received === 'string' &&\n  (!MULTILINE_REGEXP.test(expected) || !MULTILINE_REGEXP.test(received));\n",
  "packages/expect-utils/src/utils.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport type { Tester } from './types';\ntype GetPath = {\n    hasEndProp?: boolean;\n    endPropIsDefined?: boolean;\n    lastTraversedObject: unknown;\n    traversedPath: Array<string>;\n    value?: unknown;\n};\nexport declare const getObjectKeys: (object: object) => Array<string | symbol>;\nexport declare const getPath: (object: Record<string, any>, propertyPath: string | Array<string>) => GetPath;\nexport declare const getObjectSubset: (object: any, subset: any, customTesters?: Array<Tester>, seenReferences?: WeakMap<object, boolean>) => any;\nexport declare const iterableEquality: (a: any, b: any, customTesters?: Array<Tester>, aStack?: Array<any>, bStack?: Array<any>) => boolean | undefined;\nexport declare const subsetEquality: (object: unknown, subset: unknown, customTesters?: Array<Tester>) => boolean | undefined;\nexport declare const typeEquality: (a: any, b: any) => boolean | undefined;\nexport declare const arrayBufferEquality: (a: unknown, b: unknown) => boolean | undefined;\nexport declare const sparseArrayEquality: (a: unknown, b: unknown, customTesters?: Array<Tester>) => boolean | undefined;\nexport declare const partition: <T>(items: Array<T>, predicate: (arg: T) => boolean) => [Array<T>, Array<T>];\nexport declare const pathAsArray: (propertyPath: string) => Array<any>;\nexport declare const isError: (value: unknown) => value is Error;\nexport declare function emptyObject(obj: unknown): boolean;\nexport declare const isOneline: (expected: unknown, received: unknown) => boolean;\nexport {};\n",
  "packages/expect-utils/src/types.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {EqualsFunction} from './jasmineUtils';\n\nexport type Tester = (\n  this: TesterContext,\n  a: any,\n  b: any,\n  customTesters: Array<Tester>,\n) => boolean | undefined;\n\nexport interface TesterContext {\n  equals: EqualsFunction;\n}\n",
  "packages/expect-utils/src/types.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport type { EqualsFunction } from './jasmineUtils';\nexport type Tester = (this: TesterContext, a: any, b: any, customTesters: Array<Tester>) => boolean | undefined;\nexport interface TesterContext {\n    equals: EqualsFunction;\n}\n",
  "packages/expect-utils/src/jasmineUtils.ts": "/*\nCopyright (c) 2008-2016 Pivotal Labs\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n*/\n\nimport type {Tester, TesterContext} from './types';\n\nexport type EqualsFunction = (\n  a: unknown,\n  b: unknown,\n  customTesters?: Array<Tester>,\n  strictCheck?: boolean,\n) => boolean;\n\n// Extracted out of jasmine 2.5.2\nexport const equals: EqualsFunction = (a, b, customTesters, strictCheck) => {\n  customTesters = customTesters || [];\n  return eq(a, b, [], [], customTesters, strictCheck);\n};\n\nfunction isAsymmetric(obj: any) {\n  return !!obj && isA('Function', obj.asymmetricMatch);\n}\n\nfunction asymmetricMatch(a: any, b: any) {\n  const asymmetricA = isAsymmetric(a);\n  const asymmetricB = isAsymmetric(b);\n\n  if (asymmetricA && asymmetricB) {\n    return undefined;\n  }\n\n  if (asymmetricA) {\n    return a.asymmetricMatch(b);\n  }\n\n  if (asymmetricB) {\n    return b.asymmetricMatch(a);\n  }\n}\n\n// Equality function lovingly adapted from isEqual in\n//   [Underscore](http://underscorejs.org)\nfunction eq(\n  a: any,\n  b: any,\n  aStack: Array<unknown>,\n  bStack: Array<unknown>,\n  customTesters: Array<Tester>,\n  strictCheck: boolean | undefined,\n): boolean {\n  let result = true;\n\n  const asymmetricResult = asymmetricMatch(a, b);\n  if (asymmetricResult !== undefined) {\n    return asymmetricResult;\n  }\n\n  const testerContext: TesterContext = {equals};\n  for (const item of customTesters) {\n    const customTesterResult = item.call(testerContext, a, b, customTesters);\n    if (customTesterResult !== undefined) {\n      return customTesterResult;\n    }\n  }\n\n  if (a instanceof Error && b instanceof Error) {\n    return a.message === b.message;\n  }\n\n  if (Object.is(a, b)) {\n    return true;\n  }\n  // A strict comparison is necessary because `null == undefined`.\n  if (a === null || b === null) {\n    return false;\n  }\n  const className = Object.prototype.toString.call(a);\n  if (className !== Object.prototype.toString.call(b)) {\n    return false;\n  }\n  switch (className) {\n    case '[object Boolean]':\n    case '[object String]':\n    case '[object Number]':\n      if (typeof a !== typeof b) {\n        // One is a primitive, one a `new Primitive()`\n        return false;\n      } else if (typeof a !== 'object' && typeof b !== 'object') {\n        // both are proper primitives\n        return false;\n      } else {\n        // both are `new Primitive()`s\n        return Object.is(a.valueOf(), b.valueOf());\n      }\n    case '[object Date]':\n      // Coerce dates to numeric primitive values. Dates are compared by their\n      // millisecond representations. Note that invalid dates with millisecond representations\n      // of `NaN` are not equivalent.\n      return +a === +b;\n    // RegExps are compared by their source patterns and flags.\n    case '[object RegExp]':\n      return a.source === b.source && a.flags === b.flags;\n    // URLs are compared by their href property which contains the entire url string.\n    case '[object URL]':\n      return a.href === b.href;\n  }\n  if (typeof a !== 'object' || typeof b !== 'object') {\n    return false;\n  }\n\n  // Use DOM3 method isEqualNode (IE>=9)\n  if (isDomNode(a) && isDomNode(b)) {\n    return a.isEqualNode(b);\n  }\n\n  // Used to detect circular references.\n  let length = aStack.length;\n  while (length--) {\n    // Linear search. Performance is inversely proportional to the number of\n    // unique nested structures.\n    // circular references at same depth are equal\n    // circular reference is not equal to non-circular one\n    if (aStack[length] === a) {\n      return bStack[length] === b;\n    } else if (bStack[length] === b) {\n      return false;\n    }\n  }\n  // Add the first object to the stack of traversed objects.\n  aStack.push(a);\n  bStack.push(b);\n  // Recursively compare objects and arrays.\n  // Compare array lengths to determine if a deep comparison is necessary.\n  if (strictCheck && className === '[object Array]' && a.length !== b.length) {\n    return false;\n  }\n\n  // Deep compare objects.\n  const aKeys = keys(a, hasKey);\n  let key;\n\n  const bKeys = keys(b, hasKey);\n  // Add keys corresponding to asymmetric matchers if they miss in non strict check mode\n  if (!strictCheck) {\n    for (let index = 0; index !== bKeys.length; ++index) {\n      key = bKeys[index];\n      if ((isAsymmetric(b[key]) || b[key] === undefined) && !hasKey(a, key)) {\n        aKeys.push(key);\n      }\n    }\n    for (let index = 0; index !== aKeys.length; ++index) {\n      key = aKeys[index];\n      if ((isAsymmetric(a[key]) || a[key] === undefined) && !hasKey(b, key)) {\n        bKeys.push(key);\n      }\n    }\n  }\n\n  // Ensure that both objects contain the same number of properties before comparing deep equality.\n  let size = aKeys.length;\n  if (bKeys.length !== size) {\n    return false;\n  }\n\n  while (size--) {\n    key = aKeys[size];\n\n    // Deep compare each member\n    if (strictCheck)\n      result =\n        hasKey(b, key) &&\n        eq(a[key], b[key], aStack, bStack, customTesters, strictCheck);\n    else\n      result =\n        (hasKey(b, key) || isAsymmetric(a[key]) || a[key] === undefined) &&\n        eq(a[key], b[key], aStack, bStack, customTesters, strictCheck);\n\n    if (!result) {\n      return false;\n    }\n  }\n  // Remove the first object from the stack of traversed objects.\n  aStack.pop();\n  bStack.pop();\n\n  return result;\n}\n\nfunction keys(obj: object, hasKey: (obj: object, key: string) => boolean) {\n  const keys = [];\n  for (const key in obj) {\n    if (hasKey(obj, key)) {\n      keys.push(key);\n    }\n  }\n  return [\n    ...keys,\n    ...Object.getOwnPropertySymbols(obj).filter(\n      symbol => Object.getOwnPropertyDescriptor(obj, symbol)!.enumerable,\n    ),\n  ];\n}\n\nfunction hasKey(obj: any, key: string | symbol) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nexport function isA<T>(typeName: string, value: unknown): value is T {\n  return Object.prototype.toString.apply(value) === `[object ${typeName}]`;\n}\n\nfunction isDomNode(obj: any): boolean {\n  return (\n    obj !== null &&\n    typeof obj === 'object' &&\n    typeof obj.nodeType === 'number' &&\n    typeof obj.nodeName === 'string' &&\n    typeof obj.isEqualNode === 'function'\n  );\n}\n",
  "packages/expect-utils/src/jasmineUtils.d.ts": "import type { Tester } from './types';\nexport type EqualsFunction = (a: unknown, b: unknown, customTesters?: Array<Tester>, strictCheck?: boolean) => boolean;\nexport declare const equals: EqualsFunction;\nexport declare function isA<T>(typeName: string, value: unknown): value is T;\n",
  "packages/expect-utils/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nexport {equals, isA} from './jasmineUtils';\nexport type {EqualsFunction} from './jasmineUtils';\nexport * from './utils';\n\nexport type {Tester, TesterContext} from './types';\n",
  "packages/expect-utils/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport { equals, isA } from './jasmineUtils';\nexport type { EqualsFunction } from './jasmineUtils';\nexport * from './utils';\nexport type { Tester, TesterContext } from './types';\n",
  "packages/expect-utils/src/immutableUtils.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// SENTINEL constants are from https://github.com/immutable-js/immutable-js/tree/main/src/predicates\nconst IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\nconst IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';\nconst IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';\nconst IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\nconst IS_RECORD_SYMBOL = '@@__IMMUTABLE_RECORD__@@';\n\nfunction isObjectLiteral(source: unknown): source is Record<string, unknown> {\n  return source != null && typeof source === 'object' && !Array.isArray(source);\n}\n\nexport function isImmutableUnorderedKeyed(source: unknown): boolean {\n  return Boolean(\n    source &&\n      isObjectLiteral(source) &&\n      source[IS_KEYED_SENTINEL] &&\n      !source[IS_ORDERED_SENTINEL],\n  );\n}\n\nexport function isImmutableUnorderedSet(source: unknown): boolean {\n  return Boolean(\n    source &&\n      isObjectLiteral(source) &&\n      source[IS_SET_SENTINEL] &&\n      !source[IS_ORDERED_SENTINEL],\n  );\n}\n\nexport function isImmutableList(source: unknown): boolean {\n  return Boolean(source && isObjectLiteral(source) && source[IS_LIST_SENTINEL]);\n}\n\nexport function isImmutableOrderedKeyed(source: unknown): boolean {\n  return Boolean(\n    source &&\n      isObjectLiteral(source) &&\n      source[IS_KEYED_SENTINEL] &&\n      source[IS_ORDERED_SENTINEL],\n  );\n}\n\nexport function isImmutableOrderedSet(source: unknown): boolean {\n  return Boolean(\n    source &&\n      isObjectLiteral(source) &&\n      source[IS_SET_SENTINEL] &&\n      source[IS_ORDERED_SENTINEL],\n  );\n}\n\nexport function isImmutableRecord(source: unknown): boolean {\n  return Boolean(source && isObjectLiteral(source) && source[IS_RECORD_SYMBOL]);\n}\n",
  "packages/expect-utils/src/immutableUtils.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport declare function isImmutableUnorderedKeyed(source: unknown): boolean;\nexport declare function isImmutableUnorderedSet(source: unknown): boolean;\nexport declare function isImmutableList(source: unknown): boolean;\nexport declare function isImmutableOrderedKeyed(source: unknown): boolean;\nexport declare function isImmutableOrderedSet(source: unknown): boolean;\nexport declare function isImmutableRecord(source: unknown): boolean;\n",
  "packages/expect-utils/src/__tests__/utils.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {List, OrderedMap, OrderedSet, Record} from 'immutable';\nimport {stringify} from 'jest-matcher-utils';\nimport {equals} from '../jasmineUtils';\nimport {\n  arrayBufferEquality,\n  emptyObject,\n  getObjectSubset,\n  getPath,\n  iterableEquality,\n  subsetEquality,\n  typeEquality,\n} from '../utils';\n\ndescribe('getPath()', () => {\n  test('property exists', () => {\n    expect(getPath({a: {b: {c: 5}}}, 'a.b.c')).toEqual({\n      endPropIsDefined: true,\n      hasEndProp: true,\n      lastTraversedObject: {c: 5},\n      traversedPath: ['a', 'b', 'c'],\n      value: 5,\n    });\n\n    expect(getPath({a: {b: {c: {d: 1}}}}, 'a.b.c.d')).toEqual({\n      endPropIsDefined: true,\n      hasEndProp: true,\n      lastTraversedObject: {d: 1},\n      traversedPath: ['a', 'b', 'c', 'd'],\n      value: 1,\n    });\n  });\n\n  test('property doesnt exist', () => {\n    expect(getPath({a: {b: {}}}, 'a.b.c')).toEqual({\n      endPropIsDefined: false,\n      hasEndProp: false,\n      lastTraversedObject: {},\n      traversedPath: ['a', 'b'],\n      value: undefined,\n    });\n  });\n\n  test('property exist but undefined', () => {\n    expect(getPath({a: {b: {c: undefined}}}, 'a.b.c')).toEqual({\n      endPropIsDefined: true,\n      hasEndProp: true,\n      lastTraversedObject: {c: undefined},\n      traversedPath: ['a', 'b', 'c'],\n      value: undefined,\n    });\n  });\n\n  test('property is a getter on class instance', () => {\n    class A {\n      get a() {\n        return 'a';\n      }\n      get b() {\n        return {c: 'c'};\n      }\n    }\n\n    expect(getPath(new A(), 'a')).toEqual({\n      endPropIsDefined: true,\n      hasEndProp: true,\n      lastTraversedObject: new A(),\n      traversedPath: ['a'],\n      value: 'a',\n    });\n    expect(getPath(new A(), 'b.c')).toEqual({\n      endPropIsDefined: true,\n      hasEndProp: true,\n      lastTraversedObject: {c: 'c'},\n      traversedPath: ['b', 'c'],\n      value: 'c',\n    });\n  });\n\n  test('property is inherited', () => {\n    class A {}\n    // @ts-expect-error\n    A.prototype.a = 'a';\n\n    expect(getPath(new A(), 'a')).toEqual({\n      endPropIsDefined: true,\n      hasEndProp: true,\n      lastTraversedObject: new A(),\n      traversedPath: ['a'],\n      value: 'a',\n    });\n  });\n\n  test('path breaks', () => {\n    expect(getPath({a: {}}, 'a.b.c')).toEqual({\n      hasEndProp: false,\n      lastTraversedObject: {},\n      traversedPath: ['a'],\n      value: undefined,\n    });\n  });\n\n  test('empty object at the end', () => {\n    expect(getPath({a: {b: {c: {}}}}, 'a.b.c.d')).toEqual({\n      endPropIsDefined: false,\n      hasEndProp: false,\n      lastTraversedObject: {},\n      traversedPath: ['a', 'b', 'c'],\n      value: undefined,\n    });\n  });\n});\n\ndescribe('getObjectSubset', () => {\n  for (const [object, subset, expected] of [\n    [{a: 'b', c: 'd'}, {a: 'd'}, {a: 'b'}],\n    [{a: [1, 2], b: 'b'}, {a: [3, 4]}, {a: [1, 2]}],\n    [[{a: 'b', c: 'd'}], [{a: 'z'}], [{a: 'b'}]],\n    [\n      [1, 2],\n      [1, 2, 3],\n      [1, 2],\n    ],\n    [{a: [1]}, {a: [1, 2]}, {a: [1]}],\n    [new Date('2015-11-30'), new Date('2016-12-30'), new Date('2015-11-30')],\n  ]) {\n    test(\n      `expect(getObjectSubset(${stringify(object)}, ${stringify(subset)}))` +\n        `.toEqual(${stringify(expected)})`,\n      () => {\n        expect(getObjectSubset(object, subset)).toEqual(expected);\n      },\n    );\n  }\n\n  describe('returns the object instance if the subset has no extra properties', () => {\n    test('Date', () => {\n      const object = new Date('2015-11-30');\n      const subset = new Date('2016-12-30');\n\n      expect(getObjectSubset(object, subset)).toBe(object);\n    });\n  });\n\n  describe('returns the subset instance if its property values are equal', () => {\n    test('Object', () => {\n      const object = {key0: 'zero', key1: 'one', key2: 'two'};\n      const subset = {key0: 'zero', key2: 'two'};\n\n      expect(getObjectSubset(object, subset)).toBe(subset);\n    });\n\n    describe('Uint8Array', () => {\n      const equalObject = {'0': 0, '1': 0, '2': 0};\n      const typedArray = new Uint8Array(3);\n\n      test('expected', () => {\n        const object = equalObject;\n        const subset = typedArray;\n\n        expect(getObjectSubset(object, subset)).toBe(subset);\n      });\n\n      test('received', () => {\n        const object = typedArray;\n        const subset = equalObject;\n\n        expect(getObjectSubset(object, subset)).toBe(subset);\n      });\n    });\n  });\n\n  describe('calculating subsets of objects with circular references', () => {\n    test('simple circular references', () => {\n      type CircularObj = {a?: string; b?: string; ref?: unknown};\n\n      const nonCircularObj = {a: 'world', b: 'something'};\n\n      const circularObjA: CircularObj = {a: 'hello'};\n      circularObjA.ref = circularObjA;\n\n      const circularObjB: CircularObj = {a: 'world'};\n      circularObjB.ref = circularObjB;\n\n      const primitiveInsteadOfRef: CircularObj = {b: 'something'};\n      primitiveInsteadOfRef.ref = 'not a ref';\n\n      const nonCircularRef: CircularObj = {b: 'something'};\n      nonCircularRef.ref = {};\n\n      expect(getObjectSubset(circularObjA, nonCircularObj)).toEqual({\n        a: 'hello',\n      });\n      expect(getObjectSubset(nonCircularObj, circularObjA)).toEqual({\n        a: 'world',\n      });\n\n      expect(getObjectSubset(circularObjB, circularObjA)).toEqual(circularObjB);\n\n      expect(getObjectSubset(primitiveInsteadOfRef, circularObjA)).toEqual({\n        ref: 'not a ref',\n      });\n      expect(getObjectSubset(nonCircularRef, circularObjA)).toEqual({\n        ref: {},\n      });\n    });\n\n    test('transitive circular references', () => {\n      type CircularObj = {a?: string; nestedObj?: unknown};\n\n      const nonCircularObj = {a: 'world', b: 'something'};\n\n      const transitiveCircularObjA: CircularObj = {a: 'hello'};\n      transitiveCircularObjA.nestedObj = {parentObj: transitiveCircularObjA};\n\n      const transitiveCircularObjB: CircularObj = {a: 'world'};\n      transitiveCircularObjB.nestedObj = {parentObj: transitiveCircularObjB};\n\n      const primitiveInsteadOfRef: CircularObj = {};\n      primitiveInsteadOfRef.nestedObj = {otherProp: 'not the parent ref'};\n\n      const nonCircularRef: CircularObj = {};\n      nonCircularRef.nestedObj = {otherProp: {}};\n\n      expect(getObjectSubset(transitiveCircularObjA, nonCircularObj)).toEqual({\n        a: 'hello',\n      });\n      expect(getObjectSubset(nonCircularObj, transitiveCircularObjA)).toEqual({\n        a: 'world',\n      });\n\n      expect(\n        getObjectSubset(transitiveCircularObjB, transitiveCircularObjA),\n      ).toEqual(transitiveCircularObjB);\n\n      expect(\n        getObjectSubset(primitiveInsteadOfRef, transitiveCircularObjA),\n      ).toEqual({nestedObj: {otherProp: 'not the parent ref'}});\n      expect(getObjectSubset(nonCircularRef, transitiveCircularObjA)).toEqual({\n        nestedObj: {otherProp: {}},\n      });\n    });\n  });\n});\n\ndescribe('emptyObject()', () => {\n  test('matches an empty object', () => {\n    expect(emptyObject({})).toBe(true);\n  });\n\n  test('does not match an object with keys', () => {\n    expect(emptyObject({foo: undefined})).toBe(false);\n  });\n\n  test('does not match a non-object', () => {\n    expect(emptyObject(null)).toBe(false);\n    expect(emptyObject(34)).toBe(false);\n  });\n});\n\ndescribe('subsetEquality()', () => {\n  test('matching object returns true', () => {\n    expect(subsetEquality({foo: 'bar'}, {foo: 'bar'})).toBe(true);\n  });\n\n  test('object without keys is undefined', () => {\n    expect(subsetEquality('foo', 'bar')).toBeUndefined();\n  });\n\n  test('objects to not match', () => {\n    expect(subsetEquality({foo: 'bar'}, {foo: 'baz'})).toBe(false);\n    expect(subsetEquality('foo', {foo: 'baz'})).toBe(false);\n  });\n\n  test('null does not return errors', () => {\n    expect(subsetEquality(null, {foo: 'bar'})).not.toBeTruthy();\n  });\n\n  test('undefined does not return errors', () => {\n    expect(subsetEquality(undefined, {foo: 'bar'})).not.toBeTruthy();\n  });\n\n  describe('matching subsets with circular references', () => {\n    test('simple circular references', () => {\n      type CircularObj = {a?: string; ref?: unknown};\n\n      const circularObjA1: CircularObj = {a: 'hello'};\n      circularObjA1.ref = circularObjA1;\n\n      const circularObjA2: CircularObj = {a: 'hello'};\n      circularObjA2.ref = circularObjA2;\n\n      const circularObjB: CircularObj = {a: 'world'};\n      circularObjB.ref = circularObjB;\n\n      const primitiveInsteadOfRef: CircularObj = {};\n      primitiveInsteadOfRef.ref = 'not a ref';\n\n      expect(subsetEquality(circularObjA1, {})).toBe(true);\n      expect(subsetEquality({}, circularObjA1)).toBe(false);\n      expect(subsetEquality(circularObjA2, circularObjA1)).toBe(true);\n      expect(subsetEquality(circularObjB, circularObjA1)).toBe(false);\n      expect(subsetEquality(primitiveInsteadOfRef, circularObjA1)).toBe(false);\n    });\n\n    test('referenced object on same level should not regarded as circular reference', () => {\n      const referencedObj = {abc: 'def'};\n      const object = {\n        a: {abc: 'def'},\n        b: {abc: 'def', zzz: 'zzz'},\n      };\n      const thisIsNotCircular = {\n        a: referencedObj,\n        b: referencedObj,\n      };\n      expect(subsetEquality(object, thisIsNotCircular)).toBeTruthy();\n    });\n\n    test('transitive circular references', () => {\n      type CircularObj = {a: string; nestedObj?: unknown};\n\n      const transitiveCircularObjA1: CircularObj = {a: 'hello'};\n      transitiveCircularObjA1.nestedObj = {parentObj: transitiveCircularObjA1};\n\n      const transitiveCircularObjA2: CircularObj = {a: 'hello'};\n      transitiveCircularObjA2.nestedObj = {\n        parentObj: transitiveCircularObjA2,\n      };\n\n      const transitiveCircularObjB: CircularObj = {a: 'world'};\n      transitiveCircularObjB.nestedObj = {\n        parentObj: transitiveCircularObjB,\n      };\n\n      const primitiveInsteadOfRef = {\n        parentObj: 'not the parent ref',\n      };\n\n      expect(subsetEquality(transitiveCircularObjA1, {})).toBe(true);\n      expect(subsetEquality({}, transitiveCircularObjA1)).toBe(false);\n      expect(\n        subsetEquality(transitiveCircularObjA2, transitiveCircularObjA1),\n      ).toBe(true);\n      expect(\n        subsetEquality(transitiveCircularObjB, transitiveCircularObjA1),\n      ).toBe(false);\n      expect(\n        subsetEquality(primitiveInsteadOfRef, transitiveCircularObjA1),\n      ).toBe(false);\n    });\n  });\n\n  describe('matching subsets with symbols', () => {\n    describe('same symbol', () => {\n      test('objects to not match with value diff', () => {\n        const symbol = Symbol('foo');\n        expect(subsetEquality({[symbol]: 1}, {[symbol]: 2})).toBe(false);\n      });\n\n      test('objects to match with non-enumerable symbols', () => {\n        const symbol = Symbol('foo');\n        const foo = {};\n        Object.defineProperty(foo, symbol, {\n          enumerable: false,\n          value: 1,\n        });\n        const bar = {};\n        Object.defineProperty(bar, symbol, {\n          enumerable: false,\n          value: 2,\n        });\n        expect(subsetEquality(foo, bar)).toBe(true);\n      });\n    });\n\n    describe('different symbol', () => {\n      test('objects to not match with same value', () => {\n        expect(subsetEquality({[Symbol('foo')]: 1}, {[Symbol('foo')]: 2})).toBe(\n          false,\n        );\n      });\n      test('objects to match with non-enumerable symbols', () => {\n        const foo = {};\n        Object.defineProperty(foo, Symbol('foo'), {\n          enumerable: false,\n          value: 1,\n        });\n        const bar = {};\n        Object.defineProperty(bar, Symbol('foo'), {\n          enumerable: false,\n          value: 2,\n        });\n        expect(subsetEquality(foo, bar)).toBe(true);\n      });\n    });\n  });\n\n  describe('subset is not object with keys', () => {\n    test('returns true if subset has keys', () => {\n      expect(subsetEquality({foo: 'bar'}, {foo: 'bar'})).toBe(true);\n    });\n    test('returns true if subset has Symbols', () => {\n      const symbol = Symbol('foo');\n      expect(subsetEquality({[symbol]: 'bar'}, {[symbol]: 'bar'})).toBe(true);\n    });\n    test('returns undefined if subset has no keys', () => {\n      expect(subsetEquality('foo', 'bar')).toBeUndefined();\n    });\n    test('returns undefined if subset is null', () => {\n      expect(subsetEquality({foo: 'bar'}, null)).toBeUndefined();\n    });\n    test('returns undefined if subset is Error', () => {\n      expect(subsetEquality({foo: 'bar'}, new Error())).toBeUndefined();\n    });\n    test('returns undefined if subset is Array', () => {\n      expect(subsetEquality({foo: 'bar'}, [])).toBeUndefined();\n    });\n    test('returns undefined if subset is Date', () => {\n      expect(subsetEquality({foo: 'bar'}, new Date())).toBeUndefined();\n    });\n    test('returns undefined if subset is Set', () => {\n      expect(subsetEquality({foo: 'bar'}, new Set())).toBeUndefined();\n    });\n    test('returns undefined if subset is Map', () => {\n      expect(subsetEquality({foo: 'bar'}, new Map())).toBeUndefined();\n    });\n  });\n});\n\ndescribe('iterableEquality', () => {\n  test('returns true when given circular iterators', () => {\n    class Iter {\n      *[Symbol.iterator]() {\n        yield this;\n      }\n    }\n\n    const a = new Iter();\n    const b = new Iter();\n\n    expect(iterableEquality(a, b)).toBe(true);\n  });\n\n  test('returns true when given circular Set', () => {\n    const a = new Set();\n    a.add(a);\n    const b = new Set();\n    b.add(b);\n    expect(iterableEquality(a, b)).toBe(true);\n  });\n\n  test('returns true when given nested Sets', () => {\n    expect(\n      iterableEquality(\n        new Set([new Set([[1]]), new Set([[2]])]),\n        new Set([new Set([[2]]), new Set([[1]])]),\n      ),\n    ).toBe(true);\n    expect(\n      iterableEquality(\n        new Set([new Set([[1]]), new Set([[2]])]),\n        new Set([new Set([[3]]), new Set([[1]])]),\n      ),\n    ).toBe(false);\n  });\n\n  test('returns false when given inequal set within a set', () => {\n    expect(\n      iterableEquality(new Set([new Set([2])]), new Set([new Set([1, 2])])),\n    ).toBe(false);\n    expect(\n      iterableEquality(new Set([new Set([2])]), new Set([new Set([1, 2])])),\n    ).toBe(false);\n  });\n\n  test('returns false when given inequal map within a set', () => {\n    expect(\n      iterableEquality(\n        new Set([new Map([['a', 2]])]),\n        new Set([new Map([['a', 3]])]),\n      ),\n    ).toBe(false);\n    expect(\n      iterableEquality(new Set([new Set([2])]), new Set([new Set([1, 2])])),\n    ).toBe(false);\n  });\n\n  test('returns false when given inequal set within a map', () => {\n    expect(\n      iterableEquality(\n        new Map([['one', new Set([2])]]),\n        new Map([['one', new Set([1, 2])]]),\n      ),\n    ).toBe(false);\n  });\n\n  test('returns true when given iterator within equal objects', () => {\n    const a = {\n      [Symbol.iterator]: () => ({next: () => ({done: true})}),\n      a: [],\n    };\n    const b = {\n      [Symbol.iterator]: () => ({next: () => ({done: true})}),\n      a: [],\n    };\n\n    expect(iterableEquality(a, b)).toBe(true);\n  });\n\n  test('returns false when given iterator within inequal objects', () => {\n    const a = {\n      [Symbol.iterator]: () => ({next: () => ({done: true})}),\n      a: [1],\n    };\n    const b = {\n      [Symbol.iterator]: () => ({next: () => ({done: true})}),\n      a: [],\n    };\n\n    expect(iterableEquality(a, b)).toBe(false);\n  });\n\n  test('returns false when given iterator within inequal nested objects', () => {\n    const a = {\n      [Symbol.iterator]: () => ({next: () => ({done: true})}),\n      a: {\n        b: [1],\n      },\n    };\n    const b = {\n      [Symbol.iterator]: () => ({next: () => ({done: true})}),\n      a: {\n        b: [],\n      },\n    };\n\n    expect(iterableEquality(a, b)).toBe(false);\n  });\n\n  test('returns true when given circular Set shape', () => {\n    const a1 = new Set();\n    const a2 = new Set();\n    a1.add(a2);\n    a2.add(a1);\n    const b = new Set();\n    b.add(b);\n\n    expect(iterableEquality(a1, b)).toBe(true);\n  });\n\n  test('returns true when given circular key in Map', () => {\n    const a = new Map();\n    a.set(a, 'a');\n    const b = new Map();\n    b.set(b, 'a');\n\n    expect(iterableEquality(a, b)).toBe(true);\n  });\n\n  test('returns true when given nested Maps', () => {\n    expect(\n      iterableEquality(\n        new Map([['hello', new Map([['world', 'foobar']])]]),\n        new Map([['hello', new Map([['world', 'qux']])]]),\n      ),\n    ).toBe(false);\n    expect(\n      iterableEquality(\n        new Map([['hello', new Map([['world', 'foobar']])]]),\n        new Map([['hello', new Map([['world', 'foobar']])]]),\n      ),\n    ).toBe(true);\n  });\n\n  test('returns true when given circular key and value in Map', () => {\n    const a = new Map();\n    a.set(a, a);\n    const b = new Map();\n    b.set(b, b);\n\n    expect(iterableEquality(a, b)).toBe(true);\n  });\n\n  test('returns true when given circular value in Map', () => {\n    const a = new Map();\n    a.set('a', a);\n    const b = new Map();\n    b.set('a', b);\n\n    expect(iterableEquality(a, b)).toBe(true);\n  });\n\n  test('returns true when given Immutable Lists without an OwnerID', () => {\n    const a = List([1, 2, 3]);\n    const b = a.filter(v => v > 0);\n\n    expect(iterableEquality(a, b)).toBe(true);\n  });\n\n  test('returns true when given Immutable OrderedMaps without an OwnerID', () => {\n    const a = OrderedMap().set('saving', true);\n    const b = OrderedMap().merge({saving: true});\n    expect(iterableEquality(a, b)).toBe(true);\n  });\n\n  test('returns true when given Immutable OrderedSets without an OwnerID', () => {\n    const a = OrderedSet().add('newValue');\n    const b = List(['newValue']).toOrderedSet();\n    expect(iterableEquality(a, b)).toBe(true);\n  });\n\n  test('returns true when given Immutable Record without an OwnerID', () => {\n    class TestRecord extends Record({dummy: ''}) {}\n    const a = new TestRecord().merge({dummy: 'data'});\n    const b = new TestRecord().set('dummy', 'data');\n    expect(iterableEquality(a, b)).toBe(true);\n  });\n\n  test('returns true when given a symbols keys within equal objects', () => {\n    const KEY = Symbol();\n\n    const a = {\n      [Symbol.iterator]: () => ({next: () => ({done: true})}),\n      [KEY]: [],\n    };\n    const b = {\n      [Symbol.iterator]: () => ({next: () => ({done: true})}),\n      [KEY]: [],\n    };\n\n    expect(iterableEquality(a, b)).toBe(true);\n  });\n\n  test('returns false when given a symbols keys within inequal objects', () => {\n    const KEY = Symbol();\n\n    const a = {\n      [Symbol.iterator]: () => ({next: () => ({done: true})}),\n      [KEY]: [1],\n    };\n    const b = {\n      [Symbol.iterator]: () => ({next: () => ({done: true})}),\n      [KEY]: [],\n    };\n\n    expect(iterableEquality(a, b)).toBe(false);\n  });\n});\n\ndescribe('typeEquality', () => {\n  test('returns undefined if given mock.calls and []', () => {\n    expect(typeEquality(jest.fn().mock.calls, [])).toBeUndefined();\n  });\n});\n\ndescribe('arrayBufferEquality', () => {\n  test('returns undefined if given a non instance of ArrayBuffer', () => {\n    expect(arrayBufferEquality(2, 's')).toBeUndefined();\n    expect(arrayBufferEquality(undefined, 2)).toBeUndefined();\n    expect(arrayBufferEquality(new Date(), new ArrayBuffer(2))).toBeUndefined();\n  });\n\n  test('returns false when given non-matching buffers', () => {\n    const a = Uint8Array.from([2, 4]).buffer;\n    const b = Uint16Array.from([1, 7]).buffer;\n    expect(arrayBufferEquality(a, b)).toBe(false);\n  });\n\n  test('returns false when given matching buffers of different byte length', () => {\n    const a = Uint8Array.from([1, 2]).buffer;\n    const b = Uint16Array.from([1, 2]).buffer;\n    expect(arrayBufferEquality(a, b)).toBe(false);\n  });\n\n  test('returns true when given matching buffers', () => {\n    const a = Uint8Array.from([1, 2]).buffer;\n    const b = Uint8Array.from([1, 2]).buffer;\n    expect(arrayBufferEquality(a, b)).toBe(true);\n  });\n\n  test('returns true when given matching DataView', () => {\n    const a = new DataView(Uint8Array.from([1, 2, 3]).buffer);\n    const b = new DataView(Uint8Array.from([1, 2, 3]).buffer);\n    expect(arrayBufferEquality(a, b)).toBe(true);\n  });\n\n  test('returns false when given non-matching DataView', () => {\n    const a = new DataView(Uint8Array.from([1, 2, 3]).buffer);\n    const b = new DataView(Uint8Array.from([3, 2, 1]).buffer);\n    expect(arrayBufferEquality(a, b)).toBe(false);\n  });\n\n  test('returns true when given matching Float64Array', () => {\n    const a = Float64Array.from(Array.from({length: 10}));\n    const b = Float64Array.from(Array.from({length: 10}));\n    expect(arrayBufferEquality(a, b)).toBe(true);\n  });\n\n  test('returns false when given non-matching Float64Array', () => {\n    const a = Float64Array.from(Array.from({length: 10}));\n    const b = Float64Array.from(Array.from({length: 100}));\n    expect(arrayBufferEquality(a, b)).toBe(false);\n  });\n\n  test('returns true when given matching URL', () => {\n    const a = new URL('https://jestjs.io/');\n    const b = new URL('https://jestjs.io/');\n    expect(equals(a, b)).toBe(true);\n  });\n\n  test('returns false when given non-matching URL', () => {\n    const a = new URL('https://jestjs.io/docs/getting-started');\n    const b = new URL('https://jestjs.io/docs/getting-started#using-babel');\n    expect(equals(a, b)).toBe(false);\n  });\n});\n\ndescribe('jasmineUtils primitives comparison', () => {\n  const falseCases: Array<[any, any]> = [\n    [null, undefined],\n    [null, 0],\n    [false, 0],\n    [false, ''],\n  ];\n\n  for (const [a, b] of falseCases) {\n    test(`${JSON.stringify(a)} and ${JSON.stringify(b)} returns false`, () => {\n      expect(equals(a, b)).toBe(false);\n    });\n  }\n\n  const trueCases: Array<any> = [null, 0, false, '', undefined];\n\n  for (const value of trueCases) {\n    test(`${JSON.stringify(value)} returns true`, () => {\n      expect(equals(value, value)).toBe(true);\n    });\n  }\n});\n",
  "packages/expect-utils/src/__tests__/utils.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport {};\n",
  "packages/expect-utils/src/__tests__/isError.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @jest-environment jsdom\n */\n\n/// <reference lib=\"dom\" />\n\nimport {isError} from '../utils';\n\n// Copied from https://github.com/graingert/angular.js/blob/a43574052e9775cbc1d7dd8a086752c979b0f020/test/AngularSpec.js#L1883\ndescribe('isError', () => {\n  function testErrorFromDifferentContext(\n    createError: (win: Window | typeof globalThis) => Error | null,\n  ) {\n    const iframe = document.createElement('iframe');\n    document.body.append(iframe);\n    try {\n      const contentWindow = iframe.contentWindow;\n\n      expect(contentWindow).toBeTruthy();\n\n      if (!contentWindow) {\n        throw new Error('Dead code');\n      }\n\n      const error = createError(contentWindow);\n      expect(isError(error)).toBe(true);\n    } finally {\n      iframe.remove();\n    }\n  }\n\n  it('should not assume objects are errors', () => {\n    const fakeError = {message: 'A fake error', stack: 'no stack here'};\n    expect(isError(fakeError)).toBe(false);\n  });\n\n  it('should detect simple error instances', () => {\n    expect(isError(new Error())).toBe(true);\n  });\n\n  it('should detect errors from another context', () => {\n    testErrorFromDifferentContext(\n      win => new (win as typeof globalThis).Error(),\n    );\n  });\n\n  it('should detect DOMException errors from another context', () => {\n    testErrorFromDifferentContext(win => {\n      try {\n        win.document.querySelectorAll('');\n      } catch (error) {\n        return error as Error;\n      }\n\n      return null;\n    });\n  });\n});\n",
  "packages/expect-utils/src/__tests__/isError.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @jest-environment jsdom\n */\nexport {};\n",
  "packages/expect-utils/__typetests__/utils.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {expect, test} from 'tstyche';\nimport {isA} from '@jest/expect-utils';\n\ntest('isA', () => {\n  expect(isA('String', 'default')).type.toBe<boolean>();\n  expect(isA<number>('Number', 123)).type.toBe<boolean>();\n\n  const sample = {} as unknown;\n\n  if (isA('String', sample)) {\n    expect(sample).type.toBe<unknown>();\n  }\n\n  if (isA<string>('String', sample)) {\n    expect(sample).type.toBe<string>();\n  }\n\n  if (isA<number>('Number', sample)) {\n    expect(sample).type.toBe<number>();\n  }\n\n  if (isA<Map<unknown, unknown>>('Map', sample)) {\n    expect(sample).type.toBe<Map<unknown, unknown>>();\n  }\n\n  if (isA<Set<unknown>>('Set', sample)) {\n    expect(sample).type.toBe<Set<unknown>>();\n  }\n});\n",
  "packages/expect-utils/__typetests__/utils.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/expect/src/types.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {EqualsFunction, Tester} from '@jest/expect-utils';\nimport type * as jestMatcherUtils from 'jest-matcher-utils';\nimport type {MockInstance} from 'jest-mock';\nimport type {INTERNAL_MATCHER_FLAG} from './jestMatchersObject';\n\nexport type SyncExpectationResult = {\n  pass: boolean;\n  message(): string;\n};\n\nexport type AsyncExpectationResult = Promise<SyncExpectationResult>;\n\nexport type ExpectationResult = SyncExpectationResult | AsyncExpectationResult;\n\nexport type MatcherFunctionWithContext<\n  Context extends MatcherContext = MatcherContext,\n  Expected extends\n    Array<any> = [] /** TODO should be: extends Array<unknown> = [] */,\n> = (\n  this: Context,\n  actual: unknown,\n  ...expected: Expected\n) => ExpectationResult;\n\nexport type MatcherFunction<Expected extends Array<unknown> = []> =\n  MatcherFunctionWithContext<MatcherContext, Expected>;\n\n// TODO should be replaced with `MatcherFunctionWithContext`\nexport type RawMatcherFn<Context extends MatcherContext = MatcherContext> = {\n  (this: Context, actual: any, ...expected: Array<any>): ExpectationResult;\n  /** @internal */\n  [INTERNAL_MATCHER_FLAG]?: boolean;\n};\n\nexport type MatchersObject = {\n  [name: string]: RawMatcherFn;\n};\n\nexport type ThrowingMatcherFn = (actual: any) => void;\nexport type PromiseMatcherFn = (actual: any) => Promise<void>;\n\nexport interface MatcherUtils {\n  customTesters: Array<Tester>;\n  dontThrow(): void;\n  equals: EqualsFunction;\n  utils: typeof jestMatcherUtils & {\n    iterableEquality: Tester;\n    subsetEquality: Tester;\n  };\n}\n\nexport interface MatcherState {\n  assertionCalls: number;\n  currentConcurrentTestName?: () => string | undefined;\n  currentTestName?: string;\n  error?: Error;\n  expand?: boolean;\n  expectedAssertionsNumber: number | null;\n  expectedAssertionsNumberError?: Error;\n  isExpectingAssertions: boolean;\n  isExpectingAssertionsError?: Error;\n  isNot?: boolean;\n  numPassingAsserts: number;\n  promise?: string;\n  suppressedErrors: Array<Error>;\n  testPath?: string;\n}\n\nexport type MatcherContext = MatcherUtils & Readonly<MatcherState>;\n\nexport type AsymmetricMatcher = {\n  asymmetricMatch(other: unknown): boolean;\n  toString(): string;\n  getExpectedType?(): string;\n  toAsymmetricMatcher?(): string;\n};\n\nexport type ExpectedAssertionsErrors = Array<{\n  actual: string | number;\n  error: Error;\n  expected: string;\n}>;\n\nexport interface BaseExpect {\n  assertions(numberOfAssertions: number): void;\n  addEqualityTesters(testers: Array<Tester>): void;\n  extend(matchers: MatchersObject): void;\n  extractExpectedAssertionsErrors(): ExpectedAssertionsErrors;\n  getState(): MatcherState;\n  hasAssertions(): void;\n  setState(state: Partial<MatcherState>): void;\n}\n\nexport type Expect = (<T = unknown>(\n  actual: T,\n) => Matchers<void, T> & Inverse<Matchers<void, T>> & PromiseMatchers<T>) &\n  BaseExpect &\n  AsymmetricMatchers &\n  Inverse<Omit<AsymmetricMatchers, 'any' | 'anything'>>;\n\nexport type Inverse<Matchers> = {\n  /**\n   * Inverse next matcher. If you know how to test something, `.not` lets you test its opposite.\n   */\n  not: Matchers;\n};\n\nexport interface AsymmetricMatchers {\n  any(sample: unknown): AsymmetricMatcher;\n  anything(): AsymmetricMatcher;\n  arrayContaining(sample: Array<unknown>): AsymmetricMatcher;\n  arrayOf(sample: unknown): AsymmetricMatcher;\n  closeTo(sample: number, precision?: number): AsymmetricMatcher;\n  objectContaining(sample: Record<string, unknown>): AsymmetricMatcher;\n  stringContaining(sample: string): AsymmetricMatcher;\n  stringMatching(sample: string | RegExp): AsymmetricMatcher;\n}\n\ntype PromiseMatchers<T = unknown> = {\n  /**\n   * Unwraps the reason of a rejected promise so any other matcher can be chained.\n   * If the promise is fulfilled the assertion fails.\n   */\n  rejects: Matchers<Promise<void>, T> & Inverse<Matchers<Promise<void>, T>>;\n  /**\n   * Unwraps the value of a fulfilled promise so any other matcher can be chained.\n   * If the promise is rejected the assertion fails.\n   */\n  resolves: Matchers<Promise<void>, T> & Inverse<Matchers<Promise<void>, T>>;\n};\n\nexport interface Matchers<R extends void | Promise<void>, T = unknown> {\n  /**\n   * T is a type param for the benefit of users who extend Matchers. It's\n   * intentionally unused and needs to be named T, not _T, for those users.\n   * This makes sure TypeScript agrees.\n   *\n   * @internal\n   */\n  _unusedT(expected: T): R;\n  /**\n   * Checks that a value is what you expect. It calls `Object.is` to compare values.\n   * Don't use `toBe` with floating-point numbers.\n   */\n  toBe(expected: unknown): R;\n  /**\n   * Using exact equality with floating point numbers is a bad idea.\n   * Rounding means that intuitive things fail.\n   * The default for `precision` is 2.\n   */\n  toBeCloseTo(expected: number, precision?: number): R;\n  /**\n   * Ensure that a variable is not undefined.\n   */\n  toBeDefined(): R;\n  /**\n   * When you don't care what a value is, you just want to\n   * ensure a value is false in a boolean context.\n   */\n  toBeFalsy(): R;\n  /**\n   * For comparing floating point numbers.\n   */\n  toBeGreaterThan(expected: number | bigint): R;\n  /**\n   * For comparing floating point numbers.\n   */\n  toBeGreaterThanOrEqual(expected: number | bigint): R;\n  /**\n   * Ensure that an object is an instance of a class.\n   * This matcher uses `instanceof` underneath.\n   */\n  toBeInstanceOf(expected: unknown): R;\n  /**\n   * For comparing floating point numbers.\n   */\n  toBeLessThan(expected: number | bigint): R;\n  /**\n   * For comparing floating point numbers.\n   */\n  toBeLessThanOrEqual(expected: number | bigint): R;\n  /**\n   * Used to check that a variable is NaN.\n   */\n  toBeNaN(): R;\n  /**\n   * This is the same as `.toBe(null)` but the error messages are a bit nicer.\n   * So use `.toBeNull()` when you want to check that something is null.\n   */\n  toBeNull(): R;\n  /**\n   * Use when you don't care what a value is, you just want to ensure a value\n   * is true in a boolean context. In JavaScript, there are six falsy values:\n   * `false`, `0`, `''`, `null`, `undefined`, and `NaN`. Everything else is truthy.\n   */\n  toBeTruthy(): R;\n  /**\n   * Used to check that a variable is undefined.\n   */\n  toBeUndefined(): R;\n  /**\n   * Used when you want to check that an item is in a list.\n   * For testing the items in the list, this uses `===`, a strict equality check.\n   */\n  toContain(expected: unknown): R;\n  /**\n   * Used when you want to check that an item is in a list.\n   * For testing the items in the list, this  matcher recursively checks the\n   * equality of all fields, rather than checking for object identity.\n   */\n  toContainEqual(expected: unknown): R;\n  /**\n   * Used when you want to check that two objects have the same value.\n   * This matcher recursively checks the equality of all fields, rather than checking for object identity.\n   */\n  toEqual(expected: unknown): R;\n  /**\n   * Ensures that a mock function is called.\n   */\n  toHaveBeenCalled(): R;\n  /**\n   * Ensures that a mock function is called an exact number of times.\n   */\n  toHaveBeenCalledTimes(expected: number): R;\n  /**\n   * Ensure that a mock function is called with specific arguments.\n   */\n  toHaveBeenCalledWith(...expected: MockParameters<T>): R;\n  /**\n   * Ensure that a mock function is called with specific arguments on an Nth call.\n   */\n  toHaveBeenNthCalledWith(nth: number, ...expected: MockParameters<T>): R;\n  /**\n   * If you have a mock function, you can use `.toHaveBeenLastCalledWith`\n   * to test what arguments it was last called with.\n   */\n  toHaveBeenLastCalledWith(...expected: MockParameters<T>): R;\n  /**\n   * Use to test the specific value that a mock function last returned.\n   * If the last call to the mock function threw an error, then this matcher will fail\n   * no matter what value you provided as the expected return value.\n   */\n  toHaveLastReturnedWith(expected?: unknown): R;\n  /**\n   * Used to check that an object has a `.length` property\n   * and it is set to a certain numeric value.\n   */\n  toHaveLength(expected: number): R;\n  /**\n   * Use to test the specific value that a mock function returned for the nth call.\n   * If the nth call to the mock function threw an error, then this matcher will fail\n   * no matter what value you provided as the expected return value.\n   */\n  toHaveNthReturnedWith(nth: number, expected?: unknown): R;\n  /**\n   * Use to check if property at provided reference keyPath exists for an object.\n   * For checking deeply nested properties in an object you may use dot notation or an array containing\n   * the keyPath for deep references.\n   *\n   * Optionally, you can provide a value to check if it's equal to the value present at keyPath\n   * on the target object. This matcher uses 'deep equality' (like `toEqual()`) and recursively checks\n   * the equality of all fields.\n   *\n   * @example\n   *\n   * expect(houseForSale).toHaveProperty('kitchen.area', 20);\n   */\n  toHaveProperty(\n    expectedPath: string | Array<string>,\n    expectedValue?: unknown,\n  ): R;\n  /**\n   * Use to test that the mock function successfully returned (i.e., did not throw an error) at least one time\n   */\n  toHaveReturned(): R;\n  /**\n   * Use to ensure that a mock function returned successfully (i.e., did not throw an error) an exact number of times.\n   * Any calls to the mock function that throw an error are not counted toward the number of times the function returned.\n   */\n  toHaveReturnedTimes(expected: number): R;\n  /**\n   * Use to ensure that a mock function returned a specific value.\n   */\n  toHaveReturnedWith(expected?: unknown): R;\n  /**\n   * Check that a string matches a regular expression.\n   */\n  toMatch(expected: string | RegExp): R;\n  /**\n   * Used to check that a JavaScript object matches a subset of the properties of an object\n   */\n  toMatchObject(\n    expected: Record<string, unknown> | Array<Record<string, unknown>>,\n  ): R;\n  /**\n   * Use to test that objects have the same types as well as structure.\n   */\n  toStrictEqual(expected: unknown): R;\n  /**\n   * Used to test that a function throws when it is called.\n   */\n  toThrow(expected?: unknown): R;\n}\n\n/**\n * Obtains the parameters of the given function or {@link MockInstance}'s function type.\n * ```ts\n * type P = MockParameters<MockInstance<(foo: number) => void>>;\n * // or without an explicit mock\n * // type P = MockParameters<(foo: number) => void>;\n *\n * const params1: P = [1]; // compiles\n * const params2: P = ['bar']; // error\n * const params3: P = []; // error\n * ```\n *\n * This is similar to {@link Parameters}, with these notable differences:\n *\n * 1. Each of the parameters can also accept an {@link AsymmetricMatcher}.\n * ```ts\n * const params4: P = [expect.anything()]; // compiles\n * ```\n * This works with nested types as well:\n * ```ts\n * type Nested = MockParameters<MockInstance<(foo: { a: number }, bar: [string]) => void>>;\n *\n * const params1: Nested = [{ foo: { a: 1 }}, ['value']]; // compiles\n * const params2: Nested = [expect.anything(), expect.anything()]; // compiles\n * const params3: Nested = [{ foo: { a: expect.anything() }}, [expect.anything()]]; // compiles\n * ```\n *\n * 2. This type works with overloaded functions (up to 15 overloads):\n * ```ts\n * function overloaded(): void;\n * function overloaded(foo: number): void;\n * function overloaded(foo: number, bar: string): void;\n * function overloaded(foo?: number, bar?: string): void {}\n *\n * type Overloaded = MockParameters<MockInstance<typeof overloaded>>;\n *\n * const params1: Overloaded = []; // compiles\n * const params2: Overloaded = [1]; // compiles\n * const params3: Overloaded = [1, 'value']; // compiles\n * const params4: Overloaded = ['value']; // error\n * const params5: Overloaded = ['value', 1]; // error\n * ```\n *\n * Mocks generated with the default `MockInstance` type will evaluate to `Array<unknown>`:\n * ```ts\n * MockParameters<MockInstance> // Array<unknown>\n * ```\n *\n * If the given type is not a `MockInstance` nor a function, this type will evaluate to `Array<unknown>`:\n * ```ts\n * MockParameters<boolean> // Array<unknown>\n * ```\n */\ntype MockParameters<M> =\n  M extends MockInstance<infer F>\n    ? FunctionParameters<F>\n    : FunctionParameters<M>;\n\n/**\n * A wrapper over `FunctionParametersInternal` which converts `never` evaluations to `Array<unknown>`.\n *\n * This is only necessary for Typescript versions prior to 5.3.\n *\n * In those versions, a function without parameters (`() => any`) is interpreted the same as an overloaded function,\n * causing `FunctionParametersInternal` to evaluate it to `[] | Array<unknown>`, which is incorrect.\n *\n * The workaround is to \"catch\" this edge-case in `WithAsymmetricMatchers` and interpret it as `never`.\n * However, this also affects {@link UnknownFunction} (the default generic type of `MockInstance`):\n * ```ts\n * FunctionParametersInternal<() => any> // [] | never --> [] --> correct\n * FunctionParametersInternal<UnknownFunction> // never --> incorrect\n * ```\n * An empty array is the expected type for a function without parameters,\n * so all that's left is converting `never` to `Array<unknown>` for the case of `UnknownFunction`,\n * as it needs to accept _any_ combination of parameters.\n */\ntype FunctionParameters<F> =\n  FunctionParametersInternal<F> extends never\n    ? Array<unknown>\n    : FunctionParametersInternal<F>;\n\n/**\n * 1. If the function is overloaded or has no parameters -> overloaded form (union of tuples).\n * 2. If the function has parameters -> simple form.\n * 3. else -> `never`.\n */\ntype FunctionParametersInternal<F> = F extends {\n  (...args: infer P1): any;\n  (...args: infer P2): any;\n  (...args: infer P3): any;\n  (...args: infer P4): any;\n  (...args: infer P5): any;\n  (...args: infer P6): any;\n  (...args: infer P7): any;\n  (...args: infer P8): any;\n  (...args: infer P9): any;\n  (...args: infer P10): any;\n  (...args: infer P11): any;\n  (...args: infer P12): any;\n  (...args: infer P13): any;\n  (...args: infer P14): any;\n  (...args: infer P15): any;\n}\n  ?\n      | WithAsymmetricMatchers<P1>\n      | WithAsymmetricMatchers<P2>\n      | WithAsymmetricMatchers<P3>\n      | WithAsymmetricMatchers<P4>\n      | WithAsymmetricMatchers<P5>\n      | WithAsymmetricMatchers<P6>\n      | WithAsymmetricMatchers<P7>\n      | WithAsymmetricMatchers<P8>\n      | WithAsymmetricMatchers<P9>\n      | WithAsymmetricMatchers<P10>\n      | WithAsymmetricMatchers<P11>\n      | WithAsymmetricMatchers<P12>\n      | WithAsymmetricMatchers<P13>\n      | WithAsymmetricMatchers<P14>\n      | WithAsymmetricMatchers<P15>\n  : F extends (...args: infer P) => any\n    ? WithAsymmetricMatchers<P>\n    : never;\n\n/**\n * @see FunctionParameters\n */\ntype WithAsymmetricMatchers<P extends Array<any>> =\n  Array<unknown> extends P\n    ? never\n    : {[K in keyof P]: DeepAsymmetricMatcher<P[K]>};\n\n/**\n * Replaces `T` with `T | AsymmetricMatcher`.\n *\n * If `T` is an object or an array, recursively replaces all nested types with the same logic:\n * ```ts\n * type DeepAsymmetricMatcher<boolean>; // AsymmetricMatcher | boolean\n * type DeepAsymmetricMatcher<{ foo: number }>; // AsymmetricMatcher | { foo: AsymmetricMatcher | number }\n * type DeepAsymmetricMatcher<[string]>; // AsymmetricMatcher | [AsymmetricMatcher | string]\n * ```\n */\ntype DeepAsymmetricMatcher<T> = T extends object\n  ? AsymmetricMatcher | {[K in keyof T]: DeepAsymmetricMatcher<T[K]>}\n  : AsymmetricMatcher | T;\n",
  "packages/expect/src/types.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport type { EqualsFunction, Tester } from '@jest/expect-utils';\nimport type * as jestMatcherUtils from 'jest-matcher-utils';\nimport type { MockInstance } from 'jest-mock';\nexport type SyncExpectationResult = {\n    pass: boolean;\n    message(): string;\n};\nexport type AsyncExpectationResult = Promise<SyncExpectationResult>;\nexport type ExpectationResult = SyncExpectationResult | AsyncExpectationResult;\nexport type MatcherFunctionWithContext<Context extends MatcherContext = MatcherContext, Expected extends Array<any> = [] /** TODO should be: extends Array<unknown> = [] */> = (this: Context, actual: unknown, ...expected: Expected) => ExpectationResult;\nexport type MatcherFunction<Expected extends Array<unknown> = []> = MatcherFunctionWithContext<MatcherContext, Expected>;\nexport type RawMatcherFn<Context extends MatcherContext = MatcherContext> = {\n    (this: Context, actual: any, ...expected: Array<any>): ExpectationResult;\n};\nexport type MatchersObject = {\n    [name: string]: RawMatcherFn;\n};\nexport type ThrowingMatcherFn = (actual: any) => void;\nexport type PromiseMatcherFn = (actual: any) => Promise<void>;\nexport interface MatcherUtils {\n    customTesters: Array<Tester>;\n    dontThrow(): void;\n    equals: EqualsFunction;\n    utils: typeof jestMatcherUtils & {\n        iterableEquality: Tester;\n        subsetEquality: Tester;\n    };\n}\nexport interface MatcherState {\n    assertionCalls: number;\n    currentConcurrentTestName?: () => string | undefined;\n    currentTestName?: string;\n    error?: Error;\n    expand?: boolean;\n    expectedAssertionsNumber: number | null;\n    expectedAssertionsNumberError?: Error;\n    isExpectingAssertions: boolean;\n    isExpectingAssertionsError?: Error;\n    isNot?: boolean;\n    numPassingAsserts: number;\n    promise?: string;\n    suppressedErrors: Array<Error>;\n    testPath?: string;\n}\nexport type MatcherContext = MatcherUtils & Readonly<MatcherState>;\nexport type AsymmetricMatcher = {\n    asymmetricMatch(other: unknown): boolean;\n    toString(): string;\n    getExpectedType?(): string;\n    toAsymmetricMatcher?(): string;\n};\nexport type ExpectedAssertionsErrors = Array<{\n    actual: string | number;\n    error: Error;\n    expected: string;\n}>;\nexport interface BaseExpect {\n    assertions(numberOfAssertions: number): void;\n    addEqualityTesters(testers: Array<Tester>): void;\n    extend(matchers: MatchersObject): void;\n    extractExpectedAssertionsErrors(): ExpectedAssertionsErrors;\n    getState(): MatcherState;\n    hasAssertions(): void;\n    setState(state: Partial<MatcherState>): void;\n}\nexport type Expect = (<T = unknown>(actual: T) => Matchers<void, T> & Inverse<Matchers<void, T>> & PromiseMatchers<T>) & BaseExpect & AsymmetricMatchers & Inverse<Omit<AsymmetricMatchers, 'any' | 'anything'>>;\nexport type Inverse<Matchers> = {\n    /**\n     * Inverse next matcher. If you know how to test something, `.not` lets you test its opposite.\n     */\n    not: Matchers;\n};\nexport interface AsymmetricMatchers {\n    any(sample: unknown): AsymmetricMatcher;\n    anything(): AsymmetricMatcher;\n    arrayContaining(sample: Array<unknown>): AsymmetricMatcher;\n    arrayOf(sample: unknown): AsymmetricMatcher;\n    closeTo(sample: number, precision?: number): AsymmetricMatcher;\n    objectContaining(sample: Record<string, unknown>): AsymmetricMatcher;\n    stringContaining(sample: string): AsymmetricMatcher;\n    stringMatching(sample: string | RegExp): AsymmetricMatcher;\n}\ntype PromiseMatchers<T = unknown> = {\n    /**\n     * Unwraps the reason of a rejected promise so any other matcher can be chained.\n     * If the promise is fulfilled the assertion fails.\n     */\n    rejects: Matchers<Promise<void>, T> & Inverse<Matchers<Promise<void>, T>>;\n    /**\n     * Unwraps the value of a fulfilled promise so any other matcher can be chained.\n     * If the promise is rejected the assertion fails.\n     */\n    resolves: Matchers<Promise<void>, T> & Inverse<Matchers<Promise<void>, T>>;\n};\nexport interface Matchers<R extends void | Promise<void>, T = unknown> {\n    /**\n     * Checks that a value is what you expect. It calls `Object.is` to compare values.\n     * Don't use `toBe` with floating-point numbers.\n     */\n    toBe(expected: unknown): R;\n    /**\n     * Using exact equality with floating point numbers is a bad idea.\n     * Rounding means that intuitive things fail.\n     * The default for `precision` is 2.\n     */\n    toBeCloseTo(expected: number, precision?: number): R;\n    /**\n     * Ensure that a variable is not undefined.\n     */\n    toBeDefined(): R;\n    /**\n     * When you don't care what a value is, you just want to\n     * ensure a value is false in a boolean context.\n     */\n    toBeFalsy(): R;\n    /**\n     * For comparing floating point numbers.\n     */\n    toBeGreaterThan(expected: number | bigint): R;\n    /**\n     * For comparing floating point numbers.\n     */\n    toBeGreaterThanOrEqual(expected: number | bigint): R;\n    /**\n     * Ensure that an object is an instance of a class.\n     * This matcher uses `instanceof` underneath.\n     */\n    toBeInstanceOf(expected: unknown): R;\n    /**\n     * For comparing floating point numbers.\n     */\n    toBeLessThan(expected: number | bigint): R;\n    /**\n     * For comparing floating point numbers.\n     */\n    toBeLessThanOrEqual(expected: number | bigint): R;\n    /**\n     * Used to check that a variable is NaN.\n     */\n    toBeNaN(): R;\n    /**\n     * This is the same as `.toBe(null)` but the error messages are a bit nicer.\n     * So use `.toBeNull()` when you want to check that something is null.\n     */\n    toBeNull(): R;\n    /**\n     * Use when you don't care what a value is, you just want to ensure a value\n     * is true in a boolean context. In JavaScript, there are six falsy values:\n     * `false`, `0`, `''`, `null`, `undefined`, and `NaN`. Everything else is truthy.\n     */\n    toBeTruthy(): R;\n    /**\n     * Used to check that a variable is undefined.\n     */\n    toBeUndefined(): R;\n    /**\n     * Used when you want to check that an item is in a list.\n     * For testing the items in the list, this uses `===`, a strict equality check.\n     */\n    toContain(expected: unknown): R;\n    /**\n     * Used when you want to check that an item is in a list.\n     * For testing the items in the list, this  matcher recursively checks the\n     * equality of all fields, rather than checking for object identity.\n     */\n    toContainEqual(expected: unknown): R;\n    /**\n     * Used when you want to check that two objects have the same value.\n     * This matcher recursively checks the equality of all fields, rather than checking for object identity.\n     */\n    toEqual(expected: unknown): R;\n    /**\n     * Ensures that a mock function is called.\n     */\n    toHaveBeenCalled(): R;\n    /**\n     * Ensures that a mock function is called an exact number of times.\n     */\n    toHaveBeenCalledTimes(expected: number): R;\n    /**\n     * Ensure that a mock function is called with specific arguments.\n     */\n    toHaveBeenCalledWith(...expected: MockParameters<T>): R;\n    /**\n     * Ensure that a mock function is called with specific arguments on an Nth call.\n     */\n    toHaveBeenNthCalledWith(nth: number, ...expected: MockParameters<T>): R;\n    /**\n     * If you have a mock function, you can use `.toHaveBeenLastCalledWith`\n     * to test what arguments it was last called with.\n     */\n    toHaveBeenLastCalledWith(...expected: MockParameters<T>): R;\n    /**\n     * Use to test the specific value that a mock function last returned.\n     * If the last call to the mock function threw an error, then this matcher will fail\n     * no matter what value you provided as the expected return value.\n     */\n    toHaveLastReturnedWith(expected?: unknown): R;\n    /**\n     * Used to check that an object has a `.length` property\n     * and it is set to a certain numeric value.\n     */\n    toHaveLength(expected: number): R;\n    /**\n     * Use to test the specific value that a mock function returned for the nth call.\n     * If the nth call to the mock function threw an error, then this matcher will fail\n     * no matter what value you provided as the expected return value.\n     */\n    toHaveNthReturnedWith(nth: number, expected?: unknown): R;\n    /**\n     * Use to check if property at provided reference keyPath exists for an object.\n     * For checking deeply nested properties in an object you may use dot notation or an array containing\n     * the keyPath for deep references.\n     *\n     * Optionally, you can provide a value to check if it's equal to the value present at keyPath\n     * on the target object. This matcher uses 'deep equality' (like `toEqual()`) and recursively checks\n     * the equality of all fields.\n     *\n     * @example\n     *\n     * expect(houseForSale).toHaveProperty('kitchen.area', 20);\n     */\n    toHaveProperty(expectedPath: string | Array<string>, expectedValue?: unknown): R;\n    /**\n     * Use to test that the mock function successfully returned (i.e., did not throw an error) at least one time\n     */\n    toHaveReturned(): R;\n    /**\n     * Use to ensure that a mock function returned successfully (i.e., did not throw an error) an exact number of times.\n     * Any calls to the mock function that throw an error are not counted toward the number of times the function returned.\n     */\n    toHaveReturnedTimes(expected: number): R;\n    /**\n     * Use to ensure that a mock function returned a specific value.\n     */\n    toHaveReturnedWith(expected?: unknown): R;\n    /**\n     * Check that a string matches a regular expression.\n     */\n    toMatch(expected: string | RegExp): R;\n    /**\n     * Used to check that a JavaScript object matches a subset of the properties of an object\n     */\n    toMatchObject(expected: Record<string, unknown> | Array<Record<string, unknown>>): R;\n    /**\n     * Use to test that objects have the same types as well as structure.\n     */\n    toStrictEqual(expected: unknown): R;\n    /**\n     * Used to test that a function throws when it is called.\n     */\n    toThrow(expected?: unknown): R;\n}\n/**\n * Obtains the parameters of the given function or {@link MockInstance}'s function type.\n * ```ts\n * type P = MockParameters<MockInstance<(foo: number) => void>>;\n * // or without an explicit mock\n * // type P = MockParameters<(foo: number) => void>;\n *\n * const params1: P = [1]; // compiles\n * const params2: P = ['bar']; // error\n * const params3: P = []; // error\n * ```\n *\n * This is similar to {@link Parameters}, with these notable differences:\n *\n * 1. Each of the parameters can also accept an {@link AsymmetricMatcher}.\n * ```ts\n * const params4: P = [expect.anything()]; // compiles\n * ```\n * This works with nested types as well:\n * ```ts\n * type Nested = MockParameters<MockInstance<(foo: { a: number }, bar: [string]) => void>>;\n *\n * const params1: Nested = [{ foo: { a: 1 }}, ['value']]; // compiles\n * const params2: Nested = [expect.anything(), expect.anything()]; // compiles\n * const params3: Nested = [{ foo: { a: expect.anything() }}, [expect.anything()]]; // compiles\n * ```\n *\n * 2. This type works with overloaded functions (up to 15 overloads):\n * ```ts\n * function overloaded(): void;\n * function overloaded(foo: number): void;\n * function overloaded(foo: number, bar: string): void;\n * function overloaded(foo?: number, bar?: string): void {}\n *\n * type Overloaded = MockParameters<MockInstance<typeof overloaded>>;\n *\n * const params1: Overloaded = []; // compiles\n * const params2: Overloaded = [1]; // compiles\n * const params3: Overloaded = [1, 'value']; // compiles\n * const params4: Overloaded = ['value']; // error\n * const params5: Overloaded = ['value', 1]; // error\n * ```\n *\n * Mocks generated with the default `MockInstance` type will evaluate to `Array<unknown>`:\n * ```ts\n * MockParameters<MockInstance> // Array<unknown>\n * ```\n *\n * If the given type is not a `MockInstance` nor a function, this type will evaluate to `Array<unknown>`:\n * ```ts\n * MockParameters<boolean> // Array<unknown>\n * ```\n */\ntype MockParameters<M> = M extends MockInstance<infer F> ? FunctionParameters<F> : FunctionParameters<M>;\n/**\n * A wrapper over `FunctionParametersInternal` which converts `never` evaluations to `Array<unknown>`.\n *\n * This is only necessary for Typescript versions prior to 5.3.\n *\n * In those versions, a function without parameters (`() => any`) is interpreted the same as an overloaded function,\n * causing `FunctionParametersInternal` to evaluate it to `[] | Array<unknown>`, which is incorrect.\n *\n * The workaround is to \"catch\" this edge-case in `WithAsymmetricMatchers` and interpret it as `never`.\n * However, this also affects {@link UnknownFunction} (the default generic type of `MockInstance`):\n * ```ts\n * FunctionParametersInternal<() => any> // [] | never --> [] --> correct\n * FunctionParametersInternal<UnknownFunction> // never --> incorrect\n * ```\n * An empty array is the expected type for a function without parameters,\n * so all that's left is converting `never` to `Array<unknown>` for the case of `UnknownFunction`,\n * as it needs to accept _any_ combination of parameters.\n */\ntype FunctionParameters<F> = FunctionParametersInternal<F> extends never ? Array<unknown> : FunctionParametersInternal<F>;\n/**\n * 1. If the function is overloaded or has no parameters -> overloaded form (union of tuples).\n * 2. If the function has parameters -> simple form.\n * 3. else -> `never`.\n */\ntype FunctionParametersInternal<F> = F extends {\n    (...args: infer P1): any;\n    (...args: infer P2): any;\n    (...args: infer P3): any;\n    (...args: infer P4): any;\n    (...args: infer P5): any;\n    (...args: infer P6): any;\n    (...args: infer P7): any;\n    (...args: infer P8): any;\n    (...args: infer P9): any;\n    (...args: infer P10): any;\n    (...args: infer P11): any;\n    (...args: infer P12): any;\n    (...args: infer P13): any;\n    (...args: infer P14): any;\n    (...args: infer P15): any;\n} ? WithAsymmetricMatchers<P1> | WithAsymmetricMatchers<P2> | WithAsymmetricMatchers<P3> | WithAsymmetricMatchers<P4> | WithAsymmetricMatchers<P5> | WithAsymmetricMatchers<P6> | WithAsymmetricMatchers<P7> | WithAsymmetricMatchers<P8> | WithAsymmetricMatchers<P9> | WithAsymmetricMatchers<P10> | WithAsymmetricMatchers<P11> | WithAsymmetricMatchers<P12> | WithAsymmetricMatchers<P13> | WithAsymmetricMatchers<P14> | WithAsymmetricMatchers<P15> : F extends (...args: infer P) => any ? WithAsymmetricMatchers<P> : never;\n/**\n * @see FunctionParameters\n */\ntype WithAsymmetricMatchers<P extends Array<any>> = Array<unknown> extends P ? never : {\n    [K in keyof P]: DeepAsymmetricMatcher<P[K]>;\n};\n/**\n * Replaces `T` with `T | AsymmetricMatcher`.\n *\n * If `T` is an object or an array, recursively replaces all nested types with the same logic:\n * ```ts\n * type DeepAsymmetricMatcher<boolean>; // AsymmetricMatcher | boolean\n * type DeepAsymmetricMatcher<{ foo: number }>; // AsymmetricMatcher | { foo: AsymmetricMatcher | number }\n * type DeepAsymmetricMatcher<[string]>; // AsymmetricMatcher | [AsymmetricMatcher | string]\n * ```\n */\ntype DeepAsymmetricMatcher<T> = T extends object ? AsymmetricMatcher | {\n    [K in keyof T]: DeepAsymmetricMatcher<T[K]>;\n} : AsymmetricMatcher | T;\nexport {};\n",
  "packages/expect/src/toThrowMatchers.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {isError} from '@jest/expect-utils';\nimport {\n  EXPECTED_COLOR,\n  type MatcherHintOptions,\n  RECEIVED_COLOR,\n  matcherErrorMessage,\n  matcherHint,\n  printDiffOrStringify,\n  printExpected,\n  printReceived,\n  printWithType,\n} from 'jest-matcher-utils';\nimport {\n  formatExecError,\n  formatStackTrace,\n  separateMessageFromStack,\n} from 'jest-message-util';\nimport {\n  printExpectedConstructorName,\n  printExpectedConstructorNameNot,\n  printReceivedConstructorName,\n  printReceivedConstructorNameNot,\n  printReceivedStringContainExpectedResult,\n  printReceivedStringContainExpectedSubstring,\n} from './print';\nimport type {\n  ExpectationResult,\n  MatcherFunction,\n  MatchersObject,\n  SyncExpectationResult,\n} from './types';\n\nconst DID_NOT_THROW = 'Received function did not throw';\n\ntype Thrown =\n  | {\n      hasMessage: true;\n      isError: true;\n      message: string;\n      value: Error;\n    }\n  | {\n      hasMessage: boolean;\n      isError: false;\n      message: string;\n      value: any;\n    };\n\nconst getThrown = (e: any): Thrown => {\n  const hasMessage =\n    e !== null && e !== undefined && typeof e.message === 'string';\n\n  if (hasMessage && typeof e.name === 'string' && typeof e.stack === 'string') {\n    return {\n      hasMessage,\n      isError: true,\n      message: e.message,\n      value: e,\n    };\n  }\n\n  return {\n    hasMessage,\n    isError: false,\n    message: hasMessage ? e.message : String(e),\n    value: e,\n  };\n};\n\nexport const createMatcher = (\n  matcherName: string,\n  fromPromise?: boolean,\n): MatcherFunction<[any]> =>\n  function (received, expected): ExpectationResult {\n    const options = {\n      isNot: this.isNot,\n      promise: this.promise,\n    };\n\n    let thrown = null;\n\n    if (fromPromise && isError(received)) {\n      thrown = getThrown(received);\n    } else {\n      if (typeof received === 'function') {\n        try {\n          received();\n        } catch (error) {\n          thrown = getThrown(error);\n        }\n      } else {\n        if (!fromPromise) {\n          const placeholder = expected === undefined ? '' : 'expected';\n          throw new Error(\n            matcherErrorMessage(\n              matcherHint(matcherName, undefined, placeholder, options),\n              `${RECEIVED_COLOR('received')} value must be a function`,\n              printWithType('Received', received, printReceived),\n            ),\n          );\n        }\n      }\n    }\n\n    if (expected === undefined) {\n      return toThrow(matcherName, options, thrown);\n    } else if (typeof expected === 'function') {\n      return toThrowExpectedClass(matcherName, options, thrown, expected);\n    } else if (typeof expected === 'string') {\n      return toThrowExpectedString(matcherName, options, thrown, expected);\n    } else if (expected !== null && typeof expected.test === 'function') {\n      return toThrowExpectedRegExp(matcherName, options, thrown, expected);\n    } else if (\n      expected !== null &&\n      typeof expected.asymmetricMatch === 'function'\n    ) {\n      return toThrowExpectedAsymmetric(matcherName, options, thrown, expected);\n    } else if (expected !== null && typeof expected === 'object') {\n      return toThrowExpectedObject(matcherName, options, thrown, expected);\n    } else {\n      throw new Error(\n        matcherErrorMessage(\n          matcherHint(matcherName, undefined, undefined, options),\n          `${EXPECTED_COLOR(\n            'expected',\n          )} value must be a string or regular expression or class or error`,\n          printWithType('Expected', expected, printExpected),\n        ),\n      );\n    }\n  };\n\nconst matchers: MatchersObject = {\n  toThrow: createMatcher('toThrow'),\n};\n\nconst toThrowExpectedRegExp = (\n  matcherName: string,\n  options: MatcherHintOptions,\n  thrown: Thrown | null,\n  expected: RegExp,\n): SyncExpectationResult => {\n  const pass = thrown !== null && expected.test(thrown.message);\n\n  const message = pass\n    ? () =>\n        // eslint-disable-next-line prefer-template\n        matcherHint(matcherName, undefined, undefined, options) +\n        '\\n\\n' +\n        formatExpected('Expected pattern: not ', expected) +\n        (thrown !== null && thrown.hasMessage\n          ? formatReceived(\n              'Received message:     ',\n              thrown,\n              'message',\n              expected,\n            ) + formatStack(thrown)\n          : formatReceived('Received value:       ', thrown, 'value'))\n    : () =>\n        // eslint-disable-next-line prefer-template\n        matcherHint(matcherName, undefined, undefined, options) +\n        '\\n\\n' +\n        formatExpected('Expected pattern: ', expected) +\n        (thrown === null\n          ? `\\n${DID_NOT_THROW}`\n          : thrown.hasMessage\n            ? formatReceived('Received message: ', thrown, 'message') +\n              formatStack(thrown)\n            : formatReceived('Received value:   ', thrown, 'value'));\n\n  return {message, pass};\n};\n\ntype AsymmetricMatcher = {\n  asymmetricMatch: (received: unknown) => boolean;\n};\n\nconst toThrowExpectedAsymmetric = (\n  matcherName: string,\n  options: MatcherHintOptions,\n  thrown: Thrown | null,\n  expected: AsymmetricMatcher,\n): SyncExpectationResult => {\n  const pass = thrown !== null && expected.asymmetricMatch(thrown.value);\n\n  const message = pass\n    ? () =>\n        // eslint-disable-next-line prefer-template\n        matcherHint(matcherName, undefined, undefined, options) +\n        '\\n\\n' +\n        formatExpected('Expected asymmetric matcher: not ', expected) +\n        '\\n' +\n        (thrown !== null && thrown.hasMessage\n          ? formatReceived('Received name:    ', thrown, 'name') +\n            formatReceived('Received message: ', thrown, 'message') +\n            formatStack(thrown)\n          : formatReceived('Thrown value: ', thrown, 'value'))\n    : () =>\n        // eslint-disable-next-line prefer-template\n        matcherHint(matcherName, undefined, undefined, options) +\n        '\\n\\n' +\n        formatExpected('Expected asymmetric matcher: ', expected) +\n        '\\n' +\n        (thrown === null\n          ? DID_NOT_THROW\n          : thrown.hasMessage\n            ? formatReceived('Received name:    ', thrown, 'name') +\n              formatReceived('Received message: ', thrown, 'message') +\n              formatStack(thrown)\n            : formatReceived('Thrown value: ', thrown, 'value'));\n\n  return {message, pass};\n};\n\nconst toThrowExpectedObject = (\n  matcherName: string,\n  options: MatcherHintOptions,\n  thrown: Thrown | null,\n  expected: Error,\n): SyncExpectationResult => {\n  const expectedMessageAndCause = createMessageAndCause(expected);\n  const thrownMessageAndCause =\n    thrown === null ? null : createMessageAndCause(thrown.value);\n  const isCompareErrorInstance = thrown?.isError && expected instanceof Error;\n  const isExpectedCustomErrorInstance =\n    expected.constructor.name !== Error.name;\n\n  const pass =\n    thrown !== null &&\n    thrown.message === expected.message &&\n    thrownMessageAndCause === expectedMessageAndCause &&\n    (!isCompareErrorInstance ||\n      !isExpectedCustomErrorInstance ||\n      thrown.value instanceof expected.constructor);\n\n  const message = pass\n    ? () =>\n        // eslint-disable-next-line prefer-template\n        matcherHint(matcherName, undefined, undefined, options) +\n        '\\n\\n' +\n        formatExpected(\n          `Expected ${messageAndCause(expected)}: not `,\n          expectedMessageAndCause,\n        ) +\n        (thrown !== null && thrown.hasMessage\n          ? formatStack(thrown)\n          : formatReceived('Received value:       ', thrown, 'value'))\n    : () =>\n        // eslint-disable-next-line prefer-template\n        matcherHint(matcherName, undefined, undefined, options) +\n        '\\n\\n' +\n        (thrown === null\n          ? // eslint-disable-next-line prefer-template\n            formatExpected(\n              `Expected ${messageAndCause(expected)}: `,\n              expectedMessageAndCause,\n            ) +\n            '\\n' +\n            DID_NOT_THROW\n          : thrown.hasMessage\n            ? // eslint-disable-next-line prefer-template\n              printDiffOrStringify(\n                expectedMessageAndCause,\n                thrownMessageAndCause,\n                `Expected ${messageAndCause(expected)}`,\n                `Received ${messageAndCause(thrown.value)}`,\n                true,\n              ) +\n              '\\n' +\n              formatStack(thrown)\n            : formatExpected(\n                `Expected ${messageAndCause(expected)}: `,\n                expectedMessageAndCause,\n              ) + formatReceived('Received value:   ', thrown, 'value'));\n\n  return {message, pass};\n};\n\nconst toThrowExpectedClass = (\n  matcherName: string,\n  options: MatcherHintOptions,\n  thrown: Thrown | null,\n  expected: Function,\n): SyncExpectationResult => {\n  const pass = thrown !== null && thrown.value instanceof expected;\n\n  const message = pass\n    ? () =>\n        // eslint-disable-next-line prefer-template\n        matcherHint(matcherName, undefined, undefined, options) +\n        '\\n\\n' +\n        printExpectedConstructorNameNot('Expected constructor', expected) +\n        (thrown !== null &&\n        thrown.value != null &&\n        typeof thrown.value.constructor === 'function' &&\n        thrown.value.constructor !== expected\n          ? printReceivedConstructorNameNot(\n              'Received constructor',\n              thrown.value.constructor,\n              expected,\n            )\n          : '') +\n        '\\n' +\n        (thrown !== null && thrown.hasMessage\n          ? formatReceived('Received message: ', thrown, 'message') +\n            formatStack(thrown)\n          : formatReceived('Received value: ', thrown, 'value'))\n    : () =>\n        // eslint-disable-next-line prefer-template\n        matcherHint(matcherName, undefined, undefined, options) +\n        '\\n\\n' +\n        printExpectedConstructorName('Expected constructor', expected) +\n        (thrown === null\n          ? `\\n${DID_NOT_THROW}`\n          : `${\n              thrown.value != null &&\n              typeof thrown.value.constructor === 'function'\n                ? printReceivedConstructorName(\n                    'Received constructor',\n                    thrown.value.constructor,\n                  )\n                : ''\n            }\\n${\n              thrown.hasMessage\n                ? formatReceived('Received message: ', thrown, 'message') +\n                  formatStack(thrown)\n                : formatReceived('Received value: ', thrown, 'value')\n            }`);\n\n  return {message, pass};\n};\n\nconst toThrowExpectedString = (\n  matcherName: string,\n  options: MatcherHintOptions,\n  thrown: Thrown | null,\n  expected: string,\n): SyncExpectationResult => {\n  const pass = thrown !== null && thrown.message.includes(expected);\n\n  const message = pass\n    ? () =>\n        // eslint-disable-next-line prefer-template\n        matcherHint(matcherName, undefined, undefined, options) +\n        '\\n\\n' +\n        formatExpected('Expected substring: not ', expected) +\n        (thrown !== null && thrown.hasMessage\n          ? formatReceived(\n              'Received message:       ',\n              thrown,\n              'message',\n              expected,\n            ) + formatStack(thrown)\n          : formatReceived('Received value:         ', thrown, 'value'))\n    : () =>\n        // eslint-disable-next-line prefer-template\n        matcherHint(matcherName, undefined, undefined, options) +\n        '\\n\\n' +\n        formatExpected('Expected substring: ', expected) +\n        (thrown === null\n          ? `\\n${DID_NOT_THROW}`\n          : thrown.hasMessage\n            ? formatReceived('Received message:   ', thrown, 'message') +\n              formatStack(thrown)\n            : formatReceived('Received value:     ', thrown, 'value'));\n\n  return {message, pass};\n};\n\nconst toThrow = (\n  matcherName: string,\n  options: MatcherHintOptions,\n  thrown: Thrown | null,\n): SyncExpectationResult => {\n  const pass = thrown !== null;\n\n  const message = pass\n    ? () =>\n        // eslint-disable-next-line prefer-template\n        matcherHint(matcherName, undefined, '', options) +\n        '\\n\\n' +\n        (thrown !== null && thrown.hasMessage\n          ? formatReceived('Error name:    ', thrown, 'name') +\n            formatReceived('Error message: ', thrown, 'message') +\n            formatStack(thrown)\n          : formatReceived('Thrown value: ', thrown, 'value'))\n    : () =>\n        // eslint-disable-next-line prefer-template\n        matcherHint(matcherName, undefined, '', options) +\n        '\\n\\n' +\n        DID_NOT_THROW;\n\n  return {message, pass};\n};\n\nconst formatExpected = (label: string, expected: unknown) =>\n  `${label + printExpected(expected)}\\n`;\n\nconst formatReceived = (\n  label: string,\n  thrown: Thrown | null,\n  key: string,\n  expected?: string | RegExp,\n) => {\n  if (thrown === null) {\n    return '';\n  }\n\n  if (key === 'message') {\n    const message = thrown.message;\n\n    if (typeof expected === 'string') {\n      const index = message.indexOf(expected);\n      if (index !== -1) {\n        return `${\n          label +\n          printReceivedStringContainExpectedSubstring(\n            message,\n            index,\n            expected.length,\n          )\n        }\\n`;\n      }\n    } else if (expected instanceof RegExp) {\n      return `${\n        label +\n        printReceivedStringContainExpectedResult(\n          message,\n          typeof expected.exec === 'function' ? expected.exec(message) : null,\n        )\n      }\\n`;\n    }\n\n    return `${label + printReceived(message)}\\n`;\n  }\n\n  if (key === 'name') {\n    return thrown.isError\n      ? `${label + printReceived(thrown.value.name)}\\n`\n      : '';\n  }\n\n  if (key === 'value') {\n    return thrown.isError ? '' : `${label + printReceived(thrown.value)}\\n`;\n  }\n\n  return '';\n};\n\nconst formatStack = (thrown: Thrown | null) => {\n  if (thrown === null || !thrown.isError) {\n    return '';\n  } else {\n    const config = {\n      rootDir: process.cwd(),\n      testMatch: [],\n    };\n    const options = {\n      noStackTrace: false,\n    };\n    if (thrown.value instanceof AggregateError) {\n      return formatExecError(thrown.value, config, options);\n    } else {\n      return formatStackTrace(\n        separateMessageFromStack(thrown.value.stack!).stack,\n        config,\n        options,\n      );\n    }\n  }\n};\n\nfunction createMessageAndCause(error: Error) {\n  if (error.cause) {\n    const seen = new WeakSet();\n    return JSON.stringify(buildSerializeError(error), (_, value) => {\n      if (isObject(value)) {\n        if (seen.has(value)) return;\n        seen.add(value); // stop circular references\n      }\n      if (typeof value === 'bigint' || value === undefined) {\n        return String(value);\n      }\n      return value;\n    });\n  }\n\n  return error.message;\n}\n\nfunction buildSerializeError(error: {[key: string]: any}) {\n  if (!isObject(error)) {\n    return error;\n  }\n\n  const result: {[key: string]: any} = {};\n  for (const name of Object.getOwnPropertyNames(error).sort()) {\n    if (['stack', 'fileName', 'lineNumber'].includes(name)) {\n      continue;\n    }\n    if (name === 'cause') {\n      result[name] = buildSerializeError(error['cause']);\n      continue;\n    }\n    result[name] = error[name];\n  }\n\n  return result;\n}\n\nfunction isObject(obj: unknown) {\n  return obj != null && typeof obj === 'object';\n}\n\nfunction messageAndCause(error: Error) {\n  return error.cause === undefined ? 'message' : 'message and cause';\n}\n\nexport default matchers;\n",
  "packages/expect/src/toThrowMatchers.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport type { MatcherFunction, MatchersObject } from './types';\nexport declare const createMatcher: (matcherName: string, fromPromise?: boolean) => MatcherFunction<[any]>;\ndeclare const matchers: MatchersObject;\nexport default matchers;\n",
  "packages/expect/src/spyMatchers.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/* eslint-disable unicorn/consistent-function-scoping */\n\nimport {equals, iterableEquality} from '@jest/expect-utils';\nimport {getType, isPrimitive} from '@jest/get-type';\nimport {\n  DIM_COLOR,\n  EXPECTED_COLOR,\n  type MatcherHintOptions,\n  RECEIVED_COLOR,\n  diff,\n  ensureExpectedIsNonNegativeInteger,\n  ensureNoExpected,\n  matcherErrorMessage,\n  matcherHint,\n  printExpected,\n  printReceived,\n  printWithType,\n  stringify,\n} from 'jest-matcher-utils';\nimport {getCustomEqualityTesters} from './jestMatchersObject';\nimport type {\n  MatcherFunction,\n  MatchersObject,\n  SyncExpectationResult,\n} from './types';\n\n// The optional property of matcher context is true if undefined.\nconst isExpand = (expand?: boolean): boolean => expand !== false;\n\nconst PRINT_LIMIT = 3;\n\nconst NO_ARGUMENTS = 'called with 0 arguments';\n\nconst printExpectedArgs = (expected: Array<unknown>): string =>\n  expected.length === 0\n    ? NO_ARGUMENTS\n    : expected.map(arg => printExpected(arg)).join(', ');\n\nconst printReceivedArgs = (\n  received: Array<unknown>,\n  expected?: Array<unknown>,\n): string =>\n  received.length === 0\n    ? NO_ARGUMENTS\n    : received\n        .map((arg, i) =>\n          Array.isArray(expected) &&\n          i < expected.length &&\n          isEqualValue(expected[i], arg)\n            ? printCommon(arg)\n            : printReceived(arg),\n        )\n        .join(', ');\n\nconst printCommon = (val: unknown) => DIM_COLOR(stringify(val));\n\nconst isEqualValue = (expected: unknown, received: unknown): boolean =>\n  equals(expected, received, [...getCustomEqualityTesters(), iterableEquality]);\n\nconst isEqualCall = (\n  expected: Array<unknown>,\n  received: Array<unknown>,\n): boolean =>\n  received.length === expected.length && isEqualValue(expected, received);\n\nconst isEqualReturn = (expected: unknown, result: any): boolean =>\n  result.type === 'return' && isEqualValue(expected, result.value);\n\nconst countReturns = (results: Array<any>): number =>\n  results.reduce(\n    (n: number, result: any) => (result.type === 'return' ? n + 1 : n),\n    0,\n  );\n\nconst printNumberOfReturns = (\n  countReturns: number,\n  countCalls: number,\n): string =>\n  `\\nNumber of returns: ${printReceived(countReturns)}${\n    countCalls === countReturns\n      ? ''\n      : `\\nNumber of calls:   ${printReceived(countCalls)}`\n  }`;\n\ntype PrintLabel = (string: string, isExpectedCall: boolean) => string;\n\n// Given a label, return a function which given a string,\n// right-aligns it preceding the colon in the label.\nconst getRightAlignedPrinter = (label: string): PrintLabel => {\n  // Assume that the label contains a colon.\n  const index = label.indexOf(':');\n  const suffix = label.slice(index);\n\n  return (string: string, isExpectedCall: boolean) =>\n    (isExpectedCall\n      ? `->${' '.repeat(Math.max(0, index - 2 - string.length))}`\n      : ' '.repeat(Math.max(index - string.length))) +\n    string +\n    suffix;\n};\n\ntype IndexedCall = [number, Array<unknown>];\n\nconst printReceivedCallsNegative = (\n  expected: Array<unknown>,\n  indexedCalls: Array<IndexedCall>,\n  isOnlyCall: boolean,\n  iExpectedCall?: number,\n) => {\n  if (indexedCalls.length === 0) {\n    return '';\n  }\n\n  const label = 'Received:     ';\n  if (isOnlyCall) {\n    return `${label + printReceivedArgs(indexedCalls[0], expected)}\\n`;\n  }\n\n  const printAligned = getRightAlignedPrinter(label);\n\n  return `Received\\n${indexedCalls.reduce(\n    (printed: string, [i, args]: IndexedCall) =>\n      `${\n        printed +\n        printAligned(String(i + 1), i === iExpectedCall) +\n        printReceivedArgs(args, expected)\n      }\\n`,\n    '',\n  )}`;\n};\n\nconst printExpectedReceivedCallsPositive = (\n  expected: Array<unknown>,\n  indexedCalls: Array<IndexedCall>,\n  expand: boolean,\n  isOnlyCall: boolean,\n  iExpectedCall?: number,\n) => {\n  const expectedLine = `Expected: ${printExpectedArgs(expected)}\\n`;\n  if (indexedCalls.length === 0) {\n    return expectedLine;\n  }\n\n  const label = 'Received: ';\n  if (isOnlyCall && (iExpectedCall === 0 || iExpectedCall === undefined)) {\n    const received = indexedCalls[0][1];\n\n    if (isLineDiffableCall(expected, received)) {\n      // Display diff without indentation.\n      const lines = [\n        EXPECTED_COLOR('- Expected'),\n        RECEIVED_COLOR('+ Received'),\n        '',\n      ];\n\n      const length = Math.max(expected.length, received.length);\n      for (let i = 0; i < length; i += 1) {\n        if (i < expected.length && i < received.length) {\n          if (isEqualValue(expected[i], received[i])) {\n            lines.push(`  ${printCommon(received[i])},`);\n            continue;\n          }\n\n          if (isLineDiffableArg(expected[i], received[i])) {\n            const difference = diff(expected[i], received[i], {expand});\n            if (\n              typeof difference === 'string' &&\n              difference.includes('- Expected') &&\n              difference.includes('+ Received')\n            ) {\n              // Omit annotation in case multiple args have diff.\n              lines.push(`${difference.split('\\n').slice(3).join('\\n')},`);\n              continue;\n            }\n          }\n        }\n\n        if (i < expected.length) {\n          lines.push(`${EXPECTED_COLOR(`- ${stringify(expected[i])}`)},`);\n        }\n        if (i < received.length) {\n          lines.push(`${RECEIVED_COLOR(`+ ${stringify(received[i])}`)},`);\n        }\n      }\n\n      return `${lines.join('\\n')}\\n`;\n    }\n\n    return `${expectedLine + label + printReceivedArgs(received, expected)}\\n`;\n  }\n\n  const printAligned = getRightAlignedPrinter(label);\n\n  return (\n    // eslint-disable-next-line prefer-template\n    expectedLine +\n    'Received\\n' +\n    indexedCalls.reduce((printed: string, [i, received]: IndexedCall) => {\n      const aligned = printAligned(String(i + 1), i === iExpectedCall);\n      return `${\n        printed +\n        ((i === iExpectedCall || iExpectedCall === undefined) &&\n        isLineDiffableCall(expected, received)\n          ? aligned.replace(': ', '\\n') +\n            printDiffCall(expected, received, expand)\n          : aligned + printReceivedArgs(received, expected))\n      }\\n`;\n    }, '')\n  );\n};\n\nconst indentation = 'Received'.replaceAll(/\\w/g, ' ');\n\nconst printDiffCall = (\n  expected: Array<unknown>,\n  received: Array<unknown>,\n  expand: boolean,\n) =>\n  received\n    .map((arg, i) => {\n      if (i < expected.length) {\n        if (isEqualValue(expected[i], arg)) {\n          return `${indentation}  ${printCommon(arg)},`;\n        }\n\n        if (isLineDiffableArg(expected[i], arg)) {\n          const difference = diff(expected[i], arg, {expand});\n\n          if (\n            typeof difference === 'string' &&\n            difference.includes('- Expected') &&\n            difference.includes('+ Received')\n          ) {\n            // Display diff with indentation.\n            // Omit annotation in case multiple args have diff.\n            return `${difference\n              .split('\\n')\n              .slice(3)\n              .map(line => indentation + line)\n              .join('\\n')},`;\n          }\n        }\n      }\n\n      // Display + only if received arg has no corresponding expected arg.\n      return `${\n        indentation +\n        (i < expected.length\n          ? `  ${printReceived(arg)}`\n          : RECEIVED_COLOR(`+ ${stringify(arg)}`))\n      },`;\n    })\n    .join('\\n');\n\nconst isLineDiffableCall = (\n  expected: Array<unknown>,\n  received: Array<unknown>,\n): boolean =>\n  expected.some(\n    (arg, i) => i < received.length && isLineDiffableArg(arg, received[i]),\n  );\n\n// Almost redundant with function in jest-matcher-utils,\n// except no line diff for any strings.\nconst isLineDiffableArg = (expected: unknown, received: unknown): boolean => {\n  const expectedType = getType(expected);\n  const receivedType = getType(received);\n\n  if (expectedType !== receivedType) {\n    return false;\n  }\n\n  if (isPrimitive(expected)) {\n    return false;\n  }\n\n  if (\n    expectedType === 'date' ||\n    expectedType === 'function' ||\n    expectedType === 'regexp'\n  ) {\n    return false;\n  }\n\n  if (expected instanceof Error && received instanceof Error) {\n    return false;\n  }\n\n  if (\n    expectedType === 'object' &&\n    typeof (expected as any).asymmetricMatch === 'function'\n  ) {\n    return false;\n  }\n\n  if (\n    receivedType === 'object' &&\n    typeof (received as any).asymmetricMatch === 'function'\n  ) {\n    return false;\n  }\n\n  return true;\n};\n\nconst printResult = (result: any, expected: unknown) =>\n  result.type === 'throw'\n    ? 'function call threw an error'\n    : result.type === 'incomplete'\n      ? 'function call has not returned yet'\n      : isEqualValue(expected, result.value)\n        ? printCommon(result.value)\n        : printReceived(result.value);\n\ntype IndexedResult = [number, any];\n\n// Return either empty string or one line per indexed result,\n// so additional empty line can separate from `Number of returns` which follows.\nconst printReceivedResults = (\n  label: string,\n  expected: unknown,\n  indexedResults: Array<IndexedResult>,\n  isOnlyCall: boolean,\n  iExpectedCall?: number,\n) => {\n  if (indexedResults.length === 0) {\n    return '';\n  }\n\n  if (isOnlyCall && (iExpectedCall === 0 || iExpectedCall === undefined)) {\n    return `${label + printResult(indexedResults[0][1], expected)}\\n`;\n  }\n\n  const printAligned = getRightAlignedPrinter(label);\n\n  return (\n    // eslint-disable-next-line prefer-template\n    label.replace(':', '').trim() +\n    '\\n' +\n    indexedResults.reduce(\n      (printed: string, [i, result]: IndexedResult) =>\n        `${\n          printed +\n          printAligned(String(i + 1), i === iExpectedCall) +\n          printResult(result, expected)\n        }\\n`,\n      '',\n    )\n  );\n};\n\nconst createToHaveBeenCalledMatcher = (): MatcherFunction<[unknown]> =>\n  function (received: any, expected: unknown): SyncExpectationResult {\n    const expectedArgument = '';\n    const options: MatcherHintOptions = {\n      isNot: this.isNot,\n      promise: this.promise,\n    };\n    ensureNoExpected(expected, 'toHaveBeenCalled', options);\n    ensureMockOrSpy(received, 'toHaveBeenCalled', expectedArgument, options);\n\n    const receivedIsSpy = isSpy(received);\n    const receivedName = receivedIsSpy ? 'spy' : received.getMockName();\n    const count = receivedIsSpy\n      ? received.calls.count()\n      : received.mock.calls.length;\n    const calls = receivedIsSpy\n      ? received.calls.all().map((x: any) => x.args)\n      : received.mock.calls;\n    const pass = count > 0;\n    const message = pass\n      ? () =>\n          // eslint-disable-next-line prefer-template\n          matcherHint(\n            'toHaveBeenCalled',\n            receivedName,\n            expectedArgument,\n            options,\n          ) +\n          '\\n\\n' +\n          `Expected number of calls: ${printExpected(0)}\\n` +\n          `Received number of calls: ${printReceived(count)}\\n\\n` +\n          calls\n            .reduce((lines: Array<string>, args: any, i: number) => {\n              if (lines.length < PRINT_LIMIT) {\n                lines.push(`${i + 1}: ${printReceivedArgs(args)}`);\n              }\n\n              return lines;\n            }, [])\n            .join('\\n')\n      : () =>\n          // eslint-disable-next-line prefer-template\n          matcherHint(\n            'toHaveBeenCalled',\n            receivedName,\n            expectedArgument,\n            options,\n          ) +\n          '\\n\\n' +\n          `Expected number of calls: >= ${printExpected(1)}\\n` +\n          `Received number of calls:    ${printReceived(count)}`;\n\n    return {message, pass};\n  };\n\nconst createToHaveReturnedMatcher = (): MatcherFunction<[unknown]> =>\n  function (received: any, expected): SyncExpectationResult {\n    const expectedArgument = '';\n    const options: MatcherHintOptions = {\n      isNot: this.isNot,\n      promise: this.promise,\n    };\n    ensureNoExpected(expected, 'toHaveReturned', options);\n    ensureMock(received, 'toHaveReturned', expectedArgument, options);\n\n    const receivedName = received.getMockName();\n\n    // Count return values that correspond only to calls that returned\n    const count = received.mock.results.reduce(\n      (n: number, result: any) => (result.type === 'return' ? n + 1 : n),\n      0,\n    );\n\n    const pass = count > 0;\n\n    const message = pass\n      ? () =>\n          // eslint-disable-next-line prefer-template\n          matcherHint(\n            'toHaveReturned',\n            receivedName,\n            expectedArgument,\n            options,\n          ) +\n          '\\n\\n' +\n          `Expected number of returns: ${printExpected(0)}\\n` +\n          `Received number of returns: ${printReceived(count)}\\n\\n` +\n          received.mock.results\n            .reduce((lines: Array<string>, result: any, i: number) => {\n              if (result.type === 'return' && lines.length < PRINT_LIMIT) {\n                lines.push(`${i + 1}: ${printReceived(result.value)}`);\n              }\n\n              return lines;\n            }, [])\n            .join('\\n') +\n          (received.mock.calls.length === count\n            ? ''\n            : `\\n\\nReceived number of calls:   ${printReceived(\n                received.mock.calls.length,\n              )}`)\n      : () =>\n          // eslint-disable-next-line prefer-template\n          matcherHint(\n            'toHaveReturned',\n            receivedName,\n            expectedArgument,\n            options,\n          ) +\n          '\\n\\n' +\n          `Expected number of returns: >= ${printExpected(1)}\\n` +\n          `Received number of returns:    ${printReceived(count)}` +\n          (received.mock.calls.length === count\n            ? ''\n            : `\\nReceived number of calls:      ${printReceived(\n                received.mock.calls.length,\n              )}`);\n\n    return {message, pass};\n  };\n\nconst createToHaveBeenCalledTimesMatcher = (): MatcherFunction<[number]> =>\n  function (received: any, expected): SyncExpectationResult {\n    const expectedArgument = 'expected';\n    const options: MatcherHintOptions = {\n      isNot: this.isNot,\n      promise: this.promise,\n    };\n    ensureExpectedIsNonNegativeInteger(\n      expected,\n      'toHaveBeenCalledTimes',\n      options,\n    );\n    ensureMockOrSpy(\n      received,\n      'toHaveBeenCalledTimes',\n      expectedArgument,\n      options,\n    );\n\n    const receivedIsSpy = isSpy(received);\n    const receivedName = receivedIsSpy ? 'spy' : received.getMockName();\n    const count = receivedIsSpy\n      ? received.calls.count()\n      : received.mock.calls.length;\n\n    const pass = count === expected;\n\n    const message = pass\n      ? () =>\n          // eslint-disable-next-line prefer-template\n          matcherHint(\n            'toHaveBeenCalledTimes',\n            receivedName,\n            expectedArgument,\n            options,\n          ) +\n          '\\n\\n' +\n          `Expected number of calls: not ${printExpected(expected)}`\n      : () =>\n          // eslint-disable-next-line prefer-template\n          matcherHint(\n            'toHaveBeenCalledTimes',\n            receivedName,\n            expectedArgument,\n            options,\n          ) +\n          '\\n\\n' +\n          `Expected number of calls: ${printExpected(expected)}\\n` +\n          `Received number of calls: ${printReceived(count)}`;\n\n    return {message, pass};\n  };\n\nconst createToHaveReturnedTimesMatcher = (): MatcherFunction<[number]> =>\n  function (received: any, expected): SyncExpectationResult {\n    const expectedArgument = 'expected';\n    const options: MatcherHintOptions = {\n      isNot: this.isNot,\n      promise: this.promise,\n    };\n    ensureExpectedIsNonNegativeInteger(\n      expected,\n      'toHaveReturnedTimes',\n      options,\n    );\n    ensureMock(received, 'toHaveReturnedTimes', expectedArgument, options);\n\n    const receivedName = received.getMockName();\n\n    // Count return values that correspond only to calls that returned\n    const count = received.mock.results.reduce(\n      (n: number, result: any) => (result.type === 'return' ? n + 1 : n),\n      0,\n    );\n\n    const pass = count === expected;\n\n    const message = pass\n      ? () =>\n          // eslint-disable-next-line prefer-template\n          matcherHint(\n            'toHaveReturnedTimes',\n            receivedName,\n            expectedArgument,\n            options,\n          ) +\n          '\\n\\n' +\n          `Expected number of returns: not ${printExpected(expected)}` +\n          (received.mock.calls.length === count\n            ? ''\n            : `\\n\\nReceived number of calls:       ${printReceived(\n                received.mock.calls.length,\n              )}`)\n      : () =>\n          // eslint-disable-next-line prefer-template\n          matcherHint(\n            'toHaveReturnedTimes',\n            receivedName,\n            expectedArgument,\n            options,\n          ) +\n          '\\n\\n' +\n          `Expected number of returns: ${printExpected(expected)}\\n` +\n          `Received number of returns: ${printReceived(count)}` +\n          (received.mock.calls.length === count\n            ? ''\n            : `\\nReceived number of calls:   ${printReceived(\n                received.mock.calls.length,\n              )}`);\n\n    return {message, pass};\n  };\n\nconst createToHaveBeenCalledWithMatcher = (): MatcherFunction<Array<unknown>> =>\n  function (received: any, ...expected): SyncExpectationResult {\n    const expectedArgument = '...expected';\n    const options: MatcherHintOptions = {\n      isNot: this.isNot,\n      promise: this.promise,\n    };\n    ensureMockOrSpy(\n      received,\n      'toHaveBeenCalledWith',\n      expectedArgument,\n      options,\n    );\n\n    const receivedIsSpy = isSpy(received);\n    const receivedName = receivedIsSpy ? 'spy' : received.getMockName();\n\n    const calls = receivedIsSpy\n      ? received.calls.all().map((x: any) => x.args)\n      : received.mock.calls;\n\n    const pass = calls.some((call: any) => isEqualCall(expected, call));\n\n    const message = pass\n      ? () => {\n          // Some examples of calls that are equal to expected value.\n          const indexedCalls: Array<IndexedCall> = [];\n          let i = 0;\n          while (i < calls.length && indexedCalls.length < PRINT_LIMIT) {\n            if (isEqualCall(expected, calls[i])) {\n              indexedCalls.push([i, calls[i]]);\n            }\n            i += 1;\n          }\n\n          return (\n            // eslint-disable-next-line prefer-template\n            matcherHint(\n              'toHaveBeenCalledWith',\n              receivedName,\n              expectedArgument,\n              options,\n            ) +\n            '\\n\\n' +\n            `Expected: not ${printExpectedArgs(expected)}\\n` +\n            (calls.length === 1 && stringify(calls[0]) === stringify(expected)\n              ? ''\n              : printReceivedCallsNegative(\n                  expected,\n                  indexedCalls,\n                  calls.length === 1,\n                )) +\n            `\\nNumber of calls: ${printReceived(calls.length)}`\n          );\n        }\n      : () => {\n          // Some examples of calls that are not equal to expected value.\n          const indexedCalls: Array<IndexedCall> = [];\n          let i = 0;\n          while (i < calls.length && indexedCalls.length < PRINT_LIMIT) {\n            indexedCalls.push([i, calls[i]]);\n            i += 1;\n          }\n\n          return (\n            // eslint-disable-next-line prefer-template\n            matcherHint(\n              'toHaveBeenCalledWith',\n              receivedName,\n              expectedArgument,\n              options,\n            ) +\n            '\\n\\n' +\n            printExpectedReceivedCallsPositive(\n              expected,\n              indexedCalls,\n              isExpand(this.expand),\n              calls.length === 1,\n            ) +\n            `\\nNumber of calls: ${printReceived(calls.length)}`\n          );\n        };\n\n    return {message, pass};\n  };\n\nconst createToHaveReturnedWithMatcher = (): MatcherFunction<[unknown]> =>\n  function (received: any, expected): SyncExpectationResult {\n    const expectedArgument = 'expected';\n    const options: MatcherHintOptions = {\n      isNot: this.isNot,\n      promise: this.promise,\n    };\n    ensureMock(received, 'toHaveReturnedWith', expectedArgument, options);\n\n    const receivedName = received.getMockName();\n    const {calls, results} = received.mock;\n\n    const pass = results.some((result: any) => isEqualReturn(expected, result));\n\n    const message = pass\n      ? () => {\n          // Some examples of results that are equal to expected value.\n          const indexedResults: Array<IndexedResult> = [];\n          let i = 0;\n          while (i < results.length && indexedResults.length < PRINT_LIMIT) {\n            if (isEqualReturn(expected, results[i])) {\n              indexedResults.push([i, results[i]]);\n            }\n            i += 1;\n          }\n\n          return (\n            // eslint-disable-next-line prefer-template\n            matcherHint(\n              'toHaveReturnedWith',\n              receivedName,\n              expectedArgument,\n              options,\n            ) +\n            '\\n\\n' +\n            `Expected: not ${printExpected(expected)}\\n` +\n            (results.length === 1 &&\n            results[0].type === 'return' &&\n            stringify(results[0].value) === stringify(expected)\n              ? ''\n              : printReceivedResults(\n                  'Received:     ',\n                  expected,\n                  indexedResults,\n                  results.length === 1,\n                )) +\n            printNumberOfReturns(countReturns(results), calls.length)\n          );\n        }\n      : () => {\n          // Some examples of results that are not equal to expected value.\n          const indexedResults: Array<IndexedResult> = [];\n          let i = 0;\n          while (i < results.length && indexedResults.length < PRINT_LIMIT) {\n            indexedResults.push([i, results[i]]);\n            i += 1;\n          }\n\n          return (\n            // eslint-disable-next-line prefer-template\n            matcherHint(\n              'toHaveReturnedWith',\n              receivedName,\n              expectedArgument,\n              options,\n            ) +\n            '\\n\\n' +\n            `Expected: ${printExpected(expected)}\\n` +\n            printReceivedResults(\n              'Received: ',\n              expected,\n              indexedResults,\n              results.length === 1,\n            ) +\n            printNumberOfReturns(countReturns(results), calls.length)\n          );\n        };\n\n    return {message, pass};\n  };\n\nconst createToHaveBeenLastCalledWithMatcher = (): MatcherFunction<\n  Array<unknown>\n> =>\n  function (received: any, ...expected): SyncExpectationResult {\n    const expectedArgument = '...expected';\n    const options: MatcherHintOptions = {\n      isNot: this.isNot,\n      promise: this.promise,\n    };\n    ensureMockOrSpy(\n      received,\n      'toHaveBeenLastCalledWith',\n      expectedArgument,\n      options,\n    );\n\n    const receivedIsSpy = isSpy(received);\n    const receivedName = receivedIsSpy ? 'spy' : received.getMockName();\n\n    const calls = receivedIsSpy\n      ? received.calls.all().map((x: any) => x.args)\n      : received.mock.calls;\n    const iLast = calls.length - 1;\n\n    const pass = iLast >= 0 && isEqualCall(expected, calls[iLast]);\n\n    const message = pass\n      ? () => {\n          const indexedCalls: Array<IndexedCall> = [];\n          if (iLast > 0) {\n            // Display preceding call as context.\n            indexedCalls.push([iLast - 1, calls[iLast - 1]]);\n          }\n          indexedCalls.push([iLast, calls[iLast]]);\n\n          return (\n            // eslint-disable-next-line prefer-template\n            matcherHint(\n              'toHaveBeenLastCalledWith',\n              receivedName,\n              expectedArgument,\n              options,\n            ) +\n            '\\n\\n' +\n            `Expected: not ${printExpectedArgs(expected)}\\n` +\n            (calls.length === 1 && stringify(calls[0]) === stringify(expected)\n              ? ''\n              : printReceivedCallsNegative(\n                  expected,\n                  indexedCalls,\n                  calls.length === 1,\n                  iLast,\n                )) +\n            `\\nNumber of calls: ${printReceived(calls.length)}`\n          );\n        }\n      : () => {\n          const indexedCalls: Array<IndexedCall> = [];\n          if (iLast >= 0) {\n            if (iLast > 0) {\n              let i = iLast - 1;\n              // Is there a preceding call that is equal to expected args?\n              while (i >= 0 && !isEqualCall(expected, calls[i])) {\n                i -= 1;\n              }\n              if (i < 0) {\n                i = iLast - 1; // otherwise, preceding call\n              }\n\n              indexedCalls.push([i, calls[i]]);\n            }\n\n            indexedCalls.push([iLast, calls[iLast]]);\n          }\n\n          return (\n            // eslint-disable-next-line prefer-template\n            matcherHint(\n              'toHaveBeenLastCalledWith',\n              receivedName,\n              expectedArgument,\n              options,\n            ) +\n            '\\n\\n' +\n            printExpectedReceivedCallsPositive(\n              expected,\n              indexedCalls,\n              isExpand(this.expand),\n              calls.length === 1,\n              iLast,\n            ) +\n            `\\nNumber of calls: ${printReceived(calls.length)}`\n          );\n        };\n\n    return {message, pass};\n  };\n\nconst createToHaveLastReturnedWithMatcher = (): MatcherFunction<[unknown]> =>\n  function (received: any, expected): SyncExpectationResult {\n    const expectedArgument = 'expected';\n    const options: MatcherHintOptions = {\n      isNot: this.isNot,\n      promise: this.promise,\n    };\n    ensureMock(received, 'toHaveLastReturnedWith', expectedArgument, options);\n\n    const receivedName = received.getMockName();\n\n    const {calls, results} = received.mock;\n    const iLast = results.length - 1;\n\n    const pass = iLast >= 0 && isEqualReturn(expected, results[iLast]);\n\n    const message = pass\n      ? () => {\n          const indexedResults: Array<IndexedResult> = [];\n          if (iLast > 0) {\n            // Display preceding result as context.\n            indexedResults.push([iLast - 1, results[iLast - 1]]);\n          }\n          indexedResults.push([iLast, results[iLast]]);\n\n          return (\n            // eslint-disable-next-line prefer-template\n            matcherHint(\n              'toHaveLastReturnedWith',\n              receivedName,\n              expectedArgument,\n              options,\n            ) +\n            '\\n\\n' +\n            `Expected: not ${printExpected(expected)}\\n` +\n            (results.length === 1 &&\n            results[0].type === 'return' &&\n            stringify(results[0].value) === stringify(expected)\n              ? ''\n              : printReceivedResults(\n                  'Received:     ',\n                  expected,\n                  indexedResults,\n                  results.length === 1,\n                  iLast,\n                )) +\n            printNumberOfReturns(countReturns(results), calls.length)\n          );\n        }\n      : () => {\n          const indexedResults: Array<IndexedResult> = [];\n          if (iLast >= 0) {\n            if (iLast > 0) {\n              let i = iLast - 1;\n              // Is there a preceding result that is equal to expected value?\n              while (i >= 0 && !isEqualReturn(expected, results[i])) {\n                i -= 1;\n              }\n              if (i < 0) {\n                i = iLast - 1; // otherwise, preceding result\n              }\n\n              indexedResults.push([i, results[i]]);\n            }\n\n            indexedResults.push([iLast, results[iLast]]);\n          }\n\n          return (\n            // eslint-disable-next-line prefer-template\n            matcherHint(\n              'toHaveLastReturnedWith',\n              receivedName,\n              expectedArgument,\n              options,\n            ) +\n            '\\n\\n' +\n            `Expected: ${printExpected(expected)}\\n` +\n            printReceivedResults(\n              'Received: ',\n              expected,\n              indexedResults,\n              results.length === 1,\n              iLast,\n            ) +\n            printNumberOfReturns(countReturns(results), calls.length)\n          );\n        };\n\n    return {message, pass};\n  };\n\nconst createToHaveBeenNthCalledWithMatcher = (): MatcherFunction<\n  [number, ...Array<unknown>]\n> =>\n  function (received: any, nth, ...expected): SyncExpectationResult {\n    const expectedArgument = 'n';\n    const options: MatcherHintOptions = {\n      expectedColor: (arg: string) => arg,\n      isNot: this.isNot,\n      promise: this.promise,\n      secondArgument: '...expected',\n    };\n    ensureMockOrSpy(\n      received,\n      'toHaveBeenNthCalledWith',\n      expectedArgument,\n      options,\n    );\n\n    if (!Number.isSafeInteger(nth) || nth < 1) {\n      throw new Error(\n        matcherErrorMessage(\n          matcherHint(\n            'toHaveBeenNthCalledWith',\n            undefined,\n            expectedArgument,\n            options,\n          ),\n          `${expectedArgument} must be a positive integer`,\n          printWithType(expectedArgument, nth, stringify),\n        ),\n      );\n    }\n\n    const receivedIsSpy = isSpy(received);\n    const receivedName = receivedIsSpy ? 'spy' : received.getMockName();\n\n    const calls = receivedIsSpy\n      ? received.calls.all().map((x: any) => x.args)\n      : received.mock.calls;\n    const length = calls.length;\n    const iNth = nth - 1;\n\n    const pass = iNth < length && isEqualCall(expected, calls[iNth]);\n\n    const message = pass\n      ? () => {\n          // Display preceding and following calls,\n          // in case assertions fails because index is off by one.\n          const indexedCalls: Array<IndexedCall> = [];\n          if (iNth - 1 >= 0) {\n            indexedCalls.push([iNth - 1, calls[iNth - 1]]);\n          }\n          indexedCalls.push([iNth, calls[iNth]]);\n          if (iNth + 1 < length) {\n            indexedCalls.push([iNth + 1, calls[iNth + 1]]);\n          }\n\n          return (\n            // eslint-disable-next-line prefer-template\n            matcherHint(\n              'toHaveBeenNthCalledWith',\n              receivedName,\n              expectedArgument,\n              options,\n            ) +\n            '\\n\\n' +\n            `n: ${nth}\\n` +\n            `Expected: not ${printExpectedArgs(expected)}\\n` +\n            (calls.length === 1 && stringify(calls[0]) === stringify(expected)\n              ? ''\n              : printReceivedCallsNegative(\n                  expected,\n                  indexedCalls,\n                  calls.length === 1,\n                  iNth,\n                )) +\n            `\\nNumber of calls: ${printReceived(calls.length)}`\n          );\n        }\n      : () => {\n          // Display preceding and following calls:\n          // * nearest call that is equal to expected args\n          // * otherwise, adjacent call\n          // in case assertions fails because of index, especially off by one.\n          const indexedCalls: Array<IndexedCall> = [];\n          if (iNth < length) {\n            if (iNth - 1 >= 0) {\n              let i = iNth - 1;\n              // Is there a preceding call that is equal to expected args?\n              while (i >= 0 && !isEqualCall(expected, calls[i])) {\n                i -= 1;\n              }\n              if (i < 0) {\n                i = iNth - 1; // otherwise, adjacent call\n              }\n\n              indexedCalls.push([i, calls[i]]);\n            }\n            indexedCalls.push([iNth, calls[iNth]]);\n            if (iNth + 1 < length) {\n              let i = iNth + 1;\n              // Is there a following call that is equal to expected args?\n              while (i < length && !isEqualCall(expected, calls[i])) {\n                i += 1;\n              }\n              if (i >= length) {\n                i = iNth + 1; // otherwise, adjacent call\n              }\n\n              indexedCalls.push([i, calls[i]]);\n            }\n          } else if (length > 0) {\n            // The number of received calls is fewer than the expected number.\n            let i = length - 1;\n            // Is there a call that is equal to expected args?\n            while (i >= 0 && !isEqualCall(expected, calls[i])) {\n              i -= 1;\n            }\n            if (i < 0) {\n              i = length - 1; // otherwise, last call\n            }\n\n            indexedCalls.push([i, calls[i]]);\n          }\n\n          return (\n            // eslint-disable-next-line prefer-template\n            matcherHint(\n              'toHaveBeenNthCalledWith',\n              receivedName,\n              expectedArgument,\n              options,\n            ) +\n            '\\n\\n' +\n            `n: ${nth}\\n` +\n            printExpectedReceivedCallsPositive(\n              expected,\n              indexedCalls,\n              isExpand(this.expand),\n              calls.length === 1,\n              iNth,\n            ) +\n            `\\nNumber of calls: ${printReceived(calls.length)}`\n          );\n        };\n\n    return {message, pass};\n  };\n\nconst createToHaveNthReturnedWithMatcher = (): MatcherFunction<\n  [number, unknown]\n> =>\n  function (received: any, nth, expected): SyncExpectationResult {\n    const expectedArgument = 'n';\n    const options: MatcherHintOptions = {\n      expectedColor: (arg: string) => arg,\n      isNot: this.isNot,\n      promise: this.promise,\n      secondArgument: 'expected',\n    };\n    ensureMock(received, 'toHaveNthReturnedWith', expectedArgument, options);\n\n    if (!Number.isSafeInteger(nth) || nth < 1) {\n      throw new Error(\n        matcherErrorMessage(\n          matcherHint(\n            'toHaveNthReturnedWith',\n            undefined,\n            expectedArgument,\n            options,\n          ),\n          `${expectedArgument} must be a positive integer`,\n          printWithType(expectedArgument, nth, stringify),\n        ),\n      );\n    }\n\n    const receivedName = received.getMockName();\n    const {calls, results} = received.mock;\n    const length = results.length;\n    const iNth = nth - 1;\n\n    const pass = iNth < length && isEqualReturn(expected, results[iNth]);\n\n    const message = pass\n      ? () => {\n          // Display preceding and following results,\n          // in case assertions fails because index is off by one.\n          const indexedResults: Array<IndexedResult> = [];\n          if (iNth - 1 >= 0) {\n            indexedResults.push([iNth - 1, results[iNth - 1]]);\n          }\n          indexedResults.push([iNth, results[iNth]]);\n          if (iNth + 1 < length) {\n            indexedResults.push([iNth + 1, results[iNth + 1]]);\n          }\n\n          return (\n            // eslint-disable-next-line prefer-template\n            matcherHint(\n              'toHaveNthReturnedWith',\n              receivedName,\n              expectedArgument,\n              options,\n            ) +\n            '\\n\\n' +\n            `n: ${nth}\\n` +\n            `Expected: not ${printExpected(expected)}\\n` +\n            (results.length === 1 &&\n            results[0].type === 'return' &&\n            stringify(results[0].value) === stringify(expected)\n              ? ''\n              : printReceivedResults(\n                  'Received:     ',\n                  expected,\n                  indexedResults,\n                  results.length === 1,\n                  iNth,\n                )) +\n            printNumberOfReturns(countReturns(results), calls.length)\n          );\n        }\n      : () => {\n          // Display preceding and following results:\n          // * nearest result that is equal to expected value\n          // * otherwise, adjacent result\n          // in case assertions fails because of index, especially off by one.\n          const indexedResults: Array<IndexedResult> = [];\n          if (iNth < length) {\n            if (iNth - 1 >= 0) {\n              let i = iNth - 1;\n              // Is there a preceding result that is equal to expected value?\n              while (i >= 0 && !isEqualReturn(expected, results[i])) {\n                i -= 1;\n              }\n              if (i < 0) {\n                i = iNth - 1; // otherwise, adjacent result\n              }\n\n              indexedResults.push([i, results[i]]);\n            }\n            indexedResults.push([iNth, results[iNth]]);\n            if (iNth + 1 < length) {\n              let i = iNth + 1;\n              // Is there a following result that is equal to expected value?\n              while (i < length && !isEqualReturn(expected, results[i])) {\n                i += 1;\n              }\n              if (i >= length) {\n                i = iNth + 1; // otherwise, adjacent result\n              }\n\n              indexedResults.push([i, results[i]]);\n            }\n          } else if (length > 0) {\n            // The number of received calls is fewer than the expected number.\n            let i = length - 1;\n            // Is there a result that is equal to expected value?\n            while (i >= 0 && !isEqualReturn(expected, results[i])) {\n              i -= 1;\n            }\n            if (i < 0) {\n              i = length - 1; // otherwise, last result\n            }\n\n            indexedResults.push([i, results[i]]);\n          }\n\n          return (\n            // eslint-disable-next-line prefer-template\n            matcherHint(\n              'toHaveNthReturnedWith',\n              receivedName,\n              expectedArgument,\n              options,\n            ) +\n            '\\n\\n' +\n            `n: ${nth}\\n` +\n            `Expected: ${printExpected(expected)}\\n` +\n            printReceivedResults(\n              'Received: ',\n              expected,\n              indexedResults,\n              results.length === 1,\n              iNth,\n            ) +\n            printNumberOfReturns(countReturns(results), calls.length)\n          );\n        };\n\n    return {message, pass};\n  };\n\nconst spyMatchers: MatchersObject = {\n  toHaveBeenCalled: createToHaveBeenCalledMatcher(),\n  toHaveBeenCalledTimes: createToHaveBeenCalledTimesMatcher(),\n  toHaveBeenCalledWith: createToHaveBeenCalledWithMatcher(),\n  toHaveBeenLastCalledWith: createToHaveBeenLastCalledWithMatcher(),\n  toHaveBeenNthCalledWith: createToHaveBeenNthCalledWithMatcher(),\n  toHaveLastReturnedWith: createToHaveLastReturnedWithMatcher(),\n  toHaveNthReturnedWith: createToHaveNthReturnedWithMatcher(),\n  toHaveReturned: createToHaveReturnedMatcher(),\n  toHaveReturnedTimes: createToHaveReturnedTimesMatcher(),\n  toHaveReturnedWith: createToHaveReturnedWithMatcher(),\n};\n\nconst isMock = (received: any) =>\n  received != null && received._isMockFunction === true;\n\nconst isSpy = (received: any) =>\n  received != null &&\n  received.calls != null &&\n  typeof received.calls.all === 'function' &&\n  typeof received.calls.count === 'function';\n\nconst ensureMockOrSpy = (\n  received: any,\n  matcherName: string,\n  expectedArgument: string,\n  options: MatcherHintOptions,\n) => {\n  if (!isMock(received) && !isSpy(received)) {\n    throw new Error(\n      matcherErrorMessage(\n        matcherHint(matcherName, undefined, expectedArgument, options),\n        `${RECEIVED_COLOR('received')} value must be a mock or spy function`,\n        printWithType('Received', received, printReceived),\n      ),\n    );\n  }\n};\n\nconst ensureMock = (\n  received: any,\n  matcherName: string,\n  expectedArgument: string,\n  options: MatcherHintOptions,\n) => {\n  if (!isMock(received)) {\n    throw new Error(\n      matcherErrorMessage(\n        matcherHint(matcherName, undefined, expectedArgument, options),\n        `${RECEIVED_COLOR('received')} value must be a mock function`,\n        printWithType('Received', received, printReceived),\n      ),\n    );\n  }\n};\n\nexport default spyMatchers;\n",
  "packages/expect/src/spyMatchers.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { MatchersObject } from './types';\ndeclare const spyMatchers: MatchersObject;\nexport default spyMatchers;\n",
  "packages/expect/src/print.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {\n  EXPECTED_COLOR,\n  INVERTED_COLOR,\n  RECEIVED_COLOR,\n  printReceived,\n  stringify,\n} from 'jest-matcher-utils';\n\n// Format substring but do not enclose in double quote marks.\n// The replacement is compatible with pretty-format package.\nconst printSubstring = (val: string): string => val.replaceAll(/\"|\\\\/g, '\\\\$&');\n\nexport const printReceivedStringContainExpectedSubstring = (\n  received: string,\n  start: number,\n  length: number, // not end\n): string =>\n  RECEIVED_COLOR(\n    `\"${printSubstring(received.slice(0, start))}${INVERTED_COLOR(\n      printSubstring(received.slice(start, start + length)),\n    )}${printSubstring(received.slice(start + length))}\"`,\n  );\n\nexport const printReceivedStringContainExpectedResult = (\n  received: string,\n  result: RegExpExecArray | null,\n): string =>\n  result === null\n    ? printReceived(received)\n    : printReceivedStringContainExpectedSubstring(\n        received,\n        result.index,\n        result[0].length,\n      );\n\n// The serialized array is compatible with pretty-format package min option.\n// However, items have default stringify depth (instead of depth - 1)\n// so expected item looks consistent by itself and enclosed in the array.\nexport const printReceivedArrayContainExpectedItem = (\n  received: Array<unknown>,\n  index: number,\n): string =>\n  RECEIVED_COLOR(\n    `[${received\n      .map((item, i) => {\n        const stringified = stringify(item);\n        return i === index ? INVERTED_COLOR(stringified) : stringified;\n      })\n      .join(', ')}]`,\n  );\n\nexport const printCloseTo = (\n  receivedDiff: number,\n  expectedDiff: number,\n  precision: number,\n  isNot: boolean | undefined,\n): string => {\n  const receivedDiffString = stringify(receivedDiff);\n  const expectedDiffString = receivedDiffString.includes('e')\n    ? // toExponential arg is number of digits after the decimal point.\n      expectedDiff.toExponential(0)\n    : 0 <= precision && precision < 20\n      ? // toFixed arg is number of digits after the decimal point.\n        // It may be a value between 0 and 20 inclusive.\n        // Implementations may optionally support a larger range of values.\n        expectedDiff.toFixed(precision + 1)\n      : stringify(expectedDiff);\n\n  return (\n    `Expected precision:  ${isNot ? '    ' : ''}  ${stringify(precision)}\\n` +\n    `Expected difference: ${isNot ? 'not ' : ''}< ${EXPECTED_COLOR(\n      expectedDiffString,\n    )}\\n` +\n    `Received difference: ${isNot ? '    ' : ''}  ${RECEIVED_COLOR(\n      receivedDiffString,\n    )}`\n  );\n};\n\nexport const printExpectedConstructorName = (\n  label: string,\n  expected: Function,\n): string => `${printConstructorName(label, expected, false, true)}\\n`;\n\nexport const printExpectedConstructorNameNot = (\n  label: string,\n  expected: Function,\n): string => `${printConstructorName(label, expected, true, true)}\\n`;\n\nexport const printReceivedConstructorName = (\n  label: string,\n  received: Function,\n): string => `${printConstructorName(label, received, false, false)}\\n`;\n\n// Do not call function if received is equal to expected.\nexport const printReceivedConstructorNameNot = (\n  label: string,\n  received: Function,\n  expected: Function,\n): string =>\n  typeof expected.name === 'string' &&\n  expected.name.length > 0 &&\n  typeof received.name === 'string' &&\n  received.name.length > 0\n    ? `${printConstructorName(label, received, true, false)} ${\n        Object.getPrototypeOf(received) === expected\n          ? 'extends'\n          : 'extends … extends'\n      } ${EXPECTED_COLOR(expected.name)}\\n`\n    : `${printConstructorName(label, received, false, false)}\\n`;\n\nconst printConstructorName = (\n  label: string,\n  constructor: Function,\n  isNot: boolean,\n  isExpected: boolean,\n): string =>\n  typeof constructor.name === 'string'\n    ? constructor.name.length === 0\n      ? `${label} name is an empty string`\n      : `${label}: ${isNot ? (isExpected ? 'not ' : '    ') : ''}${\n          isExpected\n            ? EXPECTED_COLOR(constructor.name)\n            : RECEIVED_COLOR(constructor.name)\n        }`\n    : `${label} name is not a string`;\n",
  "packages/expect/src/print.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport declare const printReceivedStringContainExpectedSubstring: (received: string, start: number, length: number) => string;\nexport declare const printReceivedStringContainExpectedResult: (received: string, result: RegExpExecArray | null) => string;\nexport declare const printReceivedArrayContainExpectedItem: (received: Array<unknown>, index: number) => string;\nexport declare const printCloseTo: (receivedDiff: number, expectedDiff: number, precision: number, isNot: boolean | undefined) => string;\nexport declare const printExpectedConstructorName: (label: string, expected: Function) => string;\nexport declare const printExpectedConstructorNameNot: (label: string, expected: Function) => string;\nexport declare const printReceivedConstructorName: (label: string, received: Function) => string;\nexport declare const printReceivedConstructorNameNot: (label: string, received: Function, expected: Function) => string;\n",
  "packages/expect/src/matchers.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {\n  arrayBufferEquality,\n  equals,\n  getObjectSubset,\n  getPath,\n  iterableEquality,\n  pathAsArray,\n  sparseArrayEquality,\n  subsetEquality,\n  typeEquality,\n} from '@jest/expect-utils';\nimport {getType, isPrimitive} from '@jest/get-type';\nimport {\n  DIM_COLOR,\n  EXPECTED_COLOR,\n  type MatcherHintOptions,\n  RECEIVED_COLOR,\n  SUGGEST_TO_CONTAIN_EQUAL,\n  ensureExpectedIsNonNegativeInteger,\n  ensureNoExpected,\n  ensureNumbers,\n  getLabelPrinter,\n  matcherErrorMessage,\n  matcherHint,\n  printDiffOrStringify,\n  printExpected,\n  printReceived,\n  printWithType,\n  stringify,\n} from 'jest-matcher-utils';\nimport {\n  printCloseTo,\n  printExpectedConstructorName,\n  printExpectedConstructorNameNot,\n  printReceivedArrayContainExpectedItem,\n  printReceivedConstructorName,\n  printReceivedConstructorNameNot,\n  printReceivedStringContainExpectedResult,\n  printReceivedStringContainExpectedSubstring,\n} from './print';\nimport type {MatchersObject} from './types';\n\n// Omit colon and one or more spaces, so can call getLabelPrinter.\nconst EXPECTED_LABEL = 'Expected';\nconst RECEIVED_LABEL = 'Received';\nconst EXPECTED_VALUE_LABEL = 'Expected value';\nconst RECEIVED_VALUE_LABEL = 'Received value';\n\n// The optional property of matcher context is true if undefined.\nconst isExpand = (expand?: boolean): boolean => expand !== false;\n\nconst toStrictEqualTesters = [\n  iterableEquality,\n  typeEquality,\n  sparseArrayEquality,\n  arrayBufferEquality,\n];\n\ntype ContainIterable =\n  | Array<unknown>\n  | Set<unknown>\n  | NodeListOf<Node>\n  | DOMTokenList\n  | HTMLCollectionOf<any>;\n\nconst matchers: MatchersObject = {\n  toBe(received: unknown, expected: unknown) {\n    const matcherName = 'toBe';\n    const options: MatcherHintOptions = {\n      comment: 'Object.is equality',\n      isNot: this.isNot,\n      promise: this.promise,\n    };\n\n    const pass = Object.is(received, expected);\n\n    const message = pass\n      ? () =>\n          // eslint-disable-next-line prefer-template\n          matcherHint(matcherName, undefined, undefined, options) +\n          '\\n\\n' +\n          `Expected: not ${printExpected(expected)}`\n      : () => {\n          const expectedType = getType(expected);\n\n          let deepEqualityName = null;\n          if (expectedType !== 'map' && expectedType !== 'set') {\n            // If deep equality passes when referential identity fails,\n            // but exclude map and set until review of their equality logic.\n            if (\n              equals(\n                received,\n                expected,\n                [...this.customTesters, ...toStrictEqualTesters],\n                true,\n              )\n            ) {\n              deepEqualityName = 'toStrictEqual';\n            } else if (\n              equals(received, expected, [\n                ...this.customTesters,\n                iterableEquality,\n              ])\n            ) {\n              deepEqualityName = 'toEqual';\n            }\n          }\n\n          return (\n            // eslint-disable-next-line prefer-template\n            matcherHint(matcherName, undefined, undefined, options) +\n            '\\n\\n' +\n            (deepEqualityName === null\n              ? ''\n              : `${DIM_COLOR(\n                  `If it should pass with deep equality, replace \"${matcherName}\" with \"${deepEqualityName}\"`,\n                )}\\n\\n`) +\n            printDiffOrStringify(\n              expected,\n              received,\n              EXPECTED_LABEL,\n              RECEIVED_LABEL,\n              isExpand(this.expand),\n            )\n          );\n        };\n\n    // Passing the actual and expected objects so that a custom reporter\n    // could access them, for example in order to display a custom visual diff,\n    // or create a different error message\n    return {actual: received, expected, message, name: matcherName, pass};\n  },\n\n  toBeCloseTo(received: number, expected: number, precision = 2) {\n    const matcherName = 'toBeCloseTo';\n    const secondArgument = arguments.length === 3 ? 'precision' : undefined;\n    const isNot = this.isNot;\n    const options: MatcherHintOptions = {\n      isNot,\n      promise: this.promise,\n      secondArgument,\n      secondArgumentColor: (arg: string) => arg,\n    };\n\n    if (typeof expected !== 'number') {\n      throw new TypeError(\n        matcherErrorMessage(\n          matcherHint(matcherName, undefined, undefined, options),\n          `${EXPECTED_COLOR('expected')} value must be a number`,\n          printWithType('Expected', expected, printExpected),\n        ),\n      );\n    }\n\n    if (typeof received !== 'number') {\n      throw new TypeError(\n        matcherErrorMessage(\n          matcherHint(matcherName, undefined, undefined, options),\n          `${RECEIVED_COLOR('received')} value must be a number`,\n          printWithType('Received', received, printReceived),\n        ),\n      );\n    }\n\n    let pass = false;\n    let expectedDiff = 0;\n    let receivedDiff = 0;\n\n    if (\n      received === Number.POSITIVE_INFINITY &&\n      expected === Number.POSITIVE_INFINITY\n    ) {\n      pass = true; // Infinity - Infinity is NaN\n    } else if (\n      received === Number.NEGATIVE_INFINITY &&\n      expected === Number.NEGATIVE_INFINITY\n    ) {\n      pass = true; // -Infinity - -Infinity is NaN\n    } else {\n      expectedDiff = Math.pow(10, -precision) / 2;\n      receivedDiff = Math.abs(expected - received);\n      pass = receivedDiff < expectedDiff;\n    }\n\n    const message = pass\n      ? () =>\n          // eslint-disable-next-line prefer-template\n          matcherHint(matcherName, undefined, undefined, options) +\n          '\\n\\n' +\n          `Expected: not ${printExpected(expected)}\\n` +\n          (receivedDiff === 0\n            ? ''\n            : `Received:     ${printReceived(received)}\\n` +\n              `\\n${printCloseTo(receivedDiff, expectedDiff, precision, isNot)}`)\n      : () =>\n          // eslint-disable-next-line prefer-template\n          matcherHint(matcherName, undefined, undefined, options) +\n          '\\n\\n' +\n          `Expected: ${printExpected(expected)}\\n` +\n          `Received: ${printReceived(received)}\\n` +\n          '\\n' +\n          printCloseTo(receivedDiff, expectedDiff, precision, isNot);\n\n    return {message, pass};\n  },\n\n  toBeDefined(received: unknown, expected: void) {\n    const matcherName = 'toBeDefined';\n    const options: MatcherHintOptions = {\n      isNot: this.isNot,\n      promise: this.promise,\n    };\n    ensureNoExpected(expected, matcherName, options);\n\n    const pass = received !== void 0;\n\n    const message = () =>\n      // eslint-disable-next-line prefer-template\n      matcherHint(matcherName, undefined, '', options) +\n      '\\n\\n' +\n      `Received: ${printReceived(received)}`;\n\n    return {message, pass};\n  },\n\n  toBeFalsy(received: unknown, expected: void) {\n    const matcherName = 'toBeFalsy';\n    const options: MatcherHintOptions = {\n      isNot: this.isNot,\n      promise: this.promise,\n    };\n    ensureNoExpected(expected, matcherName, options);\n\n    const pass = !received;\n\n    const message = () =>\n      // eslint-disable-next-line prefer-template\n      matcherHint(matcherName, undefined, '', options) +\n      '\\n\\n' +\n      `Received: ${printReceived(received)}`;\n\n    return {message, pass};\n  },\n\n  toBeGreaterThan(received: number | bigint, expected: number | bigint) {\n    const matcherName = 'toBeGreaterThan';\n    const isNot = this.isNot;\n    const options: MatcherHintOptions = {\n      isNot,\n      promise: this.promise,\n    };\n    ensureNumbers(received, expected, matcherName, options);\n\n    const pass = received > expected;\n\n    const message = () =>\n      // eslint-disable-next-line prefer-template\n      matcherHint(matcherName, undefined, undefined, options) +\n      '\\n\\n' +\n      `Expected:${isNot ? ' not' : ''} > ${printExpected(expected)}\\n` +\n      `Received:${isNot ? '    ' : ''}   ${printReceived(received)}`;\n\n    return {message, pass};\n  },\n\n  toBeGreaterThanOrEqual(received: number | bigint, expected: number | bigint) {\n    const matcherName = 'toBeGreaterThanOrEqual';\n    const isNot = this.isNot;\n    const options: MatcherHintOptions = {\n      isNot,\n      promise: this.promise,\n    };\n    ensureNumbers(received, expected, matcherName, options);\n\n    const pass = received >= expected;\n\n    const message = () =>\n      // eslint-disable-next-line prefer-template\n      matcherHint(matcherName, undefined, undefined, options) +\n      '\\n\\n' +\n      `Expected:${isNot ? ' not' : ''} >= ${printExpected(expected)}\\n` +\n      `Received:${isNot ? '    ' : ''}    ${printReceived(received)}`;\n\n    return {message, pass};\n  },\n\n  toBeInstanceOf(received: any, expected: Function) {\n    const matcherName = 'toBeInstanceOf';\n    const options: MatcherHintOptions = {\n      isNot: this.isNot,\n      promise: this.promise,\n    };\n\n    if (typeof expected !== 'function') {\n      throw new TypeError(\n        matcherErrorMessage(\n          matcherHint(matcherName, undefined, undefined, options),\n          `${EXPECTED_COLOR('expected')} value must be a function`,\n          printWithType('Expected', expected, printExpected),\n        ),\n      );\n    }\n\n    const pass = received instanceof expected;\n\n    const message = pass\n      ? () =>\n          // eslint-disable-next-line prefer-template\n          matcherHint(matcherName, undefined, undefined, options) +\n          '\\n\\n' +\n          printExpectedConstructorNameNot('Expected constructor', expected) +\n          (typeof received.constructor === 'function' &&\n          received.constructor !== expected\n            ? printReceivedConstructorNameNot(\n                'Received constructor',\n                received.constructor,\n                expected,\n              )\n            : '')\n      : () =>\n          // eslint-disable-next-line prefer-template\n          matcherHint(matcherName, undefined, undefined, options) +\n          '\\n\\n' +\n          printExpectedConstructorName('Expected constructor', expected) +\n          (isPrimitive(received) || Object.getPrototypeOf(received) === null\n            ? `\\nReceived value has no prototype\\nReceived value: ${printReceived(\n                received,\n              )}`\n            : typeof received.constructor === 'function'\n              ? printReceivedConstructorName(\n                  'Received constructor',\n                  received.constructor,\n                )\n              : `\\nReceived value: ${printReceived(received)}`);\n\n    return {message, pass};\n  },\n\n  toBeLessThan(received: number | bigint, expected: number | bigint) {\n    const matcherName = 'toBeLessThan';\n    const isNot = this.isNot;\n    const options: MatcherHintOptions = {\n      isNot,\n      promise: this.promise,\n    };\n    ensureNumbers(received, expected, matcherName, options);\n\n    const pass = received < expected;\n\n    const message = () =>\n      // eslint-disable-next-line prefer-template\n      matcherHint(matcherName, undefined, undefined, options) +\n      '\\n\\n' +\n      `Expected:${isNot ? ' not' : ''} < ${printExpected(expected)}\\n` +\n      `Received:${isNot ? '    ' : ''}   ${printReceived(received)}`;\n\n    return {message, pass};\n  },\n\n  toBeLessThanOrEqual(received: number | bigint, expected: number | bigint) {\n    const matcherName = 'toBeLessThanOrEqual';\n    const isNot = this.isNot;\n    const options: MatcherHintOptions = {\n      isNot,\n      promise: this.promise,\n    };\n    ensureNumbers(received, expected, matcherName, options);\n\n    const pass = received <= expected;\n\n    const message = () =>\n      // eslint-disable-next-line prefer-template\n      matcherHint(matcherName, undefined, undefined, options) +\n      '\\n\\n' +\n      `Expected:${isNot ? ' not' : ''} <= ${printExpected(expected)}\\n` +\n      `Received:${isNot ? '    ' : ''}    ${printReceived(received)}`;\n\n    return {message, pass};\n  },\n\n  toBeNaN(received: any, expected: void) {\n    const matcherName = 'toBeNaN';\n    const options: MatcherHintOptions = {\n      isNot: this.isNot,\n      promise: this.promise,\n    };\n    ensureNoExpected(expected, matcherName, options);\n\n    const pass = Number.isNaN(received);\n\n    const message = () =>\n      // eslint-disable-next-line prefer-template\n      matcherHint(matcherName, undefined, '', options) +\n      '\\n\\n' +\n      `Received: ${printReceived(received)}`;\n\n    return {message, pass};\n  },\n\n  toBeNull(received: unknown, expected: void) {\n    const matcherName = 'toBeNull';\n    const options: MatcherHintOptions = {\n      isNot: this.isNot,\n      promise: this.promise,\n    };\n    ensureNoExpected(expected, matcherName, options);\n\n    const pass = received === null;\n\n    const message = () =>\n      // eslint-disable-next-line prefer-template\n      matcherHint(matcherName, undefined, '', options) +\n      '\\n\\n' +\n      `Received: ${printReceived(received)}`;\n\n    return {message, pass};\n  },\n\n  toBeTruthy(received: unknown, expected: void) {\n    const matcherName = 'toBeTruthy';\n    const options: MatcherHintOptions = {\n      isNot: this.isNot,\n      promise: this.promise,\n    };\n    ensureNoExpected(expected, matcherName, options);\n\n    const pass = !!received;\n\n    const message = () =>\n      // eslint-disable-next-line prefer-template\n      matcherHint(matcherName, undefined, '', options) +\n      '\\n\\n' +\n      `Received: ${printReceived(received)}`;\n\n    return {message, pass};\n  },\n\n  toBeUndefined(received: unknown, expected: void) {\n    const matcherName = 'toBeUndefined';\n    const options: MatcherHintOptions = {\n      isNot: this.isNot,\n      promise: this.promise,\n    };\n    ensureNoExpected(expected, matcherName, options);\n\n    const pass = received === void 0;\n\n    const message = () =>\n      // eslint-disable-next-line prefer-template\n      matcherHint(matcherName, undefined, '', options) +\n      '\\n\\n' +\n      `Received: ${printReceived(received)}`;\n\n    return {message, pass};\n  },\n\n  toContain(received: ContainIterable | string, expected: unknown) {\n    const matcherName = 'toContain';\n    const isNot = this.isNot;\n    const options: MatcherHintOptions = {\n      comment: 'indexOf',\n      isNot,\n      promise: this.promise,\n    };\n\n    if (received == null) {\n      throw new Error(\n        matcherErrorMessage(\n          matcherHint(matcherName, undefined, undefined, options),\n          `${RECEIVED_COLOR('received')} value must not be null nor undefined`,\n          printWithType('Received', received, printReceived),\n        ),\n      );\n    }\n\n    if (typeof received === 'string') {\n      const wrongTypeErrorMessage = `${EXPECTED_COLOR(\n        'expected',\n      )} value must be a string if ${RECEIVED_COLOR(\n        'received',\n      )} value is a string`;\n\n      if (typeof expected !== 'string') {\n        throw new TypeError(\n          matcherErrorMessage(\n            matcherHint(matcherName, received, String(expected), options),\n            wrongTypeErrorMessage,\n            // eslint-disable-next-line prefer-template\n            printWithType('Expected', expected, printExpected) +\n              '\\n' +\n              printWithType('Received', received, printReceived),\n          ),\n        );\n      }\n\n      const index = received.indexOf(String(expected));\n      const pass = index !== -1;\n\n      const message = () => {\n        const labelExpected = `Expected ${\n          typeof expected === 'string' ? 'substring' : 'value'\n        }`;\n        const labelReceived = 'Received string';\n        const printLabel = getLabelPrinter(labelExpected, labelReceived);\n\n        return (\n          // eslint-disable-next-line prefer-template\n          matcherHint(matcherName, undefined, undefined, options) +\n          '\\n\\n' +\n          `${printLabel(labelExpected)}${isNot ? 'not ' : ''}${printExpected(\n            expected,\n          )}\\n` +\n          `${printLabel(labelReceived)}${isNot ? '    ' : ''}${\n            isNot\n              ? printReceivedStringContainExpectedSubstring(\n                  received,\n                  index,\n                  String(expected).length,\n                )\n              : printReceived(received)\n          }`\n        );\n      };\n\n      return {message, pass};\n    }\n\n    const indexable = [...received];\n    const index = indexable.indexOf(expected);\n    const pass = index !== -1;\n\n    const message = () => {\n      const labelExpected = 'Expected value';\n      const labelReceived = `Received ${getType(received)}`;\n      const printLabel = getLabelPrinter(labelExpected, labelReceived);\n\n      return (\n        // eslint-disable-next-line prefer-template\n        matcherHint(matcherName, undefined, undefined, options) +\n        '\\n\\n' +\n        `${printLabel(labelExpected)}${isNot ? 'not ' : ''}${printExpected(\n          expected,\n        )}\\n` +\n        `${printLabel(labelReceived)}${isNot ? '    ' : ''}${\n          isNot && Array.isArray(received)\n            ? printReceivedArrayContainExpectedItem(received, index)\n            : printReceived(received)\n        }` +\n        (!isNot &&\n        indexable.some(item =>\n          equals(item, expected, [...this.customTesters, iterableEquality]),\n        )\n          ? `\\n\\n${SUGGEST_TO_CONTAIN_EQUAL}`\n          : '')\n      );\n    };\n\n    return {message, pass};\n  },\n\n  toContainEqual(received: ContainIterable, expected: unknown) {\n    const matcherName = 'toContainEqual';\n    const isNot = this.isNot;\n    const options: MatcherHintOptions = {\n      comment: 'deep equality',\n      isNot,\n      promise: this.promise,\n    };\n\n    if (received == null) {\n      throw new Error(\n        matcherErrorMessage(\n          matcherHint(matcherName, undefined, undefined, options),\n          `${RECEIVED_COLOR('received')} value must not be null nor undefined`,\n          printWithType('Received', received, printReceived),\n        ),\n      );\n    }\n\n    const index = [...received].findIndex(item =>\n      equals(item, expected, [...this.customTesters, iterableEquality]),\n    );\n    const pass = index !== -1;\n\n    const message = () => {\n      const labelExpected = 'Expected value';\n      const labelReceived = `Received ${getType(received)}`;\n      const printLabel = getLabelPrinter(labelExpected, labelReceived);\n\n      return (\n        // eslint-disable-next-line prefer-template\n        matcherHint(matcherName, undefined, undefined, options) +\n        '\\n\\n' +\n        `${printLabel(labelExpected)}${isNot ? 'not ' : ''}${printExpected(\n          expected,\n        )}\\n` +\n        `${printLabel(labelReceived)}${isNot ? '    ' : ''}${\n          isNot && Array.isArray(received)\n            ? printReceivedArrayContainExpectedItem(received, index)\n            : printReceived(received)\n        }`\n      );\n    };\n\n    return {message, pass};\n  },\n\n  toEqual(received: unknown, expected: unknown) {\n    const matcherName = 'toEqual';\n    const options: MatcherHintOptions = {\n      comment: 'deep equality',\n      isNot: this.isNot,\n      promise: this.promise,\n    };\n\n    const pass = equals(received, expected, [\n      ...this.customTesters,\n      iterableEquality,\n    ]);\n\n    const message = pass\n      ? () =>\n          // eslint-disable-next-line prefer-template\n          matcherHint(matcherName, undefined, undefined, options) +\n          '\\n\\n' +\n          `Expected: not ${printExpected(expected)}\\n` +\n          (stringify(expected) === stringify(received)\n            ? ''\n            : `Received:     ${printReceived(received)}`)\n      : () =>\n          // eslint-disable-next-line prefer-template\n          matcherHint(matcherName, undefined, undefined, options) +\n          '\\n\\n' +\n          printDiffOrStringify(\n            expected,\n            received,\n            EXPECTED_LABEL,\n            RECEIVED_LABEL,\n            isExpand(this.expand),\n          );\n\n    // Passing the actual and expected objects so that a custom reporter\n    // could access them, for example in order to display a custom visual diff,\n    // or create a different error message\n    return {actual: received, expected, message, name: matcherName, pass};\n  },\n\n  toHaveLength(received: any, expected: number) {\n    const matcherName = 'toHaveLength';\n    const isNot = this.isNot;\n    const options: MatcherHintOptions = {\n      isNot,\n      promise: this.promise,\n    };\n\n    if (typeof received?.length !== 'number') {\n      throw new TypeError(\n        matcherErrorMessage(\n          matcherHint(matcherName, undefined, undefined, options),\n          `${RECEIVED_COLOR(\n            'received',\n          )} value must have a length property whose value must be a number`,\n          printWithType('Received', received, printReceived),\n        ),\n      );\n    }\n\n    ensureExpectedIsNonNegativeInteger(expected, matcherName, options);\n\n    const pass = received.length === expected;\n\n    const message = () => {\n      const labelExpected = 'Expected length';\n      const labelReceivedLength = 'Received length';\n      const labelReceivedValue = `Received ${getType(received)}`;\n      const printLabel = getLabelPrinter(\n        labelExpected,\n        labelReceivedLength,\n        labelReceivedValue,\n      );\n\n      return (\n        // eslint-disable-next-line prefer-template\n        matcherHint(matcherName, undefined, undefined, options) +\n        '\\n\\n' +\n        `${printLabel(labelExpected)}${isNot ? 'not ' : ''}${printExpected(\n          expected,\n        )}\\n` +\n        (isNot\n          ? ''\n          : `${printLabel(labelReceivedLength)}${printReceived(\n              received.length,\n            )}\\n`) +\n        `${printLabel(labelReceivedValue)}${isNot ? '    ' : ''}${printReceived(\n          received,\n        )}`\n      );\n    };\n\n    return {message, pass};\n  },\n\n  toHaveProperty(\n    received: object,\n    expectedPath: string | Array<string>,\n    expectedValue?: unknown,\n  ) {\n    const matcherName = 'toHaveProperty';\n    const expectedArgument = 'path';\n    const hasValue = arguments.length === 3;\n    const options: MatcherHintOptions = {\n      isNot: this.isNot,\n      promise: this.promise,\n      secondArgument: hasValue ? 'value' : '',\n    };\n\n    if (received === null || received === undefined) {\n      throw new Error(\n        matcherErrorMessage(\n          matcherHint(matcherName, undefined, expectedArgument, options),\n          `${RECEIVED_COLOR('received')} value must not be null nor undefined`,\n          printWithType('Received', received, printReceived),\n        ),\n      );\n    }\n\n    const expectedPathType = getType(expectedPath);\n\n    if (expectedPathType !== 'string' && expectedPathType !== 'array') {\n      throw new Error(\n        matcherErrorMessage(\n          matcherHint(matcherName, undefined, expectedArgument, options),\n          `${EXPECTED_COLOR('expected')} path must be a string or array`,\n          printWithType('Expected', expectedPath, printExpected),\n        ),\n      );\n    }\n\n    const expectedPathLength =\n      typeof expectedPath === 'string'\n        ? pathAsArray(expectedPath).length\n        : expectedPath.length;\n\n    if (expectedPathType === 'array' && expectedPathLength === 0) {\n      throw new Error(\n        matcherErrorMessage(\n          matcherHint(matcherName, undefined, expectedArgument, options),\n          `${EXPECTED_COLOR('expected')} path must not be an empty array`,\n          printWithType('Expected', expectedPath, printExpected),\n        ),\n      );\n    }\n\n    const result = getPath(received, expectedPath);\n    const {lastTraversedObject, endPropIsDefined, hasEndProp, value} = result;\n    const receivedPath = result.traversedPath;\n    const hasCompletePath = receivedPath.length === expectedPathLength;\n    const receivedValue = hasCompletePath ? result.value : lastTraversedObject;\n\n    const pass =\n      hasValue && endPropIsDefined\n        ? equals(value, expectedValue, [\n            ...this.customTesters,\n            iterableEquality,\n          ])\n        : Boolean(hasEndProp);\n\n    const message = pass\n      ? () =>\n          // eslint-disable-next-line prefer-template\n          matcherHint(matcherName, undefined, expectedArgument, options) +\n          '\\n\\n' +\n          (hasValue\n            ? `Expected path: ${printExpected(expectedPath)}\\n\\n` +\n              `Expected value: not ${printExpected(expectedValue)}${\n                stringify(expectedValue) === stringify(receivedValue)\n                  ? ''\n                  : `\\nReceived value:     ${printReceived(receivedValue)}`\n              }`\n            : `Expected path: not ${printExpected(expectedPath)}\\n\\n` +\n              `Received value: ${printReceived(receivedValue)}`)\n      : () =>\n          // eslint-disable-next-line prefer-template\n          matcherHint(matcherName, undefined, expectedArgument, options) +\n          '\\n\\n' +\n          `Expected path: ${printExpected(expectedPath)}\\n` +\n          (hasCompletePath\n            ? `\\n${printDiffOrStringify(\n                expectedValue,\n                receivedValue,\n                EXPECTED_VALUE_LABEL,\n                RECEIVED_VALUE_LABEL,\n                isExpand(this.expand),\n              )}`\n            : `Received path: ${printReceived(\n                expectedPathType === 'array' || receivedPath.length === 0\n                  ? receivedPath\n                  : receivedPath.join('.'),\n              )}\\n\\n${\n                hasValue\n                  ? `Expected value: ${printExpected(expectedValue)}\\n`\n                  : ''\n              }Received value: ${printReceived(receivedValue)}`);\n\n    return {message, pass};\n  },\n\n  toMatch(received: string, expected: string | RegExp) {\n    const matcherName = 'toMatch';\n    const options: MatcherHintOptions = {\n      isNot: this.isNot,\n      promise: this.promise,\n    };\n\n    if (typeof received !== 'string') {\n      throw new TypeError(\n        matcherErrorMessage(\n          matcherHint(matcherName, undefined, undefined, options),\n          `${RECEIVED_COLOR('received')} value must be a string`,\n          printWithType('Received', received, printReceived),\n        ),\n      );\n    }\n\n    if (\n      !(typeof expected === 'string') &&\n      !(expected && typeof expected.test === 'function')\n    ) {\n      throw new Error(\n        matcherErrorMessage(\n          matcherHint(matcherName, undefined, undefined, options),\n          `${EXPECTED_COLOR(\n            'expected',\n          )} value must be a string or regular expression`,\n          printWithType('Expected', expected, printExpected),\n        ),\n      );\n    }\n\n    const pass =\n      typeof expected === 'string'\n        ? received.includes(expected)\n        : new RegExp(expected).test(received);\n\n    const message = pass\n      ? () =>\n          typeof expected === 'string'\n            ? // eslint-disable-next-line prefer-template\n              matcherHint(matcherName, undefined, undefined, options) +\n              '\\n\\n' +\n              `Expected substring: not ${printExpected(expected)}\\n` +\n              `Received string:        ${printReceivedStringContainExpectedSubstring(\n                received,\n                received.indexOf(expected),\n                expected.length,\n              )}`\n            : // eslint-disable-next-line prefer-template\n              matcherHint(matcherName, undefined, undefined, options) +\n              '\\n\\n' +\n              `Expected pattern: not ${printExpected(expected)}\\n` +\n              `Received string:      ${printReceivedStringContainExpectedResult(\n                received,\n                typeof expected.exec === 'function'\n                  ? expected.exec(received)\n                  : null,\n              )}`\n      : () => {\n          const labelExpected = `Expected ${\n            typeof expected === 'string' ? 'substring' : 'pattern'\n          }`;\n          const labelReceived = 'Received string';\n          const printLabel = getLabelPrinter(labelExpected, labelReceived);\n\n          return (\n            // eslint-disable-next-line prefer-template\n            matcherHint(matcherName, undefined, undefined, options) +\n            '\\n\\n' +\n            `${printLabel(labelExpected)}${printExpected(expected)}\\n` +\n            `${printLabel(labelReceived)}${printReceived(received)}`\n          );\n        };\n\n    return {message, pass};\n  },\n\n  toMatchObject(received: object, expected: object) {\n    const matcherName = 'toMatchObject';\n    const options: MatcherHintOptions = {\n      isNot: this.isNot,\n      promise: this.promise,\n    };\n\n    if (typeof received !== 'object' || received === null) {\n      throw new Error(\n        matcherErrorMessage(\n          matcherHint(matcherName, undefined, undefined, options),\n          `${RECEIVED_COLOR('received')} value must be a non-null object`,\n          printWithType('Received', received, printReceived),\n        ),\n      );\n    }\n\n    if (typeof expected !== 'object' || expected === null) {\n      throw new Error(\n        matcherErrorMessage(\n          matcherHint(matcherName, undefined, undefined, options),\n          `${EXPECTED_COLOR('expected')} value must be a non-null object`,\n          printWithType('Expected', expected, printExpected),\n        ),\n      );\n    }\n\n    const pass = equals(received, expected, [\n      ...this.customTesters,\n      iterableEquality,\n      subsetEquality,\n    ]);\n\n    const message = pass\n      ? () =>\n          // eslint-disable-next-line prefer-template\n          matcherHint(matcherName, undefined, undefined, options) +\n          '\\n\\n' +\n          `Expected: not ${printExpected(expected)}` +\n          (stringify(expected) === stringify(received)\n            ? ''\n            : `\\nReceived:     ${printReceived(received)}`)\n      : () =>\n          // eslint-disable-next-line prefer-template\n          matcherHint(matcherName, undefined, undefined, options) +\n          '\\n\\n' +\n          printDiffOrStringify(\n            expected,\n            getObjectSubset(received, expected, this.customTesters),\n            EXPECTED_LABEL,\n            RECEIVED_LABEL,\n            isExpand(this.expand),\n          );\n\n    return {message, pass};\n  },\n\n  toStrictEqual(received: unknown, expected: unknown) {\n    const matcherName = 'toStrictEqual';\n    const options: MatcherHintOptions = {\n      comment: 'deep equality',\n      isNot: this.isNot,\n      promise: this.promise,\n    };\n\n    const pass = equals(\n      received,\n      expected,\n      [...this.customTesters, ...toStrictEqualTesters],\n      true,\n    );\n\n    const message = pass\n      ? () =>\n          // eslint-disable-next-line prefer-template\n          matcherHint(matcherName, undefined, undefined, options) +\n          '\\n\\n' +\n          `Expected: not ${printExpected(expected)}\\n` +\n          (stringify(expected) === stringify(received)\n            ? ''\n            : `Received:     ${printReceived(received)}`)\n      : () =>\n          // eslint-disable-next-line prefer-template\n          matcherHint(matcherName, undefined, undefined, options) +\n          '\\n\\n' +\n          printDiffOrStringify(\n            expected,\n            received,\n            EXPECTED_LABEL,\n            RECEIVED_LABEL,\n            isExpand(this.expand),\n          );\n\n    // Passing the actual and expected objects so that a custom reporter\n    // could access them, for example in order to display a custom visual diff,\n    // or create a different error message\n    return {actual: received, expected, message, name: matcherName, pass};\n  },\n};\n\nexport default matchers;\n",
  "packages/expect/src/matchers.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport type { MatchersObject } from './types';\ndeclare const matchers: MatchersObject;\nexport default matchers;\n",
  "packages/expect/src/jestMatchersObject.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {Tester} from '@jest/expect-utils';\nimport {getType} from '@jest/get-type';\nimport {AsymmetricMatcher} from './asymmetricMatchers';\nimport type {\n  Expect,\n  MatcherState,\n  MatchersObject,\n  SyncExpectationResult,\n} from './types';\n\n// Global matchers object holds the list of available matchers and\n// the state, that can hold matcher specific values that change over time.\nconst JEST_MATCHERS_OBJECT = Symbol.for('$$jest-matchers-object');\n\n// Notes a built-in/internal Jest matcher.\n// Jest may override the stack trace of Errors thrown by internal matchers.\nexport const INTERNAL_MATCHER_FLAG = Symbol.for('$$jest-internal-matcher');\n\nif (!Object.prototype.hasOwnProperty.call(globalThis, JEST_MATCHERS_OBJECT)) {\n  const defaultState: MatcherState = {\n    assertionCalls: 0,\n    expectedAssertionsNumber: null,\n    isExpectingAssertions: false,\n    numPassingAsserts: 0,\n    suppressedErrors: [], // errors that are not thrown immediately.\n  };\n  Object.defineProperty(globalThis, JEST_MATCHERS_OBJECT, {\n    value: {\n      customEqualityTesters: [],\n      matchers: Object.create(null),\n      state: defaultState,\n    },\n  });\n}\n\nexport const getState = <State extends MatcherState = MatcherState>(): State =>\n  (globalThis as any)[JEST_MATCHERS_OBJECT].state;\n\nexport const setState = <State extends MatcherState = MatcherState>(\n  state: Partial<State>,\n): void => {\n  Object.assign((globalThis as any)[JEST_MATCHERS_OBJECT].state, state);\n};\n\nexport const getMatchers = (): MatchersObject =>\n  (globalThis as any)[JEST_MATCHERS_OBJECT].matchers;\n\nexport const setMatchers = (\n  matchers: MatchersObject,\n  isInternal: boolean,\n  expect: Expect,\n): void => {\n  for (const key of Object.keys(matchers)) {\n    const matcher = matchers[key];\n\n    if (typeof matcher !== 'function') {\n      throw new TypeError(\n        `expect.extend: \\`${key}\\` is not a valid matcher. Must be a function, is \"${getType(\n          matcher,\n        )}\"`,\n      );\n    }\n\n    Object.defineProperty(matcher, INTERNAL_MATCHER_FLAG, {\n      value: isInternal,\n    });\n\n    if (!isInternal) {\n      // expect is defined\n\n      class CustomMatcher extends AsymmetricMatcher<\n        [unknown, ...Array<unknown>]\n      > {\n        constructor(inverse = false, ...sample: [unknown, ...Array<unknown>]) {\n          super(sample, inverse);\n        }\n\n        asymmetricMatch(other: unknown) {\n          const {pass} = matcher.call(\n            this.getMatcherContext(),\n            other,\n            ...this.sample,\n          ) as SyncExpectationResult;\n\n          return this.inverse ? !pass : pass;\n        }\n\n        toString() {\n          return `${this.inverse ? 'not.' : ''}${key}`;\n        }\n\n        override getExpectedType() {\n          return 'any';\n        }\n\n        override toAsymmetricMatcher() {\n          return `${this.toString()}<${this.sample.map(String).join(', ')}>`;\n        }\n      }\n\n      Object.defineProperty(expect, key, {\n        configurable: true,\n        enumerable: true,\n        value: (...sample: [unknown, ...Array<unknown>]) =>\n          new CustomMatcher(false, ...sample),\n        writable: true,\n      });\n      Object.defineProperty(expect.not, key, {\n        configurable: true,\n        enumerable: true,\n        value: (...sample: [unknown, ...Array<unknown>]) =>\n          new CustomMatcher(true, ...sample),\n        writable: true,\n      });\n    }\n  }\n\n  Object.assign((globalThis as any)[JEST_MATCHERS_OBJECT].matchers, matchers);\n};\n\nexport const getCustomEqualityTesters = (): Array<Tester> =>\n  (globalThis as any)[JEST_MATCHERS_OBJECT].customEqualityTesters;\n\nexport const addCustomEqualityTesters = (newTesters: Array<Tester>): void => {\n  if (!Array.isArray(newTesters)) {\n    throw new TypeError(\n      `expect.customEqualityTesters: Must be set to an array of Testers. Was given \"${getType(\n        newTesters,\n      )}\"`,\n    );\n  }\n\n  (globalThis as any)[JEST_MATCHERS_OBJECT].customEqualityTesters.push(\n    ...newTesters,\n  );\n};\n",
  "packages/expect/src/jestMatchersObject.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport type { Tester } from '@jest/expect-utils';\nimport type { Expect, MatcherState, MatchersObject } from './types';\nexport declare const INTERNAL_MATCHER_FLAG: unique symbol;\nexport declare const getState: <State extends MatcherState = MatcherState>() => State;\nexport declare const setState: <State extends MatcherState = MatcherState>(state: Partial<State>) => void;\nexport declare const getMatchers: () => MatchersObject;\nexport declare const setMatchers: (matchers: MatchersObject, isInternal: boolean, expect: Expect) => void;\nexport declare const getCustomEqualityTesters: () => Array<Tester>;\nexport declare const addCustomEqualityTesters: (newTesters: Array<Tester>) => void;\n",
  "packages/expect/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/* eslint-disable local/prefer-spread-eventually */\n\nimport {equals, iterableEquality, subsetEquality} from '@jest/expect-utils';\nimport * as matcherUtils from 'jest-matcher-utils';\nimport {ErrorWithStack, isPromise} from 'jest-util';\nimport {\n  any,\n  anything,\n  arrayContaining,\n  arrayNotContaining,\n  arrayOf,\n  closeTo,\n  notArrayOf,\n  notCloseTo,\n  objectContaining,\n  objectNotContaining,\n  stringContaining,\n  stringMatching,\n  stringNotContaining,\n  stringNotMatching,\n} from './asymmetricMatchers';\nimport extractExpectedAssertionsErrors from './extractExpectedAssertionsErrors';\nimport {\n  INTERNAL_MATCHER_FLAG,\n  addCustomEqualityTesters,\n  getCustomEqualityTesters,\n  getMatchers,\n  getState,\n  setMatchers,\n  setState,\n} from './jestMatchersObject';\nimport matchers from './matchers';\nimport spyMatchers from './spyMatchers';\nimport toThrowMatchers, {\n  createMatcher as createThrowMatcher,\n} from './toThrowMatchers';\nimport type {\n  Expect,\n  ExpectationResult,\n  MatcherContext,\n  MatcherState,\n  MatcherUtils,\n  MatchersObject,\n  PromiseMatcherFn,\n  RawMatcherFn,\n  SyncExpectationResult,\n  ThrowingMatcherFn,\n} from './types';\n\nexport type {Tester, TesterContext} from '@jest/expect-utils';\nexport {AsymmetricMatcher} from './asymmetricMatchers';\nexport type {\n  AsyncExpectationResult,\n  AsymmetricMatchers,\n  BaseExpect,\n  Expect,\n  ExpectationResult,\n  Inverse,\n  MatcherContext,\n  MatcherFunction,\n  MatcherFunctionWithContext,\n  MatcherState,\n  MatcherUtils,\n  Matchers,\n  SyncExpectationResult,\n} from './types';\n\nexport class JestAssertionError extends Error {\n  matcherResult?: Omit<SyncExpectationResult, 'message'> & {message: string};\n}\n\nconst createToThrowErrorMatchingSnapshotMatcher = function (\n  matcher: RawMatcherFn,\n) {\n  return function (\n    this: MatcherContext,\n    received: any,\n    testNameOrInlineSnapshot?: string,\n  ) {\n    return matcher.apply(this, [received, testNameOrInlineSnapshot, true]);\n  };\n};\n\nconst getPromiseMatcher = (name: string, matcher: RawMatcherFn) => {\n  if (name === 'toThrow') {\n    return createThrowMatcher(name, true);\n  } else if (\n    name === 'toThrowErrorMatchingSnapshot' ||\n    name === 'toThrowErrorMatchingInlineSnapshot'\n  ) {\n    return createToThrowErrorMatchingSnapshotMatcher(matcher);\n  }\n\n  return null;\n};\n\nexport const expect: Expect = (actual: any, ...rest: Array<any>) => {\n  if (rest.length > 0) {\n    throw new Error('Expect takes at most one argument.');\n  }\n\n  const allMatchers = getMatchers();\n  const expectation: any = {\n    not: {},\n    rejects: {not: {}},\n    resolves: {not: {}},\n  };\n\n  const err = new JestAssertionError();\n\n  for (const name of Object.keys(allMatchers)) {\n    const matcher = allMatchers[name];\n    const promiseMatcher = getPromiseMatcher(name, matcher) || matcher;\n    expectation[name] = makeThrowingMatcher(matcher, false, '', actual);\n    expectation.not[name] = makeThrowingMatcher(matcher, true, '', actual);\n\n    expectation.resolves[name] = makeResolveMatcher(\n      name,\n      promiseMatcher,\n      false,\n      actual,\n      err,\n    );\n    expectation.resolves.not[name] = makeResolveMatcher(\n      name,\n      promiseMatcher,\n      true,\n      actual,\n      err,\n    );\n\n    expectation.rejects[name] = makeRejectMatcher(\n      name,\n      promiseMatcher,\n      false,\n      actual,\n      err,\n    );\n    expectation.rejects.not[name] = makeRejectMatcher(\n      name,\n      promiseMatcher,\n      true,\n      actual,\n      err,\n    );\n  }\n\n  return expectation;\n};\n\nconst getMessage = (message?: () => string) =>\n  (message && message()) ||\n  matcherUtils.RECEIVED_COLOR('No message was specified for this matcher.');\n\nconst makeResolveMatcher =\n  (\n    matcherName: string,\n    matcher: RawMatcherFn,\n    isNot: boolean,\n    actual: Promise<any> | (() => Promise<any>),\n    outerErr: JestAssertionError,\n  ): PromiseMatcherFn =>\n  (...args) => {\n    const options = {\n      isNot,\n      promise: 'resolves',\n    };\n\n    const actualWrapper: Promise<any> =\n      typeof actual === 'function' ? actual() : actual;\n\n    if (!isPromise(actualWrapper)) {\n      throw new JestAssertionError(\n        matcherUtils.matcherErrorMessage(\n          matcherUtils.matcherHint(matcherName, undefined, '', options),\n          `${matcherUtils.RECEIVED_COLOR(\n            'received',\n          )} value must be a promise or a function returning a promise`,\n          matcherUtils.printWithType(\n            'Received',\n            actual,\n            matcherUtils.printReceived,\n          ),\n        ),\n      );\n    }\n\n    const innerErr = new JestAssertionError();\n\n    return actualWrapper.then(\n      result =>\n        makeThrowingMatcher(matcher, isNot, 'resolves', result, innerErr).apply(\n          null,\n          args,\n        ),\n      error => {\n        outerErr.message =\n          `${matcherUtils.matcherHint(\n            matcherName,\n            undefined,\n            '',\n            options,\n          )}\\n\\n` +\n          'Received promise rejected instead of resolved\\n' +\n          `Rejected to value: ${matcherUtils.printReceived(error)}`;\n        throw outerErr;\n      },\n    );\n  };\n\nconst makeRejectMatcher =\n  (\n    matcherName: string,\n    matcher: RawMatcherFn,\n    isNot: boolean,\n    actual: Promise<any> | (() => Promise<any>),\n    outerErr: JestAssertionError,\n  ): PromiseMatcherFn =>\n  (...args) => {\n    const options = {\n      isNot,\n      promise: 'rejects',\n    };\n\n    const actualWrapper: Promise<any> =\n      typeof actual === 'function' ? actual() : actual;\n\n    if (!isPromise(actualWrapper)) {\n      throw new JestAssertionError(\n        matcherUtils.matcherErrorMessage(\n          matcherUtils.matcherHint(matcherName, undefined, '', options),\n          `${matcherUtils.RECEIVED_COLOR(\n            'received',\n          )} value must be a promise or a function returning a promise`,\n          matcherUtils.printWithType(\n            'Received',\n            actual,\n            matcherUtils.printReceived,\n          ),\n        ),\n      );\n    }\n\n    const innerErr = new JestAssertionError();\n\n    return actualWrapper.then(\n      result => {\n        outerErr.message =\n          `${matcherUtils.matcherHint(\n            matcherName,\n            undefined,\n            '',\n            options,\n          )}\\n\\n` +\n          'Received promise resolved instead of rejected\\n' +\n          `Resolved to value: ${matcherUtils.printReceived(result)}`;\n        throw outerErr;\n      },\n      error =>\n        makeThrowingMatcher(matcher, isNot, 'rejects', error, innerErr).apply(\n          null,\n          args,\n        ),\n    );\n  };\n\nconst makeThrowingMatcher = (\n  matcher: RawMatcherFn,\n  isNot: boolean,\n  promise: string,\n  actual: any,\n  err?: JestAssertionError,\n): ThrowingMatcherFn =>\n  function throwingMatcher(...args): any {\n    let throws = true;\n    const utils: MatcherUtils['utils'] = {\n      ...matcherUtils,\n      iterableEquality,\n      subsetEquality,\n    };\n\n    const matcherUtilsThing: MatcherUtils = {\n      customTesters: getCustomEqualityTesters(),\n      // When throws is disabled, the matcher will not throw errors during test\n      // execution but instead add them to the global matcher state. If a\n      // matcher throws, test execution is normally stopped immediately. The\n      // snapshot matcher uses it because we want to log all snapshot\n      // failures in a test.\n      dontThrow: () => (throws = false),\n      equals,\n      utils,\n    };\n\n    const matcherContext: MatcherContext = {\n      ...getState<MatcherState>(),\n      ...matcherUtilsThing,\n      error: err,\n      isNot,\n      promise,\n    };\n\n    const processResult = (\n      result: SyncExpectationResult,\n      asyncError?: JestAssertionError,\n    ) => {\n      _validateResult(result);\n\n      getState().assertionCalls++;\n\n      if ((result.pass && isNot) || (!result.pass && !isNot)) {\n        // XOR\n        const message = getMessage(result.message);\n        let error;\n\n        if (err) {\n          error = err;\n          error.message = message;\n        } else if (asyncError) {\n          error = asyncError;\n          error.message = message;\n        } else {\n          error = new JestAssertionError(message);\n\n          // Try to remove this function from the stack trace frame.\n          // Guard for some environments (browsers) that do not support this feature.\n          if (Error.captureStackTrace) {\n            Error.captureStackTrace(error, throwingMatcher);\n          }\n        }\n        // Passing the result of the matcher with the error so that a custom\n        // reporter could access the actual and expected objects of the result\n        // for example in order to display a custom visual diff\n        error.matcherResult = {...result, message};\n\n        if (throws) {\n          throw error;\n        } else {\n          getState().suppressedErrors.push(error);\n        }\n      } else {\n        getState().numPassingAsserts++;\n      }\n    };\n\n    const handleError = (error: Error) => {\n      if (\n        matcher[INTERNAL_MATCHER_FLAG] === true &&\n        !(error instanceof JestAssertionError) &&\n        error.name !== 'PrettyFormatPluginError' &&\n        // Guard for some environments (browsers) that do not support this feature.\n        Error.captureStackTrace\n      ) {\n        // Try to remove this and deeper functions from the stack trace frame.\n        Error.captureStackTrace(error, throwingMatcher);\n      }\n      throw error;\n    };\n\n    let potentialResult: ExpectationResult;\n\n    try {\n      potentialResult =\n        matcher[INTERNAL_MATCHER_FLAG] === true\n          ? matcher.call(matcherContext, actual, ...args)\n          : // It's a trap specifically for inline snapshot to capture this name\n            // in the stack trace, so that it can correctly get the custom matcher\n            // function call.\n            (function __EXTERNAL_MATCHER_TRAP__() {\n              return matcher.call(matcherContext, actual, ...args);\n            })();\n\n      if (isPromise(potentialResult)) {\n        const asyncError = new JestAssertionError();\n        if (Error.captureStackTrace) {\n          Error.captureStackTrace(asyncError, throwingMatcher);\n        }\n\n        return potentialResult\n          .then(aResult => processResult(aResult, asyncError))\n          .catch(handleError);\n      } else {\n        return processResult(potentialResult);\n      }\n    } catch (error: any) {\n      return handleError(error);\n    }\n  };\n\nexpect.extend = (matchers: MatchersObject) =>\n  setMatchers(matchers, false, expect);\n\nexpect.addEqualityTesters = customTesters =>\n  addCustomEqualityTesters(customTesters);\n\nexpect.anything = anything;\nexpect.any = any;\n\nexpect.not = {\n  arrayContaining: arrayNotContaining,\n  arrayOf: notArrayOf,\n  closeTo: notCloseTo,\n  objectContaining: objectNotContaining,\n  stringContaining: stringNotContaining,\n  stringMatching: stringNotMatching,\n};\n\nexpect.arrayContaining = arrayContaining;\nexpect.arrayOf = arrayOf;\nexpect.closeTo = closeTo;\nexpect.objectContaining = objectContaining;\nexpect.stringContaining = stringContaining;\nexpect.stringMatching = stringMatching;\n\nconst _validateResult = (result: any) => {\n  if (\n    typeof result !== 'object' ||\n    typeof result.pass !== 'boolean' ||\n    (result.message &&\n      typeof result.message !== 'string' &&\n      typeof result.message !== 'function')\n  ) {\n    throw new Error(\n      'Unexpected return from a matcher function.\\n' +\n        'Matcher functions should ' +\n        'return an object in the following format:\\n' +\n        '  {message?: string | function, pass: boolean}\\n' +\n        `'${matcherUtils.stringify(result)}' was returned`,\n    );\n  }\n};\n\nfunction assertions(expected: number): void {\n  const error = new ErrorWithStack(undefined, assertions);\n\n  setState({\n    expectedAssertionsNumber: expected,\n    expectedAssertionsNumberError: error,\n  });\n}\nfunction hasAssertions(...args: Array<unknown>): void {\n  const error = new ErrorWithStack(undefined, hasAssertions);\n\n  matcherUtils.ensureNoExpected(args[0], '.hasAssertions');\n  setState({\n    isExpectingAssertions: true,\n    isExpectingAssertionsError: error,\n  });\n}\n\n// add default jest matchers\nsetMatchers(matchers, true, expect);\nsetMatchers(spyMatchers, true, expect);\nsetMatchers(toThrowMatchers, true, expect);\n\nexpect.assertions = assertions;\nexpect.hasAssertions = hasAssertions;\nexpect.getState = getState;\nexpect.setState = setState;\nexpect.extractExpectedAssertionsErrors = extractExpectedAssertionsErrors;\n\nexport default expect;\n",
  "packages/expect/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport type { Expect, SyncExpectationResult } from './types';\nexport type { Tester, TesterContext } from '@jest/expect-utils';\nexport { AsymmetricMatcher } from './asymmetricMatchers';\nexport type { AsyncExpectationResult, AsymmetricMatchers, BaseExpect, Expect, ExpectationResult, Inverse, MatcherContext, MatcherFunction, MatcherFunctionWithContext, MatcherState, MatcherUtils, Matchers, SyncExpectationResult, } from './types';\nexport declare class JestAssertionError extends Error {\n    matcherResult?: Omit<SyncExpectationResult, 'message'> & {\n        message: string;\n    };\n}\nexport declare const expect: Expect;\nexport default expect;\n",
  "packages/expect/src/extractExpectedAssertionsErrors.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {\n  EXPECTED_COLOR,\n  RECEIVED_COLOR,\n  matcherHint,\n  pluralize,\n} from 'jest-matcher-utils';\nimport {getState, setState} from './jestMatchersObject';\nimport type {Expect, ExpectedAssertionsErrors} from './types';\n\nconst resetAssertionsLocalState = () => {\n  setState({\n    assertionCalls: 0,\n    expectedAssertionsNumber: null,\n    isExpectingAssertions: false,\n    numPassingAsserts: 0,\n  });\n};\n\n// Create and format all errors related to the mismatched number of `expect`\n// calls and reset the matcher's state.\nconst extractExpectedAssertionsErrors: Expect['extractExpectedAssertionsErrors'] =\n  () => {\n    const result: ExpectedAssertionsErrors = [];\n    const {\n      assertionCalls,\n      expectedAssertionsNumber,\n      expectedAssertionsNumberError,\n      isExpectingAssertions,\n      isExpectingAssertionsError,\n    } = getState();\n\n    resetAssertionsLocalState();\n\n    if (\n      typeof expectedAssertionsNumber === 'number' &&\n      assertionCalls !== expectedAssertionsNumber\n    ) {\n      const numOfAssertionsExpected = EXPECTED_COLOR(\n        pluralize('assertion', expectedAssertionsNumber),\n      );\n\n      expectedAssertionsNumberError!.message =\n        `${matcherHint('.assertions', '', expectedAssertionsNumber.toString(), {\n          isDirectExpectCall: true,\n        })}\\n\\n` +\n        `Expected ${numOfAssertionsExpected} to be called but received ${RECEIVED_COLOR(\n          pluralize('assertion call', assertionCalls || 0),\n        )}.`;\n\n      result.push({\n        actual: assertionCalls.toString(),\n        error: expectedAssertionsNumberError!,\n        expected: expectedAssertionsNumber.toString(),\n      });\n    }\n    if (isExpectingAssertions && assertionCalls === 0) {\n      const expected = EXPECTED_COLOR('at least one assertion');\n      const received = RECEIVED_COLOR('received none');\n\n      isExpectingAssertionsError!.message = `${matcherHint(\n        '.hasAssertions',\n        '',\n        '',\n        {isDirectExpectCall: true},\n      )}\\n\\nExpected ${expected} to be called but ${received}.`;\n\n      result.push({\n        actual: 'none',\n        error: isExpectingAssertionsError!,\n        expected: 'at least one',\n      });\n    }\n\n    return result;\n  };\n\nexport default extractExpectedAssertionsErrors;\n",
  "packages/expect/src/extractExpectedAssertionsErrors.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport type { Expect } from './types';\ndeclare const extractExpectedAssertionsErrors: Expect['extractExpectedAssertionsErrors'];\nexport default extractExpectedAssertionsErrors;\n",
  "packages/expect/src/asymmetricMatchers.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {\n  equals,\n  getObjectKeys,\n  isA,\n  iterableEquality,\n  subsetEquality,\n} from '@jest/expect-utils';\nimport * as matcherUtils from 'jest-matcher-utils';\nimport {pluralize} from 'jest-util';\nimport {getCustomEqualityTesters, getState} from './jestMatchersObject';\nimport type {\n  AsymmetricMatcher as AsymmetricMatcherInterface,\n  MatcherContext,\n  MatcherState,\n} from './types';\n\nconst functionToString = Function.prototype.toString;\n\nfunction fnNameFor(func: () => unknown) {\n  if (func.name) {\n    return func.name;\n  }\n\n  const matches = functionToString\n    .call(func)\n    .match(/^(?:async)?\\s*function\\s*\\*?\\s*([\\w$]+)\\s*\\(/);\n  return matches ? matches[1] : '<anonymous>';\n}\n\nconst utils = Object.freeze({\n  ...matcherUtils,\n  iterableEquality,\n  subsetEquality,\n});\n\nexport function hasProperty(\n  obj: object | null,\n  property: string | symbol,\n): boolean {\n  if (!obj) {\n    return false;\n  }\n\n  if (Object.prototype.hasOwnProperty.call(obj, property)) {\n    return true;\n  }\n\n  return hasProperty(Object.getPrototypeOf(obj), property);\n}\n\nexport abstract class AsymmetricMatcher<T>\n  implements AsymmetricMatcherInterface\n{\n  $$typeof = Symbol.for('jest.asymmetricMatcher');\n\n  constructor(\n    protected sample: T,\n    protected inverse = false,\n  ) {}\n\n  protected getMatcherContext(): MatcherContext {\n    return {\n      customTesters: getCustomEqualityTesters(),\n      // eslint-disable-next-line @typescript-eslint/no-empty-function\n      dontThrow: () => {},\n      ...getState<MatcherState>(),\n      equals,\n      isNot: this.inverse,\n      utils,\n    };\n  }\n\n  abstract asymmetricMatch(other: unknown): boolean;\n  abstract toString(): string;\n  getExpectedType?(): string;\n  toAsymmetricMatcher?(): string;\n}\n\nclass Any extends AsymmetricMatcher<any> {\n  constructor(sample: unknown) {\n    if (sample === undefined) {\n      throw new TypeError(\n        'any() expects to be passed a constructor function. ' +\n          'Please pass one or use anything() to match any object.',\n      );\n    }\n    super(sample);\n  }\n\n  asymmetricMatch(other: unknown) {\n    if (this.sample === String) {\n      // eslint-disable-next-line unicorn/no-instanceof-builtins\n      return typeof other === 'string' || other instanceof String;\n    }\n\n    if (this.sample === Number) {\n      // eslint-disable-next-line unicorn/no-instanceof-builtins\n      return typeof other === 'number' || other instanceof Number;\n    }\n\n    if (this.sample === Function) {\n      // eslint-disable-next-line unicorn/no-instanceof-builtins\n      return typeof other === 'function' || other instanceof Function;\n    }\n\n    if (this.sample === Boolean) {\n      // eslint-disable-next-line unicorn/no-instanceof-builtins\n      return typeof other === 'boolean' || other instanceof Boolean;\n    }\n\n    if (this.sample === BigInt) {\n      // eslint-disable-next-line unicorn/no-instanceof-builtins\n      return typeof other === 'bigint' || other instanceof BigInt;\n    }\n\n    if (this.sample === Symbol) {\n      // eslint-disable-next-line unicorn/no-instanceof-builtins\n      return typeof other === 'symbol' || other instanceof Symbol;\n    }\n\n    if (this.sample === Object) {\n      return typeof other === 'object';\n    }\n\n    if (this.sample === Array) {\n      return Array.isArray(other);\n    }\n\n    return other instanceof this.sample;\n  }\n\n  toString() {\n    return 'Any';\n  }\n\n  override getExpectedType() {\n    if (this.sample === String) {\n      return 'string';\n    }\n\n    if (this.sample === Number) {\n      return 'number';\n    }\n\n    if (this.sample === Function) {\n      return 'function';\n    }\n\n    if (this.sample === Object) {\n      return 'object';\n    }\n\n    if (this.sample === Boolean) {\n      return 'boolean';\n    }\n\n    if (this.sample === Array) {\n      return 'array';\n    }\n\n    return fnNameFor(this.sample);\n  }\n\n  override toAsymmetricMatcher() {\n    return `Any<${fnNameFor(this.sample)}>`;\n  }\n}\n\nclass Anything extends AsymmetricMatcher<void> {\n  asymmetricMatch(other: unknown) {\n    return other != null;\n  }\n\n  toString() {\n    return 'Anything';\n  }\n\n  // No getExpectedType method, because it matches either null or undefined.\n\n  override toAsymmetricMatcher() {\n    return 'Anything';\n  }\n}\n\nclass ArrayContaining extends AsymmetricMatcher<Array<unknown>> {\n  constructor(sample: Array<unknown>, inverse = false) {\n    super(sample, inverse);\n  }\n\n  asymmetricMatch(other: unknown) {\n    if (!Array.isArray(this.sample)) {\n      throw new TypeError(\n        `You must provide an array to ${this.toString()}, not '${typeof this\n          .sample}'.`,\n      );\n    }\n\n    const matcherContext = this.getMatcherContext();\n    const result =\n      this.sample.length === 0 ||\n      (Array.isArray(other) &&\n        this.sample.every(item =>\n          other.some(another =>\n            equals(item, another, matcherContext.customTesters),\n          ),\n        ));\n\n    return this.inverse ? !result : result;\n  }\n\n  toString() {\n    return `Array${this.inverse ? 'Not' : ''}Containing`;\n  }\n\n  override getExpectedType() {\n    return 'array';\n  }\n}\n\nclass ArrayOf extends AsymmetricMatcher<unknown> {\n  asymmetricMatch(other: unknown) {\n    const matcherContext = this.getMatcherContext();\n    const result =\n      Array.isArray(other) &&\n      other.every(item =>\n        equals(this.sample, item, matcherContext.customTesters),\n      );\n\n    return this.inverse ? !result : result;\n  }\n\n  toString() {\n    return `${this.inverse ? 'Not' : ''}ArrayOf`;\n  }\n\n  override getExpectedType() {\n    return 'array';\n  }\n}\n\nclass ObjectContaining extends AsymmetricMatcher<\n  Record<string | symbol, unknown>\n> {\n  constructor(sample: Record<string | symbol, unknown>, inverse = false) {\n    super(sample, inverse);\n  }\n\n  asymmetricMatch(other: any) {\n    // Ensures that the argument passed to the objectContaining method is an object\n    if (typeof this.sample !== 'object') {\n      throw new TypeError(\n        `You must provide an object to ${this.toString()}, not '${typeof this\n          .sample}'.`,\n      );\n    }\n\n    // Ensures that the argument passed to the expect function is an object\n    // This is necessary to avoid matching of non-object values\n    // Arrays are a special type of object, but having a valid match with a standard object\n    // does not make sense, hence we do a simple array check\n    if (typeof other !== 'object' || Array.isArray(other)) {\n      return false;\n    }\n\n    let result = true;\n\n    const matcherContext = this.getMatcherContext();\n    const objectKeys = getObjectKeys(this.sample);\n\n    for (const key of objectKeys) {\n      if (\n        !hasProperty(other, key) ||\n        !equals(this.sample[key], other[key], matcherContext.customTesters)\n      ) {\n        result = false;\n        break;\n      }\n    }\n\n    return this.inverse ? !result : result;\n  }\n\n  toString() {\n    return `Object${this.inverse ? 'Not' : ''}Containing`;\n  }\n\n  override getExpectedType() {\n    return 'object';\n  }\n}\n\nclass StringContaining extends AsymmetricMatcher<string> {\n  constructor(sample: string, inverse = false) {\n    if (!isA('String', sample)) {\n      throw new Error('Expected is not a string');\n    }\n    super(sample, inverse);\n  }\n\n  asymmetricMatch(other: unknown) {\n    const result = isA<string>('String', other) && other.includes(this.sample);\n\n    return this.inverse ? !result : result;\n  }\n\n  toString() {\n    return `String${this.inverse ? 'Not' : ''}Containing`;\n  }\n\n  override getExpectedType() {\n    return 'string';\n  }\n}\n\nclass StringMatching extends AsymmetricMatcher<RegExp> {\n  constructor(sample: string | RegExp, inverse = false) {\n    if (!isA('String', sample) && !isA('RegExp', sample)) {\n      throw new Error('Expected is not a String or a RegExp');\n    }\n    super(new RegExp(sample), inverse);\n  }\n\n  asymmetricMatch(other: unknown) {\n    const result = isA<string>('String', other) && this.sample.test(other);\n\n    return this.inverse ? !result : result;\n  }\n\n  toString() {\n    return `String${this.inverse ? 'Not' : ''}Matching`;\n  }\n\n  override getExpectedType() {\n    return 'string';\n  }\n}\n\nclass CloseTo extends AsymmetricMatcher<number> {\n  private readonly precision: number;\n\n  constructor(sample: number, precision = 2, inverse = false) {\n    if (!isA('Number', sample)) {\n      throw new Error('Expected is not a Number');\n    }\n\n    if (!isA('Number', precision)) {\n      throw new Error('Precision is not a Number');\n    }\n\n    super(sample);\n    this.inverse = inverse;\n    this.precision = precision;\n  }\n\n  asymmetricMatch(other: unknown) {\n    if (!isA<number>('Number', other)) {\n      return false;\n    }\n    let result = false;\n    if (\n      other === Number.POSITIVE_INFINITY &&\n      this.sample === Number.POSITIVE_INFINITY\n    ) {\n      result = true; // Infinity - Infinity is NaN\n    } else if (\n      other === Number.NEGATIVE_INFINITY &&\n      this.sample === Number.NEGATIVE_INFINITY\n    ) {\n      result = true; // -Infinity - -Infinity is NaN\n    } else {\n      result =\n        Math.abs(this.sample - other) < Math.pow(10, -this.precision) / 2;\n    }\n    return this.inverse ? !result : result;\n  }\n\n  toString() {\n    return `Number${this.inverse ? 'Not' : ''}CloseTo`;\n  }\n\n  override getExpectedType() {\n    return 'number';\n  }\n\n  override toAsymmetricMatcher(): string {\n    return [\n      this.toString(),\n      this.sample,\n      `(${pluralize('digit', this.precision)})`,\n    ].join(' ');\n  }\n}\n\nexport const any = (expectedObject: unknown): Any => new Any(expectedObject);\nexport const anything = (): Anything => new Anything();\nexport const arrayContaining = (sample: Array<unknown>): ArrayContaining =>\n  new ArrayContaining(sample);\nexport const arrayNotContaining = (sample: Array<unknown>): ArrayContaining =>\n  new ArrayContaining(sample, true);\nexport const arrayOf = (sample: unknown): ArrayOf => new ArrayOf(sample);\nexport const notArrayOf = (sample: unknown): ArrayOf =>\n  new ArrayOf(sample, true);\nexport const objectContaining = (\n  sample: Record<string, unknown>,\n): ObjectContaining => new ObjectContaining(sample);\nexport const objectNotContaining = (\n  sample: Record<string, unknown>,\n): ObjectContaining => new ObjectContaining(sample, true);\nexport const stringContaining = (expected: string): StringContaining =>\n  new StringContaining(expected);\nexport const stringNotContaining = (expected: string): StringContaining =>\n  new StringContaining(expected, true);\nexport const stringMatching = (expected: string | RegExp): StringMatching =>\n  new StringMatching(expected);\nexport const stringNotMatching = (expected: string | RegExp): StringMatching =>\n  new StringMatching(expected, true);\nexport const closeTo = (expected: number, precision?: number): CloseTo =>\n  new CloseTo(expected, precision);\nexport const notCloseTo = (expected: number, precision?: number): CloseTo =>\n  new CloseTo(expected, precision, true);\n",
  "packages/expect/src/asymmetricMatchers.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport type { AsymmetricMatcher as AsymmetricMatcherInterface, MatcherContext } from './types';\nexport declare function hasProperty(obj: object | null, property: string | symbol): boolean;\nexport declare abstract class AsymmetricMatcher<T> implements AsymmetricMatcherInterface {\n    protected sample: T;\n    protected inverse: boolean;\n    $$typeof: symbol;\n    constructor(sample: T, inverse?: boolean);\n    protected getMatcherContext(): MatcherContext;\n    abstract asymmetricMatch(other: unknown): boolean;\n    abstract toString(): string;\n    getExpectedType?(): string;\n    toAsymmetricMatcher?(): string;\n}\ndeclare class Any extends AsymmetricMatcher<any> {\n    constructor(sample: unknown);\n    asymmetricMatch(other: unknown): boolean;\n    toString(): string;\n    getExpectedType(): string;\n    toAsymmetricMatcher(): string;\n}\ndeclare class Anything extends AsymmetricMatcher<void> {\n    asymmetricMatch(other: unknown): other is {};\n    toString(): string;\n    toAsymmetricMatcher(): string;\n}\ndeclare class ArrayContaining extends AsymmetricMatcher<Array<unknown>> {\n    constructor(sample: Array<unknown>, inverse?: boolean);\n    asymmetricMatch(other: unknown): boolean;\n    toString(): string;\n    getExpectedType(): string;\n}\ndeclare class ArrayOf extends AsymmetricMatcher<unknown> {\n    asymmetricMatch(other: unknown): boolean;\n    toString(): string;\n    getExpectedType(): string;\n}\ndeclare class ObjectContaining extends AsymmetricMatcher<Record<string | symbol, unknown>> {\n    constructor(sample: Record<string | symbol, unknown>, inverse?: boolean);\n    asymmetricMatch(other: any): boolean;\n    toString(): string;\n    getExpectedType(): string;\n}\ndeclare class StringContaining extends AsymmetricMatcher<string> {\n    constructor(sample: string, inverse?: boolean);\n    asymmetricMatch(other: unknown): any;\n    toString(): string;\n    getExpectedType(): string;\n}\ndeclare class StringMatching extends AsymmetricMatcher<RegExp> {\n    constructor(sample: string | RegExp, inverse?: boolean);\n    asymmetricMatch(other: unknown): any;\n    toString(): string;\n    getExpectedType(): string;\n}\ndeclare class CloseTo extends AsymmetricMatcher<number> {\n    private readonly precision;\n    constructor(sample: number, precision?: number, inverse?: boolean);\n    asymmetricMatch(other: unknown): boolean;\n    toString(): string;\n    getExpectedType(): string;\n    toAsymmetricMatcher(): string;\n}\nexport declare const any: (expectedObject: unknown) => Any;\nexport declare const anything: () => Anything;\nexport declare const arrayContaining: (sample: Array<unknown>) => ArrayContaining;\nexport declare const arrayNotContaining: (sample: Array<unknown>) => ArrayContaining;\nexport declare const arrayOf: (sample: unknown) => ArrayOf;\nexport declare const notArrayOf: (sample: unknown) => ArrayOf;\nexport declare const objectContaining: (sample: Record<string, unknown>) => ObjectContaining;\nexport declare const objectNotContaining: (sample: Record<string, unknown>) => ObjectContaining;\nexport declare const stringContaining: (expected: string) => StringContaining;\nexport declare const stringNotContaining: (expected: string) => StringContaining;\nexport declare const stringMatching: (expected: string | RegExp) => StringMatching;\nexport declare const stringNotMatching: (expected: string | RegExp) => StringMatching;\nexport declare const closeTo: (expected: number, precision?: number) => CloseTo;\nexport declare const notCloseTo: (expected: number, precision?: number) => CloseTo;\nexport {};\n",
  "packages/expect/src/__tests__/toThrowMatchers.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {alignedAnsiStyleSerializer} from '@jest/test-utils';\nimport jestExpect from '../';\n\nexpect.addSnapshotSerializer(alignedAnsiStyleSerializer);\n\n// Custom Error class because node versions have different stack trace strings.\nclass CustomError extends Error {\n  constructor(message?: string) {\n    super(message);\n    this.name = 'Error';\n    this.stack =\n      'Error\\n' +\n      '  at jestExpect' +\n      ' (packages/expect/src/__tests__/toThrowMatchers-test.js:24:74)';\n  }\n}\n\ndescribe('toThrow', () => {\n  class Err extends CustomError {}\n  class Err2 extends CustomError {}\n\n  test('to throw or not to throw', () => {\n    jestExpect(() => {\n      throw new CustomError('apple');\n    }).toThrow();\n    jestExpect(() => {}).not.toThrow();\n  });\n\n  describe('substring', () => {\n    it('passes', () => {\n      jestExpect(() => {\n        throw new CustomError('apple');\n      }).toThrow('apple');\n      jestExpect(() => {\n        throw new CustomError('banana');\n      }).not.toThrow('apple');\n      jestExpect(() => {}).not.toThrow('apple');\n    });\n\n    test('did not throw at all', () => {\n      expect(() =>\n        jestExpect(() => {}).toThrow('apple'),\n      ).toThrowErrorMatchingSnapshot();\n    });\n\n    test('threw, but message did not match (error)', () => {\n      expect(() => {\n        jestExpect(() => {\n          throw new CustomError('apple');\n        }).toThrow('banana');\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('threw, but message did not match (non-error falsey)', () => {\n      expect(() => {\n        jestExpect(() => {\n          // eslint-disable-next-line no-throw-literal\n          throw '';\n        }).toThrow('Server Error');\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    it('properly escapes strings when matching against errors', () => {\n      jestExpect(() => {\n        throw new TypeError('\"this\"? throws.');\n      }).toThrow('\"this\"? throws.');\n    });\n\n    test('threw, but message should not match (error)', () => {\n      expect(() => {\n        jestExpect(() => {\n          throw new CustomError('Invalid array length');\n        }).not.toThrow('array');\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('threw, but message should not match (non-error truthy)', () => {\n      expect(() => {\n        jestExpect(() => {\n          // eslint-disable-next-line no-throw-literal\n          throw 'Internal Server Error';\n        }).not.toThrow('Server Error');\n      }).toThrowErrorMatchingSnapshot();\n    });\n  });\n\n  describe('regexp', () => {\n    it('passes', () => {\n      jestExpect(() => {\n        throw new CustomError('apple');\n      }).toThrow(/apple/);\n      jestExpect(() => {\n        throw new CustomError('banana');\n      }).not.toThrow(/apple/);\n      jestExpect(() => {}).not.toThrow(/apple/);\n    });\n\n    test('did not throw at all', () => {\n      expect(() =>\n        jestExpect(() => {}).toThrow(/apple/),\n      ).toThrowErrorMatchingSnapshot();\n    });\n\n    test('threw, but message did not match (error)', () => {\n      expect(() => {\n        jestExpect(() => {\n          throw new CustomError('apple');\n        }).toThrow(/banana/);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('threw, but message did not match (non-error falsey)', () => {\n      expect(() => {\n        jestExpect(() => {\n          // eslint-disable-next-line no-throw-literal\n          throw 0;\n        }).toThrow(/^[1-9]\\d*/);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('threw, but message should not match (error)', () => {\n      expect(() => {\n        jestExpect(() => {\n          throw new CustomError('Invalid array length');\n        }).not.toThrow(/ array /);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('threw, but message should not match (non-error truthy)', () => {\n      expect(() => {\n        jestExpect(() => {\n          // eslint-disable-next-line no-throw-literal\n          throw 404;\n        }).not.toThrow(/^[1-9]\\d*/);\n      }).toThrowErrorMatchingSnapshot();\n    });\n  });\n\n  describe('error class', () => {\n    class SubErr extends Err {\n      constructor(message?: string) {\n        super(message);\n        // In a carefully written error subclass,\n        // name property is equal to constructor name.\n        this.name = this.constructor.name;\n      }\n    }\n\n    class SubSubErr extends SubErr {\n      constructor(message?: string) {\n        super(message);\n        // In a carefully written error subclass,\n        // name property is equal to constructor name.\n        this.name = this.constructor.name;\n      }\n    }\n\n    it('passes', () => {\n      jestExpect(() => {\n        throw new Err();\n      }).toThrow(Err);\n      jestExpect(() => {\n        throw new Err();\n      }).toThrow(CustomError);\n      jestExpect(() => {\n        throw new SubErr();\n      }).toThrow(new SubErr());\n      jestExpect(() => {\n        throw new Err();\n      }).not.toThrow(Err2);\n      jestExpect(() => {}).not.toThrow(Err);\n      jestExpect(() => {\n        throw new SubErr();\n      }).not.toThrow(new SubSubErr());\n    });\n\n    test('did not throw at all', () => {\n      expect(() =>\n        expect(() => {}).toThrow(Err),\n      ).toThrowErrorMatchingSnapshot();\n    });\n\n    test('threw, but class did not match (error)', () => {\n      expect(() => {\n        jestExpect(() => {\n          throw new Err('apple');\n        }).toThrow(Err2);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('threw, but class did not match (non-error falsey)', () => {\n      expect(() => {\n        jestExpect(() => {\n          // eslint-disable-next-line no-throw-literal\n          throw undefined;\n        }).toThrow(Err2);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('threw, but class should not match (error)', () => {\n      expect(() => {\n        jestExpect(() => {\n          throw new Err('apple');\n        }).not.toThrow(Err);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('threw, but class should not match (error subclass)', () => {\n      expect(() => {\n        jestExpect(() => {\n          throw new SubErr('apple');\n        }).not.toThrow(Err);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('threw, but class should not match (error subsubclass)', () => {\n      expect(() => {\n        jestExpect(() => {\n          throw new SubSubErr('apple');\n        }).not.toThrow(Err);\n      }).toThrowErrorMatchingSnapshot();\n    });\n  });\n\n  describe('error-message', () => {\n    // Received message in report if object has message property.\n    class ErrorMessage {\n      // not extending Error!\n      constructor(public message: string) {}\n    }\n    const expected = new ErrorMessage('apple');\n\n    describe('pass', () => {\n      test('isNot false', () => {\n        jestExpect(() => {\n          throw new ErrorMessage('apple');\n        }).toThrow(expected);\n      });\n\n      test('isNot true', () => {\n        jestExpect(() => {\n          throw new ErrorMessage('banana');\n        }).not.toThrow(expected);\n      });\n    });\n\n    describe('fail', () => {\n      test('isNot false', () => {\n        expect(() =>\n          jestExpect(() => {\n            throw new ErrorMessage('banana');\n          }).toThrow(expected),\n        ).toThrowErrorMatchingSnapshot();\n      });\n\n      test('isNot true', () => {\n        const message = 'Invalid array length';\n        expect(() =>\n          jestExpect(() => {\n            throw new ErrorMessage(message);\n          }).not.toThrow({message}),\n        ).toThrowErrorMatchingSnapshot();\n      });\n\n      test('multiline diff highlight incorrect expected space', () => {\n        // jest/issues/2673\n        const a =\n          \"There is no route defined for key Settings. \\nMust be one of: 'Home'\";\n        const b =\n          \"There is no route defined for key Settings.\\nMust be one of: 'Home'\";\n        expect(() =>\n          jestExpect(() => {\n            throw new ErrorMessage(b);\n          }).toThrow({message: a}),\n        ).toThrowErrorMatchingSnapshot();\n      });\n    });\n  });\n\n  describe('error message and cause', () => {\n    const errorA = new Error('A');\n    const errorB = new Error('B', {cause: errorA});\n    const expected = new Error('good', {cause: errorB});\n\n    describe('pass', () => {\n      test('isNot false', () => {\n        jestExpect(() => {\n          throw new Error('good', {cause: errorB});\n        }).toThrow(expected);\n      });\n\n      test('isNot true, incorrect message', () => {\n        jestExpect(() => {\n          throw new Error('bad', {cause: errorB});\n        }).not.toThrow(expected);\n      });\n\n      test('isNot true, incorrect cause', () => {\n        jestExpect(() => {\n          throw new Error('good', {cause: errorA});\n        }).not.toThrow(expected);\n      });\n\n      test('isNot false, compare Error with object', () => {\n        jestExpect(() => {\n          throw errorB;\n        }).toThrow({\n          cause: {\n            message: 'A',\n          },\n          message: 'B',\n        });\n      });\n\n      test('isNot false, cause is string', () => {\n        jestExpect(() => {\n          throw new Error('Message', {cause: 'line 123'});\n        }).toThrow({\n          cause: 'line 123',\n          message: 'Message',\n        });\n      });\n\n      test('isNot false, cause is bigint', () => {\n        jestExpect(() => {\n          throw new Error('Message', {cause: 0n});\n        }).toThrow({\n          cause: 0n,\n          message: 'Message',\n        });\n      });\n\n      test('isNot false, cause is object', () => {\n        jestExpect(() => {\n          throw new Error('Message', {\n            cause: {prop1: true, prop2: false, prop3: null, prop4: undefined},\n          });\n        }).toThrow({\n          cause: {prop1: true, prop2: false, prop3: null, prop4: undefined},\n          message: 'Message',\n        });\n      });\n    });\n\n    describe('fail', () => {\n      test('isNot false, incorrect message', () => {\n        expect(() =>\n          jestExpect(() => {\n            throw new Error('bad', {cause: errorB});\n          }).toThrow(expected),\n        ).toThrow(\n          /^(?=.*Expected message and cause: ).*Received message and cause: /s,\n        );\n      });\n\n      test('isNot true, incorrect cause', () => {\n        expect(() =>\n          jestExpect(() => {\n            throw new Error('good', {cause: errorA});\n          }).toThrow(expected),\n        ).toThrow(\n          /^(?=.*Expected message and cause: ).*Received message and cause: /s,\n        );\n      });\n    });\n  });\n\n  describe('aggregate-errors', () => {\n    const fetchFromApi1 = Promise.reject(new Error('API 1 failed'));\n    const fetchFromApi2 = Promise.reject(new Error('API 2 failed'));\n    const promiseAny = Promise.any([fetchFromApi1, fetchFromApi2]);\n\n    test('string', () => {\n      jestExpect(promiseAny).rejects.toThrow('All promises were rejected');\n    });\n\n    test('undefined', () => {\n      jestExpect(promiseAny).rejects.toThrow();\n    });\n\n    test('asymmetricMatch', () => {\n      jestExpect(promiseAny).rejects.toThrow(\n        expect.objectContaining({\n          message: 'All promises were rejected',\n        }),\n      );\n    });\n\n    test('regexp', () => {\n      jestExpect(promiseAny).rejects.toThrow(/All promises were rejected/);\n    });\n\n    test('class', () => {\n      jestExpect(promiseAny).rejects.toThrow(AggregateError);\n    });\n  });\n\n  describe('asymmetric', () => {\n    describe('any-Class', () => {\n      describe('pass', () => {\n        test('isNot false', () => {\n          jestExpect(() => {\n            throw new Err('apple');\n          }).toThrow(expect.any(Err));\n        });\n\n        test('isNot true', () => {\n          jestExpect(() => {\n            throw new Err('apple');\n          }).not.toThrow(expect.any(Err2));\n        });\n      });\n\n      describe('fail', () => {\n        test('isNot false', () => {\n          expect(() =>\n            jestExpect(() => {\n              throw new Err('apple');\n            }).toThrow(expect.any(Err2)),\n          ).toThrowErrorMatchingSnapshot();\n        });\n\n        test('isNot true', () => {\n          expect(() =>\n            jestExpect(() => {\n              throw new Err('apple');\n            }).not.toThrow(expect.any(Err)),\n          ).toThrowErrorMatchingSnapshot();\n        });\n      });\n    });\n\n    describe('anything', () => {\n      describe('pass', () => {\n        test('isNot false', () => {\n          jestExpect(() => {\n            throw new CustomError('apple');\n          }).toThrow(expect.anything());\n        });\n\n        test('isNot true', () => {\n          jestExpect(() => {}).not.toThrow(expect.anything());\n          jestExpect(() => {\n            // eslint-disable-next-line no-throw-literal\n            throw null;\n          }).not.toThrow(expect.anything());\n        });\n      });\n\n      describe('fail', () => {\n        test('isNot false', () => {\n          expect(() =>\n            jestExpect(() => {\n              // eslint-disable-next-line no-throw-literal\n              throw null;\n            }).toThrow(expect.anything()),\n          ).toThrowErrorMatchingSnapshot();\n        });\n\n        test('isNot true', () => {\n          expect(() =>\n            jestExpect(() => {\n              throw new CustomError('apple');\n            }).not.toThrow(expect.anything()),\n          ).toThrowErrorMatchingSnapshot();\n        });\n      });\n    });\n\n    describe('no-symbol', () => {\n      // Test serialization of asymmetric matcher which has no property:\n      // this.$$typeof = Symbol.for('jest.asymmetricMatcher')\n      const matchError = {\n        asymmetricMatch(received: Error | null | undefined) {\n          return (\n            received !== null &&\n            received !== undefined &&\n            received.name === 'Error'\n          );\n        },\n      };\n      const matchNotError = {\n        asymmetricMatch(received: Error | null | undefined) {\n          return (\n            received !== null &&\n            received !== undefined &&\n            received.name !== 'Error'\n          );\n        },\n      };\n\n      describe('pass', () => {\n        test('isNot false', () => {\n          jestExpect(() => {\n            throw new CustomError('apple');\n          }).toThrow(matchError);\n        });\n\n        test('isNot true', () => {\n          jestExpect(() => {\n            throw new CustomError('apple');\n          }).not.toThrow(matchNotError);\n        });\n      });\n\n      describe('fail', () => {\n        test('isNot false', () => {\n          expect(() =>\n            jestExpect(() => {\n              throw new CustomError('apple');\n            }).toThrow(matchNotError),\n          ).toThrowErrorMatchingSnapshot();\n        });\n\n        test('isNot true', () => {\n          expect(() =>\n            jestExpect(() => {\n              throw new CustomError('apple');\n            }).not.toThrow(matchError),\n          ).toThrowErrorMatchingSnapshot();\n        });\n      });\n    });\n\n    describe('objectContaining', () => {\n      const matchError = expect.objectContaining({\n        name: 'Error',\n      });\n      const matchNotError = expect.objectContaining({\n        name: 'NotError',\n      });\n\n      describe('pass', () => {\n        test('isNot false', () => {\n          jestExpect(() => {\n            throw new CustomError('apple');\n          }).toThrow(matchError);\n        });\n\n        test('isNot true', () => {\n          jestExpect(() => {\n            throw new CustomError('apple');\n          }).not.toThrow(matchNotError);\n        });\n      });\n\n      describe('fail', () => {\n        test('isNot false', () => {\n          expect(() =>\n            jestExpect(() => {\n              throw new CustomError('apple');\n            }).toThrow(matchNotError),\n          ).toThrowErrorMatchingSnapshot();\n        });\n\n        test('isNot true', () => {\n          expect(() =>\n            jestExpect(() => {\n              throw new CustomError('apple');\n            }).not.toThrow(matchError),\n          ).toThrowErrorMatchingSnapshot();\n        });\n      });\n    });\n  });\n\n  describe('promise/async throws if Error-like object is returned', () => {\n    const asyncFn = async (shouldThrow?: boolean, resolve?: boolean) => {\n      let err;\n      if (shouldThrow) {\n        err = new Err('async apple');\n      }\n      if (resolve) {\n        return err || 'apple';\n      } else {\n        throw err || 'apple';\n      }\n    };\n\n    test('passes', async () => {\n      expect.assertions(24);\n      await jestExpect(Promise.reject(new Error())).rejects.toThrow();\n\n      await jestExpect(asyncFn(true)).rejects.toThrow();\n      await jestExpect(asyncFn(true)).rejects.toThrow(Err);\n      await jestExpect(asyncFn(true)).rejects.toThrow(Error);\n      await jestExpect(asyncFn(true)).rejects.toThrow('apple');\n      await jestExpect(asyncFn(true)).rejects.toThrow(/app/);\n\n      await jestExpect(asyncFn(true)).rejects.not.toThrow(Err2);\n      await jestExpect(asyncFn(true)).rejects.not.toThrow('banana');\n      await jestExpect(asyncFn(true)).rejects.not.toThrow(/banana/);\n\n      await jestExpect(asyncFn(true, true)).resolves.toThrow();\n\n      await jestExpect(asyncFn(false, true)).resolves.not.toThrow();\n      await jestExpect(asyncFn(false, true)).resolves.not.toThrow(Error);\n      await jestExpect(asyncFn(false, true)).resolves.not.toThrow('apple');\n      await jestExpect(asyncFn(false, true)).resolves.not.toThrow(/apple/);\n      await jestExpect(asyncFn(false, true)).resolves.not.toThrow('banana');\n      await jestExpect(asyncFn(false, true)).resolves.not.toThrow(/banana/);\n\n      await jestExpect(asyncFn()).rejects.not.toThrow();\n      await jestExpect(asyncFn()).rejects.not.toThrow(Error);\n      await jestExpect(asyncFn()).rejects.not.toThrow('apple');\n      await jestExpect(asyncFn()).rejects.not.toThrow(/apple/);\n      await jestExpect(asyncFn()).rejects.not.toThrow('banana');\n      await jestExpect(asyncFn()).rejects.not.toThrow(/banana/);\n\n      // Works with nested functions inside promises\n      await jestExpect(\n        Promise.reject(() => {\n          throw new Error();\n        }),\n      ).rejects.toThrow();\n      await jestExpect(Promise.reject(() => {})).rejects.not.toThrow();\n    });\n\n    test('did not throw at all', async () => {\n      await expect(\n        jestExpect(asyncFn()).rejects.toThrow(),\n      ).rejects.toThrowErrorMatchingSnapshot();\n    });\n\n    test('threw, but class did not match', async () => {\n      await expect(\n        jestExpect(asyncFn(true)).rejects.toThrow(Err2),\n      ).rejects.toThrowErrorMatchingSnapshot();\n    });\n\n    test('threw, but should not have', async () => {\n      await expect(\n        jestExpect(asyncFn(true)).rejects.not.toThrow(),\n      ).rejects.toThrowErrorMatchingSnapshot();\n    });\n  });\n\n  describe('expected is undefined', () => {\n    test('threw, but should not have (non-error falsey)', () => {\n      expect(() => {\n        jestExpect(() => {\n          // eslint-disable-next-line no-throw-literal\n          throw null;\n        }).not.toThrow();\n      }).toThrowErrorMatchingSnapshot();\n    });\n  });\n\n  test('invalid arguments', () => {\n    expect(() =>\n      jestExpect(() => {}).not.toThrow(111),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('invalid actual', () => {\n    expect(() =>\n      jestExpect('a string').toThrow(),\n    ).toThrowErrorMatchingSnapshot();\n  });\n});\n",
  "packages/expect/src/__tests__/toThrowMatchers.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/expect/src/__tests__/toEqual-dom.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @jest-environment jsdom\n */\n\n/// <reference lib=\"dom\" />\n\n/* global document */\n\nimport {expect} from '@jest/globals';\n\ndescribe('toEqual', () => {\n  describe('duck type', () => {\n    // https://github.com/jestjs/jest/issues/7786\n\n    const createElement = (name: string, ...childNodes: Array<unknown>) => ({\n      childNodes,\n      nodeType: 1,\n      tagName: name.toUpperCase(),\n    });\n\n    const createTextNode = (data: unknown) => ({\n      data,\n      nodeType: 3,\n    });\n\n    const createDocumentFragment = (...children: Array<unknown>) => ({\n      children,\n      nodeType: 11,\n    });\n\n    describe('Text', () => {\n      test('isNot false', () => {\n        const data = 'deep equal';\n\n        const a = createTextNode(data);\n        const b = createTextNode(data);\n\n        expect(a).toEqual(b);\n        expect(b).toEqual(a);\n      });\n\n      test('isNot true', () => {\n        const a = createTextNode('not deep equal a');\n        const b = createTextNode('not deep equal b');\n\n        expect(a).not.toEqual(b);\n        expect(b).not.toEqual(a);\n      });\n    });\n\n    describe('Element', () => {\n      test('isNot false', () => {\n        const name = 'span';\n        const data = 'deep equal';\n\n        const a = createElement(name, createTextNode(data));\n        const b = createElement(name, createTextNode(data));\n\n        expect(a).toEqual(b);\n        expect(b).toEqual(a);\n      });\n\n      test('isNot true', () => {\n        const data = 'not deep equal';\n\n        const a = createElement('strong', createTextNode(data));\n        const b = createElement('span', createTextNode(data));\n\n        expect(a).not.toEqual(b);\n        expect(b).not.toEqual(a);\n      });\n    });\n\n    describe('Fragment', () => {\n      test('isNot false', () => {\n        const name1 = 'strong';\n        const name2 = 'span';\n        const data1 = 'deep';\n        const data2 = 'equal';\n\n        const a = createDocumentFragment(\n          createElement(name1, createTextNode(data1)),\n          createElement(name2, createTextNode(data2)),\n        );\n        const b = createDocumentFragment(\n          createElement(name1, createTextNode(data1)),\n          createElement(name2, createTextNode(data2)),\n        );\n\n        expect(a).toEqual(b);\n        expect(b).toEqual(a);\n      });\n\n      test('isNot true', () => {\n        const name = 'span';\n        const data1 = 'not';\n        const data2 = 'deep equal';\n\n        const a = createDocumentFragment(\n          createElement('strong', createTextNode(data1)),\n          createElement(name, createTextNode(data2)),\n        );\n        const b = createDocumentFragment(\n          createElement(name, createTextNode(data1)),\n          createElement(name, createTextNode(data2)),\n        );\n\n        expect(a).not.toEqual(b);\n        expect(b).not.toEqual(a);\n      });\n    });\n  });\n\n  describe('document', () => {\n    describe('createTextNode', () => {\n      test('isNot false', () => {\n        const data = 'deep equal';\n\n        const a = document.createTextNode(data);\n        const b = document.createTextNode(data);\n\n        expect(a).toEqual(b);\n        expect(b).toEqual(a);\n      });\n\n      test('isNot true', () => {\n        const a = document.createTextNode('not deep equal a');\n        const b = document.createTextNode('not deep equal b');\n\n        expect(a).not.toEqual(b);\n        expect(b).not.toEqual(a);\n      });\n    });\n\n    describe('createElement', () => {\n      test('isNot false', () => {\n        const name = 'span';\n        const data = 'deep equal';\n\n        const a = document.createElement(name);\n        const b = document.createElement(name);\n        a.append(document.createTextNode(data));\n        b.append(document.createTextNode(data));\n\n        expect(a).toEqual(b);\n        expect(b).toEqual(a);\n      });\n\n      test('isNot true', () => {\n        const data = 'not deep equal';\n\n        const a = document.createElement('strong');\n        const b = document.createElement('span');\n        a.append(document.createTextNode(data));\n        b.append(document.createTextNode(data));\n\n        expect(a).not.toEqual(b);\n        expect(b).not.toEqual(a);\n      });\n    });\n\n    describe('createDocumentFragment', () => {\n      test('isNot false', () => {\n        const name1 = 'strong';\n        const name2 = 'span';\n        const data1 = 'deep';\n        const data2 = 'equal';\n\n        const aSpan1 = document.createElement(name1);\n        const bSpan1 = document.createElement(name1);\n        aSpan1.append(document.createTextNode(data1));\n        bSpan1.append(document.createTextNode(data1));\n\n        const aSpan2 = document.createElement(name2);\n        const bSpan2 = document.createElement(name2);\n        aSpan2.append(document.createTextNode(data2));\n        bSpan2.append(document.createTextNode(data2));\n\n        const a = document.createDocumentFragment();\n        const b = document.createDocumentFragment();\n        a.append(aSpan1);\n        a.append(aSpan2);\n        b.append(bSpan1);\n        b.append(bSpan2);\n\n        expect(a).toEqual(b);\n        expect(b).toEqual(a);\n      });\n\n      test('isNot true', () => {\n        const name = 'span';\n        const data1 = 'not';\n        const data2 = 'deep equal';\n\n        const aSpan1 = document.createElement('strong');\n        const bSpan1 = document.createElement(name);\n        aSpan1.append(document.createTextNode(data1));\n        bSpan1.append(document.createTextNode(data1));\n\n        const aSpan2 = document.createElement(name);\n        const bSpan2 = document.createElement(name);\n        aSpan2.append(document.createTextNode(data2));\n        bSpan2.append(document.createTextNode(data2));\n\n        const a = document.createDocumentFragment();\n        const b = document.createDocumentFragment();\n        a.append(aSpan1);\n        a.append(aSpan2);\n        b.append(bSpan1);\n        b.append(bSpan2);\n\n        expect(a).not.toEqual(b);\n        expect(b).not.toEqual(a);\n      });\n    });\n  });\n});\n",
  "packages/expect/src/__tests__/toEqual-dom.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @jest-environment jsdom\n */\nexport {};\n",
  "packages/expect/src/__tests__/symbolInObjects.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {expect} from '@jest/globals';\n\ndescribe('Symbol in objects', () => {\n  test('should compare objects with Symbol keys', () => {\n    const sym = Symbol('foo');\n    const obj1 = {[sym]: 'one'};\n    const obj2 = {[sym]: 'two'};\n    const obj3 = {[sym]: 'one'};\n\n    expect(obj1).toEqual(obj3);\n    expect(obj1).not.toEqual(obj2);\n  });\n\n  test('should compare objects with mixed keys and Symbol', () => {\n    const sym = Symbol('foo2');\n    const obj1 = {foo: 2, [sym]: 'one'};\n    const obj2 = {foo: 2, [sym]: 'two'};\n    const obj3 = {foo: 2, [sym]: 'one'};\n\n    expect(obj1).toEqual(obj3);\n    expect(obj1).not.toEqual(obj2);\n  });\n\n  test('should compare objects with different Symbol keys', () => {\n    const sym = Symbol('foo');\n    const sym2 = Symbol('foo');\n    const obj1 = {[sym]: 'one'};\n    const obj2 = {[sym2]: 'one'};\n    const obj3 = {[sym]: 'one'};\n\n    expect(obj1).toEqual(obj3);\n    expect(obj1).not.toEqual(obj2);\n  });\n});\n",
  "packages/expect/src/__tests__/symbolInObjects.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport {};\n",
  "packages/expect/src/__tests__/stacktrace.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport jestExpect from '../';\n\njestExpect.extend({\n  toCustomMatch(callback: () => unknown, expected: unknown) {\n    const actual = callback();\n\n    if (actual !== expected) {\n      return {\n        message: () => `Expected \"${expected}\" but got \"${actual}\"`,\n        pass: false,\n      };\n    }\n\n    return {\n      message: () => '',\n      pass: true,\n    };\n  },\n  toMatchPredicate(received: unknown, expected: (a: unknown) => void) {\n    expected(received);\n    return {\n      message: () => '',\n      pass: true,\n    };\n  },\n});\n\ndeclare module '../types' {\n  interface Matchers<R> {\n    toCustomMatch(expected: unknown): R;\n    toMatchPredicate(expected: (a: unknown) => void): R;\n  }\n}\n\nit('stack trace points to correct location when using matchers', () => {\n  try {\n    jestExpect(true).toBe(false);\n  } catch (error: any) {\n    expect(error.stack).toContain('stacktrace.test.ts:45:22');\n  }\n});\n\nit('stack trace points to correct location when using nested matchers', () => {\n  try {\n    jestExpect(true).toMatchPredicate((value: unknown) => {\n      jestExpect(value).toBe(false);\n    });\n  } catch (error: any) {\n    expect(error.stack).toContain('stacktrace.test.ts:54:25');\n  }\n});\n\nit('stack trace points to correct location when throwing from a custom matcher', () => {\n  try {\n    jestExpect(() => {\n      const foo = () => bar();\n      const bar = () => baz();\n      const baz = () => {\n        throw new Error('Expected');\n      };\n\n      foo();\n    }).toCustomMatch('bar');\n  } catch (error: any) {\n    expect(error.stack).toContain('stacktrace.test.ts:67:15');\n  }\n});\n",
  "packages/expect/src/__tests__/stacktrace.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\ndeclare module '../types' {\n    interface Matchers<R> {\n        toCustomMatch(expected: unknown): R;\n        toMatchPredicate(expected: (a: unknown) => void): R;\n    }\n}\nexport {};\n",
  "packages/expect/src/__tests__/spyMatchers.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as Immutable from 'immutable';\nimport {alignedAnsiStyleSerializer} from '@jest/test-utils';\nimport type {FunctionLike} from 'jest-mock';\nimport jestExpect from '../';\n\nexpect.addSnapshotSerializer(alignedAnsiStyleSerializer);\n\njestExpect.extend({\n  optionalFn(fn?: unknown) {\n    const pass = fn === undefined || typeof fn === 'function';\n    return {message: () => 'expect either a function or undefined', pass};\n  },\n});\n\ndeclare module '../types' {\n  interface AsymmetricMatchers {\n    optionalFn(fn?: unknown): void;\n  }\n}\n\n// Given a Jest mock function, return a minimal mock of a spy.\nconst createSpy = <T extends FunctionLike>(fn: jest.Mock<T>): jest.Mock<T> => {\n  const spy = function () {};\n\n  spy.calls = {\n    all() {\n      return fn.mock.calls.map(args => ({args}));\n    },\n    count() {\n      return fn.mock.calls.length;\n    },\n  };\n\n  return spy as unknown as jest.Mock<T>;\n};\n\ndescribe('toHaveBeenCalled', () => {\n  test('works only on spies or jest.fn', () => {\n    const fn = function fn() {};\n\n    expect(() =>\n      jestExpect(fn).toHaveBeenCalled(),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('passes when called', () => {\n    const fn = jest.fn();\n    fn('arg0', 'arg1', 'arg2');\n    jestExpect(createSpy(fn)).toHaveBeenCalled();\n    jestExpect(fn).toHaveBeenCalled();\n    expect(() =>\n      jestExpect(fn).not.toHaveBeenCalled(),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('.not passes when called', () => {\n    const fn = jest.fn();\n    const spy = createSpy(fn);\n\n    jestExpect(spy).not.toHaveBeenCalled();\n    jestExpect(fn).not.toHaveBeenCalled();\n    expect(() =>\n      jestExpect(spy).toHaveBeenCalled(),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('fails with any argument passed', () => {\n    const fn = jest.fn();\n\n    fn();\n    expect(() =>\n      // @ts-expect-error: Testing runtime error\n      jestExpect(fn).toHaveBeenCalled(555),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('.not fails with any argument passed', () => {\n    const fn = jest.fn();\n\n    expect(() =>\n      // @ts-expect-error: Testing runtime error\n      jestExpect(fn).not.toHaveBeenCalled(555),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('includes the custom mock name in the error message', () => {\n    const fn = jest.fn().mockName('named-mock');\n\n    fn();\n    jestExpect(fn).toHaveBeenCalled();\n    expect(() =>\n      jestExpect(fn).not.toHaveBeenCalled(),\n    ).toThrowErrorMatchingSnapshot();\n  });\n});\n\ndescribe('toHaveBeenCalledTimes', () => {\n  test('.not works only on spies or jest.fn', () => {\n    const fn = function fn() {};\n\n    expect(() =>\n      jestExpect(fn).not.toHaveBeenCalledTimes(2),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('only accepts a number argument', () => {\n    const fn = jest.fn();\n    fn();\n    jestExpect(fn).toHaveBeenCalledTimes(1);\n\n    for (const value of [{}, [], true, 'a', new Map(), () => {}]) {\n      expect(() =>\n        // @ts-expect-error: Testing runtime error\n        jestExpect(fn).toHaveBeenCalledTimes(value),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('.not only accepts a number argument', () => {\n    const fn = jest.fn();\n    jestExpect(fn).not.toHaveBeenCalledTimes(1);\n\n    for (const value of [{}, [], true, 'a', new Map(), () => {}]) {\n      expect(() =>\n        // @ts-expect-error: Testing runtime error\n        jestExpect(fn).not.toHaveBeenCalledTimes(value),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('passes if function called equal to expected times', () => {\n    const fn = jest.fn();\n    fn();\n    fn();\n\n    const spy = createSpy(fn);\n    jestExpect(spy).toHaveBeenCalledTimes(2);\n    jestExpect(fn).toHaveBeenCalledTimes(2);\n\n    expect(() =>\n      jestExpect(spy).not.toHaveBeenCalledTimes(2),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('.not passes if function called more than expected times', () => {\n    const fn = jest.fn();\n    fn();\n    fn();\n    fn();\n\n    const spy = createSpy(fn);\n    jestExpect(spy).toHaveBeenCalledTimes(3);\n    jestExpect(spy).not.toHaveBeenCalledTimes(2);\n\n    jestExpect(fn).toHaveBeenCalledTimes(3);\n    jestExpect(fn).not.toHaveBeenCalledTimes(2);\n\n    expect(() =>\n      jestExpect(fn).toHaveBeenCalledTimes(2),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('.not passes if function called less than expected times', () => {\n    const fn = jest.fn();\n    fn();\n\n    const spy = createSpy(fn);\n    jestExpect(spy).toHaveBeenCalledTimes(1);\n    jestExpect(spy).not.toHaveBeenCalledTimes(2);\n\n    jestExpect(fn).toHaveBeenCalledTimes(1);\n    jestExpect(fn).not.toHaveBeenCalledTimes(2);\n\n    expect(() =>\n      jestExpect(fn).toHaveBeenCalledTimes(2),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('includes the custom mock name in the error message', () => {\n    const fn = jest.fn().mockName('named-mock');\n    fn();\n\n    expect(() =>\n      jestExpect(fn).toHaveBeenCalledTimes(2),\n    ).toThrowErrorMatchingSnapshot();\n  });\n});\n\ndescribe.each([\n  'toHaveBeenLastCalledWith',\n  'toHaveBeenNthCalledWith',\n  'toHaveBeenCalledWith',\n] as const)('%s', calledWith => {\n  function isToHaveNth(\n    calledWith: string,\n  ): calledWith is 'toHaveBeenNthCalledWith' {\n    return calledWith === 'toHaveBeenNthCalledWith';\n  }\n\n  test('works only on spies or jest.fn', () => {\n    const fn = function fn() {};\n\n    if (isToHaveNth(calledWith)) {\n      expect(() =>\n        jestExpect(fn)[calledWith](3),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      expect(() => jestExpect(fn)[calledWith]()).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works when not called', () => {\n    const fn = jest.fn();\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(createSpy(fn)).not[calledWith](1, 'foo', 'bar');\n      jestExpect(fn).not[calledWith](1, 'foo', 'bar');\n\n      expect(() =>\n        jestExpect(fn)[calledWith](1, 'foo', 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(createSpy(fn)).not[calledWith]('foo', 'bar');\n      jestExpect(fn).not[calledWith]('foo', 'bar');\n\n      expect(() =>\n        jestExpect(fn)[calledWith]('foo', 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with no arguments', () => {\n    const fn = jest.fn();\n    fn();\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(createSpy(fn))[calledWith](1);\n      jestExpect(fn)[calledWith](1);\n    } else {\n      jestExpect(createSpy(fn))[calledWith]();\n      jestExpect(fn)[calledWith]();\n    }\n  });\n\n  test(\"works with arguments that don't match\", () => {\n    const fn = jest.fn();\n    fn('foo', 'bar1');\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(createSpy(fn)).not[calledWith](1, 'foo', 'bar');\n      jestExpect(fn).not[calledWith](1, 'foo', 'bar');\n\n      expect(() =>\n        jestExpect(fn)[calledWith](1, 'foo', 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(createSpy(fn)).not[calledWith]('foo', 'bar');\n      jestExpect(fn).not[calledWith]('foo', 'bar');\n\n      expect(() =>\n        jestExpect(fn)[calledWith]('foo', 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test(\"works with arguments that don't match in number of arguments\", () => {\n    const fn = jest.fn();\n    fn('foo', 'bar', 'plop');\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(createSpy(fn)).not[calledWith](1, 'foo', 'bar');\n      jestExpect(fn).not[calledWith](1, 'foo', 'bar');\n\n      expect(() =>\n        jestExpect(fn)[calledWith](1, 'foo', 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(createSpy(fn)).not[calledWith]('foo', 'bar');\n      jestExpect(fn).not[calledWith]('foo', 'bar');\n\n      expect(() =>\n        jestExpect(fn)[calledWith]('foo', 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test(\"works with arguments that don't match with matchers\", () => {\n    const fn = jest.fn();\n    fn('foo', 'bar');\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(createSpy(fn)).not[calledWith](\n        1,\n        jestExpect.any(String),\n        jestExpect.any(Number),\n      );\n      jestExpect(fn).not[calledWith](\n        1,\n        jestExpect.any(String),\n        jestExpect.any(Number),\n      );\n\n      expect(() =>\n        jestExpect(fn)[calledWith](\n          1,\n          jestExpect.any(String),\n          jestExpect.any(Number),\n        ),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(createSpy(fn)).not[calledWith](\n        jestExpect.any(String),\n        jestExpect.any(Number),\n      );\n      jestExpect(fn).not[calledWith](\n        jestExpect.any(String),\n        jestExpect.any(Number),\n      );\n\n      expect(() =>\n        jestExpect(fn)[calledWith](\n          jestExpect.any(String),\n          jestExpect.any(Number),\n        ),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test(\"works with arguments that don't match with matchers even when argument is undefined\", () => {\n    const fn = jest.fn();\n    fn('foo', undefined);\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(createSpy(fn)).not[calledWith](\n        1,\n        'foo',\n        jestExpect.any(String),\n      );\n      jestExpect(fn).not[calledWith](1, 'foo', jestExpect.any(String));\n\n      expect(() =>\n        jestExpect(fn)[calledWith](1, 'foo', jestExpect.any(String)),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(createSpy(fn)).not[calledWith]('foo', jestExpect.any(String));\n      jestExpect(fn).not[calledWith]('foo', jestExpect.any(String));\n\n      expect(() =>\n        jestExpect(fn)[calledWith]('foo', jestExpect.any(String)),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test(\"works with arguments that don't match in size even if one is an optional matcher\", () => {\n    // issue 12463\n    const fn = jest.fn();\n    fn('foo');\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(fn).not[calledWith](1, 'foo', jestExpect.optionalFn());\n      expect(() =>\n        jestExpect(fn)[calledWith](1, 'foo', jestExpect.optionalFn()),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn).not[calledWith]('foo', jestExpect.optionalFn());\n      expect(() =>\n        jestExpect(fn)[calledWith]('foo', jestExpect.optionalFn()),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with arguments that match', () => {\n    const fn = jest.fn();\n    fn('foo', 'bar');\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(createSpy(fn))[calledWith](1, 'foo', 'bar');\n      jestExpect(fn)[calledWith](1, 'foo', 'bar');\n\n      expect(() =>\n        jestExpect(fn).not[calledWith](1, 'foo', 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(createSpy(fn))[calledWith]('foo', 'bar');\n      jestExpect(fn)[calledWith]('foo', 'bar');\n\n      expect(() =>\n        jestExpect(fn).not[calledWith]('foo', 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with arguments that match with matchers', () => {\n    const fn = jest.fn();\n    fn('foo', 'bar');\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(createSpy(fn))[calledWith](\n        1,\n        jestExpect.any(String),\n        jestExpect.any(String),\n      );\n      jestExpect(fn)[calledWith](\n        1,\n        jestExpect.any(String),\n        jestExpect.any(String),\n      );\n\n      expect(() =>\n        jestExpect(fn).not[calledWith](\n          1,\n          jestExpect.any(String),\n          jestExpect.any(String),\n        ),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(createSpy(fn))[calledWith](\n        jestExpect.any(String),\n        jestExpect.any(String),\n      );\n      jestExpect(fn)[calledWith](\n        jestExpect.any(String),\n        jestExpect.any(String),\n      );\n\n      expect(() =>\n        jestExpect(fn).not[calledWith](\n          jestExpect.any(String),\n          jestExpect.any(String),\n        ),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with trailing undefined arguments', () => {\n    const fn = jest.fn();\n    fn('foo', undefined);\n\n    if (isToHaveNth(calledWith)) {\n      expect(() =>\n        jestExpect(fn)[calledWith](1, 'foo'),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      expect(() =>\n        jestExpect(fn)[calledWith]('foo'),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with trailing undefined arguments if requested by the match query', () => {\n    const fn = jest.fn();\n    fn('foo', undefined);\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(fn)[calledWith](1, 'foo', undefined);\n      expect(() =>\n        jestExpect(fn).not[calledWith](1, 'foo', undefined),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[calledWith]('foo', undefined);\n      expect(() =>\n        jestExpect(fn).not[calledWith]('foo', undefined),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with trailing undefined arguments when explicitly requested as optional by matcher', () => {\n    // issue 12463\n    const fn = jest.fn();\n    fn('foo', undefined);\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(fn)[calledWith](1, 'foo', jestExpect.optionalFn());\n      expect(() =>\n        jestExpect(fn).not[calledWith](1, 'foo', jestExpect.optionalFn()),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[calledWith]('foo', jestExpect.optionalFn());\n      expect(() =>\n        jestExpect(fn).not[calledWith]('foo', jestExpect.optionalFn()),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with Map', () => {\n    const fn = jest.fn();\n\n    const m1 = new Map([\n      [1, 2],\n      [2, 1],\n    ]);\n    const m2 = new Map([\n      [1, 2],\n      [2, 1],\n    ]);\n    const m3 = new Map([\n      ['a', 'b'],\n      ['b', 'a'],\n    ]);\n\n    fn(m1);\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(fn)[calledWith](1, m2);\n      jestExpect(fn).not[calledWith](1, m3);\n\n      expect(() =>\n        jestExpect(fn).not[calledWith](1, m2),\n      ).toThrowErrorMatchingSnapshot();\n      expect(() =>\n        jestExpect(fn)[calledWith](1, m3),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[calledWith](m2);\n      jestExpect(fn).not[calledWith](m3);\n\n      expect(() =>\n        jestExpect(fn).not[calledWith](m2),\n      ).toThrowErrorMatchingSnapshot();\n      expect(() =>\n        jestExpect(fn)[calledWith](m3),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with Set', () => {\n    const fn = jest.fn();\n\n    const s1 = new Set([1, 2]);\n    const s2 = new Set([1, 2]);\n    const s3 = new Set([3, 4]);\n\n    fn(s1);\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(fn)[calledWith](1, s2);\n      jestExpect(fn).not[calledWith](1, s3);\n\n      expect(() =>\n        jestExpect(fn).not[calledWith](1, s2),\n      ).toThrowErrorMatchingSnapshot();\n      expect(() =>\n        jestExpect(fn)[calledWith](1, s3),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[calledWith](s2);\n      jestExpect(fn).not[calledWith](s3);\n\n      expect(() =>\n        jestExpect(fn).not[calledWith](s2),\n      ).toThrowErrorMatchingSnapshot();\n      expect(() =>\n        jestExpect(fn)[calledWith](s3),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with Immutable.js objects', () => {\n    const fn = jest.fn();\n    const directlyCreated = Immutable.Map([['a', {b: 'c'}]]);\n    const indirectlyCreated = Immutable.Map().set('a', {b: 'c'});\n    fn(directlyCreated, indirectlyCreated);\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(fn)[calledWith](1, indirectlyCreated, directlyCreated);\n\n      expect(() =>\n        jestExpect(fn).not[calledWith](1, indirectlyCreated, directlyCreated),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[calledWith](indirectlyCreated, directlyCreated);\n\n      expect(() =>\n        jestExpect(fn).not[calledWith](indirectlyCreated, directlyCreated),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  if (!isToHaveNth(calledWith)) {\n    test('works with many arguments', () => {\n      const fn = jest.fn();\n      fn('foo1', 'bar');\n      fn('foo', 'bar1');\n      fn('foo', 'bar');\n\n      jestExpect(fn)[calledWith]('foo', 'bar');\n\n      expect(() =>\n        jestExpect(fn).not[calledWith]('foo', 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    });\n\n    test(\"works with many arguments that don't match\", () => {\n      const fn = jest.fn();\n      fn('foo', 'bar1');\n      fn('foo', 'bar2');\n      fn('foo', 'bar3');\n\n      jestExpect(fn).not[calledWith]('foo', 'bar');\n\n      expect(() =>\n        jestExpect(fn)[calledWith]('foo', 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    });\n  }\n\n  if (isToHaveNth(calledWith)) {\n    test('works with three calls', () => {\n      const fn = jest.fn();\n      fn('foo1', 'bar');\n      fn('foo', 'bar1');\n      fn('foo', 'bar');\n\n      jestExpect(fn)[calledWith](1, 'foo1', 'bar');\n      jestExpect(fn)[calledWith](2, 'foo', 'bar1');\n      jestExpect(fn)[calledWith](3, 'foo', 'bar');\n\n      expect(() => {\n        jestExpect(fn).not[calledWith](1, 'foo1', 'bar');\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('positive throw matcher error for n that is not positive integer', async () => {\n      const fn = jest.fn();\n      fn('foo1', 'bar');\n\n      expect(() => {\n        jestExpect(fn)[calledWith](0, 'foo1', 'bar');\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('positive throw matcher error for n that is not integer', async () => {\n      const fn = jest.fn();\n      fn('foo1', 'bar');\n\n      expect(() => {\n        jestExpect(fn)[calledWith](0.1, 'foo1', 'bar');\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('negative throw matcher error for n that is not integer', async () => {\n      const fn = jest.fn();\n      fn('foo1', 'bar');\n\n      expect(() => {\n        jestExpect(fn).not[calledWith](Number.POSITIVE_INFINITY, 'foo1', 'bar');\n      }).toThrowErrorMatchingSnapshot();\n    });\n  }\n\n  test('includes the custom mock name in the error message', () => {\n    const fn = jest.fn().mockName('named-mock');\n    fn('foo', 'bar');\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(fn)[calledWith](1, 'foo', 'bar');\n\n      expect(() =>\n        jestExpect(fn).not[calledWith](1, 'foo', 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[calledWith]('foo', 'bar');\n\n      expect(() =>\n        jestExpect(fn).not[calledWith]('foo', 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with objectContaining', () => {\n    const fn = jest.fn();\n    // Call the function twice with different objects and verify that the\n    // correct comparison sample is still used (original sample isn't mutated)\n    fn({a: 1, b: 2, c: 4});\n    fn({a: 3, b: 7, c: 4});\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(fn)[calledWith](1, jestExpect.objectContaining({b: 2}));\n      jestExpect(fn)[calledWith](2, jestExpect.objectContaining({b: 7}));\n      jestExpect(fn)[calledWith](2, jestExpect.not.objectContaining({b: 2}));\n\n      expect(() =>\n        jestExpect(fn)[calledWith](1, jestExpect.objectContaining({b: 7})),\n      ).toThrowErrorMatchingSnapshot();\n\n      expect(() =>\n        jestExpect(fn).not[calledWith](1, jestExpect.objectContaining({b: 2})),\n      ).toThrowErrorMatchingSnapshot();\n\n      expect(() =>\n        jestExpect(fn)[calledWith](1, jestExpect.not.objectContaining({b: 2})),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[calledWith](jestExpect.objectContaining({b: 7}));\n      jestExpect(fn)[calledWith](jestExpect.not.objectContaining({b: 3}));\n\n      // The function was never called with this value.\n      // Only {\"b\": 3} should be shown as the expected value in the snapshot\n      // (no extra properties in the expected value).\n      expect(() =>\n        jestExpect(fn)[calledWith](jestExpect.objectContaining({b: 3})),\n      ).toThrowErrorMatchingSnapshot();\n\n      // Only {\"b\": 7} should be shown in the snapshot.\n      expect(() =>\n        jestExpect(fn).not[calledWith](jestExpect.objectContaining({b: 7})),\n      ).toThrowErrorMatchingSnapshot();\n    }\n\n    if (calledWith === 'toHaveBeenCalledWith') {\n      // The first call had {b: 2}, so this passes.\n      jestExpect(fn)[calledWith](jestExpect.not.objectContaining({b: 7}));\n\n      // Only {\"c\": 4} should be shown in the snapshot.\n      expect(() =>\n        jestExpect(fn)[calledWith](jestExpect.not.objectContaining({c: 4})),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n});\n\ndescribe('toHaveReturned', () => {\n  test('.not works only on jest.fn', () => {\n    const fn = function fn() {};\n\n    expect(() =>\n      jestExpect(fn).not.toHaveReturned(),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('throw matcher error if received is spy', () => {\n    const spy = createSpy(jest.fn());\n\n    expect(() =>\n      jestExpect(spy).toHaveReturned(),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('passes when returned', () => {\n    const fn = jest.fn(() => 42);\n    fn();\n    jestExpect(fn).toHaveReturned();\n    expect(() =>\n      jestExpect(fn).not.toHaveReturned(),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('passes when undefined is returned', () => {\n    const fn = jest.fn(() => undefined);\n    fn();\n    jestExpect(fn).toHaveReturned();\n    expect(() =>\n      jestExpect(fn).not.toHaveReturned(),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('passes when at least one call does not throw', () => {\n    const fn = jest.fn((causeError: boolean) => {\n      if (causeError) {\n        throw new Error('Error!');\n      }\n\n      return 42;\n    });\n\n    fn(false);\n\n    try {\n      fn(true);\n    } catch {\n      // ignore error\n    }\n\n    fn(false);\n\n    jestExpect(fn).toHaveReturned();\n    expect(() =>\n      jestExpect(fn).not.toHaveReturned(),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('.not passes when not returned', () => {\n    const fn = jest.fn();\n\n    jestExpect(fn).not.toHaveReturned();\n    expect(() =>\n      jestExpect(fn).toHaveReturned(),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('.not passes when all calls throw', () => {\n    const fn = jest.fn(() => {\n      throw new Error('Error!');\n    });\n\n    try {\n      fn();\n    } catch {\n      // ignore error\n    }\n\n    try {\n      fn();\n    } catch {\n      // ignore error\n    }\n\n    jestExpect(fn).not.toHaveReturned();\n    expect(() =>\n      jestExpect(fn).toHaveReturned(),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('.not passes when a call throws undefined', () => {\n    const fn = jest.fn(() => {\n      // eslint-disable-next-line no-throw-literal\n      throw undefined;\n    });\n\n    try {\n      fn();\n    } catch {\n      // ignore error\n    }\n\n    jestExpect(fn).not.toHaveReturned();\n    expect(() =>\n      jestExpect(fn).toHaveReturned(),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('fails with any argument passed', () => {\n    const fn = jest.fn();\n\n    fn();\n    expect(() =>\n      // @ts-expect-error: Testing runtime error\n      jestExpect(fn).toHaveReturned(555),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('.not fails with any argument passed', () => {\n    const fn = jest.fn();\n\n    expect(() =>\n      // @ts-expect-error: Testing runtime error\n      jestExpect(fn).not.toHaveReturned(555),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('includes the custom mock name in the error message', () => {\n    const fn = jest.fn(() => 42).mockName('named-mock');\n    fn();\n    jestExpect(fn).toHaveReturned();\n    expect(() =>\n      jestExpect(fn).not.toHaveReturned(),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('incomplete recursive calls are handled properly', () => {\n    // sums up all integers from 0 -> value, using recursion\n    const fn: jest.Mock<(value: number) => number> = jest.fn(value => {\n      if (value === 0) {\n        // Before returning from the base case of recursion, none of the\n        // calls have returned yet.\n        jestExpect(fn).not.toHaveReturned();\n        expect(() =>\n          jestExpect(fn).toHaveReturned(),\n        ).toThrowErrorMatchingSnapshot();\n        return 0;\n      } else {\n        return value + fn(value - 1);\n      }\n    });\n\n    fn(3);\n  });\n});\n\ndescribe('toHaveReturnedTimes', () => {\n  test('throw matcher error if received is spy', () => {\n    const spy = createSpy(jest.fn());\n\n    expect(() =>\n      jestExpect(spy).not.toHaveReturnedTimes(2),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('only accepts a number argument', () => {\n    const fn = jest.fn(() => 42);\n    fn();\n    jestExpect(fn).toHaveReturnedTimes(1);\n\n    for (const value of [{}, [], true, 'a', new Map(), () => {}]) {\n      expect(() =>\n        // @ts-expect-error: Testing runtime error\n        jestExpect(fn).toHaveReturnedTimes(value),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('.not only accepts a number argument', () => {\n    const fn = jest.fn(() => 42);\n    jestExpect(fn).not.toHaveReturnedTimes(2);\n\n    for (const value of [{}, [], true, 'a', new Map(), () => {}]) {\n      expect(() =>\n        // @ts-expect-error: Testing runtime error\n        jestExpect(fn).not.toHaveReturnedTimes(value),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('passes if function returned equal to expected times', () => {\n    const fn = jest.fn(() => 42);\n    fn();\n    fn();\n\n    jestExpect(fn).toHaveReturnedTimes(2);\n\n    expect(() =>\n      jestExpect(fn).not.toHaveReturnedTimes(2),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('calls that return undefined are counted as returns', () => {\n    const fn = jest.fn(() => undefined);\n    fn();\n    fn();\n\n    jestExpect(fn).toHaveReturnedTimes(2);\n\n    expect(() =>\n      jestExpect(fn).not.toHaveReturnedTimes(2),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('.not passes if function returned more than expected times', () => {\n    const fn = jest.fn(() => 42);\n    fn();\n    fn();\n    fn();\n\n    jestExpect(fn).toHaveReturnedTimes(3);\n    jestExpect(fn).not.toHaveReturnedTimes(2);\n\n    expect(() =>\n      jestExpect(fn).toHaveReturnedTimes(2),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('.not passes if function called less than expected times', () => {\n    const fn = jest.fn(() => 42);\n    fn();\n\n    jestExpect(fn).toHaveReturnedTimes(1);\n    jestExpect(fn).not.toHaveReturnedTimes(2);\n\n    expect(() =>\n      jestExpect(fn).toHaveReturnedTimes(2),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('calls that throw are not counted', () => {\n    const fn = jest.fn((causeError: boolean) => {\n      if (causeError) {\n        throw new Error('Error!');\n      }\n\n      return 42;\n    });\n\n    fn(false);\n\n    try {\n      fn(true);\n    } catch {\n      // ignore error\n    }\n\n    fn(false);\n\n    jestExpect(fn).not.toHaveReturnedTimes(3);\n\n    expect(() =>\n      jestExpect(fn).toHaveReturnedTimes(3),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('calls that throw undefined are not counted', () => {\n    const fn = jest.fn((causeError: boolean) => {\n      if (causeError) {\n        // eslint-disable-next-line no-throw-literal\n        throw undefined;\n      }\n\n      return 42;\n    });\n\n    fn(false);\n\n    try {\n      fn(true);\n    } catch {\n      // ignore error\n    }\n\n    fn(false);\n\n    jestExpect(fn).toHaveReturnedTimes(2);\n\n    expect(() =>\n      jestExpect(fn).not.toHaveReturnedTimes(2),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('includes the custom mock name in the error message', () => {\n    const fn = jest.fn(() => 42).mockName('named-mock');\n    fn();\n    fn();\n\n    jestExpect(fn).toHaveReturnedTimes(2);\n\n    expect(() =>\n      jestExpect(fn).toHaveReturnedTimes(1),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('incomplete recursive calls are handled properly', () => {\n    // sums up all integers from 0 -> value, using recursion\n    const fn: jest.Mock<(value: number) => number> = jest.fn(value => {\n      if (value === 0) {\n        return 0;\n      } else {\n        const recursiveResult = fn(value - 1);\n\n        if (value === 2) {\n          // Only 2 of the recursive calls have returned at this point\n          jestExpect(fn).toHaveReturnedTimes(2);\n          expect(() =>\n            jestExpect(fn).not.toHaveReturnedTimes(2),\n          ).toThrowErrorMatchingSnapshot();\n        }\n\n        return value + recursiveResult;\n      }\n    });\n\n    fn(3);\n  });\n});\n\ndescribe.each([\n  'toHaveLastReturnedWith',\n  'toHaveNthReturnedWith',\n  'toHaveReturnedWith',\n] as const)('%s', returnedWith => {\n  function isToHaveNth(\n    returnedWith: string,\n  ): returnedWith is 'toHaveNthReturnedWith' {\n    return returnedWith === 'toHaveNthReturnedWith';\n  }\n\n  function isToHaveLast(\n    returnedWith: string,\n  ): returnedWith is 'toHaveLastReturnedWith' {\n    return returnedWith === 'toHaveLastReturnedWith';\n  }\n  test('works only on spies or jest.fn', () => {\n    const fn = function fn() {};\n\n    // @ts-expect-error: Testing runtime error\n    expect(() => jestExpect(fn)[returnedWith]()).toThrowErrorMatchingSnapshot();\n  });\n\n  test('works when not called', () => {\n    const fn = jest.fn();\n\n    if (isToHaveNth(returnedWith)) {\n      jestExpect(fn).not[returnedWith](1, 'foo');\n\n      expect(() =>\n        jestExpect(fn)[returnedWith](1, 'foo'),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn).not[returnedWith]('foo');\n\n      expect(() =>\n        jestExpect(fn)[returnedWith]('foo'),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with no arguments', () => {\n    const fn = jest.fn();\n    fn();\n\n    if (isToHaveNth(returnedWith)) {\n      jestExpect(fn)[returnedWith](1);\n    } else {\n      jestExpect(fn)[returnedWith]();\n    }\n  });\n\n  test('works with argument that does not match', () => {\n    const fn = jest.fn(() => 'foo');\n    fn();\n\n    if (isToHaveNth(returnedWith)) {\n      jestExpect(fn).not[returnedWith](1, 'bar');\n\n      expect(() =>\n        jestExpect(fn)[returnedWith](1, 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn).not[returnedWith]('bar');\n\n      expect(() =>\n        jestExpect(fn)[returnedWith]('bar'),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with argument that does match', () => {\n    const fn = jest.fn(() => 'foo');\n    fn();\n\n    if (isToHaveNth(returnedWith)) {\n      jestExpect(fn)[returnedWith](1, 'foo');\n\n      expect(() =>\n        jestExpect(fn).not[returnedWith](1, 'foo'),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[returnedWith]('foo');\n\n      expect(() =>\n        jestExpect(fn).not[returnedWith]('foo'),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with undefined', () => {\n    const fn = jest.fn(() => undefined);\n    fn();\n\n    if (isToHaveNth(returnedWith)) {\n      jestExpect(fn)[returnedWith](1, undefined);\n\n      expect(() =>\n        jestExpect(fn).not[returnedWith](1, undefined),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[returnedWith](undefined);\n\n      expect(() =>\n        jestExpect(fn).not[returnedWith](undefined),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with Map', () => {\n    const m1 = new Map([\n      [1, 2],\n      [2, 1],\n    ]);\n    const m2 = new Map([\n      [1, 2],\n      [2, 1],\n    ]);\n    const m3 = new Map([\n      ['a', 'b'],\n      ['b', 'a'],\n    ]);\n\n    const fn = jest.fn(() => m1);\n    fn();\n\n    if (isToHaveNth(returnedWith)) {\n      jestExpect(fn)[returnedWith](1, m2);\n      jestExpect(fn).not[returnedWith](1, m3);\n\n      expect(() =>\n        jestExpect(fn).not[returnedWith](1, m2),\n      ).toThrowErrorMatchingSnapshot();\n      expect(() =>\n        jestExpect(fn)[returnedWith](1, m3),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[returnedWith](m2);\n      jestExpect(fn).not[returnedWith](m3);\n\n      expect(() =>\n        jestExpect(fn).not[returnedWith](m2),\n      ).toThrowErrorMatchingSnapshot();\n      expect(() =>\n        jestExpect(fn)[returnedWith](m3),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with Set', () => {\n    const s1 = new Set([1, 2]);\n    const s2 = new Set([1, 2]);\n    const s3 = new Set([3, 4]);\n\n    const fn = jest.fn(() => s1);\n    fn();\n\n    if (isToHaveNth(returnedWith)) {\n      jestExpect(fn)[returnedWith](1, s2);\n      jestExpect(fn).not[returnedWith](1, s3);\n\n      expect(() =>\n        jestExpect(fn).not[returnedWith](1, s2),\n      ).toThrowErrorMatchingSnapshot();\n      expect(() =>\n        jestExpect(fn)[returnedWith](1, s3),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[returnedWith](s2);\n      jestExpect(fn).not[returnedWith](s3);\n\n      expect(() =>\n        jestExpect(fn).not[returnedWith](s2),\n      ).toThrowErrorMatchingSnapshot();\n      expect(() =>\n        jestExpect(fn)[returnedWith](s3),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with Immutable.js objects directly created', () => {\n    const directlyCreated = Immutable.Map([['a', {b: 'c'}]]);\n    const fn = jest.fn(() => directlyCreated);\n    fn();\n\n    if (isToHaveNth(returnedWith)) {\n      jestExpect(fn)[returnedWith](1, directlyCreated);\n\n      expect(() =>\n        jestExpect(fn).not[returnedWith](1, directlyCreated),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[returnedWith](directlyCreated);\n\n      expect(() =>\n        jestExpect(fn).not[returnedWith](directlyCreated),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with Immutable.js objects indirectly created', () => {\n    const indirectlyCreated = Immutable.Map().set('a', {b: 'c'});\n    const fn = jest.fn(() => indirectlyCreated);\n    fn();\n\n    if (isToHaveNth(returnedWith)) {\n      jestExpect(fn)[returnedWith](1, indirectlyCreated);\n\n      expect(() =>\n        jestExpect(fn).not[returnedWith](1, indirectlyCreated),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[returnedWith](indirectlyCreated);\n\n      expect(() =>\n        jestExpect(fn).not[returnedWith](indirectlyCreated),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('a call that throws is not considered to have returned', () => {\n    const fn = jest.fn(() => {\n      throw new Error('Error!');\n    });\n\n    try {\n      fn();\n    } catch {\n      // ignore error\n    }\n\n    if (isToHaveNth(returnedWith)) {\n      // It doesn't matter what return value is tested if the call threw\n      jestExpect(fn).not[returnedWith](1, 'foo');\n      jestExpect(fn).not[returnedWith](1, null);\n      jestExpect(fn).not[returnedWith](1, undefined);\n\n      expect(() =>\n        jestExpect(fn)[returnedWith](1, undefined),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      // It doesn't matter what return value is tested if the call threw\n      jestExpect(fn).not[returnedWith]('foo');\n      jestExpect(fn).not[returnedWith](null);\n      jestExpect(fn).not[returnedWith](undefined);\n\n      expect(() =>\n        jestExpect(fn)[returnedWith](undefined),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('a call that throws undefined is not considered to have returned', () => {\n    const fn = jest.fn(() => {\n      // eslint-disable-next-line no-throw-literal\n      throw undefined;\n    });\n\n    try {\n      fn();\n    } catch {\n      // ignore error\n    }\n\n    if (isToHaveNth(returnedWith)) {\n      // It doesn't matter what return value is tested if the call threw\n      jestExpect(fn).not[returnedWith](1, 'foo');\n      jestExpect(fn).not[returnedWith](1, null);\n      jestExpect(fn).not[returnedWith](1, undefined);\n\n      expect(() =>\n        jestExpect(fn)[returnedWith](1, undefined),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      // It doesn't matter what return value is tested if the call threw\n      jestExpect(fn).not[returnedWith]('foo');\n      jestExpect(fn).not[returnedWith](null);\n      jestExpect(fn).not[returnedWith](undefined);\n\n      expect(() =>\n        jestExpect(fn)[returnedWith](undefined),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  if (!isToHaveNth(returnedWith)) {\n    describe('toHaveReturnedWith', () => {\n      test('works with more calls than the limit', () => {\n        const fn = jest.fn<() => string>();\n        fn.mockReturnValueOnce('foo1');\n        fn.mockReturnValueOnce('foo2');\n        fn.mockReturnValueOnce('foo3');\n        fn.mockReturnValueOnce('foo4');\n        fn.mockReturnValueOnce('foo5');\n        fn.mockReturnValueOnce('foo6');\n\n        fn();\n        fn();\n        fn();\n        fn();\n        fn();\n        fn();\n\n        jestExpect(fn).not[returnedWith]('bar');\n\n        expect(() => {\n          jestExpect(fn)[returnedWith]('bar');\n        }).toThrowErrorMatchingSnapshot();\n      });\n\n      test('incomplete recursive calls are handled properly', () => {\n        // sums up all integers from 0 -> value, using recursion\n        const fn: jest.Mock<(value: number) => number> = jest.fn(value => {\n          if (value === 0) {\n            // Before returning from the base case of recursion, none of the\n            // calls have returned yet.\n            // This test ensures that the incomplete calls are not incorrectly\n            // interpreted as have returned undefined\n            jestExpect(fn).not[returnedWith](undefined);\n            expect(() =>\n              jestExpect(fn)[returnedWith](undefined),\n            ).toThrowErrorMatchingSnapshot();\n\n            return 0;\n          } else {\n            return value + fn(value - 1);\n          }\n        });\n\n        fn(3);\n      });\n    });\n  }\n\n  if (isToHaveNth(returnedWith)) {\n    describe('toHaveNthReturnedWith', () => {\n      test('works with three calls', () => {\n        const fn = jest.fn<() => string>();\n        fn.mockReturnValueOnce('foo1');\n        fn.mockReturnValueOnce('foo2');\n        fn.mockReturnValueOnce('foo3');\n        fn();\n        fn();\n        fn();\n\n        jestExpect(fn)[returnedWith](1, 'foo1');\n        jestExpect(fn)[returnedWith](2, 'foo2');\n        jestExpect(fn)[returnedWith](3, 'foo3');\n\n        expect(() => {\n          jestExpect(fn).not[returnedWith](1, 'foo1');\n          jestExpect(fn).not[returnedWith](2, 'foo2');\n          jestExpect(fn).not[returnedWith](3, 'foo3');\n        }).toThrowErrorMatchingSnapshot();\n      });\n\n      test('should replace 1st, 2nd, 3rd with first, second, third', async () => {\n        const fn = jest.fn<() => string>();\n        fn.mockReturnValueOnce('foo1');\n        fn.mockReturnValueOnce('foo2');\n        fn.mockReturnValueOnce('foo3');\n        fn();\n        fn();\n        fn();\n\n        expect(() => {\n          jestExpect(fn)[returnedWith](1, 'bar1');\n          jestExpect(fn)[returnedWith](2, 'bar2');\n          jestExpect(fn)[returnedWith](3, 'bar3');\n        }).toThrowErrorMatchingSnapshot();\n\n        expect(() => {\n          jestExpect(fn).not[returnedWith](1, 'foo1');\n          jestExpect(fn).not[returnedWith](2, 'foo2');\n          jestExpect(fn).not[returnedWith](3, 'foo3');\n        }).toThrowErrorMatchingSnapshot();\n      });\n\n      test('positive throw matcher error for n that is not positive integer', async () => {\n        const fn = jest.fn(() => 'foo');\n        fn();\n\n        expect(() => {\n          jestExpect(fn)[returnedWith](0, 'foo');\n        }).toThrowErrorMatchingSnapshot();\n      });\n\n      test('should reject nth value greater than number of calls', async () => {\n        const fn = jest.fn(() => 'foo');\n        fn();\n        fn();\n        fn();\n\n        expect(() => {\n          jestExpect(fn)[returnedWith](4, 'foo');\n        }).toThrowErrorMatchingSnapshot();\n      });\n\n      test('positive throw matcher error for n that is not integer', async () => {\n        const fn = jest.fn<(a: string) => string>(() => 'foo');\n        fn('foo');\n\n        expect(() => {\n          jestExpect(fn)[returnedWith](0.1, 'foo');\n        }).toThrowErrorMatchingSnapshot();\n      });\n\n      test('negative throw matcher error for n that is not number', async () => {\n        const fn = jest.fn<(a: string) => string>(() => 'foo');\n        fn('foo');\n\n        expect(() => {\n          // @ts-expect-error: Testing runtime error\n          jestExpect(fn).not[returnedWith]();\n        }).toThrowErrorMatchingSnapshot();\n      });\n\n      test('incomplete recursive calls are handled properly', () => {\n        // sums up all integers from 0 -> value, using recursion\n        const fn: jest.Mock<(value: number) => number> = jest.fn(value => {\n          if (value === 0) {\n            return 0;\n          } else {\n            const recursiveResult = fn(value - 1);\n\n            if (value === 2) {\n              // Only 2 of the recursive calls have returned at this point\n              jestExpect(fn).not[returnedWith](1, 6);\n              jestExpect(fn).not[returnedWith](2, 3);\n              jestExpect(fn)[returnedWith](3, 1);\n              jestExpect(fn)[returnedWith](4, 0);\n\n              expect(() =>\n                jestExpect(fn)[returnedWith](1, 6),\n              ).toThrowErrorMatchingSnapshot();\n              expect(() =>\n                jestExpect(fn)[returnedWith](2, 3),\n              ).toThrowErrorMatchingSnapshot();\n              expect(() =>\n                jestExpect(fn).not[returnedWith](3, 1),\n              ).toThrowErrorMatchingSnapshot();\n              expect(() =>\n                jestExpect(fn).not[returnedWith](4, 0),\n              ).toThrowErrorMatchingSnapshot();\n            }\n\n            return value + recursiveResult;\n          }\n        });\n\n        fn(3);\n      });\n    });\n  }\n\n  if (isToHaveLast(returnedWith)) {\n    describe('toHaveLastReturnedWith', () => {\n      test('works with three calls', () => {\n        const fn = jest.fn<() => string>();\n        fn.mockReturnValueOnce('foo1');\n        fn.mockReturnValueOnce('foo2');\n        fn.mockReturnValueOnce('foo3');\n        fn();\n        fn();\n        fn();\n\n        jestExpect(fn)[returnedWith]('foo3');\n\n        expect(() => {\n          jestExpect(fn).not[returnedWith]('foo3');\n        }).toThrowErrorMatchingSnapshot();\n      });\n\n      test('incomplete recursive calls are handled properly', () => {\n        // sums up all integers from 0 -> value, using recursion\n        const fn: jest.Mock<(value: number) => number> = jest.fn(value => {\n          if (value === 0) {\n            // Before returning from the base case of recursion, none of the\n            // calls have returned yet.\n            jestExpect(fn).not[returnedWith](0);\n            expect(() =>\n              jestExpect(fn)[returnedWith](0),\n            ).toThrowErrorMatchingSnapshot();\n            return 0;\n          } else {\n            return value + fn(value - 1);\n          }\n        });\n\n        fn(3);\n      });\n    });\n  }\n\n  test('includes the custom mock name in the error message', () => {\n    const fn = jest.fn().mockName('named-mock');\n\n    if (isToHaveNth(returnedWith)) {\n      jestExpect(fn).not[returnedWith](1, 'foo');\n\n      expect(() =>\n        jestExpect(fn)[returnedWith](1, 'foo'),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn).not[returnedWith]('foo');\n\n      expect(() =>\n        jestExpect(fn)[returnedWith]('foo'),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n});\n",
  "packages/expect/src/__tests__/spyMatchers.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\ndeclare module '../types' {\n    interface AsymmetricMatchers {\n        optionalFn(fn?: unknown): void;\n    }\n}\nexport {};\n",
  "packages/expect/src/__tests__/matchers-toStrictEqual.property.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {strict as assert} from 'assert';\nimport {fc, it} from '@fast-check/jest';\nimport expect from '../';\nimport {\n  anythingSettings,\n  assertSettings,\n} from './__arbitraries__/sharedSettings';\n\ndescribe('toStrictEqual', () => {\n  const safeExpectStrictEqual = (a: unknown, b: unknown) => {\n    try {\n      expect(a).toStrictEqual(b);\n      return true;\n    } catch {\n      return false;\n    }\n  };\n  const safeAssertDeepStrictEqual = (a: unknown, b: unknown) => {\n    try {\n      assert.deepStrictEqual(a, b);\n      return true;\n    } catch {\n      return false;\n    }\n  };\n\n  it.prop([fc.clone(fc.anything(anythingSettings), 2)], assertSettings)(\n    'should be reflexive',\n    ([a, b]) => {\n      // Given: a and b identical values\n      expect(a).toStrictEqual(b);\n    },\n  );\n\n  it.prop(\n    [fc.anything(anythingSettings), fc.anything(anythingSettings)],\n    assertSettings,\n  )('should be symmetric', (a, b) => {\n    // Given:  a and b values\n    // Assert: We expect `expect(a).toStrictEqual(b)`\n    //         to be equivalent to `expect(b).toStrictEqual(a)`\n    expect(safeExpectStrictEqual(a, b)).toBe(safeExpectStrictEqual(b, a));\n  });\n\n  it.prop(\n    [fc.anything(anythingSettings), fc.anything(anythingSettings)],\n    assertSettings,\n  )('should be equivalent to Node deepStrictEqual', (a, b) => {\n    expect(safeExpectStrictEqual(a, b)).toBe(safeAssertDeepStrictEqual(a, b));\n  });\n});\n",
  "packages/expect/src/__tests__/matchers-toStrictEqual.property.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport {};\n",
  "packages/expect/src/__tests__/matchers-toEqual.property.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {fc, it} from '@fast-check/jest';\nimport expect from '../';\nimport {\n  anythingSettings,\n  assertSettings,\n} from './__arbitraries__/sharedSettings';\n\ndescribe('toEqual', () => {\n  it.prop([fc.clone(fc.anything(anythingSettings), 2)], assertSettings)(\n    'should be reflexive',\n    ([a, b]) => {\n      // Given: a and b identical values\n      expect(a).toEqual(b);\n    },\n  );\n\n  const safeExpectEqual = (a: unknown, b: unknown) => {\n    try {\n      expect(a).toEqual(b);\n      return true;\n    } catch {\n      return false;\n    }\n  };\n\n  it.prop([fc.anything(anythingSettings), fc.anything(anythingSettings)], {\n    ...assertSettings,\n    examples: [\n      [0, 5e-324], // Issue #7941\n      // [\n      //   new Set([false, true]),\n      //   new Set([new Boolean(true), new Boolean(true)]),\n      // ], // Issue #7975\n    ],\n  })('should be symmetric', (a, b) => {\n    // Given:  a and b values\n    // Assert: We expect `expect(a).toEqual(b)`\n    //         to be equivalent to `expect(b).toEqual(a)`\n    expect(safeExpectEqual(a, b)).toBe(safeExpectEqual(b, a));\n  });\n});\n",
  "packages/expect/src/__tests__/matchers-toEqual.property.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport {};\n",
  "packages/expect/src/__tests__/matchers-toContainEqual.property.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {fc, it} from '@fast-check/jest';\nimport expect from '../';\nimport {\n  anythingSettings,\n  assertSettings,\n} from './__arbitraries__/sharedSettings';\n\ndescribe('toContainEqual', () => {\n  it.prop(\n    [\n      fc.array(fc.anything(anythingSettings)),\n      fc.array(fc.anything(anythingSettings)),\n      fc.anything(anythingSettings),\n    ],\n    assertSettings,\n  )(\n    'should always find the value when inside the array',\n    (startValues, endValues, v) => {\n      // Given: startValues, endValues arrays and v any value\n      expect([...startValues, v, ...endValues]).toContainEqual(v);\n    },\n  );\n\n  it.prop(\n    [\n      fc.array(fc.anything(anythingSettings)),\n      fc.array(fc.anything(anythingSettings)),\n      fc.clone(fc.anything(anythingSettings), 2),\n    ],\n    assertSettings,\n  )(\n    'should always find the value when cloned inside the array',\n    (startValues, endValues, [a, b]) => {\n      // Given: startValues, endValues arrays\n      //        and [a, b] identical values\n      expect([...startValues, a, ...endValues]).toContainEqual(b);\n    },\n  );\n});\n",
  "packages/expect/src/__tests__/matchers-toContainEqual.property.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport {};\n",
  "packages/expect/src/__tests__/matchers-toContain.property.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {fc, it} from '@fast-check/jest';\nimport expect from '../';\nimport {\n  anythingSettings,\n  assertSettings,\n} from './__arbitraries__/sharedSettings';\n\ndescribe('toContain', () => {\n  it.prop(\n    [\n      fc.array(fc.anything(anythingSettings)),\n      fc.array(fc.anything(anythingSettings)),\n      fc.anything(anythingSettings).filter(v => !Number.isNaN(v)),\n    ],\n    assertSettings,\n  )(\n    'should always find the value when inside the array',\n    (startValues, endValues, v) => {\n      // Given: startValues, endValues arrays and v value (not NaN)\n      expect([...startValues, v, ...endValues]).toContain(v);\n    },\n  );\n\n  it.prop(\n    [\n      fc.array(fc.anything(anythingSettings)),\n      fc.array(fc.anything(anythingSettings)),\n      fc.clone(fc.anything(anythingSettings), 2),\n    ],\n    assertSettings,\n  )(\n    'should not find the value if it has been cloned into the array',\n    (startValues, endValues, [a, b]) => {\n      // Given: startValues, endValues arrays\n      //        and [a, b] equal, but not the same values\n      //        with `typeof a === 'object && a !== null`\n      fc.pre(typeof a === 'object' && a !== null);\n      expect([...startValues, a, ...endValues]).not.toContain(b);\n    },\n  );\n});\n",
  "packages/expect/src/__tests__/matchers-toContain.property.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport {};\n",
  "packages/expect/src/__tests__/extend.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {equals, iterableEquality, subsetEquality} from '@jest/expect-utils';\nimport {alignedAnsiStyleSerializer} from '@jest/test-utils';\nimport * as matcherUtils from 'jest-matcher-utils';\nimport jestExpect from '../';\n\nexpect.addSnapshotSerializer(alignedAnsiStyleSerializer);\n\njestExpect.extend({\n  toBeDivisibleBy(actual: number, expected: number) {\n    const pass = actual % expected === 0;\n    const message: () => string = pass\n      ? () =>\n          `expected ${this.utils.printReceived(\n            actual,\n          )} not to be divisible by ${expected}`\n      : () =>\n          `expected ${this.utils.printReceived(\n            actual,\n          )} to be divisible by ${expected}`;\n\n    return {message, pass};\n  },\n  toBeSymbol(actual: symbol, expected: symbol) {\n    const pass = actual === expected;\n    const message = () =>\n      `expected ${actual.toString()} to be Symbol ${expected.toString()}`;\n\n    return {message, pass};\n  },\n  toBeWithinRange(actual: number, floor: number, ceiling: number) {\n    const pass = actual >= floor && actual <= ceiling;\n    const message = pass\n      ? () =>\n          `expected ${this.utils.printReceived(\n            actual,\n          )} not to be within range ${floor} - ${ceiling}`\n      : () =>\n          `expected ${this.utils.printReceived(\n            actual,\n          )} to be within range ${floor} - ${ceiling}`;\n\n    return {message, pass};\n  },\n});\n\ndeclare module '../types' {\n  interface AsymmetricMatchers {\n    toBeDivisibleBy(expected: number): void;\n    toBeSymbol(expected: symbol): void;\n    toBeWithinRange(floor: number, ceiling: number): void;\n  }\n  interface Matchers<R> {\n    toBeDivisibleBy(expected: number): R;\n    toBeSymbol(expected: symbol): R;\n    toBeWithinRange(floor: number, ceiling: number): R;\n\n    shouldNotError(): R;\n    toFailWithoutMessage(): R;\n    toBeOne(): R;\n    toAllowOverridingExistingMatcher(): R;\n  }\n}\n\nit('is available globally when matcher is unary', () => {\n  jestExpect(15).toBeDivisibleBy(5);\n  jestExpect(15).toBeDivisibleBy(3);\n  jestExpect(15).not.toBeDivisibleBy(6);\n\n  expect(() =>\n    jestExpect(15).toBeDivisibleBy(2),\n  ).toThrowErrorMatchingSnapshot();\n});\n\nit('is available globally when matcher is variadic', () => {\n  jestExpect(15).toBeWithinRange(10, 20);\n  jestExpect(15).not.toBeWithinRange(6, 10);\n\n  expect(() =>\n    jestExpect(15).toBeWithinRange(1, 3),\n  ).toThrowErrorMatchingSnapshot();\n});\n\nit('exposes matcherUtils in context', () => {\n  jestExpect.extend({\n    shouldNotError(_actual: unknown) {\n      const pass: boolean = this.equals(\n        this.utils,\n        Object.assign(matcherUtils, {\n          iterableEquality,\n          subsetEquality,\n        }),\n      );\n      const message = pass\n        ? () => 'expected this.utils to be defined in an extend call'\n        : () => 'expected this.utils not to be defined in an extend call';\n\n      return {message, pass};\n    },\n  });\n\n  jestExpect('test').shouldNotError();\n});\n\nit('is ok if there is no message specified', () => {\n  jestExpect.extend({\n    toFailWithoutMessage(_expected: unknown) {\n      return {message: () => '', pass: false};\n    },\n  });\n\n  expect(() =>\n    jestExpect(true).toFailWithoutMessage(),\n  ).toThrowErrorMatchingSnapshot();\n});\n\nit('exposes an equality function to custom matchers', () => {\n  // jestExpect and expect share the same global state\n  expect.assertions(3);\n  jestExpect.extend({\n    toBeOne(_expected: unknown) {\n      expect(this.equals).toBe(equals);\n      return {message: () => '', pass: !!this.equals(1, 1)};\n    },\n  });\n\n  expect(() => jestExpect('test').toBeOne()).not.toThrow();\n});\n\nit('defines asymmetric unary matchers', () => {\n  expect(() =>\n    jestExpect({value: 2}).toEqual({value: jestExpect.toBeDivisibleBy(2)}),\n  ).not.toThrow();\n  expect(() =>\n    jestExpect({value: 3}).toEqual({value: jestExpect.toBeDivisibleBy(2)}),\n  ).toThrowErrorMatchingSnapshot();\n});\n\nit('defines asymmetric unary matchers that can be prefixed by not', () => {\n  expect(() =>\n    jestExpect({value: 2}).toEqual({value: jestExpect.not.toBeDivisibleBy(2)}),\n  ).toThrowErrorMatchingSnapshot();\n  expect(() =>\n    jestExpect({value: 3}).toEqual({value: jestExpect.not.toBeDivisibleBy(2)}),\n  ).not.toThrow();\n});\n\nit('defines asymmetric variadic matchers', () => {\n  expect(() =>\n    jestExpect({value: 2}).toEqual({value: jestExpect.toBeWithinRange(1, 3)}),\n  ).not.toThrow();\n  expect(() =>\n    jestExpect({value: 3}).toEqual({value: jestExpect.toBeWithinRange(4, 11)}),\n  ).toThrowErrorMatchingSnapshot();\n});\n\nit('defines asymmetric variadic matchers that can be prefixed by not', () => {\n  expect(() =>\n    jestExpect({value: 2}).toEqual({\n      value: jestExpect.not.toBeWithinRange(1, 3),\n    }),\n  ).toThrowErrorMatchingSnapshot();\n  expect(() =>\n    jestExpect({value: 3}).toEqual({\n      value: jestExpect.not.toBeWithinRange(5, 7),\n    }),\n  ).not.toThrow();\n});\n\nit('prints the Symbol into the error message', () => {\n  const foo = Symbol('foo');\n  const bar = Symbol('bar');\n\n  expect(() =>\n    jestExpect({a: foo}).toEqual({\n      a: jestExpect.toBeSymbol(bar),\n    }),\n  ).toThrowErrorMatchingSnapshot();\n});\n\nit('allows overriding existing extension', () => {\n  jestExpect.extend({\n    toAllowOverridingExistingMatcher(_expected: unknown) {\n      return {message: () => '', pass: _expected === 'bar'};\n    },\n  });\n\n  jestExpect('foo').not.toAllowOverridingExistingMatcher();\n\n  jestExpect.extend({\n    toAllowOverridingExistingMatcher(_expected: unknown) {\n      return {message: () => '', pass: _expected === 'foo'};\n    },\n  });\n\n  jestExpect('foo').toAllowOverridingExistingMatcher();\n});\n\nit('throws descriptive errors for invalid matchers', () => {\n  expect(() =>\n    jestExpect.extend({\n      // @ts-expect-error: Testing runtime error\n      default: undefined,\n    }),\n  ).toThrow(\n    'expect.extend: `default` is not a valid matcher. Must be a function, is \"undefined\"',\n  );\n  expect(() =>\n    jestExpect.extend({\n      // @ts-expect-error: Testing runtime error\n      default: 42,\n    }),\n  ).toThrow(\n    'expect.extend: `default` is not a valid matcher. Must be a function, is \"number\"',\n  );\n  expect(() =>\n    jestExpect.extend({\n      // @ts-expect-error: Testing runtime error\n      default: 'foobar',\n    }),\n  ).toThrow(\n    'expect.extend: `default` is not a valid matcher. Must be a function, is \"string\"',\n  );\n});\n",
  "packages/expect/src/__tests__/extend.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\ndeclare module '../types' {\n    interface AsymmetricMatchers {\n        toBeDivisibleBy(expected: number): void;\n        toBeSymbol(expected: symbol): void;\n        toBeWithinRange(floor: number, ceiling: number): void;\n    }\n    interface Matchers<R> {\n        toBeDivisibleBy(expected: number): R;\n        toBeSymbol(expected: symbol): R;\n        toBeWithinRange(floor: number, ceiling: number): R;\n        shouldNotError(): R;\n        toFailWithoutMessage(): R;\n        toBeOne(): R;\n        toAllowOverridingExistingMatcher(): R;\n    }\n}\nexport {};\n",
  "packages/expect/src/__tests__/customEqualityTestersRecursive.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {type Tester, equals} from '@jest/expect-utils';\nimport jestExpect from '../';\n\n// Test test file demonstrates and tests the capability of recursive custom\n// testers that call `equals` within their tester logic. These testers should\n// receive the array of custom testers and be able to pass it into equals\n\nconst CONNECTION_PROP = '__connection';\ntype DbConnection = number;\nlet DbConnectionId = 0;\n\nclass Author {\n  public name: string;\n  public [CONNECTION_PROP]: DbConnection;\n\n  constructor(name: string) {\n    this.name = name;\n    this[CONNECTION_PROP] = DbConnectionId++;\n  }\n}\n\nclass Book {\n  public name: string;\n  public authors: Array<Author>;\n  public [CONNECTION_PROP]: DbConnection;\n\n  constructor(name: string, authors: Array<Author>) {\n    this.name = name;\n    this.authors = authors;\n    this[CONNECTION_PROP] = DbConnectionId++;\n  }\n}\n\nconst areAuthorsEqual: Tester = (a: unknown, b: unknown) => {\n  const isAAuthor = a instanceof Author;\n  const isBAuthor = b instanceof Author;\n\n  if (isAAuthor && isBAuthor) {\n    return a.name === b.name;\n  } else if (isAAuthor === isBAuthor) {\n    return undefined;\n  } else {\n    return false;\n  }\n};\n\nconst areBooksEqual: Tester = function (\n  a: unknown,\n  b: unknown,\n  customTesters: Array<Tester>,\n) {\n  const isABook = a instanceof Book;\n  const isBBook = b instanceof Book;\n\n  if (isABook && isBBook) {\n    return (\n      a.name === b.name && this.equals(a.authors, b.authors, customTesters)\n    );\n  } else if (isABook === isBBook) {\n    return undefined;\n  } else {\n    return false;\n  }\n};\n\nfunction* toIterator<T>(array: Array<T>): Iterator<T> {\n  for (const obj of array) {\n    yield obj;\n  }\n}\n\ndeclare module '../types' {\n  interface Matchers<R> {\n    toEqualBook(expected: Book): R;\n  }\n}\n\njestExpect.extend({\n  toEqualBook(expected: Book, actual: Book) {\n    const result = this.equals(expected, actual, this.customTesters);\n\n    return {\n      message: () =>\n        `Expected Book object: ${expected.name}. Actual Book object: ${actual.name}`,\n      pass: result,\n    };\n  },\n});\n\n// Create books with the same name and authors for use in tests. Without the\n// custom tester, these books would not be equal because their DbConnections\n// would have different values. However, with our custom tester they are equal.\nconst book1 = new Book('Book 1', [\n  new Author('Author 1'),\n  new Author('Author 2'),\n]);\nconst book1b = new Book('Book 1', [\n  new Author('Author 1'),\n  new Author('Author 2'),\n]);\n\nconst bookArg1a = new Book('Book Arg 1', [\n  new Author('Author Arg 1'),\n  new Author('Author Arg 2'),\n]);\nconst bookArg1b = new Book('Book Arg 1', [\n  new Author('Author Arg 1'),\n  new Author('Author Arg 2'),\n]);\nconst bookArg2a = new Book('Book Arg 2', [\n  new Author('Author Arg 3'),\n  new Author('Author Arg 4'),\n]);\nconst bookArg2b = new Book('Book Arg 2', [\n  new Author('Author Arg 3'),\n  new Author('Author Arg 4'),\n]);\n\nconst bookReturn1a = new Book('Book Return 1', [\n  new Author('Author Return 1'),\n  new Author('Author Return 2'),\n]);\nconst bookReturn1b = new Book('Book Return 1', [\n  new Author('Author Return 1'),\n  new Author('Author Return 2'),\n]);\n\nconst testArgs = [bookArg1a, bookArg1b, [bookArg2a, bookArg2b]];\n// Swap the order of args to assert custom tester works correctly and ignores\n// DbConnection differences\nconst expectedArgs = [bookArg1b, bookArg1a, [bookArg2b, bookArg2a]];\n\nexpect.addEqualityTesters([areAuthorsEqual, areBooksEqual]);\n\ndescribe('with custom equality testers', () => {\n  it('exposes an equality function to custom testers', () => {\n    const runTestSymbol = Symbol('run this test');\n\n    // jestExpect and expect share the same global state\n    expect.assertions(3);\n    jestExpect.addEqualityTesters([\n      function dummyTester(a) {\n        // Equality testers are globally added. Only run this assertion for this test\n        if (a === runTestSymbol) {\n          expect(this.equals).toBe(equals);\n          return true;\n        }\n\n        return undefined;\n      },\n    ]);\n\n    expect(() =>\n      jestExpect(runTestSymbol).toEqual(runTestSymbol),\n    ).not.toThrow();\n  });\n\n  it('basic matchers customTesters do not apply to still do not pass different Book objects', () => {\n    expect(book1).not.toBe(book1b);\n    expect([book1]).not.toContain(book1b);\n  });\n\n  it('basic matchers pass different Book objects', () => {\n    expect(book1).toEqual(book1);\n    expect(book1).toEqual(book1b);\n    expect([book1, book1b]).toEqual([book1b, book1]);\n    expect(new Map([['key', book1]])).toEqual(new Map([['key', book1b]]));\n    expect(new Set([book1])).toEqual(new Set([book1b]));\n    expect(toIterator([book1, book1b])).toEqual(toIterator([book1b, book1]));\n    expect([book1]).toContainEqual(book1b);\n    expect({a: book1}).toHaveProperty('a', book1b);\n    expect({a: book1, b: undefined}).toStrictEqual({\n      a: book1b,\n      b: undefined,\n    });\n    expect({a: 1, b: {c: book1}}).toMatchObject({\n      a: 1,\n      b: {c: book1b},\n    });\n  });\n\n  it('asymmetric matchers pass different Book objects', () => {\n    expect([book1]).toEqual(expect.arrayContaining([book1b]));\n    expect({a: 1, b: {c: book1}}).toEqual(\n      expect.objectContaining({b: {c: book1b}}),\n    );\n  });\n\n  it('spy matchers pass different Book objects', () => {\n    const mockFn = jest.fn<(...args: Array<unknown>) => unknown>(\n      () => bookReturn1a,\n    );\n    mockFn(...testArgs);\n\n    expect(mockFn).toHaveBeenCalledWith(...expectedArgs);\n    expect(mockFn).toHaveBeenLastCalledWith(...expectedArgs);\n    expect(mockFn).toHaveBeenNthCalledWith(1, ...expectedArgs);\n\n    expect(mockFn).toHaveReturnedWith(bookReturn1b);\n    expect(mockFn).toHaveLastReturnedWith(bookReturn1b);\n    expect(mockFn).toHaveNthReturnedWith(1, bookReturn1b);\n  });\n\n  it('custom matchers pass different Book objects', () => {\n    expect(book1).toEqualBook(book1b);\n  });\n\n  it('toBe recommends toStrictEqual even with different Book objects', () => {\n    expect(() => expect(book1).toBe(book1b)).toThrow('toStrictEqual');\n  });\n\n  it('toBe recommends toEqual even with different Book objects', () => {\n    expect(() => expect({a: undefined, b: book1}).toBe({b: book1b})).toThrow(\n      'toEqual',\n    );\n  });\n\n  it('toContains recommends toContainEquals even with different Book objects', () => {\n    expect(() => expect([book1]).toContain(book1b)).toThrow('toContainEqual');\n  });\n\n  it('toMatchObject error shows Book objects as equal', () => {\n    expect(() =>\n      expect({a: 1, b: book1}).toMatchObject({a: 2, b: book1b}),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  it('iterableEquality still properly detects cycles', () => {\n    const a = new Set();\n    a.add(book1);\n    a.add(a);\n\n    const b = new Set();\n    b.add(book1b);\n    b.add(b);\n\n    expect(a).toEqual(b);\n  });\n});\n",
  "packages/expect/src/__tests__/customEqualityTestersRecursive.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\ndeclare const CONNECTION_PROP = \"__connection\";\ntype DbConnection = number;\ndeclare class Author {\n    name: string;\n    [CONNECTION_PROP]: DbConnection;\n    constructor(name: string);\n}\ndeclare class Book {\n    name: string;\n    authors: Array<Author>;\n    [CONNECTION_PROP]: DbConnection;\n    constructor(name: string, authors: Array<Author>);\n}\ndeclare module '../types' {\n    interface Matchers<R> {\n        toEqualBook(expected: Book): R;\n    }\n}\nexport {};\n",
  "packages/expect/src/__tests__/customEqualityTesters.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {Tester} from '@jest/expect-utils';\nimport jestExpect from '../';\n\nclass Volume {\n  public amount: number;\n  public unit: 'L' | 'mL';\n\n  constructor(amount: number, unit: 'L' | 'mL') {\n    this.amount = amount;\n    this.unit = unit;\n  }\n\n  toString(): string {\n    return `[Volume ${this.amount}${this.unit}]`;\n  }\n\n  equals(other: Volume): boolean {\n    if (this.unit === other.unit) {\n      return this.amount === other.amount;\n    } else if (this.unit === 'L' && other.unit === 'mL') {\n      return this.amount * 1000 === other.amount;\n    } else {\n      return this.amount === other.amount * 1000;\n    }\n  }\n}\n\nfunction createVolume(amount: number, unit: 'L' | 'mL' = 'L') {\n  return new Volume(amount, unit);\n}\n\nfunction isVolume(a: unknown): a is Volume {\n  return a instanceof Volume;\n}\n\nconst areVolumesEqual: Tester = (\n  a: unknown,\n  b: unknown,\n): boolean | undefined => {\n  const isAVolume = isVolume(a);\n  const isBVolume = isVolume(b);\n\n  if (isAVolume && isBVolume) {\n    return a.equals(b);\n  } else if (isAVolume === isBVolume) {\n    return undefined;\n  } else {\n    return false;\n  }\n};\n\nfunction* toIterator<T>(array: Array<T>): Iterator<T> {\n  for (const obj of array) {\n    yield obj;\n  }\n}\n\ndeclare module '../types' {\n  interface Matchers<R> {\n    toEqualVolume(expected: Volume): R;\n  }\n}\n\njestExpect.extend({\n  toEqualVolume(expected: Volume, actual: Volume) {\n    const result = this.equals(expected, actual, this.customTesters);\n\n    return {\n      message: () =>\n        `Expected Volume object: ${expected.toString()}. Actual Volume object: ${actual.toString()}`,\n      pass: result,\n    };\n  },\n});\n\n// Create Volumes with different specifications but the same value for use in\n// tests. Without the custom tester, these volumes would not be equal because\n// their properties have different values. However, with our custom tester they\n// are equal.\nconst volume1 = createVolume(1, 'L');\nconst volume2 = createVolume(1000, 'mL');\n\nconst volumeArg1 = createVolume(1, 'L');\nconst volumeArg2 = createVolume(1000, 'mL');\nconst volumeArg3 = createVolume(2, 'L');\nconst volumeArg4 = createVolume(2000, 'mL');\n\nconst volumeReturn1 = createVolume(2, 'L');\nconst volumeReturn2 = createVolume(2000, 'mL');\n\nconst testArgs = [volumeArg1, volumeArg2, [volumeArg3, volumeArg4]];\n// Swap the order of args to assert custom tester sees these volumes as equal\nconst expectedArgs = [volumeArg2, volumeArg1, [volumeArg4, volumeArg3]];\n\nexpect.addEqualityTesters([areVolumesEqual]);\n\ndescribe('with custom equality testers', () => {\n  it('basic matchers customTesters do not apply to still do not pass different Volume objects', () => {\n    expect(volume1).not.toBe(volume2);\n    expect([volume1]).not.toContain(volume2);\n  });\n\n  it('basic matchers pass different Volume objects', () => {\n    expect(volume1).toEqual(volume1);\n    expect(volume1).toEqual(volume2);\n    expect([volume1, volume2]).toEqual([volume2, volume1]);\n    expect(new Map([['key', volume1]])).toEqual(new Map([['key', volume2]]));\n    expect(new Set([volume1])).toEqual(new Set([volume2]));\n    expect(toIterator([volume1, volume2])).toEqual(\n      toIterator([volume2, volume1]),\n    );\n    expect([volume1]).toContainEqual(volume2);\n    expect({a: volume1}).toHaveProperty('a', volume2);\n    expect({a: volume1, b: undefined}).toStrictEqual({\n      a: volume2,\n      b: undefined,\n    });\n    expect({a: 1, b: {c: volume1}}).toMatchObject({\n      a: 1,\n      b: {c: volume2},\n    });\n  });\n\n  it('asymmetric matchers pass different Volume objects', () => {\n    expect([volume1]).toEqual(expect.arrayContaining([volume2]));\n    expect({a: 1, b: {c: volume1}}).toEqual(\n      expect.objectContaining({b: {c: volume2}}),\n    );\n  });\n\n  it('spy matchers pass different Volume objects', () => {\n    const mockFn = jest.fn<(...args: Array<unknown>) => unknown>(\n      () => volumeReturn1,\n    );\n    mockFn(...testArgs);\n\n    expect(mockFn).toHaveBeenCalledWith(...expectedArgs);\n    expect(mockFn).toHaveBeenLastCalledWith(...expectedArgs);\n    expect(mockFn).toHaveBeenNthCalledWith(1, ...expectedArgs);\n\n    expect(mockFn).toHaveReturnedWith(volumeReturn2);\n    expect(mockFn).toHaveLastReturnedWith(volumeReturn2);\n    expect(mockFn).toHaveNthReturnedWith(1, volumeReturn2);\n  });\n\n  it('custom matchers pass different Volume objects', () => {\n    expect(volume1).toEqualVolume(volume2);\n  });\n\n  it('toBe recommends toStrictEqual even with different Volume objects', () => {\n    expect(() => expect(volume1).toBe(volume2)).toThrow('toStrictEqual');\n  });\n\n  it('toBe recommends toEqual even with different Volume objects', () => {\n    expect(() => expect({a: undefined, b: volume1}).toBe({b: volume2})).toThrow(\n      'toEqual',\n    );\n  });\n\n  it('toContains recommends toContainEquals even with different Volume objects', () => {\n    expect(() => expect([volume1]).toContain(volume2)).toThrow(\n      'toContainEqual',\n    );\n  });\n\n  it('toMatchObject error shows Volume objects as equal', () => {\n    expect(() =>\n      expect({a: 1, b: volume1}).toMatchObject({a: 2, b: volume2}),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  it('iterableEquality still properly detects cycles', () => {\n    const a = new Set();\n    a.add(volume1);\n    a.add(a);\n\n    const b = new Set();\n    b.add(volume2);\n    b.add(b);\n\n    expect(a).toEqual(b);\n  });\n});\n",
  "packages/expect/src/__tests__/customEqualityTesters.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\ndeclare class Volume {\n    amount: number;\n    unit: 'L' | 'mL';\n    constructor(amount: number, unit: 'L' | 'mL');\n    toString(): string;\n    equals(other: Volume): boolean;\n}\ndeclare module '../types' {\n    interface Matchers<R> {\n        toEqualVolume(expected: Volume): R;\n    }\n}\nexport {};\n",
  "packages/expect/src/__tests__/asymmetricMatchers.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {runInNewContext} from 'node:vm';\nimport jestExpect from '../';\nimport {\n  any,\n  anything,\n  arrayContaining,\n  arrayNotContaining,\n  arrayOf,\n  closeTo,\n  notArrayOf,\n  notCloseTo,\n  objectContaining,\n  objectNotContaining,\n  stringContaining,\n  stringMatching,\n  stringNotContaining,\n  stringNotMatching,\n} from '../asymmetricMatchers';\n\ntest('Any.asymmetricMatch()', () => {\n  class Thing {}\n\n  for (const test of [\n    any(String).asymmetricMatch('jest'),\n    any(Number).asymmetricMatch(1),\n    any(Function).asymmetricMatch(() => {}),\n    any(Boolean).asymmetricMatch(true),\n    any(BigInt).asymmetricMatch(1n),\n    any(Symbol).asymmetricMatch(Symbol()),\n    any(Object).asymmetricMatch({}),\n    any(Object).asymmetricMatch(null),\n    any(Array).asymmetricMatch([]),\n    any(Thing).asymmetricMatch(new Thing()),\n  ]) {\n    jestExpect(test).toBe(true);\n  }\n});\n\ntest('Any.asymmetricMatch() on primitive wrapper classes', () => {\n  for (const test of [\n    /* eslint-disable no-new-wrappers, unicorn/new-for-builtins */\n    any(String).asymmetricMatch(new String('jest')),\n    any(Number).asymmetricMatch(new Number(1)),\n    // eslint-disable-next-line no-new-func\n    any(Function).asymmetricMatch(new Function('() => {}')),\n    any(Boolean).asymmetricMatch(new Boolean(true)),\n    any(BigInt).asymmetricMatch(Object(1n)),\n    any(Symbol).asymmetricMatch(Object(Symbol())),\n    any(Array).asymmetricMatch(runInNewContext('[];')),\n    /* eslint-enable */\n  ]) {\n    jestExpect(test).toBe(true);\n  }\n});\n\ntest('Any.toAsymmetricMatcher()', () => {\n  jestExpect(any(Number).toAsymmetricMatcher()).toBe('Any<Number>');\n});\n\ntest('Any.toAsymmetricMatcher() with function name', () => {\n  for (const [name, fn] of [\n    ['someFunc', function someFunc() {}],\n    ['$someFunc', function $someFunc() {}],\n    [\n      '$someFunc2',\n      (function () {\n        function $someFunc2() {}\n        Object.defineProperty($someFunc2, 'name', {value: ''});\n        return $someFunc2;\n      })(),\n    ],\n    [\n      '$someAsyncFunc',\n      (function () {\n        async function $someAsyncFunc() {}\n        Object.defineProperty($someAsyncFunc, 'name', {value: ''});\n        return $someAsyncFunc;\n      })(),\n    ],\n    [\n      '$someGeneratorFunc',\n      (function () {\n        function* $someGeneratorFunc() {}\n        Object.defineProperty($someGeneratorFunc, 'name', {value: ''});\n        return $someGeneratorFunc;\n      })(),\n    ],\n    [\n      '$someFuncWithFakeToString',\n      (function () {\n        function $someFuncWithFakeToString() {}\n        $someFuncWithFakeToString.toString = () => 'Fake to string';\n        return $someFuncWithFakeToString;\n      })(),\n    ],\n  ]) {\n    jestExpect(any(fn).toAsymmetricMatcher()).toBe(`Any<${name}>`);\n  }\n});\n\ntest('Any throws when called with empty constructor', () => {\n  // @ts-expect-error: Testing runtime error\n  jestExpect(() => any()).toThrow(\n    'any() expects to be passed a constructor function. Please pass one or use anything() to match any object.',\n  );\n});\n\ntest('Anything matches any type', () => {\n  for (const test of [\n    anything().asymmetricMatch('jest'),\n    anything().asymmetricMatch(1),\n    anything().asymmetricMatch(() => {}),\n    anything().asymmetricMatch(true),\n    anything().asymmetricMatch({}),\n    anything().asymmetricMatch([]),\n  ]) {\n    jestExpect(test).toBe(true);\n  }\n});\n\ntest('Anything does not match null and undefined', () => {\n  for (const test of [\n    anything().asymmetricMatch(null),\n    anything().asymmetricMatch(undefined),\n  ]) {\n    jestExpect(test).toBe(false);\n  }\n});\n\ntest('Anything.toAsymmetricMatcher()', () => {\n  jestExpect(anything().toAsymmetricMatcher()).toBe('Anything');\n});\n\ntest('ArrayContaining matches', () => {\n  for (const test of [\n    arrayContaining([]).asymmetricMatch('jest'),\n    arrayContaining(['foo']).asymmetricMatch(['foo']),\n    arrayContaining(['foo']).asymmetricMatch(['foo', 'bar']),\n    arrayContaining([]).asymmetricMatch({}),\n  ]) {\n    jestExpect(test).toEqual(true);\n  }\n});\n\ntest('ArrayContaining does not match', () => {\n  jestExpect(arrayContaining(['foo']).asymmetricMatch(['bar'])).toBe(false);\n});\n\ntest('ArrayContaining throws for non-arrays', () => {\n  jestExpect(() => {\n    // @ts-expect-error: Testing runtime error\n    arrayContaining('foo').asymmetricMatch([]);\n  }).toThrow(\"You must provide an array to ArrayContaining, not 'string'.\");\n});\n\ntest('ArrayNotContaining matches', () => {\n  jestExpect(arrayNotContaining(['foo']).asymmetricMatch(['bar'])).toBe(true);\n});\n\ntest('ArrayNotContaining does not match', () => {\n  for (const test of [\n    arrayNotContaining([]).asymmetricMatch('jest'),\n    arrayNotContaining(['foo']).asymmetricMatch(['foo']),\n    arrayNotContaining(['foo']).asymmetricMatch(['foo', 'bar']),\n    arrayNotContaining([]).asymmetricMatch({}),\n  ]) {\n    jestExpect(test).toEqual(false);\n  }\n});\n\ntest('ArrayNotContaining throws for non-arrays', () => {\n  jestExpect(() => {\n    // @ts-expect-error: Testing runtime error\n    arrayNotContaining('foo').asymmetricMatch([]);\n  }).toThrow(\"You must provide an array to ArrayNotContaining, not 'string'.\");\n});\n\ntest('ObjectContaining matches', () => {\n  const foo = Symbol('foo');\n  for (const test of [\n    objectContaining({foo: 'foo'}).asymmetricMatch({foo: 'foo', jest: 'jest'}),\n    objectContaining({foo: undefined}).asymmetricMatch({foo: undefined}),\n    objectContaining({first: objectContaining({second: {}})}).asymmetricMatch({\n      first: {second: {}},\n    }),\n    objectContaining({foo: Buffer.from('foo')}).asymmetricMatch({\n      foo: Buffer.from('foo'),\n      jest: 'jest',\n    }),\n    objectContaining({[foo]: 'foo'}).asymmetricMatch({[foo]: 'foo'}),\n  ]) {\n    jestExpect(test).toEqual(true);\n  }\n});\n\ntest('ObjectContaining does not match', () => {\n  const foo = Symbol('foo');\n  const bar = Symbol('bar');\n  for (const test of [\n    objectContaining({foo: 'foo'}).asymmetricMatch({bar: 'bar'}),\n    objectContaining({foo: 'foo'}).asymmetricMatch({foo: 'foox'}),\n    objectContaining({foo: undefined}).asymmetricMatch({}),\n    objectContaining({\n      answer: 42,\n      foo: {bar: 'baz', foobar: 'qux'},\n    }).asymmetricMatch({foo: {bar: 'baz'}}),\n    objectContaining({[foo]: 'foo'}).asymmetricMatch({[bar]: 'bar'}),\n  ]) {\n    jestExpect(test).toEqual(false);\n  }\n});\n\ntest('ObjectContaining matches defined properties', () => {\n  const definedPropertyObject = {};\n  Object.defineProperty(definedPropertyObject, 'foo', {get: () => 'bar'});\n  jestExpect(\n    objectContaining({foo: 'bar'}).asymmetricMatch(definedPropertyObject),\n  ).toBe(true);\n});\n\ntest('ObjectContaining matches prototype properties', () => {\n  const prototypeObject = {foo: 'bar'};\n  let obj;\n\n  if (Object.create) {\n    obj = Object.create(prototypeObject);\n  } else {\n    function Foo() {}\n    Foo.prototype = prototypeObject;\n    Foo.prototype.constructor = Foo;\n    obj = new (Foo as any)();\n  }\n  jestExpect(objectContaining({foo: 'bar'}).asymmetricMatch(obj)).toBe(true);\n});\n\ntest('ObjectContaining throws for non-objects', () => {\n  // @ts-expect-error: Testing runtime error\n  jestExpect(() => objectContaining(1337).asymmetricMatch()).toThrow(\n    \"You must provide an object to ObjectContaining, not 'number'.\",\n  );\n});\n\ntest('ObjectContaining does not match when non-objects are passed to the expect function as arguments', () => {\n  for (const test of [\n    objectContaining({}).asymmetricMatch('jest'),\n    objectContaining({}).asymmetricMatch(10),\n    objectContaining({}).asymmetricMatch(false),\n    objectContaining({}).asymmetricMatch(undefined),\n    objectContaining({}).asymmetricMatch([]),\n  ]) {\n    jestExpect(test).toEqual(false);\n  }\n});\n\ntest('ObjectContaining does not mutate the sample', () => {\n  const sample = {foo: {bar: {}}};\n  const sample_json = JSON.stringify(sample);\n  expect({foo: {bar: {}}}).toEqual(expect.objectContaining(sample));\n\n  expect(JSON.stringify(sample)).toEqual(sample_json);\n});\n\ntest('ObjectNotContaining matches', () => {\n  const foo = Symbol('foo');\n  const bar = Symbol('bar');\n  for (const test of [\n    objectNotContaining({[foo]: 'foo'}).asymmetricMatch({[bar]: 'bar'}),\n    objectNotContaining({foo: 'foo'}).asymmetricMatch({bar: 'bar'}),\n    objectNotContaining({foo: 'foo'}).asymmetricMatch({foo: 'foox'}),\n    objectNotContaining({foo: undefined}).asymmetricMatch({}),\n    objectNotContaining({\n      first: objectNotContaining({second: {}}),\n    }).asymmetricMatch({first: {second: {}}}),\n    objectNotContaining({first: {second: {}, third: {}}}).asymmetricMatch({\n      first: {second: {}},\n    }),\n    objectNotContaining({first: {second: {}}}).asymmetricMatch({\n      first: {second: {}, third: {}},\n    }),\n    objectNotContaining({foo: 'foo', jest: 'jest'}).asymmetricMatch({\n      foo: 'foo',\n    }),\n  ]) {\n    jestExpect(test).toEqual(true);\n  }\n});\n\ntest('ObjectNotContaining does not match', () => {\n  for (const test of [\n    objectNotContaining({}).asymmetricMatch('jest'),\n    objectNotContaining({foo: 'foo'}).asymmetricMatch({\n      foo: 'foo',\n      jest: 'jest',\n    }),\n    objectNotContaining({foo: undefined}).asymmetricMatch({foo: undefined}),\n    objectNotContaining({first: {second: {}}}).asymmetricMatch({\n      first: {second: {}},\n    }),\n    objectNotContaining({\n      first: objectContaining({second: {}}),\n    }).asymmetricMatch({first: {second: {}}}),\n    objectNotContaining({}).asymmetricMatch(null),\n    objectNotContaining({}).asymmetricMatch(undefined),\n    objectNotContaining({}).asymmetricMatch({}),\n  ]) {\n    jestExpect(test).toEqual(false);\n  }\n});\n\ntest('ObjectNotContaining inverts ObjectContaining', () => {\n  for (const [sample, received] of [\n    [{}, null],\n    [{foo: 'foo'}, {foo: 'foo', jest: 'jest'}],\n    [{foo: 'foo', jest: 'jest'}, {foo: 'foo'}],\n    [{foo: undefined}, {foo: undefined}],\n    [{foo: undefined}, {}],\n    [{first: {second: {}}}, {first: {second: {}}}],\n    [{first: objectContaining({second: {}})}, {first: {second: {}}}],\n    [{first: objectNotContaining({second: {}})}, {first: {second: {}}}],\n    [{}, {foo: undefined}],\n  ] as const) {\n    jestExpect(objectNotContaining(sample).asymmetricMatch(received)).toEqual(\n      !objectContaining(sample).asymmetricMatch(received),\n    );\n  }\n});\n\ntest('ObjectNotContaining throws for non-objects', () => {\n  jestExpect(() => {\n    // @ts-expect-error: Testing runtime error\n    objectNotContaining(1337).asymmetricMatch();\n  }).toThrow(\n    \"You must provide an object to ObjectNotContaining, not 'number'.\",\n  );\n});\n\ntest('StringContaining matches string against string', () => {\n  jestExpect(stringContaining('en*').asymmetricMatch('queen*')).toBe(true);\n  jestExpect(stringContaining('en').asymmetricMatch('queue')).toBe(false);\n});\n\ntest('StringContaining throws if expected value is not string', () => {\n  jestExpect(() => {\n    // @ts-expect-error: Testing runtime error\n    stringContaining([1]).asymmetricMatch('queen');\n  }).toThrow('Expected is not a string');\n});\n\ntest('StringContaining returns false if received value is not string', () => {\n  jestExpect(stringContaining('en*').asymmetricMatch(1)).toBe(false);\n});\n\ntest('StringNotContaining matches string against string', () => {\n  jestExpect(stringNotContaining('en*').asymmetricMatch('queen*')).toBe(false);\n  jestExpect(stringNotContaining('en').asymmetricMatch('queue')).toBe(true);\n});\n\ntest('StringNotContaining throws if expected value is not string', () => {\n  jestExpect(() => {\n    // @ts-expect-error: Testing runtime error\n    stringNotContaining([1]).asymmetricMatch('queen');\n  }).toThrow('Expected is not a string');\n});\n\ntest('StringNotContaining returns true if received value is not string', () => {\n  jestExpect(stringNotContaining('en*').asymmetricMatch(1)).toBe(true);\n});\n\ntest('StringMatching matches string against regexp', () => {\n  jestExpect(stringMatching(/en/).asymmetricMatch('queen')).toBe(true);\n  jestExpect(stringMatching(/en/).asymmetricMatch('queue')).toBe(false);\n});\n\ntest('StringMatching matches string against string', () => {\n  jestExpect(stringMatching('en').asymmetricMatch('queen')).toBe(true);\n  jestExpect(stringMatching('en').asymmetricMatch('queue')).toBe(false);\n});\n\ntest('StringMatching throws if expected value is neither string nor regexp', () => {\n  jestExpect(() => {\n    // @ts-expect-error: Testing runtime error\n    stringMatching([1]).asymmetricMatch('queen');\n  }).toThrow('Expected is not a String or a RegExp');\n});\n\ntest('StringMatching returns false if received value is not string', () => {\n  jestExpect(stringMatching('en').asymmetricMatch(1)).toBe(false);\n});\n\ntest('StringMatching returns false even if coerced non-string received value matches pattern', () => {\n  jestExpect(stringMatching('null').asymmetricMatch(null)).toBe(false);\n});\n\ntest('StringNotMatching matches string against regexp', () => {\n  jestExpect(stringNotMatching(/en/).asymmetricMatch('queen')).toBe(false);\n  jestExpect(stringNotMatching(/en/).asymmetricMatch('queue')).toBe(true);\n});\n\ntest('StringNotMatching matches string against string', () => {\n  jestExpect(stringNotMatching('en').asymmetricMatch('queen')).toBe(false);\n  jestExpect(stringNotMatching('en').asymmetricMatch('queue')).toBe(true);\n});\n\ntest('StringNotMatching throws if expected value is neither string nor regexp', () => {\n  jestExpect(() => {\n    // @ts-expect-error: Testing runtime error\n    stringNotMatching([1]).asymmetricMatch('queen');\n  }).toThrow('Expected is not a String or a RegExp');\n});\n\ntest('StringNotMatching returns true if received value is not string', () => {\n  jestExpect(stringNotMatching('en').asymmetricMatch(1)).toBe(true);\n});\n\ndescribe('closeTo', () => {\n  for (const [expected, received] of [\n    [0, 0],\n    [0, 0.001],\n    [1.23, 1.229],\n    [1.23, 1.226],\n    [1.23, 1.225],\n    [1.23, 1.234],\n    [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY],\n    [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],\n  ]) {\n    test(`${expected} closeTo ${received} return true`, () => {\n      jestExpect(closeTo(expected).asymmetricMatch(received)).toBe(true);\n    });\n    test(`${expected} notCloseTo ${received} return false`, () => {\n      jestExpect(notCloseTo(expected).asymmetricMatch(received)).toBe(false);\n    });\n  }\n\n  for (const [expected, received] of [\n    [0, 0.01],\n    [1, 1.23],\n    [1.23, 1.224_999_9],\n    [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY],\n    [Number.POSITIVE_INFINITY, 1.23],\n    [Number.NEGATIVE_INFINITY, -1.23],\n  ]) {\n    test(`${expected} closeTo ${received} return false`, () => {\n      jestExpect(closeTo(expected).asymmetricMatch(received)).toBe(false);\n    });\n    test(`${expected} notCloseTo ${received} return true`, () => {\n      jestExpect(notCloseTo(expected).asymmetricMatch(received)).toBe(true);\n    });\n  }\n\n  for (const [expected, received, precision] of [\n    [0, 0.1, 0],\n    [0, 0.0001, 3],\n    [0, 0.000_004, 5],\n    [2.000_000_2, 2, 5],\n  ]) {\n    test(`${expected} closeTo ${received} with precision ${precision} return true`, () => {\n      jestExpect(closeTo(expected, precision).asymmetricMatch(received)).toBe(\n        true,\n      );\n    });\n    test(`${expected} notCloseTo ${received} with precision ${precision} return false`, () => {\n      jestExpect(\n        notCloseTo(expected, precision).asymmetricMatch(received),\n      ).toBe(false);\n    });\n  }\n\n  for (const [expected, received, precision] of [\n    [3.141_592e-7, 3e-7, 8],\n    [56_789, 51_234, -4],\n  ]) {\n    test(`${expected} closeTo ${received} with precision ${precision} return false`, () => {\n      jestExpect(closeTo(expected, precision).asymmetricMatch(received)).toBe(\n        false,\n      );\n    });\n    test(`${expected} notCloseTo ${received} with precision ${precision} return true`, () => {\n      jestExpect(\n        notCloseTo(expected, precision).asymmetricMatch(received),\n      ).toBe(true);\n    });\n  }\n\n  test('closeTo throw if expected is not number', () => {\n    jestExpect(() => {\n      // @ts-expect-error: Testing runtime error\n      closeTo('a');\n    }).toThrow('Expected is not a Number');\n  });\n\n  test('notCloseTo throw if expected is not number', () => {\n    jestExpect(() => {\n      // @ts-expect-error: Testing runtime error\n      notCloseTo('a');\n    }).toThrow('Expected is not a Number');\n  });\n\n  test('closeTo throw if precision is not number', () => {\n    jestExpect(() => {\n      // @ts-expect-error: Testing runtime error\n      closeTo(1, 'a');\n    }).toThrow('Precision is not a Number');\n  });\n\n  test('notCloseTo throw if precision is not number', () => {\n    jestExpect(() => {\n      // @ts-expect-error: Testing runtime error\n      notCloseTo(1, 'a');\n    }).toThrow('Precision is not a Number');\n  });\n\n  test('closeTo return false if received is not number', () => {\n    jestExpect(closeTo(1).asymmetricMatch('a')).toBe(false);\n  });\n\n  test('notCloseTo return false if received is not number', () => {\n    jestExpect(notCloseTo(1).asymmetricMatch('a')).toBe(false);\n  });\n});\n\ntest('ArrayOf matches', () => {\n  for (const test of [\n    arrayOf(1).asymmetricMatch([1]),\n    arrayOf(1).asymmetricMatch([1, 1, 1]),\n    arrayOf({a: 1}).asymmetricMatch([{a: 1}, {a: 1}]),\n    arrayOf(undefined).asymmetricMatch([undefined]),\n    arrayOf(null).asymmetricMatch([null]),\n    arrayOf([]).asymmetricMatch([[], []]),\n    arrayOf(any(String)).asymmetricMatch(['a', 'b', 'c']),\n  ]) {\n    jestExpect(test).toEqual(true);\n  }\n});\n\ntest('ArrayOf does not match', () => {\n  for (const test of [\n    arrayOf(1).asymmetricMatch([2]),\n    arrayOf(1).asymmetricMatch([1, 2]),\n    arrayOf({a: 1}).asymmetricMatch([{a: 2}]),\n    arrayOf(undefined).asymmetricMatch([null]),\n    arrayOf(null).asymmetricMatch([undefined]),\n    arrayOf([]).asymmetricMatch([{}]),\n    arrayOf(1).asymmetricMatch(1),\n    arrayOf(1).asymmetricMatch('not an array'),\n    arrayOf(1).asymmetricMatch({}),\n    arrayOf(any(String)).asymmetricMatch([1, 2]),\n  ]) {\n    jestExpect(test).toEqual(false);\n  }\n});\n\ntest('NotArrayOf matches', () => {\n  for (const test of [\n    notArrayOf(1).asymmetricMatch([2]),\n    notArrayOf(1).asymmetricMatch([1, 2]),\n    notArrayOf({a: 1}).asymmetricMatch([{a: 2}]),\n    notArrayOf(1).asymmetricMatch(1),\n    notArrayOf(1).asymmetricMatch('not an array'),\n    notArrayOf(1).asymmetricMatch({}),\n    notArrayOf(any(Number)).asymmetricMatch(['a', 'b']),\n  ]) {\n    jestExpect(test).toEqual(true);\n  }\n});\n\ntest('NotArrayOf does not match', () => {\n  for (const test of [\n    notArrayOf(1).asymmetricMatch([1]),\n    notArrayOf(1).asymmetricMatch([1, 1, 1]),\n    notArrayOf({a: 1}).asymmetricMatch([{a: 1}, {a: 1}]),\n    notArrayOf(undefined).asymmetricMatch([undefined]),\n    notArrayOf(null).asymmetricMatch([null]),\n    notArrayOf([]).asymmetricMatch([[], []]),\n    notArrayOf(any(String)).asymmetricMatch(['a', 'b', 'c']),\n  ]) {\n    jestExpect(test).toEqual(false);\n  }\n});\n",
  "packages/expect/src/__tests__/asymmetricMatchers.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport {};\n",
  "packages/expect/src/__tests__/assertionCounts.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {alignedAnsiStyleSerializer} from '@jest/test-utils';\nimport jestExpect from '../';\n\nexpect.addSnapshotSerializer(alignedAnsiStyleSerializer);\n\ndescribe('.assertions()', () => {\n  it('does not throw', () => {\n    jestExpect.assertions(2);\n    jestExpect('a').not.toBe('b');\n    jestExpect('a').toBe('a');\n  });\n\n  it('redeclares different assertion count', () => {\n    jestExpect.assertions(3);\n    jestExpect('a').not.toBe('b');\n    jestExpect('a').toBe('a');\n    jestExpect.assertions(2);\n  });\n  it('expects no assertions', () => {\n    jestExpect.assertions(0);\n  });\n});\n\ndescribe('.hasAssertions()', () => {\n  it('does not throw if there is an assertion', () => {\n    jestExpect.hasAssertions();\n    jestExpect('a').toBe('a');\n  });\n\n  it('throws if expected is not undefined', () => {\n    expect(() => {\n      // @ts-expect-error\n      jestExpect.hasAssertions(2);\n    }).toThrowErrorMatchingSnapshot();\n  });\n\n  it('hasAssertions not leaking to global state', () => {});\n});\n\ndescribe('numPassingAsserts', () => {\n  it('verify the default value of numPassingAsserts', () => {\n    const {numPassingAsserts} = jestExpect.getState();\n    expect(numPassingAsserts).toBe(0);\n  });\n\n  it('verify the resetting of numPassingAsserts after a test', () => {\n    expect('a').toBe('a');\n    expect('a').toBe('a');\n    // reset state\n    jestExpect.extractExpectedAssertionsErrors();\n    const {numPassingAsserts} = jestExpect.getState();\n    expect(numPassingAsserts).toBe(0);\n  });\n\n  it('verify the correctness of numPassingAsserts count for passing test', () => {\n    expect('a').toBe('a');\n    expect('a').toBe('a');\n    const {numPassingAsserts} = jestExpect.getState();\n    expect(numPassingAsserts).toBe(2);\n  });\n\n  it('verify the correctness of numPassingAsserts count for failing test', () => {\n    expect('a').toBe('a');\n    try {\n      expect('a').toBe('b');\n    } catch {}\n    const {numPassingAsserts} = jestExpect.getState();\n    expect(numPassingAsserts).toBe(1);\n  });\n});\n",
  "packages/expect/src/__tests__/assertionCounts.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport {};\n",
  "packages/expect/src/__tests__/__arbitraries__/sharedSettings.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {fc} from '@fast-check/jest';\n\n// settings for anything arbitrary\nexport const anythingSettings = {\n  key: fc.oneof(fc.string(), fc.constantFrom('k1', 'k2', 'k3')),\n  maxDepth: 2, // Limit object depth (default: 2)\n  maxKeys: 5, // Limit number of keys per object (default: 5)\n  withBoxedValues: true,\n  // Issue #7975 have to be fixed before enabling the generation of Map\n  withMap: false,\n  // Issue #7975 have to be fixed before enabling the generation of Set\n  withSet: false,\n};\n\n// assertion settings\nexport const assertSettings = {}; // eg.: {numRuns: 10000}\n",
  "packages/expect/src/__tests__/__arbitraries__/sharedSettings.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport declare const anythingSettings: {\n    key: any;\n    maxDepth: number;\n    maxKeys: number;\n    withBoxedValues: boolean;\n    withMap: boolean;\n    withSet: boolean;\n};\nexport declare const assertSettings: {};\n",
  "packages/expect/__typetests__/expectTyped.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {describe, expect, test} from 'tstyche';\nimport {expect as _expect} from 'expect';\n\ndeclare module 'expect' {\n  interface Matchers<R, T> {\n    toTypedEqual(expected: T): void;\n  }\n}\n\ndescribe('Expect', () => {\n  test('allows type inference of the `actual` argument', () => {\n    expect(_expect(100).toTypedEqual(100)).type.toBe<void>();\n    expect(_expect(101).not.toTypedEqual(100)).type.toBe<void>();\n\n    expect(_expect(100).toTypedEqual).type.not.toBeCallableWith('three');\n  });\n});\n",
  "packages/expect/__typetests__/expectTyped.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\ndeclare module 'expect' {\n    interface Matchers<R, T> {\n        toTypedEqual(expected: T): void;\n    }\n}\nexport {};\n",
  "packages/expect/__typetests__/expect.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {describe, expect, test} from 'tstyche';\nimport type {EqualsFunction} from '@jest/expect-utils';\nimport {\n  type MatcherContext,\n  type MatcherFunction,\n  type MatcherFunctionWithContext,\n  type Matchers,\n  type Tester,\n  type TesterContext,\n  expect as jestExpect,\n} from 'expect';\nimport type * as jestMatcherUtils from 'jest-matcher-utils';\n\ndeclare module 'expect' {\n  interface AsymmetricMatchers {\n    toBeWithinRange(floor: number, ceiling: number): void;\n  }\n  interface Matchers<R> {\n    toBeWithinRange(floor: number, ceiling: number): void;\n  }\n}\n\ndescribe('Matchers', () => {\n  test('requires between 1 and 2 type arguments', () => {\n    expect<Matchers<void, string>>().type.not.toRaiseError();\n    expect<Matchers<void>>().type.not.toRaiseError();\n\n    expect<Matchers>().type.toRaiseError(\n      'requires between 1 and 2 type arguments',\n    );\n  });\n});\n\ndescribe('Expect', () => {\n  test('.addEqualityTesters()', () => {\n    const tester1: Tester = function (a, b, customTesters) {\n      expect(a).type.toBe<any>();\n      expect(b).type.toBe<any>();\n      expect(customTesters).type.toBe<Array<Tester>>();\n      expect(this).type.toBe<TesterContext>();\n      expect(this.equals).type.toBe<EqualsFunction>();\n\n      return undefined;\n    };\n\n    expect(\n      jestExpect.addEqualityTesters([\n        tester1,\n\n        (a, b, customTesters) => {\n          expect(a).type.toBe<any>();\n          expect(b).type.toBe<any>();\n          expect(customTesters).type.toBe<Array<Tester>>();\n          expect(this).type.toBe<undefined>();\n\n          return true;\n        },\n\n        function anotherTester(a, b, customTesters) {\n          expect(a).type.toBe<any>();\n          expect(b).type.toBe<any>();\n          expect(customTesters).type.toBe<Array<Tester>>();\n          expect(this).type.toBe<TesterContext>();\n          expect(this.equals).type.toBe<EqualsFunction>();\n\n          return undefined;\n        },\n      ]),\n    ).type.toBe<void>();\n  });\n\n  test('.extend()', () => {\n    type MatcherUtils = typeof jestMatcherUtils & {\n      iterableEquality: Tester;\n      subsetEquality: Tester;\n    };\n\n    expect(\n      jestExpect.extend({\n        // TODO `actual` should be allowed to have only `unknown` type\n        toBeWithinRange(actual: number, floor: number, ceiling: number) {\n          expect(this.assertionCalls).type.toBe<number>();\n          expect(this.currentTestName).type.toBe<string | undefined>();\n          expect(this.customTesters).type.toBe<Array<Tester>>();\n          expect(this.dontThrow).type.toBe<() => void>();\n          expect(this.error).type.toBe<Error | undefined>();\n          expect(this.equals).type.toBe<EqualsFunction>();\n          expect(this.expand).type.toBe<boolean | undefined>();\n          expect(this.expectedAssertionsNumber).type.toBe<number | null>();\n          expect(this.expectedAssertionsNumberError).type.toBe<\n            Error | undefined\n          >();\n          expect(this.isExpectingAssertions).type.toBe<boolean>();\n          expect(this.isExpectingAssertionsError).type.toBe<\n            Error | undefined\n          >();\n          expect(this.isNot).type.toBe<boolean | undefined>();\n          expect(this.numPassingAsserts).type.toBe<number>();\n          expect(this.promise).type.toBe<string | undefined>();\n          expect(this.suppressedErrors).type.toBe<Array<Error>>();\n          expect(this.testPath).type.toBe<string | undefined>();\n          expect(this.utils).type.toBe<MatcherUtils>();\n\n          const pass = actual >= floor && actual <= ceiling;\n          if (pass) {\n            return {\n              message: () =>\n                `expected ${actual} not to be within range ${floor} - ${ceiling}`,\n              pass: true,\n            };\n          } else {\n            return {\n              message: () =>\n                `expected ${actual} to be within range ${floor} - ${ceiling}`,\n              pass: false,\n            };\n          }\n        },\n      }),\n    ).type.toBe<void>();\n\n    expect(jestExpect(100).toBeWithinRange(90, 110)).type.toBe<void>();\n    expect(jestExpect(101).not.toBeWithinRange(0, 100)).type.toBe<void>();\n\n    expect(\n      jestExpect({apples: 6, bananas: 3}).toEqual({\n        apples: jestExpect.toBeWithinRange(1, 10),\n        bananas: jestExpect.not.toBeWithinRange(11, 20),\n      }),\n    ).type.toBe<void>();\n  });\n\n  test('does not define the `.toMatchSnapshot()` matcher', () => {\n    expect(jestExpect(null)).type.not.toHaveProperty('toMatchSnapshot');\n  });\n});\n\ndescribe('MatcherFunction', () => {\n  test('models typings of a matcher function', () => {\n    type ToBeWithinRange = (\n      this: MatcherContext,\n      actual: unknown,\n      floor: number,\n      ceiling: number,\n    ) => any;\n\n    const toBeWithinRange: MatcherFunction<[floor: number, ceiling: number]> = (\n      actual: unknown,\n      floor: unknown,\n      ceiling: unknown,\n    ) => {\n      return {\n        message: () => `actual ${actual}; range ${floor}-${ceiling}`,\n        pass: true,\n      };\n    };\n\n    expect<ToBeWithinRange>().type.toBeAssignableWith(toBeWithinRange);\n  });\n\n  test('requires the `actual` argument to be of type `unknown`', () => {\n    const actualMustBeUnknown = (actual: string) => {\n      return {\n        message: () => `result: ${actual}`,\n        pass: actual === 'result',\n      };\n    };\n\n    expect<MatcherFunction>().type.not.toBeAssignableWith(actualMustBeUnknown);\n  });\n\n  test('allows omitting the `expected` argument', () => {\n    type AllowOmittingExpected = (this: MatcherContext, actual: unknown) => any;\n\n    const allowOmittingExpected: MatcherFunction = (\n      actual: unknown,\n      ...expected: Array<unknown>\n    ) => {\n      if (expected.length > 0) {\n        throw new Error('This matcher does not take any expected argument.');\n      }\n\n      return {\n        message: () => `actual ${actual}`,\n        pass: true,\n      };\n    };\n\n    expect<AllowOmittingExpected>().type.toBeAssignableWith(\n      allowOmittingExpected,\n    );\n  });\n\n  test('the `message` property is required in the return type', () => {\n    const lacksMessage = (actual: unknown) => {\n      return {\n        pass: actual === 'result',\n      };\n    };\n\n    expect<MatcherFunction>().type.not.toBeAssignableWith(lacksMessage);\n  });\n\n  test('the `pass` property is required in the return type', () => {\n    const lacksPass = (actual: unknown) => {\n      return {\n        message: () => `result: ${actual}`,\n      };\n    };\n\n    expect<MatcherFunction>().type.not.toBeAssignableWith(lacksPass);\n  });\n\n  test('context is defined inside a matcher function', () => {\n    const toHaveContext: MatcherFunction = function (\n      actual: unknown,\n      ...expected: Array<unknown>\n    ) {\n      expect(this).type.toBe<MatcherContext>();\n\n      if (expected.length > 0) {\n        throw new Error('This matcher does not take any expected argument.');\n      }\n\n      return {\n        message: () => `result: ${actual}`,\n        pass: actual === 'result',\n      };\n    };\n  });\n\n  test('context can be customized', () => {\n    interface CustomContext extends MatcherContext {\n      customMethod(): void;\n    }\n\n    const customContext: MatcherFunctionWithContext<CustomContext> = function (\n      actual: unknown,\n      ...expected: Array<unknown>\n    ) {\n      expect(this).type.toBe<CustomContext>();\n      expect(this.customMethod()).type.toBe<void>();\n\n      if (expected.length > 0) {\n        throw new Error('This matcher does not take any expected argument.');\n      }\n\n      return {\n        message: () => `result: ${actual}`,\n        pass: actual === 'result',\n      };\n    };\n  });\n\n  test('context and type of `expected` can be customized', () => {\n    interface CustomContext extends MatcherContext {\n      customMethod(): void;\n    }\n\n    type CustomStateAndExpected = (\n      this: CustomContext,\n      actual: unknown,\n      count: number,\n    ) => any;\n\n    const customContextAndExpected: MatcherFunctionWithContext<\n      CustomContext,\n      [count: number]\n    > = function (actual: unknown, count: unknown) {\n      expect(this).type.toBe<CustomContext>();\n      expect(this.customMethod()).type.toBe<void>();\n\n      return {\n        message: () => `count: ${count}`,\n        pass: actual === count,\n      };\n    };\n\n    expect<CustomStateAndExpected>().type.toBeAssignableWith(\n      customContextAndExpected,\n    );\n  });\n});\n",
  "packages/expect/__typetests__/expect.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\ndeclare module 'expect' {\n    interface AsymmetricMatchers {\n        toBeWithinRange(floor: number, ceiling: number): void;\n    }\n    interface Matchers<R> {\n        toBeWithinRange(floor: number, ceiling: number): void;\n    }\n}\nexport {};\n",
  "packages/diff-sequences/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// This diff-sequences package implements the linear space variation in\n// An O(ND) Difference Algorithm and Its Variations by Eugene W. Myers\n\n// Relationship in notation between Myers paper and this package:\n// A is a\n// N is aLength, aEnd - aStart, and so on\n// x is aIndex, aFirst, aLast, and so on\n// B is b\n// M is bLength, bEnd - bStart, and so on\n// y is bIndex, bFirst, bLast, and so on\n// Δ = N - M is negative of baDeltaLength = bLength - aLength\n// D is d\n// k is kF\n// k + Δ is kF = kR - baDeltaLength\n// V is aIndexesF or aIndexesR (see comment below about Indexes type)\n// index intervals [1, N] and [1, M] are [0, aLength) and [0, bLength)\n// starting point in forward direction (0, 0) is (-1, -1)\n// starting point in reverse direction (N + 1, M + 1) is (aLength, bLength)\n\n// The “edit graph” for sequences a and b corresponds to items:\n// in a on the horizontal axis\n// in b on the vertical axis\n//\n// Given a-coordinate of a point in a diagonal, you can compute b-coordinate.\n//\n// Forward diagonals kF:\n// zero diagonal intersects top left corner\n// positive diagonals intersect top edge\n// negative diagonals intersect left edge\n//\n// Reverse diagonals kR:\n// zero diagonal intersects bottom right corner\n// positive diagonals intersect right edge\n// negative diagonals intersect bottom edge\n\n// The graph contains a directed acyclic graph of edges:\n// horizontal: delete an item from a\n// vertical: insert an item from b\n// diagonal: common item in a and b\n//\n// The algorithm solves dual problems in the graph analogy:\n// Find longest common subsequence: path with maximum number of diagonal edges\n// Find shortest edit script: path with minimum number of non-diagonal edges\n\n// Input callback function compares items at indexes in the sequences.\ntype IsCommon = (\n  aIndex: number, // caller can assume: 0 <= aIndex && aIndex < aLength\n  bIndex: number, // caller can assume: 0 <= bIndex && bIndex < bLength\n) => boolean;\n\n// Output callback function receives the number of adjacent items\n// and starting indexes of each common subsequence.\ntype FoundSubsequence = (\n  nCommon: number, // caller can assume: 0 < nCommon\n  aCommon: number, // caller can assume: 0 <= aCommon && aCommon < aLength\n  bCommon: number, // caller can assume: 0 <= bCommon && bCommon < bLength\n) => void;\n\n// Either original functions or wrapped to swap indexes if graph is transposed.\nexport type Callbacks = {\n  foundSubsequence: FoundSubsequence;\n  isCommon: IsCommon;\n};\n\n// Indexes in sequence a of last point of forward or reverse paths in graph.\n// Myers algorithm indexes by diagonal k which for negative is bad deopt in V8.\n// This package indexes by iF and iR which are greater than or equal to zero.\n// and also updates the index arrays in place to cut memory in half.\n// kF = 2 * iF - d\n// kR = d - 2 * iR\ntype Indexes = Array<number>;\n\n// Division of index intervals in sequences a and b at the middle change.\n// Invariant: intervals do not have common items at the start or end.\ntype Division = {\n  // The end of interval preceding division is open like array slice method.\n  nChangePreceding: number; // number of change items\n  aEndPreceding: number;\n  bEndPreceding: number;\n\n  nCommonPreceding: number; // 0 if no common items preceding middle change\n  aCommonPreceding: number; // ignore prop value if nCommonPreceding === 0\n  bCommonPreceding: number; // ignore prop value if nCommonPreceding === 0\n\n  nCommonFollowing: number; // 0 if no common items following middle change\n  aCommonFollowing: number; // ignore prop value if nCommonFollowing === 0\n  bCommonFollowing: number; // ignore prop value if nCommonFollowing === 0\n\n  // The start of interval following division is closed like array slice method.\n  nChangeFollowing: number; // number of change items\n  aStartFollowing: number;\n  bStartFollowing: number;\n};\n\nconst pkg = '@jest/diff-sequences'; // for error messages\nconst NOT_YET_SET = 0; // small int instead of undefined to avoid deopt in V8\n\n// Return the number of common items that follow in forward direction.\n// The length of what Myers paper calls a “snake” in a forward path.\nconst countCommonItemsF = (\n  aIndex: number,\n  aEnd: number,\n  bIndex: number,\n  bEnd: number,\n  isCommon: IsCommon,\n) => {\n  let nCommon = 0;\n  while (aIndex < aEnd && bIndex < bEnd && isCommon(aIndex, bIndex)) {\n    aIndex += 1;\n    bIndex += 1;\n    nCommon += 1;\n  }\n  return nCommon;\n};\n\n// Return the number of common items that precede in reverse direction.\n// The length of what Myers paper calls a “snake” in a reverse path.\nconst countCommonItemsR = (\n  aStart: number,\n  aIndex: number,\n  bStart: number,\n  bIndex: number,\n  isCommon: IsCommon,\n) => {\n  let nCommon = 0;\n  while (aStart <= aIndex && bStart <= bIndex && isCommon(aIndex, bIndex)) {\n    aIndex -= 1;\n    bIndex -= 1;\n    nCommon += 1;\n  }\n  return nCommon;\n};\n\n// A simple function to extend forward paths from (d - 1) to d changes\n// when forward and reverse paths cannot yet overlap.\nconst extendPathsF = (\n  d: number,\n  aEnd: number,\n  bEnd: number,\n  bF: number, // bIndex = bF + aIndex - kF\n  isCommon: IsCommon,\n  aIndexesF: Indexes, // update indexes in sequence a of paths in diagonals kF\n  iMaxF: number, // return the value because optimization might decrease it\n): number => {\n  // Unroll the first iteration.\n  let iF = 0;\n  let kF = -d; // kF = 2 * iF - d\n  let aFirst = aIndexesF[iF]; // in first iteration always insert\n  let aIndexPrev1 = aFirst; // prev value of [iF - 1] in next iteration\n  aIndexesF[iF] += countCommonItemsF(\n    aFirst + 1,\n    aEnd,\n    bF + aFirst - kF + 1,\n    bEnd,\n    isCommon,\n  );\n\n  // Optimization: skip diagonals in which paths cannot ever overlap.\n  const nF = Math.min(d, iMaxF);\n\n  // The diagonals kF are odd when d is odd and even when d is even.\n  for (iF += 1, kF += 2; iF <= nF; iF += 1, kF += 2) {\n    // To get first point of path segment, move one change in forward direction\n    // from last point of previous path segment in an adjacent diagonal.\n    // In last possible iteration when iF === d and kF === d always delete.\n    if (iF !== d && aIndexPrev1 < aIndexesF[iF]) {\n      aFirst = aIndexesF[iF]; // vertical to insert from b\n    } else {\n      aFirst = aIndexPrev1 + 1; // horizontal to delete from a\n\n      if (aEnd <= aFirst) {\n        // Optimization: delete moved past right of graph.\n        return iF - 1;\n      }\n    }\n\n    // To get last point of path segment, move along diagonal of common items.\n    aIndexPrev1 = aIndexesF[iF];\n    aIndexesF[iF] =\n      aFirst +\n      countCommonItemsF(aFirst + 1, aEnd, bF + aFirst - kF + 1, bEnd, isCommon);\n  }\n\n  return iMaxF;\n};\n\n// A simple function to extend reverse paths from (d - 1) to d changes\n// when reverse and forward paths cannot yet overlap.\nconst extendPathsR = (\n  d: number,\n  aStart: number,\n  bStart: number,\n  bR: number, // bIndex = bR + aIndex - kR\n  isCommon: IsCommon,\n  aIndexesR: Indexes, // update indexes in sequence a of paths in diagonals kR\n  iMaxR: number, // return the value because optimization might decrease it\n): number => {\n  // Unroll the first iteration.\n  let iR = 0;\n  let kR = d; // kR = d - 2 * iR\n  let aFirst = aIndexesR[iR]; // in first iteration always insert\n  let aIndexPrev1 = aFirst; // prev value of [iR - 1] in next iteration\n  aIndexesR[iR] -= countCommonItemsR(\n    aStart,\n    aFirst - 1,\n    bStart,\n    bR + aFirst - kR - 1,\n    isCommon,\n  );\n\n  // Optimization: skip diagonals in which paths cannot ever overlap.\n  const nR = Math.min(d, iMaxR);\n\n  // The diagonals kR are odd when d is odd and even when d is even.\n  for (iR += 1, kR -= 2; iR <= nR; iR += 1, kR -= 2) {\n    // To get first point of path segment, move one change in reverse direction\n    // from last point of previous path segment in an adjacent diagonal.\n    // In last possible iteration when iR === d and kR === -d always delete.\n    if (iR !== d && aIndexesR[iR] < aIndexPrev1) {\n      aFirst = aIndexesR[iR]; // vertical to insert from b\n    } else {\n      aFirst = aIndexPrev1 - 1; // horizontal to delete from a\n\n      if (aFirst < aStart) {\n        // Optimization: delete moved past left of graph.\n        return iR - 1;\n      }\n    }\n\n    // To get last point of path segment, move along diagonal of common items.\n    aIndexPrev1 = aIndexesR[iR];\n    aIndexesR[iR] =\n      aFirst -\n      countCommonItemsR(\n        aStart,\n        aFirst - 1,\n        bStart,\n        bR + aFirst - kR - 1,\n        isCommon,\n      );\n  }\n\n  return iMaxR;\n};\n\n// A complete function to extend forward paths from (d - 1) to d changes.\n// Return true if a path overlaps reverse path of (d - 1) changes in its diagonal.\nconst extendOverlappablePathsF = (\n  d: number,\n  aStart: number,\n  aEnd: number,\n  bStart: number,\n  bEnd: number,\n  isCommon: IsCommon,\n  aIndexesF: Indexes, // update indexes in sequence a of paths in diagonals kF\n  iMaxF: number,\n  aIndexesR: Indexes,\n  iMaxR: number,\n  division: Division, // update prop values if return true\n): boolean => {\n  const bF = bStart - aStart; // bIndex = bF + aIndex - kF\n  const aLength = aEnd - aStart;\n  const bLength = bEnd - bStart;\n  const baDeltaLength = bLength - aLength; // kF = kR - baDeltaLength\n\n  // Range of diagonals in which forward and reverse paths might overlap.\n  const kMinOverlapF = -baDeltaLength - (d - 1); // -(d - 1) <= kR\n  const kMaxOverlapF = -baDeltaLength + (d - 1); // kR <= (d - 1)\n\n  let aIndexPrev1 = NOT_YET_SET; // prev value of [iF - 1] in next iteration\n\n  // Optimization: skip diagonals in which paths cannot ever overlap.\n  const nF = Math.min(d, iMaxF);\n\n  // The diagonals kF = 2 * iF - d are odd when d is odd and even when d is even.\n  for (let iF = 0, kF = -d; iF <= nF; iF += 1, kF += 2) {\n    // To get first point of path segment, move one change in forward direction\n    // from last point of previous path segment in an adjacent diagonal.\n    // In first iteration when iF === 0 and kF === -d always insert.\n    // In last possible iteration when iF === d and kF === d always delete.\n    const insert = iF === 0 || (iF !== d && aIndexPrev1 < aIndexesF[iF]);\n    const aLastPrev = insert ? aIndexesF[iF] : aIndexPrev1;\n    const aFirst = insert\n      ? aLastPrev // vertical to insert from b\n      : aLastPrev + 1; // horizontal to delete from a\n\n    // To get last point of path segment, move along diagonal of common items.\n    const bFirst = bF + aFirst - kF;\n    const nCommonF = countCommonItemsF(\n      aFirst + 1,\n      aEnd,\n      bFirst + 1,\n      bEnd,\n      isCommon,\n    );\n    const aLast = aFirst + nCommonF;\n\n    aIndexPrev1 = aIndexesF[iF];\n    aIndexesF[iF] = aLast;\n\n    if (kMinOverlapF <= kF && kF <= kMaxOverlapF) {\n      // Solve for iR of reverse path with (d - 1) changes in diagonal kF:\n      // kR = kF + baDeltaLength\n      // kR = (d - 1) - 2 * iR\n      const iR = (d - 1 - (kF + baDeltaLength)) / 2;\n\n      // If this forward path overlaps the reverse path in this diagonal,\n      // then this is the middle change of the index intervals.\n      if (iR <= iMaxR && aIndexesR[iR] - 1 <= aLast) {\n        // Unlike the Myers algorithm which finds only the middle “snake”\n        // this package can find two common subsequences per division.\n        // Last point of previous path segment is on an adjacent diagonal.\n        const bLastPrev = bF + aLastPrev - (insert ? kF + 1 : kF - 1);\n\n        // Because of invariant that intervals preceding the middle change\n        // cannot have common items at the end,\n        // move in reverse direction along a diagonal of common items.\n        const nCommonR = countCommonItemsR(\n          aStart,\n          aLastPrev,\n          bStart,\n          bLastPrev,\n          isCommon,\n        );\n\n        const aIndexPrevFirst = aLastPrev - nCommonR;\n        const bIndexPrevFirst = bLastPrev - nCommonR;\n\n        const aEndPreceding = aIndexPrevFirst + 1;\n        const bEndPreceding = bIndexPrevFirst + 1;\n\n        division.nChangePreceding = d - 1;\n        if (d - 1 === aEndPreceding + bEndPreceding - aStart - bStart) {\n          // Optimization: number of preceding changes in forward direction\n          // is equal to number of items in preceding interval,\n          // therefore it cannot contain any common items.\n          division.aEndPreceding = aStart;\n          division.bEndPreceding = bStart;\n        } else {\n          division.aEndPreceding = aEndPreceding;\n          division.bEndPreceding = bEndPreceding;\n        }\n\n        division.nCommonPreceding = nCommonR;\n        if (nCommonR !== 0) {\n          division.aCommonPreceding = aEndPreceding;\n          division.bCommonPreceding = bEndPreceding;\n        }\n\n        division.nCommonFollowing = nCommonF;\n        if (nCommonF !== 0) {\n          division.aCommonFollowing = aFirst + 1;\n          division.bCommonFollowing = bFirst + 1;\n        }\n\n        const aStartFollowing = aLast + 1;\n        const bStartFollowing = bFirst + nCommonF + 1;\n\n        division.nChangeFollowing = d - 1;\n        if (d - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing) {\n          // Optimization: number of changes in reverse direction\n          // is equal to number of items in following interval,\n          // therefore it cannot contain any common items.\n          division.aStartFollowing = aEnd;\n          division.bStartFollowing = bEnd;\n        } else {\n          division.aStartFollowing = aStartFollowing;\n          division.bStartFollowing = bStartFollowing;\n        }\n\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\n// A complete function to extend reverse paths from (d - 1) to d changes.\n// Return true if a path overlaps forward path of d changes in its diagonal.\nconst extendOverlappablePathsR = (\n  d: number,\n  aStart: number,\n  aEnd: number,\n  bStart: number,\n  bEnd: number,\n  isCommon: IsCommon,\n  aIndexesF: Indexes,\n  iMaxF: number,\n  aIndexesR: Indexes, // update indexes in sequence a of paths in diagonals kR\n  iMaxR: number,\n  division: Division, // update prop values if return true\n): boolean => {\n  const bR = bEnd - aEnd; // bIndex = bR + aIndex - kR\n  const aLength = aEnd - aStart;\n  const bLength = bEnd - bStart;\n  const baDeltaLength = bLength - aLength; // kR = kF + baDeltaLength\n\n  // Range of diagonals in which forward and reverse paths might overlap.\n  const kMinOverlapR = baDeltaLength - d; // -d <= kF\n  const kMaxOverlapR = baDeltaLength + d; // kF <= d\n\n  let aIndexPrev1 = NOT_YET_SET; // prev value of [iR - 1] in next iteration\n\n  // Optimization: skip diagonals in which paths cannot ever overlap.\n  const nR = Math.min(d, iMaxR);\n\n  // The diagonals kR = d - 2 * iR are odd when d is odd and even when d is even.\n  for (let iR = 0, kR = d; iR <= nR; iR += 1, kR -= 2) {\n    // To get first point of path segment, move one change in reverse direction\n    // from last point of previous path segment in an adjacent diagonal.\n    // In first iteration when iR === 0 and kR === d always insert.\n    // In last possible iteration when iR === d and kR === -d always delete.\n    const insert = iR === 0 || (iR !== d && aIndexesR[iR] < aIndexPrev1);\n    const aLastPrev = insert ? aIndexesR[iR] : aIndexPrev1;\n    const aFirst = insert\n      ? aLastPrev // vertical to insert from b\n      : aLastPrev - 1; // horizontal to delete from a\n\n    // To get last point of path segment, move along diagonal of common items.\n    const bFirst = bR + aFirst - kR;\n    const nCommonR = countCommonItemsR(\n      aStart,\n      aFirst - 1,\n      bStart,\n      bFirst - 1,\n      isCommon,\n    );\n    const aLast = aFirst - nCommonR;\n\n    aIndexPrev1 = aIndexesR[iR];\n    aIndexesR[iR] = aLast;\n\n    if (kMinOverlapR <= kR && kR <= kMaxOverlapR) {\n      // Solve for iF of forward path with d changes in diagonal kR:\n      // kF = kR - baDeltaLength\n      // kF = 2 * iF - d\n      const iF = (d + (kR - baDeltaLength)) / 2;\n\n      // If this reverse path overlaps the forward path in this diagonal,\n      // then this is a middle change of the index intervals.\n      if (iF <= iMaxF && aLast - 1 <= aIndexesF[iF]) {\n        const bLast = bFirst - nCommonR;\n\n        division.nChangePreceding = d;\n        if (d === aLast + bLast - aStart - bStart) {\n          // Optimization: number of changes in reverse direction\n          // is equal to number of items in preceding interval,\n          // therefore it cannot contain any common items.\n          division.aEndPreceding = aStart;\n          division.bEndPreceding = bStart;\n        } else {\n          division.aEndPreceding = aLast;\n          division.bEndPreceding = bLast;\n        }\n\n        division.nCommonPreceding = nCommonR;\n        if (nCommonR !== 0) {\n          // The last point of reverse path segment is start of common subsequence.\n          division.aCommonPreceding = aLast;\n          division.bCommonPreceding = bLast;\n        }\n\n        division.nChangeFollowing = d - 1;\n        if (d === 1) {\n          // There is no previous path segment.\n          division.nCommonFollowing = 0;\n          division.aStartFollowing = aEnd;\n          division.bStartFollowing = bEnd;\n        } else {\n          // Unlike the Myers algorithm which finds only the middle “snake”\n          // this package can find two common subsequences per division.\n          // Last point of previous path segment is on an adjacent diagonal.\n          const bLastPrev = bR + aLastPrev - (insert ? kR - 1 : kR + 1);\n\n          // Because of invariant that intervals following the middle change\n          // cannot have common items at the start,\n          // move in forward direction along a diagonal of common items.\n          const nCommonF = countCommonItemsF(\n            aLastPrev,\n            aEnd,\n            bLastPrev,\n            bEnd,\n            isCommon,\n          );\n\n          division.nCommonFollowing = nCommonF;\n          if (nCommonF !== 0) {\n            // The last point of reverse path segment is start of common subsequence.\n            division.aCommonFollowing = aLastPrev;\n            division.bCommonFollowing = bLastPrev;\n          }\n\n          const aStartFollowing = aLastPrev + nCommonF; // aFirstPrev\n          const bStartFollowing = bLastPrev + nCommonF; // bFirstPrev\n\n          if (d - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing) {\n            // Optimization: number of changes in forward direction\n            // is equal to number of items in following interval,\n            // therefore it cannot contain any common items.\n            division.aStartFollowing = aEnd;\n            division.bStartFollowing = bEnd;\n          } else {\n            division.aStartFollowing = aStartFollowing;\n            division.bStartFollowing = bStartFollowing;\n          }\n        }\n\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\n// Given index intervals and input function to compare items at indexes,\n// divide at the middle change.\n//\n// DO NOT CALL if start === end, because interval cannot contain common items\n// and because this function will throw the “no overlap” error.\nconst divide = (\n  nChange: number,\n  aStart: number,\n  aEnd: number,\n  bStart: number,\n  bEnd: number,\n  isCommon: IsCommon,\n  aIndexesF: Indexes, // temporary memory, not input nor output\n  aIndexesR: Indexes, // temporary memory, not input nor output\n  division: Division, // output\n) => {\n  const bF = bStart - aStart; // bIndex = bF + aIndex - kF\n  const bR = bEnd - aEnd; // bIndex = bR + aIndex - kR\n  const aLength = aEnd - aStart;\n  const bLength = bEnd - bStart;\n\n  // Because graph has square or portrait orientation,\n  // length difference is minimum number of items to insert from b.\n  // Corresponding forward and reverse diagonals in graph\n  // depend on length difference of the sequences:\n  // kF = kR - baDeltaLength\n  // kR = kF + baDeltaLength\n  const baDeltaLength = bLength - aLength;\n\n  // Optimization: max diagonal in graph intersects corner of shorter side.\n  let iMaxF = aLength;\n  let iMaxR = aLength;\n\n  // Initialize no changes yet in forward or reverse direction:\n  aIndexesF[0] = aStart - 1; // at open start of interval, outside closed start\n  aIndexesR[0] = aEnd; // at open end of interval\n\n  if (baDeltaLength % 2 === 0) {\n    // The number of changes in paths is 2 * d if length difference is even.\n    const dMin = (nChange || baDeltaLength) / 2;\n    const dMax = (aLength + bLength) / 2;\n\n    for (let d = 1; d <= dMax; d += 1) {\n      iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);\n\n      if (d < dMin) {\n        iMaxR = extendPathsR(d, aStart, bStart, bR, isCommon, aIndexesR, iMaxR);\n      } else if (\n        // If a reverse path overlaps a forward path in the same diagonal,\n        // return a division of the index intervals at the middle change.\n        extendOverlappablePathsR(\n          d,\n          aStart,\n          aEnd,\n          bStart,\n          bEnd,\n          isCommon,\n          aIndexesF,\n          iMaxF,\n          aIndexesR,\n          iMaxR,\n          division,\n        )\n      ) {\n        return;\n      }\n    }\n  } else {\n    // The number of changes in paths is 2 * d - 1 if length difference is odd.\n    const dMin = ((nChange || baDeltaLength) + 1) / 2;\n    const dMax = (aLength + bLength + 1) / 2;\n\n    // Unroll first half iteration so loop extends the relevant pairs of paths.\n    // Because of invariant that intervals have no common items at start or end,\n    // and limitation not to call divide with empty intervals,\n    // therefore it cannot be called if a forward path with one change\n    // would overlap a reverse path with no changes, even if dMin === 1.\n    let d = 1;\n    iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);\n\n    for (d += 1; d <= dMax; d += 1) {\n      iMaxR = extendPathsR(\n        d - 1,\n        aStart,\n        bStart,\n        bR,\n        isCommon,\n        aIndexesR,\n        iMaxR,\n      );\n\n      if (d < dMin) {\n        iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);\n      } else if (\n        // If a forward path overlaps a reverse path in the same diagonal,\n        // return a division of the index intervals at the middle change.\n        extendOverlappablePathsF(\n          d,\n          aStart,\n          aEnd,\n          bStart,\n          bEnd,\n          isCommon,\n          aIndexesF,\n          iMaxF,\n          aIndexesR,\n          iMaxR,\n          division,\n        )\n      ) {\n        return;\n      }\n    }\n  }\n\n  /* istanbul ignore next */\n  throw new Error(\n    `${pkg}: no overlap aStart=${aStart} aEnd=${aEnd} bStart=${bStart} bEnd=${bEnd}`,\n  );\n};\n\n// Given index intervals and input function to compare items at indexes,\n// return by output function the number of adjacent items and starting indexes\n// of each common subsequence. Divide and conquer with only linear space.\n//\n// The index intervals are half open [start, end) like array slice method.\n// DO NOT CALL if start === end, because interval cannot contain common items\n// and because divide function will throw the “no overlap” error.\nconst findSubsequences = (\n  nChange: number,\n  aStart: number,\n  aEnd: number,\n  bStart: number,\n  bEnd: number,\n  transposed: boolean,\n  callbacks: Array<Callbacks>,\n  aIndexesF: Indexes, // temporary memory, not input nor output\n  aIndexesR: Indexes, // temporary memory, not input nor output\n  division: Division, // temporary memory, not input nor output\n) => {\n  if (bEnd - bStart < aEnd - aStart) {\n    // Transpose graph so it has portrait instead of landscape orientation.\n    // Always compare shorter to longer sequence for consistency and optimization.\n    transposed = !transposed;\n    if (transposed && callbacks.length === 1) {\n      // Lazily wrap callback functions to swap args if graph is transposed.\n      const {foundSubsequence, isCommon} = callbacks[0];\n      callbacks[1] = {\n        foundSubsequence: (nCommon, bCommon, aCommon) => {\n          foundSubsequence(nCommon, aCommon, bCommon);\n        },\n        isCommon: (bIndex, aIndex) => isCommon(aIndex, bIndex),\n      };\n    }\n\n    const tStart = aStart;\n    const tEnd = aEnd;\n    aStart = bStart;\n    aEnd = bEnd;\n    bStart = tStart;\n    bEnd = tEnd;\n  }\n  const {foundSubsequence, isCommon} = callbacks[transposed ? 1 : 0];\n\n  // Divide the index intervals at the middle change.\n  divide(\n    nChange,\n    aStart,\n    aEnd,\n    bStart,\n    bEnd,\n    isCommon,\n    aIndexesF,\n    aIndexesR,\n    division,\n  );\n  const {\n    nChangePreceding,\n    aEndPreceding,\n    bEndPreceding,\n    nCommonPreceding,\n    aCommonPreceding,\n    bCommonPreceding,\n    nCommonFollowing,\n    aCommonFollowing,\n    bCommonFollowing,\n    nChangeFollowing,\n    aStartFollowing,\n    bStartFollowing,\n  } = division;\n\n  // Unless either index interval is empty, they might contain common items.\n  if (aStart < aEndPreceding && bStart < bEndPreceding) {\n    // Recursely find and return common subsequences preceding the division.\n    findSubsequences(\n      nChangePreceding,\n      aStart,\n      aEndPreceding,\n      bStart,\n      bEndPreceding,\n      transposed,\n      callbacks,\n      aIndexesF,\n      aIndexesR,\n      division,\n    );\n  }\n\n  // Return common subsequences that are adjacent to the middle change.\n  if (nCommonPreceding !== 0) {\n    foundSubsequence(nCommonPreceding, aCommonPreceding, bCommonPreceding);\n  }\n  if (nCommonFollowing !== 0) {\n    foundSubsequence(nCommonFollowing, aCommonFollowing, bCommonFollowing);\n  }\n\n  // Unless either index interval is empty, they might contain common items.\n  if (aStartFollowing < aEnd && bStartFollowing < bEnd) {\n    // Recursely find and return common subsequences following the division.\n    findSubsequences(\n      nChangeFollowing,\n      aStartFollowing,\n      aEnd,\n      bStartFollowing,\n      bEnd,\n      transposed,\n      callbacks,\n      aIndexesF,\n      aIndexesR,\n      division,\n    );\n  }\n};\n\nconst validateLength = (name: string, arg: unknown) => {\n  if (typeof arg !== 'number') {\n    throw new TypeError(`${pkg}: ${name} typeof ${typeof arg} is not a number`);\n  }\n  if (!Number.isSafeInteger(arg)) {\n    throw new RangeError(`${pkg}: ${name} value ${arg} is not a safe integer`);\n  }\n  if (arg < 0) {\n    throw new RangeError(`${pkg}: ${name} value ${arg} is a negative integer`);\n  }\n};\n\nconst validateCallback = (name: string, arg: unknown) => {\n  const type = typeof arg;\n  if (type !== 'function') {\n    throw new TypeError(`${pkg}: ${name} typeof ${type} is not a function`);\n  }\n};\n\n// Compare items in two sequences to find a longest common subsequence.\n// Given lengths of sequences and input function to compare items at indexes,\n// return by output function the number of adjacent items and starting indexes\n// of each common subsequence.\nexport default function diffSequence(\n  aLength: number,\n  bLength: number,\n  isCommon: IsCommon,\n  foundSubsequence: FoundSubsequence,\n): void {\n  validateLength('aLength', aLength);\n  validateLength('bLength', bLength);\n  validateCallback('isCommon', isCommon);\n  validateCallback('foundSubsequence', foundSubsequence);\n\n  // Count common items from the start in the forward direction.\n  const nCommonF = countCommonItemsF(0, aLength, 0, bLength, isCommon);\n\n  if (nCommonF !== 0) {\n    foundSubsequence(nCommonF, 0, 0);\n  }\n\n  // Unless both sequences consist of common items only,\n  // find common items in the half-trimmed index intervals.\n  if (aLength !== nCommonF || bLength !== nCommonF) {\n    // Invariant: intervals do not have common items at the start.\n    // The start of an index interval is closed like array slice method.\n    const aStart = nCommonF;\n    const bStart = nCommonF;\n\n    // Count common items from the end in the reverse direction.\n    const nCommonR = countCommonItemsR(\n      aStart,\n      aLength - 1,\n      bStart,\n      bLength - 1,\n      isCommon,\n    );\n\n    // Invariant: intervals do not have common items at the end.\n    // The end of an index interval is open like array slice method.\n    const aEnd = aLength - nCommonR;\n    const bEnd = bLength - nCommonR;\n\n    // Unless one sequence consists of common items only,\n    // therefore the other trimmed index interval consists of changes only,\n    // find common items in the trimmed index intervals.\n    const nCommonFR = nCommonF + nCommonR;\n    if (aLength !== nCommonFR && bLength !== nCommonFR) {\n      const nChange = 0; // number of change items is not yet known\n      const transposed = false; // call the original unwrapped functions\n      const callbacks = [{foundSubsequence, isCommon}];\n\n      // Indexes in sequence a of last points in furthest reaching paths\n      // from outside the start at top left in the forward direction:\n      const aIndexesF = [NOT_YET_SET];\n      // from the end at bottom right in the reverse direction:\n      const aIndexesR = [NOT_YET_SET];\n\n      // Initialize one object as output of all calls to divide function.\n      const division = {\n        aCommonFollowing: NOT_YET_SET,\n        aCommonPreceding: NOT_YET_SET,\n        aEndPreceding: NOT_YET_SET,\n        aStartFollowing: NOT_YET_SET,\n        bCommonFollowing: NOT_YET_SET,\n        bCommonPreceding: NOT_YET_SET,\n        bEndPreceding: NOT_YET_SET,\n        bStartFollowing: NOT_YET_SET,\n        nChangeFollowing: NOT_YET_SET,\n        nChangePreceding: NOT_YET_SET,\n        nCommonFollowing: NOT_YET_SET,\n        nCommonPreceding: NOT_YET_SET,\n      };\n\n      // Find and return common subsequences in the trimmed index intervals.\n      findSubsequences(\n        nChange,\n        aStart,\n        aEnd,\n        bStart,\n        bEnd,\n        transposed,\n        callbacks,\n        aIndexesF,\n        aIndexesR,\n        division,\n      );\n    }\n\n    if (nCommonR !== 0) {\n      foundSubsequence(nCommonR, aEnd, bEnd);\n    }\n  }\n}\n",
  "packages/diff-sequences/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\ntype IsCommon = (aIndex: number, // caller can assume: 0 <= aIndex && aIndex < aLength\nbIndex: number) => boolean;\ntype FoundSubsequence = (nCommon: number, // caller can assume: 0 < nCommon\naCommon: number, // caller can assume: 0 <= aCommon && aCommon < aLength\nbCommon: number) => void;\nexport type Callbacks = {\n    foundSubsequence: FoundSubsequence;\n    isCommon: IsCommon;\n};\nexport default function diffSequence(aLength: number, bLength: number, isCommon: IsCommon, foundSubsequence: FoundSubsequence): void;\nexport {};\n",
  "packages/diff-sequences/src/__tests__/index.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport diff from '../';\n\ndescribe('invalid arg', () => {\n  const isCommon = () => false;\n  const foundSubsequence = () => {};\n\n  describe('length', () => {\n    test('is not a number', () => {\n      expect(() => {\n        // @ts-expect-error: Testing runtime errors here\n        diff('0', 0, isCommon, foundSubsequence);\n      }).toThrow(/aLength/);\n    });\n    test('Infinity is not a safe integer', () => {\n      expect(() => {\n        diff(Number.POSITIVE_INFINITY, 0, isCommon, foundSubsequence);\n      }).toThrow(/aLength/);\n    });\n    test('Not a Number is not a safe integer', () => {\n      expect(() => {\n        diff(Number.NaN, 0, isCommon, foundSubsequence);\n      }).toThrow(/aLength/);\n    });\n\n    test('MAX_SAFE_INTEGER + 1 is not a safe integer', () => {\n      expect(() => {\n        diff(0, Number.MAX_SAFE_INTEGER + 1, isCommon, foundSubsequence);\n      }).toThrow(/bLength/);\n    });\n    test('MIN_SAFE_INTEGER - 1 is not a safe integer', () => {\n      expect(() => {\n        diff(0, Number.MIN_SAFE_INTEGER - 1, isCommon, foundSubsequence);\n      }).toThrow(/bLength/);\n    });\n    test('is a negative integer', () => {\n      expect(() => {\n        diff(0, -1, isCommon, foundSubsequence);\n      }).toThrow(/bLength/);\n    });\n  });\n\n  describe('callback', () => {\n    test('null is not a function', () => {\n      expect(() => {\n        // @ts-expect-error: Testing runtime errors here\n        diff(0, 0, null, foundSubsequence);\n      }).toThrow(/isCommon/);\n    });\n    test('undefined is not a function', () => {\n      expect(() => {\n        // @ts-expect-error: Testing runtime errors here\n        diff(0, 0, isCommon, undefined);\n      }).toThrow(/foundSubsequence/);\n    });\n  });\n});\n\n// Return length of longest common subsequence according to Object.is method.\nconst countCommonObjectIs = (a: Array<unknown>, b: Array<unknown>): number => {\n  let n = 0;\n  diff(\n    a.length,\n    b.length,\n    (aIndex: number, bIndex: number) => Object.is(a[aIndex], b[bIndex]),\n    (nCommon: number) => {\n      n += nCommon;\n    },\n  );\n  return n;\n};\n\n// Return length of longest common subsequence according to === operator.\nconst countCommonStrictEquality = (\n  a: Array<unknown>,\n  b: Array<unknown>,\n): number => {\n  let n = 0;\n  diff(\n    a.length,\n    b.length,\n    (aIndex: number, bIndex: number) => a[aIndex] === b[bIndex],\n    (nCommon: number) => {\n      n += nCommon;\n    },\n  );\n  return n;\n};\n\ndescribe('input callback encapsulates comparison', () => {\n  describe('zero and negative zero', () => {\n    const a = [0];\n    const b = [-0];\n\n    test('are not common according to Object.is method', () => {\n      expect(countCommonObjectIs(a, b)).toBe(0);\n    });\n    test('are common according to === operator', () => {\n      expect(countCommonStrictEquality(a, b)).toBe(1);\n    });\n  });\n\n  describe('Not a Number', () => {\n    // input callback encapsulates identical sequences\n    const a = [Number.NaN];\n\n    test('is common according to Object.is method', () => {\n      expect(countCommonObjectIs(a, a)).toBe(1);\n    });\n    test('is not common according to === operator', () => {\n      expect(countCommonStrictEquality(a, a)).toBe(0);\n    });\n  });\n});\n\nconst assertMin = (name: string, val: number, min: number) => {\n  if (val < min) {\n    throw new RangeError(`${name} value ${val} is less than min ${min}`);\n  }\n};\n\nconst assertMax = (name: string, val: number, max: number) => {\n  if (max < val) {\n    throw new RangeError(`${name} value ${val} is greater than max ${max}`);\n  }\n};\n\nconst assertEnd = (name: string, val: number, end: number) => {\n  if (end <= val) {\n    throw new RangeError(`${name} value ${val} is not less than end ${end}`);\n  }\n};\n\nconst assertCommonItems = (\n  a: Array<unknown> | string,\n  b: Array<unknown> | string,\n  nCommon: number,\n  aCommon: number,\n  bCommon: number,\n) => {\n  for (; nCommon !== 0; nCommon -= 1, aCommon += 1, bCommon += 1) {\n    if (a[aCommon] !== b[bCommon]) {\n      throw new Error(\n        `output item is not common for aCommon=${aCommon} and bCommon=${bCommon}`,\n      );\n    }\n  }\n};\n\n// Given lengths of sequences and input function to compare items at indexes,\n// return number of differences according to baseline greedy forward algorithm.\nconst countDifferences = (\n  aLength: number,\n  bLength: number,\n  isCommon: (aIndex: number, bIndex: number) => boolean,\n): number => {\n  const dMax = aLength + bLength;\n  const aIndexes = [-1]; // initialize for aLast + 1 in loop when d = 0\n\n  for (let d = 0; d <= dMax; d += 1) {\n    let aIndexPrev1 = 0; // that is, not yet set\n\n    for (let iF = 0, kF = -d; iF <= d; iF += 1, kF += 2) {\n      const aFirst =\n        iF === 0 || (iF !== d && aIndexPrev1 < aIndexes[iF])\n          ? aIndexes[iF] // vertical to insert from b\n          : aIndexPrev1 + 1; // horizontal to delete from a\n\n      // To get last point of path segment, move along diagonal of common items.\n      let aLast = aFirst;\n      let bLast = aFirst - kF;\n      while (\n        aLast + 1 < aLength &&\n        bLast + 1 < bLength &&\n        isCommon(aLast + 1, bLast + 1)\n      ) {\n        aLast += 1;\n        bLast += 1;\n      }\n\n      aIndexPrev1 = aIndexes[iF];\n      aIndexes[iF] = aLast;\n\n      if (aLast === aLength - 1 && bLast === bLength - 1) {\n        return d;\n      }\n    }\n  }\n  throw new Error('countDifferences did not return a number');\n};\n\n// Return array of items in a longest common subsequence of array-like objects.\nconst findCommonItems = (\n  a: Array<unknown> | string,\n  b: Array<unknown> | string,\n): Array<unknown> => {\n  const aLength = a.length;\n  const bLength = b.length;\n  const isCommon = (aIndex: number, bIndex: number) => {\n    assertMin('input aIndex', aIndex, 0);\n    assertEnd('input aIndex', aIndex, aLength);\n    assertMin('input bIndex', bIndex, 0);\n    assertEnd('input bIndex', bIndex, bLength);\n    return a[aIndex] === b[bIndex];\n  };\n\n  const array: Array<unknown> = [];\n  diff(\n    aLength,\n    bLength,\n    isCommon,\n    (nCommon: number, aCommon: number, bCommon: number) => {\n      assertMin('output nCommon', nCommon, 1);\n      assertMin('output aCommon', aCommon, 0);\n      assertMax('output aCommon + nCommon', aCommon + nCommon, aLength);\n      assertMin('output bCommon', bCommon, 0);\n      assertMax('output bCommon + nCommon', bCommon + nCommon, bLength);\n      assertCommonItems(a, b, nCommon, aCommon, bCommon);\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n\n  const nDifferences = countDifferences(aLength, bLength, isCommon);\n  expect(aLength + bLength - 2 * array.length).toBe(nDifferences);\n\n  return array;\n};\n\n// Assert that array-like objects have the expected common items.\nconst expectCommonItems = (\n  a: Array<unknown> | string,\n  b: Array<unknown> | string,\n  expected: Array<unknown>,\n) => {\n  expect(findCommonItems(a, b)).toEqual(expected);\n\n  if (a.length !== b.length) {\n    // If sequences a and b have different lengths,\n    // then if you swap sequences in your callback functions,\n    // this package finds the same items.\n    expect(findCommonItems(b, a)).toEqual(expected);\n  }\n};\n\ndescribe('input callback encapsulates sequences', () => {\n  // Example sequences in “edit graph” analogy from\n  // An O(ND) Difference Algorithm and Its Variations by Eugene W. Myers\n  const a = ['a', 'b', 'c', 'a', 'b', 'b', 'a'];\n  const b = ['c', 'b', 'a', 'b', 'a', 'c'];\n\n  // Because a and b have more than one longest common subsequence,\n  // expected value might change if implementation changes.\n  // For example, Myers paper shows: ['c', 'a', 'b', 'a']\n  const expected = ['c', 'b', 'b', 'a'];\n\n  test('arrays of strings', () => {\n    expectCommonItems(a, b, expected);\n  });\n  test('string and array of strings', () => {\n    expectCommonItems(a.join(''), b, expected);\n  });\n  test('strings', () => {\n    expectCommonItems(a.join(''), b.join(''), expected);\n  });\n});\n\ndescribe('no common items', () => {\n  // default export does not call findSubsequences nor divide\n\n  describe('negative zero is equivalent to zero for length', () => {\n    const countItemsNegativeZero = (aLength: number, bLength: number) => {\n      let n = 0;\n      diff(\n        aLength,\n        bLength,\n        () => {\n          throw new Error('input function should not have been called');\n        },\n        nCommon => {\n          n += nCommon;\n        },\n      );\n      return n;\n    };\n\n    test('of a', () => {\n      expect(countItemsNegativeZero(-0, 1)).toBe(0);\n    });\n    test('of b', () => {\n      expect(countItemsNegativeZero(1, -0)).toBe(0);\n    });\n    test('of a and b', () => {\n      expect(countItemsNegativeZero(-0, -0)).toBe(0);\n    });\n  });\n\n  test('a empty and b empty', () => {\n    const a: Array<unknown> = [];\n    const b: Array<unknown> = [];\n    const expected: Array<unknown> = [];\n    expectCommonItems(a, b, expected);\n  });\n  test('a empty and b non-empty', () => {\n    const a: Array<unknown> = [];\n    const b = [false];\n    const expected: Array<unknown> = [];\n    expectCommonItems(a, b, expected);\n  });\n  test('a non-empty and b empty', () => {\n    const a = [false, true];\n    const b: Array<unknown> = [];\n    const expected: Array<unknown> = [];\n    expectCommonItems(a, b, expected);\n  });\n\n  // default export does call findSubsequences and divide\n  describe('a non-empty and b non-empty', () => {\n    test('baDeltaLength 0 even', () => {\n      // findSubsequences not transposed because graph is square\n      // reverse path overlaps on first iteration with d === 1\n      // last segment cannot have a prev segment\n      const a = [false];\n      const b = [true];\n      const expected: Array<unknown> = [];\n      expectCommonItems(a, b, expected);\n    });\n    test('baDeltaLength 1 odd', () => {\n      // findSubsequences transposed because graph has landscape orientation\n      // forward path overlaps on first iteration with d === 2\n      // last segment has a prev segment because unroll a half iteration\n      const a = [0, 1];\n      const b = ['0'];\n      const expected: Array<unknown> = [];\n      expectCommonItems(a, b, expected);\n    });\n    test('baDeltaLength 2 even', () => {\n      // findSubsequences transposed because graph has landscape orientation\n      // reverse path overlaps with d === 3\n      // last segment has a prev segment\n      const a = [0, 1, 2, 3];\n      const b = ['0', '1'];\n      const expected: Array<unknown> = [];\n      expectCommonItems(a, b, expected);\n    });\n    test('baDeltaLength 7 odd', () => {\n      // findSubsequences not transposed because graph has portrait orientation\n      // forward path overlaps with d === 7\n      // last segment has a prev segment\n      const a = ['0', '1', '2'];\n      const b = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n      const expected: Array<unknown> = [];\n      expectCommonItems(a, b, expected);\n    });\n  });\n});\n\ndescribe('only common items', () => {\n  // input callback encapsulates identical sequences\n  // default export trims common items from the start\n  // default export does not call findSubsequences nor divide\n  test('length 1', () => {\n    const a = [false];\n    expectCommonItems(a, a, a);\n  });\n  test('length 2', () => {\n    const a = [false, true];\n    expectCommonItems(a, a, a);\n  });\n});\n\ndescribe('all common items outside', () => {\n  const common1 = 'common1';\n  const common2 = 'common2';\n  const common3 = 'common3';\n\n  // default export does not call findSubsequences nor divide\n  test('preceding changes', () => {\n    // default export trims common item from the start\n    const a = [common1];\n    const b = [common1, 'insert1', 'insert2'];\n    const expected = [common1];\n    expectCommonItems(a, b, expected);\n  });\n  test('following change', () => {\n    // default export trims common items from the end\n    const a = ['delete1', common1, common2];\n    const b = [common1, common2];\n    const expected = [common1, common2];\n    expectCommonItems(a, b, expected);\n  });\n  test('preceding and following changes in one sequence', () => {\n    // default export trims common items from the start and end\n    const a = [common1, common2, 'delete1', 'delete2', common3];\n    const b = [common1, common2, common3];\n    const expected = [common1, common2, common3];\n    expectCommonItems(a, b, expected);\n  });\n});\n\ndescribe('some common items inside and outside', () => {\n  const common1 = 'common1';\n  const common2 = 'common2';\n\n  // default export does call findSubsequences and divide\n  test('preceding changes adjacent to common in both sequences', () => {\n    // default export trims common item from the start\n    // baDeltaLength 0 even\n    // common item follows last (only) reverse segment when d === 1\n    const a = [common1, common2, 'delete1_lastR'];\n    const b = [common1, 'insert1', common2];\n    const expected = [common1, common2];\n    expectCommonItems(a, b, expected);\n  });\n  test('following changes adjacent to common in both sequences', () => {\n    // default export trims common item from the end\n    // baDeltaLength 1 odd\n    // common item follows prev (but not last) forward segment when d === 2\n    const a = [common1, 'delete1', common2];\n    const b = ['insert1_prevF', common1, 'insert2_lastF', common2];\n    const expected = [common1, common2];\n    expectCommonItems(a, b, expected);\n  });\n});\n\ndescribe('all common items inside non-recursive', () => {\n  // The index intervals preceding and following the middle change\n  // contain only changes, therefore they cannot contain any common items.\n  const common1 = 'common1';\n  const common2 = 'common2';\n  const common3 = 'common3';\n\n  test('move from start to end relative to change', () => {\n    // baDeltaLength 0 even\n    // common items follow last (only) reverse segment when d === 1\n    const a = [common1, common2, 'delete1'];\n    const b = ['insert1', common1, common2];\n    const expected = [common1, common2];\n    expectCommonItems(a, b, expected);\n  });\n  test('move from start to end relative to common', () => {\n    // baDeltaLength 0 even\n    // common items follow last (only) reverse segment when d === 1\n    const a = [common1, common2, common3];\n    const b = [common3, common1, common2];\n    // common3 is delete from a and insert from b\n    const expected = [common1, common2];\n    expectCommonItems(a, b, expected);\n  });\n  test('move from start to end relative to change and common', () => {\n    // baDeltaLength 0 even\n    // common items follow last reverse segment when d === 3\n    const a = [common1, common2, 'delete1_lastR', common3, 'delete2'];\n    const b = ['insert1', common3, 'insert2', common1, common2];\n    // common3 is delete from a and insert from b\n    const expected = [common1, common2];\n    expectCommonItems(a, b, expected);\n  });\n  test('reverse relative to change', () => {\n    // baDeltaLength 0 even\n    // common item follows last reverse segment when d === 4\n    const a = [common1, 'delete1', common2, 'delete2', common3];\n    const b = [common3, 'insert1_lastR', common2, 'insert2', common1];\n\n    // Because a and b have more than one longest common subsequence,\n    // expected value might change if implementation changes.\n    // common1 and common2 are delete from a and insert from b\n    const expected = [common3];\n    expectCommonItems(a, b, expected);\n  });\n\n  test('preceding middle', () => {\n    // baDeltaLength 1 odd\n    // common items follow prev and last forward segments when d === 3\n    const a = ['delete1', common1, common2, common3, 'delete2'];\n    const b = [\n      'insert1_prevF',\n      common1,\n      'insert2_lastF',\n      common2,\n      common3,\n      'insert3',\n    ];\n    const expected = [common1, common2, common3];\n    expectCommonItems(a, b, expected);\n  });\n  test('following middle', () => {\n    // baDeltaLength 2 even\n    // common items follow prev and last reverse segments when d === 4\n    const a = ['delete1', 'delete2', common1, common2, common3, 'delete3'];\n    const b = [\n      'insert1',\n      'insert2',\n      common1,\n      common2,\n      'insert3_lastR',\n      common3,\n      'insert4_prevR',\n      'insert5',\n    ];\n    const expected = [common1, common2, common3];\n    expectCommonItems(a, b, expected);\n  });\n});\n\ndescribe('all common items inside recursive', () => {\n  // Because a and b have only one longest common subsequence,\n  // expected value cannot change if implementation changes.\n  const common1 = 'common1';\n  const common2 = 'common2';\n  const common3 = 'common3';\n  const common4 = 'common4';\n  const common5 = 'common5';\n  const common6 = 'common6';\n\n  test('prev reverse at depth 1 and preceding at depth 2', () => {\n    // depth 1 common item follows prev reverse segment when d === 3\n    // depth 2 preceding common items follow prev and last forward segments when d === 2\n    const a = [\n      'delete1_depth2_preceding_prevF',\n      common1,\n      common2,\n      common3,\n      'delete2_depth1_prevR',\n      'delete3',\n    ];\n    const b = [\n      common1,\n      'insert1_depth2_preceding_lastF',\n      common2,\n      'insert2',\n      'insert3_depth1_lastR',\n      common3,\n    ];\n    const expected = [common1, common2, common3];\n    expectCommonItems(a, b, expected);\n  });\n  test('last forward at depth 1 and following at depth 2', () => {\n    // depth 1 common item follows last forward segment when d === 5\n    // depth 2 following common items follow prev and last reverse segments when d === 2\n    const a = [\n      'delete1',\n      'delete2',\n      common1,\n      'delete3',\n      common2,\n      'delete4_depth2_following_lastR',\n      common3,\n    ];\n    const b = [\n      'insert1',\n      'insert2',\n      'insert3_depth1_lastF',\n      common1,\n      'insert4',\n      common2,\n      common3,\n      'insert5_depth2_following_prevR',\n    ];\n    const expected = [common1, common2, common3];\n    expectCommonItems(a, b, expected);\n  });\n  test('preceding at depth 2 and both at depth 3 of following', () => {\n    // depth 1 transposed from landscape to portrait so swap args\n    // depth 1 common items do not follow prev nor last forward segment when d === 8\n    // depth 2 preceding common item follows prev forward segment when d === 4\n    // depth 2 following transposed again so unswap swapped args\n    // depth 2 following common items do not follow prev nor last forward segment when d === 4\n    // depth 3 preceding common item follows last forward segment when d === 2\n    // depth 3 following transposed again so swap args again\n    // depth 3 following common item follows last forward segment when d === 2\n    const a = [\n      'delete1_depth2_preceding_prevF',\n      common1,\n      'delete2_depth2_preceding_middle',\n      'delete3',\n      'delete4',\n      'delete5_depth1_middle',\n      common2,\n      'delete6',\n      'delete7',\n      'delete8_depth3_following_lastF',\n      common3,\n    ];\n    const b = [\n      'insert1',\n      'insert2',\n      common1,\n      'insert3',\n      'insert4',\n      'insert5_depth3_preceding_lastF',\n      common2,\n      'insert6_depth2_following_middle',\n      common3,\n      'insert7',\n    ];\n    const expected = [common1, common2, common3];\n    expectCommonItems(a, b, expected);\n  });\n\n  test('interleaved single change', () => {\n    // depth 1 common items follow prev and last forward segment when d === 4\n    // depth 2 preceding common items follow prev and last forward segment when d === 2\n    // depth 2 following common items follow prev and last forward segment when d === 2\n    const a = [common1, common2, common3, common4, common5, common6];\n    const b = [\n      'insert1_depth_2_preceding_prevF',\n      common1,\n      'insert2_depth2_preceding_lastF',\n      common2,\n      'insert3_depth1_prevF',\n      common3,\n      'insert4_depth1_lastF',\n      common4,\n      'insert5_depth2_following_prevF',\n      common5,\n      'insert6_depth2_following_lastF',\n      common6,\n      'insert7',\n    ];\n    const expected = [common1, common2, common3, common4, common5, common6];\n    expectCommonItems(a, b, expected);\n  });\n  test('interleaved double changes', () => {\n    // depth 1 common item follows prev reverse segment when d === 7\n    // depth 2 preceding transposed from landscape to portrait so swap args\n    // depth 2 preceding common item follows last forward segment when d === 4\n    // depth 3 preceding transposed again so unswap swapped args\n    // depth 3 preceding preceding common item follows last forward segment when d === 2\n    // depth 2 following common item follows prev reverse segment when d === 3\n    // depth 3 following preceding transposed\n    // depth 3 following preceding common item follows last forward segment when d === 2\n    const a = [\n      'delete1',\n      common1,\n      'delete2_depth2_preceding_lastF',\n      common2,\n      'delete3_depth3_preceding_following_lastF',\n      common3,\n      'delete4',\n      common4,\n      'delete5_depth3_following_preceding_lastF',\n      common5,\n      'delete6',\n      common6,\n      'delete7',\n    ];\n    const b = [\n      'insert1_depth3_preceding_preceding_lastF',\n      common1,\n      'insert2',\n      common2,\n      'insert3',\n      common3,\n      'insert4_depth1_middle',\n      common4,\n      'insert5_depth1_prevR',\n      common5,\n      'insert6',\n      common6,\n      'insert7_depth2_following_prevR',\n    ];\n    const expected = [common1, common2, common3, common4, common5, common6];\n    expectCommonItems(a, b, expected);\n  });\n\n  test('optimization decreases iMaxF', () => {\n    // iMaxF 3 initially because aLength\n    // iMaxF 1 at d === 4\n    // depth 1 common items do not follow prev nor last forward segment when d === 5\n    // depth 2 preceding common item follows last forward segment when d === 3\n    // depth 3 preceding preceding common item follows last (only) reverse segment when d === 1\n    const a = [common1, 'delete1_depth3_lastR', common2];\n    const b = [\n      'insert1',\n      common1,\n      'insert2_depth2_lastF',\n      common2,\n      'insert3',\n      'insert4',\n      'insert5',\n      'insert6',\n      'insert7',\n      'insert8',\n      'insert9',\n    ];\n    const expected = [common1, common2];\n    expectCommonItems(a, b, expected);\n  });\n  test('optimization decreases iMaxR', () => {\n    // iMaxF 3 initially because aLength\n    // iMaxR 0 at d === 2\n    // depth 1 common items do not follow prev nor last forward segment when d === 5\n    // depth 2 following common items follow prev reverse segment when d === 2\n    const a = [common1, common2];\n    const b = [\n      'insert1',\n      'insert2',\n      'insert3',\n      'insert4',\n      'insert5_depth1_middle',\n      'insert6',\n      'insert7',\n      'insert8_depth2_middle',\n      common1,\n      common2,\n      'insert9_depth2_prevR',\n    ];\n    const expected = [common1, common2];\n    expectCommonItems(a, b, expected);\n  });\n});\n\nconst assertCommonSubstring = (\n  a: string,\n  b: string,\n  nCommon: number,\n  aCommon: number,\n  bCommon: number,\n) => {\n  const aSubstring = a.slice(aCommon, aCommon + nCommon);\n  const bSubstring = b.slice(bCommon, bCommon + nCommon);\n  if (aSubstring !== bSubstring) {\n    throw new Error(\n      `output substrings ${aSubstring} and ${bSubstring} are not common for nCommon=${nCommon} aCommon=${aCommon} bCommon=${bCommon}`,\n    );\n  }\n};\n\n// Return array of substrings in a longest common subsequence of strings.\nconst findCommonSubstrings = (a: string, b: string): Array<string> => {\n  const array: Array<string> = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex: number, bIndex: number) => {\n      assertMin('input aIndex', aIndex, 0);\n      assertEnd('input aIndex', aIndex, a.length);\n      assertMin('input bIndex', bIndex, 0);\n      assertEnd('input bIndex', bIndex, b.length);\n      return a[aIndex] === b[bIndex];\n    },\n    (nCommon: number, aCommon: number, bCommon: number) => {\n      assertMin('output nCommon', nCommon, 1);\n      assertMin('output aCommon', aCommon, 0);\n      assertMax('output aCommon + nCommon', aCommon + nCommon, a.length);\n      assertMin('output bCommon', bCommon, 0);\n      assertMax('output bCommon + nCommon', bCommon + nCommon, b.length);\n      assertCommonSubstring(a, b, nCommon, aCommon, bCommon);\n      array.push(a.slice(aCommon, aCommon + nCommon));\n    },\n  );\n  return array;\n};\n\ndescribe('common substrings', () => {\n  // Find changed and unchanged substrings within adjacent changed lines\n  // in expected and received values after a test fails in Jest.\n  test('progress', () => {\n    // Confirm expected progress. If change is correct, then update test.\n    // A property value changes from an object to an array of objects.\n    // prettier-ignore\n    const a = [\n      '\"sorting\": Object {',\n      '\"ascending\": true,',\n    ].join('\\n');\n    // prettier-ignore\n    const b = [\n      '\"sorting\": Array [',\n      'Object {',\n      '\"descending\": false,',\n    ].join('\\n');\n    const expected = ['\"sorting\": ', 'Object {\\n\"', 'scending\": ', 'e,'];\n    const abCommonSubstrings = findCommonSubstrings(a, b);\n    const baCommonSubstrings = findCommonSubstrings(b, a);\n    expect(abCommonSubstrings).toEqual(baCommonSubstrings);\n    expect(abCommonSubstrings).toEqual(expected);\n  });\n  test('regression', () => {\n    // Prevent unexpected regression. If change is incorrect, then fix code.\n    // Internationalization fails for a text node.\n    // English translation and French quotation by Antoine de Saint Exupéry:\n    const a =\n      'It seems that perfection is attained not when there is nothing more to add, but when there is nothing more to remove.';\n    const b =\n      \"Il semble que la perfection soit atteinte non quand il n'y a plus rien à ajouter, mais quand il n'y a plus rien à retrancher.\";\n    const abCommonSubstrings = findCommonSubstrings(a, b);\n    const baCommonSubstrings = findCommonSubstrings(b, a);\n    expect(abCommonSubstrings).toEqual(baCommonSubstrings);\n    expect(abCommonSubstrings).toMatchSnapshot();\n  });\n  test('wrapping', () => {\n    const a = [\n      'When engineers are provided with ready-to-use tools, they end up writing more',\n      'tests, which in turn results in more stable code bases.',\n    ].join('\\n');\n    const b = [\n      'When engineers have ready-to-use tools, they write more tests, which results in',\n      'more stable and healthy code bases.',\n    ].join('\\n');\n    const abCommonSubstrings = findCommonSubstrings(a, b);\n    const baCommonSubstrings = findCommonSubstrings(b, a);\n    expect(abCommonSubstrings).toEqual(baCommonSubstrings);\n    expect(abCommonSubstrings).toMatchSnapshot();\n  });\n});\n",
  "packages/diff-sequences/src/__tests__/index.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport {};\n",
  "packages/diff-sequences/src/__tests__/index.property.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {fc, it} from '@fast-check/jest';\nimport diff from '../';\n\nconst char = () =>\n  fc.string({maxLength: 1, minLength: 1, unit: 'grapheme-ascii'});\n\nconst findCommonItems = (a: Array<string>, b: Array<string>): Array<string> => {\n  const array: Array<string> = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex: number, bIndex: number) => a[aIndex] === b[bIndex],\n    (nCommon: number, aCommon: number) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst extractCount = (data: Array<string>): Map<string, number> => {\n  const countPerChar = new Map<string, number>();\n  for (const item of data) {\n    const currentCount = countPerChar.get(item) ?? 0;\n    countPerChar.set(item, currentCount + 1);\n  }\n  return countPerChar;\n};\n\nconst flatten = (data: Array<Array<string>>) => {\n  const array: Array<string> = [];\n  for (const items of data) {\n    array.push(...items);\n  }\n  return array;\n};\n\nconst isSubsequenceOf = (\n  subsequence: Array<string>,\n  sequence: Array<string>,\n): boolean => {\n  let iSub = 0;\n  for (let iSeq = 0; iSeq !== sequence.length; iSeq += 1) {\n    if (iSub !== subsequence.length && subsequence[iSub] === sequence[iSeq]) {\n      iSub += 1;\n    }\n  }\n\n  return iSub === subsequence.length;\n};\n\nit.prop([fc.array(char())])('should be reflexive', a => {\n  expect(findCommonItems(a, a)).toEqual(a);\n});\n\nit.prop([fc.array(char()), fc.array(char())])(\n  'should find the same number of common items when switching the inputs',\n  // findCommonItems is not symmetric as:\n  // > findCommonItems([\"Z\",\" \"], [\" \",\"Z\"]) = [\" \"]\n  // > findCommonItems([\" \",\"Z\"], [\"Z\",\" \"]) = [\"Z\"]\n  (a, b) => {\n    const commonItems = findCommonItems(a, b);\n    const symmetricCommonItems = findCommonItems(b, a);\n    expect(symmetricCommonItems).toHaveLength(commonItems.length);\n  },\n);\n\nit.prop([fc.array(char()), fc.array(char())])(\n  'should have at most the length of its inputs',\n  (a, b) => {\n    const commonItems = findCommonItems(a, b);\n    expect(commonItems.length).toBeLessThanOrEqual(a.length);\n    expect(commonItems.length).toBeLessThanOrEqual(b.length);\n  },\n);\n\nit.prop([fc.array(char()), fc.array(char())])(\n  'should have at most the same number of each character as its inputs',\n  (a, b) => {\n    const commonItems = findCommonItems(a, b);\n    const commonCount = extractCount(commonItems);\n    const aCount = extractCount(a);\n    for (const [item, count] of commonCount) {\n      const countOfItemInA = aCount.get(item) ?? 0;\n      expect(countOfItemInA).toBeGreaterThanOrEqual(count);\n    }\n  },\n);\n\nit.prop([fc.array(char()), fc.array(char())])(\n  'should be a subsequence of its inputs',\n  (a, b) => {\n    const commonItems = findCommonItems(a, b);\n    expect(isSubsequenceOf(commonItems, a)).toBe(true);\n    expect(isSubsequenceOf(commonItems, b)).toBe(true);\n  },\n);\n\nit.prop([fc.array(char()), fc.array(char())])(\n  'should be no-op when passing common items',\n  (a, b) => {\n    const commonItems = findCommonItems(a, b);\n    expect(findCommonItems(a, commonItems)).toEqual(commonItems);\n    expect(findCommonItems(commonItems, a)).toEqual(commonItems);\n  },\n);\n\nit.prop([fc.array(fc.array(char()))])(\n  'should find the exact common items when one array is subarray of the other',\n  data => {\n    const allData = flatten(data); // [...data[0], ...data[1], ...data[2], ...data[3], ...]\n    const partialData = flatten(data.filter((_, i) => i % 2 === 1)); // [...data[1], ...data[3], ...]\n    const commonItems = findCommonItems(allData, partialData);\n    // We have:\n    // 1. commonItems contains at least all the items of partialData as they are in allData too\n    // 2. commonItems cannot contain more items than its inputs (partialData for instance)\n    expect(commonItems.length).toBeGreaterThanOrEqual(partialData.length);\n  },\n);\n",
  "packages/diff-sequences/src/__tests__/index.property.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport {};\n",
  "packages/create-jest/src/types.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {Config} from '@jest/types';\n\nexport type ProjectPackageJson = {\n  jest?: Partial<Config.InitialOptions>;\n  scripts?: Record<string, string>;\n  type?: 'commonjs' | 'module';\n};\n\nexport type PromptsResults = {\n  useTypescript: boolean;\n  clearMocks: boolean;\n  coverage: boolean;\n  coverageProvider: string;\n  environment: string;\n  scripts: boolean;\n};\n",
  "packages/create-jest/src/types.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { Config } from '@jest/types';\nexport type ProjectPackageJson = {\n    jest?: Partial<Config.InitialOptions>;\n    scripts?: Record<string, string>;\n    type?: 'commonjs' | 'module';\n};\nexport type PromptsResults = {\n    useTypescript: boolean;\n    clearMocks: boolean;\n    coverage: boolean;\n    coverageProvider: string;\n    environment: string;\n    scripts: boolean;\n};\n",
  "packages/create-jest/src/runCreate.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport chalk from 'chalk';\nimport exit from 'exit-x';\nimport * as fs from 'graceful-fs';\nimport prompts from 'prompts';\nimport {constants} from 'jest-config';\nimport {clearLine, tryRealpath} from 'jest-util';\nimport {MalformedPackageJsonError, NotFoundPackageJsonError} from './errors';\nimport generateConfigFile from './generateConfigFile';\nimport modifyPackageJson from './modifyPackageJson';\nimport defaultQuestions, {testScriptQuestion} from './questions';\nimport type {ProjectPackageJson, PromptsResults} from './types';\n\nconst {\n  JEST_CONFIG_BASE_NAME,\n  JEST_CONFIG_EXT_MJS,\n  JEST_CONFIG_EXT_JS,\n  JEST_CONFIG_EXT_TS,\n  JEST_CONFIG_EXT_ORDER,\n  PACKAGE_JSON,\n} = constants;\n\nconst getConfigFilename = (ext: string) => JEST_CONFIG_BASE_NAME + ext;\n\nexport async function runCLI(): Promise<void> {\n  try {\n    const rootDir = process.argv[2];\n    await runCreate(rootDir);\n  } catch (error: unknown) {\n    clearLine(process.stderr);\n    clearLine(process.stdout);\n    if (error instanceof Error && Boolean(error?.stack)) {\n      console.error(chalk.red(error.stack));\n    } else {\n      console.error(chalk.red(error));\n    }\n\n    exit(1);\n    throw error;\n  }\n}\n\nexport async function runCreate(rootDir = process.cwd()): Promise<void> {\n  rootDir = tryRealpath(rootDir);\n  // prerequisite checks\n  const projectPackageJsonPath = path.join(rootDir, PACKAGE_JSON);\n\n  if (!fs.existsSync(projectPackageJsonPath)) {\n    throw new NotFoundPackageJsonError(rootDir);\n  }\n\n  const questions = [...defaultQuestions];\n  let hasJestProperty = false;\n  let projectPackageJson: ProjectPackageJson;\n\n  try {\n    projectPackageJson = JSON.parse(\n      fs.readFileSync(projectPackageJsonPath, 'utf8'),\n    ) as ProjectPackageJson;\n  } catch {\n    throw new MalformedPackageJsonError(projectPackageJsonPath);\n  }\n\n  if (projectPackageJson.jest) {\n    hasJestProperty = true;\n  }\n\n  const existingJestConfigExt = JEST_CONFIG_EXT_ORDER.find(ext =>\n    fs.existsSync(path.join(rootDir, getConfigFilename(ext))),\n  );\n\n  if (hasJestProperty || existingJestConfigExt != null) {\n    const result: {continue: boolean} = await prompts({\n      initial: true,\n      message:\n        'It seems that you already have a jest configuration, do you want to override it?',\n      name: 'continue',\n      type: 'confirm',\n    });\n\n    if (!result.continue) {\n      console.log();\n      console.log('Aborting...');\n      return;\n    }\n  }\n\n  // Add test script installation only if needed\n  if (\n    !projectPackageJson.scripts ||\n    projectPackageJson.scripts.test !== 'jest'\n  ) {\n    questions.unshift(testScriptQuestion);\n  }\n\n  // Start the init process\n  console.log();\n  console.log(\n    chalk.underline(\n      'The following questions will help Jest to create a suitable configuration for your project\\n',\n    ),\n  );\n\n  let promptAborted = false;\n\n  const results = (await prompts(questions, {\n    onCancel: () => {\n      promptAborted = true;\n    },\n  })) as PromptsResults;\n\n  if (promptAborted) {\n    console.log();\n    console.log('Aborting...');\n    return;\n  }\n\n  // Determine if Jest should use JS or TS for the config file\n  const jestConfigFileExt = results.useTypescript\n    ? JEST_CONFIG_EXT_TS\n    : projectPackageJson.type === 'module'\n      ? JEST_CONFIG_EXT_MJS\n      : JEST_CONFIG_EXT_JS;\n\n  // Determine Jest config path\n  const jestConfigPath =\n    existingJestConfigExt == null\n      ? path.join(rootDir, getConfigFilename(jestConfigFileExt))\n      : getConfigFilename(existingJestConfigExt);\n\n  const shouldModifyScripts = results.scripts;\n\n  if (shouldModifyScripts || hasJestProperty) {\n    const modifiedPackageJson = modifyPackageJson({\n      projectPackageJson,\n      shouldModifyScripts,\n    });\n\n    fs.writeFileSync(projectPackageJsonPath, modifiedPackageJson);\n\n    console.log('');\n    console.log(`✏️  Modified ${chalk.cyan(projectPackageJsonPath)}`);\n  }\n\n  const generatedConfig = generateConfigFile(\n    results,\n    projectPackageJson.type === 'module' ||\n      jestConfigPath.endsWith(JEST_CONFIG_EXT_MJS),\n  );\n\n  fs.writeFileSync(jestConfigPath, generatedConfig);\n\n  console.log('');\n  console.log(\n    `📝  Configuration file created at ${chalk.cyan(jestConfigPath)}`,\n  );\n}\n",
  "packages/create-jest/src/runCreate.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport declare function runCLI(): Promise<void>;\nexport declare function runCreate(rootDir?: string): Promise<void>;\n",
  "packages/create-jest/src/questions.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {PromptObject} from 'prompts';\n\nconst defaultQuestions: Array<PromptObject> = [\n  {\n    initial: false,\n    message: 'Would you like to use Typescript for the configuration file?',\n    name: 'useTypescript',\n    type: 'confirm',\n  },\n  {\n    choices: [\n      {title: 'node', value: 'node'},\n      {title: 'jsdom (browser-like)', value: 'jsdom'},\n    ],\n    initial: 0,\n    message: 'Choose the test environment that will be used for testing',\n    name: 'environment',\n    type: 'select',\n  },\n  {\n    initial: false,\n    message: 'Do you want Jest to add coverage reports?',\n    name: 'coverage',\n    type: 'confirm',\n  },\n  {\n    choices: [\n      {title: 'v8', value: 'v8'},\n      {title: 'babel', value: 'babel'},\n    ],\n    initial: 0,\n    message: 'Which provider should be used to instrument code for coverage?',\n    name: 'coverageProvider',\n    type: 'select',\n  },\n  {\n    initial: false,\n    message:\n      'Automatically clear mock calls, instances, contexts and results before every test?',\n    name: 'clearMocks',\n    type: 'confirm',\n  },\n];\n\nexport default defaultQuestions;\n\nexport const testScriptQuestion: PromptObject = {\n  initial: true,\n  message:\n    'Would you like to use Jest when running \"test\" script in \"package.json\"?',\n  name: 'scripts',\n  type: 'confirm',\n};\n",
  "packages/create-jest/src/questions.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { PromptObject } from 'prompts';\ndeclare const defaultQuestions: Array<PromptObject>;\nexport default defaultQuestions;\nexport declare const testScriptQuestion: PromptObject;\n",
  "packages/create-jest/src/modifyPackageJson.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {ProjectPackageJson} from './types';\n\nconst modifyPackageJson = ({\n  projectPackageJson,\n  shouldModifyScripts,\n}: {\n  projectPackageJson: ProjectPackageJson;\n  shouldModifyScripts: boolean;\n}): string => {\n  if (shouldModifyScripts) {\n    if (projectPackageJson.scripts) {\n      projectPackageJson.scripts.test = 'jest';\n    } else {\n      projectPackageJson.scripts = {test: 'jest'};\n    }\n  }\n\n  delete projectPackageJson.jest;\n\n  return `${JSON.stringify(projectPackageJson, null, 2)}\\n`;\n};\n\nexport default modifyPackageJson;\n",
  "packages/create-jest/src/modifyPackageJson.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { ProjectPackageJson } from './types';\ndeclare const modifyPackageJson: ({ projectPackageJson, shouldModifyScripts, }: {\n    projectPackageJson: ProjectPackageJson;\n    shouldModifyScripts: boolean;\n}) => string;\nexport default modifyPackageJson;\n",
  "packages/create-jest/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nexport {runCreate, runCLI} from './runCreate';\n",
  "packages/create-jest/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport { runCreate, runCLI } from './runCreate';\n",
  "packages/create-jest/src/generateConfigFile.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {Config} from '@jest/types';\nimport {defaults, descriptions} from 'jest-config';\nimport type {PromptsResults} from './types';\n\nconst stringifyOption = (\n  option: keyof Config.InitialOptions,\n  map: Partial<Config.InitialOptions>,\n  linePrefix = '',\n): string => {\n  const description = descriptions[option];\n  const optionDescription =\n    description != null && description.length > 0 ? `  // ${description}` : '';\n  const stringifiedObject = `${option}: ${JSON.stringify(\n    map[option],\n    null,\n    2,\n  )}`;\n\n  return `${optionDescription}\\n${stringifiedObject\n    .split('\\n')\n    .map(line => `  ${linePrefix}${line}`)\n    .join('\\n')},`;\n};\n\nconst generateConfigFile = (\n  results: PromptsResults,\n  generateEsm = false,\n): string => {\n  const {useTypescript, coverage, coverageProvider, clearMocks, environment} =\n    results;\n\n  const overrides: Record<string, unknown> = {};\n\n  if (coverage) {\n    Object.assign(overrides, {\n      collectCoverage: true,\n      coverageDirectory: 'coverage',\n    });\n  }\n\n  if (coverageProvider === 'v8') {\n    Object.assign(overrides, {\n      coverageProvider: 'v8',\n    });\n  }\n\n  if (environment === 'jsdom') {\n    Object.assign(overrides, {\n      testEnvironment: 'jsdom',\n    });\n  }\n\n  if (clearMocks) {\n    Object.assign(overrides, {\n      clearMocks: true,\n    });\n  }\n\n  const overrideKeys = Object.keys(overrides) as Array<\n    keyof Config.InitialOptions\n  >;\n\n  const properties: Array<string> = [];\n\n  for (const option in descriptions) {\n    const opt = option as keyof typeof descriptions;\n\n    if (overrideKeys.includes(opt)) {\n      properties.push(stringifyOption(opt, overrides));\n    } else {\n      properties.push(\n        stringifyOption(opt, defaults as Config.InitialOptions, '// '),\n      );\n    }\n  }\n\n  const configHeaderMessage = `/**\n * For a detailed explanation regarding each configuration property, visit:\n * https://jestjs.io/docs/configuration\n */\n`;\n\n  const jsDeclaration = `/** @type {import('jest').Config} */\nconst config = {`;\n\n  const tsDeclaration = `import type {Config} from 'jest';\n\nconst config: Config = {`;\n\n  const cjsExport = 'module.exports = config;';\n  const esmExport = 'export default config;';\n\n  return [\n    configHeaderMessage,\n    useTypescript ? tsDeclaration : jsDeclaration,\n    properties.join('\\n\\n'),\n    '};\\n',\n    useTypescript || generateEsm ? esmExport : cjsExport,\n    '',\n  ].join('\\n');\n};\n\nexport default generateConfigFile;\n",
  "packages/create-jest/src/generateConfigFile.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { PromptsResults } from './types';\ndeclare const generateConfigFile: (results: PromptsResults, generateEsm?: boolean) => string;\nexport default generateConfigFile;\n",
  "packages/create-jest/src/errors.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nexport class NotFoundPackageJsonError extends Error {\n  constructor(rootDir: string) {\n    super(`Could not find a \"package.json\" file in ${rootDir}`);\n    this.name = '';\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    Error.captureStackTrace(this, () => {});\n  }\n}\n\nexport class MalformedPackageJsonError extends Error {\n  constructor(packageJsonPath: string) {\n    super(`There is malformed json in ${packageJsonPath}`);\n    this.name = '';\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    Error.captureStackTrace(this, () => {});\n  }\n}\n",
  "packages/create-jest/src/errors.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport declare class NotFoundPackageJsonError extends Error {\n    constructor(rootDir: string);\n}\nexport declare class MalformedPackageJsonError extends Error {\n    constructor(packageJsonPath: string);\n}\n",
  "packages/create-jest/src/__tests__/modifyPackageJson.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport modifyPackageJson from '../modifyPackageJson';\n\ntest('should remove jest config if exists', () => {\n  expect(\n    modifyPackageJson({\n      projectPackageJson: {\n        jest: {\n          collectCoverage: true,\n        },\n      },\n      shouldModifyScripts: true,\n    }),\n  ).toMatchSnapshot();\n});\n\ntest('should add test script when there are no scripts', () => {\n  expect(\n    modifyPackageJson({\n      projectPackageJson: {},\n      shouldModifyScripts: true,\n    }),\n  ).toMatchSnapshot();\n});\n\ntest('should add test script when there are scripts', () => {\n  expect(\n    modifyPackageJson({\n      projectPackageJson: {\n        scripts: {\n          lint: 'eslint .',\n          test: 'jasmine',\n        },\n      },\n      shouldModifyScripts: true,\n    }),\n  ).toMatchSnapshot();\n});\n\ntest('should not add test script when { shouldModifyScripts: false }', () => {\n  expect(\n    modifyPackageJson({\n      projectPackageJson: {},\n      shouldModifyScripts: false,\n    }),\n  ).toMatchSnapshot();\n});\n",
  "packages/create-jest/src/__tests__/modifyPackageJson.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/create-jest/src/__tests__/init.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/* eslint-disable no-eval */\nimport * as path from 'path';\nimport {writeFileSync} from 'graceful-fs';\nimport * as prompts from 'prompts';\nimport {constants} from 'jest-config';\nimport {runCreate} from '../runCreate';\n\nconst {JEST_CONFIG_EXT_ORDER} = constants;\n\njest.mock('prompts');\njest.mock('path', () => ({\n  ...jest.requireActual<typeof import('path')>('path'),\n  sep: '/',\n}));\njest.mock('graceful-fs', () => ({\n  ...jest.requireActual<typeof import('graceful-fs')>('graceful-fs'),\n  writeFileSync: jest.fn(),\n}));\n\nconst resolveFromFixture = (relativePath: string) =>\n  path.resolve(__dirname, '__fixtures__', relativePath);\n\nconst consoleLog = console.log;\n\ndescribe('init', () => {\n  beforeEach(() => {\n    console.log = jest.fn();\n  });\n\n  afterEach(() => {\n    jest.clearAllMocks();\n    console.log = consoleLog;\n  });\n\n  describe('project with package.json and no jest config', () => {\n    describe('all questions answered with answer: \"No\"', () => {\n      it('should return the default configuration (an empty config)', async () => {\n        jest.mocked(prompts).mockResolvedValueOnce({});\n\n        await runCreate(resolveFromFixture('only-package-json'));\n\n        const writtenJestConfigFilename =\n          jest.mocked(writeFileSync).mock.calls[0][0];\n        const writtenJestConfig = jest.mocked(writeFileSync).mock.calls[0][1];\n\n        expect(path.basename(writtenJestConfigFilename as string)).toBe(\n          'jest.config.js',\n        );\n        expect(\n          (writtenJestConfig as string).replace(\n            /\\/\\/ cacheDirectory: .*,/,\n            '// cacheDirectory: \"/tmp/jest\",',\n          ),\n        ).toMatchSnapshot();\n\n        const evaluatedConfig = eval(writtenJestConfig as string) as Record<\n          string,\n          unknown\n        >;\n\n        expect(evaluatedConfig).toEqual({});\n      });\n\n      it('should generate empty config with mjs extension', async () => {\n        jest.mocked(prompts).mockResolvedValueOnce({});\n\n        await runCreate(resolveFromFixture('type-module'));\n\n        const writtenJestConfigFilename =\n          jest.mocked(writeFileSync).mock.calls[0][0];\n        const writtenJestConfig = jest.mocked(writeFileSync).mock.calls[0][1];\n\n        expect(path.basename(writtenJestConfigFilename as string)).toBe(\n          'jest.config.mjs',\n        );\n        expect(\n          (writtenJestConfig as string).replace(\n            /\\/\\/ cacheDirectory: .*,/,\n            '// cacheDirectory: \"/tmp/jest\",',\n          ),\n        ).toMatchSnapshot();\n      });\n    });\n\n    describe('some questions answered with answer: \"Yes\"', () => {\n      it('should create configuration for {clearMocks: true}', async () => {\n        jest.mocked(prompts).mockResolvedValueOnce({clearMocks: true});\n\n        await runCreate(resolveFromFixture('only-package-json'));\n\n        const writtenJestConfig = jest.mocked(writeFileSync).mock.calls[0][1];\n        const evaluatedConfig = eval(writtenJestConfig as string) as Record<\n          string,\n          unknown\n        >;\n\n        expect(evaluatedConfig).toEqual({clearMocks: true});\n      });\n\n      it('should create configuration for {coverage: true}', async () => {\n        jest.mocked(prompts).mockResolvedValueOnce({coverage: true});\n\n        await runCreate(resolveFromFixture('only-package-json'));\n\n        const writtenJestConfig = jest.mocked(writeFileSync).mock.calls[0][1];\n        const evaluatedConfig = eval(writtenJestConfig as string) as Record<\n          string,\n          unknown\n        >;\n\n        expect(evaluatedConfig).toEqual({\n          collectCoverage: true,\n          coverageDirectory: 'coverage',\n        });\n      });\n\n      it('should create configuration for {coverageProvider: \"babel\"}', async () => {\n        jest.mocked(prompts).mockResolvedValueOnce({coverageProvider: 'babel'});\n\n        await runCreate(resolveFromFixture('only-package-json'));\n\n        const writtenJestConfig = jest.mocked(writeFileSync).mock.calls[0][1];\n        const evaluatedConfig = eval(writtenJestConfig as string) as Record<\n          string,\n          unknown\n        >;\n        // should modify when the default coverageProvider will be changed to \"v8\"\n        expect(evaluatedConfig).toEqual({});\n      });\n\n      it('should create configuration for {coverageProvider: \"v8\"}', async () => {\n        jest.mocked(prompts).mockResolvedValueOnce({coverageProvider: 'v8'});\n\n        await runCreate(resolveFromFixture('only-package-json'));\n\n        const writtenJestConfig = jest.mocked(writeFileSync).mock.calls[0][1];\n        const evaluatedConfig = eval(writtenJestConfig as string) as Record<\n          string,\n          unknown\n        >;\n        // should modify when the default coverageProvider will be changed to \"v8\"\n        expect(evaluatedConfig).toEqual({coverageProvider: 'v8'});\n      });\n\n      it('should create configuration for {environment: \"jsdom\"}', async () => {\n        jest.mocked(prompts).mockResolvedValueOnce({environment: 'jsdom'});\n\n        await runCreate(resolveFromFixture('only-package-json'));\n\n        const writtenJestConfig = jest.mocked(writeFileSync).mock.calls[0][1];\n        const evaluatedConfig = eval(writtenJestConfig as string) as Record<\n          string,\n          unknown\n        >;\n        expect(evaluatedConfig).toEqual({testEnvironment: 'jsdom'});\n      });\n\n      it('should create configuration for {environment: \"node\"}', async () => {\n        jest.mocked(prompts).mockResolvedValueOnce({environment: 'node'});\n\n        await runCreate(resolveFromFixture('only-package-json'));\n\n        const writtenJestConfig = jest.mocked(writeFileSync).mock.calls[0][1];\n        const evaluatedConfig = eval(writtenJestConfig as string) as Record<\n          string,\n          unknown\n        >;\n        expect(evaluatedConfig).toEqual({});\n      });\n\n      it('should create package.json with configured test command when {scripts: true}', async () => {\n        jest.mocked(prompts).mockResolvedValueOnce({scripts: true});\n\n        await runCreate(resolveFromFixture('only-package-json'));\n\n        const writtenPackageJson = jest.mocked(writeFileSync).mock.calls[0][1];\n        const parsedPackageJson = JSON.parse(writtenPackageJson as string) as {\n          scripts: {test: string};\n        };\n\n        expect(writtenPackageJson).toMatchSnapshot();\n        expect(parsedPackageJson.scripts.test).toBe('jest');\n      });\n    });\n  });\n\n  describe('no package json', () => {\n    it('should throw an error if there is no package.json file', async () => {\n      expect.assertions(1);\n\n      try {\n        await runCreate(resolveFromFixture('no-package-json'));\n      } catch (error) {\n        expect((error as Error).message).toMatch(\n          'Could not find a \"package.json\" file in',\n        );\n      }\n    });\n  });\n\n  describe.each(JEST_CONFIG_EXT_ORDER.map(e => e.slice(1)))(\n    'has-jest-config-file-%s',\n    extension => {\n      describe('ask the user whether to override config or not', () => {\n        it('user answered with \"Yes\"', async () => {\n          jest\n            .mocked(prompts)\n            .mockResolvedValueOnce({continue: true})\n            .mockResolvedValueOnce({});\n\n          await runCreate(\n            resolveFromFixture(`has-jest-config-file-${extension}`),\n          );\n\n          expect(jest.mocked(prompts).mock.calls[0][0]).toMatchSnapshot();\n\n          const jestConfigFileName =\n            jest.mocked(writeFileSync).mock.calls[0][0];\n          const writtenJestConfig = jest.mocked(writeFileSync).mock.calls[0][1];\n\n          expect(jestConfigFileName).toBe(`jest.config.${extension}`);\n          expect(writtenJestConfig).toBeDefined();\n        });\n\n        it('user answered with \"No\"', async () => {\n          jest.mocked(prompts).mockResolvedValueOnce({continue: false});\n\n          await runCreate(\n            resolveFromFixture(`has-jest-config-file-${extension}`),\n          );\n          // return after first prompt\n          expect(prompts).toHaveBeenCalledTimes(1);\n        });\n      });\n    },\n  );\n\n  describe('project using jest.config.ts', () => {\n    describe('ask the user whether he wants to use Typescript or not', () => {\n      it('user answered with \"Yes\"', async () => {\n        jest.mocked(prompts).mockResolvedValueOnce({useTypescript: true});\n\n        await runCreate(resolveFromFixture('test-generated-jest-config-ts'));\n\n        expect(jest.mocked(prompts).mock.calls[0][0]).toMatchSnapshot();\n\n        const jestConfigFileName = jest.mocked(writeFileSync).mock.calls[0][0];\n        const writtenJestConfig = jest.mocked(writeFileSync).mock.calls[0][1];\n\n        expect(path.basename(jestConfigFileName as string)).toBe(\n          'jest.config.ts',\n        );\n        expect(\n          (writtenJestConfig as string).replace(\n            /\\/\\/ cacheDirectory: .*,/,\n            '// cacheDirectory: \"/tmp/jest\",',\n          ),\n        ).toMatchSnapshot();\n      });\n\n      it('user answered with \"No\"', async () => {\n        jest.mocked(prompts).mockResolvedValueOnce({useTypescript: false});\n\n        await runCreate(resolveFromFixture('test-generated-jest-config-ts'));\n\n        const jestConfigFileName = jest.mocked(writeFileSync).mock.calls[0][0];\n\n        expect(path.basename(jestConfigFileName as string)).not.toBe(\n          'jest.config.ts',\n        );\n      });\n    });\n  });\n\n  describe('has jest config in package.json', () => {\n    it('should ask the user whether to override config or not', async () => {\n      jest\n        .mocked(prompts)\n        .mockResolvedValueOnce({continue: true})\n        .mockResolvedValueOnce({});\n\n      await runCreate(resolveFromFixture('has-jest-config-in-package-json'));\n\n      expect(jest.mocked(prompts).mock.calls[0][0]).toMatchSnapshot();\n\n      const writtenJestConfig = jest.mocked(writeFileSync).mock.calls[0][1];\n\n      expect(writtenJestConfig).toBeDefined();\n    });\n  });\n\n  describe('already has \"jest\" in packageJson.scripts.test', () => {\n    it('should not ask \"test script question\"', async () => {\n      jest.mocked(prompts).mockResolvedValueOnce({});\n\n      await runCreate(resolveFromFixture('test-script-configured'));\n\n      const questions = jest.mocked(prompts).mock.calls[0][0] as Array<\n        prompts.PromptObject<string>\n      >;\n      const questionsNames = questions.map(question => question.name);\n\n      expect(questionsNames).not.toContain('scripts');\n    });\n  });\n});\n",
  "packages/create-jest/src/__tests__/init.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/create-jest/src/__tests__/__fixtures__/has-jest-config-file-ts/jest.config.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nexport default {};\n",
  "packages/create-jest/src/__tests__/__fixtures__/has-jest-config-file-ts/jest.config.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\ndeclare const _default: {};\nexport default _default;\n",
  "packages/babel-plugin-jest-hoist/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {PluginObj} from '@babel/core';\nimport {statement} from '@babel/template';\nimport type {NodePath} from '@babel/traverse';\nimport {\n  type CallExpression,\n  type Expression,\n  type Identifier,\n  type ImportDeclaration,\n  type MemberExpression,\n  type Node,\n  type Statement,\n  type Super,\n  type VariableDeclaration,\n  type VariableDeclarator,\n  callExpression,\n  isIdentifier,\n  variableDeclaration,\n} from '@babel/types';\n\nconst JEST_GLOBAL_NAME = 'jest';\nconst JEST_GLOBALS_MODULE_NAME = '@jest/globals';\nconst JEST_GLOBALS_MODULE_JEST_EXPORT_NAME = 'jest';\n\nconst hoistedVariables = new WeakSet<VariableDeclarator>();\nconst hoistedJestGetters = new WeakSet<CallExpression>();\nconst hoistedJestExpressions = new WeakSet<Expression>();\n\n// We allow `jest`, `expect`, `require`, all default Node.js globals and all\n// ES2015 built-ins to be used inside of a `jest.mock` factory.\n// We also allow variables prefixed with `mock` as an escape-hatch.\nconst ALLOWED_IDENTIFIERS = new Set<string>(\n  [\n    'Array',\n    'ArrayBuffer',\n    'Boolean',\n    'BigInt',\n    'DataView',\n    'Date',\n    'Error',\n    'EvalError',\n    'Float32Array',\n    'Float64Array',\n    'Function',\n    'Generator',\n    'GeneratorFunction',\n    'Infinity',\n    'Int16Array',\n    'Int32Array',\n    'Int8Array',\n    'InternalError',\n    'Intl',\n    'JSON',\n    'Map',\n    'Math',\n    'NaN',\n    'Number',\n    'Object',\n    'Promise',\n    'Proxy',\n    'RangeError',\n    'ReferenceError',\n    'Reflect',\n    'RegExp',\n    'Set',\n    'String',\n    'Symbol',\n    'SyntaxError',\n    'TypeError',\n    'URIError',\n    'Uint16Array',\n    'Uint32Array',\n    'Uint8Array',\n    'Uint8ClampedArray',\n    'WeakMap',\n    'WeakSet',\n    'arguments',\n    'console',\n    'expect',\n    'isNaN',\n    'jest',\n    'parseFloat',\n    'parseInt',\n    'exports',\n    'require',\n    'module',\n    '__filename',\n    '__dirname',\n    'undefined',\n    ...Object.getOwnPropertyNames(globalThis),\n  ].sort(),\n);\n\nconst IDVisitor = {\n  ReferencedIdentifier(\n    path: NodePath<Identifier>,\n    {ids}: {ids: Set<NodePath<Identifier>>},\n  ) {\n    ids.add(path);\n  },\n  denylist: [\n    'TypeAnnotation',\n    'TSTypeAnnotation',\n    'TSTypeQuery',\n    'TSTypeReference',\n  ],\n};\n\nconst FUNCTIONS = Object.create(null) as Record<\n  string,\n  <T extends Node>(args: Array<NodePath<T>>) => boolean\n>;\n\nFUNCTIONS.mock = args => {\n  if (args.length === 1) {\n    return args[0].isStringLiteral() || args[0].isLiteral();\n  } else if (args.length === 2 || args.length === 3) {\n    const moduleFactory = args[1];\n\n    if (!moduleFactory.isFunction()) {\n      throw moduleFactory.buildCodeFrameError(\n        'The second argument of `jest.mock` must be an inline function.\\n',\n        TypeError,\n      );\n    }\n\n    const ids = new Set<NodePath<Identifier>>();\n    const parentScope = moduleFactory.parentPath.scope;\n    // @ts-expect-error: ReferencedIdentifier and denylist are not known on visitors\n    moduleFactory.traverse(IDVisitor, {ids});\n    for (const id of ids) {\n      const {name} = id.node;\n      let found = false;\n      let scope = id.scope;\n\n      while (scope !== parentScope) {\n        if (scope.bindings[name] != null) {\n          found = true;\n          break;\n        }\n\n        scope = scope.parent;\n      }\n\n      if (!found) {\n        let isAllowedIdentifier =\n          (scope.hasGlobal(name) && ALLOWED_IDENTIFIERS.has(name)) ||\n          /^mock/i.test(name) ||\n          // Allow istanbul's coverage variable to pass.\n          /^(?:__)?cov/.test(name);\n\n        if (!isAllowedIdentifier) {\n          const binding = scope.bindings[name];\n\n          if (binding?.path.isVariableDeclarator()) {\n            const {node} = binding.path;\n            const initNode = node.init;\n\n            if (initNode && binding.constant && scope.isPure(initNode, true)) {\n              hoistedVariables.add(node);\n              isAllowedIdentifier = true;\n            }\n          } else if (binding?.path.isImportSpecifier()) {\n            const importDecl = binding.path\n              .parentPath as NodePath<ImportDeclaration>;\n            const imported = binding.path.node.imported;\n            if (\n              importDecl.node.source.value === JEST_GLOBALS_MODULE_NAME &&\n              (isIdentifier(imported) ? imported.name : imported.value) ===\n                JEST_GLOBALS_MODULE_JEST_EXPORT_NAME\n            ) {\n              isAllowedIdentifier = true;\n              // Imports are already hoisted, so we don't need to add it\n              // to hoistedVariables.\n            }\n          }\n        }\n\n        if (!isAllowedIdentifier) {\n          throw id.buildCodeFrameError(\n            'The module factory of `jest.mock()` is not allowed to ' +\n              'reference any out-of-scope variables.\\n' +\n              `Invalid variable access: ${name}\\n` +\n              `Allowed objects: ${[...ALLOWED_IDENTIFIERS].join(', ')}.\\n` +\n              'Note: This is a precaution to guard against uninitialized mock ' +\n              'variables. If it is ensured that the mock is required lazily, ' +\n              'variable names prefixed with `mock` (case insensitive) are permitted.\\n',\n            ReferenceError,\n          );\n        }\n      }\n    }\n\n    return true;\n  }\n  return false;\n};\n\nFUNCTIONS.unmock = args => args.length === 1 && args[0].isStringLiteral();\nFUNCTIONS.deepUnmock = args => args.length === 1 && args[0].isStringLiteral();\nFUNCTIONS.disableAutomock = FUNCTIONS.enableAutomock = args =>\n  args.length === 0;\n\nconst createJestObjectGetter = statement`\nfunction GETTER_NAME() {\n  const { JEST_GLOBALS_MODULE_JEST_EXPORT_NAME } = require(\"JEST_GLOBALS_MODULE_NAME\");\n  GETTER_NAME = () => JEST_GLOBALS_MODULE_JEST_EXPORT_NAME;\n  return JEST_GLOBALS_MODULE_JEST_EXPORT_NAME;\n}\n`;\n\nconst isJestObject = (\n  expression: NodePath<Expression | Super>,\n): expression is NodePath<Identifier | MemberExpression> => {\n  // global\n  if (\n    expression.isIdentifier() &&\n    expression.node.name === JEST_GLOBAL_NAME &&\n    !expression.scope.hasBinding(JEST_GLOBAL_NAME)\n  ) {\n    return true;\n  }\n  // import { jest } from '@jest/globals'\n  if (\n    expression.referencesImport(\n      JEST_GLOBALS_MODULE_NAME,\n      JEST_GLOBALS_MODULE_JEST_EXPORT_NAME,\n    )\n  ) {\n    return true;\n  }\n  // import * as JestGlobals from '@jest/globals'\n  if (\n    expression.isMemberExpression() &&\n    !expression.node.computed &&\n    expression\n      .get<'object'>('object')\n      .referencesImport(JEST_GLOBALS_MODULE_NAME, '*') &&\n    expression.node.property.type === 'Identifier' &&\n    expression.node.property.name === JEST_GLOBALS_MODULE_JEST_EXPORT_NAME\n  ) {\n    return true;\n  }\n\n  return false;\n};\n\ntype JestObjInfo = {\n  hoist: boolean;\n  path: NodePath<Expression>;\n};\n\nconst extractJestObjExprIfHoistable = (expr: NodePath): JestObjInfo | null => {\n  if (!expr.isCallExpression()) {\n    return null;\n  }\n\n  const callee = expr.get<'callee'>('callee');\n  const args = expr.get<'arguments'>('arguments');\n\n  if (!callee.isMemberExpression() || callee.node.computed) {\n    return null;\n  }\n\n  const object = callee.get<'object'>('object');\n  const property = callee.get<'property'>('property') as NodePath<Identifier>;\n  const propertyName = property.node.name;\n\n  const jestObjExpr = isJestObject(object)\n    ? object\n    : // The Jest object could be returned from another call since the functions are all chainable.\n      extractJestObjExprIfHoistable(object)?.path;\n  if (!jestObjExpr) {\n    return null;\n  }\n\n  // Important: Call the function check last\n  // It might throw an error to display to the user,\n  // which should only happen if we're already sure it's a call on the Jest object.\n  const functionIsHoistable = FUNCTIONS[propertyName]?.(args) ?? false;\n  let functionHasHoistableScope = functionIsHoistable;\n  for (\n    let path: NodePath<Node> | null = expr;\n    path && !functionHasHoistableScope;\n    path = path.parentPath\n  ) {\n    functionHasHoistableScope = hoistedJestExpressions.has(\n      // @ts-expect-error: it's ok if path.node is not an Expression, .has will\n      // just return false.\n      path.node,\n    );\n  }\n\n  if (functionHasHoistableScope) {\n    hoistedJestExpressions.add(expr.node);\n    return {\n      hoist: functionIsHoistable,\n      path: jestObjExpr,\n    };\n  }\n\n  return null;\n};\n\n/* eslint-disable sort-keys */\nexport default function jestHoist(): PluginObj<{\n  declareJestObjGetterIdentifier: () => Identifier;\n  jestObjGetterIdentifier?: Identifier;\n}> {\n  return {\n    pre({path: program}) {\n      this.declareJestObjGetterIdentifier = () => {\n        if (this.jestObjGetterIdentifier) {\n          return this.jestObjGetterIdentifier;\n        }\n\n        this.jestObjGetterIdentifier =\n          program.scope.generateUidIdentifier('getJestObj');\n\n        program.unshiftContainer('body', [\n          createJestObjectGetter({\n            GETTER_NAME: this.jestObjGetterIdentifier.name,\n            JEST_GLOBALS_MODULE_JEST_EXPORT_NAME,\n            JEST_GLOBALS_MODULE_NAME,\n          }),\n        ]);\n\n        return this.jestObjGetterIdentifier;\n      };\n    },\n    visitor: {\n      ExpressionStatement(exprStmt) {\n        const jestObjInfo = extractJestObjExprIfHoistable(\n          exprStmt.get('expression'),\n        );\n        if (jestObjInfo) {\n          const jestCallExpr = callExpression(\n            this.declareJestObjGetterIdentifier(),\n            [],\n          );\n          jestObjInfo.path.replaceWith(jestCallExpr);\n          if (jestObjInfo.hoist) {\n            hoistedJestGetters.add(jestCallExpr);\n          }\n        }\n      },\n    },\n    // in `post` to make sure we come after an import transform and can unshift above the `require`s\n    post({path: program}) {\n      type Item = {calls: Array<Statement>; vars: Array<Statement>};\n\n      const stack: Array<Item> = [{calls: [], vars: []}];\n      program.traverse({\n        BlockStatement: {\n          enter() {\n            stack.push({calls: [], vars: []});\n          },\n          exit(path) {\n            const item = stack.pop()!;\n            path.node.body.unshift(...item.vars, ...item.calls);\n          },\n        },\n        CallExpression(callExpr: NodePath<CallExpression>) {\n          if (hoistedJestGetters.has(callExpr.node)) {\n            const mockStmt = callExpr.getStatementParent();\n\n            if (mockStmt?.parentPath.isBlock()) {\n              stack.at(-1)!.calls.push(mockStmt.node);\n              mockStmt.remove();\n            }\n          }\n        },\n        VariableDeclarator(varDecl: NodePath<VariableDeclarator>) {\n          if (hoistedVariables.has(varDecl.node)) {\n            // should be assert function, but it's not. So let's cast below\n            varDecl.parentPath.assertVariableDeclaration();\n\n            const {kind, declarations} = varDecl.parent as VariableDeclaration;\n            if (declarations.length === 1) {\n              varDecl.parentPath.remove();\n            } else {\n              varDecl.remove();\n            }\n            stack.at(-1)!.vars.push(variableDeclaration(kind, [varDecl.node]));\n          }\n        },\n      });\n      const item = stack.pop()!;\n      program.node.body.unshift(...item.vars, ...item.calls);\n    },\n  };\n}\n/* eslint-enable */\n",
  "packages/babel-plugin-jest-hoist/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport type { PluginObj } from '@babel/core';\nimport { type Identifier } from '@babel/types';\nexport default function jestHoist(): PluginObj<{\n    declareJestObjGetterIdentifier: () => Identifier;\n    jestObjGetterIdentifier?: Identifier;\n}>;\n",
  "packages/babel-plugin-jest-hoist/src/__tests__/hoistPlugin.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport * as path from 'path';\nimport {format as formatCode, resolveConfig} from '@prettier/sync';\nimport pluginTester from 'babel-plugin-tester';\nimport type {Options} from 'prettier';\nimport babelPluginJestHoist from '..';\n\nconst prettierOptions: Options = {\n  ...resolveConfig(__filename),\n  filepath: __filename,\n  parser: 'babel-ts',\n};\n\nconst formatResult = (code: string) => formatCode(code, prettierOptions);\n\npluginTester({\n  plugin: babelPluginJestHoist,\n  pluginName: 'babel-plugin-jest-hoist',\n  tests: {\n    /* eslint-disable sort-keys */\n    'automatic react runtime': {\n      babelOptions: {\n        babelrc: false,\n        configFile: false,\n        filename: path.resolve(__dirname, '../file.js'),\n        presets: [\n          [\n            require.resolve('@babel/preset-react'),\n            {development: true, runtime: 'automatic'},\n          ],\n        ],\n      },\n      code: formatResult(`\n        jest.mock('./App', () => () => <div>Hello world</div>);\n      `),\n      formatResult(code) {\n        // replace the filename with something that will be the same across OSes and machine\n        const codeWithoutSystemPath = code.replace(\n          /var _jsxFileName = \".*\";/,\n          'var _jsxFileName = \"/root/project/src/file.js\";',\n        );\n\n        return formatResult(codeWithoutSystemPath);\n      },\n      snapshot: true,\n    },\n    'top level mocking': {\n      code: formatResult(`\n        require('x');\n\n        jest.enableAutomock();\n        jest.disableAutomock();\n      `),\n      formatResult,\n      snapshot: true,\n    },\n    'within a block': {\n      code: formatResult(`\n        beforeEach(() => {\n          require('x')\n          jest.mock('someNode')\n        })\n      `),\n      formatResult,\n      snapshot: true,\n    },\n    'within a block with no siblings': {\n      code: formatResult(`\n        beforeEach(() => {\n          jest.mock('someNode')\n        })\n      `),\n      formatResult,\n      snapshot: true,\n    },\n\n    'required `jest` within `jest`': {\n      code: formatResult(`\n        const {jest} = require('@jest/globals');\n\n        jest.mock('some-module', () => {\n          jest.requireActual('some-module');\n        });\n      `),\n      formatResult,\n      snapshot: true,\n    },\n    'imported jest.mock within jest.mock': {\n      code: formatResult(`\n        import {jest} from '@jest/globals';\n\n        jest.mock('some-module', () => {\n          jest.mock('some-module');\n        });\n      `),\n      formatResult,\n      snapshot: true,\n    },\n    'global jest.mock within jest.mock': {\n      code: formatResult(`\n        jest.mock('some-module', () => {\n          jest.mock('some-module');\n        });\n      `),\n      formatResult,\n      snapshot: true,\n    },\n    'imported jest.requireActual in jest.mock': {\n      code: formatResult(`\n        import {jest} from '@jest/globals';\n\n        jest.mock('some-module', () => {\n          jest.requireActual('some-module');\n        });\n\n        jest.requireActual('some-module');\n      `),\n      formatResult,\n      snapshot: true,\n    },\n    'global jest.requireActual in jest.mock': {\n      code: formatResult(`\n        jest.mock('some-module', () => {\n          jest.requireActual('some-module');\n        });\n\n        jest.requireActual('some-module');\n      `),\n      formatResult,\n      snapshot: true,\n    },\n    'TS typeof usage in jest.mock': {\n      babelOptions: {\n        babelrc: false,\n        configFile: false,\n        filename: path.resolve(__dirname, '../file.ts'),\n        presets: [[require.resolve('@babel/preset-typescript')]],\n      },\n      code: formatResult(`\n        jest.mock('some-module', () => {\n          const actual = jest.requireActual('some-module');\n\n          return jest.fn<typeof actual.method>();\n        });\n      `),\n      formatResult,\n      snapshot: true,\n    },\n    'jest.spyOn call on the imported module': {\n      code: formatResult(`\n        jest.mock('some-module', () => {\n          const module = jest.requireActual('some-module');\n          jest.spyOn(module, 'add');\n          return module;\n        });\n      `),\n      formatResult,\n      snapshot: true,\n    },\n    'jest.spyOn call in class constructor': {\n      code: formatResult(`\n        jest.mock('some-module', () => {\n          const Actual = jest.requireActual('some-module');\n          return class Mocked extends Actual {\n            constructor() {\n              super();\n              jest.spyOn(this, 'add');\n            }\n          };\n        });\n      `),\n      formatResult,\n      snapshot: true,\n    },\n  },\n  /* eslint-enable */\n});\n",
  "packages/babel-plugin-jest-hoist/src/__tests__/hoistPlugin.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nexport {};\n",
  "packages/babel-jest/src/loadBabelConfig.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// this is a separate file so it can be mocked in tests\nexport {loadPartialConfig, loadPartialConfigAsync} from '@babel/core';\n",
  "packages/babel-jest/src/loadBabelConfig.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport { loadPartialConfig, loadPartialConfigAsync } from '@babel/core';\n",
  "packages/babel-jest/src/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {createHash} from 'crypto';\nimport * as path from 'path';\nimport {\n  type TransformOptions as BabelTransformOptions,\n  type PartialConfig,\n  transformSync as babelTransform,\n  transformAsync as babelTransformAsync,\n} from '@babel/core';\nimport chalk from 'chalk';\nimport * as fs from 'graceful-fs';\nimport slash from 'slash';\nimport type {\n  TransformOptions as JestTransformOptions,\n  SyncTransformer,\n  TransformerCreator,\n} from '@jest/transform';\nimport {loadPartialConfig, loadPartialConfigAsync} from './loadBabelConfig';\n\ninterface TransformerConfig extends BabelTransformOptions {\n  excludeJestPreset?: boolean;\n}\n\nconst THIS_FILE = fs.readFileSync(__filename);\nconst jestPresetPath = require.resolve('babel-preset-jest');\nconst babelIstanbulPlugin = require.resolve('babel-plugin-istanbul');\n\nfunction assertLoadedBabelConfig(\n  babelConfig: Readonly<PartialConfig> | null,\n  cwd: string,\n  filename: string,\n): asserts babelConfig {\n  if (!babelConfig) {\n    throw new Error(\n      `babel-jest: Babel ignores ${chalk.bold(\n        slash(path.relative(cwd, filename)),\n      )} - make sure to include the file in Jest's ${chalk.bold(\n        'transformIgnorePatterns',\n      )} as well.`,\n    );\n  }\n}\n\nfunction addIstanbulInstrumentation(\n  babelOptions: BabelTransformOptions,\n  transformOptions: JestTransformOptions,\n): BabelTransformOptions {\n  if (transformOptions.instrument) {\n    const copiedBabelOptions: BabelTransformOptions = {...babelOptions};\n    copiedBabelOptions.auxiliaryCommentBefore = ' istanbul ignore next ';\n    // Copied from jest-runtime transform.js\n    copiedBabelOptions.plugins = [\n      ...(copiedBabelOptions.plugins ?? []),\n      [\n        babelIstanbulPlugin,\n        {\n          // files outside `cwd` will not be instrumented\n          cwd: transformOptions.config.cwd,\n          exclude: [],\n        },\n      ],\n    ];\n\n    return copiedBabelOptions;\n  }\n\n  return babelOptions;\n}\n\nfunction getCacheKeyFromConfig(\n  sourceText: string,\n  sourcePath: string,\n  babelOptions: PartialConfig,\n  transformOptions: JestTransformOptions,\n): string {\n  const {config, configString, instrument} = transformOptions;\n\n  const configPath = [babelOptions.config ?? '', babelOptions.babelrc ?? ''];\n\n  return createHash('sha1')\n    .update(THIS_FILE)\n    .update('\\0', 'utf8')\n    .update(JSON.stringify(babelOptions.options))\n    .update('\\0', 'utf8')\n    .update(sourceText)\n    .update('\\0', 'utf8')\n    .update(path.relative(config.rootDir, sourcePath))\n    .update('\\0', 'utf8')\n    .update(configString)\n    .update('\\0', 'utf8')\n    .update(configPath.join(''))\n    .update('\\0', 'utf8')\n    .update(instrument ? 'instrument' : '')\n    .update('\\0', 'utf8')\n    .update(process.env.NODE_ENV ?? '')\n    .update('\\0', 'utf8')\n    .update(process.env.BABEL_ENV ?? '')\n    .update('\\0', 'utf8')\n    .update(process.version)\n    .digest('hex')\n    .slice(0, 32);\n}\n\nfunction loadBabelConfig(\n  cwd: string,\n  filename: string,\n  transformOptions: BabelTransformOptions,\n): PartialConfig {\n  const babelConfig = loadPartialConfig(transformOptions);\n\n  assertLoadedBabelConfig(babelConfig, cwd, filename);\n\n  return babelConfig;\n}\n\nasync function loadBabelConfigAsync(\n  cwd: string,\n  filename: string,\n  transformOptions: BabelTransformOptions,\n): Promise<PartialConfig> {\n  const babelConfig = await loadPartialConfigAsync(transformOptions);\n\n  assertLoadedBabelConfig(babelConfig, cwd, filename);\n\n  return babelConfig;\n}\n\nfunction loadBabelOptions(\n  cwd: string,\n  filename: string,\n  transformOptions: BabelTransformOptions,\n  jestTransformOptions: JestTransformOptions,\n): BabelTransformOptions {\n  const {options} = loadBabelConfig(cwd, filename, transformOptions);\n\n  return addIstanbulInstrumentation(options, jestTransformOptions);\n}\n\nasync function loadBabelOptionsAsync(\n  cwd: string,\n  filename: string,\n  transformOptions: BabelTransformOptions,\n  jestTransformOptions: JestTransformOptions,\n): Promise<BabelTransformOptions> {\n  const {options} = await loadBabelConfigAsync(cwd, filename, transformOptions);\n\n  return addIstanbulInstrumentation(options, jestTransformOptions);\n}\n\nexport const createTransformer: TransformerCreator<\n  SyncTransformer<TransformerConfig>,\n  TransformerConfig\n> = transformerConfig => {\n  const {excludeJestPreset, ...inputOptions} = transformerConfig ?? {};\n\n  const options = {\n    ...inputOptions,\n    caller: {\n      name: 'babel-jest',\n      supportsDynamicImport: false,\n      supportsExportNamespaceFrom: false,\n      supportsStaticESM: false,\n      supportsTopLevelAwait: false,\n      ...inputOptions.caller,\n    },\n    compact: false,\n    plugins: inputOptions.plugins ?? [],\n    presets: [\n      ...(inputOptions.presets ?? []),\n      ...(excludeJestPreset === true ? [] : [jestPresetPath]),\n    ],\n    sourceMaps: 'both',\n  } satisfies BabelTransformOptions;\n\n  function mergeBabelTransformOptions(\n    filename: string,\n    transformOptions: JestTransformOptions,\n  ): BabelTransformOptions {\n    const {cwd, rootDir} = transformOptions.config;\n    // `cwd` and `root` first to allow incoming options to override it\n    return {\n      cwd,\n      root: rootDir,\n      ...options,\n      caller: {\n        ...options.caller,\n        supportsDynamicImport:\n          transformOptions.supportsDynamicImport ??\n          options.caller.supportsDynamicImport,\n        supportsExportNamespaceFrom:\n          transformOptions.supportsExportNamespaceFrom ??\n          options.caller.supportsExportNamespaceFrom,\n        supportsStaticESM:\n          transformOptions.supportsStaticESM ??\n          options.caller.supportsStaticESM,\n        supportsTopLevelAwait:\n          transformOptions.supportsTopLevelAwait ??\n          options.caller.supportsTopLevelAwait,\n      },\n      filename,\n    };\n  }\n\n  return {\n    canInstrument: true,\n    getCacheKey(sourceText, sourcePath, transformOptions) {\n      const babelOptions = loadBabelConfig(\n        transformOptions.config.cwd,\n        sourcePath,\n        mergeBabelTransformOptions(sourcePath, transformOptions),\n      );\n\n      return getCacheKeyFromConfig(\n        sourceText,\n        sourcePath,\n        babelOptions,\n        transformOptions,\n      );\n    },\n    async getCacheKeyAsync(sourceText, sourcePath, transformOptions) {\n      const babelOptions = await loadBabelConfigAsync(\n        transformOptions.config.cwd,\n        sourcePath,\n        mergeBabelTransformOptions(sourcePath, transformOptions),\n      );\n\n      return getCacheKeyFromConfig(\n        sourceText,\n        sourcePath,\n        babelOptions,\n        transformOptions,\n      );\n    },\n    process(sourceText, sourcePath, transformOptions) {\n      const babelOptions = loadBabelOptions(\n        transformOptions.config.cwd,\n        sourcePath,\n        mergeBabelTransformOptions(sourcePath, transformOptions),\n        transformOptions,\n      );\n\n      const transformResult = babelTransform(sourceText, babelOptions);\n\n      if (transformResult) {\n        const {code, map} = transformResult;\n        if (typeof code === 'string') {\n          return {code, map};\n        }\n      }\n\n      return {code: sourceText};\n    },\n    async processAsync(sourceText, sourcePath, transformOptions) {\n      const babelOptions = await loadBabelOptionsAsync(\n        transformOptions.config.cwd,\n        sourcePath,\n        mergeBabelTransformOptions(sourcePath, transformOptions),\n        transformOptions,\n      );\n\n      const transformResult = await babelTransformAsync(\n        sourceText,\n        babelOptions,\n      );\n\n      if (transformResult) {\n        const {code, map} = transformResult;\n        if (typeof code === 'string') {\n          return {code, map};\n        }\n      }\n\n      return {code: sourceText};\n    },\n  };\n};\n\nconst transformerFactory = {\n  // Assigned here, instead of as a separate export, due to limitations in Jest's\n  // requireOrImportModule, requiring all exports to be on the `default` export\n  createTransformer,\n};\n\nexport default transformerFactory;\n",
  "packages/babel-jest/src/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { type TransformOptions as BabelTransformOptions } from '@babel/core';\nimport type { SyncTransformer, TransformerCreator } from '@jest/transform';\ninterface TransformerConfig extends BabelTransformOptions {\n    excludeJestPreset?: boolean;\n}\nexport declare const createTransformer: TransformerCreator<SyncTransformer<TransformerConfig>, TransformerConfig>;\ndeclare const transformerFactory: {\n    createTransformer: TransformerCreator<SyncTransformer<TransformerConfig>, TransformerConfig>;\n};\nexport default transformerFactory;\n",
  "packages/babel-jest/src/__tests__/index.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {\n  BabelFileResult,\n  TransformOptions as BabelTransformOptions,\n} from '@babel/core';\nimport {makeProjectConfig} from '@jest/test-utils';\nimport type {SyncTransformer, TransformOptions} from '@jest/transform';\nimport babelJest, {createTransformer} from '../index';\nimport {loadPartialConfig} from '../loadBabelConfig';\n\njest.mock('../loadBabelConfig', () => {\n  const actual =\n    jest.requireActual<typeof import('@babel/core')>('@babel/core');\n\n  return {\n    loadPartialConfig: jest.fn<typeof actual.loadPartialConfig>((...args) =>\n      actual.loadPartialConfig(...args),\n    ),\n    loadPartialConfigAsync: jest.fn<typeof actual.loadPartialConfigAsync>(\n      (...args) => actual.loadPartialConfigAsync(...args),\n    ),\n  };\n});\n\nconst defaultBabelJestTransformer =\n  babelJest.createTransformer() as SyncTransformer<BabelTransformOptions>;\n\n//Mock data for all the tests\nconst sourceString = `\nconst sum = (a, b) => a+b;\nconst difference = (a, b) => a-b;\n\nconst customMultiply = (obj, mul) => {\n    const {a, ...rest} = obj;\n    return a * mul;\n}\n\ncustomMultiply({a: 32, dummy: \"test\"}, 2);\n`;\n\nbeforeEach(() => {\n  jest.clearAllMocks();\n});\n\ntest('Returns source string with inline maps when no transformOptions is passed', () => {\n  const result = defaultBabelJestTransformer.process(\n    sourceString,\n    'dummy_path.js',\n    {\n      cacheFS: new Map<string, string>(),\n      config: makeProjectConfig(),\n      configString: JSON.stringify(makeProjectConfig()),\n      instrument: false,\n      transformerConfig: {},\n    } as TransformOptions<BabelTransformOptions>,\n  );\n\n  expect(typeof result).toBe('object');\n  expect(result.code).toBeDefined();\n  expect(result.map).toBeDefined();\n  expect(result.code).toMatch('//# sourceMappingURL');\n  expect(result.code).toMatch('customMultiply');\n  expect((result as BabelFileResult).map!.sources).toEqual(['dummy_path.js']);\n  expect(\n    JSON.stringify((result as BabelFileResult).map!.sourcesContent),\n  ).toMatch('customMultiply');\n});\n\ntest('Returns source string with inline maps when no transformOptions is passed async', async () => {\n  const result = await defaultBabelJestTransformer.processAsync!(\n    sourceString,\n    'dummy_path.js',\n    {\n      cacheFS: new Map<string, string>(),\n      config: makeProjectConfig(),\n      configString: JSON.stringify(makeProjectConfig()),\n      instrument: false,\n      transformerConfig: {},\n    } as TransformOptions<BabelTransformOptions>,\n  );\n\n  expect(typeof result).toBe('object');\n  expect(result.code).toBeDefined();\n  expect(result.map).toBeDefined();\n  expect(result.code).toMatch('//# sourceMappingURL');\n  expect(result.code).toMatch('customMultiply');\n\n  const {map} = result;\n\n  expect(map).toBeTruthy();\n  expect(typeof map).not.toBe('string');\n\n  if (map == null || typeof map === 'string') {\n    throw new Error('dead code');\n  }\n\n  expect(map.sources).toEqual(['dummy_path.js']);\n  expect(JSON.stringify(map.sourcesContent)).toMatch('customMultiply');\n});\n\ndescribe('caller option correctly merges from defaults and options', () => {\n  test.each([\n    [\n      {supportsDynamicImport: true, supportsStaticESM: true},\n      {supportsDynamicImport: true, supportsStaticESM: true},\n    ],\n    [\n      {supportsDynamicImport: false, supportsStaticESM: false},\n      {supportsDynamicImport: false, supportsStaticESM: false},\n    ],\n    [\n      {supportsStaticESM: false},\n      {supportsDynamicImport: false, supportsStaticESM: false},\n    ],\n    [\n      {supportsDynamicImport: true},\n      {supportsDynamicImport: true, supportsStaticESM: false},\n    ],\n  ])('%j -> %j', (input, output) => {\n    defaultBabelJestTransformer.process(sourceString, 'dummy_path.js', {\n      cacheFS: new Map<string, string>(),\n      config: makeProjectConfig(),\n      configString: JSON.stringify(makeProjectConfig()),\n      instrument: false,\n      transformerConfig: {},\n      ...input,\n    } as TransformOptions<BabelTransformOptions>);\n\n    expect(loadPartialConfig).toHaveBeenCalledTimes(1);\n    expect(loadPartialConfig).toHaveBeenCalledWith(\n      expect.objectContaining({\n        caller: {\n          name: 'babel-jest',\n          ...output,\n          supportsExportNamespaceFrom: false,\n          supportsTopLevelAwait: false,\n        },\n      }),\n    );\n  });\n});\n\ntest('can pass null to createTransformer', async () => {\n  const transformer = await createTransformer();\n  transformer.process(sourceString, 'dummy_path.js', {\n    cacheFS: new Map<string, string>(),\n    config: makeProjectConfig(),\n    configString: JSON.stringify(makeProjectConfig()),\n    instrument: false,\n    transformerConfig: {},\n  } as TransformOptions<BabelTransformOptions>);\n\n  expect(loadPartialConfig).toHaveBeenCalledTimes(1);\n  expect(loadPartialConfig).toHaveBeenCalledWith(\n    expect.objectContaining({\n      caller: {\n        name: 'babel-jest',\n        supportsDynamicImport: false,\n        supportsExportNamespaceFrom: false,\n        supportsStaticESM: false,\n        supportsTopLevelAwait: false,\n      },\n    }),\n  );\n});\n\ntest('include babel-preset-jest by default', () => {\n  defaultBabelJestTransformer.process(sourceString, 'dummy_path.js', {\n    cacheFS: new Map<string, string>(),\n    config: makeProjectConfig(),\n    configString: JSON.stringify(makeProjectConfig()),\n    instrument: false,\n    transformerConfig: {},\n  } as TransformOptions<BabelTransformOptions>);\n\n  expect(loadPartialConfig).toHaveBeenCalledTimes(1);\n  expect(loadPartialConfig).toHaveBeenCalledWith(\n    expect.objectContaining({presets: [require.resolve('babel-preset-jest')]}),\n  );\n});\n\ntest('can opting out of babel-preset-jest by passing excludeJestPreset: true', async () => {\n  const transformer = await createTransformer({excludeJestPreset: true});\n  transformer.process(sourceString, 'dummy_path.js', {\n    cacheFS: new Map<string, string>(),\n    config: makeProjectConfig(),\n    configString: JSON.stringify(makeProjectConfig()),\n    instrument: false,\n    transformerConfig: {},\n  } as TransformOptions<BabelTransformOptions>);\n\n  expect(loadPartialConfig).toHaveBeenCalledTimes(1);\n  expect(loadPartialConfig).toHaveBeenCalledWith(\n    expect.objectContaining({presets: []}),\n  );\n});\n",
  "packages/babel-jest/src/__tests__/index.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n",
  "packages/babel-jest/src/__tests__/getCacheKey.test.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {TransformOptions as BabelTransformOptions} from '@babel/core';\nimport type {SyncTransformer, TransformOptions} from '@jest/transform';\nimport babelJest from '../index';\n\nconst {getCacheKey} =\n  babelJest.createTransformer() as SyncTransformer<BabelTransformOptions>;\n\nconst processVersion = process.version;\nconst nodeEnv = process.env.NODE_ENV;\nconst babelEnv = process.env.BABEL_ENV;\n\nafterEach(() => {\n  jest.resetModules();\n\n  if (process.version === 'new-node-version') {\n    // @ts-expect-error: Testing purpose\n    process.version = processVersion;\n  }\n\n  if (process.env.NODE_ENV === 'NEW_NODE_ENV') {\n    process.env.NODE_ENV = nodeEnv;\n  }\n\n  if (process.env.BABEL_ENV === 'NEW_BABEL_ENV') {\n    process.env.BABEL_ENV = babelEnv;\n  }\n});\n\ndescribe('getCacheKey', () => {\n  const sourceText = 'mock source';\n  const sourcePath = 'mock-source-path.js';\n\n  const transformOptions = {\n    config: {rootDir: 'mock-root-dir'},\n    configString: 'mock-config-string',\n    instrument: true,\n  } as TransformOptions<BabelTransformOptions>;\n\n  const oldCacheKey = getCacheKey!(sourceText, sourcePath, transformOptions);\n\n  test('returns cache key hash', () => {\n    expect(oldCacheKey).toHaveLength(32);\n  });\n\n  test('if `THIS_FILE` value is changing', async () => {\n    jest.doMock('graceful-fs', () => ({\n      readFileSync: () => 'new this file',\n    }));\n\n    const {createTransformer} =\n      require('../index') as typeof import('../index');\n\n    const newCacheKey = (await createTransformer()).getCacheKey!(\n      sourceText,\n      sourcePath,\n      transformOptions,\n    );\n\n    expect(oldCacheKey).not.toEqual(newCacheKey);\n  });\n\n  test('if `babelOptions.options` value is changing', async () => {\n    jest.doMock('../loadBabelConfig', () => {\n      const babel = require('@babel/core') as typeof import('@babel/core');\n\n      return {\n        loadPartialConfig: (options: BabelTransformOptions) => ({\n          ...babel.loadPartialConfig(options),\n          options: 'new-options',\n        }),\n      };\n    });\n\n    const {createTransformer} =\n      require('../index') as typeof import('../index');\n\n    const newCacheKey = (await createTransformer()).getCacheKey!(\n      sourceText,\n      sourcePath,\n      transformOptions,\n    );\n\n    expect(oldCacheKey).not.toEqual(newCacheKey);\n  });\n\n  test('if `sourceText` value is changing', () => {\n    const newCacheKey = getCacheKey!(\n      'new source text',\n      sourcePath,\n      transformOptions,\n    );\n\n    expect(oldCacheKey).not.toEqual(newCacheKey);\n  });\n\n  test('if `sourcePath` value is changing', () => {\n    const newCacheKey = getCacheKey!(\n      sourceText,\n      'new-source-path.js',\n      transformOptions,\n    );\n\n    expect(oldCacheKey).not.toEqual(newCacheKey);\n  });\n\n  test('if `configString` value is changing', () => {\n    const newCacheKey = getCacheKey!(sourceText, sourcePath, {\n      ...transformOptions,\n      configString: 'new-config-string',\n    });\n\n    expect(oldCacheKey).not.toEqual(newCacheKey);\n  });\n\n  test('if `babelOptions.config` value is changing', async () => {\n    jest.doMock('../loadBabelConfig', () => {\n      const babel = require('@babel/core') as typeof import('@babel/core');\n\n      return {\n        loadPartialConfig: (options: BabelTransformOptions) => ({\n          ...babel.loadPartialConfig(options),\n          config: 'new-config',\n        }),\n      };\n    });\n\n    const {createTransformer} =\n      require('../index') as typeof import('../index');\n\n    const newCacheKey = (await createTransformer()).getCacheKey!(\n      sourceText,\n      sourcePath,\n      transformOptions,\n    );\n\n    expect(oldCacheKey).not.toEqual(newCacheKey);\n  });\n\n  test('if `babelOptions.babelrc` value is changing', async () => {\n    jest.doMock('../loadBabelConfig', () => {\n      const babel = require('@babel/core') as typeof import('@babel/core');\n\n      return {\n        loadPartialConfig: (options: BabelTransformOptions) => ({\n          ...babel.loadPartialConfig(options),\n          babelrc: 'new-babelrc',\n        }),\n      };\n    });\n\n    const {createTransformer} =\n      require('../index') as typeof import('../index');\n\n    const newCacheKey = (await createTransformer()).getCacheKey!(\n      sourceText,\n      sourcePath,\n      transformOptions,\n    );\n\n    expect(oldCacheKey).not.toEqual(newCacheKey);\n  });\n\n  test('if `instrument` value is changing', () => {\n    const newCacheKey = getCacheKey!(sourceText, sourcePath, {\n      ...transformOptions,\n      instrument: false,\n    });\n\n    expect(oldCacheKey).not.toEqual(newCacheKey);\n  });\n\n  test('if `process.env.NODE_ENV` value is changing', () => {\n    process.env.NODE_ENV = 'NEW_NODE_ENV';\n\n    const newCacheKey = getCacheKey!(sourceText, sourcePath, transformOptions);\n\n    expect(oldCacheKey).not.toEqual(newCacheKey);\n  });\n\n  test('if `process.env.BABEL_ENV` value is changing', () => {\n    process.env.BABEL_ENV = 'NEW_BABEL_ENV';\n\n    const newCacheKey = getCacheKey!(sourceText, sourcePath, transformOptions);\n\n    expect(oldCacheKey).not.toEqual(newCacheKey);\n  });\n\n  test('if node version is changing', () => {\n    // @ts-expect-error: Testing purpose\n    delete process.version;\n    // @ts-expect-error: Testing purpose\n    process.version = 'new-node-version';\n\n    const newCacheKey = getCacheKey!(sourceText, sourcePath, transformOptions);\n\n    expect(oldCacheKey).not.toEqual(newCacheKey);\n  });\n});\n",
  "packages/babel-jest/src/__tests__/getCacheKey.test.d.ts": "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nexport {};\n"
};