/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/babylon/lib/index.js":
/*!*******************************************!*\
  !*** ./node_modules/babylon/lib/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("{\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\n// A second optional argument can be given to further configure\n// the parser process. These options are recognized:\nvar defaultOptions = {\n  // Source type (\"script\" or \"module\") for different semantics\n  sourceType: \"script\",\n  // Source filename.\n  sourceFilename: undefined,\n  // Line from which to start counting source. Useful for\n  // integration with other tools.\n  startLine: 1,\n  // When enabled, a return at the top level is not considered an\n  // error.\n  allowReturnOutsideFunction: false,\n  // When enabled, import/export statements are not constrained to\n  // appearing at the top of the program.\n  allowImportExportEverywhere: false,\n  // TODO\n  allowSuperOutsideMethod: false,\n  // An array of plugins to enable\n  plugins: [],\n  // TODO\n  strictMode: null,\n  // Nodes have their start and end characters offsets recorded in\n  // `start` and `end` properties (directly on the node, rather than\n  // the `loc` object, which holds line/column data. To also add a\n  // [semi-standardized][range] `range` property holding a `[start,\n  // end]` array with the same numbers, set the `ranges` option to\n  // `true`.\n  //\n  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n  ranges: false,\n  // Adds all parsed tokens to a `tokens` property on the `File` node\n  tokens: false\n}; // Interpret and default an options object\n\nfunction getOptions(opts) {\n  var options = {};\n\n  for (var key in defaultOptions) {\n    options[key] = opts && opts[key] != null ? opts[key] : defaultOptions[key];\n  }\n\n  return options;\n}\n\n// ## Token types\n// The assignment of fine-grained, information-carrying type objects\n// allows the tokenizer to store the information it has about a\n// token in a way that is very cheap for the parser to look up.\n// All token type variables start with an underscore, to make them\n// easy to recognize.\n// The `beforeExpr` property is used to disambiguate between regular\n// expressions and divisions. It is set on all token types that can\n// be followed by an expression (thus, a slash after them would be a\n// regular expression).\n//\n// `isLoop` marks a keyword as starting a loop, which is important\n// to know when parsing a label, in order to allow or disallow\n// continue jumps to that label.\nvar beforeExpr = true;\nvar startsExpr = true;\nvar isLoop = true;\nvar isAssign = true;\nvar prefix = true;\nvar postfix = true;\nvar TokenType = function TokenType(label, conf) {\n  if (conf === void 0) {\n    conf = {};\n  }\n\n  this.label = label;\n  this.keyword = conf.keyword;\n  this.beforeExpr = !!conf.beforeExpr;\n  this.startsExpr = !!conf.startsExpr;\n  this.rightAssociative = !!conf.rightAssociative;\n  this.isLoop = !!conf.isLoop;\n  this.isAssign = !!conf.isAssign;\n  this.prefix = !!conf.prefix;\n  this.postfix = !!conf.postfix;\n  this.binop = conf.binop === 0 ? 0 : conf.binop || null;\n  this.updateContext = null;\n};\n\nvar KeywordTokenType =\n/*#__PURE__*/\nfunction (_TokenType) {\n  _inheritsLoose(KeywordTokenType, _TokenType);\n\n  function KeywordTokenType(name, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    options.keyword = name;\n    return _TokenType.call(this, name, options) || this;\n  }\n\n  return KeywordTokenType;\n}(TokenType);\n\nvar BinopTokenType =\n/*#__PURE__*/\nfunction (_TokenType2) {\n  _inheritsLoose(BinopTokenType, _TokenType2);\n\n  function BinopTokenType(name, prec) {\n    return _TokenType2.call(this, name, {\n      beforeExpr,\n      binop: prec\n    }) || this;\n  }\n\n  return BinopTokenType;\n}(TokenType);\nvar types = {\n  num: new TokenType(\"num\", {\n    startsExpr\n  }),\n  bigint: new TokenType(\"bigint\", {\n    startsExpr\n  }),\n  regexp: new TokenType(\"regexp\", {\n    startsExpr\n  }),\n  string: new TokenType(\"string\", {\n    startsExpr\n  }),\n  name: new TokenType(\"name\", {\n    startsExpr\n  }),\n  eof: new TokenType(\"eof\"),\n  // Punctuation token types.\n  bracketL: new TokenType(\"[\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketR: new TokenType(\"]\"),\n  braceL: new TokenType(\"{\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceBarL: new TokenType(\"{|\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceR: new TokenType(\"}\"),\n  braceBarR: new TokenType(\"|}\"),\n  parenL: new TokenType(\"(\", {\n    beforeExpr,\n    startsExpr\n  }),\n  parenR: new TokenType(\")\"),\n  comma: new TokenType(\",\", {\n    beforeExpr\n  }),\n  semi: new TokenType(\";\", {\n    beforeExpr\n  }),\n  colon: new TokenType(\":\", {\n    beforeExpr\n  }),\n  doubleColon: new TokenType(\"::\", {\n    beforeExpr\n  }),\n  dot: new TokenType(\".\"),\n  question: new TokenType(\"?\", {\n    beforeExpr\n  }),\n  questionDot: new TokenType(\"?.\"),\n  arrow: new TokenType(\"=>\", {\n    beforeExpr\n  }),\n  template: new TokenType(\"template\"),\n  ellipsis: new TokenType(\"...\", {\n    beforeExpr\n  }),\n  backQuote: new TokenType(\"`\", {\n    startsExpr\n  }),\n  dollarBraceL: new TokenType(\"${\", {\n    beforeExpr,\n    startsExpr\n  }),\n  at: new TokenType(\"@\"),\n  hash: new TokenType(\"#\"),\n  // Operators. These carry several kinds of properties to help the\n  // parser use them properly (the presence of these properties is\n  // what categorizes them as operators).\n  //\n  // `binop`, when present, specifies that this operator is a binary\n  // operator, and will refer to its precedence.\n  //\n  // `prefix` and `postfix` mark the operator as a prefix or postfix\n  // unary operator.\n  //\n  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n  // binary operators with a very low precedence, that should result\n  // in AssignmentExpression nodes.\n  eq: new TokenType(\"=\", {\n    beforeExpr,\n    isAssign\n  }),\n  assign: new TokenType(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  incDec: new TokenType(\"++/--\", {\n    prefix,\n    postfix,\n    startsExpr\n  }),\n  bang: new TokenType(\"!\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  tilde: new TokenType(\"~\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  pipeline: new BinopTokenType(\"|>\", 0),\n  nullishCoalescing: new BinopTokenType(\"??\", 1),\n  logicalOR: new BinopTokenType(\"||\", 1),\n  logicalAND: new BinopTokenType(\"&&\", 2),\n  bitwiseOR: new BinopTokenType(\"|\", 3),\n  bitwiseXOR: new BinopTokenType(\"^\", 4),\n  bitwiseAND: new BinopTokenType(\"&\", 5),\n  equality: new BinopTokenType(\"==/!=\", 6),\n  relational: new BinopTokenType(\"</>\", 7),\n  bitShift: new BinopTokenType(\"<</>>\", 8),\n  plusMin: new TokenType(\"+/-\", {\n    beforeExpr,\n    binop: 9,\n    prefix,\n    startsExpr\n  }),\n  modulo: new BinopTokenType(\"%\", 10),\n  star: new BinopTokenType(\"*\", 10),\n  slash: new BinopTokenType(\"/\", 10),\n  exponent: new TokenType(\"**\", {\n    beforeExpr,\n    binop: 11,\n    rightAssociative: true\n  })\n};\nvar keywords = {\n  break: new KeywordTokenType(\"break\"),\n  case: new KeywordTokenType(\"case\", {\n    beforeExpr\n  }),\n  catch: new KeywordTokenType(\"catch\"),\n  continue: new KeywordTokenType(\"continue\"),\n  debugger: new KeywordTokenType(\"debugger\"),\n  default: new KeywordTokenType(\"default\", {\n    beforeExpr\n  }),\n  do: new KeywordTokenType(\"do\", {\n    isLoop,\n    beforeExpr\n  }),\n  else: new KeywordTokenType(\"else\", {\n    beforeExpr\n  }),\n  finally: new KeywordTokenType(\"finally\"),\n  for: new KeywordTokenType(\"for\", {\n    isLoop\n  }),\n  function: new KeywordTokenType(\"function\", {\n    startsExpr\n  }),\n  if: new KeywordTokenType(\"if\"),\n  return: new KeywordTokenType(\"return\", {\n    beforeExpr\n  }),\n  switch: new KeywordTokenType(\"switch\"),\n  throw: new KeywordTokenType(\"throw\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  try: new KeywordTokenType(\"try\"),\n  var: new KeywordTokenType(\"var\"),\n  let: new KeywordTokenType(\"let\"),\n  const: new KeywordTokenType(\"const\"),\n  while: new KeywordTokenType(\"while\", {\n    isLoop\n  }),\n  with: new KeywordTokenType(\"with\"),\n  new: new KeywordTokenType(\"new\", {\n    beforeExpr,\n    startsExpr\n  }),\n  this: new KeywordTokenType(\"this\", {\n    startsExpr\n  }),\n  super: new KeywordTokenType(\"super\", {\n    startsExpr\n  }),\n  class: new KeywordTokenType(\"class\"),\n  extends: new KeywordTokenType(\"extends\", {\n    beforeExpr\n  }),\n  export: new KeywordTokenType(\"export\"),\n  import: new KeywordTokenType(\"import\", {\n    startsExpr\n  }),\n  yield: new KeywordTokenType(\"yield\", {\n    beforeExpr,\n    startsExpr\n  }),\n  null: new KeywordTokenType(\"null\", {\n    startsExpr\n  }),\n  true: new KeywordTokenType(\"true\", {\n    startsExpr\n  }),\n  false: new KeywordTokenType(\"false\", {\n    startsExpr\n  }),\n  in: new KeywordTokenType(\"in\", {\n    beforeExpr,\n    binop: 7\n  }),\n  instanceof: new KeywordTokenType(\"instanceof\", {\n    beforeExpr,\n    binop: 7\n  }),\n  typeof: new KeywordTokenType(\"typeof\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  void: new KeywordTokenType(\"void\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  delete: new KeywordTokenType(\"delete\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  })\n}; // Map keyword names to token types.\n\nObject.keys(keywords).forEach(function (name) {\n  types[\"_\" + name] = keywords[name];\n});\n\n/* eslint max-len: 0 */\nfunction makePredicate(words) {\n  var wordsArr = words.split(\" \");\n  return function (str) {\n    return wordsArr.indexOf(str) >= 0;\n  };\n} // Reserved word lists for various dialects of the language\n\n\nvar reservedWords = {\n  \"6\": makePredicate(\"enum await\"),\n  strict: makePredicate(\"implements interface let package private protected public static yield\"),\n  strictBind: makePredicate(\"eval arguments\")\n}; // And the keywords\n\nvar isKeyword = makePredicate(\"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this let const class extends export import yield super\"); // ## Character categories\n// Big ugly regular expressions that match characters in the\n// whitespace, identifier, and identifier-start categories. These\n// are only applied when a character is found to actually have a\n// code point above 128.\n// Generated by `bin/generate-identifier-regex.js`.\n\nvar nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0-\\u08b4\\u08b6-\\u08bd\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fd5\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7ae\\ua7b0-\\ua7b7\\ua7f7-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab65\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\nvar nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08d4-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c03\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d01-\\u0d03\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf2-\\u1cf4\\u1cf8\\u1cf9\\u1dc0-\\u1df5\\u1dfb-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua900-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\nvar nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nvar nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null; // These are a run-length and offset encoded representation of the\n// >0xffff code points that are a valid part of identifiers. The\n// offset starts at 0x10000, and each pair of numbers represents an\n// offset to the next range, and then a size of the range. They were\n// generated by `bin/generate-identifier-regex.js`.\n// eslint-disable-next-line comma-spacing\n\n/* prettier-ignore */\n\nvar astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 17, 26, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 26, 45, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 785, 52, 76, 44, 33, 24, 27, 35, 42, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 54, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 86, 25, 391, 63, 32, 0, 449, 56, 264, 8, 2, 36, 18, 0, 50, 29, 881, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 881, 68, 12, 0, 67, 12, 65, 0, 32, 6124, 20, 754, 9486, 1, 3071, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 4149, 196, 60, 67, 1213, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 3, 5761, 10591, 541]; // eslint-disable-next-line comma-spacing\n\n/* prettier-ignore */\n\nvar astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 1306, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 52, 0, 13, 2, 49, 13, 10, 2, 4, 9, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 57, 0, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 87, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 423, 9, 838, 7, 2, 7, 17, 9, 57, 21, 2, 13, 19882, 9, 135, 4, 60, 6, 26, 9, 1016, 45, 17, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 2214, 6, 110, 6, 6, 9, 792487, 239]; // This has a complexity linear to the value of the code. The\n// assumption is that looking up astral identifier characters is\n// rare.\n\nfunction isInAstralSet(code, set) {\n  var pos = 0x10000;\n\n  for (var i = 0; i < set.length; i += 2) {\n    pos += set[i];\n    if (pos > code) return false;\n    pos += set[i + 1];\n    if (pos >= code) return true;\n  }\n\n  return false;\n} // Test whether a given character code starts an identifier.\n\n\nfunction isIdentifierStart(code) {\n  if (code < 65) return code === 36;\n  if (code < 91) return true;\n  if (code < 97) return code === 95;\n  if (code < 123) return true;\n\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n  }\n\n  return isInAstralSet(code, astralIdentifierStartCodes);\n} // Test whether a given character is part of an identifier.\n\nfunction isIdentifierChar(code) {\n  if (code < 48) return code === 36;\n  if (code < 58) return true;\n  if (code < 65) return false;\n  if (code < 91) return true;\n  if (code < 97) return code === 95;\n  if (code < 123) return true;\n\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  }\n\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);\n}\n\n// Matches a whole line break (where CRLF is considered a single\n// line break). Used to count lines.\nvar lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/;\nvar lineBreakG = new RegExp(lineBreak.source, \"g\");\nfunction isNewLine(code) {\n  return code === 10 || code === 13 || code === 0x2028 || code === 0x2029;\n}\nvar nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n\n// The algorithm used to determine whether a regexp can appear at a\n// given point in the program is loosely based on sweet.js' approach.\n// See https://github.com/mozilla/sweet.js/wiki/design\nvar TokContext = function TokContext(token, isExpr, preserveSpace, override) // Takes a Tokenizer as a this-parameter, and returns void.\n{\n  this.token = token;\n  this.isExpr = !!isExpr;\n  this.preserveSpace = !!preserveSpace;\n  this.override = override;\n};\nvar types$1 = {\n  braceStatement: new TokContext(\"{\", false),\n  braceExpression: new TokContext(\"{\", true),\n  templateQuasi: new TokContext(\"${\", true),\n  parenStatement: new TokContext(\"(\", false),\n  parenExpression: new TokContext(\"(\", true),\n  template: new TokContext(\"`\", true, true, function (p) {\n    return p.readTmplToken();\n  }),\n  functionExpression: new TokContext(\"function\", true)\n}; // Token-specific context update code\n\ntypes.parenR.updateContext = types.braceR.updateContext = function () {\n  if (this.state.context.length === 1) {\n    this.state.exprAllowed = true;\n    return;\n  }\n\n  var out = this.state.context.pop();\n\n  if (out === types$1.braceStatement && this.curContext() === types$1.functionExpression) {\n    this.state.context.pop();\n    this.state.exprAllowed = false;\n  } else if (out === types$1.templateQuasi) {\n    this.state.exprAllowed = true;\n  } else {\n    this.state.exprAllowed = !out.isExpr;\n  }\n};\n\ntypes.name.updateContext = function (prevType) {\n  if (this.state.value === \"of\" && this.curContext() === types$1.parenStatement) {\n    this.state.exprAllowed = !prevType.beforeExpr;\n    return;\n  }\n\n  this.state.exprAllowed = false;\n\n  if (prevType === types._let || prevType === types._const || prevType === types._var) {\n    if (lineBreak.test(this.input.slice(this.state.end))) {\n      this.state.exprAllowed = true;\n    }\n  }\n};\n\ntypes.braceL.updateContext = function (prevType) {\n  this.state.context.push(this.braceIsBlock(prevType) ? types$1.braceStatement : types$1.braceExpression);\n  this.state.exprAllowed = true;\n};\n\ntypes.dollarBraceL.updateContext = function () {\n  this.state.context.push(types$1.templateQuasi);\n  this.state.exprAllowed = true;\n};\n\ntypes.parenL.updateContext = function (prevType) {\n  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;\n  this.state.context.push(statementParens ? types$1.parenStatement : types$1.parenExpression);\n  this.state.exprAllowed = true;\n};\n\ntypes.incDec.updateContext = function () {// tokExprAllowed stays unchanged\n};\n\ntypes._function.updateContext = function () {\n  if (this.curContext() !== types$1.braceStatement) {\n    this.state.context.push(types$1.functionExpression);\n  }\n\n  this.state.exprAllowed = false;\n};\n\ntypes.backQuote.updateContext = function () {\n  if (this.curContext() === types$1.template) {\n    this.state.context.pop();\n  } else {\n    this.state.context.push(types$1.template);\n  }\n\n  this.state.exprAllowed = false;\n};\n\n// These are used when `options.locations` is on, for the\n// `startLoc` and `endLoc` properties.\nvar Position = function Position(line, col) {\n  this.line = line;\n  this.column = col;\n};\nvar SourceLocation = function SourceLocation(start, end) {\n  this.start = start; // $FlowIgnore (may start as null, but initialized later)\n\n  this.end = end;\n}; // The `getLineInfo` function is mostly useful when the\n// `locations` option is off (for performance reasons) and you\n// want to find the line/column position for a given character\n// offset. `input` should be the code string that the offset refers\n// into.\n\nfunction getLineInfo(input, offset) {\n  for (var line = 1, cur = 0;;) {\n    lineBreakG.lastIndex = cur;\n    var match = lineBreakG.exec(input);\n\n    if (match && match.index < offset) {\n      ++line;\n      cur = match.index + match[0].length;\n    } else {\n      return new Position(line, offset - cur);\n    }\n  } // istanbul ignore next\n\n\n  throw new Error(\"Unreachable\");\n}\n\nvar BaseParser =\n/*#__PURE__*/\nfunction () {\n  function BaseParser() {}\n\n  var _proto = BaseParser.prototype;\n\n  // Properties set by constructor in index.js\n  // Initialized by Tokenizer\n  _proto.isReservedWord = function isReservedWord(word) {\n    if (word === \"await\") {\n      return this.inModule;\n    } else {\n      return reservedWords[6](word);\n    }\n  };\n\n  _proto.hasPlugin = function hasPlugin(name) {\n    return !!this.plugins[name];\n  };\n\n  return BaseParser;\n}();\n\n/* eslint max-len: 0 */\n\n/**\n * Based on the comment attachment algorithm used in espree and estraverse.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * * Redistributions of source code must retain the above copyright\n *   notice, this list of conditions and the following disclaimer.\n * * Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nfunction last(stack) {\n  return stack[stack.length - 1];\n}\n\nvar CommentsParser =\n/*#__PURE__*/\nfunction (_BaseParser) {\n  _inheritsLoose(CommentsParser, _BaseParser);\n\n  function CommentsParser() {\n    return _BaseParser.apply(this, arguments) || this;\n  }\n\n  var _proto = CommentsParser.prototype;\n\n  _proto.addComment = function addComment(comment) {\n    if (this.filename) comment.loc.filename = this.filename;\n    this.state.trailingComments.push(comment);\n    this.state.leadingComments.push(comment);\n  };\n\n  _proto.processComment = function processComment(node) {\n    if (node.type === \"Program\" && node.body.length > 0) return;\n    var stack = this.state.commentStack;\n    var firstChild, lastChild, trailingComments, i, j;\n\n    if (this.state.trailingComments.length > 0) {\n      // If the first comment in trailingComments comes after the\n      // current node, then we're good - all comments in the array will\n      // come after the node and so it's safe to add them as official\n      // trailingComments.\n      if (this.state.trailingComments[0].start >= node.end) {\n        trailingComments = this.state.trailingComments;\n        this.state.trailingComments = [];\n      } else {\n        // Otherwise, if the first comment doesn't come after the\n        // current node, that means we have a mix of leading and trailing\n        // comments in the array and that leadingComments contains the\n        // same items as trailingComments. Reset trailingComments to\n        // zero items and we'll handle this by evaluating leadingComments\n        // later.\n        this.state.trailingComments.length = 0;\n      }\n    } else {\n      if (stack.length > 0) {\n        var lastInStack = last(stack);\n\n        if (lastInStack.trailingComments && lastInStack.trailingComments[0].start >= node.end) {\n          trailingComments = lastInStack.trailingComments;\n          lastInStack.trailingComments = null;\n        }\n      }\n    } // Eating the stack.\n\n\n    if (stack.length > 0 && last(stack).start >= node.start) {\n      firstChild = stack.pop();\n    }\n\n    while (stack.length > 0 && last(stack).start >= node.start) {\n      lastChild = stack.pop();\n    }\n\n    if (!lastChild && firstChild) lastChild = firstChild; // Attach comments that follow a trailing comma on the last\n    // property in an object literal or a trailing comma in function arguments\n    // as trailing comments\n\n    if (firstChild && this.state.leadingComments.length > 0) {\n      var lastComment = last(this.state.leadingComments);\n\n      if (firstChild.type === \"ObjectProperty\") {\n        if (lastComment.start >= node.start) {\n          if (this.state.commentPreviousNode) {\n            for (j = 0; j < this.state.leadingComments.length; j++) {\n              if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {\n                this.state.leadingComments.splice(j, 1);\n                j--;\n              }\n            }\n\n            if (this.state.leadingComments.length > 0) {\n              firstChild.trailingComments = this.state.leadingComments;\n              this.state.leadingComments = [];\n            }\n          }\n        }\n      } else if (node.type === \"CallExpression\" && node.arguments && node.arguments.length) {\n        var lastArg = last(node.arguments);\n\n        if (lastArg && lastComment.start >= lastArg.start && lastComment.end <= node.end) {\n          if (this.state.commentPreviousNode) {\n            if (this.state.leadingComments.length > 0) {\n              lastArg.trailingComments = this.state.leadingComments;\n              this.state.leadingComments = [];\n            }\n          }\n        }\n      }\n    }\n\n    if (lastChild) {\n      if (lastChild.leadingComments) {\n        if (lastChild !== node && lastChild.leadingComments.length > 0 && last(lastChild.leadingComments).end <= node.start) {\n          node.leadingComments = lastChild.leadingComments;\n          lastChild.leadingComments = null;\n        } else {\n          // A leading comment for an anonymous class had been stolen by its first ClassMethod,\n          // so this takes back the leading comment.\n          // See also: https://github.com/eslint/espree/issues/158\n          for (i = lastChild.leadingComments.length - 2; i >= 0; --i) {\n            if (lastChild.leadingComments[i].end <= node.start) {\n              node.leadingComments = lastChild.leadingComments.splice(0, i + 1);\n              break;\n            }\n          }\n        }\n      }\n    } else if (this.state.leadingComments.length > 0) {\n      if (last(this.state.leadingComments).end <= node.start) {\n        if (this.state.commentPreviousNode) {\n          for (j = 0; j < this.state.leadingComments.length; j++) {\n            if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {\n              this.state.leadingComments.splice(j, 1);\n              j--;\n            }\n          }\n        }\n\n        if (this.state.leadingComments.length > 0) {\n          node.leadingComments = this.state.leadingComments;\n          this.state.leadingComments = [];\n        }\n      } else {\n        // https://github.com/eslint/espree/issues/2\n        //\n        // In special cases, such as return (without a value) and\n        // debugger, all comments will end up as leadingComments and\n        // will otherwise be eliminated. This step runs when the\n        // commentStack is empty and there are comments left\n        // in leadingComments.\n        //\n        // This loop figures out the stopping point between the actual\n        // leading and trailing comments by finding the location of the\n        // first comment that comes after the given node.\n        for (i = 0; i < this.state.leadingComments.length; i++) {\n          if (this.state.leadingComments[i].end > node.start) {\n            break;\n          }\n        } // Split the array based on the location of the first comment\n        // that comes after the node. Keep in mind that this could\n        // result in an empty array, and if so, the array must be\n        // deleted.\n\n\n        var leadingComments = this.state.leadingComments.slice(0, i);\n        node.leadingComments = leadingComments.length === 0 ? null : leadingComments; // Similarly, trailing comments are attached later. The variable\n        // must be reset to null if there are no trailing comments.\n\n        trailingComments = this.state.leadingComments.slice(i);\n\n        if (trailingComments.length === 0) {\n          trailingComments = null;\n        }\n      }\n    }\n\n    this.state.commentPreviousNode = node;\n\n    if (trailingComments) {\n      if (trailingComments.length && trailingComments[0].start >= node.start && last(trailingComments).end <= node.end) {\n        node.innerComments = trailingComments;\n      } else {\n        node.trailingComments = trailingComments;\n      }\n    }\n\n    stack.push(node);\n  };\n\n  return CommentsParser;\n}(BaseParser);\n\n// takes an offset integer (into the current `input`) to indicate\n// the location of the error, attaches the position to the end\n// of the error message, and then raises a `SyntaxError` with that\n// message.\n\nvar LocationParser =\n/*#__PURE__*/\nfunction (_CommentsParser) {\n  _inheritsLoose(LocationParser, _CommentsParser);\n\n  function LocationParser() {\n    return _CommentsParser.apply(this, arguments) || this;\n  }\n\n  var _proto = LocationParser.prototype;\n\n  _proto.raise = function raise(pos, message, missingPluginNames) {\n    var loc = getLineInfo(this.input, pos);\n    message += ` (${loc.line}:${loc.column})`; // $FlowIgnore\n\n    var err = new SyntaxError(message);\n    err.pos = pos;\n    err.loc = loc;\n\n    if (missingPluginNames) {\n      err.missingPlugin = missingPluginNames;\n    }\n\n    throw err;\n  };\n\n  return LocationParser;\n}(CommentsParser);\n\nvar State =\n/*#__PURE__*/\nfunction () {\n  function State() {}\n\n  var _proto = State.prototype;\n\n  _proto.init = function init(options, input) {\n    this.strict = options.strictMode === false ? false : options.sourceType === \"module\";\n    this.input = input;\n    this.potentialArrowAt = -1;\n    this.noArrowAt = [];\n    this.noArrowParamsConversionAt = []; // eslint-disable-next-line max-len\n\n    this.inMethod = this.inFunction = this.inParameters = this.maybeInArrowParameters = this.inGenerator = this.inAsync = this.inPropertyName = this.inType = this.inClassProperty = this.noAnonFunctionType = false;\n    this.classLevel = 0;\n    this.labels = [];\n    this.decoratorStack = [[]];\n    this.yieldInPossibleArrowParameters = null;\n    this.tokens = [];\n    this.comments = [];\n    this.trailingComments = [];\n    this.leadingComments = [];\n    this.commentStack = []; // $FlowIgnore\n\n    this.commentPreviousNode = null;\n    this.pos = this.lineStart = 0;\n    this.curLine = options.startLine;\n    this.type = types.eof;\n    this.value = null;\n    this.start = this.end = this.pos;\n    this.startLoc = this.endLoc = this.curPosition(); // $FlowIgnore\n\n    this.lastTokEndLoc = this.lastTokStartLoc = null;\n    this.lastTokStart = this.lastTokEnd = this.pos;\n    this.context = [types$1.braceStatement];\n    this.exprAllowed = true;\n    this.containsEsc = this.containsOctal = false;\n    this.octalPosition = null;\n    this.invalidTemplateEscapePosition = null;\n    this.exportedIdentifiers = [];\n  }; // TODO\n\n\n  _proto.curPosition = function curPosition() {\n    return new Position(this.curLine, this.pos - this.lineStart);\n  };\n\n  _proto.clone = function clone(skipArrays) {\n    var _this = this;\n\n    var state = new State();\n    Object.keys(this).forEach(function (key) {\n      // $FlowIgnore\n      var val = _this[key];\n\n      if ((!skipArrays || key === \"context\") && Array.isArray(val)) {\n        val = val.slice();\n      } // $FlowIgnore\n\n\n      state[key] = val;\n    });\n    return state;\n  };\n\n  return State;\n}();\n\n/* eslint max-len: 0 */\n// an immediate sibling of NumericLiteralSeparator _\n\nvar forbiddenNumericSeparatorSiblings = {\n  decBinOct: [46, // .\n  66, // B\n  69, // E\n  79, // O\n  95, // _ (multiple separators are not allowed)\n  98, // b\n  101, // e\n  111],\n  hex: [46, // .\n  88, // X\n  95, // _ (multiple separators are not allowed)\n  120]\n};\nvar allowedNumericSeparatorSiblings = {};\nallowedNumericSeparatorSiblings.bin = [// 0 - 1\n48, 49];\nallowedNumericSeparatorSiblings.oct = [].concat(allowedNumericSeparatorSiblings.bin, [50, 51, 52, 53, 54, 55]);\nallowedNumericSeparatorSiblings.dec = [].concat(allowedNumericSeparatorSiblings.oct, [56, 57]);\nallowedNumericSeparatorSiblings.hex = [].concat(allowedNumericSeparatorSiblings.dec, [// A - F\n65, 66, 67, 68, 69, 70, // a - f\n97, 98, 99, 100, 101, 102]); // Object type used to represent tokens. Note that normally, tokens\n// simply exist as properties on the parser object. This is only\n// used for the onToken callback and the external tokenizer.\n\nvar Token = function Token(state) {\n  this.type = state.type;\n  this.value = state.value;\n  this.start = state.start;\n  this.end = state.end;\n  this.loc = new SourceLocation(state.startLoc, state.endLoc);\n}; // ## Tokenizer\n\nfunction codePointToString(code) {\n  // UTF-16 Decoding\n  if (code <= 0xffff) {\n    return String.fromCharCode(code);\n  } else {\n    return String.fromCharCode((code - 0x10000 >> 10) + 0xd800, (code - 0x10000 & 1023) + 0xdc00);\n  }\n}\n\nvar Tokenizer =\n/*#__PURE__*/\nfunction (_LocationParser) {\n  _inheritsLoose(Tokenizer, _LocationParser);\n\n  // Forward-declarations\n  // parser/util.js\n  function Tokenizer(options, input) {\n    var _this;\n\n    _this = _LocationParser.call(this) || this;\n    _this.state = new State();\n\n    _this.state.init(options, input);\n\n    _this.isLookahead = false;\n    return _this;\n  } // Move to the next token\n\n\n  var _proto = Tokenizer.prototype;\n\n  _proto.next = function next() {\n    if (this.options.tokens && !this.isLookahead) {\n      this.state.tokens.push(new Token(this.state));\n    }\n\n    this.state.lastTokEnd = this.state.end;\n    this.state.lastTokStart = this.state.start;\n    this.state.lastTokEndLoc = this.state.endLoc;\n    this.state.lastTokStartLoc = this.state.startLoc;\n    this.nextToken();\n  }; // TODO\n\n\n  _proto.eat = function eat(type) {\n    if (this.match(type)) {\n      this.next();\n      return true;\n    } else {\n      return false;\n    }\n  }; // TODO\n\n\n  _proto.match = function match(type) {\n    return this.state.type === type;\n  }; // TODO\n\n\n  _proto.isKeyword = function isKeyword$$1(word) {\n    return isKeyword(word);\n  }; // TODO\n\n\n  _proto.lookahead = function lookahead() {\n    var old = this.state;\n    this.state = old.clone(true);\n    this.isLookahead = true;\n    this.next();\n    this.isLookahead = false;\n    var curr = this.state;\n    this.state = old;\n    return curr;\n  }; // Toggle strict mode. Re-reads the next number or string to please\n  // pedantic tests (`\"use strict\"; 010;` should fail).\n\n\n  _proto.setStrict = function setStrict(strict) {\n    this.state.strict = strict;\n    if (!this.match(types.num) && !this.match(types.string)) return;\n    this.state.pos = this.state.start;\n\n    while (this.state.pos < this.state.lineStart) {\n      this.state.lineStart = this.input.lastIndexOf(\"\\n\", this.state.lineStart - 2) + 1;\n      --this.state.curLine;\n    }\n\n    this.nextToken();\n  };\n\n  _proto.curContext = function curContext() {\n    return this.state.context[this.state.context.length - 1];\n  }; // Read a single token, updating the parser object's token-related\n  // properties.\n\n\n  _proto.nextToken = function nextToken() {\n    var curContext = this.curContext();\n    if (!curContext || !curContext.preserveSpace) this.skipSpace();\n    this.state.containsOctal = false;\n    this.state.octalPosition = null;\n    this.state.start = this.state.pos;\n    this.state.startLoc = this.state.curPosition();\n\n    if (this.state.pos >= this.input.length) {\n      this.finishToken(types.eof);\n      return;\n    }\n\n    if (curContext.override) {\n      curContext.override(this);\n    } else {\n      this.readToken(this.fullCharCodeAtPos());\n    }\n  };\n\n  _proto.readToken = function readToken(code) {\n    // Identifier or keyword. '\\uXXXX' sequences are allowed in\n    // identifiers, so '\\' also dispatches to that.\n    if (isIdentifierStart(code) || code === 92\n    /* '\\' */\n    ) {\n        this.readWord();\n      } else {\n      this.getTokenFromCode(code);\n    }\n  };\n\n  _proto.fullCharCodeAtPos = function fullCharCodeAtPos() {\n    var code = this.input.charCodeAt(this.state.pos);\n    if (code <= 0xd7ff || code >= 0xe000) return code;\n    var next = this.input.charCodeAt(this.state.pos + 1);\n    return (code << 10) + next - 0x35fdc00;\n  };\n\n  _proto.pushComment = function pushComment(block, text, start, end, startLoc, endLoc) {\n    var comment = {\n      type: block ? \"CommentBlock\" : \"CommentLine\",\n      value: text,\n      start: start,\n      end: end,\n      loc: new SourceLocation(startLoc, endLoc)\n    };\n\n    if (!this.isLookahead) {\n      if (this.options.tokens) this.state.tokens.push(comment);\n      this.state.comments.push(comment);\n      this.addComment(comment);\n    }\n  };\n\n  _proto.skipBlockComment = function skipBlockComment() {\n    var startLoc = this.state.curPosition();\n    var start = this.state.pos;\n    var end = this.input.indexOf(\"*/\", this.state.pos += 2);\n    if (end === -1) this.raise(this.state.pos - 2, \"Unterminated comment\");\n    this.state.pos = end + 2;\n    lineBreakG.lastIndex = start;\n    var match;\n\n    while ((match = lineBreakG.exec(this.input)) && match.index < this.state.pos) {\n      ++this.state.curLine;\n      this.state.lineStart = match.index + match[0].length;\n    }\n\n    this.pushComment(true, this.input.slice(start + 2, end), start, this.state.pos, startLoc, this.state.curPosition());\n  };\n\n  _proto.skipLineComment = function skipLineComment(startSkip) {\n    var start = this.state.pos;\n    var startLoc = this.state.curPosition();\n    var ch = this.input.charCodeAt(this.state.pos += startSkip);\n\n    if (this.state.pos < this.input.length) {\n      while (ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233 && ++this.state.pos < this.input.length) {\n        ch = this.input.charCodeAt(this.state.pos);\n      }\n    }\n\n    this.pushComment(false, this.input.slice(start + startSkip, this.state.pos), start, this.state.pos, startLoc, this.state.curPosition());\n  }; // Called at the start of the parse and after every token. Skips\n  // whitespace and comments, and.\n\n\n  _proto.skipSpace = function skipSpace() {\n    loop: while (this.state.pos < this.input.length) {\n      var ch = this.input.charCodeAt(this.state.pos);\n\n      switch (ch) {\n        case 32: // space\n\n        case 160:\n          // non-breaking space\n          ++this.state.pos;\n          break;\n\n        case 13:\n          // '\\r' carriage return\n          if (this.input.charCodeAt(this.state.pos + 1) === 10) {\n            ++this.state.pos;\n          }\n\n        case 10: // '\\n' line feed\n\n        case 8232: // line separator\n\n        case 8233:\n          // paragraph separator\n          ++this.state.pos;\n          ++this.state.curLine;\n          this.state.lineStart = this.state.pos;\n          break;\n\n        case 47:\n          // '/'\n          switch (this.input.charCodeAt(this.state.pos + 1)) {\n            case 42:\n              // '*'\n              this.skipBlockComment();\n              break;\n\n            case 47:\n              this.skipLineComment(2);\n              break;\n\n            default:\n              break loop;\n          }\n\n          break;\n\n        default:\n          if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n            ++this.state.pos;\n          } else {\n            break loop;\n          }\n\n      }\n    }\n  }; // Called at the end of every token. Sets `end`, `val`, and\n  // maintains `context` and `exprAllowed`, and skips the space after\n  // the token, so that the next one's `start` will point at the\n  // right position.\n\n\n  _proto.finishToken = function finishToken(type, val) {\n    this.state.end = this.state.pos;\n    this.state.endLoc = this.state.curPosition();\n    var prevType = this.state.type;\n    this.state.type = type;\n    this.state.value = val;\n    this.updateContext(prevType);\n  }; // ### Token reading\n  // This is the function that is called to fetch the next token. It\n  // is somewhat obscure, because it works in character codes rather\n  // than characters, and because operator parsing has been inlined\n  // into it.\n  //\n  // All in the name of speed.\n  //\n\n\n  _proto.readToken_dot = function readToken_dot() {\n    var next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next >= 48 && next <= 57) {\n      this.readNumber(true);\n      return;\n    }\n\n    var next2 = this.input.charCodeAt(this.state.pos + 2);\n\n    if (next === 46 && next2 === 46) {\n      // 46 = dot '.'\n      this.state.pos += 3;\n      this.finishToken(types.ellipsis);\n    } else {\n      ++this.state.pos;\n      this.finishToken(types.dot);\n    }\n  };\n\n  _proto.readToken_slash = function readToken_slash() {\n    // '/'\n    if (this.state.exprAllowed) {\n      ++this.state.pos;\n      this.readRegexp();\n      return;\n    }\n\n    var next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === 61) {\n      this.finishOp(types.assign, 2);\n    } else {\n      this.finishOp(types.slash, 1);\n    }\n  };\n\n  _proto.readToken_mult_modulo = function readToken_mult_modulo(code) {\n    // '%*'\n    var type = code === 42 ? types.star : types.modulo;\n    var width = 1;\n    var next = this.input.charCodeAt(this.state.pos + 1);\n    var exprAllowed = this.state.exprAllowed; // Exponentiation operator **\n\n    if (code === 42 && next === 42) {\n      width++;\n      next = this.input.charCodeAt(this.state.pos + 2);\n      type = types.exponent;\n    }\n\n    if (next === 61 && !exprAllowed) {\n      width++;\n      type = types.assign;\n    }\n\n    this.finishOp(type, width);\n  };\n\n  _proto.readToken_pipe_amp = function readToken_pipe_amp(code) {\n    // '|&'\n    var next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === code) {\n      this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2);\n      return;\n    }\n\n    if (code === 124) {\n      // '|>'\n      if (next === 62) {\n        this.finishOp(types.pipeline, 2);\n        return;\n      } else if (next === 125 && this.hasPlugin(\"flow\")) {\n        // '|}'\n        this.finishOp(types.braceBarR, 2);\n        return;\n      }\n    }\n\n    if (next === 61) {\n      this.finishOp(types.assign, 2);\n      return;\n    }\n\n    this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1);\n  };\n\n  _proto.readToken_caret = function readToken_caret() {\n    // '^'\n    var next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === 61) {\n      this.finishOp(types.assign, 2);\n    } else {\n      this.finishOp(types.bitwiseXOR, 1);\n    }\n  };\n\n  _proto.readToken_plus_min = function readToken_plus_min(code) {\n    // '+-'\n    var next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === code) {\n      if (next === 45 && !this.inModule && this.input.charCodeAt(this.state.pos + 2) === 62 && lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.pos))) {\n        // A `-->` line comment\n        this.skipLineComment(3);\n        this.skipSpace();\n        this.nextToken();\n        return;\n      }\n\n      this.finishOp(types.incDec, 2);\n      return;\n    }\n\n    if (next === 61) {\n      this.finishOp(types.assign, 2);\n    } else {\n      this.finishOp(types.plusMin, 1);\n    }\n  };\n\n  _proto.readToken_lt_gt = function readToken_lt_gt(code) {\n    // '<>'\n    var next = this.input.charCodeAt(this.state.pos + 1);\n    var size = 1;\n\n    if (next === code) {\n      size = code === 62 && this.input.charCodeAt(this.state.pos + 2) === 62 ? 3 : 2;\n\n      if (this.input.charCodeAt(this.state.pos + size) === 61) {\n        this.finishOp(types.assign, size + 1);\n        return;\n      }\n\n      this.finishOp(types.bitShift, size);\n      return;\n    }\n\n    if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.state.pos + 2) === 45 && this.input.charCodeAt(this.state.pos + 3) === 45) {\n      // `<!--`, an XML-style comment that should be interpreted as a line comment\n      this.skipLineComment(4);\n      this.skipSpace();\n      this.nextToken();\n      return;\n    }\n\n    if (next === 61) {\n      // <= | >=\n      size = 2;\n    }\n\n    this.finishOp(types.relational, size);\n  };\n\n  _proto.readToken_eq_excl = function readToken_eq_excl(code) {\n    // '=!'\n    var next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === 61) {\n      this.finishOp(types.equality, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);\n      return;\n    }\n\n    if (code === 61 && next === 62) {\n      // '=>'\n      this.state.pos += 2;\n      this.finishToken(types.arrow);\n      return;\n    }\n\n    this.finishOp(code === 61 ? types.eq : types.bang, 1);\n  };\n\n  _proto.readToken_question = function readToken_question() {\n    // '?'\n    var next = this.input.charCodeAt(this.state.pos + 1);\n    var next2 = this.input.charCodeAt(this.state.pos + 2);\n\n    if (next === 63) {\n      // '??'\n      this.finishOp(types.nullishCoalescing, 2);\n    } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {\n      // '.' not followed by a number\n      this.state.pos += 2;\n      this.finishToken(types.questionDot);\n    } else {\n      ++this.state.pos;\n      this.finishToken(types.question);\n    }\n  };\n\n  _proto.getTokenFromCode = function getTokenFromCode(code) {\n    switch (code) {\n      case 35:\n        // '#'\n        if ((this.hasPlugin(\"classPrivateProperties\") || this.hasPlugin(\"classPrivateMethods\")) && this.state.classLevel > 0) {\n          ++this.state.pos;\n          this.finishToken(types.hash);\n          return;\n        } else {\n          this.raise(this.state.pos, `Unexpected character '${codePointToString(code)}'`);\n        }\n\n      // The interpretation of a dot depends on whether it is followed\n      // by a digit or another two dots.\n\n      case 46:\n        // '.'\n        this.readToken_dot();\n        return;\n      // Punctuation tokens.\n\n      case 40:\n        ++this.state.pos;\n        this.finishToken(types.parenL);\n        return;\n\n      case 41:\n        ++this.state.pos;\n        this.finishToken(types.parenR);\n        return;\n\n      case 59:\n        ++this.state.pos;\n        this.finishToken(types.semi);\n        return;\n\n      case 44:\n        ++this.state.pos;\n        this.finishToken(types.comma);\n        return;\n\n      case 91:\n        ++this.state.pos;\n        this.finishToken(types.bracketL);\n        return;\n\n      case 93:\n        ++this.state.pos;\n        this.finishToken(types.bracketR);\n        return;\n\n      case 123:\n        if (this.hasPlugin(\"flow\") && this.input.charCodeAt(this.state.pos + 1) === 124) {\n          this.finishOp(types.braceBarL, 2);\n        } else {\n          ++this.state.pos;\n          this.finishToken(types.braceL);\n        }\n\n        return;\n\n      case 125:\n        ++this.state.pos;\n        this.finishToken(types.braceR);\n        return;\n\n      case 58:\n        if (this.hasPlugin(\"functionBind\") && this.input.charCodeAt(this.state.pos + 1) === 58) {\n          this.finishOp(types.doubleColon, 2);\n        } else {\n          ++this.state.pos;\n          this.finishToken(types.colon);\n        }\n\n        return;\n\n      case 63:\n        this.readToken_question();\n        return;\n\n      case 64:\n        ++this.state.pos;\n        this.finishToken(types.at);\n        return;\n\n      case 96:\n        // '`'\n        ++this.state.pos;\n        this.finishToken(types.backQuote);\n        return;\n\n      case 48:\n        {\n          // '0'\n          var next = this.input.charCodeAt(this.state.pos + 1); // '0x', '0X' - hex number\n\n          if (next === 120 || next === 88) {\n            this.readRadixNumber(16);\n            return;\n          } // '0o', '0O' - octal number\n\n\n          if (next === 111 || next === 79) {\n            this.readRadixNumber(8);\n            return;\n          } // '0b', '0B' - binary number\n\n\n          if (next === 98 || next === 66) {\n            this.readRadixNumber(2);\n            return;\n          }\n        }\n      // Anything else beginning with a digit is an integer, octal\n      // number, or float.\n\n      case 49:\n      case 50:\n      case 51:\n      case 52:\n      case 53:\n      case 54:\n      case 55:\n      case 56:\n      case 57:\n        // 1-9\n        this.readNumber(false);\n        return;\n      // Quotes produce strings.\n\n      case 34:\n      case 39:\n        // '\"', \"'\"\n        this.readString(code);\n        return;\n      // Operators are parsed inline in tiny state machines. '=' (61) is\n      // often referred to. `finishOp` simply skips the amount of\n      // characters it is given as second argument, and returns a token\n      // of the type given by its first argument.\n\n      case 47:\n        // '/'\n        this.readToken_slash();\n        return;\n\n      case 37:\n      case 42:\n        // '%*'\n        this.readToken_mult_modulo(code);\n        return;\n\n      case 124:\n      case 38:\n        // '|&'\n        this.readToken_pipe_amp(code);\n        return;\n\n      case 94:\n        // '^'\n        this.readToken_caret();\n        return;\n\n      case 43:\n      case 45:\n        // '+-'\n        this.readToken_plus_min(code);\n        return;\n\n      case 60:\n      case 62:\n        // '<>'\n        this.readToken_lt_gt(code);\n        return;\n\n      case 61:\n      case 33:\n        // '=!'\n        this.readToken_eq_excl(code);\n        return;\n\n      case 126:\n        // '~'\n        this.finishOp(types.tilde, 1);\n        return;\n    }\n\n    this.raise(this.state.pos, `Unexpected character '${codePointToString(code)}'`);\n  };\n\n  _proto.finishOp = function finishOp(type, size) {\n    var str = this.input.slice(this.state.pos, this.state.pos + size);\n    this.state.pos += size;\n    this.finishToken(type, str);\n  };\n\n  _proto.readRegexp = function readRegexp() {\n    var start = this.state.pos;\n    var escaped, inClass;\n\n    for (;;) {\n      if (this.state.pos >= this.input.length) {\n        this.raise(start, \"Unterminated regular expression\");\n      }\n\n      var ch = this.input.charAt(this.state.pos);\n\n      if (lineBreak.test(ch)) {\n        this.raise(start, \"Unterminated regular expression\");\n      }\n\n      if (escaped) {\n        escaped = false;\n      } else {\n        if (ch === \"[\") {\n          inClass = true;\n        } else if (ch === \"]\" && inClass) {\n          inClass = false;\n        } else if (ch === \"/\" && !inClass) {\n          break;\n        }\n\n        escaped = ch === \"\\\\\";\n      }\n\n      ++this.state.pos;\n    }\n\n    var content = this.input.slice(start, this.state.pos);\n    ++this.state.pos; // Need to use `readWord1` because '\\uXXXX' sequences are allowed\n    // here (don't ask).\n\n    var mods = this.readWord1();\n\n    if (mods) {\n      var validFlags = /^[gmsiyu]*$/;\n\n      if (!validFlags.test(mods)) {\n        this.raise(start, \"Invalid regular expression flag\");\n      }\n    }\n\n    this.finishToken(types.regexp, {\n      pattern: content,\n      flags: mods\n    });\n  }; // Read an integer in the given radix. Return null if zero digits\n  // were read, the integer value otherwise. When `len` is given, this\n  // will return `null` unless the integer has exactly `len` digits.\n\n\n  _proto.readInt = function readInt(radix, len) {\n    var start = this.state.pos;\n    var forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;\n    var allowedSiblings = radix === 16 ? allowedNumericSeparatorSiblings.hex : radix === 10 ? allowedNumericSeparatorSiblings.dec : radix === 8 ? allowedNumericSeparatorSiblings.oct : allowedNumericSeparatorSiblings.bin;\n    var total = 0;\n\n    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n      var code = this.input.charCodeAt(this.state.pos);\n      var val = void 0;\n\n      if (this.hasPlugin(\"numericSeparator\")) {\n        var prev = this.input.charCodeAt(this.state.pos - 1);\n        var next = this.input.charCodeAt(this.state.pos + 1);\n\n        if (code === 95) {\n          if (allowedSiblings.indexOf(next) === -1) {\n            this.raise(this.state.pos, \"Invalid or unexpected token\");\n          }\n\n          if (forbiddenSiblings.indexOf(prev) > -1 || forbiddenSiblings.indexOf(next) > -1 || Number.isNaN(next)) {\n            this.raise(this.state.pos, \"Invalid or unexpected token\");\n          } // Ignore this _ character\n\n\n          ++this.state.pos;\n          continue;\n        }\n      }\n\n      if (code >= 97) {\n        val = code - 97 + 10; // a\n      } else if (code >= 65) {\n        val = code - 65 + 10; // A\n      } else if (code >= 48 && code <= 57) {\n        val = code - 48; // 0-9\n      } else {\n        val = Infinity;\n      }\n\n      if (val >= radix) break;\n      ++this.state.pos;\n      total = total * radix + val;\n    }\n\n    if (this.state.pos === start || len != null && this.state.pos - start !== len) {\n      return null;\n    }\n\n    return total;\n  };\n\n  _proto.readRadixNumber = function readRadixNumber(radix) {\n    var start = this.state.pos;\n    var isBigInt = false;\n    this.state.pos += 2; // 0x\n\n    var val = this.readInt(radix);\n\n    if (val == null) {\n      this.raise(this.state.start + 2, \"Expected number in radix \" + radix);\n    }\n\n    if (this.hasPlugin(\"bigInt\")) {\n      if (this.input.charCodeAt(this.state.pos) === 0x6e) {\n        // 'n'\n        ++this.state.pos;\n        isBigInt = true;\n      }\n    }\n\n    if (isIdentifierStart(this.fullCharCodeAtPos())) {\n      this.raise(this.state.pos, \"Identifier directly after number\");\n    }\n\n    if (isBigInt) {\n      var str = this.input.slice(start, this.state.pos).replace(/[_n]/g, \"\");\n      this.finishToken(types.bigint, str);\n      return;\n    }\n\n    this.finishToken(types.num, val);\n  }; // Read an integer, octal integer, or floating-point number.\n\n\n  _proto.readNumber = function readNumber(startsWithDot) {\n    var start = this.state.pos;\n    var octal = this.input.charCodeAt(start) === 0x30; // '0'\n\n    var isFloat = false;\n    var isBigInt = false;\n\n    if (!startsWithDot && this.readInt(10) === null) {\n      this.raise(start, \"Invalid number\");\n    }\n\n    if (octal && this.state.pos == start + 1) octal = false; // number === 0\n\n    var next = this.input.charCodeAt(this.state.pos);\n\n    if (next === 0x2e && !octal) {\n      // '.'\n      ++this.state.pos;\n      this.readInt(10);\n      isFloat = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n\n    if ((next === 0x45 || next === 0x65) && !octal) {\n      // 'Ee'\n      next = this.input.charCodeAt(++this.state.pos);\n      if (next === 0x2b || next === 0x2d) ++this.state.pos; // '+-'\n\n      if (this.readInt(10) === null) this.raise(start, \"Invalid number\");\n      isFloat = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n\n    if (this.hasPlugin(\"bigInt\")) {\n      if (next === 0x6e) {\n        // 'n'\n        // disallow floats and legacy octal syntax, new style octal (\"0o\") is handled in this.readRadixNumber\n        if (isFloat || octal) this.raise(start, \"Invalid BigIntLiteral\");\n        ++this.state.pos;\n        isBigInt = true;\n      }\n    }\n\n    if (isIdentifierStart(this.fullCharCodeAtPos())) {\n      this.raise(this.state.pos, \"Identifier directly after number\");\n    } // remove \"_\" for numeric literal separator, and \"n\" for BigInts\n\n\n    var str = this.input.slice(start, this.state.pos).replace(/[_n]/g, \"\");\n\n    if (isBigInt) {\n      this.finishToken(types.bigint, str);\n      return;\n    }\n\n    var val;\n\n    if (isFloat) {\n      val = parseFloat(str);\n    } else if (!octal || str.length === 1) {\n      val = parseInt(str, 10);\n    } else if (this.state.strict) {\n      this.raise(start, \"Invalid number\");\n    } else if (/[89]/.test(str)) {\n      val = parseInt(str, 10);\n    } else {\n      val = parseInt(str, 8);\n    }\n\n    this.finishToken(types.num, val);\n  }; // Read a string value, interpreting backslash-escapes.\n\n\n  _proto.readCodePoint = function readCodePoint(throwOnInvalid) {\n    var ch = this.input.charCodeAt(this.state.pos);\n    var code;\n\n    if (ch === 123) {\n      // '{'\n      var codePos = ++this.state.pos;\n      code = this.readHexChar(this.input.indexOf(\"}\", this.state.pos) - this.state.pos, throwOnInvalid);\n      ++this.state.pos;\n\n      if (code === null) {\n        // $FlowFixMe (is this always non-null?)\n        --this.state.invalidTemplateEscapePosition; // to point to the '\\'' instead of the 'u'\n      } else if (code > 0x10ffff) {\n        if (throwOnInvalid) {\n          this.raise(codePos, \"Code point out of bounds\");\n        } else {\n          this.state.invalidTemplateEscapePosition = codePos - 2;\n          return null;\n        }\n      }\n    } else {\n      code = this.readHexChar(4, throwOnInvalid);\n    }\n\n    return code;\n  };\n\n  _proto.readString = function readString(quote) {\n    var out = \"\",\n        chunkStart = ++this.state.pos;\n\n    for (;;) {\n      if (this.state.pos >= this.input.length) {\n        this.raise(this.state.start, \"Unterminated string constant\");\n      }\n\n      var ch = this.input.charCodeAt(this.state.pos);\n      if (ch === quote) break;\n\n      if (ch === 92) {\n        // '\\'\n        out += this.input.slice(chunkStart, this.state.pos); // $FlowFixMe\n\n        out += this.readEscapedChar(false);\n        chunkStart = this.state.pos;\n      } else {\n        if (isNewLine(ch)) {\n          this.raise(this.state.start, \"Unterminated string constant\");\n        }\n\n        ++this.state.pos;\n      }\n    }\n\n    out += this.input.slice(chunkStart, this.state.pos++);\n    this.finishToken(types.string, out);\n  }; // Reads template string tokens.\n\n\n  _proto.readTmplToken = function readTmplToken() {\n    var out = \"\",\n        chunkStart = this.state.pos,\n        containsInvalid = false;\n\n    for (;;) {\n      if (this.state.pos >= this.input.length) {\n        this.raise(this.state.start, \"Unterminated template\");\n      }\n\n      var ch = this.input.charCodeAt(this.state.pos);\n\n      if (ch === 96 || ch === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {\n        // '`', '${'\n        if (this.state.pos === this.state.start && this.match(types.template)) {\n          if (ch === 36) {\n            this.state.pos += 2;\n            this.finishToken(types.dollarBraceL);\n            return;\n          } else {\n            ++this.state.pos;\n            this.finishToken(types.backQuote);\n            return;\n          }\n        }\n\n        out += this.input.slice(chunkStart, this.state.pos);\n        this.finishToken(types.template, containsInvalid ? null : out);\n        return;\n      }\n\n      if (ch === 92) {\n        // '\\'\n        out += this.input.slice(chunkStart, this.state.pos);\n        var escaped = this.readEscapedChar(true);\n\n        if (escaped === null) {\n          containsInvalid = true;\n        } else {\n          out += escaped;\n        }\n\n        chunkStart = this.state.pos;\n      } else if (isNewLine(ch)) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        ++this.state.pos;\n\n        switch (ch) {\n          case 13:\n            if (this.input.charCodeAt(this.state.pos) === 10) ++this.state.pos;\n\n          case 10:\n            out += \"\\n\";\n            break;\n\n          default:\n            out += String.fromCharCode(ch);\n            break;\n        }\n\n        ++this.state.curLine;\n        this.state.lineStart = this.state.pos;\n        chunkStart = this.state.pos;\n      } else {\n        ++this.state.pos;\n      }\n    }\n  }; // Used to read escaped characters\n\n\n  _proto.readEscapedChar = function readEscapedChar(inTemplate) {\n    var throwOnInvalid = !inTemplate;\n    var ch = this.input.charCodeAt(++this.state.pos);\n    ++this.state.pos;\n\n    switch (ch) {\n      case 110:\n        return \"\\n\";\n      // 'n' -> '\\n'\n\n      case 114:\n        return \"\\r\";\n      // 'r' -> '\\r'\n\n      case 120:\n        {\n          // 'x'\n          var code = this.readHexChar(2, throwOnInvalid);\n          return code === null ? null : String.fromCharCode(code);\n        }\n\n      case 117:\n        {\n          // 'u'\n          var _code = this.readCodePoint(throwOnInvalid);\n\n          return _code === null ? null : codePointToString(_code);\n        }\n\n      case 116:\n        return \"\\t\";\n      // 't' -> '\\t'\n\n      case 98:\n        return \"\\b\";\n      // 'b' -> '\\b'\n\n      case 118:\n        return \"\\u000b\";\n      // 'v' -> '\\u000b'\n\n      case 102:\n        return \"\\f\";\n      // 'f' -> '\\f'\n\n      case 13:\n        if (this.input.charCodeAt(this.state.pos) === 10) ++this.state.pos;\n      // '\\r\\n'\n\n      case 10:\n        // ' \\n'\n        this.state.lineStart = this.state.pos;\n        ++this.state.curLine;\n        return \"\";\n\n      default:\n        if (ch >= 48 && ch <= 55) {\n          var codePos = this.state.pos - 1; // $FlowFixMe\n\n          var octalStr = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/)[0];\n          var octal = parseInt(octalStr, 8);\n\n          if (octal > 255) {\n            octalStr = octalStr.slice(0, -1);\n            octal = parseInt(octalStr, 8);\n          }\n\n          if (octal > 0) {\n            if (inTemplate) {\n              this.state.invalidTemplateEscapePosition = codePos;\n              return null;\n            } else if (this.state.strict) {\n              this.raise(codePos, \"Octal literal in strict mode\");\n            } else if (!this.state.containsOctal) {\n              // These properties are only used to throw an error for an octal which occurs\n              // in a directive which occurs prior to a \"use strict\" directive.\n              this.state.containsOctal = true;\n              this.state.octalPosition = codePos;\n            }\n          }\n\n          this.state.pos += octalStr.length - 1;\n          return String.fromCharCode(octal);\n        }\n\n        return String.fromCharCode(ch);\n    }\n  }; // Used to read character escape sequences ('\\x', '\\u').\n\n\n  _proto.readHexChar = function readHexChar(len, throwOnInvalid) {\n    var codePos = this.state.pos;\n    var n = this.readInt(16, len);\n\n    if (n === null) {\n      if (throwOnInvalid) {\n        this.raise(codePos, \"Bad character escape sequence\");\n      } else {\n        this.state.pos = codePos - 1;\n        this.state.invalidTemplateEscapePosition = codePos - 1;\n      }\n    }\n\n    return n;\n  }; // Read an identifier, and return it as a string. Sets `this.state.containsEsc`\n  // to whether the word contained a '\\u' escape.\n  //\n  // Incrementally adds only escaped chars, adding other chunks as-is\n  // as a micro-optimization.\n\n\n  _proto.readWord1 = function readWord1() {\n    this.state.containsEsc = false;\n    var word = \"\",\n        first = true,\n        chunkStart = this.state.pos;\n\n    while (this.state.pos < this.input.length) {\n      var ch = this.fullCharCodeAtPos();\n\n      if (isIdentifierChar(ch)) {\n        this.state.pos += ch <= 0xffff ? 1 : 2;\n      } else if (ch === 92) {\n        // \"\\\"\n        this.state.containsEsc = true;\n        word += this.input.slice(chunkStart, this.state.pos);\n        var escStart = this.state.pos;\n\n        if (this.input.charCodeAt(++this.state.pos) !== 117) {\n          // \"u\"\n          this.raise(this.state.pos, \"Expecting Unicode escape sequence \\\\uXXXX\");\n        }\n\n        ++this.state.pos;\n        var esc = this.readCodePoint(true); // $FlowFixMe (thinks esc may be null, but throwOnInvalid is true)\n\n        if (!(first ? isIdentifierStart : isIdentifierChar)(esc, true)) {\n          this.raise(escStart, \"Invalid Unicode escape\");\n        } // $FlowFixMe\n\n\n        word += codePointToString(esc);\n        chunkStart = this.state.pos;\n      } else {\n        break;\n      }\n\n      first = false;\n    }\n\n    return word + this.input.slice(chunkStart, this.state.pos);\n  }; // Read an identifier or keyword token. Will check for reserved\n  // words when necessary.\n\n\n  _proto.readWord = function readWord() {\n    var word = this.readWord1();\n    var type = types.name;\n\n    if (this.isKeyword(word)) {\n      if (this.state.containsEsc) {\n        this.raise(this.state.pos, `Escape sequence in keyword ${word}`);\n      }\n\n      type = keywords[word];\n    }\n\n    this.finishToken(type, word);\n  };\n\n  _proto.braceIsBlock = function braceIsBlock(prevType) {\n    if (prevType === types.colon) {\n      var parent = this.curContext();\n\n      if (parent === types$1.braceStatement || parent === types$1.braceExpression) {\n        return !parent.isExpr;\n      }\n    }\n\n    if (prevType === types._return) {\n      return lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));\n    }\n\n    if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR) {\n      return true;\n    }\n\n    if (prevType === types.braceL) {\n      return this.curContext() === types$1.braceStatement;\n    }\n\n    if (prevType === types.relational) {\n      // `class C<T> { ... }`\n      return true;\n    }\n\n    return !this.state.exprAllowed;\n  };\n\n  _proto.updateContext = function updateContext(prevType) {\n    var type = this.state.type;\n    var update;\n\n    if (type.keyword && (prevType === types.dot || prevType === types.questionDot)) {\n      this.state.exprAllowed = false;\n    } else if (update = type.updateContext) {\n      update.call(this, prevType);\n    } else {\n      this.state.exprAllowed = type.beforeExpr;\n    }\n  };\n\n  return Tokenizer;\n}(LocationParser);\n\nvar UtilParser =\n/*#__PURE__*/\nfunction (_Tokenizer) {\n  _inheritsLoose(UtilParser, _Tokenizer);\n\n  function UtilParser() {\n    return _Tokenizer.apply(this, arguments) || this;\n  }\n\n  var _proto = UtilParser.prototype;\n\n  // TODO\n  _proto.addExtra = function addExtra(node, key, val) {\n    if (!node) return;\n    var extra = node.extra = node.extra || {};\n    extra[key] = val;\n  }; // TODO\n\n\n  _proto.isRelational = function isRelational(op) {\n    return this.match(types.relational) && this.state.value === op;\n  }; // TODO\n\n\n  _proto.expectRelational = function expectRelational(op) {\n    if (this.isRelational(op)) {\n      this.next();\n    } else {\n      this.unexpected(null, types.relational);\n    }\n  }; // eat() for relational operators.\n\n\n  _proto.eatRelational = function eatRelational(op) {\n    if (this.isRelational(op)) {\n      this.next();\n      return true;\n    }\n\n    return false;\n  }; // Tests whether parsed token is a contextual keyword.\n\n\n  _proto.isContextual = function isContextual(name) {\n    return this.match(types.name) && this.state.value === name;\n  };\n\n  _proto.isLookaheadContextual = function isLookaheadContextual(name) {\n    var l = this.lookahead();\n    return l.type === types.name && l.value === name;\n  }; // Consumes contextual keyword if possible.\n\n\n  _proto.eatContextual = function eatContextual(name) {\n    return this.state.value === name && this.eat(types.name);\n  }; // Asserts that following token is given contextual keyword.\n\n\n  _proto.expectContextual = function expectContextual(name, message) {\n    if (!this.eatContextual(name)) this.unexpected(null, message);\n  }; // Test whether a semicolon can be inserted at the current position.\n\n\n  _proto.canInsertSemicolon = function canInsertSemicolon() {\n    return this.match(types.eof) || this.match(types.braceR) || this.hasPrecedingLineBreak();\n  };\n\n  _proto.hasPrecedingLineBreak = function hasPrecedingLineBreak() {\n    return lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));\n  }; // TODO\n\n\n  _proto.isLineTerminator = function isLineTerminator() {\n    return this.eat(types.semi) || this.canInsertSemicolon();\n  }; // Consume a semicolon, or, failing that, see if we are allowed to\n  // pretend that there is a semicolon at this position.\n\n\n  _proto.semicolon = function semicolon() {\n    if (!this.isLineTerminator()) this.unexpected(null, types.semi);\n  }; // Expect a token of a given type. If found, consume it, otherwise,\n  // raise an unexpected token error at given pos.\n\n\n  _proto.expect = function expect(type, pos) {\n    this.eat(type) || this.unexpected(pos, type);\n  }; // Raise an unexpected token error. Can take the expected token type\n  // instead of a message string.\n\n\n  _proto.unexpected = function unexpected(pos, messageOrType) {\n    if (messageOrType === void 0) {\n      messageOrType = \"Unexpected token\";\n    }\n\n    if (typeof messageOrType !== \"string\") {\n      messageOrType = `Unexpected token, expected ${messageOrType.label}`;\n    }\n\n    throw this.raise(pos != null ? pos : this.state.start, messageOrType);\n  };\n\n  _proto.expectPlugin = function expectPlugin(name, pos) {\n    if (!this.hasPlugin(name)) {\n      throw this.raise(pos != null ? pos : this.state.start, `This experimental syntax requires enabling the parser plugin: '${name}'`, [name]);\n    }\n\n    return true;\n  };\n\n  _proto.expectOnePlugin = function expectOnePlugin(names, pos) {\n    var _this = this;\n\n    if (!names.some(function (n) {\n      return _this.hasPlugin(n);\n    })) {\n      throw this.raise(pos != null ? pos : this.state.start, `This experimental syntax requires enabling one of the following parser plugin(s): '${names.join(\", \")}'`, names);\n    }\n  };\n\n  return UtilParser;\n}(Tokenizer);\n\n// Start an AST node, attaching a start offset.\nvar commentKeys = [\"leadingComments\", \"trailingComments\", \"innerComments\"];\n\nvar Node =\n/*#__PURE__*/\nfunction () {\n  function Node(parser, pos, loc) {\n    this.type = \"\";\n    this.start = pos;\n    this.end = 0;\n    this.loc = new SourceLocation(loc);\n    if (parser && parser.options.ranges) this.range = [pos, 0];\n    if (parser && parser.filename) this.loc.filename = parser.filename;\n  }\n\n  var _proto = Node.prototype;\n\n  _proto.__clone = function __clone() {\n    var _this = this;\n\n    // $FlowIgnore\n    var node2 = new Node();\n    Object.keys(this).forEach(function (key) {\n      // Do not clone comments that are already attached to the node\n      if (commentKeys.indexOf(key) < 0) {\n        // $FlowIgnore\n        node2[key] = _this[key];\n      }\n    });\n    return node2;\n  };\n\n  return Node;\n}();\n\nvar NodeUtils =\n/*#__PURE__*/\nfunction (_UtilParser) {\n  _inheritsLoose(NodeUtils, _UtilParser);\n\n  function NodeUtils() {\n    return _UtilParser.apply(this, arguments) || this;\n  }\n\n  var _proto2 = NodeUtils.prototype;\n\n  _proto2.startNode = function startNode() {\n    // $FlowIgnore\n    return new Node(this, this.state.start, this.state.startLoc);\n  };\n\n  _proto2.startNodeAt = function startNodeAt(pos, loc) {\n    // $FlowIgnore\n    return new Node(this, pos, loc);\n  };\n  /** Start a new node with a previous node's location. */\n\n\n  _proto2.startNodeAtNode = function startNodeAtNode(type) {\n    return this.startNodeAt(type.start, type.loc.start);\n  }; // Finish an AST node, adding `type` and `end` properties.\n\n\n  _proto2.finishNode = function finishNode(node, type) {\n    return this.finishNodeAt(node, type, this.state.lastTokEnd, this.state.lastTokEndLoc);\n  }; // Finish node at given position\n\n\n  _proto2.finishNodeAt = function finishNodeAt(node, type, pos, loc) {\n    node.type = type;\n    node.end = pos;\n    node.loc.end = loc;\n    if (this.options.ranges) node.range[1] = pos;\n    this.processComment(node);\n    return node;\n  };\n  /**\n   * Reset the start location of node to the start location of locationNode\n   */\n\n\n  _proto2.resetStartLocationFromNode = function resetStartLocationFromNode(node, locationNode) {\n    node.start = locationNode.start;\n    node.loc.start = locationNode.loc.start;\n    if (this.options.ranges) node.range[0] = locationNode.range[0];\n  };\n\n  return NodeUtils;\n}(UtilParser);\n\nvar LValParser =\n/*#__PURE__*/\nfunction (_NodeUtils) {\n  _inheritsLoose(LValParser, _NodeUtils);\n\n  function LValParser() {\n    return _NodeUtils.apply(this, arguments) || this;\n  }\n\n  var _proto = LValParser.prototype;\n\n  // Forward-declaration: defined in expression.js\n  // Forward-declaration: defined in statement.js\n  // Convert existing expression atom to assignable pattern\n  // if possible.\n  _proto.toAssignable = function toAssignable(node, isBinding, contextDescription) {\n    if (node) {\n      switch (node.type) {\n        case \"Identifier\":\n        case \"ObjectPattern\":\n        case \"ArrayPattern\":\n        case \"AssignmentPattern\":\n          break;\n\n        case \"ObjectExpression\":\n          node.type = \"ObjectPattern\";\n\n          for (var index = 0; index < node.properties.length; index++) {\n            var prop = node.properties[index];\n            var isLast = index === node.properties.length - 1;\n            this.toAssignableObjectExpressionProp(prop, isBinding, isLast);\n          }\n\n          break;\n\n        case \"ObjectProperty\":\n          this.toAssignable(node.value, isBinding, contextDescription);\n          break;\n\n        case \"SpreadElement\":\n          {\n            this.checkToRestConversion(node);\n            node.type = \"RestElement\";\n            var arg = node.argument;\n            this.toAssignable(arg, isBinding, contextDescription);\n            break;\n          }\n\n        case \"ArrayExpression\":\n          node.type = \"ArrayPattern\";\n          this.toAssignableList(node.elements, isBinding, contextDescription);\n          break;\n\n        case \"AssignmentExpression\":\n          if (node.operator === \"=\") {\n            node.type = \"AssignmentPattern\";\n            delete node.operator;\n          } else {\n            this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\");\n          }\n\n          break;\n\n        case \"MemberExpression\":\n          if (!isBinding) break;\n\n        default:\n          {\n            var message = \"Invalid left-hand side\" + (contextDescription ? \" in \" + contextDescription :\n            /* istanbul ignore next */\n            \"expression\");\n            this.raise(node.start, message);\n          }\n      }\n    }\n\n    return node;\n  };\n\n  _proto.toAssignableObjectExpressionProp = function toAssignableObjectExpressionProp(prop, isBinding, isLast) {\n    if (prop.type === \"ObjectMethod\") {\n      var error = prop.kind === \"get\" || prop.kind === \"set\" ? \"Object pattern can't contain getter or setter\" : \"Object pattern can't contain methods\";\n      this.raise(prop.key.start, error);\n    } else if (prop.type === \"SpreadElement\" && !isLast) {\n      this.raise(prop.start, \"The rest element has to be the last element when destructuring\");\n    } else {\n      this.toAssignable(prop, isBinding, \"object destructuring pattern\");\n    }\n  }; // Convert list of expression atoms to binding list.\n\n\n  _proto.toAssignableList = function toAssignableList(exprList, isBinding, contextDescription) {\n    var end = exprList.length;\n\n    if (end) {\n      var last = exprList[end - 1];\n\n      if (last && last.type === \"RestElement\") {\n        --end;\n      } else if (last && last.type === \"SpreadElement\") {\n        last.type = \"RestElement\";\n        var arg = last.argument;\n        this.toAssignable(arg, isBinding, contextDescription);\n\n        if (arg.type !== \"Identifier\" && arg.type !== \"MemberExpression\" && arg.type !== \"ArrayPattern\") {\n          this.unexpected(arg.start);\n        }\n\n        --end;\n      }\n    }\n\n    for (var i = 0; i < end; i++) {\n      var elt = exprList[i];\n\n      if (elt && elt.type === \"SpreadElement\") {\n        this.raise(elt.start, \"The rest element has to be the last element when destructuring\");\n      }\n\n      if (elt) this.toAssignable(elt, isBinding, contextDescription);\n    }\n\n    return exprList;\n  }; // Convert list of expression atoms to a list of\n\n\n  _proto.toReferencedList = function toReferencedList(exprList) {\n    return exprList;\n  }; // Parses spread element.\n\n\n  _proto.parseSpread = function parseSpread(refShorthandDefaultPos) {\n    var node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeAssign(false, refShorthandDefaultPos);\n    return this.finishNode(node, \"SpreadElement\");\n  };\n\n  _proto.parseRest = function parseRest() {\n    var node = this.startNode();\n    this.next();\n    node.argument = this.parseBindingAtom();\n    return this.finishNode(node, \"RestElement\");\n  };\n\n  _proto.shouldAllowYieldIdentifier = function shouldAllowYieldIdentifier() {\n    return this.match(types._yield) && !this.state.strict && !this.state.inGenerator;\n  };\n\n  _proto.parseBindingIdentifier = function parseBindingIdentifier() {\n    return this.parseIdentifier(this.shouldAllowYieldIdentifier());\n  }; // Parses lvalue (assignable) atom.\n\n\n  _proto.parseBindingAtom = function parseBindingAtom() {\n    switch (this.state.type) {\n      case types._yield:\n      case types.name:\n        return this.parseBindingIdentifier();\n\n      case types.bracketL:\n        {\n          var node = this.startNode();\n          this.next();\n          node.elements = this.parseBindingList(types.bracketR, true);\n          return this.finishNode(node, \"ArrayPattern\");\n        }\n\n      case types.braceL:\n        return this.parseObj(true);\n\n      default:\n        throw this.unexpected();\n    }\n  };\n\n  _proto.parseBindingList = function parseBindingList(close, allowEmpty, allowModifiers) {\n    var elts = [];\n    var first = true;\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(types.comma);\n      }\n\n      if (allowEmpty && this.match(types.comma)) {\n        // $FlowFixMe This method returns `$ReadOnlyArray<?Pattern>` if `allowEmpty` is set.\n        elts.push(null);\n      } else if (this.eat(close)) {\n        break;\n      } else if (this.match(types.ellipsis)) {\n        elts.push(this.parseAssignableListItemTypes(this.parseRest()));\n        this.expect(close);\n        break;\n      } else {\n        var decorators = [];\n\n        if (this.match(types.at) && this.hasPlugin(\"decorators2\")) {\n          this.raise(this.state.start, \"Stage 2 decorators cannot be used to decorate parameters\");\n        }\n\n        while (this.match(types.at)) {\n          decorators.push(this.parseDecorator());\n        }\n\n        elts.push(this.parseAssignableListItem(allowModifiers, decorators));\n      }\n    }\n\n    return elts;\n  };\n\n  _proto.parseAssignableListItem = function parseAssignableListItem(allowModifiers, decorators) {\n    var left = this.parseMaybeDefault();\n    this.parseAssignableListItemTypes(left);\n    var elt = this.parseMaybeDefault(left.start, left.loc.start, left);\n\n    if (decorators.length) {\n      left.decorators = decorators;\n    }\n\n    return elt;\n  };\n\n  _proto.parseAssignableListItemTypes = function parseAssignableListItemTypes(param) {\n    return param;\n  }; // Parses assignment pattern around given atom if possible.\n\n\n  _proto.parseMaybeDefault = function parseMaybeDefault(startPos, startLoc, left) {\n    startLoc = startLoc || this.state.startLoc;\n    startPos = startPos || this.state.start;\n    left = left || this.parseBindingAtom();\n    if (!this.eat(types.eq)) return left;\n    var node = this.startNodeAt(startPos, startLoc);\n    node.left = left;\n    node.right = this.parseMaybeAssign();\n    return this.finishNode(node, \"AssignmentPattern\");\n  }; // Verify that a node is an lval — something that can be assigned\n  // to.\n\n\n  _proto.checkLVal = function checkLVal(expr, isBinding, checkClashes, contextDescription) {\n    switch (expr.type) {\n      case \"Identifier\":\n        this.checkReservedWord(expr.name, expr.start, false, true);\n\n        if (checkClashes) {\n          // we need to prefix this with an underscore for the cases where we have a key of\n          // `__proto__`. there's a bug in old V8 where the following wouldn't work:\n          //\n          //   > var obj = Object.create(null);\n          //   undefined\n          //   > obj.__proto__\n          //   null\n          //   > obj.__proto__ = true;\n          //   true\n          //   > obj.__proto__\n          //   null\n          var _key = `_${expr.name}`;\n\n          if (checkClashes[_key]) {\n            this.raise(expr.start, \"Argument name clash in strict mode\");\n          } else {\n            checkClashes[_key] = true;\n          }\n        }\n\n        break;\n\n      case \"MemberExpression\":\n        if (isBinding) this.raise(expr.start, \"Binding member expression\");\n        break;\n\n      case \"ObjectPattern\":\n        for (var _i2 = 0, _expr$properties2 = expr.properties; _i2 < _expr$properties2.length; _i2++) {\n          var prop = _expr$properties2[_i2];\n          if (prop.type === \"ObjectProperty\") prop = prop.value;\n          this.checkLVal(prop, isBinding, checkClashes, \"object destructuring pattern\");\n        }\n\n        break;\n\n      case \"ArrayPattern\":\n        for (var _i4 = 0, _expr$elements2 = expr.elements; _i4 < _expr$elements2.length; _i4++) {\n          var elem = _expr$elements2[_i4];\n\n          if (elem) {\n            this.checkLVal(elem, isBinding, checkClashes, \"array destructuring pattern\");\n          }\n        }\n\n        break;\n\n      case \"AssignmentPattern\":\n        this.checkLVal(expr.left, isBinding, checkClashes, \"assignment pattern\");\n        break;\n\n      case \"RestElement\":\n        this.checkLVal(expr.argument, isBinding, checkClashes, \"rest element\");\n        break;\n\n      default:\n        {\n          var message = (isBinding ?\n          /* istanbul ignore next */\n          \"Binding invalid\" : \"Invalid\") + \" left-hand side\" + (contextDescription ? \" in \" + contextDescription :\n          /* istanbul ignore next */\n          \"expression\");\n          this.raise(expr.start, message);\n        }\n    }\n  };\n\n  _proto.checkToRestConversion = function checkToRestConversion(node) {\n    var validArgumentTypes = [\"Identifier\", \"MemberExpression\"];\n\n    if (validArgumentTypes.indexOf(node.argument.type) !== -1) {\n      return;\n    }\n\n    this.raise(node.argument.start, \"Invalid rest operator's argument\");\n  };\n\n  return LValParser;\n}(NodeUtils);\n\n/* eslint max-len: 0 */\n// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts — that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\nvar ExpressionParser =\n/*#__PURE__*/\nfunction (_LValParser) {\n  _inheritsLoose(ExpressionParser, _LValParser);\n\n  function ExpressionParser() {\n    return _LValParser.apply(this, arguments) || this;\n  }\n\n  var _proto = ExpressionParser.prototype;\n\n  // Forward-declaration: defined in statement.js\n  // Check if property name clashes with already added.\n  // Object/class getters and setters are not allowed to clash —\n  // either with each other or with an init property — and in\n  // strict mode, init properties are also not allowed to be repeated.\n  _proto.checkPropClash = function checkPropClash(prop, propHash) {\n    if (prop.computed || prop.kind) return;\n    var key = prop.key; // It is either an Identifier or a String/NumericLiteral\n\n    var name = key.type === \"Identifier\" ? key.name : String(key.value);\n\n    if (name === \"__proto__\") {\n      if (propHash.proto) {\n        this.raise(key.start, \"Redefinition of __proto__ property\");\n      }\n\n      propHash.proto = true;\n    }\n  }; // Convenience method to parse an Expression only\n\n\n  _proto.getExpression = function getExpression() {\n    this.nextToken();\n    var expr = this.parseExpression();\n\n    if (!this.match(types.eof)) {\n      this.unexpected();\n    }\n\n    expr.comments = this.state.comments;\n    return expr;\n  }; // ### Expression parsing\n  // These nest, from the most general expression type at the top to\n  // 'atomic', nondivisible expression types at the bottom. Most of\n  // the functions will simply let the function (s) below them parse,\n  // and, *if* the syntactic construct they handle is present, wrap\n  // the AST node that the inner parser gave them in another node.\n  // Parse a full expression. The optional arguments are used to\n  // forbid the `in` operator (in for loops initialization expressions)\n  // and provide reference for storing '=' operator inside shorthand\n  // property assignment in contexts where both object expression\n  // and object pattern might appear (so it's possible to raise\n  // delayed syntax error at correct position).\n\n\n  _proto.parseExpression = function parseExpression(noIn, refShorthandDefaultPos) {\n    var startPos = this.state.start;\n    var startLoc = this.state.startLoc;\n    var expr = this.parseMaybeAssign(noIn, refShorthandDefaultPos);\n\n    if (this.match(types.comma)) {\n      var _node = this.startNodeAt(startPos, startLoc);\n\n      _node.expressions = [expr];\n\n      while (this.eat(types.comma)) {\n        _node.expressions.push(this.parseMaybeAssign(noIn, refShorthandDefaultPos));\n      }\n\n      this.toReferencedList(_node.expressions);\n      return this.finishNode(_node, \"SequenceExpression\");\n    }\n\n    return expr;\n  }; // Parse an assignment expression. This includes applications of\n  // operators like `+=`.\n\n\n  _proto.parseMaybeAssign = function parseMaybeAssign(noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos) {\n    var startPos = this.state.start;\n    var startLoc = this.state.startLoc;\n\n    if (this.match(types._yield) && this.state.inGenerator) {\n      var _left = this.parseYield();\n\n      if (afterLeftParse) {\n        _left = afterLeftParse.call(this, _left, startPos, startLoc);\n      }\n\n      return _left;\n    }\n\n    var failOnShorthandAssign;\n\n    if (refShorthandDefaultPos) {\n      failOnShorthandAssign = false;\n    } else {\n      refShorthandDefaultPos = {\n        start: 0\n      };\n      failOnShorthandAssign = true;\n    }\n\n    if (this.match(types.parenL) || this.match(types.name) || this.match(types._yield)) {\n      this.state.potentialArrowAt = this.state.start;\n    }\n\n    var left = this.parseMaybeConditional(noIn, refShorthandDefaultPos, refNeedsArrowPos);\n\n    if (afterLeftParse) {\n      left = afterLeftParse.call(this, left, startPos, startLoc);\n    }\n\n    if (this.state.type.isAssign) {\n      var _node2 = this.startNodeAt(startPos, startLoc);\n\n      _node2.operator = this.state.value;\n      _node2.left = this.match(types.eq) ? this.toAssignable(left, undefined, \"assignment expression\") : left;\n      refShorthandDefaultPos.start = 0; // reset because shorthand default was used correctly\n\n      this.checkLVal(left, undefined, undefined, \"assignment expression\");\n\n      if (left.extra && left.extra.parenthesized) {\n        var errorMsg;\n\n        if (left.type === \"ObjectPattern\") {\n          errorMsg = \"`({a}) = 0` use `({a} = 0)`\";\n        } else if (left.type === \"ArrayPattern\") {\n          errorMsg = \"`([a]) = 0` use `([a] = 0)`\";\n        }\n\n        if (errorMsg) {\n          this.raise(left.start, `You're trying to assign to a parenthesized expression, eg. instead of ${errorMsg}`);\n        }\n      }\n\n      this.next();\n      _node2.right = this.parseMaybeAssign(noIn);\n      return this.finishNode(_node2, \"AssignmentExpression\");\n    } else if (failOnShorthandAssign && refShorthandDefaultPos.start) {\n      this.unexpected(refShorthandDefaultPos.start);\n    }\n\n    return left;\n  }; // Parse a ternary conditional (`?:`) operator.\n\n\n  _proto.parseMaybeConditional = function parseMaybeConditional(noIn, refShorthandDefaultPos, refNeedsArrowPos) {\n    var startPos = this.state.start;\n    var startLoc = this.state.startLoc;\n    var potentialArrowAt = this.state.potentialArrowAt;\n    var expr = this.parseExprOps(noIn, refShorthandDefaultPos);\n\n    if (expr.type === \"ArrowFunctionExpression\" && expr.start === potentialArrowAt) {\n      return expr;\n    }\n\n    if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;\n    return this.parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos);\n  };\n\n  _proto.parseConditional = function parseConditional(expr, noIn, startPos, startLoc, // FIXME: Disabling this for now since can't seem to get it to play nicely\n  refNeedsArrowPos) {\n    if (this.eat(types.question)) {\n      var _node3 = this.startNodeAt(startPos, startLoc);\n\n      _node3.test = expr;\n      _node3.consequent = this.parseMaybeAssign();\n      this.expect(types.colon);\n      _node3.alternate = this.parseMaybeAssign(noIn);\n      return this.finishNode(_node3, \"ConditionalExpression\");\n    }\n\n    return expr;\n  }; // Start the precedence parser.\n\n\n  _proto.parseExprOps = function parseExprOps(noIn, refShorthandDefaultPos) {\n    var startPos = this.state.start;\n    var startLoc = this.state.startLoc;\n    var potentialArrowAt = this.state.potentialArrowAt;\n    var expr = this.parseMaybeUnary(refShorthandDefaultPos);\n\n    if (expr.type === \"ArrowFunctionExpression\" && expr.start === potentialArrowAt) {\n      return expr;\n    }\n\n    if (refShorthandDefaultPos && refShorthandDefaultPos.start) {\n      return expr;\n    }\n\n    return this.parseExprOp(expr, startPos, startLoc, -1, noIn);\n  }; // Parse binary operators with the operator precedence parsing\n  // algorithm. `left` is the left-hand side of the operator.\n  // `minPrec` provides context that allows the function to stop and\n  // defer further parser to one of its callers when it encounters an\n  // operator that has a lower precedence than the set it is parsing.\n\n\n  _proto.parseExprOp = function parseExprOp(left, leftStartPos, leftStartLoc, minPrec, noIn) {\n    var prec = this.state.type.binop;\n\n    if (prec != null && (!noIn || !this.match(types._in))) {\n      if (prec > minPrec) {\n        var _node4 = this.startNodeAt(leftStartPos, leftStartLoc);\n\n        _node4.left = left;\n        _node4.operator = this.state.value;\n\n        if (_node4.operator === \"**\" && left.type === \"UnaryExpression\" && left.extra && !left.extra.parenthesizedArgument && !left.extra.parenthesized) {\n          this.raise(left.argument.start, \"Illegal expression. Wrap left hand side or entire exponentiation in parentheses.\");\n        }\n\n        var op = this.state.type;\n        this.next();\n        var startPos = this.state.start;\n        var startLoc = this.state.startLoc;\n\n        if (_node4.operator === \"|>\") {\n          this.expectPlugin(\"pipelineOperator\"); // Support syntax such as 10 |> x => x + 1\n\n          this.state.potentialArrowAt = startPos;\n        }\n\n        if (_node4.operator === \"??\") {\n          this.expectPlugin(\"nullishCoalescingOperator\");\n        }\n\n        _node4.right = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, op.rightAssociative ? prec - 1 : prec, noIn);\n        this.finishNode(_node4, op === types.logicalOR || op === types.logicalAND || op === types.nullishCoalescing ? \"LogicalExpression\" : \"BinaryExpression\");\n        return this.parseExprOp(_node4, leftStartPos, leftStartLoc, minPrec, noIn);\n      }\n    }\n\n    return left;\n  }; // Parse unary operators, both prefix and postfix.\n\n\n  _proto.parseMaybeUnary = function parseMaybeUnary(refShorthandDefaultPos) {\n    if (this.state.type.prefix) {\n      var _node5 = this.startNode();\n\n      var update = this.match(types.incDec);\n      _node5.operator = this.state.value;\n      _node5.prefix = true;\n\n      if (_node5.operator === \"throw\") {\n        this.expectPlugin(\"throwExpressions\");\n      }\n\n      this.next();\n      var argType = this.state.type;\n      _node5.argument = this.parseMaybeUnary();\n      this.addExtra(_node5, \"parenthesizedArgument\", argType === types.parenL && (!_node5.argument.extra || !_node5.argument.extra.parenthesized));\n\n      if (refShorthandDefaultPos && refShorthandDefaultPos.start) {\n        this.unexpected(refShorthandDefaultPos.start);\n      }\n\n      if (update) {\n        this.checkLVal(_node5.argument, undefined, undefined, \"prefix operation\");\n      } else if (this.state.strict && _node5.operator === \"delete\") {\n        var arg = _node5.argument;\n\n        if (arg.type === \"Identifier\") {\n          this.raise(_node5.start, \"Deleting local variable in strict mode\");\n        } else if (arg.type === \"MemberExpression\" && arg.property.type === \"PrivateName\") {\n          this.raise(_node5.start, \"Deleting a private field is not allowed\");\n        }\n      }\n\n      return this.finishNode(_node5, update ? \"UpdateExpression\" : \"UnaryExpression\");\n    }\n\n    var startPos = this.state.start;\n    var startLoc = this.state.startLoc;\n    var expr = this.parseExprSubscripts(refShorthandDefaultPos);\n    if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;\n\n    while (this.state.type.postfix && !this.canInsertSemicolon()) {\n      var _node6 = this.startNodeAt(startPos, startLoc);\n\n      _node6.operator = this.state.value;\n      _node6.prefix = false;\n      _node6.argument = expr;\n      this.checkLVal(expr, undefined, undefined, \"postfix operation\");\n      this.next();\n      expr = this.finishNode(_node6, \"UpdateExpression\");\n    }\n\n    return expr;\n  }; // Parse call, dot, and `[]`-subscript expressions.\n\n\n  _proto.parseExprSubscripts = function parseExprSubscripts(refShorthandDefaultPos) {\n    var startPos = this.state.start;\n    var startLoc = this.state.startLoc;\n    var potentialArrowAt = this.state.potentialArrowAt;\n    var expr = this.parseExprAtom(refShorthandDefaultPos);\n\n    if (expr.type === \"ArrowFunctionExpression\" && expr.start === potentialArrowAt) {\n      return expr;\n    }\n\n    if (refShorthandDefaultPos && refShorthandDefaultPos.start) {\n      return expr;\n    }\n\n    return this.parseSubscripts(expr, startPos, startLoc);\n  };\n\n  _proto.parseSubscripts = function parseSubscripts(base, startPos, startLoc, noCalls) {\n    var state = {\n      stop: false\n    };\n\n    do {\n      base = this.parseSubscript(base, startPos, startLoc, noCalls, state);\n    } while (!state.stop);\n\n    return base;\n  };\n  /** @param state Set 'state.stop = true' to indicate that we should stop parsing subscripts. */\n\n\n  _proto.parseSubscript = function parseSubscript(base, startPos, startLoc, noCalls, state) {\n    if (!noCalls && this.eat(types.doubleColon)) {\n      var _node7 = this.startNodeAt(startPos, startLoc);\n\n      _node7.object = base;\n      _node7.callee = this.parseNoCallExpr();\n      state.stop = true;\n      return this.parseSubscripts(this.finishNode(_node7, \"BindExpression\"), startPos, startLoc, noCalls);\n    } else if (this.match(types.questionDot)) {\n      this.expectPlugin(\"optionalChaining\");\n\n      if (noCalls && this.lookahead().type == types.parenL) {\n        state.stop = true;\n        return base;\n      }\n\n      this.next();\n\n      var _node8 = this.startNodeAt(startPos, startLoc);\n\n      if (this.eat(types.bracketL)) {\n        _node8.object = base;\n        _node8.property = this.parseExpression();\n        _node8.computed = true;\n        _node8.optional = true;\n        this.expect(types.bracketR);\n        return this.finishNode(_node8, \"MemberExpression\");\n      } else if (this.eat(types.parenL)) {\n        var possibleAsync = this.atPossibleAsync(base);\n        _node8.callee = base;\n        _node8.arguments = this.parseCallExpressionArguments(types.parenR, possibleAsync);\n        _node8.optional = true;\n        return this.finishNode(_node8, \"CallExpression\");\n      } else {\n        _node8.object = base;\n        _node8.property = this.parseIdentifier(true);\n        _node8.computed = false;\n        _node8.optional = true;\n        return this.finishNode(_node8, \"MemberExpression\");\n      }\n    } else if (this.eat(types.dot)) {\n      var _node9 = this.startNodeAt(startPos, startLoc);\n\n      _node9.object = base;\n      _node9.property = this.parseMaybePrivateName();\n      _node9.computed = false;\n      return this.finishNode(_node9, \"MemberExpression\");\n    } else if (this.eat(types.bracketL)) {\n      var _node10 = this.startNodeAt(startPos, startLoc);\n\n      _node10.object = base;\n      _node10.property = this.parseExpression();\n      _node10.computed = true;\n      this.expect(types.bracketR);\n      return this.finishNode(_node10, \"MemberExpression\");\n    } else if (!noCalls && this.match(types.parenL)) {\n      var _possibleAsync = this.atPossibleAsync(base);\n\n      this.next();\n\n      var _node11 = this.startNodeAt(startPos, startLoc);\n\n      _node11.callee = base; // TODO: Clean up/merge this into `this.state` or a class like acorn's\n      // `DestructuringErrors` alongside refShorthandDefaultPos and\n      // refNeedsArrowPos.\n\n      var refTrailingCommaPos = {\n        start: -1\n      };\n      _node11.arguments = this.parseCallExpressionArguments(types.parenR, _possibleAsync, refTrailingCommaPos);\n      this.finishCallExpression(_node11);\n\n      if (_possibleAsync && this.shouldParseAsyncArrow()) {\n        state.stop = true;\n\n        if (refTrailingCommaPos.start > -1) {\n          this.raise(refTrailingCommaPos.start, \"A trailing comma is not permitted after the rest element\");\n        }\n\n        return this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), _node11);\n      } else {\n        this.toReferencedList(_node11.arguments);\n      }\n\n      return _node11;\n    } else if (this.match(types.backQuote)) {\n      var _node12 = this.startNodeAt(startPos, startLoc);\n\n      _node12.tag = base;\n      _node12.quasi = this.parseTemplate(true);\n      return this.finishNode(_node12, \"TaggedTemplateExpression\");\n    } else {\n      state.stop = true;\n      return base;\n    }\n  };\n\n  _proto.atPossibleAsync = function atPossibleAsync(base) {\n    return this.state.potentialArrowAt === base.start && base.type === \"Identifier\" && base.name === \"async\" && !this.canInsertSemicolon();\n  };\n\n  _proto.finishCallExpression = function finishCallExpression(node) {\n    if (node.callee.type === \"Import\") {\n      if (node.arguments.length !== 1) {\n        this.raise(node.start, \"import() requires exactly one argument\");\n      }\n\n      var importArg = node.arguments[0];\n\n      if (importArg && importArg.type === \"SpreadElement\") {\n        this.raise(importArg.start, \"... is not allowed in import()\");\n      }\n    }\n\n    return this.finishNode(node, \"CallExpression\");\n  };\n\n  _proto.parseCallExpressionArguments = function parseCallExpressionArguments(close, possibleAsyncArrow, refTrailingCommaPos) {\n    var elts = [];\n    var innerParenStart;\n    var first = true;\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(types.comma);\n        if (this.eat(close)) break;\n      } // we need to make sure that if this is an async arrow functions, that we don't allow inner parens inside the params\n\n\n      if (this.match(types.parenL) && !innerParenStart) {\n        innerParenStart = this.state.start;\n      }\n\n      elts.push(this.parseExprListItem(false, possibleAsyncArrow ? {\n        start: 0\n      } : undefined, possibleAsyncArrow ? {\n        start: 0\n      } : undefined, possibleAsyncArrow ? refTrailingCommaPos : undefined));\n    } // we found an async arrow function so let's not allow any inner parens\n\n\n    if (possibleAsyncArrow && innerParenStart && this.shouldParseAsyncArrow()) {\n      this.unexpected();\n    }\n\n    return elts;\n  };\n\n  _proto.shouldParseAsyncArrow = function shouldParseAsyncArrow() {\n    return this.match(types.arrow);\n  };\n\n  _proto.parseAsyncArrowFromCallExpression = function parseAsyncArrowFromCallExpression(node, call) {\n    this.expect(types.arrow);\n    return this.parseArrowExpression(node, call.arguments, true);\n  }; // Parse a no-call expression (like argument of `new` or `::` operators).\n\n\n  _proto.parseNoCallExpr = function parseNoCallExpr() {\n    var startPos = this.state.start;\n    var startLoc = this.state.startLoc;\n    return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\n  }; // Parse an atomic expression — either a single token that is an\n  // expression, an expression started by a keyword like `function` or\n  // `new`, or an expression wrapped in punctuation like `()`, `[]`,\n  // or `{}`.\n\n\n  _proto.parseExprAtom = function parseExprAtom(refShorthandDefaultPos) {\n    var canBeArrow = this.state.potentialArrowAt === this.state.start;\n    var node;\n\n    switch (this.state.type) {\n      case types._super:\n        if (!this.state.inMethod && !this.state.inClassProperty && !this.options.allowSuperOutsideMethod) {\n          this.raise(this.state.start, \"'super' outside of function or class\");\n        }\n\n        node = this.startNode();\n        this.next();\n\n        if (!this.match(types.parenL) && !this.match(types.bracketL) && !this.match(types.dot)) {\n          this.unexpected();\n        }\n\n        if (this.match(types.parenL) && this.state.inMethod !== \"constructor\" && !this.options.allowSuperOutsideMethod) {\n          this.raise(node.start, \"super() is only valid inside a class constructor. Make sure the method name is spelled exactly as 'constructor'.\");\n        }\n\n        return this.finishNode(node, \"Super\");\n\n      case types._import:\n        if (this.lookahead().type === types.dot) {\n          return this.parseImportMetaProperty();\n        }\n\n        this.expectPlugin(\"dynamicImport\");\n        node = this.startNode();\n        this.next();\n\n        if (!this.match(types.parenL)) {\n          this.unexpected(null, types.parenL);\n        }\n\n        return this.finishNode(node, \"Import\");\n\n      case types._this:\n        node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"ThisExpression\");\n\n      case types._yield:\n        if (this.state.inGenerator) this.unexpected();\n\n      case types.name:\n        {\n          node = this.startNode();\n          var allowAwait = this.state.value === \"await\" && this.state.inAsync;\n          var allowYield = this.shouldAllowYieldIdentifier();\n          var id = this.parseIdentifier(allowAwait || allowYield);\n\n          if (id.name === \"await\") {\n            if (this.state.inAsync || this.inModule) {\n              return this.parseAwait(node);\n            }\n          } else if (id.name === \"async\" && this.match(types._function) && !this.canInsertSemicolon()) {\n            this.next();\n            return this.parseFunction(node, false, false, true);\n          } else if (canBeArrow && id.name === \"async\" && this.match(types.name)) {\n            var params = [this.parseIdentifier()];\n            this.expect(types.arrow); // let foo = bar => {};\n\n            return this.parseArrowExpression(node, params, true);\n          }\n\n          if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {\n            return this.parseArrowExpression(node, [id]);\n          }\n\n          return id;\n        }\n\n      case types._do:\n        {\n          this.expectPlugin(\"doExpressions\");\n\n          var _node13 = this.startNode();\n\n          this.next();\n          var oldInFunction = this.state.inFunction;\n          var oldLabels = this.state.labels;\n          this.state.labels = [];\n          this.state.inFunction = false;\n          _node13.body = this.parseBlock(false);\n          this.state.inFunction = oldInFunction;\n          this.state.labels = oldLabels;\n          return this.finishNode(_node13, \"DoExpression\");\n        }\n\n      case types.regexp:\n        {\n          var value = this.state.value;\n          node = this.parseLiteral(value.value, \"RegExpLiteral\");\n          node.pattern = value.pattern;\n          node.flags = value.flags;\n          return node;\n        }\n\n      case types.num:\n        return this.parseLiteral(this.state.value, \"NumericLiteral\");\n\n      case types.bigint:\n        return this.parseLiteral(this.state.value, \"BigIntLiteral\");\n\n      case types.string:\n        return this.parseLiteral(this.state.value, \"StringLiteral\");\n\n      case types._null:\n        node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"NullLiteral\");\n\n      case types._true:\n      case types._false:\n        return this.parseBooleanLiteral();\n\n      case types.parenL:\n        return this.parseParenAndDistinguishExpression(canBeArrow);\n\n      case types.bracketL:\n        node = this.startNode();\n        this.next();\n        node.elements = this.parseExprList(types.bracketR, true, refShorthandDefaultPos);\n        this.toReferencedList(node.elements);\n        return this.finishNode(node, \"ArrayExpression\");\n\n      case types.braceL:\n        return this.parseObj(false, refShorthandDefaultPos);\n\n      case types._function:\n        return this.parseFunctionExpression();\n\n      case types.at:\n        this.parseDecorators();\n\n      case types._class:\n        node = this.startNode();\n        this.takeDecorators(node);\n        return this.parseClass(node, false);\n\n      case types._new:\n        return this.parseNew();\n\n      case types.backQuote:\n        return this.parseTemplate(false);\n\n      case types.doubleColon:\n        {\n          node = this.startNode();\n          this.next();\n          node.object = null;\n          var callee = node.callee = this.parseNoCallExpr();\n\n          if (callee.type === \"MemberExpression\") {\n            return this.finishNode(node, \"BindExpression\");\n          } else {\n            throw this.raise(callee.start, \"Binding should be performed on object property.\");\n          }\n        }\n\n      default:\n        throw this.unexpected();\n    }\n  };\n\n  _proto.parseBooleanLiteral = function parseBooleanLiteral() {\n    var node = this.startNode();\n    node.value = this.match(types._true);\n    this.next();\n    return this.finishNode(node, \"BooleanLiteral\");\n  };\n\n  _proto.parseMaybePrivateName = function parseMaybePrivateName() {\n    var isPrivate = this.match(types.hash);\n\n    if (isPrivate) {\n      this.expectOnePlugin([\"classPrivateProperties\", \"classPrivateMethods\"]);\n\n      var _node14 = this.startNode();\n\n      this.next();\n      _node14.id = this.parseIdentifier(true);\n      return this.finishNode(_node14, \"PrivateName\");\n    } else {\n      return this.parseIdentifier(true);\n    }\n  };\n\n  _proto.parseFunctionExpression = function parseFunctionExpression() {\n    var node = this.startNode();\n    var meta = this.parseIdentifier(true);\n\n    if (this.state.inGenerator && this.eat(types.dot)) {\n      return this.parseMetaProperty(node, meta, \"sent\");\n    }\n\n    return this.parseFunction(node, false);\n  };\n\n  _proto.parseMetaProperty = function parseMetaProperty(node, meta, propertyName) {\n    node.meta = meta;\n\n    if (meta.name === \"function\" && propertyName === \"sent\") {\n      if (this.isContextual(propertyName)) {\n        this.expectPlugin(\"functionSent\");\n      } else if (!this.hasPlugin(\"functionSent\")) {\n        // They didn't actually say `function.sent`, just `function.`, so a simple error would be less confusing.\n        this.unexpected();\n      }\n    }\n\n    node.property = this.parseIdentifier(true);\n\n    if (node.property.name !== propertyName) {\n      this.raise(node.property.start, `The only valid meta property for ${meta.name} is ${meta.name}.${propertyName}`);\n    }\n\n    return this.finishNode(node, \"MetaProperty\");\n  };\n\n  _proto.parseImportMetaProperty = function parseImportMetaProperty() {\n    var node = this.startNode();\n    var id = this.parseIdentifier(true);\n    this.expect(types.dot);\n\n    if (id.name === \"import\") {\n      if (this.isContextual(\"meta\")) {\n        this.expectPlugin(\"importMeta\");\n      } else if (!this.hasPlugin(\"importMeta\")) {\n        this.raise(id.start, `Dynamic imports require a parameter: import('a.js').then`);\n      }\n    }\n\n    if (!this.inModule) {\n      this.raise(id.start, `import.meta may appear only with 'sourceType: \"module\"'`);\n    }\n\n    return this.parseMetaProperty(node, id, \"meta\");\n  };\n\n  _proto.parseLiteral = function parseLiteral(value, type, startPos, startLoc) {\n    startPos = startPos || this.state.start;\n    startLoc = startLoc || this.state.startLoc;\n    var node = this.startNodeAt(startPos, startLoc);\n    this.addExtra(node, \"rawValue\", value);\n    this.addExtra(node, \"raw\", this.input.slice(startPos, this.state.end));\n    node.value = value;\n    this.next();\n    return this.finishNode(node, type);\n  };\n\n  _proto.parseParenExpression = function parseParenExpression() {\n    this.expect(types.parenL);\n    var val = this.parseExpression();\n    this.expect(types.parenR);\n    return val;\n  };\n\n  _proto.parseParenAndDistinguishExpression = function parseParenAndDistinguishExpression(canBeArrow) {\n    var startPos = this.state.start;\n    var startLoc = this.state.startLoc;\n    var val;\n    this.expect(types.parenL);\n    var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    var oldYield = this.state.yieldInPossibleArrowParameters;\n    this.state.maybeInArrowParameters = true;\n    this.state.yieldInPossibleArrowParameters = null;\n    var innerStartPos = this.state.start;\n    var innerStartLoc = this.state.startLoc;\n    var exprList = [];\n    var refShorthandDefaultPos = {\n      start: 0\n    };\n    var refNeedsArrowPos = {\n      start: 0\n    };\n    var first = true;\n    var spreadStart;\n    var optionalCommaStart;\n\n    while (!this.match(types.parenR)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(types.comma, refNeedsArrowPos.start || null);\n\n        if (this.match(types.parenR)) {\n          optionalCommaStart = this.state.start;\n          break;\n        }\n      }\n\n      if (this.match(types.ellipsis)) {\n        var spreadNodeStartPos = this.state.start;\n        var spreadNodeStartLoc = this.state.startLoc;\n        spreadStart = this.state.start;\n        exprList.push(this.parseParenItem(this.parseRest(), spreadNodeStartPos, spreadNodeStartLoc));\n\n        if (this.match(types.comma) && this.lookahead().type === types.parenR) {\n          this.raise(this.state.start, \"A trailing comma is not permitted after the rest element\");\n        }\n\n        break;\n      } else {\n        exprList.push(this.parseMaybeAssign(false, refShorthandDefaultPos, this.parseParenItem, refNeedsArrowPos));\n      }\n    }\n\n    var innerEndPos = this.state.start;\n    var innerEndLoc = this.state.startLoc;\n    this.expect(types.parenR);\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    var arrowNode = this.startNodeAt(startPos, startLoc);\n\n    if (canBeArrow && this.shouldParseArrow() && (arrowNode = this.parseArrow(arrowNode))) {\n      for (var _i2 = 0; _i2 < exprList.length; _i2++) {\n        var param = exprList[_i2];\n\n        if (param.extra && param.extra.parenthesized) {\n          this.unexpected(param.extra.parenStart);\n        }\n      }\n\n      this.parseArrowExpression(arrowNode, exprList);\n      this.state.yieldInPossibleArrowParameters = oldYield;\n      return arrowNode;\n    }\n\n    this.state.yieldInPossibleArrowParameters = oldYield;\n\n    if (!exprList.length) {\n      this.unexpected(this.state.lastTokStart);\n    }\n\n    if (optionalCommaStart) this.unexpected(optionalCommaStart);\n    if (spreadStart) this.unexpected(spreadStart);\n\n    if (refShorthandDefaultPos.start) {\n      this.unexpected(refShorthandDefaultPos.start);\n    }\n\n    if (refNeedsArrowPos.start) this.unexpected(refNeedsArrowPos.start);\n\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartPos, innerStartLoc);\n      val.expressions = exprList;\n      this.toReferencedList(val.expressions);\n      this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n\n    this.addExtra(val, \"parenthesized\", true);\n    this.addExtra(val, \"parenStart\", startPos);\n    return val;\n  };\n\n  _proto.shouldParseArrow = function shouldParseArrow() {\n    return !this.canInsertSemicolon();\n  };\n\n  _proto.parseArrow = function parseArrow(node) {\n    if (this.eat(types.arrow)) {\n      return node;\n    }\n  };\n\n  _proto.parseParenItem = function parseParenItem(node, startPos, // eslint-disable-next-line no-unused-vars\n  startLoc) {\n    return node;\n  }; // New's precedence is slightly tricky. It must allow its argument to\n  // be a `[]` or dot subscript expression, but not a call — at least,\n  // not without wrapping it in parentheses. Thus, it uses the noCalls\n  // argument to parseSubscripts to prevent it from consuming the\n  // argument list.\n\n\n  _proto.parseNew = function parseNew() {\n    var node = this.startNode();\n    var meta = this.parseIdentifier(true);\n\n    if (this.eat(types.dot)) {\n      var metaProp = this.parseMetaProperty(node, meta, \"target\");\n\n      if (!this.state.inFunction && !this.state.inClassProperty) {\n        var error = \"new.target can only be used in functions\";\n\n        if (this.hasPlugin(\"classProperties\")) {\n          error += \" or class properties\";\n        }\n\n        this.raise(metaProp.start, error);\n      }\n\n      return metaProp;\n    }\n\n    node.callee = this.parseNoCallExpr();\n    if (this.eat(types.questionDot)) node.optional = true;\n    this.parseNewArguments(node);\n    return this.finishNode(node, \"NewExpression\");\n  };\n\n  _proto.parseNewArguments = function parseNewArguments(node) {\n    if (this.eat(types.parenL)) {\n      var args = this.parseExprList(types.parenR);\n      this.toReferencedList(args); // $FlowFixMe (parseExprList should be all non-null in this case)\n\n      node.arguments = args;\n    } else {\n      node.arguments = [];\n    }\n  }; // Parse template expression.\n\n\n  _proto.parseTemplateElement = function parseTemplateElement(isTagged) {\n    var elem = this.startNode();\n\n    if (this.state.value === null) {\n      if (!isTagged) {\n        // TODO: fix this\n        this.raise(this.state.invalidTemplateEscapePosition || 0, \"Invalid escape sequence in template\");\n      } else {\n        this.state.invalidTemplateEscapePosition = null;\n      }\n    }\n\n    elem.value = {\n      raw: this.input.slice(this.state.start, this.state.end).replace(/\\r\\n?/g, \"\\n\"),\n      cooked: this.state.value\n    };\n    this.next();\n    elem.tail = this.match(types.backQuote);\n    return this.finishNode(elem, \"TemplateElement\");\n  };\n\n  _proto.parseTemplate = function parseTemplate(isTagged) {\n    var node = this.startNode();\n    this.next();\n    node.expressions = [];\n    var curElt = this.parseTemplateElement(isTagged);\n    node.quasis = [curElt];\n\n    while (!curElt.tail) {\n      this.expect(types.dollarBraceL);\n      node.expressions.push(this.parseExpression());\n      this.expect(types.braceR);\n      node.quasis.push(curElt = this.parseTemplateElement(isTagged));\n    }\n\n    this.next();\n    return this.finishNode(node, \"TemplateLiteral\");\n  }; // Parse an object literal or binding pattern.\n\n\n  _proto.parseObj = function parseObj(isPattern, refShorthandDefaultPos) {\n    var decorators = [];\n    var propHash = Object.create(null);\n    var first = true;\n    var node = this.startNode();\n    node.properties = [];\n    this.next();\n    var firstRestLocation = null;\n\n    while (!this.eat(types.braceR)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(types.comma);\n        if (this.eat(types.braceR)) break;\n      }\n\n      if (this.match(types.at)) {\n        if (this.hasPlugin(\"decorators2\")) {\n          this.raise(this.state.start, \"Stage 2 decorators disallow object literal property decorators\");\n        } else {\n          // we needn't check if decorators (stage 0) plugin is enabled since it's checked by\n          // the call to this.parseDecorator\n          while (this.match(types.at)) {\n            decorators.push(this.parseDecorator());\n          }\n        }\n      }\n\n      var prop = this.startNode(),\n          isGenerator = false,\n          _isAsync = false,\n          startPos = void 0,\n          startLoc = void 0;\n\n      if (decorators.length) {\n        prop.decorators = decorators;\n        decorators = [];\n      }\n\n      if (this.match(types.ellipsis)) {\n        this.expectPlugin(\"objectRestSpread\");\n        prop = this.parseSpread(isPattern ? {\n          start: 0\n        } : undefined);\n\n        if (isPattern) {\n          this.toAssignable(prop, true, \"object pattern\");\n        }\n\n        node.properties.push(prop);\n\n        if (isPattern) {\n          var position = this.state.start;\n\n          if (firstRestLocation !== null) {\n            this.unexpected(firstRestLocation, \"Cannot have multiple rest elements when destructuring\");\n          } else if (this.eat(types.braceR)) {\n            break;\n          } else if (this.match(types.comma) && this.lookahead().type === types.braceR) {\n            this.unexpected(position, \"A trailing comma is not permitted after the rest element\");\n          } else {\n            firstRestLocation = position;\n            continue;\n          }\n        } else {\n          continue;\n        }\n      }\n\n      prop.method = false;\n\n      if (isPattern || refShorthandDefaultPos) {\n        startPos = this.state.start;\n        startLoc = this.state.startLoc;\n      }\n\n      if (!isPattern) {\n        isGenerator = this.eat(types.star);\n      }\n\n      if (!isPattern && this.isContextual(\"async\")) {\n        if (isGenerator) this.unexpected();\n        var asyncId = this.parseIdentifier();\n\n        if (this.match(types.colon) || this.match(types.parenL) || this.match(types.braceR) || this.match(types.eq) || this.match(types.comma)) {\n          prop.key = asyncId;\n          prop.computed = false;\n        } else {\n          _isAsync = true;\n\n          if (this.match(types.star)) {\n            this.expectPlugin(\"asyncGenerators\");\n            this.next();\n            isGenerator = true;\n          }\n\n          this.parsePropertyName(prop);\n        }\n      } else {\n        this.parsePropertyName(prop);\n      }\n\n      this.parseObjPropValue(prop, startPos, startLoc, isGenerator, _isAsync, isPattern, refShorthandDefaultPos);\n      this.checkPropClash(prop, propHash);\n\n      if (prop.shorthand) {\n        this.addExtra(prop, \"shorthand\", true);\n      }\n\n      node.properties.push(prop);\n    }\n\n    if (firstRestLocation !== null) {\n      this.unexpected(firstRestLocation, \"The rest element has to be the last element when destructuring\");\n    }\n\n    if (decorators.length) {\n      this.raise(this.state.start, \"You have trailing decorators with no property\");\n    }\n\n    return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\");\n  };\n\n  _proto.isGetterOrSetterMethod = function isGetterOrSetterMethod(prop, isPattern) {\n    return !isPattern && !prop.computed && prop.key.type === \"Identifier\" && (prop.key.name === \"get\" || prop.key.name === \"set\") && (this.match(types.string) || // get \"string\"() {}\n    this.match(types.num) || // get 1() {}\n    this.match(types.bracketL) || // get [\"string\"]() {}\n    this.match(types.name) || // get foo() {}\n    !!this.state.type.keyword) // get debugger() {}\n    ;\n  }; // get methods aren't allowed to have any parameters\n  // set methods must have exactly 1 parameter\n\n\n  _proto.checkGetterSetterParamCount = function checkGetterSetterParamCount(method) {\n    var paramCount = method.kind === \"get\" ? 0 : 1;\n\n    if (method.params.length !== paramCount) {\n      var start = method.start;\n\n      if (method.kind === \"get\") {\n        this.raise(start, \"getter should have no params\");\n      } else {\n        this.raise(start, \"setter should have exactly one param\");\n      }\n    }\n  };\n\n  _proto.parseObjectMethod = function parseObjectMethod(prop, isGenerator, isAsync, isPattern) {\n    if (isAsync || isGenerator || this.match(types.parenL)) {\n      if (isPattern) this.unexpected();\n      prop.kind = \"method\";\n      prop.method = true;\n      return this.parseMethod(prop, isGenerator, isAsync,\n      /* isConstructor */\n      false, \"ObjectMethod\");\n    }\n\n    if (this.isGetterOrSetterMethod(prop, isPattern)) {\n      if (isGenerator || isAsync) this.unexpected();\n      prop.kind = prop.key.name;\n      this.parsePropertyName(prop);\n      this.parseMethod(prop,\n      /* isGenerator */\n      false,\n      /* isAsync */\n      false,\n      /* isConstructor */\n      false, \"ObjectMethod\");\n      this.checkGetterSetterParamCount(prop);\n      return prop;\n    }\n  };\n\n  _proto.parseObjectProperty = function parseObjectProperty(prop, startPos, startLoc, isPattern, refShorthandDefaultPos) {\n    prop.shorthand = false;\n\n    if (this.eat(types.colon)) {\n      prop.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssign(false, refShorthandDefaultPos);\n      return this.finishNode(prop, \"ObjectProperty\");\n    }\n\n    if (!prop.computed && prop.key.type === \"Identifier\") {\n      this.checkReservedWord(prop.key.name, prop.key.start, true, true);\n\n      if (isPattern) {\n        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());\n      } else if (this.match(types.eq) && refShorthandDefaultPos) {\n        if (!refShorthandDefaultPos.start) {\n          refShorthandDefaultPos.start = this.state.start;\n        }\n\n        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());\n      } else {\n        prop.value = prop.key.__clone();\n      }\n\n      prop.shorthand = true;\n      return this.finishNode(prop, \"ObjectProperty\");\n    }\n  };\n\n  _proto.parseObjPropValue = function parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refShorthandDefaultPos) {\n    var node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern) || this.parseObjectProperty(prop, startPos, startLoc, isPattern, refShorthandDefaultPos);\n    if (!node) this.unexpected(); // $FlowFixMe\n\n    return node;\n  };\n\n  _proto.parsePropertyName = function parsePropertyName(prop) {\n    if (this.eat(types.bracketL)) {\n      prop.computed = true;\n      prop.key = this.parseMaybeAssign();\n      this.expect(types.bracketR);\n    } else {\n      var oldInPropertyName = this.state.inPropertyName;\n      this.state.inPropertyName = true; // We check if it's valid for it to be a private name when we push it.\n\n      prop.key = this.match(types.num) || this.match(types.string) ? this.parseExprAtom() : this.parseMaybePrivateName();\n\n      if (prop.key.type !== \"PrivateName\") {\n        // ClassPrivateProperty is never computed, so we don't assign in that case.\n        prop.computed = false;\n      }\n\n      this.state.inPropertyName = oldInPropertyName;\n    }\n\n    return prop.key;\n  }; // Initialize empty function node.\n\n\n  _proto.initFunction = function initFunction(node, isAsync) {\n    node.id = null;\n    node.generator = false;\n    node.expression = false;\n    node.async = !!isAsync;\n  }; // Parse object or class method.\n\n\n  _proto.parseMethod = function parseMethod(node, isGenerator, isAsync, isConstructor, type) {\n    var oldInFunc = this.state.inFunction;\n    var oldInMethod = this.state.inMethod;\n    var oldInGenerator = this.state.inGenerator;\n    this.state.inFunction = true;\n    this.state.inMethod = node.kind || true;\n    this.state.inGenerator = isGenerator;\n    this.initFunction(node, isAsync);\n    node.generator = !!isGenerator;\n    var allowModifiers = isConstructor; // For TypeScript parameter properties\n\n    this.parseFunctionParams(node, allowModifiers);\n    this.parseFunctionBodyAndFinish(node, type);\n    this.state.inFunction = oldInFunc;\n    this.state.inMethod = oldInMethod;\n    this.state.inGenerator = oldInGenerator;\n    return node;\n  }; // Parse arrow function expression with given parameters.\n\n\n  _proto.parseArrowExpression = function parseArrowExpression(node, params, isAsync) {\n    // if we got there, it's no more \"yield in possible arrow parameters\";\n    // it's just \"yield in arrow parameters\"\n    if (this.state.yieldInPossibleArrowParameters) {\n      this.raise(this.state.yieldInPossibleArrowParameters.start, \"yield is not allowed in the parameters of an arrow function\" + \" inside a generator\");\n    }\n\n    var oldInFunc = this.state.inFunction;\n    this.state.inFunction = true;\n    this.initFunction(node, isAsync);\n    this.setArrowFunctionParameters(node, params);\n    var oldInGenerator = this.state.inGenerator;\n    var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    this.state.inGenerator = false;\n    this.state.maybeInArrowParameters = false;\n    this.parseFunctionBody(node, true);\n    this.state.inGenerator = oldInGenerator;\n    this.state.inFunction = oldInFunc;\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return this.finishNode(node, \"ArrowFunctionExpression\");\n  };\n\n  _proto.setArrowFunctionParameters = function setArrowFunctionParameters(node, params) {\n    node.params = this.toAssignableList(params, true, \"arrow function parameters\");\n  };\n\n  _proto.isStrictBody = function isStrictBody(node, isExpression) {\n    if (!isExpression && node.body.directives.length) {\n      for (var _i4 = 0, _node$body$directives2 = node.body.directives; _i4 < _node$body$directives2.length; _i4++) {\n        var directive = _node$body$directives2[_i4];\n\n        if (directive.value.value === \"use strict\") {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  };\n\n  _proto.parseFunctionBodyAndFinish = function parseFunctionBodyAndFinish(node, type, allowExpressionBody) {\n    // $FlowIgnore (node is not bodiless if we get here)\n    this.parseFunctionBody(node, allowExpressionBody);\n    this.finishNode(node, type);\n  }; // Parse function body and check parameters.\n\n\n  _proto.parseFunctionBody = function parseFunctionBody(node, allowExpression) {\n    var isExpression = allowExpression && !this.match(types.braceL);\n    var oldInParameters = this.state.inParameters;\n    var oldInAsync = this.state.inAsync;\n    this.state.inParameters = false;\n    this.state.inAsync = node.async;\n\n    if (isExpression) {\n      node.body = this.parseMaybeAssign();\n      node.expression = true;\n    } else {\n      // Start a new scope with regard to labels and the `inGenerator`\n      // flag (restore them to their old value afterwards).\n      var oldInGen = this.state.inGenerator;\n      var oldInFunc = this.state.inFunction;\n      var oldLabels = this.state.labels;\n      this.state.inGenerator = node.generator;\n      this.state.inFunction = true;\n      this.state.labels = [];\n      node.body = this.parseBlock(true);\n      node.expression = false;\n      this.state.inFunction = oldInFunc;\n      this.state.inGenerator = oldInGen;\n      this.state.labels = oldLabels;\n    }\n\n    this.state.inAsync = oldInAsync;\n    this.checkFunctionNameAndParams(node, allowExpression);\n    this.state.inParameters = oldInParameters;\n  };\n\n  _proto.checkFunctionNameAndParams = function checkFunctionNameAndParams(node, isArrowFunction) {\n    // If this is a strict mode function, verify that argument names\n    // are not repeated, and it does not try to bind the words `eval`\n    // or `arguments`.\n    var isStrict = this.isStrictBody(node, node.expression); // Also check for arrow functions\n\n    var checkLVal = this.state.strict || isStrict || isArrowFunction;\n    var oldStrict = this.state.strict;\n    if (isStrict) this.state.strict = isStrict;\n\n    if (node.id) {\n      this.checkReservedWord(node.id, node.start, true, true);\n    }\n\n    if (checkLVal) {\n      var nameHash = Object.create(null);\n\n      if (node.id) {\n        this.checkLVal(node.id, true, undefined, \"function name\");\n      }\n\n      for (var _i6 = 0, _node$params2 = node.params; _i6 < _node$params2.length; _i6++) {\n        var param = _node$params2[_i6];\n\n        if (isStrict && param.type !== \"Identifier\") {\n          this.raise(param.start, \"Non-simple parameter in strict mode\");\n        }\n\n        this.checkLVal(param, true, nameHash, \"function parameter list\");\n      }\n    }\n\n    this.state.strict = oldStrict;\n  }; // Parses a comma-separated list of expressions, and returns them as\n  // an array. `close` is the token type that ends the list, and\n  // `allowEmpty` can be turned on to allow subsequent commas with\n  // nothing in between them to be parsed as `null` (which is needed\n  // for array literals).\n\n\n  _proto.parseExprList = function parseExprList(close, allowEmpty, refShorthandDefaultPos) {\n    var elts = [];\n    var first = true;\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(types.comma);\n        if (this.eat(close)) break;\n      }\n\n      elts.push(this.parseExprListItem(allowEmpty, refShorthandDefaultPos));\n    }\n\n    return elts;\n  };\n\n  _proto.parseExprListItem = function parseExprListItem(allowEmpty, refShorthandDefaultPos, refNeedsArrowPos, refTrailingCommaPos) {\n    var elt;\n\n    if (allowEmpty && this.match(types.comma)) {\n      elt = null;\n    } else if (this.match(types.ellipsis)) {\n      elt = this.parseSpread(refShorthandDefaultPos);\n\n      if (refTrailingCommaPos && this.match(types.comma)) {\n        refTrailingCommaPos.start = this.state.start;\n      }\n    } else {\n      elt = this.parseMaybeAssign(false, refShorthandDefaultPos, this.parseParenItem, refNeedsArrowPos);\n    }\n\n    return elt;\n  }; // Parse the next token as an identifier. If `liberal` is true (used\n  // when parsing properties), it will also convert keywords into\n  // identifiers.\n\n\n  _proto.parseIdentifier = function parseIdentifier(liberal) {\n    var node = this.startNode();\n    var name = this.parseIdentifierName(node.start, liberal);\n    node.name = name;\n    node.loc.identifierName = name;\n    return this.finishNode(node, \"Identifier\");\n  };\n\n  _proto.parseIdentifierName = function parseIdentifierName(pos, liberal) {\n    if (!liberal) {\n      this.checkReservedWord(this.state.value, this.state.start, !!this.state.type.keyword, false);\n    }\n\n    var name;\n\n    if (this.match(types.name)) {\n      name = this.state.value;\n    } else if (this.state.type.keyword) {\n      name = this.state.type.keyword;\n    } else {\n      throw this.unexpected();\n    }\n\n    if (!liberal && name === \"await\" && this.state.inAsync) {\n      this.raise(pos, \"invalid use of await inside of an async function\");\n    }\n\n    this.next();\n    return name;\n  };\n\n  _proto.checkReservedWord = function checkReservedWord(word, startLoc, checkKeywords, isBinding) {\n    if (this.state.strict && (reservedWords.strict(word) || isBinding && reservedWords.strictBind(word))) {\n      this.raise(startLoc, word + \" is a reserved word in strict mode\");\n    }\n\n    if (this.state.inGenerator && word === \"yield\") {\n      this.raise(startLoc, \"yield is a reserved word inside generator functions\");\n    }\n\n    if (this.isReservedWord(word) || checkKeywords && this.isKeyword(word)) {\n      this.raise(startLoc, word + \" is a reserved word\");\n    }\n  }; // Parses await expression inside async function.\n\n\n  _proto.parseAwait = function parseAwait(node) {\n    // istanbul ignore next: this condition is checked at the call site so won't be hit here\n    if (!this.state.inAsync) {\n      this.unexpected();\n    }\n\n    if (this.match(types.star)) {\n      this.raise(node.start, \"await* has been removed from the async functions proposal. Use Promise.all() instead.\");\n    }\n\n    node.argument = this.parseMaybeUnary();\n    return this.finishNode(node, \"AwaitExpression\");\n  }; // Parses yield expression inside generator.\n\n\n  _proto.parseYield = function parseYield() {\n    var node = this.startNode();\n\n    if (this.state.inParameters) {\n      this.raise(node.start, \"yield is not allowed in generator parameters\");\n    }\n\n    if (this.state.maybeInArrowParameters && // We only set yieldInPossibleArrowParameters if we haven't already\n    // found a possible invalid YieldExpression.\n    !this.state.yieldInPossibleArrowParameters) {\n      this.state.yieldInPossibleArrowParameters = node;\n    }\n\n    this.next();\n\n    if (this.match(types.semi) || this.canInsertSemicolon() || !this.match(types.star) && !this.state.type.startsExpr) {\n      node.delegate = false;\n      node.argument = null;\n    } else {\n      node.delegate = this.eat(types.star);\n      node.argument = this.parseMaybeAssign();\n    }\n\n    return this.finishNode(node, \"YieldExpression\");\n  };\n\n  return ExpressionParser;\n}(LValParser);\n\n/* eslint max-len: 0 */\nvar empty = [];\nvar loopLabel = {\n  kind: \"loop\"\n};\nvar switchLabel = {\n  kind: \"switch\"\n};\n\nvar StatementParser =\n/*#__PURE__*/\nfunction (_ExpressionParser) {\n  _inheritsLoose(StatementParser, _ExpressionParser);\n\n  function StatementParser() {\n    return _ExpressionParser.apply(this, arguments) || this;\n  }\n\n  var _proto = StatementParser.prototype;\n\n  // ### Statement parsing\n  // Parse a program. Initializes the parser, reads any number of\n  // statements, and wraps them in a Program node.  Optionally takes a\n  // `program` argument.  If present, the statements will be appended\n  // to its body instead of creating a new node.\n  _proto.parseTopLevel = function parseTopLevel(file, program) {\n    program.sourceType = this.options.sourceType;\n    this.parseBlockBody(program, true, true, types.eof);\n    file.program = this.finishNode(program, \"Program\");\n    file.comments = this.state.comments;\n    if (this.options.tokens) file.tokens = this.state.tokens;\n    return this.finishNode(file, \"File\");\n  }; // TODO\n\n\n  _proto.stmtToDirective = function stmtToDirective(stmt) {\n    var expr = stmt.expression;\n    var directiveLiteral = this.startNodeAt(expr.start, expr.loc.start);\n    var directive = this.startNodeAt(stmt.start, stmt.loc.start);\n    var raw = this.input.slice(expr.start, expr.end);\n    var val = directiveLiteral.value = raw.slice(1, -1); // remove quotes\n\n    this.addExtra(directiveLiteral, \"raw\", raw);\n    this.addExtra(directiveLiteral, \"rawValue\", val);\n    directive.value = this.finishNodeAt(directiveLiteral, \"DirectiveLiteral\", expr.end, expr.loc.end);\n    return this.finishNodeAt(directive, \"Directive\", stmt.end, stmt.loc.end);\n  }; // Parse a single statement.\n  //\n  // If expecting a statement and finding a slash operator, parse a\n  // regular expression literal. This is to handle cases like\n  // `if (foo) /blah/.exec(foo)`, where looking at the previous token\n  // does not help.\n\n\n  _proto.parseStatement = function parseStatement(declaration, topLevel) {\n    if (this.match(types.at)) {\n      this.parseDecorators(true);\n    }\n\n    return this.parseStatementContent(declaration, topLevel);\n  };\n\n  _proto.parseStatementContent = function parseStatementContent(declaration, topLevel) {\n    var starttype = this.state.type;\n    var node = this.startNode(); // Most types of statements are recognized by the keyword they\n    // start with. Many are trivial to parse, some require a bit of\n    // complexity.\n\n    switch (starttype) {\n      case types._break:\n      case types._continue:\n        // $FlowFixMe\n        return this.parseBreakContinueStatement(node, starttype.keyword);\n\n      case types._debugger:\n        return this.parseDebuggerStatement(node);\n\n      case types._do:\n        return this.parseDoStatement(node);\n\n      case types._for:\n        return this.parseForStatement(node);\n\n      case types._function:\n        if (this.lookahead().type === types.dot) break;\n        if (!declaration) this.unexpected();\n        return this.parseFunctionStatement(node);\n\n      case types._class:\n        if (!declaration) this.unexpected();\n        return this.parseClass(node, true);\n\n      case types._if:\n        return this.parseIfStatement(node);\n\n      case types._return:\n        return this.parseReturnStatement(node);\n\n      case types._switch:\n        return this.parseSwitchStatement(node);\n\n      case types._throw:\n        return this.parseThrowStatement(node);\n\n      case types._try:\n        return this.parseTryStatement(node);\n\n      case types._let:\n      case types._const:\n        if (!declaration) this.unexpected();\n      // NOTE: falls through to _var\n\n      case types._var:\n        return this.parseVarStatement(node, starttype);\n\n      case types._while:\n        return this.parseWhileStatement(node);\n\n      case types._with:\n        return this.parseWithStatement(node);\n\n      case types.braceL:\n        return this.parseBlock();\n\n      case types.semi:\n        return this.parseEmptyStatement(node);\n\n      case types._export:\n      case types._import:\n        {\n          if (this.hasPlugin(\"dynamicImport\") && this.lookahead().type === types.parenL || this.hasPlugin(\"importMeta\") && this.lookahead().type === types.dot) {\n            break;\n          }\n\n          if (!this.options.allowImportExportEverywhere && !topLevel) {\n            this.raise(this.state.start, \"'import' and 'export' may only appear at the top level\");\n          }\n\n          this.next();\n          var result;\n\n          if (starttype == types._import) {\n            result = this.parseImport(node);\n          } else {\n            result = this.parseExport(node);\n          }\n\n          this.assertModuleNodeAllowed(node);\n          return result;\n        }\n\n      case types.name:\n        if (this.state.value === \"async\") {\n          // peek ahead and see if next token is a function\n          var state = this.state.clone();\n          this.next();\n\n          if (this.match(types._function) && !this.canInsertSemicolon()) {\n            this.expect(types._function);\n            return this.parseFunction(node, true, false, true);\n          } else {\n            this.state = state;\n          }\n        }\n\n    } // If the statement does not start with a statement keyword or a\n    // brace, it's an ExpressionStatement or LabeledStatement. We\n    // simply start parsing an expression, and afterwards, if the\n    // next token is a colon and the expression was a simple\n    // Identifier node, we switch to interpreting it as a label.\n\n\n    var maybeName = this.state.value;\n    var expr = this.parseExpression();\n\n    if (starttype === types.name && expr.type === \"Identifier\" && this.eat(types.colon)) {\n      return this.parseLabeledStatement(node, maybeName, expr);\n    } else {\n      return this.parseExpressionStatement(node, expr);\n    }\n  };\n\n  _proto.assertModuleNodeAllowed = function assertModuleNodeAllowed(node) {\n    if (!this.options.allowImportExportEverywhere && !this.inModule) {\n      this.raise(node.start, `'import' and 'export' may appear only with 'sourceType: \"module\"'`);\n    }\n  };\n\n  _proto.takeDecorators = function takeDecorators(node) {\n    var decorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];\n\n    if (decorators.length) {\n      node.decorators = decorators;\n      this.resetStartLocationFromNode(node, decorators[0]);\n      this.state.decoratorStack[this.state.decoratorStack.length - 1] = [];\n    }\n  };\n\n  _proto.parseDecorators = function parseDecorators(allowExport) {\n    if (this.hasPlugin(\"decorators2\")) {\n      allowExport = false;\n    }\n\n    var currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];\n\n    while (this.match(types.at)) {\n      var decorator = this.parseDecorator();\n      currentContextDecorators.push(decorator);\n    }\n\n    if (this.match(types._export)) {\n      if (allowExport) {\n        return;\n      } else {\n        this.raise(this.state.start, \"Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead\");\n      }\n    }\n\n    if (!this.match(types._class)) {\n      this.raise(this.state.start, \"Leading decorators must be attached to a class declaration\");\n    }\n  };\n\n  _proto.parseDecorator = function parseDecorator() {\n    this.expectOnePlugin([\"decorators\", \"decorators2\"]);\n    var node = this.startNode();\n    this.next();\n\n    if (this.hasPlugin(\"decorators2\")) {\n      var startPos = this.state.start;\n      var startLoc = this.state.startLoc;\n      var expr = this.parseIdentifier(false);\n\n      while (this.eat(types.dot)) {\n        var _node = this.startNodeAt(startPos, startLoc);\n\n        _node.object = expr;\n        _node.property = this.parseIdentifier(true);\n        _node.computed = false;\n        expr = this.finishNode(_node, \"MemberExpression\");\n      }\n\n      if (this.eat(types.parenL)) {\n        var _node2 = this.startNodeAt(startPos, startLoc);\n\n        _node2.callee = expr; // Every time a decorator class expression is evaluated, a new empty array is pushed onto the stack\n        // So that the decorators of any nested class expressions will be dealt with separately\n\n        this.state.decoratorStack.push([]);\n        _node2.arguments = this.parseCallExpressionArguments(types.parenR, false);\n        this.state.decoratorStack.pop();\n        expr = this.finishNode(_node2, \"CallExpression\");\n        this.toReferencedList(expr.arguments);\n      }\n\n      node.expression = expr;\n    } else {\n      node.expression = this.parseMaybeAssign();\n    }\n\n    return this.finishNode(node, \"Decorator\");\n  };\n\n  _proto.parseBreakContinueStatement = function parseBreakContinueStatement(node, keyword) {\n    var isBreak = keyword === \"break\";\n    this.next();\n\n    if (this.isLineTerminator()) {\n      node.label = null;\n    } else if (!this.match(types.name)) {\n      this.unexpected();\n    } else {\n      node.label = this.parseIdentifier();\n      this.semicolon();\n    } // Verify that there is an actual destination to break or\n    // continue to.\n\n\n    var i;\n\n    for (i = 0; i < this.state.labels.length; ++i) {\n      var lab = this.state.labels[i];\n\n      if (node.label == null || lab.name === node.label.name) {\n        if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break;\n        if (node.label && isBreak) break;\n      }\n    }\n\n    if (i === this.state.labels.length) {\n      this.raise(node.start, \"Unsyntactic \" + keyword);\n    }\n\n    return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n  };\n\n  _proto.parseDebuggerStatement = function parseDebuggerStatement(node) {\n    this.next();\n    this.semicolon();\n    return this.finishNode(node, \"DebuggerStatement\");\n  };\n\n  _proto.parseDoStatement = function parseDoStatement(node) {\n    this.next();\n    this.state.labels.push(loopLabel);\n    node.body = this.parseStatement(false);\n    this.state.labels.pop();\n    this.expect(types._while);\n    node.test = this.parseParenExpression();\n    this.eat(types.semi);\n    return this.finishNode(node, \"DoWhileStatement\");\n  }; // Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n  // loop is non-trivial. Basically, we have to parse the init `var`\n  // statement or expression, disallowing the `in` operator (see\n  // the second parameter to `parseExpression`), and then check\n  // whether the next token is `in` or `of`. When there is no init\n  // part (semicolon immediately after the opening parenthesis), it\n  // is a regular `for` loop.\n\n\n  _proto.parseForStatement = function parseForStatement(node) {\n    this.next();\n    this.state.labels.push(loopLabel);\n    var forAwait = false;\n\n    if (this.state.inAsync && this.isContextual(\"await\")) {\n      this.expectPlugin(\"asyncGenerators\");\n      forAwait = true;\n      this.next();\n    }\n\n    this.expect(types.parenL);\n\n    if (this.match(types.semi)) {\n      if (forAwait) {\n        this.unexpected();\n      }\n\n      return this.parseFor(node, null);\n    }\n\n    if (this.match(types._var) || this.match(types._let) || this.match(types._const)) {\n      var _init = this.startNode();\n\n      var varKind = this.state.type;\n      this.next();\n      this.parseVar(_init, true, varKind);\n      this.finishNode(_init, \"VariableDeclaration\");\n\n      if (this.match(types._in) || this.isContextual(\"of\")) {\n        if (_init.declarations.length === 1 && !_init.declarations[0].init) {\n          return this.parseForIn(node, _init, forAwait);\n        }\n      }\n\n      if (forAwait) {\n        this.unexpected();\n      }\n\n      return this.parseFor(node, _init);\n    }\n\n    var refShorthandDefaultPos = {\n      start: 0\n    };\n    var init = this.parseExpression(true, refShorthandDefaultPos);\n\n    if (this.match(types._in) || this.isContextual(\"of\")) {\n      var description = this.isContextual(\"of\") ? \"for-of statement\" : \"for-in statement\";\n      this.toAssignable(init, undefined, description);\n      this.checkLVal(init, undefined, undefined, description);\n      return this.parseForIn(node, init, forAwait);\n    } else if (refShorthandDefaultPos.start) {\n      this.unexpected(refShorthandDefaultPos.start);\n    }\n\n    if (forAwait) {\n      this.unexpected();\n    }\n\n    return this.parseFor(node, init);\n  };\n\n  _proto.parseFunctionStatement = function parseFunctionStatement(node) {\n    this.next();\n    return this.parseFunction(node, true);\n  };\n\n  _proto.parseIfStatement = function parseIfStatement(node) {\n    this.next();\n    node.test = this.parseParenExpression();\n    node.consequent = this.parseStatement(false);\n    node.alternate = this.eat(types._else) ? this.parseStatement(false) : null;\n    return this.finishNode(node, \"IfStatement\");\n  };\n\n  _proto.parseReturnStatement = function parseReturnStatement(node) {\n    if (!this.state.inFunction && !this.options.allowReturnOutsideFunction) {\n      this.raise(this.state.start, \"'return' outside of function\");\n    }\n\n    this.next(); // In `return` (and `break`/`continue`), the keywords with\n    // optional arguments, we eagerly look for a semicolon or the\n    // possibility to insert one.\n\n    if (this.isLineTerminator()) {\n      node.argument = null;\n    } else {\n      node.argument = this.parseExpression();\n      this.semicolon();\n    }\n\n    return this.finishNode(node, \"ReturnStatement\");\n  };\n\n  _proto.parseSwitchStatement = function parseSwitchStatement(node) {\n    this.next();\n    node.discriminant = this.parseParenExpression();\n    var cases = node.cases = [];\n    this.expect(types.braceL);\n    this.state.labels.push(switchLabel); // Statements under must be grouped (by label) in SwitchCase\n    // nodes. `cur` is used to keep the node that we are currently\n    // adding statements to.\n\n    var cur;\n\n    for (var sawDefault; !this.match(types.braceR);) {\n      if (this.match(types._case) || this.match(types._default)) {\n        var isCase = this.match(types._case);\n        if (cur) this.finishNode(cur, \"SwitchCase\");\n        cases.push(cur = this.startNode());\n        cur.consequent = [];\n        this.next();\n\n        if (isCase) {\n          cur.test = this.parseExpression();\n        } else {\n          if (sawDefault) {\n            this.raise(this.state.lastTokStart, \"Multiple default clauses\");\n          }\n\n          sawDefault = true;\n          cur.test = null;\n        }\n\n        this.expect(types.colon);\n      } else {\n        if (cur) {\n          cur.consequent.push(this.parseStatement(true));\n        } else {\n          this.unexpected();\n        }\n      }\n    }\n\n    if (cur) this.finishNode(cur, \"SwitchCase\");\n    this.next(); // Closing brace\n\n    this.state.labels.pop();\n    return this.finishNode(node, \"SwitchStatement\");\n  };\n\n  _proto.parseThrowStatement = function parseThrowStatement(node) {\n    this.next();\n\n    if (lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start))) {\n      this.raise(this.state.lastTokEnd, \"Illegal newline after throw\");\n    }\n\n    node.argument = this.parseExpression();\n    this.semicolon();\n    return this.finishNode(node, \"ThrowStatement\");\n  };\n\n  _proto.parseTryStatement = function parseTryStatement(node) {\n    this.next();\n    node.block = this.parseBlock();\n    node.handler = null;\n\n    if (this.match(types._catch)) {\n      var clause = this.startNode();\n      this.next();\n\n      if (this.match(types.parenL)) {\n        this.expect(types.parenL);\n        clause.param = this.parseBindingAtom();\n        var clashes = Object.create(null);\n        this.checkLVal(clause.param, true, clashes, \"catch clause\");\n        this.expect(types.parenR);\n      } else {\n        this.expectPlugin(\"optionalCatchBinding\");\n        clause.param = null;\n      }\n\n      clause.body = this.parseBlock();\n      node.handler = this.finishNode(clause, \"CatchClause\");\n    }\n\n    node.guardedHandlers = empty;\n    node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;\n\n    if (!node.handler && !node.finalizer) {\n      this.raise(node.start, \"Missing catch or finally clause\");\n    }\n\n    return this.finishNode(node, \"TryStatement\");\n  };\n\n  _proto.parseVarStatement = function parseVarStatement(node, kind) {\n    this.next();\n    this.parseVar(node, false, kind);\n    this.semicolon();\n    return this.finishNode(node, \"VariableDeclaration\");\n  };\n\n  _proto.parseWhileStatement = function parseWhileStatement(node) {\n    this.next();\n    node.test = this.parseParenExpression();\n    this.state.labels.push(loopLabel);\n    node.body = this.parseStatement(false);\n    this.state.labels.pop();\n    return this.finishNode(node, \"WhileStatement\");\n  };\n\n  _proto.parseWithStatement = function parseWithStatement(node) {\n    if (this.state.strict) {\n      this.raise(this.state.start, \"'with' in strict mode\");\n    }\n\n    this.next();\n    node.object = this.parseParenExpression();\n    node.body = this.parseStatement(false);\n    return this.finishNode(node, \"WithStatement\");\n  };\n\n  _proto.parseEmptyStatement = function parseEmptyStatement(node) {\n    this.next();\n    return this.finishNode(node, \"EmptyStatement\");\n  };\n\n  _proto.parseLabeledStatement = function parseLabeledStatement(node, maybeName, expr) {\n    for (var _i2 = 0, _state$labels2 = this.state.labels; _i2 < _state$labels2.length; _i2++) {\n      var label = _state$labels2[_i2];\n\n      if (label.name === maybeName) {\n        this.raise(expr.start, `Label '${maybeName}' is already declared`);\n      }\n    }\n\n    var kind = this.state.type.isLoop ? \"loop\" : this.match(types._switch) ? \"switch\" : null;\n\n    for (var i = this.state.labels.length - 1; i >= 0; i--) {\n      var _label = this.state.labels[i];\n\n      if (_label.statementStart === node.start) {\n        _label.statementStart = this.state.start;\n        _label.kind = kind;\n      } else {\n        break;\n      }\n    }\n\n    this.state.labels.push({\n      name: maybeName,\n      kind: kind,\n      statementStart: this.state.start\n    });\n    node.body = this.parseStatement(true);\n\n    if (node.body.type == \"ClassDeclaration\" || node.body.type == \"VariableDeclaration\" && node.body.kind !== \"var\" || node.body.type == \"FunctionDeclaration\" && (this.state.strict || node.body.generator || node.body.async)) {\n      this.raise(node.body.start, \"Invalid labeled declaration\");\n    }\n\n    this.state.labels.pop();\n    node.label = expr;\n    return this.finishNode(node, \"LabeledStatement\");\n  };\n\n  _proto.parseExpressionStatement = function parseExpressionStatement(node, expr) {\n    node.expression = expr;\n    this.semicolon();\n    return this.finishNode(node, \"ExpressionStatement\");\n  }; // Parse a semicolon-enclosed block of statements, handling `\"use\n  // strict\"` declarations when `allowStrict` is true (used for\n  // function bodies).\n\n\n  _proto.parseBlock = function parseBlock(allowDirectives) {\n    var node = this.startNode();\n    this.expect(types.braceL);\n    this.parseBlockBody(node, allowDirectives, false, types.braceR);\n    return this.finishNode(node, \"BlockStatement\");\n  };\n\n  _proto.isValidDirective = function isValidDirective(stmt) {\n    return stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"StringLiteral\" && !stmt.expression.extra.parenthesized;\n  };\n\n  _proto.parseBlockBody = function parseBlockBody(node, allowDirectives, topLevel, end) {\n    var body = node.body = [];\n    var directives = node.directives = [];\n    this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : undefined, topLevel, end);\n  }; // Undefined directives means that directives are not allowed.\n\n\n  _proto.parseBlockOrModuleBlockBody = function parseBlockOrModuleBlockBody(body, directives, topLevel, end) {\n    var parsedNonDirective = false;\n    var oldStrict;\n    var octalPosition;\n\n    while (!this.eat(end)) {\n      if (!parsedNonDirective && this.state.containsOctal && !octalPosition) {\n        octalPosition = this.state.octalPosition;\n      }\n\n      var stmt = this.parseStatement(true, topLevel);\n\n      if (directives && !parsedNonDirective && this.isValidDirective(stmt)) {\n        var directive = this.stmtToDirective(stmt);\n        directives.push(directive);\n\n        if (oldStrict === undefined && directive.value.value === \"use strict\") {\n          oldStrict = this.state.strict;\n          this.setStrict(true);\n\n          if (octalPosition) {\n            this.raise(octalPosition, \"Octal literal in strict mode\");\n          }\n        }\n\n        continue;\n      }\n\n      parsedNonDirective = true;\n      body.push(stmt);\n    }\n\n    if (oldStrict === false) {\n      this.setStrict(false);\n    }\n  }; // Parse a regular `for` loop. The disambiguation code in\n  // `parseStatement` will already have parsed the init statement or\n  // expression.\n\n\n  _proto.parseFor = function parseFor(node, init) {\n    node.init = init;\n    this.expect(types.semi);\n    node.test = this.match(types.semi) ? null : this.parseExpression();\n    this.expect(types.semi);\n    node.update = this.match(types.parenR) ? null : this.parseExpression();\n    this.expect(types.parenR);\n    node.body = this.parseStatement(false);\n    this.state.labels.pop();\n    return this.finishNode(node, \"ForStatement\");\n  }; // Parse a `for`/`in` and `for`/`of` loop, which are almost\n  // same from parser's perspective.\n\n\n  _proto.parseForIn = function parseForIn(node, init, forAwait) {\n    var type = this.match(types._in) ? \"ForInStatement\" : \"ForOfStatement\";\n\n    if (forAwait) {\n      this.eatContextual(\"of\");\n    } else {\n      this.next();\n    }\n\n    if (type === \"ForOfStatement\") {\n      node.await = !!forAwait;\n    }\n\n    node.left = init;\n    node.right = this.parseExpression();\n    this.expect(types.parenR);\n    node.body = this.parseStatement(false);\n    this.state.labels.pop();\n    return this.finishNode(node, type);\n  }; // Parse a list of variable declarations.\n\n\n  _proto.parseVar = function parseVar(node, isFor, kind) {\n    var declarations = node.declarations = []; // $FlowFixMe\n\n    node.kind = kind.keyword;\n\n    for (;;) {\n      var decl = this.startNode();\n      this.parseVarHead(decl);\n\n      if (this.eat(types.eq)) {\n        decl.init = this.parseMaybeAssign(isFor);\n      } else {\n        if (kind === types._const && !(this.match(types._in) || this.isContextual(\"of\"))) {\n          // `const` with no initializer is allowed in TypeScript. It could be a declaration `const x: number;`.\n          if (!this.hasPlugin(\"typescript\")) {\n            this.unexpected();\n          }\n        } else if (decl.id.type !== \"Identifier\" && !(isFor && (this.match(types._in) || this.isContextual(\"of\")))) {\n          this.raise(this.state.lastTokEnd, \"Complex binding patterns require an initialization value\");\n        }\n\n        decl.init = null;\n      }\n\n      declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n      if (!this.eat(types.comma)) break;\n    }\n\n    return node;\n  };\n\n  _proto.parseVarHead = function parseVarHead(decl) {\n    decl.id = this.parseBindingAtom();\n    this.checkLVal(decl.id, true, undefined, \"variable declaration\");\n  }; // Parse a function declaration or literal (depending on the\n  // `isStatement` parameter).\n\n\n  _proto.parseFunction = function parseFunction(node, isStatement, allowExpressionBody, isAsync, optionalId) {\n    var oldInFunc = this.state.inFunction;\n    var oldInMethod = this.state.inMethod;\n    var oldInGenerator = this.state.inGenerator;\n    this.state.inFunction = true;\n    this.state.inMethod = false;\n    this.initFunction(node, isAsync);\n\n    if (this.match(types.star)) {\n      if (node.async) {\n        this.expectPlugin(\"asyncGenerators\");\n      }\n\n      node.generator = true;\n      this.next();\n    }\n\n    if (isStatement && !optionalId && !this.match(types.name) && !this.match(types._yield)) {\n      this.unexpected();\n    } // When parsing function expression, the binding identifier is parsed\n    // according to the rules inside the function.\n    // e.g. (function* yield() {}) is invalid because \"yield\" is disallowed in\n    // generators.\n    // This isn't the case with function declarations: function* yield() {} is\n    // valid because yield is parsed as if it was outside the generator.\n    // Therefore, this.state.inGenerator is set before or after parsing the\n    // function id according to the \"isStatement\" parameter.\n\n\n    if (!isStatement) this.state.inGenerator = node.generator;\n\n    if (this.match(types.name) || this.match(types._yield)) {\n      node.id = this.parseBindingIdentifier();\n    }\n\n    if (isStatement) this.state.inGenerator = node.generator;\n    this.parseFunctionParams(node);\n    this.parseFunctionBodyAndFinish(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\", allowExpressionBody);\n    this.state.inFunction = oldInFunc;\n    this.state.inMethod = oldInMethod;\n    this.state.inGenerator = oldInGenerator;\n    return node;\n  };\n\n  _proto.parseFunctionParams = function parseFunctionParams(node, allowModifiers) {\n    var oldInParameters = this.state.inParameters;\n    this.state.inParameters = true;\n    this.expect(types.parenL);\n    node.params = this.parseBindingList(types.parenR,\n    /* allowEmpty */\n    false, allowModifiers);\n    this.state.inParameters = oldInParameters;\n  }; // Parse a class declaration or literal (depending on the\n  // `isStatement` parameter).\n\n\n  _proto.parseClass = function parseClass(node, isStatement, optionalId) {\n    this.next();\n    this.takeDecorators(node);\n    this.parseClassId(node, isStatement, optionalId);\n    this.parseClassSuper(node);\n    this.parseClassBody(node);\n    return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\");\n  };\n\n  _proto.isClassProperty = function isClassProperty() {\n    return this.match(types.eq) || this.match(types.semi) || this.match(types.braceR);\n  };\n\n  _proto.isClassMethod = function isClassMethod() {\n    return this.match(types.parenL);\n  };\n\n  _proto.isNonstaticConstructor = function isNonstaticConstructor(method) {\n    return !method.computed && !method.static && (method.key.name === \"constructor\" || // Identifier\n    method.key.value === \"constructor\") // String literal\n    ;\n  };\n\n  _proto.parseClassBody = function parseClassBody(node) {\n    // class bodies are implicitly strict\n    var oldStrict = this.state.strict;\n    this.state.strict = true;\n    this.state.classLevel++;\n    var state = {\n      hadConstructor: false\n    };\n    var decorators = [];\n    var classBody = this.startNode();\n    classBody.body = [];\n    this.expect(types.braceL);\n\n    while (!this.eat(types.braceR)) {\n      if (this.eat(types.semi)) {\n        if (decorators.length > 0) {\n          this.raise(this.state.lastTokEnd, \"Decorators must not be followed by a semicolon\");\n        }\n\n        continue;\n      }\n\n      if (this.match(types.at)) {\n        decorators.push(this.parseDecorator());\n        continue;\n      }\n\n      var member = this.startNode(); // steal the decorators if there are any\n\n      if (decorators.length) {\n        member.decorators = decorators;\n        this.resetStartLocationFromNode(member, decorators[0]);\n        decorators = [];\n      }\n\n      this.parseClassMember(classBody, member, state);\n\n      if (this.hasPlugin(\"decorators2\") && [\"method\", \"get\", \"set\"].indexOf(member.kind) === -1 && member.decorators && member.decorators.length > 0) {\n        this.raise(member.start, \"Stage 2 decorators may only be used with a class or a class method\");\n      }\n    }\n\n    if (decorators.length) {\n      this.raise(this.state.start, \"You have trailing decorators with no method\");\n    }\n\n    node.body = this.finishNode(classBody, \"ClassBody\");\n    this.state.classLevel--;\n    this.state.strict = oldStrict;\n  };\n\n  _proto.parseClassMember = function parseClassMember(classBody, member, state) {\n    var isStatic = false;\n\n    if (this.match(types.name) && this.state.value === \"static\") {\n      var key = this.parseIdentifier(true); // eats 'static'\n\n      if (this.isClassMethod()) {\n        var method = member; // a method named 'static'\n\n        method.kind = \"method\";\n        method.computed = false;\n        method.key = key;\n        method.static = false;\n        this.pushClassMethod(classBody, method, false, false,\n        /* isConstructor */\n        false);\n        return;\n      } else if (this.isClassProperty()) {\n        var prop = member; // a property named 'static'\n\n        prop.computed = false;\n        prop.key = key;\n        prop.static = false;\n        classBody.body.push(this.parseClassProperty(prop));\n        return;\n      } // otherwise something static\n\n\n      isStatic = true;\n    }\n\n    this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);\n  };\n\n  _proto.parseClassMemberWithIsStatic = function parseClassMemberWithIsStatic(classBody, member, state, isStatic) {\n    var publicMethod = member;\n    var privateMethod = member;\n    var publicProp = member;\n    var privateProp = member;\n    var method = publicMethod;\n    var publicMember = publicMethod;\n    member.static = isStatic;\n\n    if (this.eat(types.star)) {\n      // a generator\n      method.kind = \"method\";\n      this.parseClassPropertyName(method);\n\n      if (method.key.type === \"PrivateName\") {\n        // Private generator method\n        this.pushClassPrivateMethod(classBody, privateMethod, true, false);\n        return;\n      }\n\n      if (this.isNonstaticConstructor(publicMethod)) {\n        this.raise(publicMethod.key.start, \"Constructor can't be a generator\");\n      }\n\n      this.pushClassMethod(classBody, publicMethod, true, false,\n      /* isConstructor */\n      false);\n      return;\n    }\n\n    var key = this.parseClassPropertyName(member);\n    var isPrivate = key.type === \"PrivateName\"; // Check the key is not a computed expression or string literal.\n\n    var isSimple = key.type === \"Identifier\";\n    this.parsePostMemberNameModifiers(publicMember);\n\n    if (this.isClassMethod()) {\n      method.kind = \"method\";\n\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n        return;\n      } // a normal method\n\n\n      var isConstructor = this.isNonstaticConstructor(publicMethod);\n\n      if (isConstructor) {\n        publicMethod.kind = \"constructor\";\n\n        if (publicMethod.decorators) {\n          this.raise(publicMethod.start, \"You can't attach decorators to a class constructor\");\n        } // TypeScript allows multiple overloaded constructor declarations.\n\n\n        if (state.hadConstructor && !this.hasPlugin(\"typescript\")) {\n          this.raise(key.start, \"Duplicate constructor in the same class\");\n        }\n\n        state.hadConstructor = true;\n      }\n\n      this.pushClassMethod(classBody, publicMethod, false, false, isConstructor);\n    } else if (this.isClassProperty()) {\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else if (isSimple && key.name === \"async\" && !this.isLineTerminator()) {\n      // an async method\n      var isGenerator = this.match(types.star);\n\n      if (isGenerator) {\n        this.expectPlugin(\"asyncGenerators\");\n        this.next();\n      }\n\n      method.kind = \"method\"; // The so-called parsed name would have been \"async\": get the real name.\n\n      this.parseClassPropertyName(method);\n\n      if (method.key.type === \"PrivateName\") {\n        // private async method\n        this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(publicMethod.key.start, \"Constructor can't be an async function\");\n        }\n\n        this.pushClassMethod(classBody, publicMethod, isGenerator, true,\n        /* isConstructor */\n        false);\n      }\n    } else if (isSimple && (key.name === \"get\" || key.name === \"set\") && !(this.isLineTerminator() && this.match(types.star))) {\n      // `get\\n*` is an uninitialized property named 'get' followed by a generator.\n      // a getter or setter\n      method.kind = key.name; // The so-called parsed name would have been \"get/set\": get the real name.\n\n      this.parseClassPropertyName(publicMethod);\n\n      if (method.key.type === \"PrivateName\") {\n        // private getter/setter\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(publicMethod.key.start, \"Constructor can't have get/set modifier\");\n        }\n\n        this.pushClassMethod(classBody, publicMethod, false, false,\n        /* isConstructor */\n        false);\n      }\n\n      this.checkGetterSetterParamCount(publicMethod);\n    } else if (this.isLineTerminator()) {\n      // an uninitialized class property (due to ASI, since we don't otherwise recognize the next token)\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else {\n      this.unexpected();\n    }\n  };\n\n  _proto.parseClassPropertyName = function parseClassPropertyName(member) {\n    var key = this.parsePropertyName(member);\n\n    if (!member.computed && member.static && (key.name === \"prototype\" || key.value === \"prototype\")) {\n      this.raise(key.start, \"Classes may not have static property named prototype\");\n    }\n\n    if (key.type === \"PrivateName\" && key.id.name === \"constructor\") {\n      this.raise(key.start, \"Classes may not have a private field named '#constructor'\");\n    }\n\n    return key;\n  };\n\n  _proto.pushClassProperty = function pushClassProperty(classBody, prop) {\n    // This only affects properties, not methods.\n    if (this.isNonstaticConstructor(prop)) {\n      this.raise(prop.key.start, \"Classes may not have a non-static field named 'constructor'\");\n    }\n\n    classBody.body.push(this.parseClassProperty(prop));\n  };\n\n  _proto.pushClassPrivateProperty = function pushClassPrivateProperty(classBody, prop) {\n    this.expectPlugin(\"classPrivateProperties\", prop.key.start);\n    classBody.body.push(this.parseClassPrivateProperty(prop));\n  };\n\n  _proto.pushClassMethod = function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor) {\n    classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, \"ClassMethod\"));\n  };\n\n  _proto.pushClassPrivateMethod = function pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    this.expectPlugin(\"classPrivateMethods\", method.key.start);\n    classBody.body.push(this.parseMethod(method, isGenerator, isAsync,\n    /* isConstructor */\n    false, \"ClassPrivateMethod\"));\n  }; // Overridden in typescript.js\n\n\n  _proto.parsePostMemberNameModifiers = function parsePostMemberNameModifiers( // eslint-disable-next-line no-unused-vars\n  methodOrProp) {}; // Overridden in typescript.js\n\n\n  _proto.parseAccessModifier = function parseAccessModifier() {\n    return undefined;\n  };\n\n  _proto.parseClassPrivateProperty = function parseClassPrivateProperty(node) {\n    this.state.inClassProperty = true;\n    node.value = this.eat(types.eq) ? this.parseMaybeAssign() : null;\n    this.semicolon();\n    this.state.inClassProperty = false;\n    return this.finishNode(node, \"ClassPrivateProperty\");\n  };\n\n  _proto.parseClassProperty = function parseClassProperty(node) {\n    if (!node.typeAnnotation) {\n      this.expectPlugin(\"classProperties\");\n    }\n\n    this.state.inClassProperty = true;\n\n    if (this.match(types.eq)) {\n      this.expectPlugin(\"classProperties\");\n      this.next();\n      node.value = this.parseMaybeAssign();\n    } else {\n      node.value = null;\n    }\n\n    this.semicolon();\n    this.state.inClassProperty = false;\n    return this.finishNode(node, \"ClassProperty\");\n  };\n\n  _proto.parseClassId = function parseClassId(node, isStatement, optionalId) {\n    if (this.match(types.name)) {\n      node.id = this.parseIdentifier();\n    } else {\n      if (optionalId || !isStatement) {\n        node.id = null;\n      } else {\n        this.unexpected(null, \"A class name is required\");\n      }\n    }\n  };\n\n  _proto.parseClassSuper = function parseClassSuper(node) {\n    node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;\n  }; // Parses module export declaration.\n  // TODO: better type. Node is an N.AnyExport.\n\n\n  _proto.parseExport = function parseExport(node) {\n    // export * from '...'\n    if (this.shouldParseExportStar()) {\n      this.parseExportStar(node, this.hasPlugin(\"exportExtensions\"));\n      if (node.type === \"ExportAllDeclaration\") return node;\n    } else if (this.hasPlugin(\"exportExtensions\") && this.isExportDefaultSpecifier()) {\n      var specifier = this.startNode();\n      specifier.exported = this.parseIdentifier(true);\n      var specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\n      node.specifiers = specifiers;\n\n      if (this.match(types.comma) && this.lookahead().type === types.star) {\n        this.expect(types.comma);\n\n        var _specifier = this.startNode();\n\n        this.expect(types.star);\n        this.expectContextual(\"as\");\n        _specifier.exported = this.parseIdentifier();\n        specifiers.push(this.finishNode(_specifier, \"ExportNamespaceSpecifier\"));\n      } else {\n        this.parseExportSpecifiersMaybe(node);\n      }\n\n      this.parseExportFrom(node, true);\n    } else if (this.eat(types._default)) {\n      // export default ...\n      var expr = this.startNode();\n      var needsSemi = false;\n\n      if (this.eat(types._function)) {\n        expr = this.parseFunction(expr, true, false, false, true);\n      } else if (this.isContextual(\"async\") && this.lookahead().type === types._function) {\n        // async function declaration\n        this.eatContextual(\"async\");\n        this.eat(types._function);\n        expr = this.parseFunction(expr, true, false, true, true);\n      } else if (this.match(types._class)) {\n        expr = this.parseClass(expr, true, true);\n      } else {\n        needsSemi = true;\n        expr = this.parseMaybeAssign();\n      }\n\n      node.declaration = expr;\n      if (needsSemi) this.semicolon();\n      this.checkExport(node, true, true);\n      return this.finishNode(node, \"ExportDefaultDeclaration\");\n    } else if (this.shouldParseExportDeclaration()) {\n      if (this.isContextual(\"async\")) {\n        var next = this.lookahead(); // export async;\n\n        if (next.type !== types._function) {\n          this.unexpected(next.start, \"Unexpected token, expected function\");\n        }\n      }\n\n      node.specifiers = [];\n      node.source = null;\n      node.declaration = this.parseExportDeclaration(node);\n    } else {\n      // export { x, y as z } [from '...']\n      node.declaration = null;\n      node.specifiers = this.parseExportSpecifiers();\n      this.parseExportFrom(node);\n    }\n\n    this.checkExport(node, true);\n    return this.finishNode(node, \"ExportNamedDeclaration\");\n  }; // eslint-disable-next-line no-unused-vars\n\n\n  _proto.parseExportDeclaration = function parseExportDeclaration(node) {\n    return this.parseStatement(true);\n  };\n\n  _proto.isExportDefaultSpecifier = function isExportDefaultSpecifier() {\n    if (this.match(types.name)) {\n      return this.state.value !== \"async\";\n    }\n\n    if (!this.match(types._default)) {\n      return false;\n    }\n\n    var lookahead = this.lookahead();\n    return lookahead.type === types.comma || lookahead.type === types.name && lookahead.value === \"from\";\n  };\n\n  _proto.parseExportSpecifiersMaybe = function parseExportSpecifiersMaybe(node) {\n    if (this.eat(types.comma)) {\n      node.specifiers = node.specifiers.concat(this.parseExportSpecifiers());\n    }\n  };\n\n  _proto.parseExportFrom = function parseExportFrom(node, expect) {\n    if (this.eatContextual(\"from\")) {\n      node.source = this.match(types.string) ? this.parseExprAtom() : this.unexpected();\n      this.checkExport(node);\n    } else {\n      if (expect) {\n        this.unexpected();\n      } else {\n        node.source = null;\n      }\n    }\n\n    this.semicolon();\n  };\n\n  _proto.shouldParseExportStar = function shouldParseExportStar() {\n    return this.match(types.star);\n  };\n\n  _proto.parseExportStar = function parseExportStar(node, allowNamed) {\n    this.expect(types.star);\n\n    if (allowNamed && this.isContextual(\"as\")) {\n      var specifier = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);\n      this.next();\n      specifier.exported = this.parseIdentifier(true);\n      node.specifiers = [this.finishNode(specifier, \"ExportNamespaceSpecifier\")];\n      this.parseExportSpecifiersMaybe(node);\n      this.parseExportFrom(node, true);\n    } else {\n      this.parseExportFrom(node, true);\n      this.finishNode(node, \"ExportAllDeclaration\");\n    }\n  };\n\n  _proto.shouldParseExportDeclaration = function shouldParseExportDeclaration() {\n    return this.state.type.keyword === \"var\" || this.state.type.keyword === \"const\" || this.state.type.keyword === \"let\" || this.state.type.keyword === \"function\" || this.state.type.keyword === \"class\" || this.isContextual(\"async\") || this.match(types.at) && this.expectPlugin(\"decorators2\");\n  };\n\n  _proto.checkExport = function checkExport(node, checkNames, isDefault) {\n    if (checkNames) {\n      // Check for duplicate exports\n      if (isDefault) {\n        // Default exports\n        this.checkDuplicateExports(node, \"default\");\n      } else if (node.specifiers && node.specifiers.length) {\n        // Named exports\n        for (var _i4 = 0, _node$specifiers2 = node.specifiers; _i4 < _node$specifiers2.length; _i4++) {\n          var specifier = _node$specifiers2[_i4];\n          this.checkDuplicateExports(specifier, specifier.exported.name);\n        }\n      } else if (node.declaration) {\n        // Exported declarations\n        if (node.declaration.type === \"FunctionDeclaration\" || node.declaration.type === \"ClassDeclaration\") {\n          this.checkDuplicateExports(node, node.declaration.id.name);\n        } else if (node.declaration.type === \"VariableDeclaration\") {\n          for (var _i6 = 0, _node$declaration$dec2 = node.declaration.declarations; _i6 < _node$declaration$dec2.length; _i6++) {\n            var declaration = _node$declaration$dec2[_i6];\n            this.checkDeclaration(declaration.id);\n          }\n        }\n      }\n    }\n\n    var currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];\n\n    if (currentContextDecorators.length) {\n      var isClass = node.declaration && (node.declaration.type === \"ClassDeclaration\" || node.declaration.type === \"ClassExpression\");\n\n      if (!node.declaration || !isClass) {\n        throw this.raise(node.start, \"You can only use decorators on an export when exporting a class\");\n      }\n\n      this.takeDecorators(node.declaration);\n    }\n  };\n\n  _proto.checkDeclaration = function checkDeclaration(node) {\n    if (node.type === \"ObjectPattern\") {\n      for (var _i8 = 0, _node$properties2 = node.properties; _i8 < _node$properties2.length; _i8++) {\n        var prop = _node$properties2[_i8];\n        // $FlowFixMe (prop may be an AssignmentProperty, in which case this does nothing?)\n        this.checkDeclaration(prop);\n      }\n    } else if (node.type === \"ArrayPattern\") {\n      for (var _i10 = 0, _node$elements2 = node.elements; _i10 < _node$elements2.length; _i10++) {\n        var elem = _node$elements2[_i10];\n\n        if (elem) {\n          this.checkDeclaration(elem);\n        }\n      }\n    } else if (node.type === \"ObjectProperty\") {\n      this.checkDeclaration(node.value);\n    } else if (node.type === \"RestElement\") {\n      this.checkDeclaration(node.argument);\n    } else if (node.type === \"Identifier\") {\n      this.checkDuplicateExports(node, node.name);\n    }\n  };\n\n  _proto.checkDuplicateExports = function checkDuplicateExports(node, name) {\n    if (this.state.exportedIdentifiers.indexOf(name) > -1) {\n      this.raiseDuplicateExportError(node, name);\n    }\n\n    this.state.exportedIdentifiers.push(name);\n  };\n\n  _proto.raiseDuplicateExportError = function raiseDuplicateExportError(node, name) {\n    throw this.raise(node.start, name === \"default\" ? \"Only one default export allowed per module.\" : `\\`${name}\\` has already been exported. Exported identifiers must be unique.`);\n  }; // Parses a comma-separated list of module exports.\n\n\n  _proto.parseExportSpecifiers = function parseExportSpecifiers() {\n    var nodes = [];\n    var first = true;\n    var needsFrom; // export { x, y as z } [from '...']\n\n    this.expect(types.braceL);\n\n    while (!this.eat(types.braceR)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(types.comma);\n        if (this.eat(types.braceR)) break;\n      }\n\n      var isDefault = this.match(types._default);\n      if (isDefault && !needsFrom) needsFrom = true;\n      var node = this.startNode();\n      node.local = this.parseIdentifier(isDefault);\n      node.exported = this.eatContextual(\"as\") ? this.parseIdentifier(true) : node.local.__clone();\n      nodes.push(this.finishNode(node, \"ExportSpecifier\"));\n    } // https://github.com/ember-cli/ember-cli/pull/3739\n\n\n    if (needsFrom && !this.isContextual(\"from\")) {\n      this.unexpected();\n    }\n\n    return nodes;\n  }; // Parses import declaration.\n\n\n  _proto.parseImport = function parseImport(node) {\n    // import '...'\n    if (this.match(types.string)) {\n      node.specifiers = [];\n      node.source = this.parseExprAtom();\n    } else {\n      node.specifiers = [];\n      this.parseImportSpecifiers(node);\n      this.expectContextual(\"from\");\n      node.source = this.match(types.string) ? this.parseExprAtom() : this.unexpected();\n    }\n\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\");\n  }; // eslint-disable-next-line no-unused-vars\n\n\n  _proto.shouldParseDefaultImport = function shouldParseDefaultImport(node) {\n    return this.match(types.name);\n  };\n\n  _proto.parseImportSpecifierLocal = function parseImportSpecifierLocal(node, specifier, type, contextDescription) {\n    specifier.local = this.parseIdentifier();\n    this.checkLVal(specifier.local, true, undefined, contextDescription);\n    node.specifiers.push(this.finishNode(specifier, type));\n  }; // Parses a comma-separated list of module imports.\n\n\n  _proto.parseImportSpecifiers = function parseImportSpecifiers(node) {\n    var first = true;\n\n    if (this.shouldParseDefaultImport(node)) {\n      // import defaultObj, { x, y as z } from '...'\n      this.parseImportSpecifierLocal(node, this.startNode(), \"ImportDefaultSpecifier\", \"default import specifier\");\n      if (!this.eat(types.comma)) return;\n    }\n\n    if (this.match(types.star)) {\n      var specifier = this.startNode();\n      this.next();\n      this.expectContextual(\"as\");\n      this.parseImportSpecifierLocal(node, specifier, \"ImportNamespaceSpecifier\", \"import namespace specifier\");\n      return;\n    }\n\n    this.expect(types.braceL);\n\n    while (!this.eat(types.braceR)) {\n      if (first) {\n        first = false;\n      } else {\n        // Detect an attempt to deep destructure\n        if (this.eat(types.colon)) {\n          this.unexpected(null, \"ES2015 named imports do not destructure. Use another statement for destructuring after the import.\");\n        }\n\n        this.expect(types.comma);\n        if (this.eat(types.braceR)) break;\n      }\n\n      this.parseImportSpecifier(node);\n    }\n  };\n\n  _proto.parseImportSpecifier = function parseImportSpecifier(node) {\n    var specifier = this.startNode();\n    specifier.imported = this.parseIdentifier(true);\n\n    if (this.eatContextual(\"as\")) {\n      specifier.local = this.parseIdentifier();\n    } else {\n      this.checkReservedWord(specifier.imported.name, specifier.start, true, true);\n      specifier.local = specifier.imported.__clone();\n    }\n\n    this.checkLVal(specifier.local, true, undefined, \"import specifier\");\n    node.specifiers.push(this.finishNode(specifier, \"ImportSpecifier\"));\n  };\n\n  return StatementParser;\n}(ExpressionParser);\n\nvar plugins = {};\n\nvar Parser =\n/*#__PURE__*/\nfunction (_StatementParser) {\n  _inheritsLoose(Parser, _StatementParser);\n\n  function Parser(options, input) {\n    var _this;\n\n    options = getOptions(options);\n    _this = _StatementParser.call(this, options, input) || this;\n    _this.options = options;\n    _this.inModule = _this.options.sourceType === \"module\";\n    _this.input = input;\n    _this.plugins = pluginsMap(_this.options.plugins);\n    _this.filename = options.sourceFilename; // If enabled, skip leading hashbang line.\n\n    if (_this.state.pos === 0 && _this.input[0] === \"#\" && _this.input[1] === \"!\") {\n      _this.skipLineComment(2);\n    }\n\n    return _this;\n  }\n\n  var _proto = Parser.prototype;\n\n  _proto.parse = function parse() {\n    var file = this.startNode();\n    var program = this.startNode();\n    this.nextToken();\n    return this.parseTopLevel(file, program);\n  };\n\n  return Parser;\n}(StatementParser);\n\nfunction pluginsMap(pluginList) {\n  var pluginMap = {};\n\n  for (var _i2 = 0; _i2 < pluginList.length; _i2++) {\n    var _name = pluginList[_i2];\n    pluginMap[_name] = true;\n  }\n\n  return pluginMap;\n}\n\nfunction isSimpleProperty(node) {\n  return node != null && node.type === \"Property\" && node.kind === \"init\" && node.method === false;\n}\n\nvar estreePlugin = (function (superClass) {\n  return (\n    /*#__PURE__*/\n    function (_superClass) {\n      _inheritsLoose(_class, _superClass);\n\n      function _class() {\n        return _superClass.apply(this, arguments) || this;\n      }\n\n      var _proto = _class.prototype;\n\n      _proto.estreeParseRegExpLiteral = function estreeParseRegExpLiteral(_ref) {\n        var pattern = _ref.pattern,\n            flags = _ref.flags;\n        var regex = null;\n\n        try {\n          regex = new RegExp(pattern, flags);\n        } catch (e) {// In environments that don't support these flags value will\n          // be null as the regex can't be represented natively.\n        }\n\n        var node = this.estreeParseLiteral(regex);\n        node.regex = {\n          pattern,\n          flags\n        };\n        return node;\n      };\n\n      _proto.estreeParseLiteral = function estreeParseLiteral(value) {\n        return this.parseLiteral(value, \"Literal\");\n      };\n\n      _proto.directiveToStmt = function directiveToStmt(directive) {\n        var directiveLiteral = directive.value;\n        var stmt = this.startNodeAt(directive.start, directive.loc.start);\n        var expression = this.startNodeAt(directiveLiteral.start, directiveLiteral.loc.start);\n        expression.value = directiveLiteral.value;\n        expression.raw = directiveLiteral.extra.raw;\n        stmt.expression = this.finishNodeAt(expression, \"Literal\", directiveLiteral.end, directiveLiteral.loc.end);\n        stmt.directive = directiveLiteral.extra.raw.slice(1, -1);\n        return this.finishNodeAt(stmt, \"ExpressionStatement\", directive.end, directive.loc.end);\n      }; // ==================================\n      // Overrides\n      // ==================================\n\n\n      _proto.checkDeclaration = function checkDeclaration(node) {\n        if (isSimpleProperty(node)) {\n          // $FlowFixMe\n          this.checkDeclaration(node.value);\n        } else {\n          _superClass.prototype.checkDeclaration.call(this, node);\n        }\n      };\n\n      _proto.checkGetterSetterParamCount = function checkGetterSetterParamCount(prop) {\n        var paramCount = prop.kind === \"get\" ? 0 : 1; // $FlowFixMe (prop.value present for ObjectMethod, but for ClassMethod should use prop.params?)\n\n        if (prop.value.params.length !== paramCount) {\n          var start = prop.start;\n\n          if (prop.kind === \"get\") {\n            this.raise(start, \"getter should have no params\");\n          } else {\n            this.raise(start, \"setter should have exactly one param\");\n          }\n        }\n      };\n\n      _proto.checkLVal = function checkLVal(expr, isBinding, checkClashes, contextDescription) {\n        var _this = this;\n\n        switch (expr.type) {\n          case \"ObjectPattern\":\n            expr.properties.forEach(function (prop) {\n              _this.checkLVal(prop.type === \"Property\" ? prop.value : prop, isBinding, checkClashes, \"object destructuring pattern\");\n            });\n            break;\n\n          default:\n            _superClass.prototype.checkLVal.call(this, expr, isBinding, checkClashes, contextDescription);\n\n        }\n      };\n\n      _proto.checkPropClash = function checkPropClash(prop, propHash) {\n        if (prop.computed || !isSimpleProperty(prop)) return;\n        var key = prop.key; // It is either an Identifier or a String/NumericLiteral\n\n        var name = key.type === \"Identifier\" ? key.name : String(key.value);\n\n        if (name === \"__proto__\") {\n          if (propHash.proto) {\n            this.raise(key.start, \"Redefinition of __proto__ property\");\n          }\n\n          propHash.proto = true;\n        }\n      };\n\n      _proto.isStrictBody = function isStrictBody(node, isExpression) {\n        if (!isExpression && node.body.body.length > 0) {\n          for (var _i2 = 0, _node$body$body2 = node.body.body; _i2 < _node$body$body2.length; _i2++) {\n            var directive = _node$body$body2[_i2];\n\n            if (directive.type === \"ExpressionStatement\" && directive.expression.type === \"Literal\") {\n              if (directive.expression.value === \"use strict\") return true;\n            } else {\n              // Break for the first non literal expression\n              break;\n            }\n          }\n        }\n\n        return false;\n      };\n\n      _proto.isValidDirective = function isValidDirective(stmt) {\n        return stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"Literal\" && typeof stmt.expression.value === \"string\" && (!stmt.expression.extra || !stmt.expression.extra.parenthesized);\n      };\n\n      _proto.stmtToDirective = function stmtToDirective(stmt) {\n        var directive = _superClass.prototype.stmtToDirective.call(this, stmt);\n\n        var value = stmt.expression.value; // Reset value to the actual value as in estree mode we want\n        // the stmt to have the real value and not the raw value\n\n        directive.value.value = value;\n        return directive;\n      };\n\n      _proto.parseBlockBody = function parseBlockBody(node, allowDirectives, topLevel, end) {\n        var _this2 = this;\n\n        _superClass.prototype.parseBlockBody.call(this, node, allowDirectives, topLevel, end);\n\n        var directiveStatements = node.directives.map(function (d) {\n          return _this2.directiveToStmt(d);\n        });\n        node.body = directiveStatements.concat(node.body);\n        delete node.directives;\n      };\n\n      _proto.pushClassMethod = function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor) {\n        this.parseMethod(method, isGenerator, isAsync, isConstructor, \"MethodDefinition\");\n\n        if (method.typeParameters) {\n          // $FlowIgnore\n          method.value.typeParameters = method.typeParameters;\n          delete method.typeParameters;\n        }\n\n        classBody.body.push(method);\n      };\n\n      _proto.parseExprAtom = function parseExprAtom(refShorthandDefaultPos) {\n        switch (this.state.type) {\n          case types.regexp:\n            return this.estreeParseRegExpLiteral(this.state.value);\n\n          case types.num:\n          case types.string:\n            return this.estreeParseLiteral(this.state.value);\n\n          case types._null:\n            return this.estreeParseLiteral(null);\n\n          case types._true:\n            return this.estreeParseLiteral(true);\n\n          case types._false:\n            return this.estreeParseLiteral(false);\n\n          default:\n            return _superClass.prototype.parseExprAtom.call(this, refShorthandDefaultPos);\n        }\n      };\n\n      _proto.parseLiteral = function parseLiteral(value, type, startPos, startLoc) {\n        var node = _superClass.prototype.parseLiteral.call(this, value, type, startPos, startLoc);\n\n        node.raw = node.extra.raw;\n        delete node.extra;\n        return node;\n      };\n\n      _proto.parseMethod = function parseMethod(node, isGenerator, isAsync, isConstructor, type) {\n        var funcNode = this.startNode();\n        funcNode.kind = node.kind; // provide kind, so super method correctly sets state\n\n        funcNode = _superClass.prototype.parseMethod.call(this, funcNode, isGenerator, isAsync, isConstructor, \"FunctionExpression\");\n        delete funcNode.kind; // $FlowIgnore\n\n        node.value = funcNode;\n        return this.finishNode(node, type);\n      };\n\n      _proto.parseObjectMethod = function parseObjectMethod(prop, isGenerator, isAsync, isPattern) {\n        var node = _superClass.prototype.parseObjectMethod.call(this, prop, isGenerator, isAsync, isPattern);\n\n        if (node) {\n          node.type = \"Property\";\n          if (node.kind === \"method\") node.kind = \"init\";\n          node.shorthand = false;\n        }\n\n        return node;\n      };\n\n      _proto.parseObjectProperty = function parseObjectProperty(prop, startPos, startLoc, isPattern, refShorthandDefaultPos) {\n        var node = _superClass.prototype.parseObjectProperty.call(this, prop, startPos, startLoc, isPattern, refShorthandDefaultPos);\n\n        if (node) {\n          node.kind = \"init\";\n          node.type = \"Property\";\n        }\n\n        return node;\n      };\n\n      _proto.toAssignable = function toAssignable(node, isBinding, contextDescription) {\n        if (isSimpleProperty(node)) {\n          this.toAssignable(node.value, isBinding, contextDescription);\n          return node;\n        }\n\n        return _superClass.prototype.toAssignable.call(this, node, isBinding, contextDescription);\n      };\n\n      _proto.toAssignableObjectExpressionProp = function toAssignableObjectExpressionProp(prop, isBinding, isLast) {\n        if (prop.kind === \"get\" || prop.kind === \"set\") {\n          this.raise(prop.key.start, \"Object pattern can't contain getter or setter\");\n        } else if (prop.method) {\n          this.raise(prop.key.start, \"Object pattern can't contain methods\");\n        } else {\n          _superClass.prototype.toAssignableObjectExpressionProp.call(this, prop, isBinding, isLast);\n        }\n      };\n\n      return _class;\n    }(superClass)\n  );\n});\n\n/* eslint max-len: 0 */\nvar primitiveTypes = [\"any\", \"bool\", \"boolean\", \"empty\", \"false\", \"mixed\", \"null\", \"number\", \"static\", \"string\", \"true\", \"typeof\", \"void\"];\n\nfunction isEsModuleType(bodyElement) {\n  return bodyElement.type === \"DeclareExportAllDeclaration\" || bodyElement.type === \"DeclareExportDeclaration\" && (!bodyElement.declaration || bodyElement.declaration.type !== \"TypeAlias\" && bodyElement.declaration.type !== \"InterfaceDeclaration\");\n}\n\nfunction hasTypeImportKind(node) {\n  return node.importKind === \"type\" || node.importKind === \"typeof\";\n}\n\nfunction isMaybeDefaultImport(state) {\n  return (state.type === types.name || !!state.type.keyword) && state.value !== \"from\";\n}\n\nvar exportSuggestions = {\n  const: \"declare export var\",\n  let: \"declare export var\",\n  type: \"export type\",\n  interface: \"export interface\"\n}; // Like Array#filter, but returns a tuple [ acceptedElements, discardedElements ]\n\nfunction partition(list, test) {\n  var list1 = [];\n  var list2 = [];\n\n  for (var i = 0; i < list.length; i++) {\n    (test(list[i], i, list) ? list1 : list2).push(list[i]);\n  }\n\n  return [list1, list2];\n}\n\nvar flowPlugin = (function (superClass) {\n  return (\n    /*#__PURE__*/\n    function (_superClass) {\n      _inheritsLoose(_class, _superClass);\n\n      function _class() {\n        return _superClass.apply(this, arguments) || this;\n      }\n\n      var _proto = _class.prototype;\n\n      _proto.flowParseTypeInitialiser = function flowParseTypeInitialiser(tok) {\n        var oldInType = this.state.inType;\n        this.state.inType = true;\n        this.expect(tok || types.colon);\n        var type = this.flowParseType();\n        this.state.inType = oldInType;\n        return type;\n      };\n\n      _proto.flowParsePredicate = function flowParsePredicate() {\n        var node = this.startNode();\n        var moduloLoc = this.state.startLoc;\n        var moduloPos = this.state.start;\n        this.expect(types.modulo);\n        var checksLoc = this.state.startLoc;\n        this.expectContextual(\"checks\"); // Force '%' and 'checks' to be adjacent\n\n        if (moduloLoc.line !== checksLoc.line || moduloLoc.column !== checksLoc.column - 1) {\n          this.raise(moduloPos, \"Spaces between ´%´ and ´checks´ are not allowed here.\");\n        }\n\n        if (this.eat(types.parenL)) {\n          node.value = this.parseExpression();\n          this.expect(types.parenR);\n          return this.finishNode(node, \"DeclaredPredicate\");\n        } else {\n          return this.finishNode(node, \"InferredPredicate\");\n        }\n      };\n\n      _proto.flowParseTypeAndPredicateInitialiser = function flowParseTypeAndPredicateInitialiser() {\n        var oldInType = this.state.inType;\n        this.state.inType = true;\n        this.expect(types.colon);\n        var type = null;\n        var predicate = null;\n\n        if (this.match(types.modulo)) {\n          this.state.inType = oldInType;\n          predicate = this.flowParsePredicate();\n        } else {\n          type = this.flowParseType();\n          this.state.inType = oldInType;\n\n          if (this.match(types.modulo)) {\n            predicate = this.flowParsePredicate();\n          }\n        }\n\n        return [type, predicate];\n      };\n\n      _proto.flowParseDeclareClass = function flowParseDeclareClass(node) {\n        this.next();\n        this.flowParseInterfaceish(node);\n        return this.finishNode(node, \"DeclareClass\");\n      };\n\n      _proto.flowParseDeclareFunction = function flowParseDeclareFunction(node) {\n        this.next();\n        var id = node.id = this.parseIdentifier();\n        var typeNode = this.startNode();\n        var typeContainer = this.startNode();\n\n        if (this.isRelational(\"<\")) {\n          typeNode.typeParameters = this.flowParseTypeParameterDeclaration();\n        } else {\n          typeNode.typeParameters = null;\n        }\n\n        this.expect(types.parenL);\n        var tmp = this.flowParseFunctionTypeParams();\n        typeNode.params = tmp.params;\n        typeNode.rest = tmp.rest;\n        this.expect(types.parenR);\n\n        var _flowParseTypeAndPred = this.flowParseTypeAndPredicateInitialiser();\n\n        // $FlowFixMe (destructuring not supported yet)\n        typeNode.returnType = _flowParseTypeAndPred[0];\n        // $FlowFixMe (destructuring not supported yet)\n        node.predicate = _flowParseTypeAndPred[1];\n        typeContainer.typeAnnotation = this.finishNode(typeNode, \"FunctionTypeAnnotation\");\n        id.typeAnnotation = this.finishNode(typeContainer, \"TypeAnnotation\");\n        this.finishNode(id, id.type);\n        this.semicolon();\n        return this.finishNode(node, \"DeclareFunction\");\n      };\n\n      _proto.flowParseDeclare = function flowParseDeclare(node, insideModule) {\n        if (this.match(types._class)) {\n          return this.flowParseDeclareClass(node);\n        } else if (this.match(types._function)) {\n          return this.flowParseDeclareFunction(node);\n        } else if (this.match(types._var)) {\n          return this.flowParseDeclareVariable(node);\n        } else if (this.isContextual(\"module\")) {\n          if (this.lookahead().type === types.dot) {\n            return this.flowParseDeclareModuleExports(node);\n          } else {\n            if (insideModule) {\n              this.unexpected(null, \"`declare module` cannot be used inside another `declare module`\");\n            }\n\n            return this.flowParseDeclareModule(node);\n          }\n        } else if (this.isContextual(\"type\")) {\n          return this.flowParseDeclareTypeAlias(node);\n        } else if (this.isContextual(\"opaque\")) {\n          return this.flowParseDeclareOpaqueType(node);\n        } else if (this.isContextual(\"interface\")) {\n          return this.flowParseDeclareInterface(node);\n        } else if (this.match(types._export)) {\n          return this.flowParseDeclareExportDeclaration(node, insideModule);\n        } else {\n          throw this.unexpected();\n        }\n      };\n\n      _proto.flowParseDeclareVariable = function flowParseDeclareVariable(node) {\n        this.next();\n        node.id = this.flowParseTypeAnnotatableIdentifier(\n        /*allowPrimitiveOverride*/\n        true);\n        this.semicolon();\n        return this.finishNode(node, \"DeclareVariable\");\n      };\n\n      _proto.flowParseDeclareModule = function flowParseDeclareModule(node) {\n        var _this = this;\n\n        this.next();\n\n        if (this.match(types.string)) {\n          node.id = this.parseExprAtom();\n        } else {\n          node.id = this.parseIdentifier();\n        }\n\n        var bodyNode = node.body = this.startNode();\n        var body = bodyNode.body = [];\n        this.expect(types.braceL);\n\n        while (!this.match(types.braceR)) {\n          var _bodyNode = this.startNode();\n\n          if (this.match(types._import)) {\n            var lookahead = this.lookahead();\n\n            if (lookahead.value !== \"type\" && lookahead.value !== \"typeof\") {\n              this.unexpected(null, \"Imports within a `declare module` body must always be `import type` or `import typeof`\");\n            }\n\n            this.next();\n            this.parseImport(_bodyNode);\n          } else {\n            this.expectContextual(\"declare\", \"Only declares and type imports are allowed inside declare module\");\n            _bodyNode = this.flowParseDeclare(_bodyNode, true);\n          }\n\n          body.push(_bodyNode);\n        }\n\n        this.expect(types.braceR);\n        this.finishNode(bodyNode, \"BlockStatement\");\n        var kind = null;\n        var hasModuleExport = false;\n        var errorMessage = \"Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module\";\n        body.forEach(function (bodyElement) {\n          if (isEsModuleType(bodyElement)) {\n            if (kind === \"CommonJS\") {\n              _this.unexpected(bodyElement.start, errorMessage);\n            }\n\n            kind = \"ES\";\n          } else if (bodyElement.type === \"DeclareModuleExports\") {\n            if (hasModuleExport) {\n              _this.unexpected(bodyElement.start, \"Duplicate `declare module.exports` statement\");\n            }\n\n            if (kind === \"ES\") _this.unexpected(bodyElement.start, errorMessage);\n            kind = \"CommonJS\";\n            hasModuleExport = true;\n          }\n        });\n        node.kind = kind || \"CommonJS\";\n        return this.finishNode(node, \"DeclareModule\");\n      };\n\n      _proto.flowParseDeclareExportDeclaration = function flowParseDeclareExportDeclaration(node, insideModule) {\n        this.expect(types._export);\n\n        if (this.eat(types._default)) {\n          if (this.match(types._function) || this.match(types._class)) {\n            // declare export default class ...\n            // declare export default function ...\n            node.declaration = this.flowParseDeclare(this.startNode());\n          } else {\n            // declare export default [type];\n            node.declaration = this.flowParseType();\n            this.semicolon();\n          }\n\n          node.default = true;\n          return this.finishNode(node, \"DeclareExportDeclaration\");\n        } else {\n          if (this.match(types._const) || this.match(types._let) || (this.isContextual(\"type\") || this.isContextual(\"interface\")) && !insideModule) {\n            var label = this.state.value;\n            var suggestion = exportSuggestions[label];\n            this.unexpected(this.state.start, `\\`declare export ${label}\\` is not supported. Use \\`${suggestion}\\` instead`);\n          }\n\n          if (this.match(types._var) || // declare export var ...\n          this.match(types._function) || // declare export function ...\n          this.match(types._class) || // declare export class ...\n          this.isContextual(\"opaque\") // declare export opaque ..\n          ) {\n              node.declaration = this.flowParseDeclare(this.startNode());\n              node.default = false;\n              return this.finishNode(node, \"DeclareExportDeclaration\");\n            } else if (this.match(types.star) || // declare export * from ''\n          this.match(types.braceL) || // declare export {} ...\n          this.isContextual(\"interface\") || // declare export interface ...\n          this.isContextual(\"type\") || // declare export type ...\n          this.isContextual(\"opaque\") // declare export opaque type ...\n          ) {\n              node = this.parseExport(node);\n\n              if (node.type === \"ExportNamedDeclaration\") {\n                // flow does not support the ExportNamedDeclaration\n                // $FlowIgnore\n                node.type = \"ExportDeclaration\"; // $FlowFixMe\n\n                node.default = false;\n                delete node.exportKind;\n              } // $FlowIgnore\n\n\n              node.type = \"Declare\" + node.type;\n              return node;\n            }\n        }\n\n        throw this.unexpected();\n      };\n\n      _proto.flowParseDeclareModuleExports = function flowParseDeclareModuleExports(node) {\n        this.expectContextual(\"module\");\n        this.expect(types.dot);\n        this.expectContextual(\"exports\");\n        node.typeAnnotation = this.flowParseTypeAnnotation();\n        this.semicolon();\n        return this.finishNode(node, \"DeclareModuleExports\");\n      };\n\n      _proto.flowParseDeclareTypeAlias = function flowParseDeclareTypeAlias(node) {\n        this.next();\n        this.flowParseTypeAlias(node);\n        return this.finishNode(node, \"DeclareTypeAlias\");\n      };\n\n      _proto.flowParseDeclareOpaqueType = function flowParseDeclareOpaqueType(node) {\n        this.next();\n        this.flowParseOpaqueType(node, true);\n        return this.finishNode(node, \"DeclareOpaqueType\");\n      };\n\n      _proto.flowParseDeclareInterface = function flowParseDeclareInterface(node) {\n        this.next();\n        this.flowParseInterfaceish(node);\n        return this.finishNode(node, \"DeclareInterface\");\n      }; // Interfaces\n\n\n      _proto.flowParseInterfaceish = function flowParseInterfaceish(node) {\n        node.id = this.parseIdentifier();\n\n        if (this.isRelational(\"<\")) {\n          node.typeParameters = this.flowParseTypeParameterDeclaration();\n        } else {\n          node.typeParameters = null;\n        }\n\n        node.extends = [];\n        node.mixins = [];\n\n        if (this.eat(types._extends)) {\n          do {\n            node.extends.push(this.flowParseInterfaceExtends());\n          } while (this.eat(types.comma));\n        }\n\n        if (this.isContextual(\"mixins\")) {\n          this.next();\n\n          do {\n            node.mixins.push(this.flowParseInterfaceExtends());\n          } while (this.eat(types.comma));\n        }\n\n        node.body = this.flowParseObjectType(true, false, false);\n      };\n\n      _proto.flowParseInterfaceExtends = function flowParseInterfaceExtends() {\n        var node = this.startNode();\n        node.id = this.flowParseQualifiedTypeIdentifier();\n\n        if (this.isRelational(\"<\")) {\n          node.typeParameters = this.flowParseTypeParameterInstantiation();\n        } else {\n          node.typeParameters = null;\n        }\n\n        return this.finishNode(node, \"InterfaceExtends\");\n      };\n\n      _proto.flowParseInterface = function flowParseInterface(node) {\n        this.flowParseInterfaceish(node);\n        return this.finishNode(node, \"InterfaceDeclaration\");\n      };\n\n      _proto.checkReservedType = function checkReservedType(word, startLoc) {\n        if (primitiveTypes.indexOf(word) > -1) {\n          this.raise(startLoc, `Cannot overwrite primitive type ${word}`);\n        }\n      };\n\n      _proto.flowParseRestrictedIdentifier = function flowParseRestrictedIdentifier(liberal) {\n        this.checkReservedType(this.state.value, this.state.start);\n        return this.parseIdentifier(liberal);\n      }; // Type aliases\n\n\n      _proto.flowParseTypeAlias = function flowParseTypeAlias(node) {\n        node.id = this.flowParseRestrictedIdentifier();\n\n        if (this.isRelational(\"<\")) {\n          node.typeParameters = this.flowParseTypeParameterDeclaration();\n        } else {\n          node.typeParameters = null;\n        }\n\n        node.right = this.flowParseTypeInitialiser(types.eq);\n        this.semicolon();\n        return this.finishNode(node, \"TypeAlias\");\n      };\n\n      _proto.flowParseOpaqueType = function flowParseOpaqueType(node, declare) {\n        this.expectContextual(\"type\");\n        node.id = this.flowParseRestrictedIdentifier();\n\n        if (this.isRelational(\"<\")) {\n          node.typeParameters = this.flowParseTypeParameterDeclaration();\n        } else {\n          node.typeParameters = null;\n        } // Parse the supertype\n\n\n        node.supertype = null;\n\n        if (this.match(types.colon)) {\n          node.supertype = this.flowParseTypeInitialiser(types.colon);\n        }\n\n        node.impltype = null;\n\n        if (!declare) {\n          node.impltype = this.flowParseTypeInitialiser(types.eq);\n        }\n\n        this.semicolon();\n        return this.finishNode(node, \"OpaqueType\");\n      }; // Type annotations\n\n\n      _proto.flowParseTypeParameter = function flowParseTypeParameter() {\n        var node = this.startNode();\n        var variance = this.flowParseVariance();\n        var ident = this.flowParseTypeAnnotatableIdentifier();\n        node.name = ident.name;\n        node.variance = variance;\n        node.bound = ident.typeAnnotation;\n\n        if (this.match(types.eq)) {\n          this.eat(types.eq);\n          node.default = this.flowParseType();\n        }\n\n        return this.finishNode(node, \"TypeParameter\");\n      };\n\n      _proto.flowParseTypeParameterDeclaration = function flowParseTypeParameterDeclaration() {\n        var oldInType = this.state.inType;\n        var node = this.startNode();\n        node.params = [];\n        this.state.inType = true; // istanbul ignore else: this condition is already checked at all call sites\n\n        if (this.isRelational(\"<\") || this.match(types.jsxTagStart)) {\n          this.next();\n        } else {\n          this.unexpected();\n        }\n\n        do {\n          node.params.push(this.flowParseTypeParameter());\n\n          if (!this.isRelational(\">\")) {\n            this.expect(types.comma);\n          }\n        } while (!this.isRelational(\">\"));\n\n        this.expectRelational(\">\");\n        this.state.inType = oldInType;\n        return this.finishNode(node, \"TypeParameterDeclaration\");\n      };\n\n      _proto.flowParseTypeParameterInstantiation = function flowParseTypeParameterInstantiation() {\n        var node = this.startNode();\n        var oldInType = this.state.inType;\n        node.params = [];\n        this.state.inType = true;\n        this.expectRelational(\"<\");\n\n        while (!this.isRelational(\">\")) {\n          node.params.push(this.flowParseType());\n\n          if (!this.isRelational(\">\")) {\n            this.expect(types.comma);\n          }\n        }\n\n        this.expectRelational(\">\");\n        this.state.inType = oldInType;\n        return this.finishNode(node, \"TypeParameterInstantiation\");\n      };\n\n      _proto.flowParseObjectPropertyKey = function flowParseObjectPropertyKey() {\n        return this.match(types.num) || this.match(types.string) ? this.parseExprAtom() : this.parseIdentifier(true);\n      };\n\n      _proto.flowParseObjectTypeIndexer = function flowParseObjectTypeIndexer(node, isStatic, variance) {\n        node.static = isStatic;\n        this.expect(types.bracketL);\n\n        if (this.lookahead().type === types.colon) {\n          node.id = this.flowParseObjectPropertyKey();\n          node.key = this.flowParseTypeInitialiser();\n        } else {\n          node.id = null;\n          node.key = this.flowParseType();\n        }\n\n        this.expect(types.bracketR);\n        node.value = this.flowParseTypeInitialiser();\n        node.variance = variance;\n        return this.finishNode(node, \"ObjectTypeIndexer\");\n      };\n\n      _proto.flowParseObjectTypeMethodish = function flowParseObjectTypeMethodish(node) {\n        node.params = [];\n        node.rest = null;\n        node.typeParameters = null;\n\n        if (this.isRelational(\"<\")) {\n          node.typeParameters = this.flowParseTypeParameterDeclaration();\n        }\n\n        this.expect(types.parenL);\n\n        while (!this.match(types.parenR) && !this.match(types.ellipsis)) {\n          node.params.push(this.flowParseFunctionTypeParam());\n\n          if (!this.match(types.parenR)) {\n            this.expect(types.comma);\n          }\n        }\n\n        if (this.eat(types.ellipsis)) {\n          node.rest = this.flowParseFunctionTypeParam();\n        }\n\n        this.expect(types.parenR);\n        node.returnType = this.flowParseTypeInitialiser();\n        return this.finishNode(node, \"FunctionTypeAnnotation\");\n      };\n\n      _proto.flowParseObjectTypeCallProperty = function flowParseObjectTypeCallProperty(node, isStatic) {\n        var valueNode = this.startNode();\n        node.static = isStatic;\n        node.value = this.flowParseObjectTypeMethodish(valueNode);\n        return this.finishNode(node, \"ObjectTypeCallProperty\");\n      };\n\n      _proto.flowParseObjectType = function flowParseObjectType(allowStatic, allowExact, allowSpread) {\n        var oldInType = this.state.inType;\n        this.state.inType = true;\n        var nodeStart = this.startNode();\n        nodeStart.callProperties = [];\n        nodeStart.properties = [];\n        nodeStart.indexers = [];\n        var endDelim;\n        var exact;\n\n        if (allowExact && this.match(types.braceBarL)) {\n          this.expect(types.braceBarL);\n          endDelim = types.braceBarR;\n          exact = true;\n        } else {\n          this.expect(types.braceL);\n          endDelim = types.braceR;\n          exact = false;\n        }\n\n        nodeStart.exact = exact;\n\n        while (!this.match(endDelim)) {\n          var isStatic = false;\n          var node = this.startNode();\n\n          if (allowStatic && this.isContextual(\"static\") && this.lookahead().type !== types.colon) {\n            this.next();\n            isStatic = true;\n          }\n\n          var variance = this.flowParseVariance();\n\n          if (this.match(types.bracketL)) {\n            nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));\n          } else if (this.match(types.parenL) || this.isRelational(\"<\")) {\n            if (variance) {\n              this.unexpected(variance.start);\n            }\n\n            nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));\n          } else {\n            var kind = \"init\";\n\n            if (this.isContextual(\"get\") || this.isContextual(\"set\")) {\n              var lookahead = this.lookahead();\n\n              if (lookahead.type === types.name || lookahead.type === types.string || lookahead.type === types.num) {\n                kind = this.state.value;\n                this.next();\n              }\n            }\n\n            nodeStart.properties.push(this.flowParseObjectTypeProperty(node, isStatic, variance, kind, allowSpread));\n          }\n\n          this.flowObjectTypeSemicolon();\n        }\n\n        this.expect(endDelim);\n        var out = this.finishNode(nodeStart, \"ObjectTypeAnnotation\");\n        this.state.inType = oldInType;\n        return out;\n      };\n\n      _proto.flowParseObjectTypeProperty = function flowParseObjectTypeProperty(node, isStatic, variance, kind, allowSpread) {\n        if (this.match(types.ellipsis)) {\n          if (!allowSpread) {\n            this.unexpected(null, \"Spread operator cannot appear in class or interface definitions\");\n          }\n\n          if (variance) {\n            this.unexpected(variance.start, \"Spread properties cannot have variance\");\n          }\n\n          this.expect(types.ellipsis);\n          node.argument = this.flowParseType();\n          return this.finishNode(node, \"ObjectTypeSpreadProperty\");\n        } else {\n          node.key = this.flowParseObjectPropertyKey();\n          node.static = isStatic;\n          node.kind = kind;\n          var optional = false;\n\n          if (this.isRelational(\"<\") || this.match(types.parenL)) {\n            // This is a method property\n            if (variance) {\n              this.unexpected(variance.start);\n            }\n\n            node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));\n\n            if (kind === \"get\" || kind === \"set\") {\n              this.flowCheckGetterSetterParamCount(node);\n            }\n          } else {\n            if (kind !== \"init\") this.unexpected();\n\n            if (this.eat(types.question)) {\n              optional = true;\n            }\n\n            node.value = this.flowParseTypeInitialiser();\n            node.variance = variance;\n          }\n\n          node.optional = optional;\n          return this.finishNode(node, \"ObjectTypeProperty\");\n        }\n      }; // This is similar to checkGetterSetterParamCount, but as\n      // babylon uses non estree properties we cannot reuse it here\n\n\n      _proto.flowCheckGetterSetterParamCount = function flowCheckGetterSetterParamCount(property) {\n        var paramCount = property.kind === \"get\" ? 0 : 1;\n\n        if (property.value.params.length !== paramCount) {\n          var start = property.start;\n\n          if (property.kind === \"get\") {\n            this.raise(start, \"getter should have no params\");\n          } else {\n            this.raise(start, \"setter should have exactly one param\");\n          }\n        }\n      };\n\n      _proto.flowObjectTypeSemicolon = function flowObjectTypeSemicolon() {\n        if (!this.eat(types.semi) && !this.eat(types.comma) && !this.match(types.braceR) && !this.match(types.braceBarR)) {\n          this.unexpected();\n        }\n      };\n\n      _proto.flowParseQualifiedTypeIdentifier = function flowParseQualifiedTypeIdentifier(startPos, startLoc, id) {\n        startPos = startPos || this.state.start;\n        startLoc = startLoc || this.state.startLoc;\n        var node = id || this.parseIdentifier();\n\n        while (this.eat(types.dot)) {\n          var node2 = this.startNodeAt(startPos, startLoc);\n          node2.qualification = node;\n          node2.id = this.parseIdentifier();\n          node = this.finishNode(node2, \"QualifiedTypeIdentifier\");\n        }\n\n        return node;\n      };\n\n      _proto.flowParseGenericType = function flowParseGenericType(startPos, startLoc, id) {\n        var node = this.startNodeAt(startPos, startLoc);\n        node.typeParameters = null;\n        node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);\n\n        if (this.isRelational(\"<\")) {\n          node.typeParameters = this.flowParseTypeParameterInstantiation();\n        }\n\n        return this.finishNode(node, \"GenericTypeAnnotation\");\n      };\n\n      _proto.flowParseTypeofType = function flowParseTypeofType() {\n        var node = this.startNode();\n        this.expect(types._typeof);\n        node.argument = this.flowParsePrimaryType();\n        return this.finishNode(node, \"TypeofTypeAnnotation\");\n      };\n\n      _proto.flowParseTupleType = function flowParseTupleType() {\n        var node = this.startNode();\n        node.types = [];\n        this.expect(types.bracketL); // We allow trailing commas\n\n        while (this.state.pos < this.input.length && !this.match(types.bracketR)) {\n          node.types.push(this.flowParseType());\n          if (this.match(types.bracketR)) break;\n          this.expect(types.comma);\n        }\n\n        this.expect(types.bracketR);\n        return this.finishNode(node, \"TupleTypeAnnotation\");\n      };\n\n      _proto.flowParseFunctionTypeParam = function flowParseFunctionTypeParam() {\n        var name = null;\n        var optional = false;\n        var typeAnnotation = null;\n        var node = this.startNode();\n        var lh = this.lookahead();\n\n        if (lh.type === types.colon || lh.type === types.question) {\n          name = this.parseIdentifier();\n\n          if (this.eat(types.question)) {\n            optional = true;\n          }\n\n          typeAnnotation = this.flowParseTypeInitialiser();\n        } else {\n          typeAnnotation = this.flowParseType();\n        }\n\n        node.name = name;\n        node.optional = optional;\n        node.typeAnnotation = typeAnnotation;\n        return this.finishNode(node, \"FunctionTypeParam\");\n      };\n\n      _proto.reinterpretTypeAsFunctionTypeParam = function reinterpretTypeAsFunctionTypeParam(type) {\n        var node = this.startNodeAt(type.start, type.loc.start);\n        node.name = null;\n        node.optional = false;\n        node.typeAnnotation = type;\n        return this.finishNode(node, \"FunctionTypeParam\");\n      };\n\n      _proto.flowParseFunctionTypeParams = function flowParseFunctionTypeParams(params) {\n        if (params === void 0) {\n          params = [];\n        }\n\n        var rest = null;\n\n        while (!this.match(types.parenR) && !this.match(types.ellipsis)) {\n          params.push(this.flowParseFunctionTypeParam());\n\n          if (!this.match(types.parenR)) {\n            this.expect(types.comma);\n          }\n        }\n\n        if (this.eat(types.ellipsis)) {\n          rest = this.flowParseFunctionTypeParam();\n        }\n\n        return {\n          params,\n          rest\n        };\n      };\n\n      _proto.flowIdentToTypeAnnotation = function flowIdentToTypeAnnotation(startPos, startLoc, node, id) {\n        switch (id.name) {\n          case \"any\":\n            return this.finishNode(node, \"AnyTypeAnnotation\");\n\n          case \"void\":\n            return this.finishNode(node, \"VoidTypeAnnotation\");\n\n          case \"bool\":\n          case \"boolean\":\n            return this.finishNode(node, \"BooleanTypeAnnotation\");\n\n          case \"mixed\":\n            return this.finishNode(node, \"MixedTypeAnnotation\");\n\n          case \"empty\":\n            return this.finishNode(node, \"EmptyTypeAnnotation\");\n\n          case \"number\":\n            return this.finishNode(node, \"NumberTypeAnnotation\");\n\n          case \"string\":\n            return this.finishNode(node, \"StringTypeAnnotation\");\n\n          default:\n            return this.flowParseGenericType(startPos, startLoc, id);\n        }\n      }; // The parsing of types roughly parallels the parsing of expressions, and\n      // primary types are kind of like primary expressions...they're the\n      // primitives with which other types are constructed.\n\n\n      _proto.flowParsePrimaryType = function flowParsePrimaryType() {\n        var startPos = this.state.start;\n        var startLoc = this.state.startLoc;\n        var node = this.startNode();\n        var tmp;\n        var type;\n        var isGroupedType = false;\n        var oldNoAnonFunctionType = this.state.noAnonFunctionType;\n\n        switch (this.state.type) {\n          case types.name:\n            return this.flowIdentToTypeAnnotation(startPos, startLoc, node, this.parseIdentifier());\n\n          case types.braceL:\n            return this.flowParseObjectType(false, false, true);\n\n          case types.braceBarL:\n            return this.flowParseObjectType(false, true, true);\n\n          case types.bracketL:\n            return this.flowParseTupleType();\n\n          case types.relational:\n            if (this.state.value === \"<\") {\n              node.typeParameters = this.flowParseTypeParameterDeclaration();\n              this.expect(types.parenL);\n              tmp = this.flowParseFunctionTypeParams();\n              node.params = tmp.params;\n              node.rest = tmp.rest;\n              this.expect(types.parenR);\n              this.expect(types.arrow);\n              node.returnType = this.flowParseType();\n              return this.finishNode(node, \"FunctionTypeAnnotation\");\n            }\n\n            break;\n\n          case types.parenL:\n            this.next(); // Check to see if this is actually a grouped type\n\n            if (!this.match(types.parenR) && !this.match(types.ellipsis)) {\n              if (this.match(types.name)) {\n                var token = this.lookahead().type;\n                isGroupedType = token !== types.question && token !== types.colon;\n              } else {\n                isGroupedType = true;\n              }\n            }\n\n            if (isGroupedType) {\n              this.state.noAnonFunctionType = false;\n              type = this.flowParseType();\n              this.state.noAnonFunctionType = oldNoAnonFunctionType; // A `,` or a `) =>` means this is an anonymous function type\n\n              if (this.state.noAnonFunctionType || !(this.match(types.comma) || this.match(types.parenR) && this.lookahead().type === types.arrow)) {\n                this.expect(types.parenR);\n                return type;\n              } else {\n                // Eat a comma if there is one\n                this.eat(types.comma);\n              }\n            }\n\n            if (type) {\n              tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);\n            } else {\n              tmp = this.flowParseFunctionTypeParams();\n            }\n\n            node.params = tmp.params;\n            node.rest = tmp.rest;\n            this.expect(types.parenR);\n            this.expect(types.arrow);\n            node.returnType = this.flowParseType();\n            node.typeParameters = null;\n            return this.finishNode(node, \"FunctionTypeAnnotation\");\n\n          case types.string:\n            return this.parseLiteral(this.state.value, \"StringLiteralTypeAnnotation\");\n\n          case types._true:\n          case types._false:\n            node.value = this.match(types._true);\n            this.next();\n            return this.finishNode(node, \"BooleanLiteralTypeAnnotation\");\n\n          case types.plusMin:\n            if (this.state.value === \"-\") {\n              this.next();\n\n              if (!this.match(types.num)) {\n                this.unexpected(null, \"Unexpected token, expected number\");\n              }\n\n              return this.parseLiteral(-this.state.value, \"NumberLiteralTypeAnnotation\", node.start, node.loc.start);\n            }\n\n            this.unexpected();\n\n          case types.num:\n            return this.parseLiteral(this.state.value, \"NumberLiteralTypeAnnotation\");\n\n          case types._null:\n            this.next();\n            return this.finishNode(node, \"NullLiteralTypeAnnotation\");\n\n          case types._this:\n            this.next();\n            return this.finishNode(node, \"ThisTypeAnnotation\");\n\n          case types.star:\n            this.next();\n            return this.finishNode(node, \"ExistsTypeAnnotation\");\n\n          default:\n            if (this.state.type.keyword === \"typeof\") {\n              return this.flowParseTypeofType();\n            }\n\n        }\n\n        throw this.unexpected();\n      };\n\n      _proto.flowParsePostfixType = function flowParsePostfixType() {\n        var startPos = this.state.start,\n            startLoc = this.state.startLoc;\n        var type = this.flowParsePrimaryType();\n\n        while (!this.canInsertSemicolon() && this.match(types.bracketL)) {\n          var node = this.startNodeAt(startPos, startLoc);\n          node.elementType = type;\n          this.expect(types.bracketL);\n          this.expect(types.bracketR);\n          type = this.finishNode(node, \"ArrayTypeAnnotation\");\n        }\n\n        return type;\n      };\n\n      _proto.flowParsePrefixType = function flowParsePrefixType() {\n        var node = this.startNode();\n\n        if (this.eat(types.question)) {\n          node.typeAnnotation = this.flowParsePrefixType();\n          return this.finishNode(node, \"NullableTypeAnnotation\");\n        } else {\n          return this.flowParsePostfixType();\n        }\n      };\n\n      _proto.flowParseAnonFunctionWithoutParens = function flowParseAnonFunctionWithoutParens() {\n        var param = this.flowParsePrefixType();\n\n        if (!this.state.noAnonFunctionType && this.eat(types.arrow)) {\n          // TODO: This should be a type error. Passing in a SourceLocation, and it expects a Position.\n          var node = this.startNodeAt(param.start, param.loc.start);\n          node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];\n          node.rest = null;\n          node.returnType = this.flowParseType();\n          node.typeParameters = null;\n          return this.finishNode(node, \"FunctionTypeAnnotation\");\n        }\n\n        return param;\n      };\n\n      _proto.flowParseIntersectionType = function flowParseIntersectionType() {\n        var node = this.startNode();\n        this.eat(types.bitwiseAND);\n        var type = this.flowParseAnonFunctionWithoutParens();\n        node.types = [type];\n\n        while (this.eat(types.bitwiseAND)) {\n          node.types.push(this.flowParseAnonFunctionWithoutParens());\n        }\n\n        return node.types.length === 1 ? type : this.finishNode(node, \"IntersectionTypeAnnotation\");\n      };\n\n      _proto.flowParseUnionType = function flowParseUnionType() {\n        var node = this.startNode();\n        this.eat(types.bitwiseOR);\n        var type = this.flowParseIntersectionType();\n        node.types = [type];\n\n        while (this.eat(types.bitwiseOR)) {\n          node.types.push(this.flowParseIntersectionType());\n        }\n\n        return node.types.length === 1 ? type : this.finishNode(node, \"UnionTypeAnnotation\");\n      };\n\n      _proto.flowParseType = function flowParseType() {\n        var oldInType = this.state.inType;\n        this.state.inType = true;\n        var type = this.flowParseUnionType();\n        this.state.inType = oldInType; // Ensure that a brace after a function generic type annotation is a\n        // statement, except in arrow functions (noAnonFunctionType)\n\n        this.state.exprAllowed = this.state.exprAllowed || this.state.noAnonFunctionType;\n        return type;\n      };\n\n      _proto.flowParseTypeAnnotation = function flowParseTypeAnnotation() {\n        var node = this.startNode();\n        node.typeAnnotation = this.flowParseTypeInitialiser();\n        return this.finishNode(node, \"TypeAnnotation\");\n      };\n\n      _proto.flowParseTypeAnnotatableIdentifier = function flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {\n        var ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();\n\n        if (this.match(types.colon)) {\n          ident.typeAnnotation = this.flowParseTypeAnnotation();\n          this.finishNode(ident, ident.type);\n        }\n\n        return ident;\n      };\n\n      _proto.typeCastToParameter = function typeCastToParameter(node) {\n        node.expression.typeAnnotation = node.typeAnnotation;\n        return this.finishNodeAt(node.expression, node.expression.type, node.typeAnnotation.end, node.typeAnnotation.loc.end);\n      };\n\n      _proto.flowParseVariance = function flowParseVariance() {\n        var variance = null;\n\n        if (this.match(types.plusMin)) {\n          variance = this.startNode();\n\n          if (this.state.value === \"+\") {\n            variance.kind = \"plus\";\n          } else {\n            variance.kind = \"minus\";\n          }\n\n          this.next();\n          this.finishNode(variance, \"Variance\");\n        }\n\n        return variance;\n      }; // ==================================\n      // Overrides\n      // ==================================\n\n\n      _proto.parseFunctionBody = function parseFunctionBody(node, allowExpressionBody) {\n        var _this2 = this;\n\n        if (allowExpressionBody) {\n          return this.forwardNoArrowParamsConversionAt(node, function () {\n            return _superClass.prototype.parseFunctionBody.call(_this2, node, true);\n          });\n        }\n\n        return _superClass.prototype.parseFunctionBody.call(this, node, false);\n      };\n\n      _proto.parseFunctionBodyAndFinish = function parseFunctionBodyAndFinish(node, type, allowExpressionBody) {\n        // For arrow functions, `parseArrow` handles the return type itself.\n        if (!allowExpressionBody && this.match(types.colon)) {\n          var typeNode = this.startNode();\n\n          var _flowParseTypeAndPred2 = this.flowParseTypeAndPredicateInitialiser();\n\n          // $FlowFixMe (destructuring not supported yet)\n          typeNode.typeAnnotation = _flowParseTypeAndPred2[0];\n          // $FlowFixMe (destructuring not supported yet)\n          node.predicate = _flowParseTypeAndPred2[1];\n          node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, \"TypeAnnotation\") : null;\n        }\n\n        _superClass.prototype.parseFunctionBodyAndFinish.call(this, node, type, allowExpressionBody);\n      }; // interfaces\n\n\n      _proto.parseStatement = function parseStatement(declaration, topLevel) {\n        // strict mode handling of `interface` since it's a reserved word\n        if (this.state.strict && this.match(types.name) && this.state.value === \"interface\") {\n          var node = this.startNode();\n          this.next();\n          return this.flowParseInterface(node);\n        } else {\n          return _superClass.prototype.parseStatement.call(this, declaration, topLevel);\n        }\n      }; // declares, interfaces and type aliases\n\n\n      _proto.parseExpressionStatement = function parseExpressionStatement(node, expr) {\n        if (expr.type === \"Identifier\") {\n          if (expr.name === \"declare\") {\n            if (this.match(types._class) || this.match(types.name) || this.match(types._function) || this.match(types._var) || this.match(types._export)) {\n              return this.flowParseDeclare(node);\n            }\n          } else if (this.match(types.name)) {\n            if (expr.name === \"interface\") {\n              return this.flowParseInterface(node);\n            } else if (expr.name === \"type\") {\n              return this.flowParseTypeAlias(node);\n            } else if (expr.name === \"opaque\") {\n              return this.flowParseOpaqueType(node, false);\n            }\n          }\n        }\n\n        return _superClass.prototype.parseExpressionStatement.call(this, node, expr);\n      }; // export type\n\n\n      _proto.shouldParseExportDeclaration = function shouldParseExportDeclaration() {\n        return this.isContextual(\"type\") || this.isContextual(\"interface\") || this.isContextual(\"opaque\") || _superClass.prototype.shouldParseExportDeclaration.call(this);\n      };\n\n      _proto.isExportDefaultSpecifier = function isExportDefaultSpecifier() {\n        if (this.match(types.name) && (this.state.value === \"type\" || this.state.value === \"interface\" || this.state.value == \"opaque\")) {\n          return false;\n        }\n\n        return _superClass.prototype.isExportDefaultSpecifier.call(this);\n      };\n\n      _proto.parseConditional = function parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos) {\n        var _this3 = this;\n\n        if (!this.match(types.question)) return expr; // only do the expensive clone if there is a question mark\n        // and if we come from inside parens\n\n        if (refNeedsArrowPos) {\n          var _state = this.state.clone();\n\n          try {\n            return _superClass.prototype.parseConditional.call(this, expr, noIn, startPos, startLoc);\n          } catch (err) {\n            if (err instanceof SyntaxError) {\n              this.state = _state;\n              refNeedsArrowPos.start = err.pos || this.state.start;\n              return expr;\n            } else {\n              // istanbul ignore next: no such error is expected\n              throw err;\n            }\n          }\n        }\n\n        this.expect(types.question);\n        var state = this.state.clone();\n        var originalNoArrowAt = this.state.noArrowAt;\n        var node = this.startNodeAt(startPos, startLoc);\n\n        var _tryParseConditionalC = this.tryParseConditionalConsequent(),\n            consequent = _tryParseConditionalC.consequent,\n            failed = _tryParseConditionalC.failed;\n\n        var _getArrowLikeExpressi = this.getArrowLikeExpressions(consequent),\n            valid = _getArrowLikeExpressi[0],\n            invalid = _getArrowLikeExpressi[1];\n\n        if (failed || invalid.length > 0) {\n          var noArrowAt = [].concat(originalNoArrowAt);\n\n          if (invalid.length > 0) {\n            this.state = state;\n            this.state.noArrowAt = noArrowAt;\n\n            for (var i = 0; i < invalid.length; i++) {\n              noArrowAt.push(invalid[i].start);\n            }\n\n            var _tryParseConditionalC2 = this.tryParseConditionalConsequent();\n\n            consequent = _tryParseConditionalC2.consequent;\n            failed = _tryParseConditionalC2.failed;\n\n            var _getArrowLikeExpressi2 = this.getArrowLikeExpressions(consequent);\n\n            valid = _getArrowLikeExpressi2[0];\n            invalid = _getArrowLikeExpressi2[1];\n          }\n\n          if (failed && valid.length > 1) {\n            // if there are two or more possible correct ways of parsing, throw an\n            // error.\n            // e.g.   Source: a ? (b): c => (d): e => f\n            //      Result 1: a ? b : (c => ((d): e => f))\n            //      Result 2: a ? ((b): c => d) : (e => f)\n            this.raise(state.start, \"Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.\");\n          }\n\n          if (failed && valid.length === 1) {\n            this.state = state;\n            this.state.noArrowAt = noArrowAt.concat(valid[0].start);\n\n            var _tryParseConditionalC3 = this.tryParseConditionalConsequent();\n\n            consequent = _tryParseConditionalC3.consequent;\n            failed = _tryParseConditionalC3.failed;\n          }\n\n          this.getArrowLikeExpressions(consequent, true);\n        }\n\n        this.state.noArrowAt = originalNoArrowAt;\n        this.expect(types.colon);\n        node.test = expr;\n        node.consequent = consequent;\n        node.alternate = this.forwardNoArrowParamsConversionAt(node, function () {\n          return _this3.parseMaybeAssign(noIn, undefined, undefined, undefined);\n        });\n        return this.finishNode(node, \"ConditionalExpression\");\n      };\n\n      _proto.tryParseConditionalConsequent = function tryParseConditionalConsequent() {\n        this.state.noArrowParamsConversionAt.push(this.state.start);\n        var consequent = this.parseMaybeAssign();\n        var failed = !this.match(types.colon);\n        this.state.noArrowParamsConversionAt.pop();\n        return {\n          consequent,\n          failed\n        };\n      }; // Given an expression, walks throught its arrow functions whose body is\n      // an expression and throught conditional expressions. It returns every\n      // function which has been parsed with a return type but could have been\n      // parenthesized expressions.\n      // These functions are separated into two arrays: one containing the ones\n      // whose parameters can be converted to assignable lists, one containing the\n      // others.\n\n\n      _proto.getArrowLikeExpressions = function getArrowLikeExpressions(node, disallowInvalid) {\n        var _this4 = this;\n\n        var stack = [node];\n        var arrows = [];\n\n        while (stack.length !== 0) {\n          var _node = stack.pop();\n\n          if (_node.type === \"ArrowFunctionExpression\") {\n            if (_node.typeParameters || !_node.returnType) {\n              // This is an arrow expression without ambiguity, so check its parameters\n              this.toAssignableList( // node.params is Expression[] instead of $ReadOnlyArray<Pattern> because it\n              // has not been converted yet.\n              _node.params, true, \"arrow function parameters\"); // Use super's method to force the parameters to be checked\n\n              _superClass.prototype.checkFunctionNameAndParams.call(this, _node, true);\n            } else {\n              arrows.push(_node);\n            }\n\n            stack.push(_node.body);\n          } else if (_node.type === \"ConditionalExpression\") {\n            stack.push(_node.consequent);\n            stack.push(_node.alternate);\n          }\n        }\n\n        if (disallowInvalid) {\n          for (var i = 0; i < arrows.length; i++) {\n            this.toAssignableList(node.params, true, \"arrow function parameters\");\n          }\n\n          return [arrows, []];\n        }\n\n        return partition(arrows, function (node) {\n          try {\n            _this4.toAssignableList(node.params, true, \"arrow function parameters\");\n\n            return true;\n          } catch (err) {\n            return false;\n          }\n        });\n      };\n\n      _proto.forwardNoArrowParamsConversionAt = function forwardNoArrowParamsConversionAt(node, parse) {\n        var result;\n\n        if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n          this.state.noArrowParamsConversionAt.push(this.state.start);\n          result = parse();\n          this.state.noArrowParamsConversionAt.pop();\n        } else {\n          result = parse();\n        }\n\n        return result;\n      };\n\n      _proto.parseParenItem = function parseParenItem(node, startPos, startLoc) {\n        node = _superClass.prototype.parseParenItem.call(this, node, startPos, startLoc);\n\n        if (this.eat(types.question)) {\n          node.optional = true;\n        }\n\n        if (this.match(types.colon)) {\n          var typeCastNode = this.startNodeAt(startPos, startLoc);\n          typeCastNode.expression = node;\n          typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();\n          return this.finishNode(typeCastNode, \"TypeCastExpression\");\n        }\n\n        return node;\n      };\n\n      _proto.assertModuleNodeAllowed = function assertModuleNodeAllowed(node) {\n        if (node.type === \"ImportDeclaration\" && (node.importKind === \"type\" || node.importKind === \"typeof\") || node.type === \"ExportNamedDeclaration\" && node.exportKind === \"type\" || node.type === \"ExportAllDeclaration\" && node.exportKind === \"type\") {\n          // Allow Flowtype imports and exports in all conditions because\n          // Flow itself does not care about 'sourceType'.\n          return;\n        }\n\n        _superClass.prototype.assertModuleNodeAllowed.call(this, node);\n      };\n\n      _proto.parseExport = function parseExport(node) {\n        node = _superClass.prototype.parseExport.call(this, node);\n\n        if (node.type === \"ExportNamedDeclaration\" || node.type === \"ExportAllDeclaration\") {\n          node.exportKind = node.exportKind || \"value\";\n        }\n\n        return node;\n      };\n\n      _proto.parseExportDeclaration = function parseExportDeclaration(node) {\n        if (this.isContextual(\"type\")) {\n          node.exportKind = \"type\";\n          var declarationNode = this.startNode();\n          this.next();\n\n          if (this.match(types.braceL)) {\n            // export type { foo, bar };\n            node.specifiers = this.parseExportSpecifiers();\n            this.parseExportFrom(node);\n            return null;\n          } else {\n            // export type Foo = Bar;\n            return this.flowParseTypeAlias(declarationNode);\n          }\n        } else if (this.isContextual(\"opaque\")) {\n          node.exportKind = \"type\";\n\n          var _declarationNode = this.startNode();\n\n          this.next(); // export opaque type Foo = Bar;\n\n          return this.flowParseOpaqueType(_declarationNode, false);\n        } else if (this.isContextual(\"interface\")) {\n          node.exportKind = \"type\";\n\n          var _declarationNode2 = this.startNode();\n\n          this.next();\n          return this.flowParseInterface(_declarationNode2);\n        } else {\n          return _superClass.prototype.parseExportDeclaration.call(this, node);\n        }\n      };\n\n      _proto.shouldParseExportStar = function shouldParseExportStar() {\n        return _superClass.prototype.shouldParseExportStar.call(this) || this.isContextual(\"type\") && this.lookahead().type === types.star;\n      };\n\n      _proto.parseExportStar = function parseExportStar(node, allowNamed) {\n        if (this.eatContextual(\"type\")) {\n          node.exportKind = \"type\";\n          allowNamed = false;\n        }\n\n        return _superClass.prototype.parseExportStar.call(this, node, allowNamed);\n      };\n\n      _proto.parseClassId = function parseClassId(node, isStatement, optionalId) {\n        _superClass.prototype.parseClassId.call(this, node, isStatement, optionalId);\n\n        if (this.isRelational(\"<\")) {\n          node.typeParameters = this.flowParseTypeParameterDeclaration();\n        }\n      }; // don't consider `void` to be a keyword as then it'll use the void token type\n      // and set startExpr\n\n\n      _proto.isKeyword = function isKeyword(name) {\n        if (this.state.inType && name === \"void\") {\n          return false;\n        } else {\n          return _superClass.prototype.isKeyword.call(this, name);\n        }\n      }; // ensure that inside flow types, we bypass the jsx parser plugin\n\n\n      _proto.readToken = function readToken(code) {\n        if (this.state.inType && (code === 62 || code === 60)) {\n          return this.finishOp(types.relational, 1);\n        } else {\n          return _superClass.prototype.readToken.call(this, code);\n        }\n      };\n\n      _proto.toAssignable = function toAssignable(node, isBinding, contextDescription) {\n        if (node.type === \"TypeCastExpression\") {\n          return _superClass.prototype.toAssignable.call(this, this.typeCastToParameter(node), isBinding, contextDescription);\n        } else {\n          return _superClass.prototype.toAssignable.call(this, node, isBinding, contextDescription);\n        }\n      }; // turn type casts that we found in function parameter head into type annotated params\n\n\n      _proto.toAssignableList = function toAssignableList(exprList, isBinding, contextDescription) {\n        for (var i = 0; i < exprList.length; i++) {\n          var expr = exprList[i];\n\n          if (expr && expr.type === \"TypeCastExpression\") {\n            exprList[i] = this.typeCastToParameter(expr);\n          }\n        }\n\n        return _superClass.prototype.toAssignableList.call(this, exprList, isBinding, contextDescription);\n      }; // this is a list of nodes, from something like a call expression, we need to filter the\n      // type casts that we've found that are illegal in this context\n\n\n      _proto.toReferencedList = function toReferencedList(exprList) {\n        for (var i = 0; i < exprList.length; i++) {\n          var expr = exprList[i];\n\n          if (expr && expr._exprListItem && expr.type === \"TypeCastExpression\") {\n            this.raise(expr.start, \"Unexpected type cast\");\n          }\n        }\n\n        return exprList;\n      }; // parse an item inside a expression list eg. `(NODE, NODE)` where NODE represents\n      // the position where this function is called\n\n\n      _proto.parseExprListItem = function parseExprListItem(allowEmpty, refShorthandDefaultPos, refNeedsArrowPos) {\n        var container = this.startNode();\n\n        var node = _superClass.prototype.parseExprListItem.call(this, allowEmpty, refShorthandDefaultPos, refNeedsArrowPos);\n\n        if (this.match(types.colon)) {\n          container._exprListItem = true;\n          container.expression = node;\n          container.typeAnnotation = this.flowParseTypeAnnotation();\n          return this.finishNode(container, \"TypeCastExpression\");\n        } else {\n          return node;\n        }\n      };\n\n      _proto.checkLVal = function checkLVal(expr, isBinding, checkClashes, contextDescription) {\n        if (expr.type !== \"TypeCastExpression\") {\n          return _superClass.prototype.checkLVal.call(this, expr, isBinding, checkClashes, contextDescription);\n        }\n      }; // parse class property type annotations\n\n\n      _proto.parseClassProperty = function parseClassProperty(node) {\n        if (this.match(types.colon)) {\n          node.typeAnnotation = this.flowParseTypeAnnotation();\n        }\n\n        return _superClass.prototype.parseClassProperty.call(this, node);\n      }; // determine whether or not we're currently in the position where a class method would appear\n\n\n      _proto.isClassMethod = function isClassMethod() {\n        return this.isRelational(\"<\") || _superClass.prototype.isClassMethod.call(this);\n      }; // determine whether or not we're currently in the position where a class property would appear\n\n\n      _proto.isClassProperty = function isClassProperty() {\n        return this.match(types.colon) || _superClass.prototype.isClassProperty.call(this);\n      };\n\n      _proto.isNonstaticConstructor = function isNonstaticConstructor(method) {\n        return !this.match(types.colon) && _superClass.prototype.isNonstaticConstructor.call(this, method);\n      }; // parse type parameters for class methods\n\n\n      _proto.pushClassMethod = function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor) {\n        if (method.variance) {\n          this.unexpected(method.variance.start);\n        }\n\n        delete method.variance;\n\n        if (this.isRelational(\"<\")) {\n          method.typeParameters = this.flowParseTypeParameterDeclaration();\n        }\n\n        _superClass.prototype.pushClassMethod.call(this, classBody, method, isGenerator, isAsync, isConstructor);\n      };\n\n      _proto.pushClassPrivateMethod = function pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n        if (method.variance) {\n          this.unexpected(method.variance.start);\n        }\n\n        delete method.variance;\n\n        if (this.isRelational(\"<\")) {\n          method.typeParameters = this.flowParseTypeParameterDeclaration();\n        }\n\n        _superClass.prototype.pushClassPrivateMethod.call(this, classBody, method, isGenerator, isAsync);\n      }; // parse a the super class type parameters and implements\n\n\n      _proto.parseClassSuper = function parseClassSuper(node) {\n        _superClass.prototype.parseClassSuper.call(this, node);\n\n        if (node.superClass && this.isRelational(\"<\")) {\n          node.superTypeParameters = this.flowParseTypeParameterInstantiation();\n        }\n\n        if (this.isContextual(\"implements\")) {\n          this.next();\n          var implemented = node.implements = [];\n\n          do {\n            var _node2 = this.startNode();\n\n            _node2.id = this.parseIdentifier();\n\n            if (this.isRelational(\"<\")) {\n              _node2.typeParameters = this.flowParseTypeParameterInstantiation();\n            } else {\n              _node2.typeParameters = null;\n            }\n\n            implemented.push(this.finishNode(_node2, \"ClassImplements\"));\n          } while (this.eat(types.comma));\n        }\n      };\n\n      _proto.parsePropertyName = function parsePropertyName(node) {\n        var variance = this.flowParseVariance();\n\n        var key = _superClass.prototype.parsePropertyName.call(this, node); // $FlowIgnore (\"variance\" not defined on TsNamedTypeElementBase)\n\n\n        node.variance = variance;\n        return key;\n      }; // parse type parameters for object method shorthand\n\n\n      _proto.parseObjPropValue = function parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refShorthandDefaultPos) {\n        if (prop.variance) {\n          this.unexpected(prop.variance.start);\n        }\n\n        delete prop.variance;\n        var typeParameters; // method shorthand\n\n        if (this.isRelational(\"<\")) {\n          typeParameters = this.flowParseTypeParameterDeclaration();\n          if (!this.match(types.parenL)) this.unexpected();\n        }\n\n        _superClass.prototype.parseObjPropValue.call(this, prop, startPos, startLoc, isGenerator, isAsync, isPattern, refShorthandDefaultPos); // add typeParameters if we found them\n\n\n        if (typeParameters) {\n          // $FlowFixMe (trying to set '.typeParameters' on an expression)\n          (prop.value || prop).typeParameters = typeParameters;\n        }\n      };\n\n      _proto.parseAssignableListItemTypes = function parseAssignableListItemTypes(param) {\n        if (this.eat(types.question)) {\n          if (param.type !== \"Identifier\") {\n            throw this.raise(param.start, \"A binding pattern parameter cannot be optional in an implementation signature.\");\n          }\n\n          param.optional = true;\n        }\n\n        if (this.match(types.colon)) {\n          param.typeAnnotation = this.flowParseTypeAnnotation();\n        }\n\n        this.finishNode(param, param.type);\n        return param;\n      };\n\n      _proto.parseMaybeDefault = function parseMaybeDefault(startPos, startLoc, left) {\n        var node = _superClass.prototype.parseMaybeDefault.call(this, startPos, startLoc, left);\n\n        if (node.type === \"AssignmentPattern\" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {\n          this.raise(node.typeAnnotation.start, \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`\");\n        }\n\n        return node;\n      };\n\n      _proto.shouldParseDefaultImport = function shouldParseDefaultImport(node) {\n        if (!hasTypeImportKind(node)) {\n          return _superClass.prototype.shouldParseDefaultImport.call(this, node);\n        }\n\n        return isMaybeDefaultImport(this.state);\n      };\n\n      _proto.parseImportSpecifierLocal = function parseImportSpecifierLocal(node, specifier, type, contextDescription) {\n        specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true) : this.parseIdentifier();\n        this.checkLVal(specifier.local, true, undefined, contextDescription);\n        node.specifiers.push(this.finishNode(specifier, type));\n      }; // parse typeof and type imports\n\n\n      _proto.parseImportSpecifiers = function parseImportSpecifiers(node) {\n        node.importKind = \"value\";\n        var kind = null;\n\n        if (this.match(types._typeof)) {\n          kind = \"typeof\";\n        } else if (this.isContextual(\"type\")) {\n          kind = \"type\";\n        }\n\n        if (kind) {\n          var lh = this.lookahead();\n\n          if (isMaybeDefaultImport(lh) || lh.type === types.braceL || lh.type === types.star) {\n            this.next();\n            node.importKind = kind;\n          }\n        }\n\n        _superClass.prototype.parseImportSpecifiers.call(this, node);\n      }; // parse import-type/typeof shorthand\n\n\n      _proto.parseImportSpecifier = function parseImportSpecifier(node) {\n        var specifier = this.startNode();\n        var firstIdentLoc = this.state.start;\n        var firstIdent = this.parseIdentifier(true);\n        var specifierTypeKind = null;\n\n        if (firstIdent.name === \"type\") {\n          specifierTypeKind = \"type\";\n        } else if (firstIdent.name === \"typeof\") {\n          specifierTypeKind = \"typeof\";\n        }\n\n        var isBinding = false;\n\n        if (this.isContextual(\"as\") && !this.isLookaheadContextual(\"as\")) {\n          var as_ident = this.parseIdentifier(true);\n\n          if (specifierTypeKind !== null && !this.match(types.name) && !this.state.type.keyword) {\n            // `import {type as ,` or `import {type as }`\n            specifier.imported = as_ident;\n            specifier.importKind = specifierTypeKind;\n            specifier.local = as_ident.__clone();\n          } else {\n            // `import {type as foo`\n            specifier.imported = firstIdent;\n            specifier.importKind = null;\n            specifier.local = this.parseIdentifier();\n          }\n        } else if (specifierTypeKind !== null && (this.match(types.name) || this.state.type.keyword)) {\n          // `import {type foo`\n          specifier.imported = this.parseIdentifier(true);\n          specifier.importKind = specifierTypeKind;\n\n          if (this.eatContextual(\"as\")) {\n            specifier.local = this.parseIdentifier();\n          } else {\n            isBinding = true;\n            specifier.local = specifier.imported.__clone();\n          }\n        } else {\n          isBinding = true;\n          specifier.imported = firstIdent;\n          specifier.importKind = null;\n          specifier.local = specifier.imported.__clone();\n        }\n\n        var nodeIsTypeImport = hasTypeImportKind(node);\n        var specifierIsTypeImport = hasTypeImportKind(specifier);\n\n        if (nodeIsTypeImport && specifierIsTypeImport) {\n          this.raise(firstIdentLoc, \"The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements\");\n        }\n\n        if (nodeIsTypeImport || specifierIsTypeImport) {\n          this.checkReservedType(specifier.local.name, specifier.local.start);\n        }\n\n        if (isBinding && !nodeIsTypeImport && !specifierIsTypeImport) {\n          this.checkReservedWord(specifier.local.name, specifier.start, true, true);\n        }\n\n        this.checkLVal(specifier.local, true, undefined, \"import specifier\");\n        node.specifiers.push(this.finishNode(specifier, \"ImportSpecifier\"));\n      }; // parse function type parameters - function foo<T>() {}\n\n\n      _proto.parseFunctionParams = function parseFunctionParams(node) {\n        // $FlowFixMe\n        var kind = node.kind;\n\n        if (kind !== \"get\" && kind !== \"set\" && this.isRelational(\"<\")) {\n          node.typeParameters = this.flowParseTypeParameterDeclaration();\n        }\n\n        _superClass.prototype.parseFunctionParams.call(this, node);\n      }; // parse flow type annotations on variable declarator heads - let foo: string = bar\n\n\n      _proto.parseVarHead = function parseVarHead(decl) {\n        _superClass.prototype.parseVarHead.call(this, decl);\n\n        if (this.match(types.colon)) {\n          decl.id.typeAnnotation = this.flowParseTypeAnnotation();\n          this.finishNode(decl.id, decl.id.type);\n        }\n      }; // parse the return type of an async arrow function - let foo = (async (): number => {});\n\n\n      _proto.parseAsyncArrowFromCallExpression = function parseAsyncArrowFromCallExpression(node, call) {\n        if (this.match(types.colon)) {\n          var oldNoAnonFunctionType = this.state.noAnonFunctionType;\n          this.state.noAnonFunctionType = true;\n          node.returnType = this.flowParseTypeAnnotation();\n          this.state.noAnonFunctionType = oldNoAnonFunctionType;\n        }\n\n        return _superClass.prototype.parseAsyncArrowFromCallExpression.call(this, node, call);\n      }; // todo description\n\n\n      _proto.shouldParseAsyncArrow = function shouldParseAsyncArrow() {\n        return this.match(types.colon) || _superClass.prototype.shouldParseAsyncArrow.call(this);\n      }; // We need to support type parameter declarations for arrow functions. This\n      // is tricky. There are three situations we need to handle\n      //\n      // 1. This is either JSX or an arrow function. We'll try JSX first. If that\n      //    fails, we'll try an arrow function. If that fails, we'll throw the JSX\n      //    error.\n      // 2. This is an arrow function. We'll parse the type parameter declaration,\n      //    parse the rest, make sure the rest is an arrow function, and go from\n      //    there\n      // 3. This is neither. Just call the super method\n\n\n      _proto.parseMaybeAssign = function parseMaybeAssign(noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos) {\n        var _this5 = this;\n\n        var jsxError = null;\n\n        if (types.jsxTagStart && this.match(types.jsxTagStart)) {\n          var state = this.state.clone();\n\n          try {\n            return _superClass.prototype.parseMaybeAssign.call(this, noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos);\n          } catch (err) {\n            if (err instanceof SyntaxError) {\n              this.state = state; // Remove `tc.j_expr` and `tc.j_oTag` from context added\n              // by parsing `jsxTagStart` to stop the JSX plugin from\n              // messing with the tokens\n\n              this.state.context.length -= 2;\n              jsxError = err;\n            } else {\n              // istanbul ignore next: no such error is expected\n              throw err;\n            }\n          }\n        }\n\n        if (jsxError != null || this.isRelational(\"<\")) {\n          var arrowExpression;\n          var typeParameters;\n\n          try {\n            typeParameters = this.flowParseTypeParameterDeclaration();\n            arrowExpression = this.forwardNoArrowParamsConversionAt(typeParameters, function () {\n              return _superClass.prototype.parseMaybeAssign.call(_this5, noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos);\n            });\n            arrowExpression.typeParameters = typeParameters;\n            this.resetStartLocationFromNode(arrowExpression, typeParameters);\n          } catch (err) {\n            throw jsxError || err;\n          }\n\n          if (arrowExpression.type === \"ArrowFunctionExpression\") {\n            return arrowExpression;\n          } else if (jsxError != null) {\n            throw jsxError;\n          } else {\n            this.raise(typeParameters.start, \"Expected an arrow function after this type parameter declaration\");\n          }\n        }\n\n        return _superClass.prototype.parseMaybeAssign.call(this, noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos);\n      }; // handle return types for arrow functions\n\n\n      _proto.parseArrow = function parseArrow(node) {\n        if (this.match(types.colon)) {\n          var state = this.state.clone();\n\n          try {\n            var oldNoAnonFunctionType = this.state.noAnonFunctionType;\n            this.state.noAnonFunctionType = true;\n            var typeNode = this.startNode();\n\n            var _flowParseTypeAndPred3 = this.flowParseTypeAndPredicateInitialiser();\n\n            // $FlowFixMe (destructuring not supported yet)\n            typeNode.typeAnnotation = _flowParseTypeAndPred3[0];\n            // $FlowFixMe (destructuring not supported yet)\n            node.predicate = _flowParseTypeAndPred3[1];\n            this.state.noAnonFunctionType = oldNoAnonFunctionType;\n            if (this.canInsertSemicolon()) this.unexpected();\n            if (!this.match(types.arrow)) this.unexpected(); // assign after it is clear it is an arrow\n\n            node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, \"TypeAnnotation\") : null;\n          } catch (err) {\n            if (err instanceof SyntaxError) {\n              this.state = state;\n            } else {\n              // istanbul ignore next: no such error is expected\n              throw err;\n            }\n          }\n        }\n\n        return _superClass.prototype.parseArrow.call(this, node);\n      };\n\n      _proto.shouldParseArrow = function shouldParseArrow() {\n        return this.match(types.colon) || _superClass.prototype.shouldParseArrow.call(this);\n      };\n\n      _proto.setArrowFunctionParameters = function setArrowFunctionParameters(node, params) {\n        if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n          node.params = params;\n        } else {\n          _superClass.prototype.setArrowFunctionParameters.call(this, node, params);\n        }\n      };\n\n      _proto.checkFunctionNameAndParams = function checkFunctionNameAndParams(node, isArrowFunction) {\n        if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n          return;\n        }\n\n        return _superClass.prototype.checkFunctionNameAndParams.call(this, node, isArrowFunction);\n      };\n\n      _proto.parseParenAndDistinguishExpression = function parseParenAndDistinguishExpression(canBeArrow) {\n        return _superClass.prototype.parseParenAndDistinguishExpression.call(this, canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);\n      };\n\n      _proto.parseSubscripts = function parseSubscripts(base, startPos, startLoc, noCalls) {\n        if (base.type === \"Identifier\" && base.name === \"async\" && this.state.noArrowAt.indexOf(startPos) !== -1) {\n          this.next();\n          var node = this.startNodeAt(startPos, startLoc);\n          node.callee = base;\n          node.arguments = this.parseCallExpressionArguments(types.parenR, false);\n          base = this.finishNode(node, \"CallExpression\");\n        }\n\n        return _superClass.prototype.parseSubscripts.call(this, base, startPos, startLoc, noCalls);\n      };\n\n      return _class;\n    }(superClass)\n  );\n});\n\nvar entities = {\n  quot: \"\\u0022\",\n  amp: \"&\",\n  apos: \"\\u0027\",\n  lt: \"<\",\n  gt: \">\",\n  nbsp: \"\\u00A0\",\n  iexcl: \"\\u00A1\",\n  cent: \"\\u00A2\",\n  pound: \"\\u00A3\",\n  curren: \"\\u00A4\",\n  yen: \"\\u00A5\",\n  brvbar: \"\\u00A6\",\n  sect: \"\\u00A7\",\n  uml: \"\\u00A8\",\n  copy: \"\\u00A9\",\n  ordf: \"\\u00AA\",\n  laquo: \"\\u00AB\",\n  not: \"\\u00AC\",\n  shy: \"\\u00AD\",\n  reg: \"\\u00AE\",\n  macr: \"\\u00AF\",\n  deg: \"\\u00B0\",\n  plusmn: \"\\u00B1\",\n  sup2: \"\\u00B2\",\n  sup3: \"\\u00B3\",\n  acute: \"\\u00B4\",\n  micro: \"\\u00B5\",\n  para: \"\\u00B6\",\n  middot: \"\\u00B7\",\n  cedil: \"\\u00B8\",\n  sup1: \"\\u00B9\",\n  ordm: \"\\u00BA\",\n  raquo: \"\\u00BB\",\n  frac14: \"\\u00BC\",\n  frac12: \"\\u00BD\",\n  frac34: \"\\u00BE\",\n  iquest: \"\\u00BF\",\n  Agrave: \"\\u00C0\",\n  Aacute: \"\\u00C1\",\n  Acirc: \"\\u00C2\",\n  Atilde: \"\\u00C3\",\n  Auml: \"\\u00C4\",\n  Aring: \"\\u00C5\",\n  AElig: \"\\u00C6\",\n  Ccedil: \"\\u00C7\",\n  Egrave: \"\\u00C8\",\n  Eacute: \"\\u00C9\",\n  Ecirc: \"\\u00CA\",\n  Euml: \"\\u00CB\",\n  Igrave: \"\\u00CC\",\n  Iacute: \"\\u00CD\",\n  Icirc: \"\\u00CE\",\n  Iuml: \"\\u00CF\",\n  ETH: \"\\u00D0\",\n  Ntilde: \"\\u00D1\",\n  Ograve: \"\\u00D2\",\n  Oacute: \"\\u00D3\",\n  Ocirc: \"\\u00D4\",\n  Otilde: \"\\u00D5\",\n  Ouml: \"\\u00D6\",\n  times: \"\\u00D7\",\n  Oslash: \"\\u00D8\",\n  Ugrave: \"\\u00D9\",\n  Uacute: \"\\u00DA\",\n  Ucirc: \"\\u00DB\",\n  Uuml: \"\\u00DC\",\n  Yacute: \"\\u00DD\",\n  THORN: \"\\u00DE\",\n  szlig: \"\\u00DF\",\n  agrave: \"\\u00E0\",\n  aacute: \"\\u00E1\",\n  acirc: \"\\u00E2\",\n  atilde: \"\\u00E3\",\n  auml: \"\\u00E4\",\n  aring: \"\\u00E5\",\n  aelig: \"\\u00E6\",\n  ccedil: \"\\u00E7\",\n  egrave: \"\\u00E8\",\n  eacute: \"\\u00E9\",\n  ecirc: \"\\u00EA\",\n  euml: \"\\u00EB\",\n  igrave: \"\\u00EC\",\n  iacute: \"\\u00ED\",\n  icirc: \"\\u00EE\",\n  iuml: \"\\u00EF\",\n  eth: \"\\u00F0\",\n  ntilde: \"\\u00F1\",\n  ograve: \"\\u00F2\",\n  oacute: \"\\u00F3\",\n  ocirc: \"\\u00F4\",\n  otilde: \"\\u00F5\",\n  ouml: \"\\u00F6\",\n  divide: \"\\u00F7\",\n  oslash: \"\\u00F8\",\n  ugrave: \"\\u00F9\",\n  uacute: \"\\u00FA\",\n  ucirc: \"\\u00FB\",\n  uuml: \"\\u00FC\",\n  yacute: \"\\u00FD\",\n  thorn: \"\\u00FE\",\n  yuml: \"\\u00FF\",\n  OElig: \"\\u0152\",\n  oelig: \"\\u0153\",\n  Scaron: \"\\u0160\",\n  scaron: \"\\u0161\",\n  Yuml: \"\\u0178\",\n  fnof: \"\\u0192\",\n  circ: \"\\u02C6\",\n  tilde: \"\\u02DC\",\n  Alpha: \"\\u0391\",\n  Beta: \"\\u0392\",\n  Gamma: \"\\u0393\",\n  Delta: \"\\u0394\",\n  Epsilon: \"\\u0395\",\n  Zeta: \"\\u0396\",\n  Eta: \"\\u0397\",\n  Theta: \"\\u0398\",\n  Iota: \"\\u0399\",\n  Kappa: \"\\u039A\",\n  Lambda: \"\\u039B\",\n  Mu: \"\\u039C\",\n  Nu: \"\\u039D\",\n  Xi: \"\\u039E\",\n  Omicron: \"\\u039F\",\n  Pi: \"\\u03A0\",\n  Rho: \"\\u03A1\",\n  Sigma: \"\\u03A3\",\n  Tau: \"\\u03A4\",\n  Upsilon: \"\\u03A5\",\n  Phi: \"\\u03A6\",\n  Chi: \"\\u03A7\",\n  Psi: \"\\u03A8\",\n  Omega: \"\\u03A9\",\n  alpha: \"\\u03B1\",\n  beta: \"\\u03B2\",\n  gamma: \"\\u03B3\",\n  delta: \"\\u03B4\",\n  epsilon: \"\\u03B5\",\n  zeta: \"\\u03B6\",\n  eta: \"\\u03B7\",\n  theta: \"\\u03B8\",\n  iota: \"\\u03B9\",\n  kappa: \"\\u03BA\",\n  lambda: \"\\u03BB\",\n  mu: \"\\u03BC\",\n  nu: \"\\u03BD\",\n  xi: \"\\u03BE\",\n  omicron: \"\\u03BF\",\n  pi: \"\\u03C0\",\n  rho: \"\\u03C1\",\n  sigmaf: \"\\u03C2\",\n  sigma: \"\\u03C3\",\n  tau: \"\\u03C4\",\n  upsilon: \"\\u03C5\",\n  phi: \"\\u03C6\",\n  chi: \"\\u03C7\",\n  psi: \"\\u03C8\",\n  omega: \"\\u03C9\",\n  thetasym: \"\\u03D1\",\n  upsih: \"\\u03D2\",\n  piv: \"\\u03D6\",\n  ensp: \"\\u2002\",\n  emsp: \"\\u2003\",\n  thinsp: \"\\u2009\",\n  zwnj: \"\\u200C\",\n  zwj: \"\\u200D\",\n  lrm: \"\\u200E\",\n  rlm: \"\\u200F\",\n  ndash: \"\\u2013\",\n  mdash: \"\\u2014\",\n  lsquo: \"\\u2018\",\n  rsquo: \"\\u2019\",\n  sbquo: \"\\u201A\",\n  ldquo: \"\\u201C\",\n  rdquo: \"\\u201D\",\n  bdquo: \"\\u201E\",\n  dagger: \"\\u2020\",\n  Dagger: \"\\u2021\",\n  bull: \"\\u2022\",\n  hellip: \"\\u2026\",\n  permil: \"\\u2030\",\n  prime: \"\\u2032\",\n  Prime: \"\\u2033\",\n  lsaquo: \"\\u2039\",\n  rsaquo: \"\\u203A\",\n  oline: \"\\u203E\",\n  frasl: \"\\u2044\",\n  euro: \"\\u20AC\",\n  image: \"\\u2111\",\n  weierp: \"\\u2118\",\n  real: \"\\u211C\",\n  trade: \"\\u2122\",\n  alefsym: \"\\u2135\",\n  larr: \"\\u2190\",\n  uarr: \"\\u2191\",\n  rarr: \"\\u2192\",\n  darr: \"\\u2193\",\n  harr: \"\\u2194\",\n  crarr: \"\\u21B5\",\n  lArr: \"\\u21D0\",\n  uArr: \"\\u21D1\",\n  rArr: \"\\u21D2\",\n  dArr: \"\\u21D3\",\n  hArr: \"\\u21D4\",\n  forall: \"\\u2200\",\n  part: \"\\u2202\",\n  exist: \"\\u2203\",\n  empty: \"\\u2205\",\n  nabla: \"\\u2207\",\n  isin: \"\\u2208\",\n  notin: \"\\u2209\",\n  ni: \"\\u220B\",\n  prod: \"\\u220F\",\n  sum: \"\\u2211\",\n  minus: \"\\u2212\",\n  lowast: \"\\u2217\",\n  radic: \"\\u221A\",\n  prop: \"\\u221D\",\n  infin: \"\\u221E\",\n  ang: \"\\u2220\",\n  and: \"\\u2227\",\n  or: \"\\u2228\",\n  cap: \"\\u2229\",\n  cup: \"\\u222A\",\n  int: \"\\u222B\",\n  there4: \"\\u2234\",\n  sim: \"\\u223C\",\n  cong: \"\\u2245\",\n  asymp: \"\\u2248\",\n  ne: \"\\u2260\",\n  equiv: \"\\u2261\",\n  le: \"\\u2264\",\n  ge: \"\\u2265\",\n  sub: \"\\u2282\",\n  sup: \"\\u2283\",\n  nsub: \"\\u2284\",\n  sube: \"\\u2286\",\n  supe: \"\\u2287\",\n  oplus: \"\\u2295\",\n  otimes: \"\\u2297\",\n  perp: \"\\u22A5\",\n  sdot: \"\\u22C5\",\n  lceil: \"\\u2308\",\n  rceil: \"\\u2309\",\n  lfloor: \"\\u230A\",\n  rfloor: \"\\u230B\",\n  lang: \"\\u2329\",\n  rang: \"\\u232A\",\n  loz: \"\\u25CA\",\n  spades: \"\\u2660\",\n  clubs: \"\\u2663\",\n  hearts: \"\\u2665\",\n  diams: \"\\u2666\"\n};\n\nvar HEX_NUMBER = /^[\\da-fA-F]+$/;\nvar DECIMAL_NUMBER = /^\\d+$/;\ntypes$1.j_oTag = new TokContext(\"<tag\", false);\ntypes$1.j_cTag = new TokContext(\"</tag\", false);\ntypes$1.j_expr = new TokContext(\"<tag>...</tag>\", true, true);\ntypes.jsxName = new TokenType(\"jsxName\");\ntypes.jsxText = new TokenType(\"jsxText\", {\n  beforeExpr: true\n});\ntypes.jsxTagStart = new TokenType(\"jsxTagStart\", {\n  startsExpr: true\n});\ntypes.jsxTagEnd = new TokenType(\"jsxTagEnd\");\n\ntypes.jsxTagStart.updateContext = function () {\n  this.state.context.push(types$1.j_expr); // treat as beginning of JSX expression\n\n  this.state.context.push(types$1.j_oTag); // start opening tag context\n\n  this.state.exprAllowed = false;\n};\n\ntypes.jsxTagEnd.updateContext = function (prevType) {\n  var out = this.state.context.pop();\n\n  if (out === types$1.j_oTag && prevType === types.slash || out === types$1.j_cTag) {\n    this.state.context.pop();\n    this.state.exprAllowed = this.curContext() === types$1.j_expr;\n  } else {\n    this.state.exprAllowed = true;\n  }\n};\n\nfunction isFragment(object) {\n  return object ? object.type === \"JSXOpeningFragment\" || object.type === \"JSXClosingFragment\" : false;\n} // Transforms JSX element name to string.\n\n\nfunction getQualifiedJSXName(object) {\n  if (object.type === \"JSXIdentifier\") {\n    return object.name;\n  }\n\n  if (object.type === \"JSXNamespacedName\") {\n    return object.namespace.name + \":\" + object.name.name;\n  }\n\n  if (object.type === \"JSXMemberExpression\") {\n    return getQualifiedJSXName(object.object) + \".\" + getQualifiedJSXName(object.property);\n  } // istanbul ignore next\n\n\n  throw new Error(\"Node had unexpected type: \" + object.type);\n}\n\nvar jsxPlugin = (function (superClass) {\n  return (\n    /*#__PURE__*/\n    function (_superClass) {\n      _inheritsLoose(_class, _superClass);\n\n      function _class() {\n        return _superClass.apply(this, arguments) || this;\n      }\n\n      var _proto = _class.prototype;\n\n      // Reads inline JSX contents token.\n      _proto.jsxReadToken = function jsxReadToken() {\n        var out = \"\";\n        var chunkStart = this.state.pos;\n\n        for (;;) {\n          if (this.state.pos >= this.input.length) {\n            this.raise(this.state.start, \"Unterminated JSX contents\");\n          }\n\n          var ch = this.input.charCodeAt(this.state.pos);\n\n          switch (ch) {\n            case 60: // \"<\"\n\n            case 123:\n              // \"{\"\n              if (this.state.pos === this.state.start) {\n                if (ch === 60 && this.state.exprAllowed) {\n                  ++this.state.pos;\n                  return this.finishToken(types.jsxTagStart);\n                }\n\n                return this.getTokenFromCode(ch);\n              }\n\n              out += this.input.slice(chunkStart, this.state.pos);\n              return this.finishToken(types.jsxText, out);\n\n            case 38:\n              // \"&\"\n              out += this.input.slice(chunkStart, this.state.pos);\n              out += this.jsxReadEntity();\n              chunkStart = this.state.pos;\n              break;\n\n            default:\n              if (isNewLine(ch)) {\n                out += this.input.slice(chunkStart, this.state.pos);\n                out += this.jsxReadNewLine(true);\n                chunkStart = this.state.pos;\n              } else {\n                ++this.state.pos;\n              }\n\n          }\n        }\n      };\n\n      _proto.jsxReadNewLine = function jsxReadNewLine(normalizeCRLF) {\n        var ch = this.input.charCodeAt(this.state.pos);\n        var out;\n        ++this.state.pos;\n\n        if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {\n          ++this.state.pos;\n          out = normalizeCRLF ? \"\\n\" : \"\\r\\n\";\n        } else {\n          out = String.fromCharCode(ch);\n        }\n\n        ++this.state.curLine;\n        this.state.lineStart = this.state.pos;\n        return out;\n      };\n\n      _proto.jsxReadString = function jsxReadString(quote) {\n        var out = \"\";\n        var chunkStart = ++this.state.pos;\n\n        for (;;) {\n          if (this.state.pos >= this.input.length) {\n            this.raise(this.state.start, \"Unterminated string constant\");\n          }\n\n          var ch = this.input.charCodeAt(this.state.pos);\n          if (ch === quote) break;\n\n          if (ch === 38) {\n            // \"&\"\n            out += this.input.slice(chunkStart, this.state.pos);\n            out += this.jsxReadEntity();\n            chunkStart = this.state.pos;\n          } else if (isNewLine(ch)) {\n            out += this.input.slice(chunkStart, this.state.pos);\n            out += this.jsxReadNewLine(false);\n            chunkStart = this.state.pos;\n          } else {\n            ++this.state.pos;\n          }\n        }\n\n        out += this.input.slice(chunkStart, this.state.pos++);\n        return this.finishToken(types.string, out);\n      };\n\n      _proto.jsxReadEntity = function jsxReadEntity() {\n        var str = \"\";\n        var count = 0;\n        var entity;\n        var ch = this.input[this.state.pos];\n        var startPos = ++this.state.pos;\n\n        while (this.state.pos < this.input.length && count++ < 10) {\n          ch = this.input[this.state.pos++];\n\n          if (ch === \";\") {\n            if (str[0] === \"#\") {\n              if (str[1] === \"x\") {\n                str = str.substr(2);\n\n                if (HEX_NUMBER.test(str)) {\n                  entity = String.fromCodePoint(parseInt(str, 16));\n                }\n              } else {\n                str = str.substr(1);\n\n                if (DECIMAL_NUMBER.test(str)) {\n                  entity = String.fromCodePoint(parseInt(str, 10));\n                }\n              }\n            } else {\n              entity = entities[str];\n            }\n\n            break;\n          }\n\n          str += ch;\n        }\n\n        if (!entity) {\n          this.state.pos = startPos;\n          return \"&\";\n        }\n\n        return entity;\n      }; // Read a JSX identifier (valid tag or attribute name).\n      //\n      // Optimized version since JSX identifiers can\"t contain\n      // escape characters and so can be read as single slice.\n      // Also assumes that first character was already checked\n      // by isIdentifierStart in readToken.\n\n\n      _proto.jsxReadWord = function jsxReadWord() {\n        var ch;\n        var start = this.state.pos;\n\n        do {\n          ch = this.input.charCodeAt(++this.state.pos);\n        } while (isIdentifierChar(ch) || ch === 45); // \"-\"\n\n\n        return this.finishToken(types.jsxName, this.input.slice(start, this.state.pos));\n      }; // Parse next token as JSX identifier\n\n\n      _proto.jsxParseIdentifier = function jsxParseIdentifier() {\n        var node = this.startNode();\n\n        if (this.match(types.jsxName)) {\n          node.name = this.state.value;\n        } else if (this.state.type.keyword) {\n          node.name = this.state.type.keyword;\n        } else {\n          this.unexpected();\n        }\n\n        this.next();\n        return this.finishNode(node, \"JSXIdentifier\");\n      }; // Parse namespaced identifier.\n\n\n      _proto.jsxParseNamespacedName = function jsxParseNamespacedName() {\n        var startPos = this.state.start;\n        var startLoc = this.state.startLoc;\n        var name = this.jsxParseIdentifier();\n        if (!this.eat(types.colon)) return name;\n        var node = this.startNodeAt(startPos, startLoc);\n        node.namespace = name;\n        node.name = this.jsxParseIdentifier();\n        return this.finishNode(node, \"JSXNamespacedName\");\n      }; // Parses element name in any form - namespaced, member\n      // or single identifier.\n\n\n      _proto.jsxParseElementName = function jsxParseElementName() {\n        var startPos = this.state.start;\n        var startLoc = this.state.startLoc;\n        var node = this.jsxParseNamespacedName();\n\n        while (this.eat(types.dot)) {\n          var newNode = this.startNodeAt(startPos, startLoc);\n          newNode.object = node;\n          newNode.property = this.jsxParseIdentifier();\n          node = this.finishNode(newNode, \"JSXMemberExpression\");\n        }\n\n        return node;\n      }; // Parses any type of JSX attribute value.\n\n\n      _proto.jsxParseAttributeValue = function jsxParseAttributeValue() {\n        var node;\n\n        switch (this.state.type) {\n          case types.braceL:\n            node = this.jsxParseExpressionContainer();\n\n            if (node.expression.type === \"JSXEmptyExpression\") {\n              throw this.raise(node.start, \"JSX attributes must only be assigned a non-empty expression\");\n            } else {\n              return node;\n            }\n\n          case types.jsxTagStart:\n          case types.string:\n            return this.parseExprAtom();\n\n          default:\n            throw this.raise(this.state.start, \"JSX value should be either an expression or a quoted JSX text\");\n        }\n      }; // JSXEmptyExpression is unique type since it doesn't actually parse anything,\n      // and so it should start at the end of last read token (left brace) and finish\n      // at the beginning of the next one (right brace).\n\n\n      _proto.jsxParseEmptyExpression = function jsxParseEmptyExpression() {\n        var node = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);\n        return this.finishNodeAt(node, \"JSXEmptyExpression\", this.state.start, this.state.startLoc);\n      }; // Parse JSX spread child\n\n\n      _proto.jsxParseSpreadChild = function jsxParseSpreadChild() {\n        var node = this.startNode();\n        this.expect(types.braceL);\n        this.expect(types.ellipsis);\n        node.expression = this.parseExpression();\n        this.expect(types.braceR);\n        return this.finishNode(node, \"JSXSpreadChild\");\n      }; // Parses JSX expression enclosed into curly brackets.\n\n\n      _proto.jsxParseExpressionContainer = function jsxParseExpressionContainer() {\n        var node = this.startNode();\n        this.next();\n\n        if (this.match(types.braceR)) {\n          node.expression = this.jsxParseEmptyExpression();\n        } else {\n          node.expression = this.parseExpression();\n        }\n\n        this.expect(types.braceR);\n        return this.finishNode(node, \"JSXExpressionContainer\");\n      }; // Parses following JSX attribute name-value pair.\n\n\n      _proto.jsxParseAttribute = function jsxParseAttribute() {\n        var node = this.startNode();\n\n        if (this.eat(types.braceL)) {\n          this.expect(types.ellipsis);\n          node.argument = this.parseMaybeAssign();\n          this.expect(types.braceR);\n          return this.finishNode(node, \"JSXSpreadAttribute\");\n        }\n\n        node.name = this.jsxParseNamespacedName();\n        node.value = this.eat(types.eq) ? this.jsxParseAttributeValue() : null;\n        return this.finishNode(node, \"JSXAttribute\");\n      }; // Parses JSX opening tag starting after \"<\".\n\n\n      _proto.jsxParseOpeningElementAt = function jsxParseOpeningElementAt(startPos, startLoc) {\n        var node = this.startNodeAt(startPos, startLoc);\n\n        if (this.match(types.jsxTagEnd)) {\n          this.expect(types.jsxTagEnd);\n          return this.finishNode(node, \"JSXOpeningFragment\");\n        }\n\n        node.attributes = [];\n        node.name = this.jsxParseElementName();\n\n        while (!this.match(types.slash) && !this.match(types.jsxTagEnd)) {\n          node.attributes.push(this.jsxParseAttribute());\n        }\n\n        node.selfClosing = this.eat(types.slash);\n        this.expect(types.jsxTagEnd);\n        return this.finishNode(node, \"JSXOpeningElement\");\n      }; // Parses JSX closing tag starting after \"</\".\n\n\n      _proto.jsxParseClosingElementAt = function jsxParseClosingElementAt(startPos, startLoc) {\n        var node = this.startNodeAt(startPos, startLoc);\n\n        if (this.match(types.jsxTagEnd)) {\n          this.expect(types.jsxTagEnd);\n          return this.finishNode(node, \"JSXClosingFragment\");\n        }\n\n        node.name = this.jsxParseElementName();\n        this.expect(types.jsxTagEnd);\n        return this.finishNode(node, \"JSXClosingElement\");\n      }; // Parses entire JSX element, including it\"s opening tag\n      // (starting after \"<\"), attributes, contents and closing tag.\n\n\n      _proto.jsxParseElementAt = function jsxParseElementAt(startPos, startLoc) {\n        var node = this.startNodeAt(startPos, startLoc);\n        var children = [];\n        var openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);\n        var closingElement = null;\n\n        if (!openingElement.selfClosing) {\n          contents: for (;;) {\n            switch (this.state.type) {\n              case types.jsxTagStart:\n                startPos = this.state.start;\n                startLoc = this.state.startLoc;\n                this.next();\n\n                if (this.eat(types.slash)) {\n                  closingElement = this.jsxParseClosingElementAt(startPos, startLoc);\n                  break contents;\n                }\n\n                children.push(this.jsxParseElementAt(startPos, startLoc));\n                break;\n\n              case types.jsxText:\n                children.push(this.parseExprAtom());\n                break;\n\n              case types.braceL:\n                if (this.lookahead().type === types.ellipsis) {\n                  children.push(this.jsxParseSpreadChild());\n                } else {\n                  children.push(this.jsxParseExpressionContainer());\n                }\n\n                break;\n              // istanbul ignore next - should never happen\n\n              default:\n                throw this.unexpected();\n            }\n          }\n\n          if (isFragment(openingElement) && !isFragment(closingElement)) {\n            this.raise( // $FlowIgnore\n            closingElement.start, \"Expected corresponding JSX closing tag for <>\");\n          } else if (!isFragment(openingElement) && isFragment(closingElement)) {\n            this.raise( // $FlowIgnore\n            closingElement.start, \"Expected corresponding JSX closing tag for <\" + getQualifiedJSXName(openingElement.name) + \">\");\n          } else if (!isFragment(openingElement) && !isFragment(closingElement)) {\n            if ( // $FlowIgnore\n            getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {\n              this.raise( // $FlowIgnore\n              closingElement.start, \"Expected corresponding JSX closing tag for <\" + getQualifiedJSXName(openingElement.name) + \">\");\n            }\n          }\n        }\n\n        if (isFragment(openingElement)) {\n          node.openingFragment = openingElement;\n          node.closingFragment = closingElement;\n        } else {\n          node.openingElement = openingElement;\n          node.closingElement = closingElement;\n        }\n\n        node.children = children;\n\n        if (this.match(types.relational) && this.state.value === \"<\") {\n          this.raise(this.state.start, \"Adjacent JSX elements must be wrapped in an enclosing tag\");\n        }\n\n        return isFragment(openingElement) ? this.finishNode(node, \"JSXFragment\") : this.finishNode(node, \"JSXElement\");\n      }; // Parses entire JSX element from current position.\n\n\n      _proto.jsxParseElement = function jsxParseElement() {\n        var startPos = this.state.start;\n        var startLoc = this.state.startLoc;\n        this.next();\n        return this.jsxParseElementAt(startPos, startLoc);\n      }; // ==================================\n      // Overrides\n      // ==================================\n\n\n      _proto.parseExprAtom = function parseExprAtom(refShortHandDefaultPos) {\n        if (this.match(types.jsxText)) {\n          return this.parseLiteral(this.state.value, \"JSXText\");\n        } else if (this.match(types.jsxTagStart)) {\n          return this.jsxParseElement();\n        } else {\n          return _superClass.prototype.parseExprAtom.call(this, refShortHandDefaultPos);\n        }\n      };\n\n      _proto.readToken = function readToken(code) {\n        if (this.state.inPropertyName) return _superClass.prototype.readToken.call(this, code);\n        var context = this.curContext();\n\n        if (context === types$1.j_expr) {\n          return this.jsxReadToken();\n        }\n\n        if (context === types$1.j_oTag || context === types$1.j_cTag) {\n          if (isIdentifierStart(code)) {\n            return this.jsxReadWord();\n          }\n\n          if (code === 62) {\n            ++this.state.pos;\n            return this.finishToken(types.jsxTagEnd);\n          }\n\n          if ((code === 34 || code === 39) && context === types$1.j_oTag) {\n            return this.jsxReadString(code);\n          }\n        }\n\n        if (code === 60 && this.state.exprAllowed) {\n          ++this.state.pos;\n          return this.finishToken(types.jsxTagStart);\n        }\n\n        return _superClass.prototype.readToken.call(this, code);\n      };\n\n      _proto.updateContext = function updateContext(prevType) {\n        if (this.match(types.braceL)) {\n          var curContext = this.curContext();\n\n          if (curContext === types$1.j_oTag) {\n            this.state.context.push(types$1.braceExpression);\n          } else if (curContext === types$1.j_expr) {\n            this.state.context.push(types$1.templateQuasi);\n          } else {\n            _superClass.prototype.updateContext.call(this, prevType);\n          }\n\n          this.state.exprAllowed = true;\n        } else if (this.match(types.slash) && prevType === types.jsxTagStart) {\n          this.state.context.length -= 2; // do not consider JSX expr -> JSX open tag -> ... anymore\n\n          this.state.context.push(types$1.j_cTag); // reconsider as closing tag context\n\n          this.state.exprAllowed = false;\n        } else {\n          return _superClass.prototype.updateContext.call(this, prevType);\n        }\n      };\n\n      return _class;\n    }(superClass)\n  );\n});\n\nfunction nonNull(x) {\n  if (x == null) {\n    // $FlowIgnore\n    throw new Error(`Unexpected ${x} value.`);\n  }\n\n  return x;\n}\n\nfunction assert(x) {\n  if (!x) {\n    throw new Error(\"Assert fail\");\n  }\n}\n\n// Doesn't handle \"void\" or \"null\" because those are keywords, not identifiers.\nfunction keywordTypeFromName(value) {\n  switch (value) {\n    case \"any\":\n      return \"TSAnyKeyword\";\n\n    case \"boolean\":\n      return \"TSBooleanKeyword\";\n\n    case \"never\":\n      return \"TSNeverKeyword\";\n\n    case \"number\":\n      return \"TSNumberKeyword\";\n\n    case \"object\":\n      return \"TSObjectKeyword\";\n\n    case \"string\":\n      return \"TSStringKeyword\";\n\n    case \"symbol\":\n      return \"TSSymbolKeyword\";\n\n    case \"undefined\":\n      return \"TSUndefinedKeyword\";\n\n    default:\n      return undefined;\n  }\n}\n\nvar typescriptPlugin = (function (superClass) {\n  return (\n    /*#__PURE__*/\n    function (_superClass) {\n      _inheritsLoose(_class, _superClass);\n\n      function _class() {\n        return _superClass.apply(this, arguments) || this;\n      }\n\n      var _proto = _class.prototype;\n\n      _proto.tsIsIdentifier = function tsIsIdentifier() {\n        // TODO: actually a bit more complex in TypeScript, but shouldn't matter.\n        // See https://github.com/Microsoft/TypeScript/issues/15008\n        return this.match(types.name);\n      };\n\n      _proto.tsNextTokenCanFollowModifier = function tsNextTokenCanFollowModifier() {\n        // Note: TypeScript's implementation is much more complicated because\n        // more things are considered modifiers there.\n        // This implementation only handles modifiers not handled by babylon itself. And \"static\".\n        // TODO: Would be nice to avoid lookahead. Want a hasLineBreakUpNext() method...\n        this.next();\n        return !this.hasPrecedingLineBreak() && !this.match(types.parenL) && !this.match(types.colon) && !this.match(types.eq) && !this.match(types.question);\n      };\n      /** Parses a modifier matching one the given modifier names. */\n\n\n      _proto.tsParseModifier = function tsParseModifier(allowedModifiers) {\n        if (!this.match(types.name)) {\n          return undefined;\n        }\n\n        var modifier = this.state.value;\n\n        if (allowedModifiers.indexOf(modifier) !== -1 && this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {\n          return modifier;\n        }\n\n        return undefined;\n      };\n\n      _proto.tsIsListTerminator = function tsIsListTerminator(kind) {\n        switch (kind) {\n          case \"EnumMembers\":\n          case \"TypeMembers\":\n            return this.match(types.braceR);\n\n          case \"HeritageClauseElement\":\n            return this.match(types.braceL);\n\n          case \"TupleElementTypes\":\n            return this.match(types.bracketR);\n\n          case \"TypeParametersOrArguments\":\n            return this.isRelational(\">\");\n        }\n\n        throw new Error(\"Unreachable\");\n      };\n\n      _proto.tsParseList = function tsParseList(kind, parseElement) {\n        var result = [];\n\n        while (!this.tsIsListTerminator(kind)) {\n          // Skipping \"parseListElement\" from the TS source since that's just for error handling.\n          result.push(parseElement());\n        }\n\n        return result;\n      };\n\n      _proto.tsParseDelimitedList = function tsParseDelimitedList(kind, parseElement) {\n        return nonNull(this.tsParseDelimitedListWorker(kind, parseElement,\n        /* expectSuccess */\n        true));\n      };\n\n      _proto.tsTryParseDelimitedList = function tsTryParseDelimitedList(kind, parseElement) {\n        return this.tsParseDelimitedListWorker(kind, parseElement,\n        /* expectSuccess */\n        false);\n      };\n      /**\n      * If !expectSuccess, returns undefined instead of failing to parse.\n      * If expectSuccess, parseElement should always return a defined value.\n      */\n\n\n      _proto.tsParseDelimitedListWorker = function tsParseDelimitedListWorker(kind, parseElement, expectSuccess) {\n        var result = [];\n\n        while (true) {\n          if (this.tsIsListTerminator(kind)) {\n            break;\n          }\n\n          var element = parseElement();\n\n          if (element == null) {\n            return undefined;\n          }\n\n          result.push(element);\n\n          if (this.eat(types.comma)) {\n            continue;\n          }\n\n          if (this.tsIsListTerminator(kind)) {\n            break;\n          }\n\n          if (expectSuccess) {\n            // This will fail with an error about a missing comma\n            this.expect(types.comma);\n          }\n\n          return undefined;\n        }\n\n        return result;\n      };\n\n      _proto.tsParseBracketedList = function tsParseBracketedList(kind, parseElement, bracket, skipFirstToken) {\n        if (!skipFirstToken) {\n          if (bracket) {\n            this.expect(types.bracketL);\n          } else {\n            this.expectRelational(\"<\");\n          }\n        }\n\n        var result = this.tsParseDelimitedList(kind, parseElement);\n\n        if (bracket) {\n          this.expect(types.bracketR);\n        } else {\n          this.expectRelational(\">\");\n        }\n\n        return result;\n      };\n\n      _proto.tsParseEntityName = function tsParseEntityName(allowReservedWords) {\n        var entity = this.parseIdentifier();\n\n        while (this.eat(types.dot)) {\n          var node = this.startNodeAtNode(entity);\n          node.left = entity;\n          node.right = this.parseIdentifier(allowReservedWords);\n          entity = this.finishNode(node, \"TSQualifiedName\");\n        }\n\n        return entity;\n      };\n\n      _proto.tsParseTypeReference = function tsParseTypeReference() {\n        var node = this.startNode();\n        node.typeName = this.tsParseEntityName(\n        /* allowReservedWords */\n        false);\n\n        if (!this.hasPrecedingLineBreak() && this.isRelational(\"<\")) {\n          node.typeParameters = this.tsParseTypeArguments();\n        }\n\n        return this.finishNode(node, \"TSTypeReference\");\n      };\n\n      _proto.tsParseThisTypePredicate = function tsParseThisTypePredicate(lhs) {\n        this.next();\n        var node = this.startNode();\n        node.parameterName = lhs;\n        node.typeAnnotation = this.tsParseTypeAnnotation(\n        /* eatColon */\n        false);\n        return this.finishNode(node, \"TSTypePredicate\");\n      };\n\n      _proto.tsParseThisTypeNode = function tsParseThisTypeNode() {\n        var node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"TSThisType\");\n      };\n\n      _proto.tsParseTypeQuery = function tsParseTypeQuery() {\n        var node = this.startNode();\n        this.expect(types._typeof);\n        node.exprName = this.tsParseEntityName(\n        /* allowReservedWords */\n        true);\n        return this.finishNode(node, \"TSTypeQuery\");\n      };\n\n      _proto.tsParseTypeParameter = function tsParseTypeParameter() {\n        var node = this.startNode();\n        node.name = this.parseIdentifierName(node.start);\n\n        if (this.eat(types._extends)) {\n          node.constraint = this.tsParseType();\n        }\n\n        if (this.eat(types.eq)) {\n          node.default = this.tsParseType();\n        }\n\n        return this.finishNode(node, \"TSTypeParameter\");\n      };\n\n      _proto.tsTryParseTypeParameters = function tsTryParseTypeParameters() {\n        if (this.isRelational(\"<\")) {\n          return this.tsParseTypeParameters();\n        }\n      };\n\n      _proto.tsParseTypeParameters = function tsParseTypeParameters() {\n        var node = this.startNode();\n\n        if (this.isRelational(\"<\") || this.match(types.jsxTagStart)) {\n          this.next();\n        } else {\n          this.unexpected();\n        }\n\n        node.params = this.tsParseBracketedList(\"TypeParametersOrArguments\", this.tsParseTypeParameter.bind(this),\n        /* bracket */\n        false,\n        /* skipFirstToken */\n        true);\n        return this.finishNode(node, \"TSTypeParameterDeclaration\");\n      }; // Note: In TypeScript implementation we must provide `yieldContext` and `awaitContext`,\n      // but here it's always false, because this is only used for types.\n\n\n      _proto.tsFillSignature = function tsFillSignature(returnToken, signature) {\n        // Arrow fns *must* have return token (`=>`). Normal functions can omit it.\n        var returnTokenRequired = returnToken === types.arrow;\n        signature.typeParameters = this.tsTryParseTypeParameters();\n        this.expect(types.parenL);\n        signature.parameters = this.tsParseBindingListForSignature();\n\n        if (returnTokenRequired) {\n          signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n        } else if (this.match(returnToken)) {\n          signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n        }\n      };\n\n      _proto.tsParseBindingListForSignature = function tsParseBindingListForSignature() {\n        var _this = this;\n\n        return this.parseBindingList(types.parenR).map(function (pattern) {\n          if (pattern.type !== \"Identifier\" && pattern.type !== \"RestElement\") {\n            throw _this.unexpected(pattern.start, \"Name in a signature must be an Identifier.\");\n          }\n\n          return pattern;\n        });\n      };\n\n      _proto.tsParseTypeMemberSemicolon = function tsParseTypeMemberSemicolon() {\n        if (!this.eat(types.comma)) {\n          this.semicolon();\n        }\n      };\n\n      _proto.tsParseSignatureMember = function tsParseSignatureMember(kind) {\n        var node = this.startNode();\n\n        if (kind === \"TSConstructSignatureDeclaration\") {\n          this.expect(types._new);\n        }\n\n        this.tsFillSignature(types.colon, node);\n        this.tsParseTypeMemberSemicolon();\n        return this.finishNode(node, kind);\n      };\n\n      _proto.tsIsUnambiguouslyIndexSignature = function tsIsUnambiguouslyIndexSignature() {\n        this.next(); // Skip '{'\n\n        return this.eat(types.name) && this.match(types.colon);\n      };\n\n      _proto.tsTryParseIndexSignature = function tsTryParseIndexSignature(node) {\n        if (!(this.match(types.bracketL) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {\n          return undefined;\n        }\n\n        this.expect(types.bracketL);\n        var id = this.parseIdentifier();\n        this.expect(types.colon);\n        id.typeAnnotation = this.tsParseTypeAnnotation(\n        /* eatColon */\n        false);\n        this.expect(types.bracketR);\n        node.parameters = [id];\n        var type = this.tsTryParseTypeAnnotation();\n        if (type) node.typeAnnotation = type;\n        this.tsParseTypeMemberSemicolon();\n        return this.finishNode(node, \"TSIndexSignature\");\n      };\n\n      _proto.tsParsePropertyOrMethodSignature = function tsParsePropertyOrMethodSignature(node, readonly) {\n        this.parsePropertyName(node);\n        if (this.eat(types.question)) node.optional = true;\n        var nodeAny = node;\n\n        if (!readonly && (this.match(types.parenL) || this.isRelational(\"<\"))) {\n          var method = nodeAny;\n          this.tsFillSignature(types.colon, method);\n          this.tsParseTypeMemberSemicolon();\n          return this.finishNode(method, \"TSMethodSignature\");\n        } else {\n          var property = nodeAny;\n          if (readonly) property.readonly = true;\n          var type = this.tsTryParseTypeAnnotation();\n          if (type) property.typeAnnotation = type;\n          this.tsParseTypeMemberSemicolon();\n          return this.finishNode(property, \"TSPropertySignature\");\n        }\n      };\n\n      _proto.tsParseTypeMember = function tsParseTypeMember() {\n        if (this.match(types.parenL) || this.isRelational(\"<\")) {\n          return this.tsParseSignatureMember(\"TSCallSignatureDeclaration\");\n        }\n\n        if (this.match(types._new) && this.tsLookAhead(this.tsIsStartOfConstructSignature.bind(this))) {\n          return this.tsParseSignatureMember(\"TSConstructSignatureDeclaration\");\n        } // Instead of fullStart, we create a node here.\n\n\n        var node = this.startNode();\n        var readonly = !!this.tsParseModifier([\"readonly\"]);\n        var idx = this.tsTryParseIndexSignature(node);\n\n        if (idx) {\n          if (readonly) node.readonly = true;\n          return idx;\n        }\n\n        return this.tsParsePropertyOrMethodSignature(node, readonly);\n      };\n\n      _proto.tsIsStartOfConstructSignature = function tsIsStartOfConstructSignature() {\n        this.next();\n        return this.match(types.parenL) || this.isRelational(\"<\");\n      };\n\n      _proto.tsParseTypeLiteral = function tsParseTypeLiteral() {\n        var node = this.startNode();\n        node.members = this.tsParseObjectTypeMembers();\n        return this.finishNode(node, \"TSTypeLiteral\");\n      };\n\n      _proto.tsParseObjectTypeMembers = function tsParseObjectTypeMembers() {\n        this.expect(types.braceL);\n        var members = this.tsParseList(\"TypeMembers\", this.tsParseTypeMember.bind(this));\n        this.expect(types.braceR);\n        return members;\n      };\n\n      _proto.tsIsStartOfMappedType = function tsIsStartOfMappedType() {\n        this.next();\n\n        if (this.isContextual(\"readonly\")) {\n          this.next();\n        }\n\n        if (!this.match(types.bracketL)) {\n          return false;\n        }\n\n        this.next();\n\n        if (!this.tsIsIdentifier()) {\n          return false;\n        }\n\n        this.next();\n        return this.match(types._in);\n      };\n\n      _proto.tsParseMappedTypeParameter = function tsParseMappedTypeParameter() {\n        var node = this.startNode();\n        node.name = this.parseIdentifierName(node.start);\n        this.expect(types._in);\n        node.constraint = this.tsParseType();\n        return this.finishNode(node, \"TSTypeParameter\");\n      };\n\n      _proto.tsParseMappedType = function tsParseMappedType() {\n        var node = this.startNode();\n        this.expect(types.braceL);\n\n        if (this.eatContextual(\"readonly\")) {\n          node.readonly = true;\n        }\n\n        this.expect(types.bracketL);\n        node.typeParameter = this.tsParseMappedTypeParameter();\n        this.expect(types.bracketR);\n\n        if (this.eat(types.question)) {\n          node.optional = true;\n        }\n\n        node.typeAnnotation = this.tsTryParseType();\n        this.semicolon();\n        this.expect(types.braceR);\n        return this.finishNode(node, \"TSMappedType\");\n      };\n\n      _proto.tsParseTupleType = function tsParseTupleType() {\n        var node = this.startNode();\n        node.elementTypes = this.tsParseBracketedList(\"TupleElementTypes\", this.tsParseType.bind(this),\n        /* bracket */\n        true,\n        /* skipFirstToken */\n        false);\n        return this.finishNode(node, \"TSTupleType\");\n      };\n\n      _proto.tsParseParenthesizedType = function tsParseParenthesizedType() {\n        var node = this.startNode();\n        this.expect(types.parenL);\n        node.typeAnnotation = this.tsParseType();\n        this.expect(types.parenR);\n        return this.finishNode(node, \"TSParenthesizedType\");\n      };\n\n      _proto.tsParseFunctionOrConstructorType = function tsParseFunctionOrConstructorType(type) {\n        var node = this.startNode();\n\n        if (type === \"TSConstructorType\") {\n          this.expect(types._new);\n        }\n\n        this.tsFillSignature(types.arrow, node);\n        return this.finishNode(node, type);\n      };\n\n      _proto.tsParseLiteralTypeNode = function tsParseLiteralTypeNode() {\n        var _this2 = this;\n\n        var node = this.startNode();\n\n        node.literal = function () {\n          switch (_this2.state.type) {\n            case types.num:\n              return _this2.parseLiteral(_this2.state.value, \"NumericLiteral\");\n\n            case types.string:\n              return _this2.parseLiteral(_this2.state.value, \"StringLiteral\");\n\n            case types._true:\n            case types._false:\n              return _this2.parseBooleanLiteral();\n\n            default:\n              throw _this2.unexpected();\n          }\n        }();\n\n        return this.finishNode(node, \"TSLiteralType\");\n      };\n\n      _proto.tsParseNonArrayType = function tsParseNonArrayType() {\n        switch (this.state.type) {\n          case types.name:\n          case types._void:\n          case types._null:\n            {\n              var type = this.match(types._void) ? \"TSVoidKeyword\" : this.match(types._null) ? \"TSNullKeyword\" : keywordTypeFromName(this.state.value);\n\n              if (type !== undefined && this.lookahead().type !== types.dot) {\n                var node = this.startNode();\n                this.next();\n                return this.finishNode(node, type);\n              }\n\n              return this.tsParseTypeReference();\n            }\n\n          case types.string:\n          case types.num:\n          case types._true:\n          case types._false:\n            return this.tsParseLiteralTypeNode();\n\n          case types.plusMin:\n            if (this.state.value === \"-\") {\n              var _node = this.startNode();\n\n              this.next();\n\n              if (!this.match(types.num)) {\n                throw this.unexpected();\n              }\n\n              _node.literal = this.parseLiteral(-this.state.value, \"NumericLiteral\", _node.start, _node.loc.start);\n              return this.finishNode(_node, \"TSLiteralType\");\n            }\n\n            break;\n\n          case types._this:\n            {\n              var thisKeyword = this.tsParseThisTypeNode();\n\n              if (this.isContextual(\"is\") && !this.hasPrecedingLineBreak()) {\n                return this.tsParseThisTypePredicate(thisKeyword);\n              } else {\n                return thisKeyword;\n              }\n            }\n\n          case types._typeof:\n            return this.tsParseTypeQuery();\n\n          case types.braceL:\n            return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();\n\n          case types.bracketL:\n            return this.tsParseTupleType();\n\n          case types.parenL:\n            return this.tsParseParenthesizedType();\n        }\n\n        throw this.unexpected();\n      };\n\n      _proto.tsParseArrayTypeOrHigher = function tsParseArrayTypeOrHigher() {\n        var type = this.tsParseNonArrayType();\n\n        while (!this.hasPrecedingLineBreak() && this.eat(types.bracketL)) {\n          if (this.match(types.bracketR)) {\n            var node = this.startNodeAtNode(type);\n            node.elementType = type;\n            this.expect(types.bracketR);\n            type = this.finishNode(node, \"TSArrayType\");\n          } else {\n            var _node2 = this.startNodeAtNode(type);\n\n            _node2.objectType = type;\n            _node2.indexType = this.tsParseType();\n            this.expect(types.bracketR);\n            type = this.finishNode(_node2, \"TSIndexedAccessType\");\n          }\n        }\n\n        return type;\n      };\n\n      _proto.tsParseTypeOperator = function tsParseTypeOperator(operator) {\n        var node = this.startNode();\n        this.expectContextual(operator);\n        node.operator = operator;\n        node.typeAnnotation = this.tsParseTypeOperatorOrHigher();\n        return this.finishNode(node, \"TSTypeOperator\");\n      };\n\n      _proto.tsParseTypeOperatorOrHigher = function tsParseTypeOperatorOrHigher() {\n        if (this.isContextual(\"keyof\")) {\n          return this.tsParseTypeOperator(\"keyof\");\n        }\n\n        return this.tsParseArrayTypeOrHigher();\n      };\n\n      _proto.tsParseUnionOrIntersectionType = function tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {\n        this.eat(operator);\n        var type = parseConstituentType();\n\n        if (this.match(operator)) {\n          var types$$1 = [type];\n\n          while (this.eat(operator)) {\n            types$$1.push(parseConstituentType());\n          }\n\n          var node = this.startNodeAtNode(type);\n          node.types = types$$1;\n          type = this.finishNode(node, kind);\n        }\n\n        return type;\n      };\n\n      _proto.tsParseIntersectionTypeOrHigher = function tsParseIntersectionTypeOrHigher() {\n        return this.tsParseUnionOrIntersectionType(\"TSIntersectionType\", this.tsParseTypeOperatorOrHigher.bind(this), types.bitwiseAND);\n      };\n\n      _proto.tsParseUnionTypeOrHigher = function tsParseUnionTypeOrHigher() {\n        return this.tsParseUnionOrIntersectionType(\"TSUnionType\", this.tsParseIntersectionTypeOrHigher.bind(this), types.bitwiseOR);\n      };\n\n      _proto.tsIsStartOfFunctionType = function tsIsStartOfFunctionType() {\n        if (this.isRelational(\"<\")) {\n          return true;\n        }\n\n        return this.match(types.parenL) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));\n      };\n\n      _proto.tsSkipParameterStart = function tsSkipParameterStart() {\n        if (this.match(types.name) || this.match(types._this)) {\n          this.next();\n          return true;\n        }\n\n        return false;\n      };\n\n      _proto.tsIsUnambiguouslyStartOfFunctionType = function tsIsUnambiguouslyStartOfFunctionType() {\n        this.next();\n\n        if (this.match(types.parenR) || this.match(types.ellipsis)) {\n          // ( )\n          // ( ...\n          return true;\n        }\n\n        if (this.tsSkipParameterStart()) {\n          if (this.match(types.colon) || this.match(types.comma) || this.match(types.question) || this.match(types.eq)) {\n            // ( xxx :\n            // ( xxx ,\n            // ( xxx ?\n            // ( xxx =\n            return true;\n          }\n\n          if (this.match(types.parenR)) {\n            this.next();\n\n            if (this.match(types.arrow)) {\n              // ( xxx ) =>\n              return true;\n            }\n          }\n        }\n\n        return false;\n      };\n\n      _proto.tsParseTypeOrTypePredicateAnnotation = function tsParseTypeOrTypePredicateAnnotation(returnToken) {\n        var t = this.startNode();\n        this.expect(returnToken);\n        var typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));\n\n        if (!typePredicateVariable) {\n          return this.tsParseTypeAnnotation(\n          /* eatColon */\n          false, t);\n        }\n\n        var type = this.tsParseTypeAnnotation(\n        /* eatColon */\n        false);\n        var node = this.startNodeAtNode(typePredicateVariable);\n        node.parameterName = typePredicateVariable;\n        node.typeAnnotation = type;\n        t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n        return this.finishNode(t, \"TSTypeAnnotation\");\n      };\n\n      _proto.tsTryParseTypeOrTypePredicateAnnotation = function tsTryParseTypeOrTypePredicateAnnotation() {\n        return this.match(types.colon) ? this.tsParseTypeOrTypePredicateAnnotation(types.colon) : undefined;\n      };\n\n      _proto.tsTryParseTypeAnnotation = function tsTryParseTypeAnnotation() {\n        return this.match(types.colon) ? this.tsParseTypeAnnotation() : undefined;\n      };\n\n      _proto.tsTryParseType = function tsTryParseType() {\n        return this.eat(types.colon) ? this.tsParseType() : undefined;\n      };\n\n      _proto.tsParseTypePredicatePrefix = function tsParseTypePredicatePrefix() {\n        var id = this.parseIdentifier();\n\n        if (this.isContextual(\"is\") && !this.hasPrecedingLineBreak()) {\n          this.next();\n          return id;\n        }\n      };\n\n      _proto.tsParseTypeAnnotation = function tsParseTypeAnnotation(eatColon, t) {\n        if (eatColon === void 0) {\n          eatColon = true;\n        }\n\n        if (t === void 0) {\n          t = this.startNode();\n        }\n\n        if (eatColon) this.expect(types.colon);\n        t.typeAnnotation = this.tsParseType();\n        return this.finishNode(t, \"TSTypeAnnotation\");\n      };\n\n      _proto.tsParseType = function tsParseType() {\n        // Need to set `state.inType` so that we don't parse JSX in a type context.\n        var oldInType = this.state.inType;\n        this.state.inType = true;\n\n        try {\n          if (this.tsIsStartOfFunctionType()) {\n            return this.tsParseFunctionOrConstructorType(\"TSFunctionType\");\n          }\n\n          if (this.match(types._new)) {\n            // As in `new () => Date`\n            return this.tsParseFunctionOrConstructorType(\"TSConstructorType\");\n          }\n\n          return this.tsParseUnionTypeOrHigher();\n        } finally {\n          this.state.inType = oldInType;\n        }\n      };\n\n      _proto.tsParseTypeAssertion = function tsParseTypeAssertion() {\n        var node = this.startNode();\n        node.typeAnnotation = this.tsParseType();\n        this.expectRelational(\">\");\n        node.expression = this.parseMaybeUnary();\n        return this.finishNode(node, \"TSTypeAssertion\");\n      };\n\n      _proto.tsTryParseTypeArgumentsInExpression = function tsTryParseTypeArgumentsInExpression() {\n        var _this3 = this;\n\n        return this.tsTryParseAndCatch(function () {\n          var res = _this3.startNode();\n\n          _this3.expectRelational(\"<\");\n\n          var typeArguments = _this3.tsParseDelimitedList(\"TypeParametersOrArguments\", _this3.tsParseType.bind(_this3));\n\n          _this3.expectRelational(\">\");\n\n          res.params = typeArguments;\n\n          _this3.finishNode(res, \"TSTypeParameterInstantiation\");\n\n          _this3.expect(types.parenL);\n\n          return res;\n        });\n      };\n\n      _proto.tsParseHeritageClause = function tsParseHeritageClause() {\n        return this.tsParseDelimitedList(\"HeritageClauseElement\", this.tsParseExpressionWithTypeArguments.bind(this));\n      };\n\n      _proto.tsParseExpressionWithTypeArguments = function tsParseExpressionWithTypeArguments() {\n        var node = this.startNode(); // Note: TS uses parseLeftHandSideExpressionOrHigher,\n        // then has grammar errors later if it's not an EntityName.\n\n        node.expression = this.tsParseEntityName(\n        /* allowReservedWords */\n        false);\n\n        if (this.isRelational(\"<\")) {\n          node.typeParameters = this.tsParseTypeArguments();\n        }\n\n        return this.finishNode(node, \"TSExpressionWithTypeArguments\");\n      };\n\n      _proto.tsParseInterfaceDeclaration = function tsParseInterfaceDeclaration(node) {\n        node.id = this.parseIdentifier();\n        node.typeParameters = this.tsTryParseTypeParameters();\n\n        if (this.eat(types._extends)) {\n          node.extends = this.tsParseHeritageClause();\n        }\n\n        var body = this.startNode();\n        body.body = this.tsParseObjectTypeMembers();\n        node.body = this.finishNode(body, \"TSInterfaceBody\");\n        return this.finishNode(node, \"TSInterfaceDeclaration\");\n      };\n\n      _proto.tsParseTypeAliasDeclaration = function tsParseTypeAliasDeclaration(node) {\n        node.id = this.parseIdentifier();\n        node.typeParameters = this.tsTryParseTypeParameters();\n        this.expect(types.eq);\n        node.typeAnnotation = this.tsParseType();\n        this.semicolon();\n        return this.finishNode(node, \"TSTypeAliasDeclaration\");\n      };\n\n      _proto.tsParseEnumMember = function tsParseEnumMember() {\n        var node = this.startNode(); // Computed property names are grammar errors in an enum, so accept just string literal or identifier.\n\n        node.id = this.match(types.string) ? this.parseLiteral(this.state.value, \"StringLiteral\") : this.parseIdentifier(\n        /* liberal */\n        true);\n\n        if (this.eat(types.eq)) {\n          node.initializer = this.parseMaybeAssign();\n        }\n\n        return this.finishNode(node, \"TSEnumMember\");\n      };\n\n      _proto.tsParseEnumDeclaration = function tsParseEnumDeclaration(node, isConst) {\n        if (isConst) node.const = true;\n        node.id = this.parseIdentifier();\n        this.expect(types.braceL);\n        node.members = this.tsParseDelimitedList(\"EnumMembers\", this.tsParseEnumMember.bind(this));\n        this.expect(types.braceR);\n        return this.finishNode(node, \"TSEnumDeclaration\");\n      };\n\n      _proto.tsParseModuleBlock = function tsParseModuleBlock() {\n        var node = this.startNode();\n        this.expect(types.braceL); // Inside of a module block is considered \"top-level\", meaning it can have imports and exports.\n\n        this.parseBlockOrModuleBlockBody(node.body = [],\n        /* directives */\n        undefined,\n        /* topLevel */\n        true,\n        /* end */\n        types.braceR);\n        return this.finishNode(node, \"TSModuleBlock\");\n      };\n\n      _proto.tsParseModuleOrNamespaceDeclaration = function tsParseModuleOrNamespaceDeclaration(node) {\n        node.id = this.parseIdentifier();\n\n        if (this.eat(types.dot)) {\n          var inner = this.startNode();\n          this.tsParseModuleOrNamespaceDeclaration(inner);\n          node.body = inner;\n        } else {\n          node.body = this.tsParseModuleBlock();\n        }\n\n        return this.finishNode(node, \"TSModuleDeclaration\");\n      };\n\n      _proto.tsParseAmbientExternalModuleDeclaration = function tsParseAmbientExternalModuleDeclaration(node) {\n        if (this.isContextual(\"global\")) {\n          node.global = true;\n          node.id = this.parseIdentifier();\n        } else if (this.match(types.string)) {\n          node.id = this.parseExprAtom();\n        } else {\n          this.unexpected();\n        }\n\n        if (this.match(types.braceL)) {\n          node.body = this.tsParseModuleBlock();\n        } else {\n          this.semicolon();\n        }\n\n        return this.finishNode(node, \"TSModuleDeclaration\");\n      };\n\n      _proto.tsParseImportEqualsDeclaration = function tsParseImportEqualsDeclaration(node, isExport) {\n        node.isExport = isExport || false;\n        node.id = this.parseIdentifier();\n        this.expect(types.eq);\n        node.moduleReference = this.tsParseModuleReference();\n        this.semicolon();\n        return this.finishNode(node, \"TSImportEqualsDeclaration\");\n      };\n\n      _proto.tsIsExternalModuleReference = function tsIsExternalModuleReference() {\n        return this.isContextual(\"require\") && this.lookahead().type === types.parenL;\n      };\n\n      _proto.tsParseModuleReference = function tsParseModuleReference() {\n        return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(\n        /* allowReservedWords */\n        false);\n      };\n\n      _proto.tsParseExternalModuleReference = function tsParseExternalModuleReference() {\n        var node = this.startNode();\n        this.expectContextual(\"require\");\n        this.expect(types.parenL);\n\n        if (!this.match(types.string)) {\n          throw this.unexpected();\n        }\n\n        node.expression = this.parseLiteral(this.state.value, \"StringLiteral\");\n        this.expect(types.parenR);\n        return this.finishNode(node, \"TSExternalModuleReference\");\n      }; // Utilities\n\n\n      _proto.tsLookAhead = function tsLookAhead(f) {\n        var state = this.state.clone();\n        var res = f();\n        this.state = state;\n        return res;\n      };\n\n      _proto.tsTryParseAndCatch = function tsTryParseAndCatch(f) {\n        var state = this.state.clone();\n\n        try {\n          return f();\n        } catch (e) {\n          if (e instanceof SyntaxError) {\n            this.state = state;\n            return undefined;\n          }\n\n          throw e;\n        }\n      };\n\n      _proto.tsTryParse = function tsTryParse(f) {\n        var state = this.state.clone();\n        var result = f();\n\n        if (result !== undefined && result !== false) {\n          return result;\n        } else {\n          this.state = state;\n          return undefined;\n        }\n      };\n\n      _proto.nodeWithSamePosition = function nodeWithSamePosition(original, type) {\n        var node = this.startNodeAtNode(original);\n        node.type = type;\n        node.end = original.end;\n        node.loc.end = original.loc.end;\n\n        if (original.leadingComments) {\n          node.leadingComments = original.leadingComments;\n        }\n\n        if (original.trailingComments) {\n          node.trailingComments = original.trailingComments;\n        }\n\n        if (original.innerComments) node.innerComments = original.innerComments;\n        return node;\n      };\n\n      _proto.tsTryParseDeclare = function tsTryParseDeclare(nany) {\n        switch (this.state.type) {\n          case types._function:\n            this.next();\n            return this.parseFunction(nany,\n            /* isStatement */\n            true);\n\n          case types._class:\n            return this.parseClass(nany,\n            /* isStatement */\n            true,\n            /* optionalId */\n            false);\n\n          case types._const:\n            if (this.match(types._const) && this.isLookaheadContextual(\"enum\")) {\n              // `const enum = 0;` not allowed because \"enum\" is a strict mode reserved word.\n              this.expect(types._const);\n              this.expectContextual(\"enum\");\n              return this.tsParseEnumDeclaration(nany,\n              /* isConst */\n              true);\n            }\n\n          // falls through\n\n          case types._var:\n          case types._let:\n            return this.parseVarStatement(nany, this.state.type);\n\n          case types.name:\n            {\n              var value = this.state.value;\n\n              if (value === \"global\") {\n                return this.tsParseAmbientExternalModuleDeclaration(nany);\n              } else {\n                return this.tsParseDeclaration(nany, value,\n                /* next */\n                true);\n              }\n            }\n        }\n      }; // Note: this won't be called unless the keyword is allowed in `shouldParseExportDeclaration`.\n\n\n      _proto.tsTryParseExportDeclaration = function tsTryParseExportDeclaration() {\n        return this.tsParseDeclaration(this.startNode(), this.state.value,\n        /* next */\n        true);\n      };\n\n      _proto.tsParseExpressionStatement = function tsParseExpressionStatement(node, expr) {\n        switch (expr.name) {\n          case \"declare\":\n            {\n              var declaration = this.tsTryParseDeclare(node);\n\n              if (declaration) {\n                declaration.declare = true;\n                return declaration;\n              }\n\n              break;\n            }\n\n          case \"global\":\n            // `global { }` (with no `declare`) may appear inside an ambient module declaration.\n            // Would like to use tsParseAmbientExternalModuleDeclaration here, but already ran past \"global\".\n            if (this.match(types.braceL)) {\n              var mod = node;\n              mod.global = true;\n              mod.id = expr;\n              mod.body = this.tsParseModuleBlock();\n              return this.finishNode(mod, \"TSModuleDeclaration\");\n            }\n\n            break;\n\n          default:\n            return this.tsParseDeclaration(node, expr.name,\n            /* next */\n            false);\n        }\n      }; // Common to tsTryParseDeclare, tsTryParseExportDeclaration, and tsParseExpressionStatement.\n\n\n      _proto.tsParseDeclaration = function tsParseDeclaration(node, value, next) {\n        switch (value) {\n          case \"abstract\":\n            if (next || this.match(types._class)) {\n              var cls = node;\n              cls.abstract = true;\n              if (next) this.next();\n              return this.parseClass(cls,\n              /* isStatement */\n              true,\n              /* optionalId */\n              false);\n            }\n\n            break;\n\n          case \"enum\":\n            if (next || this.match(types.name)) {\n              if (next) this.next();\n              return this.tsParseEnumDeclaration(node,\n              /* isConst */\n              false);\n            }\n\n            break;\n\n          case \"interface\":\n            if (next || this.match(types.name)) {\n              if (next) this.next();\n              return this.tsParseInterfaceDeclaration(node);\n            }\n\n            break;\n\n          case \"module\":\n            if (next) this.next();\n\n            if (this.match(types.string)) {\n              return this.tsParseAmbientExternalModuleDeclaration(node);\n            } else if (next || this.match(types.name)) {\n              return this.tsParseModuleOrNamespaceDeclaration(node);\n            }\n\n            break;\n\n          case \"namespace\":\n            if (next || this.match(types.name)) {\n              if (next) this.next();\n              return this.tsParseModuleOrNamespaceDeclaration(node);\n            }\n\n            break;\n\n          case \"type\":\n            if (next || this.match(types.name)) {\n              if (next) this.next();\n              return this.tsParseTypeAliasDeclaration(node);\n            }\n\n            break;\n        }\n      };\n\n      _proto.tsTryParseGenericAsyncArrowFunction = function tsTryParseGenericAsyncArrowFunction(startPos, startLoc) {\n        var _this4 = this;\n\n        var res = this.tsTryParseAndCatch(function () {\n          var node = _this4.startNodeAt(startPos, startLoc);\n\n          node.typeParameters = _this4.tsParseTypeParameters(); // Don't use overloaded parseFunctionParams which would look for \"<\" again.\n\n          _superClass.prototype.parseFunctionParams.call(_this4, node);\n\n          node.returnType = _this4.tsTryParseTypeOrTypePredicateAnnotation();\n\n          _this4.expect(types.arrow);\n\n          return node;\n        });\n\n        if (!res) {\n          return undefined;\n        }\n\n        res.id = null;\n        res.generator = false;\n        res.expression = true; // May be set again by parseFunctionBody.\n\n        res.async = true;\n        this.parseFunctionBody(res, true);\n        return this.finishNode(res, \"ArrowFunctionExpression\");\n      };\n\n      _proto.tsParseTypeArguments = function tsParseTypeArguments() {\n        var node = this.startNode();\n        this.expectRelational(\"<\");\n        node.params = this.tsParseDelimitedList(\"TypeParametersOrArguments\", this.tsParseType.bind(this));\n        this.expectRelational(\">\");\n        return this.finishNode(node, \"TSTypeParameterInstantiation\");\n      };\n\n      _proto.tsIsDeclarationStart = function tsIsDeclarationStart() {\n        if (this.match(types.name)) {\n          switch (this.state.value) {\n            case \"abstract\":\n            case \"declare\":\n            case \"enum\":\n            case \"interface\":\n            case \"module\":\n            case \"namespace\":\n            case \"type\":\n              return true;\n          }\n        }\n\n        return false;\n      }; // ======================================================\n      // OVERRIDES\n      // ======================================================\n\n\n      _proto.isExportDefaultSpecifier = function isExportDefaultSpecifier() {\n        if (this.tsIsDeclarationStart()) return false;\n        return _superClass.prototype.isExportDefaultSpecifier.call(this);\n      };\n\n      _proto.parseAssignableListItem = function parseAssignableListItem(allowModifiers, decorators) {\n        var accessibility;\n        var readonly = false;\n\n        if (allowModifiers) {\n          accessibility = this.parseAccessModifier();\n          readonly = !!this.tsParseModifier([\"readonly\"]);\n        }\n\n        var left = this.parseMaybeDefault();\n        this.parseAssignableListItemTypes(left);\n        var elt = this.parseMaybeDefault(left.start, left.loc.start, left);\n\n        if (accessibility || readonly) {\n          var pp = this.startNodeAtNode(elt);\n\n          if (decorators.length) {\n            pp.decorators = decorators;\n          }\n\n          if (accessibility) pp.accessibility = accessibility;\n          if (readonly) pp.readonly = readonly;\n\n          if (elt.type !== \"Identifier\" && elt.type !== \"AssignmentPattern\") {\n            throw this.raise(pp.start, \"A parameter property may not be declared using a binding pattern.\");\n          }\n\n          pp.parameter = elt;\n          return this.finishNode(pp, \"TSParameterProperty\");\n        } else {\n          if (decorators.length) {\n            left.decorators = decorators;\n          }\n\n          return elt;\n        }\n      };\n\n      _proto.parseFunctionBodyAndFinish = function parseFunctionBodyAndFinish(node, type, allowExpressionBody) {\n        // For arrow functions, `parseArrow` handles the return type itself.\n        if (!allowExpressionBody && this.match(types.colon)) {\n          node.returnType = this.tsParseTypeOrTypePredicateAnnotation(types.colon);\n        }\n\n        var bodilessType = type === \"FunctionDeclaration\" ? \"TSDeclareFunction\" : type === \"ClassMethod\" ? \"TSDeclareMethod\" : undefined;\n\n        if (bodilessType && !this.match(types.braceL) && this.isLineTerminator()) {\n          this.finishNode(node, bodilessType);\n          return;\n        }\n\n        _superClass.prototype.parseFunctionBodyAndFinish.call(this, node, type, allowExpressionBody);\n      };\n\n      _proto.parseSubscript = function parseSubscript(base, startPos, startLoc, noCalls, state) {\n        if (this.eat(types.bang)) {\n          var nonNullExpression = this.startNodeAt(startPos, startLoc);\n          nonNullExpression.expression = base;\n          return this.finishNode(nonNullExpression, \"TSNonNullExpression\");\n        }\n\n        if (!noCalls && this.isRelational(\"<\")) {\n          if (this.atPossibleAsync(base)) {\n            // Almost certainly this is a generic async function `async <T>() => ...\n            // But it might be a call with a type argument `async<T>();`\n            var asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startPos, startLoc);\n\n            if (asyncArrowFn) {\n              return asyncArrowFn;\n            }\n          }\n\n          var node = this.startNodeAt(startPos, startLoc);\n          node.callee = base; // May be passing type arguments. But may just be the `<` operator.\n\n          var typeArguments = this.tsTryParseTypeArgumentsInExpression(); // Also eats the \"(\"\n\n          if (typeArguments) {\n            // possibleAsync always false here, because we would have handled it above.\n            // $FlowIgnore (won't be any undefined arguments)\n            node.arguments = this.parseCallExpressionArguments(types.parenR,\n            /* possibleAsync */\n            false);\n            node.typeParameters = typeArguments;\n            return this.finishCallExpression(node);\n          }\n        }\n\n        return _superClass.prototype.parseSubscript.call(this, base, startPos, startLoc, noCalls, state);\n      };\n\n      _proto.parseNewArguments = function parseNewArguments(node) {\n        var _this5 = this;\n\n        if (this.isRelational(\"<\")) {\n          // tsTryParseAndCatch is expensive, so avoid if not necessary.\n          // 99% certain this is `new C<T>();`. But may be `new C < T;`, which is also legal.\n          var typeParameters = this.tsTryParseAndCatch(function () {\n            var args = _this5.tsParseTypeArguments();\n\n            if (!_this5.match(types.parenL)) _this5.unexpected();\n            return args;\n          });\n\n          if (typeParameters) {\n            node.typeParameters = typeParameters;\n          }\n        }\n\n        _superClass.prototype.parseNewArguments.call(this, node);\n      };\n\n      _proto.parseExprOp = function parseExprOp(left, leftStartPos, leftStartLoc, minPrec, noIn) {\n        if (nonNull(types._in.binop) > minPrec && !this.hasPrecedingLineBreak() && this.eatContextual(\"as\")) {\n          var node = this.startNodeAt(leftStartPos, leftStartLoc);\n          node.expression = left;\n          node.typeAnnotation = this.tsParseType();\n          this.finishNode(node, \"TSAsExpression\");\n          return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);\n        }\n\n        return _superClass.prototype.parseExprOp.call(this, left, leftStartPos, leftStartLoc, minPrec, noIn);\n      };\n\n      _proto.checkReservedWord = function checkReservedWord(word, startLoc, checkKeywords, // eslint-disable-next-line no-unused-vars\n      isBinding) {} // Don't bother checking for TypeScript code.\n      // Strict mode words may be allowed as in `declare namespace N { const static: number; }`.\n      // And we have a type checker anyway, so don't bother having the parser do it.\n\n      /*\n      Don't bother doing this check in TypeScript code because:\n      1. We may have a nested export statement with the same name:\n        export const x = 0;\n        export namespace N {\n          export const x = 1;\n        }\n      2. We have a type checker to warn us about this sort of thing.\n      */\n      ;\n\n      _proto.checkDuplicateExports = function checkDuplicateExports() {};\n\n      _proto.parseImport = function parseImport(node) {\n        if (this.match(types.name) && this.lookahead().type === types.eq) {\n          return this.tsParseImportEqualsDeclaration(node);\n        }\n\n        return _superClass.prototype.parseImport.call(this, node);\n      };\n\n      _proto.parseExport = function parseExport(node) {\n        if (this.match(types._import)) {\n          // `export import A = B;`\n          this.expect(types._import);\n          return this.tsParseImportEqualsDeclaration(node,\n          /* isExport */\n          true);\n        } else if (this.eat(types.eq)) {\n          // `export = x;`\n          var assign = node;\n          assign.expression = this.parseExpression();\n          this.semicolon();\n          return this.finishNode(assign, \"TSExportAssignment\");\n        } else if (this.eatContextual(\"as\")) {\n          // `export as namespace A;`\n          var decl = node; // See `parseNamespaceExportDeclaration` in TypeScript's own parser\n\n          this.expectContextual(\"namespace\");\n          decl.id = this.parseIdentifier();\n          this.semicolon();\n          return this.finishNode(decl, \"TSNamespaceExportDeclaration\");\n        } else {\n          return _superClass.prototype.parseExport.call(this, node);\n        }\n      };\n\n      _proto.parseStatementContent = function parseStatementContent(declaration, topLevel) {\n        if (this.state.type === types._const) {\n          var ahead = this.lookahead();\n\n          if (ahead.type === types.name && ahead.value === \"enum\") {\n            var node = this.startNode();\n            this.expect(types._const);\n            this.expectContextual(\"enum\");\n            return this.tsParseEnumDeclaration(node,\n            /* isConst */\n            true);\n          }\n        }\n\n        return _superClass.prototype.parseStatementContent.call(this, declaration, topLevel);\n      };\n\n      _proto.parseAccessModifier = function parseAccessModifier() {\n        return this.tsParseModifier([\"public\", \"protected\", \"private\"]);\n      };\n\n      _proto.parseClassMember = function parseClassMember(classBody, member, state) {\n        var accessibility = this.parseAccessModifier();\n        if (accessibility) member.accessibility = accessibility;\n\n        _superClass.prototype.parseClassMember.call(this, classBody, member, state);\n      };\n\n      _proto.parseClassMemberWithIsStatic = function parseClassMemberWithIsStatic(classBody, member, state, isStatic) {\n        var methodOrProp = member;\n        var prop = member;\n        var propOrIdx = member;\n        var abstract = false,\n            readonly = false;\n        var mod = this.tsParseModifier([\"abstract\", \"readonly\"]);\n\n        switch (mod) {\n          case \"readonly\":\n            readonly = true;\n            abstract = !!this.tsParseModifier([\"abstract\"]);\n            break;\n\n          case \"abstract\":\n            abstract = true;\n            readonly = !!this.tsParseModifier([\"readonly\"]);\n            break;\n        }\n\n        if (abstract) methodOrProp.abstract = true;\n        if (readonly) propOrIdx.readonly = true;\n\n        if (!abstract && !isStatic && !methodOrProp.accessibility) {\n          var idx = this.tsTryParseIndexSignature(member);\n\n          if (idx) {\n            classBody.body.push(idx);\n            return;\n          }\n        }\n\n        if (readonly) {\n          // Must be a property (if not an index signature).\n          methodOrProp.static = isStatic;\n          this.parseClassPropertyName(prop);\n          this.parsePostMemberNameModifiers(methodOrProp);\n          this.pushClassProperty(classBody, prop);\n          return;\n        }\n\n        _superClass.prototype.parseClassMemberWithIsStatic.call(this, classBody, member, state, isStatic);\n      };\n\n      _proto.parsePostMemberNameModifiers = function parsePostMemberNameModifiers(methodOrProp) {\n        var optional = this.eat(types.question);\n        if (optional) methodOrProp.optional = true;\n      }; // Note: The reason we do this in `parseExpressionStatement` and not `parseStatement`\n      // is that e.g. `type()` is valid JS, so we must try parsing that first.\n      // If it's really a type, we will parse `type` as the statement, and can correct it here\n      // by parsing the rest.\n\n\n      _proto.parseExpressionStatement = function parseExpressionStatement(node, expr) {\n        var decl = expr.type === \"Identifier\" ? this.tsParseExpressionStatement(node, expr) : undefined;\n        return decl || _superClass.prototype.parseExpressionStatement.call(this, node, expr);\n      }; // export type\n      // Should be true for anything parsed by `tsTryParseExportDeclaration`.\n\n\n      _proto.shouldParseExportDeclaration = function shouldParseExportDeclaration() {\n        if (this.tsIsDeclarationStart()) return true;\n        return _superClass.prototype.shouldParseExportDeclaration.call(this);\n      }; // An apparent conditional expression could actually be an optional parameter in an arrow function.\n\n\n      _proto.parseConditional = function parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos) {\n        // only do the expensive clone if there is a question mark\n        // and if we come from inside parens\n        if (!refNeedsArrowPos || !this.match(types.question)) {\n          return _superClass.prototype.parseConditional.call(this, expr, noIn, startPos, startLoc, refNeedsArrowPos);\n        }\n\n        var state = this.state.clone();\n\n        try {\n          return _superClass.prototype.parseConditional.call(this, expr, noIn, startPos, startLoc);\n        } catch (err) {\n          if (!(err instanceof SyntaxError)) {\n            // istanbul ignore next: no such error is expected\n            throw err;\n          }\n\n          this.state = state;\n          refNeedsArrowPos.start = err.pos || this.state.start;\n          return expr;\n        }\n      }; // Note: These \"type casts\" are *not* valid TS expressions.\n      // But we parse them here and change them when completing the arrow function.\n\n\n      _proto.parseParenItem = function parseParenItem(node, startPos, startLoc) {\n        node = _superClass.prototype.parseParenItem.call(this, node, startPos, startLoc);\n\n        if (this.eat(types.question)) {\n          node.optional = true;\n        }\n\n        if (this.match(types.colon)) {\n          var typeCastNode = this.startNodeAt(startPos, startLoc);\n          typeCastNode.expression = node;\n          typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();\n          return this.finishNode(typeCastNode, \"TSTypeCastExpression\");\n        }\n\n        return node;\n      };\n\n      _proto.parseExportDeclaration = function parseExportDeclaration(node) {\n        // \"export declare\" is equivalent to just \"export\".\n        var isDeclare = this.eatContextual(\"declare\");\n        var declaration;\n\n        if (this.match(types.name)) {\n          declaration = this.tsTryParseExportDeclaration();\n        }\n\n        if (!declaration) {\n          declaration = _superClass.prototype.parseExportDeclaration.call(this, node);\n        }\n\n        if (declaration && isDeclare) {\n          declaration.declare = true;\n        }\n\n        return declaration;\n      };\n\n      _proto.parseClassId = function parseClassId(node, isStatement, optionalId) {\n        var _superClass$prototype;\n\n        if ((!isStatement || optionalId) && this.isContextual(\"implements\")) {\n          return;\n        }\n\n        (_superClass$prototype = _superClass.prototype.parseClassId).call.apply(_superClass$prototype, [this].concat(Array.prototype.slice.call(arguments)));\n\n        var typeParameters = this.tsTryParseTypeParameters();\n        if (typeParameters) node.typeParameters = typeParameters;\n      };\n\n      _proto.parseClassProperty = function parseClassProperty(node) {\n        var type = this.tsTryParseTypeAnnotation();\n        if (type) node.typeAnnotation = type;\n        return _superClass.prototype.parseClassProperty.call(this, node);\n      };\n\n      _proto.pushClassMethod = function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor) {\n        var typeParameters = this.tsTryParseTypeParameters();\n        if (typeParameters) method.typeParameters = typeParameters;\n\n        _superClass.prototype.pushClassMethod.call(this, classBody, method, isGenerator, isAsync, isConstructor);\n      };\n\n      _proto.pushClassPrivateMethod = function pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n        var typeParameters = this.tsTryParseTypeParameters();\n        if (typeParameters) method.typeParameters = typeParameters;\n\n        _superClass.prototype.pushClassPrivateMethod.call(this, classBody, method, isGenerator, isAsync);\n      };\n\n      _proto.parseClassSuper = function parseClassSuper(node) {\n        _superClass.prototype.parseClassSuper.call(this, node);\n\n        if (node.superClass && this.isRelational(\"<\")) {\n          node.superTypeParameters = this.tsParseTypeArguments();\n        }\n\n        if (this.eatContextual(\"implements\")) {\n          node.implements = this.tsParseHeritageClause();\n        }\n      };\n\n      _proto.parseObjPropValue = function parseObjPropValue(prop) {\n        var _superClass$prototype2;\n\n        if (this.isRelational(\"<\")) {\n          throw new Error(\"TODO\");\n        }\n\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n\n        (_superClass$prototype2 = _superClass.prototype.parseObjPropValue).call.apply(_superClass$prototype2, [this, prop].concat(args));\n      };\n\n      _proto.parseFunctionParams = function parseFunctionParams(node, allowModifiers) {\n        var typeParameters = this.tsTryParseTypeParameters();\n        if (typeParameters) node.typeParameters = typeParameters;\n\n        _superClass.prototype.parseFunctionParams.call(this, node, allowModifiers);\n      }; // `let x: number;`\n\n\n      _proto.parseVarHead = function parseVarHead(decl) {\n        _superClass.prototype.parseVarHead.call(this, decl);\n\n        var type = this.tsTryParseTypeAnnotation();\n\n        if (type) {\n          decl.id.typeAnnotation = type;\n          this.finishNode(decl.id, decl.id.type); // set end position to end of type\n        }\n      }; // parse the return type of an async arrow function - let foo = (async (): number => {});\n\n\n      _proto.parseAsyncArrowFromCallExpression = function parseAsyncArrowFromCallExpression(node, call) {\n        if (this.match(types.colon)) {\n          node.returnType = this.tsParseTypeAnnotation();\n        }\n\n        return _superClass.prototype.parseAsyncArrowFromCallExpression.call(this, node, call);\n      };\n\n      _proto.parseMaybeAssign = function parseMaybeAssign() {\n        // Note: When the JSX plugin is on, type assertions (`<T> x`) aren't valid syntax.\n        var jsxError;\n\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        if (this.match(types.jsxTagStart)) {\n          var context = this.curContext();\n          assert(context === types$1.j_oTag); // Only time j_oTag is pushed is right after j_expr.\n\n          assert(this.state.context[this.state.context.length - 2] === types$1.j_expr); // Prefer to parse JSX if possible. But may be an arrow fn.\n\n          var _state = this.state.clone();\n\n          try {\n            var _superClass$prototype3;\n\n            return (_superClass$prototype3 = _superClass.prototype.parseMaybeAssign).call.apply(_superClass$prototype3, [this].concat(args));\n          } catch (err) {\n            if (!(err instanceof SyntaxError)) {\n              // istanbul ignore next: no such error is expected\n              throw err;\n            }\n\n            this.state = _state; // Pop the context added by the jsxTagStart.\n\n            assert(this.curContext() === types$1.j_oTag);\n            this.state.context.pop();\n            assert(this.curContext() === types$1.j_expr);\n            this.state.context.pop();\n            jsxError = err;\n          }\n        }\n\n        if (jsxError === undefined && !this.isRelational(\"<\")) {\n          var _superClass$prototype4;\n\n          return (_superClass$prototype4 = _superClass.prototype.parseMaybeAssign).call.apply(_superClass$prototype4, [this].concat(args));\n        } // Either way, we're looking at a '<': tt.jsxTagStart or relational.\n\n\n        var arrowExpression;\n        var typeParameters;\n        var state = this.state.clone();\n\n        try {\n          var _superClass$prototype5;\n\n          // This is similar to TypeScript's `tryParseParenthesizedArrowFunctionExpression`.\n          typeParameters = this.tsParseTypeParameters();\n          arrowExpression = (_superClass$prototype5 = _superClass.prototype.parseMaybeAssign).call.apply(_superClass$prototype5, [this].concat(args));\n\n          if (arrowExpression.type !== \"ArrowFunctionExpression\") {\n            this.unexpected(); // Go to the catch block (needs a SyntaxError).\n          }\n        } catch (err) {\n          var _superClass$prototype6;\n\n          if (!(err instanceof SyntaxError)) {\n            // istanbul ignore next: no such error is expected\n            throw err;\n          }\n\n          if (jsxError) {\n            throw jsxError;\n          } // Try parsing a type cast instead of an arrow function.\n          // This will never happen outside of JSX.\n          // (Because in JSX the '<' should be a jsxTagStart and not a relational.\n\n\n          assert(!this.hasPlugin(\"jsx\")); // Parsing an arrow function failed, so try a type cast.\n\n          this.state = state; // This will start with a type assertion (via parseMaybeUnary).\n          // But don't directly call `this.tsParseTypeAssertion` because we want to handle any binary after it.\n\n          return (_superClass$prototype6 = _superClass.prototype.parseMaybeAssign).call.apply(_superClass$prototype6, [this].concat(args));\n        } // Correct TypeScript code should have at least 1 type parameter, but don't crash on bad code.\n\n\n        if (typeParameters && typeParameters.params.length !== 0) {\n          this.resetStartLocationFromNode(arrowExpression, typeParameters.params[0]);\n        }\n\n        arrowExpression.typeParameters = typeParameters;\n        return arrowExpression;\n      }; // Handle type assertions\n\n\n      _proto.parseMaybeUnary = function parseMaybeUnary(refShorthandDefaultPos) {\n        if (!this.hasPlugin(\"jsx\") && this.eatRelational(\"<\")) {\n          return this.tsParseTypeAssertion();\n        } else {\n          return _superClass.prototype.parseMaybeUnary.call(this, refShorthandDefaultPos);\n        }\n      };\n\n      _proto.parseArrow = function parseArrow(node) {\n        if (this.match(types.colon)) {\n          // This is different from how the TS parser does it.\n          // TS uses lookahead. Babylon parses it as a parenthesized expression and converts.\n          var state = this.state.clone();\n\n          try {\n            var returnType = this.tsParseTypeOrTypePredicateAnnotation(types.colon);\n            if (this.canInsertSemicolon()) this.unexpected();\n            if (!this.match(types.arrow)) this.unexpected();\n            node.returnType = returnType;\n          } catch (err) {\n            if (err instanceof SyntaxError) {\n              this.state = state;\n            } else {\n              // istanbul ignore next: no such error is expected\n              throw err;\n            }\n          }\n        }\n\n        return _superClass.prototype.parseArrow.call(this, node);\n      }; // Allow type annotations inside of a parameter list.\n\n\n      _proto.parseAssignableListItemTypes = function parseAssignableListItemTypes(param) {\n        if (this.eat(types.question)) {\n          if (param.type !== \"Identifier\") {\n            throw this.raise(param.start, \"A binding pattern parameter cannot be optional in an implementation signature.\");\n          }\n\n          param.optional = true;\n        }\n\n        var type = this.tsTryParseTypeAnnotation();\n        if (type) param.typeAnnotation = type;\n        return this.finishNode(param, param.type);\n      };\n\n      _proto.toAssignable = function toAssignable(node, isBinding, contextDescription) {\n        switch (node.type) {\n          case \"TSTypeCastExpression\":\n            return _superClass.prototype.toAssignable.call(this, this.typeCastToParameter(node), isBinding, contextDescription);\n\n          case \"TSParameterProperty\":\n            return _superClass.prototype.toAssignable.call(this, node, isBinding, contextDescription);\n\n          default:\n            return _superClass.prototype.toAssignable.call(this, node, isBinding, contextDescription);\n        }\n      };\n\n      _proto.checkLVal = function checkLVal(expr, isBinding, checkClashes, contextDescription) {\n        switch (expr.type) {\n          case \"TSTypeCastExpression\":\n            // Allow \"typecasts\" to appear on the left of assignment expressions,\n            // because it may be in an arrow function.\n            // e.g. `const f = (foo: number = 0) => foo;`\n            return;\n\n          case \"TSParameterProperty\":\n            this.checkLVal(expr.parameter, isBinding, checkClashes, \"parameter property\");\n            return;\n\n          default:\n            _superClass.prototype.checkLVal.call(this, expr, isBinding, checkClashes, contextDescription);\n\n            return;\n        }\n      };\n\n      _proto.parseBindingAtom = function parseBindingAtom() {\n        switch (this.state.type) {\n          case types._this:\n            // \"this\" may be the name of a parameter, so allow it.\n            return this.parseIdentifier(\n            /* liberal */\n            true);\n\n          default:\n            return _superClass.prototype.parseBindingAtom.call(this);\n        }\n      }; // === === === === === === === === === === === === === === === ===\n      // Note: All below methods are duplicates of something in flow.js.\n      // Not sure what the best way to combine these is.\n      // === === === === === === === === === === === === === === === ===\n\n\n      _proto.isClassMethod = function isClassMethod() {\n        return this.isRelational(\"<\") || _superClass.prototype.isClassMethod.call(this);\n      };\n\n      _proto.isClassProperty = function isClassProperty() {\n        return this.match(types.colon) || _superClass.prototype.isClassProperty.call(this);\n      };\n\n      _proto.parseMaybeDefault = function parseMaybeDefault() {\n        var _superClass$prototype7;\n\n        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n          args[_key3] = arguments[_key3];\n        }\n\n        var node = (_superClass$prototype7 = _superClass.prototype.parseMaybeDefault).call.apply(_superClass$prototype7, [this].concat(args));\n\n        if (node.type === \"AssignmentPattern\" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {\n          this.raise(node.typeAnnotation.start, \"Type annotations must come before default assignments, \" + \"e.g. instead of `age = 25: number` use `age: number = 25`\");\n        }\n\n        return node;\n      }; // ensure that inside types, we bypass the jsx parser plugin\n\n\n      _proto.readToken = function readToken(code) {\n        if (this.state.inType && (code === 62 || code === 60)) {\n          return this.finishOp(types.relational, 1);\n        } else {\n          return _superClass.prototype.readToken.call(this, code);\n        }\n      };\n\n      _proto.toAssignableList = function toAssignableList(exprList, isBinding, contextDescription) {\n        for (var i = 0; i < exprList.length; i++) {\n          var expr = exprList[i];\n\n          if (expr && expr.type === \"TSTypeCastExpression\") {\n            exprList[i] = this.typeCastToParameter(expr);\n          }\n        }\n\n        return _superClass.prototype.toAssignableList.call(this, exprList, isBinding, contextDescription);\n      };\n\n      _proto.typeCastToParameter = function typeCastToParameter(node) {\n        node.expression.typeAnnotation = node.typeAnnotation;\n        return this.finishNodeAt(node.expression, node.expression.type, node.typeAnnotation.end, node.typeAnnotation.loc.end);\n      };\n\n      _proto.toReferencedList = function toReferencedList(exprList) {\n        for (var i = 0; i < exprList.length; i++) {\n          var expr = exprList[i];\n\n          if (expr && expr._exprListItem && expr.type === \"TsTypeCastExpression\") {\n            this.raise(expr.start, \"Did not expect a type annotation here.\");\n          }\n        }\n\n        return exprList;\n      };\n\n      _proto.shouldParseArrow = function shouldParseArrow() {\n        return this.match(types.colon) || _superClass.prototype.shouldParseArrow.call(this);\n      };\n\n      _proto.shouldParseAsyncArrow = function shouldParseAsyncArrow() {\n        return this.match(types.colon) || _superClass.prototype.shouldParseAsyncArrow.call(this);\n      };\n\n      return _class;\n    }(superClass)\n  );\n});\n\nplugins.estree = estreePlugin;\nplugins.flow = flowPlugin;\nplugins.jsx = jsxPlugin;\nplugins.typescript = typescriptPlugin;\nfunction parse(input, options) {\n  if (options && options.sourceType === \"unambiguous\") {\n    options = Object.assign({}, options);\n\n    try {\n      options.sourceType = \"module\";\n      var ast = getParser(options, input).parse(); // Rather than try to parse as a script first, we opt to parse as a module and convert back\n      // to a script where possible to avoid having to do a full re-parse of the input content.\n\n      if (!hasModuleSyntax(ast)) ast.program.sourceType = \"script\";\n      return ast;\n    } catch (moduleError) {\n      try {\n        options.sourceType = \"script\";\n        return getParser(options, input).parse();\n      } catch (scriptError) {}\n\n      throw moduleError;\n    }\n  } else {\n    return getParser(options, input).parse();\n  }\n}\nfunction parseExpression(input, options) {\n  var parser = getParser(options, input);\n\n  if (parser.options.strictMode) {\n    parser.state.strict = true;\n  }\n\n  return parser.getExpression();\n}\nfunction getParser(options, input) {\n  var cls = options && options.plugins ? getParserClass(options.plugins) : Parser;\n  return new cls(options, input);\n}\n\nvar parserClassCache = {};\n/** Get a Parser class with plugins applied. */\n\nfunction getParserClass(pluginsFromOptions) {\n  if (pluginsFromOptions.indexOf(\"decorators\") >= 0 && pluginsFromOptions.indexOf(\"decorators2\") >= 0) {\n    throw new Error(\"Cannot use decorators and decorators2 plugin together\");\n  } // Filter out just the plugins that have an actual mixin associated with them.\n\n\n  var pluginList = pluginsFromOptions.filter(function (p) {\n    return p === \"estree\" || p === \"flow\" || p === \"jsx\" || p === \"typescript\";\n  });\n\n  if (pluginList.indexOf(\"flow\") >= 0) {\n    // ensure flow plugin loads last\n    pluginList = pluginList.filter(function (plugin) {\n      return plugin !== \"flow\";\n    });\n    pluginList.push(\"flow\");\n  }\n\n  if (pluginList.indexOf(\"flow\") >= 0 && pluginList.indexOf(\"typescript\") >= 0) {\n    throw new Error(\"Cannot combine flow and typescript plugins.\");\n  }\n\n  if (pluginList.indexOf(\"typescript\") >= 0) {\n    // ensure typescript plugin loads last\n    pluginList = pluginList.filter(function (plugin) {\n      return plugin !== \"typescript\";\n    });\n    pluginList.push(\"typescript\");\n  }\n\n  if (pluginList.indexOf(\"estree\") >= 0) {\n    // ensure estree plugin loads first\n    pluginList = pluginList.filter(function (plugin) {\n      return plugin !== \"estree\";\n    });\n    pluginList.unshift(\"estree\");\n  }\n\n  var key = pluginList.join(\"/\");\n  var cls = parserClassCache[key];\n\n  if (!cls) {\n    cls = Parser;\n\n    for (var _i2 = 0, _pluginList2 = pluginList; _i2 < _pluginList2.length; _i2++) {\n      var plugin = _pluginList2[_i2];\n      cls = plugins[plugin](cls);\n    }\n\n    parserClassCache[key] = cls;\n  }\n\n  return cls;\n}\n\nfunction hasModuleSyntax(ast) {\n  return ast.program.body.some(function (child) {\n    return child.type === \"ImportDeclaration\" && (!child.importKind || child.importKind === \"value\") || child.type === \"ExportNamedDeclaration\" && (!child.exportKind || child.exportKind === \"value\") || child.type === \"ExportAllDeclaration\" && (!child.exportKind || child.exportKind === \"value\") || child.type === \"ExportDefaultDeclaration\";\n  });\n}\n\nexports.parse = parse;\nexports.parseExpression = parseExpression;\nexports.tokTypes = types;\n\n\n//# sourceURL=webpack://WTBenchmark/./node_modules/babylon/lib/index.js?\n}");

/***/ }),

/***/ "./src/babylon.mjs":
/*!*************************!*\
  !*** ./src/babylon.mjs ***!
  \*************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   runTest: () => (/* binding */ runTest)\n/* harmony export */ });\n/* harmony import */ var babylon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babylon */ \"./node_modules/babylon/lib/index.js\");\n// Copyright 2017 the V8 project authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n\n\nconst payloads = [\n  {\n    name: \"jquery-3.7.1.js\",\n    options: { sourceType: \"script\" },\n  },\n  {\n    name: \"lodash.core-4.17.21.js\",\n    options: { sourceType: \"script\" },\n  },\n  {\n    name: \"preact-8.2.5.js\",\n    options: { sourceType: \"script\" },\n  },\n  {\n    name: \"redux-5.0.1.min.js\",\n    options: { sourceType: \"module\", plugins: [\"objectRestSpread\"] },\n  },\n  {\n    name: \"speedometer-es2015-test-2.0.js\",\n    options: { sourceType: \"script\" },\n  },\n  {\n    name: \"todomvc/react/app.jsx\",\n    options: { sourceType: \"script\", plugins: [\"jsx\"] },\n  },\n  {\n    name: \"todomvc/react/footer.jsx\",\n    options: { sourceType: \"script\", plugins: [\"jsx\"] },\n  },\n  {\n    name: \"todomvc/react/todoItem.jsx\",\n    options: { sourceType: \"script\", plugins: [\"jsx\"] },\n  },\n  {\n    name: \"underscore-1.13.7.js\",\n    options: { sourceType: \"script\" },\n  },\n  {\n    name: \"vue-3.5.18.runtime.esm-browser.js\",\n    options: { sourceType: \"module\" },\n  },\n];\n\nfunction runTest(fileData) {\n  const testData = payloads.map(({ name, options }) => ({\n    payload: fileData[name],\n    name,\n    options,\n  }));\n\n  return testData.map(({ payload, name, options }) => {\n    babylon__WEBPACK_IMPORTED_MODULE_0__.parse(payload, options);\n  });\n}\n\n\n//# sourceURL=webpack://WTBenchmark/./src/babylon.mjs?\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/babylon.mjs");
/******/ 	self.WTBenchmark = __webpack_exports__;
/******/ 	
/******/ })()
;