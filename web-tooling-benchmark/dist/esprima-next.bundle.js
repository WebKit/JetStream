/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/esprima-next/dist/esprima.js":
/*!***************************************************!*\
  !*** ./node_modules/esprima-next/dist/esprima.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArrayExpression: () => (/* binding */ ArrayExpression),\n/* harmony export */   ArrayPattern: () => (/* binding */ ArrayPattern),\n/* harmony export */   ArrowFunctionExpression: () => (/* binding */ ArrowFunctionExpression),\n/* harmony export */   AssignmentExpression: () => (/* binding */ AssignmentExpression),\n/* harmony export */   AssignmentPattern: () => (/* binding */ AssignmentPattern),\n/* harmony export */   AsyncFunctionDeclaration: () => (/* binding */ AsyncFunctionDeclaration),\n/* harmony export */   AwaitExpression: () => (/* binding */ AwaitExpression),\n/* harmony export */   BigIntLiteral: () => (/* binding */ BigIntLiteral),\n/* harmony export */   BinaryExpression: () => (/* binding */ BinaryExpression),\n/* harmony export */   BlockStatement: () => (/* binding */ BlockStatement),\n/* harmony export */   BreakStatement: () => (/* binding */ BreakStatement),\n/* harmony export */   CallExpression: () => (/* binding */ CallExpression),\n/* harmony export */   CatchClause: () => (/* binding */ CatchClause),\n/* harmony export */   ChainExpression: () => (/* binding */ ChainExpression),\n/* harmony export */   ClassBody: () => (/* binding */ ClassBody),\n/* harmony export */   ClassDeclaration: () => (/* binding */ ClassDeclaration),\n/* harmony export */   ClassExpression: () => (/* binding */ ClassExpression),\n/* harmony export */   ConditionalExpression: () => (/* binding */ ConditionalExpression),\n/* harmony export */   ContinueStatement: () => (/* binding */ ContinueStatement),\n/* harmony export */   DebuggerStatement: () => (/* binding */ DebuggerStatement),\n/* harmony export */   Decorator: () => (/* binding */ Decorator),\n/* harmony export */   Directive: () => (/* binding */ Directive),\n/* harmony export */   DoWhileStatement: () => (/* binding */ DoWhileStatement),\n/* harmony export */   EmptyStatement: () => (/* binding */ EmptyStatement),\n/* harmony export */   ExportAllDeclaration: () => (/* binding */ ExportAllDeclaration),\n/* harmony export */   ExportDefaultDeclaration: () => (/* binding */ ExportDefaultDeclaration),\n/* harmony export */   ExportNamedDeclaration: () => (/* binding */ ExportNamedDeclaration),\n/* harmony export */   ExportSpecifier: () => (/* binding */ ExportSpecifier),\n/* harmony export */   ExpressionStatement: () => (/* binding */ ExpressionStatement),\n/* harmony export */   ForInStatement: () => (/* binding */ ForInStatement),\n/* harmony export */   ForOfStatement: () => (/* binding */ ForOfStatement),\n/* harmony export */   ForStatement: () => (/* binding */ ForStatement),\n/* harmony export */   FunctionDeclaration: () => (/* binding */ FunctionDeclaration),\n/* harmony export */   FunctionExpression: () => (/* binding */ FunctionExpression),\n/* harmony export */   Identifier: () => (/* binding */ Identifier),\n/* harmony export */   IfStatement: () => (/* binding */ IfStatement),\n/* harmony export */   ImportAttribute: () => (/* binding */ ImportAttribute),\n/* harmony export */   ImportDeclaration: () => (/* binding */ ImportDeclaration),\n/* harmony export */   ImportDefaultSpecifier: () => (/* binding */ ImportDefaultSpecifier),\n/* harmony export */   ImportExpression: () => (/* binding */ ImportExpression),\n/* harmony export */   ImportNamespaceSpecifier: () => (/* binding */ ImportNamespaceSpecifier),\n/* harmony export */   ImportSpecifier: () => (/* binding */ ImportSpecifier),\n/* harmony export */   LabeledStatement: () => (/* binding */ LabeledStatement),\n/* harmony export */   Literal: () => (/* binding */ Literal),\n/* harmony export */   LogicalExpression: () => (/* binding */ LogicalExpression),\n/* harmony export */   MemberExpression: () => (/* binding */ MemberExpression),\n/* harmony export */   MetaProperty: () => (/* binding */ MetaProperty),\n/* harmony export */   MethodDefinition: () => (/* binding */ MethodDefinition),\n/* harmony export */   Module: () => (/* binding */ Module),\n/* harmony export */   NewExpression: () => (/* binding */ NewExpression),\n/* harmony export */   Nodes: () => (/* binding */ nodes_exports),\n/* harmony export */   ObjectExpression: () => (/* binding */ ObjectExpression),\n/* harmony export */   ObjectPattern: () => (/* binding */ ObjectPattern),\n/* harmony export */   PrivateIdentifier: () => (/* binding */ PrivateIdentifier),\n/* harmony export */   Program: () => (/* binding */ Program),\n/* harmony export */   Property: () => (/* binding */ Property),\n/* harmony export */   PropertyDefinition: () => (/* binding */ PropertyDefinition),\n/* harmony export */   RegexLiteral: () => (/* binding */ RegexLiteral),\n/* harmony export */   RestElement: () => (/* binding */ RestElement),\n/* harmony export */   ReturnStatement: () => (/* binding */ ReturnStatement),\n/* harmony export */   Script: () => (/* binding */ Script),\n/* harmony export */   SequenceExpression: () => (/* binding */ SequenceExpression),\n/* harmony export */   SpreadElement: () => (/* binding */ SpreadElement),\n/* harmony export */   StaticBlock: () => (/* binding */ StaticBlock),\n/* harmony export */   Super: () => (/* binding */ Super),\n/* harmony export */   SwitchCase: () => (/* binding */ SwitchCase),\n/* harmony export */   SwitchStatement: () => (/* binding */ SwitchStatement),\n/* harmony export */   Syntax: () => (/* binding */ Syntax),\n/* harmony export */   TaggedTemplateExpression: () => (/* binding */ TaggedTemplateExpression),\n/* harmony export */   TemplateElement: () => (/* binding */ TemplateElement),\n/* harmony export */   TemplateLiteral: () => (/* binding */ TemplateLiteral),\n/* harmony export */   ThisExpression: () => (/* binding */ ThisExpression),\n/* harmony export */   ThrowStatement: () => (/* binding */ ThrowStatement),\n/* harmony export */   TryStatement: () => (/* binding */ TryStatement),\n/* harmony export */   UnaryExpression: () => (/* binding */ UnaryExpression),\n/* harmony export */   UpdateExpression: () => (/* binding */ UpdateExpression),\n/* harmony export */   VariableDeclaration: () => (/* binding */ VariableDeclaration),\n/* harmony export */   VariableDeclarator: () => (/* binding */ VariableDeclarator),\n/* harmony export */   Visitor: () => (/* binding */ Visitor),\n/* harmony export */   WhileStatement: () => (/* binding */ WhileStatement),\n/* harmony export */   WithStatement: () => (/* binding */ WithStatement),\n/* harmony export */   YieldExpression: () => (/* binding */ YieldExpression),\n/* harmony export */   \"default\": () => (/* binding */ esprima_default),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   parseModule: () => (/* binding */ parseModule),\n/* harmony export */   parseScript: () => (/* binding */ parseScript),\n/* harmony export */   tokenize: () => (/* binding */ tokenize),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/syntax.ts\nvar Syntax = /* @__PURE__ */ ((Syntax2) => {\n  Syntax2[\"AssignmentExpression\"] = \"AssignmentExpression\";\n  Syntax2[\"AssignmentPattern\"] = \"AssignmentPattern\";\n  Syntax2[\"ArrayExpression\"] = \"ArrayExpression\";\n  Syntax2[\"ArrayPattern\"] = \"ArrayPattern\";\n  Syntax2[\"ArrowFunctionExpression\"] = \"ArrowFunctionExpression\";\n  Syntax2[\"AwaitExpression\"] = \"AwaitExpression\";\n  Syntax2[\"BlockStatement\"] = \"BlockStatement\";\n  Syntax2[\"BinaryExpression\"] = \"BinaryExpression\";\n  Syntax2[\"BreakStatement\"] = \"BreakStatement\";\n  Syntax2[\"CallExpression\"] = \"CallExpression\";\n  Syntax2[\"CatchClause\"] = \"CatchClause\";\n  Syntax2[\"ChainExpression\"] = \"ChainExpression\";\n  Syntax2[\"ClassBody\"] = \"ClassBody\";\n  Syntax2[\"ClassDeclaration\"] = \"ClassDeclaration\";\n  Syntax2[\"ClassExpression\"] = \"ClassExpression\";\n  Syntax2[\"ConditionalExpression\"] = \"ConditionalExpression\";\n  Syntax2[\"ContinueStatement\"] = \"ContinueStatement\";\n  Syntax2[\"Decorator\"] = \"Decorator\";\n  Syntax2[\"DoWhileStatement\"] = \"DoWhileStatement\";\n  Syntax2[\"DebuggerStatement\"] = \"DebuggerStatement\";\n  Syntax2[\"EmptyStatement\"] = \"EmptyStatement\";\n  Syntax2[\"ExportAllDeclaration\"] = \"ExportAllDeclaration\";\n  Syntax2[\"ExportDefaultDeclaration\"] = \"ExportDefaultDeclaration\";\n  Syntax2[\"ExportNamedDeclaration\"] = \"ExportNamedDeclaration\";\n  Syntax2[\"ExportSpecifier\"] = \"ExportSpecifier\";\n  Syntax2[\"ExpressionStatement\"] = \"ExpressionStatement\";\n  Syntax2[\"ForStatement\"] = \"ForStatement\";\n  Syntax2[\"ForOfStatement\"] = \"ForOfStatement\";\n  Syntax2[\"ForInStatement\"] = \"ForInStatement\";\n  Syntax2[\"FunctionDeclaration\"] = \"FunctionDeclaration\";\n  Syntax2[\"FunctionExpression\"] = \"FunctionExpression\";\n  Syntax2[\"Identifier\"] = \"Identifier\";\n  Syntax2[\"IfStatement\"] = \"IfStatement\";\n  Syntax2[\"ImportAttribute\"] = \"ImportAttribute\";\n  Syntax2[\"ImportExpression\"] = \"ImportExpression\";\n  Syntax2[\"ImportDeclaration\"] = \"ImportDeclaration\";\n  Syntax2[\"ImportDefaultSpecifier\"] = \"ImportDefaultSpecifier\";\n  Syntax2[\"ImportNamespaceSpecifier\"] = \"ImportNamespaceSpecifier\";\n  Syntax2[\"ImportSpecifier\"] = \"ImportSpecifier\";\n  Syntax2[\"Literal\"] = \"Literal\";\n  Syntax2[\"LabeledStatement\"] = \"LabeledStatement\";\n  Syntax2[\"LogicalExpression\"] = \"LogicalExpression\";\n  Syntax2[\"MemberExpression\"] = \"MemberExpression\";\n  Syntax2[\"MetaProperty\"] = \"MetaProperty\";\n  Syntax2[\"MethodDefinition\"] = \"MethodDefinition\";\n  Syntax2[\"NewExpression\"] = \"NewExpression\";\n  Syntax2[\"ObjectExpression\"] = \"ObjectExpression\";\n  Syntax2[\"ObjectPattern\"] = \"ObjectPattern\";\n  Syntax2[\"Program\"] = \"Program\";\n  Syntax2[\"Property\"] = \"Property\";\n  Syntax2[\"PrivateIdentifier\"] = \"PrivateIdentifier\";\n  Syntax2[\"RestElement\"] = \"RestElement\";\n  Syntax2[\"ReturnStatement\"] = \"ReturnStatement\";\n  Syntax2[\"SequenceExpression\"] = \"SequenceExpression\";\n  Syntax2[\"SpreadElement\"] = \"SpreadElement\";\n  Syntax2[\"StaticBlock\"] = \"StaticBlock\";\n  Syntax2[\"Super\"] = \"Super\";\n  Syntax2[\"SwitchCase\"] = \"SwitchCase\";\n  Syntax2[\"SwitchStatement\"] = \"SwitchStatement\";\n  Syntax2[\"TaggedTemplateExpression\"] = \"TaggedTemplateExpression\";\n  Syntax2[\"TemplateElement\"] = \"TemplateElement\";\n  Syntax2[\"TemplateLiteral\"] = \"TemplateLiteral\";\n  Syntax2[\"ThisExpression\"] = \"ThisExpression\";\n  Syntax2[\"ThrowStatement\"] = \"ThrowStatement\";\n  Syntax2[\"TryStatement\"] = \"TryStatement\";\n  Syntax2[\"UnaryExpression\"] = \"UnaryExpression\";\n  Syntax2[\"UpdateExpression\"] = \"UpdateExpression\";\n  Syntax2[\"VariableDeclaration\"] = \"VariableDeclaration\";\n  Syntax2[\"VariableDeclarator\"] = \"VariableDeclarator\";\n  Syntax2[\"WhileStatement\"] = \"WhileStatement\";\n  Syntax2[\"WithStatement\"] = \"WithStatement\";\n  Syntax2[\"YieldExpression\"] = \"YieldExpression\";\n  return Syntax2;\n})(Syntax || {});\n\n// src/comment-handler.ts\nvar CommentHandler = class {\n  attach;\n  comments;\n  stack;\n  leading;\n  trailing;\n  constructor() {\n    this.attach = false;\n    this.comments = [];\n    this.stack = [];\n    this.leading = [];\n    this.trailing = [];\n  }\n  insertInnerComments(node, metadata) {\n    if (node.type === \"BlockStatement\" /* BlockStatement */ && node.body.length === 0) {\n      const innerComments = [];\n      for (let i = this.leading.length - 1; i >= 0; --i) {\n        const entry = this.leading[i];\n        if (metadata.end.offset >= entry.start) {\n          innerComments.unshift(entry.comment);\n          this.leading.splice(i, 1);\n          this.trailing.splice(i, 1);\n        }\n      }\n      if (innerComments.length) {\n        node.innerComments = innerComments;\n      }\n    }\n  }\n  findTrailingComments(metadata) {\n    let trailingComments = [];\n    if (this.trailing.length > 0) {\n      for (let i = this.trailing.length - 1; i >= 0; --i) {\n        const entry = this.trailing[i];\n        if (entry.start >= metadata.end.offset) {\n          trailingComments.unshift(entry.comment);\n        }\n      }\n      this.trailing.length = 0;\n      return trailingComments;\n    }\n    const last = this.stack[this.stack.length - 1];\n    if (last && last.node.trailingComments) {\n      const firstComment = last.node.trailingComments[0];\n      if (firstComment && firstComment.range[0] >= metadata.end.offset) {\n        trailingComments = last.node.trailingComments;\n        delete last.node.trailingComments;\n      }\n    }\n    return trailingComments;\n  }\n  findLeadingComments(metadata) {\n    const leadingComments = [];\n    let target;\n    while (this.stack.length > 0) {\n      const entry = this.stack[this.stack.length - 1];\n      if (entry && entry.start >= metadata.start.offset) {\n        target = entry.node;\n        this.stack.pop();\n      } else {\n        break;\n      }\n    }\n    if (target) {\n      const count = target.leadingComments ? target.leadingComments.length : 0;\n      for (let i = count - 1; i >= 0; --i) {\n        const comment = target.leadingComments[i];\n        if (comment.range[1] <= metadata.start.offset) {\n          leadingComments.unshift(comment);\n          target.leadingComments.splice(i, 1);\n        }\n      }\n      if (target.leadingComments && target.leadingComments.length === 0) {\n        delete target.leadingComments;\n      }\n      return leadingComments;\n    }\n    for (let i = this.leading.length - 1; i >= 0; --i) {\n      const entry = this.leading[i];\n      if (entry.start <= metadata.start.offset) {\n        leadingComments.unshift(entry.comment);\n        this.leading.splice(i, 1);\n      }\n    }\n    return leadingComments;\n  }\n  visitNode(node, metadata) {\n    if (node.type === \"Program\" /* Program */ && node.body.length > 0) {\n      return;\n    }\n    this.insertInnerComments(node, metadata);\n    const trailingComments = this.findTrailingComments(metadata);\n    const leadingComments = this.findLeadingComments(metadata);\n    if (leadingComments.length > 0) {\n      node.leadingComments = leadingComments;\n    }\n    if (trailingComments.length > 0) {\n      node.trailingComments = trailingComments;\n    }\n    this.stack.push({\n      node,\n      start: metadata.start.offset\n    });\n  }\n  visitComment(node, metadata) {\n    const type = node.type[0] === \"L\" ? \"Line\" : \"Block\";\n    const comment = {\n      type,\n      value: node.value\n    };\n    if (node.range) {\n      comment.range = node.range;\n    }\n    if (node.loc) {\n      comment.loc = node.loc;\n    }\n    this.comments.push(comment);\n    if (this.attach) {\n      const entry = {\n        comment: {\n          type,\n          value: node.value,\n          range: [metadata.start.offset, metadata.end.offset]\n        },\n        start: metadata.start.offset\n      };\n      if (node.loc) {\n        entry.comment.loc = node.loc;\n      }\n      node.type = type;\n      this.leading.push(entry);\n      this.trailing.push(entry);\n    }\n  }\n  visit(node, metadata) {\n    if (node.type === \"LineComment\") {\n      this.visitComment(node, metadata);\n    } else if (node.type === \"BlockComment\") {\n      this.visitComment(node, metadata);\n    } else if (this.attach) {\n      this.visitNode(node, metadata);\n    }\n  }\n};\n\n// src/character.ts\nvar Regex = {\n  // Unicode v12.1.0 NonAsciiIdentifierStart:\n  NonAsciiIdentifierStart: /[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086A\\u08A0-\\u08B4\\u08B6-\\u08BD\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u09FC\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1878\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C88\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CE9-\\u1CEC\\u1CEE-\\u1CF3\\u1CF5\\u1CF6\\u1CFA\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309B-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FEF\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7BF\\uA7C2-\\uA7C6\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA8FE\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB67\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDD00-\\uDD23\\uDF00-\\uDF1C\\uDF27\\uDF30-\\uDF45\\uDFE0-\\uDFF6]|\\uD804[\\uDC03-\\uDC37\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD44\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61]|\\uD805[\\uDC00-\\uDC34\\uDC47-\\uDC4A\\uDC5F\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA\\uDEB8\\uDF00-\\uDF1A]|\\uD806[\\uDC00-\\uDC2B\\uDCA0-\\uDCDF\\uDCFF\\uDDA0-\\uDDA7\\uDDAA-\\uDDD0\\uDDE1\\uDDE3\\uDE00\\uDE0B-\\uDE32\\uDE3A\\uDE50\\uDE5C-\\uDE89\\uDE9D\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC2E\\uDC40\\uDC72-\\uDC8F\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD30\\uDD46\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD89\\uDD98\\uDEE0-\\uDEF2]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDE40-\\uDE7F\\uDF00-\\uDF4A\\uDF50\\uDF93-\\uDF9F\\uDFE0\\uDFE1\\uDFE3]|\\uD821[\\uDC00-\\uDFF7]|\\uD822[\\uDC00-\\uDEF2]|\\uD82C[\\uDC00-\\uDD1E\\uDD50-\\uDD52\\uDD64-\\uDD67\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD838[\\uDD00-\\uDD2C\\uDD37-\\uDD3D\\uDD4E\\uDEC0-\\uDEEB]|\\uD83A[\\uDC00-\\uDCC4\\uDD00-\\uDD43\\uDD4B]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D]/,\n  // Unicode v12.1.0 NonAsciiIdentifierPart:\n  // eslint-disable-next-line no-misleading-character-class\n  NonAsciiIdentifierPart: /[\\xAA\\xB5\\xB7\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u07FD\\u0800-\\u082D\\u0840-\\u085B\\u0860-\\u086A\\u08A0-\\u08B4\\u08B6-\\u08BD\\u08D3-\\u08E1\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u09FC\\u09FE\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9-\\u0AFF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C80-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D00-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D54-\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1369-\\u1371\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1878\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19DA\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C88\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CD0-\\u1CD2\\u1CD4-\\u1CFA\\u1D00-\\u1DF9\\u1DFB-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FEF\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7BF\\uA7C2-\\uA7C6\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB67\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDDFD\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF7A\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE38-\\uDE3A\\uDE3F\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE6\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDD00-\\uDD27\\uDD30-\\uDD39\\uDF00-\\uDF1C\\uDF27\\uDF30-\\uDF50\\uDFE0-\\uDFF6]|\\uD804[\\uDC00-\\uDC46\\uDC66-\\uDC6F\\uDC7F-\\uDCBA\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD00-\\uDD34\\uDD36-\\uDD3F\\uDD44-\\uDD46\\uDD50-\\uDD73\\uDD76\\uDD80-\\uDDC4\\uDDC9-\\uDDCC\\uDDD0-\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE37\\uDE3E\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEEA\\uDEF0-\\uDEF9\\uDF00-\\uDF03\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3B-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF50\\uDF57\\uDF5D-\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC00-\\uDC4A\\uDC50-\\uDC59\\uDC5E\\uDC5F\\uDC80-\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDB5\\uDDB8-\\uDDC0\\uDDD8-\\uDDDD\\uDE00-\\uDE40\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEB8\\uDEC0-\\uDEC9\\uDF00-\\uDF1A\\uDF1D-\\uDF2B\\uDF30-\\uDF39]|\\uD806[\\uDC00-\\uDC3A\\uDCA0-\\uDCE9\\uDCFF\\uDDA0-\\uDDA7\\uDDAA-\\uDDD7\\uDDDA-\\uDDE1\\uDDE3\\uDDE4\\uDE00-\\uDE3E\\uDE47\\uDE50-\\uDE99\\uDE9D\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC36\\uDC38-\\uDC40\\uDC50-\\uDC59\\uDC72-\\uDC8F\\uDC92-\\uDCA7\\uDCA9-\\uDCB6\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD47\\uDD50-\\uDD59\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD8E\\uDD90\\uDD91\\uDD93-\\uDD98\\uDDA0-\\uDDA9\\uDEE0-\\uDEF6]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDED0-\\uDEED\\uDEF0-\\uDEF4\\uDF00-\\uDF36\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDE40-\\uDE7F\\uDF00-\\uDF4A\\uDF4F-\\uDF87\\uDF8F-\\uDF9F\\uDFE0\\uDFE1\\uDFE3]|\\uD821[\\uDC00-\\uDFF7]|\\uD822[\\uDC00-\\uDEF2]|\\uD82C[\\uDC00-\\uDD1E\\uDD50-\\uDD52\\uDD64-\\uDD67\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99\\uDC9D\\uDC9E]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDD00-\\uDD2C\\uDD30-\\uDD3D\\uDD40-\\uDD49\\uDD4E\\uDEC0-\\uDEF9]|\\uD83A[\\uDC00-\\uDCC4\\uDCD0-\\uDCD6\\uDD00-\\uDD4B\\uDD50-\\uDD59]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D]|\\uDB40[\\uDD00-\\uDDEF]/\n};\nvar Character = {\n  fromCodePoint(cp) {\n    return cp < 65536 ? String.fromCharCode(cp) : String.fromCharCode(55296 + (cp - 65536 >> 10)) + String.fromCharCode(56320 + (cp - 65536 & 1023));\n  },\n  isStringWellFormedUnicode(text) {\n    for (let i = 0; i < text.length; i++) {\n      let c = text.charCodeAt(i);\n      if (c >= 55296 && c <= 56319) {\n        if (i === text.length - 1) {\n          return false;\n        }\n        i++;\n        c = text.charCodeAt(i);\n        if (c < 56320 && c > 57343) {\n          return false;\n        }\n      } else if (c >= 56320 && c <= 57343) {\n        return false;\n      }\n    }\n    return true;\n  },\n  // https://tc39.github.io/ecma262/#sec-white-space\n  isWhiteSpace(cp) {\n    return cp === 32 || cp === 9 || cp === 11 || cp === 12 || cp === 160 || cp >= 5760 && [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(cp) >= 0;\n  },\n  // https://tc39.github.io/ecma262/#sec-line-terminators\n  isLineTerminator(cp) {\n    return cp === 10 || cp === 13 || cp === 8232 || cp === 8233;\n  },\n  // https://tc39.github.io/ecma262/#sec-names-and-keywords\n  isIdentifierStart(cp) {\n    return cp === 36 || cp === 95 || // $ (dollar) and _ (underscore)\n    cp >= 65 && cp <= 90 || // A..Z\n    cp >= 97 && cp <= 122 || // a..z\n    cp === 92 || // \\ (backslash)\n    cp >= 128 && Regex.NonAsciiIdentifierStart.test(Character.fromCodePoint(cp));\n  },\n  isIdentifierPart(cp) {\n    return cp === 36 || cp === 95 || // $ (dollar) and _ (underscore)\n    cp >= 65 && cp <= 90 || // A..Z\n    cp >= 97 && cp <= 122 || // a..z\n    cp >= 48 && cp <= 57 || // 0..9\n    cp === 92 || // \\ (backslash)\n    cp >= 128 && Regex.NonAsciiIdentifierPart.test(Character.fromCodePoint(cp));\n  },\n  // https://tc39.github.io/ecma262/#sec-literals-numeric-literals\n  isDecimalDigit(cp) {\n    return cp >= 48 && cp <= 57;\n  },\n  isDecimalDigitChar(ch) {\n    return ch.length === 1 && Character.isDecimalDigit(ch.charCodeAt(0));\n  },\n  isHexDigit(cp) {\n    return cp >= 48 && cp <= 57 || // 0..9\n    cp >= 65 && cp <= 70 || // A..F\n    cp >= 97 && cp <= 102;\n  },\n  isHexDigitChar(ch) {\n    return ch.length === 1 && Character.isHexDigit(ch.charCodeAt(0));\n  },\n  isOctalDigit(cp) {\n    return cp >= 48 && cp <= 55;\n  },\n  isOctalDigitChar(ch) {\n    return ch.length === 1 && Character.isOctalDigit(ch.charCodeAt(0));\n  }\n};\n\n// src/jsx-nodes.ts\nvar JSXClosingElement = class {\n  type;\n  name;\n  constructor(name) {\n    this.type = \"JSXClosingElement\" /* JSXClosingElement */;\n    this.name = name;\n  }\n};\nvar JSXClosingFragment = class {\n  type;\n  constructor() {\n    this.type = \"JSXClosingFragment\" /* JSXClosingFragment */;\n  }\n};\nvar JSXElement = class {\n  type;\n  openingElement;\n  children;\n  closingElement;\n  constructor(openingElement, children, closingElement) {\n    this.type = \"JSXElement\" /* JSXElement */;\n    this.openingElement = openingElement;\n    this.children = children;\n    this.closingElement = closingElement;\n  }\n};\nvar JSXEmptyExpression = class {\n  type;\n  constructor() {\n    this.type = \"JSXEmptyExpression\" /* JSXEmptyExpression */;\n  }\n};\nvar JSXExpressionContainer = class {\n  type;\n  expression;\n  constructor(expression) {\n    this.type = \"JSXExpressionContainer\" /* JSXExpressionContainer */;\n    this.expression = expression;\n  }\n};\nvar JSXIdentifier = class {\n  type;\n  name;\n  constructor(name) {\n    this.type = \"JSXIdentifier\" /* JSXIdentifier */;\n    this.name = name;\n  }\n};\nvar JSXMemberExpression = class {\n  type;\n  object;\n  property;\n  constructor(object, property) {\n    this.type = \"JSXMemberExpression\" /* JSXMemberExpression */;\n    this.object = object;\n    this.property = property;\n  }\n};\nvar JSXAttribute = class {\n  type;\n  name;\n  value;\n  constructor(name, value) {\n    this.type = \"JSXAttribute\" /* JSXAttribute */;\n    this.name = name;\n    this.value = value;\n  }\n};\nvar JSXNamespacedName = class {\n  type;\n  namespace;\n  name;\n  constructor(namespace, name) {\n    this.type = \"JSXNamespacedName\" /* JSXNamespacedName */;\n    this.namespace = namespace;\n    this.name = name;\n  }\n};\nvar JSXOpeningElement = class {\n  type;\n  name;\n  selfClosing;\n  attributes;\n  constructor(name, selfClosing, attributes) {\n    this.type = \"JSXOpeningElement\" /* JSXOpeningElement */;\n    this.name = name;\n    this.selfClosing = selfClosing;\n    this.attributes = attributes;\n  }\n};\nvar JSXOpeningFragment = class {\n  type;\n  selfClosing;\n  constructor(selfClosing) {\n    this.type = \"JSXOpeningFragment\" /* JSXOpeningFragment */;\n    this.selfClosing = selfClosing;\n  }\n};\nvar JSXSpreadAttribute = class {\n  type;\n  argument;\n  constructor(argument) {\n    this.type = \"JSXSpreadAttribute\" /* JSXSpreadAttribute */;\n    this.argument = argument;\n  }\n};\nvar JSXText = class {\n  type;\n  value;\n  raw;\n  constructor(value, raw) {\n    this.type = \"JSXText\" /* JSXText */;\n    this.value = value;\n    this.raw = raw;\n  }\n};\n\n// src/nodes.ts\nvar nodes_exports = {};\n__export(nodes_exports, {\n  ArrayExpression: () => ArrayExpression,\n  ArrayPattern: () => ArrayPattern,\n  ArrowFunctionExpression: () => ArrowFunctionExpression,\n  AssignmentExpression: () => AssignmentExpression,\n  AssignmentPattern: () => AssignmentPattern,\n  AsyncFunctionDeclaration: () => AsyncFunctionDeclaration,\n  AwaitExpression: () => AwaitExpression,\n  BigIntLiteral: () => BigIntLiteral,\n  BinaryExpression: () => BinaryExpression,\n  BlockStatement: () => BlockStatement,\n  BreakStatement: () => BreakStatement,\n  CallExpression: () => CallExpression,\n  CatchClause: () => CatchClause,\n  ChainExpression: () => ChainExpression,\n  ClassBody: () => ClassBody,\n  ClassDeclaration: () => ClassDeclaration,\n  ClassExpression: () => ClassExpression,\n  ConditionalExpression: () => ConditionalExpression,\n  ContinueStatement: () => ContinueStatement,\n  DebuggerStatement: () => DebuggerStatement,\n  Decorator: () => Decorator,\n  Directive: () => Directive,\n  DoWhileStatement: () => DoWhileStatement,\n  EmptyStatement: () => EmptyStatement,\n  ExportAllDeclaration: () => ExportAllDeclaration,\n  ExportDefaultDeclaration: () => ExportDefaultDeclaration,\n  ExportNamedDeclaration: () => ExportNamedDeclaration,\n  ExportSpecifier: () => ExportSpecifier,\n  ExpressionStatement: () => ExpressionStatement,\n  ForInStatement: () => ForInStatement,\n  ForOfStatement: () => ForOfStatement,\n  ForStatement: () => ForStatement,\n  FunctionDeclaration: () => FunctionDeclaration,\n  FunctionExpression: () => FunctionExpression,\n  Identifier: () => Identifier,\n  IfStatement: () => IfStatement,\n  ImportAttribute: () => ImportAttribute,\n  ImportDeclaration: () => ImportDeclaration,\n  ImportDefaultSpecifier: () => ImportDefaultSpecifier,\n  ImportExpression: () => ImportExpression,\n  ImportNamespaceSpecifier: () => ImportNamespaceSpecifier,\n  ImportSpecifier: () => ImportSpecifier,\n  LabeledStatement: () => LabeledStatement,\n  Literal: () => Literal,\n  LogicalExpression: () => LogicalExpression,\n  MemberExpression: () => MemberExpression,\n  MetaProperty: () => MetaProperty,\n  MethodDefinition: () => MethodDefinition,\n  Module: () => Module,\n  NewExpression: () => NewExpression,\n  ObjectExpression: () => ObjectExpression,\n  ObjectPattern: () => ObjectPattern,\n  PrivateIdentifier: () => PrivateIdentifier,\n  Program: () => Program,\n  Property: () => Property,\n  PropertyDefinition: () => PropertyDefinition,\n  RegexLiteral: () => RegexLiteral,\n  RestElement: () => RestElement,\n  ReturnStatement: () => ReturnStatement,\n  Script: () => Script,\n  SequenceExpression: () => SequenceExpression,\n  SpreadElement: () => SpreadElement,\n  StaticBlock: () => StaticBlock,\n  Super: () => Super,\n  SwitchCase: () => SwitchCase,\n  SwitchStatement: () => SwitchStatement,\n  TaggedTemplateExpression: () => TaggedTemplateExpression,\n  TemplateElement: () => TemplateElement,\n  TemplateLiteral: () => TemplateLiteral,\n  ThisExpression: () => ThisExpression,\n  ThrowStatement: () => ThrowStatement,\n  TryStatement: () => TryStatement,\n  UnaryExpression: () => UnaryExpression,\n  UpdateExpression: () => UpdateExpression,\n  VariableDeclaration: () => VariableDeclaration,\n  VariableDeclarator: () => VariableDeclarator,\n  WhileStatement: () => WhileStatement,\n  WithStatement: () => WithStatement,\n  YieldExpression: () => YieldExpression\n});\nvar ArrayExpression = class {\n  type;\n  elements;\n  constructor(elements) {\n    this.type = \"ArrayExpression\" /* ArrayExpression */;\n    this.elements = elements;\n  }\n};\nvar ArrayPattern = class {\n  type;\n  elements;\n  constructor(elements) {\n    this.type = \"ArrayPattern\" /* ArrayPattern */;\n    this.elements = elements;\n  }\n};\nvar ArrowFunctionExpression = class {\n  type;\n  id;\n  params;\n  body;\n  generator;\n  expression;\n  async;\n  constructor(params, body, expression, isAsync) {\n    this.type = \"ArrowFunctionExpression\" /* ArrowFunctionExpression */;\n    this.id = null;\n    this.params = params;\n    this.body = body;\n    this.generator = false;\n    this.expression = expression;\n    this.async = isAsync;\n  }\n};\nvar AssignmentExpression = class {\n  type;\n  operator;\n  left;\n  right;\n  constructor(operator, left, right) {\n    this.type = \"AssignmentExpression\" /* AssignmentExpression */;\n    this.operator = operator;\n    this.left = left;\n    this.right = right;\n  }\n};\nvar AssignmentPattern = class {\n  type;\n  left;\n  right;\n  constructor(left, right) {\n    this.type = \"AssignmentPattern\" /* AssignmentPattern */;\n    this.left = left;\n    this.right = right;\n  }\n};\nvar AsyncFunctionDeclaration = class {\n  type;\n  id;\n  params;\n  body;\n  generator;\n  expression;\n  async;\n  constructor(id, params, body, generator) {\n    this.type = \"FunctionDeclaration\" /* FunctionDeclaration */;\n    this.id = id;\n    this.params = params;\n    this.body = body;\n    this.generator = generator;\n    this.expression = false;\n    this.async = true;\n  }\n};\nvar AwaitExpression = class {\n  type;\n  argument;\n  constructor(argument) {\n    this.type = \"AwaitExpression\" /* AwaitExpression */;\n    this.argument = argument;\n  }\n};\nvar BigIntLiteral = class {\n  type;\n  value;\n  raw;\n  bigint;\n  constructor(value, raw, bigint) {\n    this.type = \"Literal\" /* Literal */;\n    this.value = value;\n    this.raw = raw;\n    this.bigint = bigint;\n  }\n};\nvar BinaryExpression = class {\n  type;\n  operator;\n  left;\n  right;\n  constructor(operator, left, right) {\n    this.type = \"BinaryExpression\" /* BinaryExpression */;\n    this.operator = operator;\n    this.left = left;\n    this.right = right;\n  }\n};\nvar BlockStatement = class {\n  type;\n  body;\n  constructor(body) {\n    this.type = \"BlockStatement\" /* BlockStatement */;\n    this.body = body;\n  }\n};\nvar BreakStatement = class {\n  type;\n  label;\n  constructor(label) {\n    this.type = \"BreakStatement\" /* BreakStatement */;\n    this.label = label;\n  }\n};\nvar CallExpression = class {\n  type;\n  callee;\n  arguments;\n  optional;\n  constructor(callee, args, optional) {\n    this.type = \"CallExpression\" /* CallExpression */;\n    this.callee = callee;\n    this.arguments = args;\n    this.optional = optional;\n  }\n};\nvar CatchClause = class {\n  type;\n  param;\n  body;\n  constructor(param, body) {\n    this.type = \"CatchClause\" /* CatchClause */;\n    this.param = param;\n    this.body = body;\n  }\n};\nvar ChainExpression = class {\n  type;\n  expression;\n  constructor(expression) {\n    this.type = \"ChainExpression\" /* ChainExpression */;\n    this.expression = expression;\n  }\n};\nvar ClassBody = class {\n  type;\n  body;\n  constructor(body) {\n    this.type = \"ClassBody\" /* ClassBody */;\n    this.body = body;\n  }\n};\nvar ClassDeclaration = class {\n  type;\n  id;\n  superClass;\n  body;\n  decorators;\n  constructor(id, superClass, body, decorators) {\n    this.type = \"ClassDeclaration\" /* ClassDeclaration */;\n    this.id = id;\n    this.superClass = superClass;\n    this.body = body;\n    this.decorators = decorators;\n  }\n};\nvar ClassExpression = class {\n  type;\n  id;\n  superClass;\n  body;\n  decorators;\n  constructor(id, superClass, body, decorators) {\n    this.type = \"ClassExpression\" /* ClassExpression */;\n    this.id = id;\n    this.superClass = superClass;\n    this.body = body;\n    this.decorators = decorators;\n  }\n};\nvar ConditionalExpression = class {\n  type;\n  test;\n  consequent;\n  alternate;\n  constructor(test, consequent, alternate) {\n    this.type = \"ConditionalExpression\" /* ConditionalExpression */;\n    this.test = test;\n    this.consequent = consequent;\n    this.alternate = alternate;\n  }\n};\nvar ContinueStatement = class {\n  type;\n  label;\n  constructor(label) {\n    this.type = \"ContinueStatement\" /* ContinueStatement */;\n    this.label = label;\n  }\n};\nvar DebuggerStatement = class {\n  type;\n  constructor() {\n    this.type = \"DebuggerStatement\" /* DebuggerStatement */;\n  }\n};\nvar Decorator = class {\n  type;\n  expression;\n  constructor(expression) {\n    this.type = \"Decorator\" /* Decorator */;\n    this.expression = expression;\n  }\n};\nvar Directive = class {\n  type;\n  expression;\n  directive;\n  constructor(expression, directive) {\n    this.type = \"ExpressionStatement\" /* ExpressionStatement */;\n    this.expression = expression;\n    this.directive = directive;\n  }\n};\nvar DoWhileStatement = class {\n  type;\n  body;\n  test;\n  constructor(body, test) {\n    this.type = \"DoWhileStatement\" /* DoWhileStatement */;\n    this.body = body;\n    this.test = test;\n  }\n};\nvar EmptyStatement = class {\n  type;\n  constructor() {\n    this.type = \"EmptyStatement\" /* EmptyStatement */;\n  }\n};\nvar ExportAllDeclaration = class {\n  type;\n  source;\n  exported;\n  assertions;\n  constructor(source, exported, assertions) {\n    this.type = \"ExportAllDeclaration\" /* ExportAllDeclaration */;\n    this.source = source;\n    this.exported = exported;\n    this.assertions = assertions;\n  }\n};\nvar ExportDefaultDeclaration = class {\n  type;\n  declaration;\n  constructor(declaration) {\n    this.type = \"ExportDefaultDeclaration\" /* ExportDefaultDeclaration */;\n    this.declaration = declaration;\n  }\n};\nvar ExportNamedDeclaration = class {\n  type;\n  declaration;\n  specifiers;\n  source;\n  assertions;\n  constructor(declaration, specifiers, source, assertions) {\n    this.type = \"ExportNamedDeclaration\" /* ExportNamedDeclaration */;\n    this.declaration = declaration;\n    this.specifiers = specifiers;\n    this.source = source;\n    this.assertions = assertions;\n  }\n};\nvar ExportSpecifier = class {\n  type;\n  exported;\n  local;\n  constructor(local, exported) {\n    this.type = \"ExportSpecifier\" /* ExportSpecifier */;\n    this.exported = exported;\n    this.local = local;\n  }\n};\nvar ExpressionStatement = class {\n  type;\n  expression;\n  constructor(expression) {\n    this.type = \"ExpressionStatement\" /* ExpressionStatement */;\n    this.expression = expression;\n  }\n};\nvar ForInStatement = class {\n  type;\n  left;\n  right;\n  body;\n  each;\n  constructor(left, right, body) {\n    this.type = \"ForInStatement\" /* ForInStatement */;\n    this.left = left;\n    this.right = right;\n    this.body = body;\n    this.each = false;\n  }\n};\nvar ForOfStatement = class {\n  type;\n  await;\n  left;\n  right;\n  body;\n  constructor(left, right, body, _await) {\n    this.type = \"ForOfStatement\" /* ForOfStatement */;\n    this.await = _await;\n    this.left = left;\n    this.right = right;\n    this.body = body;\n  }\n};\nvar ForStatement = class {\n  type;\n  init;\n  test;\n  update;\n  body;\n  constructor(init, test, update, body) {\n    this.type = \"ForStatement\" /* ForStatement */;\n    this.init = init;\n    this.test = test;\n    this.update = update;\n    this.body = body;\n  }\n};\nvar FunctionDeclaration = class {\n  type;\n  id;\n  params;\n  body;\n  generator;\n  expression;\n  async;\n  constructor(id, params, body, generator) {\n    this.type = \"FunctionDeclaration\" /* FunctionDeclaration */;\n    this.id = id;\n    this.params = params;\n    this.body = body;\n    this.generator = generator;\n    this.expression = false;\n    this.async = false;\n  }\n};\nvar FunctionExpression = class {\n  type;\n  id;\n  params;\n  body;\n  generator;\n  expression;\n  async;\n  constructor(id, params, body, generator, isAsync) {\n    this.type = \"FunctionExpression\" /* FunctionExpression */;\n    this.id = id;\n    this.params = params;\n    this.body = body;\n    this.generator = generator;\n    this.expression = false;\n    this.async = isAsync;\n  }\n};\nvar Identifier = class {\n  type;\n  name;\n  constructor(name) {\n    this.type = \"Identifier\" /* Identifier */;\n    this.name = name;\n  }\n};\nvar IfStatement = class {\n  type;\n  test;\n  consequent;\n  alternate;\n  constructor(test, consequent, alternate) {\n    this.type = \"IfStatement\" /* IfStatement */;\n    this.test = test;\n    this.consequent = consequent;\n    this.alternate = alternate;\n  }\n};\nvar ImportAttribute = class {\n  type;\n  key;\n  value;\n  constructor(key, value) {\n    this.type = \"ImportAttribute\" /* ImportAttribute */;\n    this.key = key;\n    this.value = value;\n  }\n};\nvar ImportExpression = class {\n  type;\n  source;\n  attributes;\n  constructor(source, attributes) {\n    this.type = \"ImportExpression\" /* ImportExpression */;\n    this.source = source;\n    this.attributes = attributes;\n  }\n};\nvar ImportDeclaration = class {\n  type;\n  specifiers;\n  source;\n  assertions;\n  constructor(specifiers, source, assertions) {\n    this.type = \"ImportDeclaration\" /* ImportDeclaration */;\n    this.specifiers = specifiers;\n    this.source = source;\n    this.assertions = assertions;\n  }\n};\nvar ImportDefaultSpecifier = class {\n  type;\n  local;\n  constructor(local) {\n    this.type = \"ImportDefaultSpecifier\" /* ImportDefaultSpecifier */;\n    this.local = local;\n  }\n};\nvar ImportNamespaceSpecifier = class {\n  type;\n  local;\n  constructor(local) {\n    this.type = \"ImportNamespaceSpecifier\" /* ImportNamespaceSpecifier */;\n    this.local = local;\n  }\n};\nvar ImportSpecifier = class {\n  type;\n  local;\n  imported;\n  constructor(local, imported) {\n    this.type = \"ImportSpecifier\" /* ImportSpecifier */;\n    this.local = local;\n    this.imported = imported;\n  }\n};\nvar LabeledStatement = class {\n  type;\n  label;\n  body;\n  constructor(label, body) {\n    this.type = \"LabeledStatement\" /* LabeledStatement */;\n    this.label = label;\n    this.body = body;\n  }\n};\nvar Literal = class {\n  type;\n  value;\n  raw;\n  constructor(value, raw) {\n    this.type = \"Literal\" /* Literal */;\n    this.value = value;\n    this.raw = raw;\n  }\n};\nvar LogicalExpression = class {\n  type;\n  operator;\n  left;\n  right;\n  constructor(operator, left, right) {\n    this.type = \"LogicalExpression\" /* LogicalExpression */;\n    this.operator = operator;\n    this.left = left;\n    this.right = right;\n  }\n};\nvar MemberExpression = class {\n  type;\n  computed;\n  object;\n  property;\n  optional;\n  constructor(computed, object, property, optional) {\n    this.type = \"MemberExpression\" /* MemberExpression */;\n    this.computed = computed;\n    this.object = object;\n    this.property = property;\n    this.optional = optional;\n  }\n};\nvar MetaProperty = class {\n  type;\n  meta;\n  property;\n  constructor(meta, property) {\n    this.type = \"MetaProperty\" /* MetaProperty */;\n    this.meta = meta;\n    this.property = property;\n  }\n};\nvar MethodDefinition = class {\n  type;\n  key;\n  computed;\n  value;\n  kind;\n  static;\n  decorators;\n  constructor(key, computed, value, kind, isStatic, decorators) {\n    this.type = \"MethodDefinition\" /* MethodDefinition */;\n    this.key = key;\n    this.computed = computed;\n    this.value = value;\n    this.kind = kind;\n    this.static = isStatic;\n    this.decorators = decorators;\n  }\n};\nvar Module = class {\n  type;\n  body;\n  sourceType;\n  constructor(body) {\n    this.type = \"Program\" /* Program */;\n    this.body = body;\n    this.sourceType = \"module\";\n  }\n};\nvar NewExpression = class {\n  type;\n  callee;\n  arguments;\n  constructor(callee, args) {\n    this.type = \"NewExpression\" /* NewExpression */;\n    this.callee = callee;\n    this.arguments = args;\n  }\n};\nvar ObjectExpression = class {\n  type;\n  properties;\n  constructor(properties) {\n    this.type = \"ObjectExpression\" /* ObjectExpression */;\n    this.properties = properties;\n  }\n};\nvar ObjectPattern = class {\n  type;\n  properties;\n  constructor(properties) {\n    this.type = \"ObjectPattern\" /* ObjectPattern */;\n    this.properties = properties;\n  }\n};\nvar PrivateIdentifier = class {\n  type;\n  name;\n  constructor(name) {\n    this.type = \"PrivateIdentifier\" /* PrivateIdentifier */;\n    this.name = name;\n  }\n};\nvar Program = class {\n  type;\n  body;\n  sourceType;\n  constructor(sourceType, body) {\n    this.type = \"Program\" /* Program */;\n    this.sourceType = sourceType;\n    this.body = body;\n  }\n};\nvar Property = class {\n  type;\n  key;\n  computed;\n  value;\n  kind;\n  method;\n  shorthand;\n  constructor(kind, key, computed, value, method, shorthand) {\n    this.type = \"Property\" /* Property */;\n    this.key = key;\n    this.computed = computed;\n    this.value = value;\n    this.kind = kind;\n    this.method = method;\n    this.shorthand = shorthand;\n  }\n};\nvar PropertyDefinition = class {\n  type;\n  key;\n  computed;\n  value;\n  static;\n  decorators;\n  constructor(key, computed, value, isStatic, decorators) {\n    this.type = \"Property\" /* Property */;\n    this.key = key;\n    this.computed = computed;\n    this.value = value;\n    this.static = isStatic;\n    this.decorators = decorators;\n  }\n};\nvar RegexLiteral = class {\n  type;\n  value;\n  raw;\n  regex;\n  constructor(value, raw, pattern, flags) {\n    this.type = \"Literal\" /* Literal */;\n    this.value = value;\n    this.raw = raw;\n    this.regex = { pattern, flags };\n  }\n};\nvar RestElement = class {\n  type;\n  argument;\n  constructor(argument) {\n    this.type = \"RestElement\" /* RestElement */;\n    this.argument = argument;\n  }\n};\nvar ReturnStatement = class {\n  type;\n  argument;\n  constructor(argument) {\n    this.type = \"ReturnStatement\" /* ReturnStatement */;\n    this.argument = argument;\n  }\n};\nvar Script = class {\n  type;\n  body;\n  sourceType;\n  constructor(body) {\n    this.type = \"Program\" /* Program */;\n    this.body = body;\n    this.sourceType = \"script\";\n  }\n};\nvar SequenceExpression = class {\n  type;\n  expressions;\n  constructor(expressions) {\n    this.type = \"SequenceExpression\" /* SequenceExpression */;\n    this.expressions = expressions;\n  }\n};\nvar SpreadElement = class {\n  type;\n  argument;\n  constructor(argument) {\n    this.type = \"SpreadElement\" /* SpreadElement */;\n    this.argument = argument;\n  }\n};\nvar StaticBlock = class {\n  type;\n  body;\n  constructor(body) {\n    this.type = \"StaticBlock\" /* StaticBlock */;\n    this.body = body;\n  }\n};\nvar Super = class {\n  type;\n  constructor() {\n    this.type = \"Super\" /* Super */;\n  }\n};\nvar SwitchCase = class {\n  type;\n  test;\n  consequent;\n  constructor(test, consequent) {\n    this.type = \"SwitchCase\" /* SwitchCase */;\n    this.test = test;\n    this.consequent = consequent;\n  }\n};\nvar SwitchStatement = class {\n  type;\n  discriminant;\n  cases;\n  constructor(discriminant, cases) {\n    this.type = \"SwitchStatement\" /* SwitchStatement */;\n    this.discriminant = discriminant;\n    this.cases = cases;\n  }\n};\nvar TaggedTemplateExpression = class {\n  type;\n  tag;\n  quasi;\n  constructor(tag, quasi) {\n    this.type = \"TaggedTemplateExpression\" /* TaggedTemplateExpression */;\n    this.tag = tag;\n    this.quasi = quasi;\n  }\n};\nvar TemplateElement = class {\n  type;\n  value;\n  tail;\n  constructor(value, tail) {\n    this.type = \"TemplateElement\" /* TemplateElement */;\n    this.value = value;\n    this.tail = tail;\n  }\n};\nvar TemplateLiteral = class {\n  type;\n  quasis;\n  expressions;\n  constructor(quasis, expressions) {\n    this.type = \"TemplateLiteral\" /* TemplateLiteral */;\n    this.quasis = quasis;\n    this.expressions = expressions;\n  }\n};\nvar ThisExpression = class {\n  type;\n  constructor() {\n    this.type = \"ThisExpression\" /* ThisExpression */;\n  }\n};\nvar ThrowStatement = class {\n  type;\n  argument;\n  constructor(argument) {\n    this.type = \"ThrowStatement\" /* ThrowStatement */;\n    this.argument = argument;\n  }\n};\nvar TryStatement = class {\n  type;\n  block;\n  handler;\n  finalizer;\n  constructor(block, handler, finalizer) {\n    this.type = \"TryStatement\" /* TryStatement */;\n    this.block = block;\n    this.handler = handler;\n    this.finalizer = finalizer;\n  }\n};\nvar UnaryExpression = class {\n  type;\n  operator;\n  argument;\n  prefix;\n  constructor(operator, argument) {\n    this.type = \"UnaryExpression\" /* UnaryExpression */;\n    this.operator = operator;\n    this.argument = argument;\n    this.prefix = true;\n  }\n};\nvar UpdateExpression = class {\n  type;\n  operator;\n  argument;\n  prefix;\n  constructor(operator, argument, prefix) {\n    this.type = \"UpdateExpression\" /* UpdateExpression */;\n    this.operator = operator;\n    this.argument = argument;\n    this.prefix = prefix;\n  }\n};\nvar VariableDeclaration = class {\n  type;\n  declarations;\n  kind;\n  constructor(declarations, kind) {\n    this.type = \"VariableDeclaration\" /* VariableDeclaration */;\n    this.declarations = declarations;\n    this.kind = kind;\n  }\n};\nvar VariableDeclarator = class {\n  type;\n  id;\n  init;\n  constructor(id, init) {\n    this.type = \"VariableDeclarator\" /* VariableDeclarator */;\n    this.id = id;\n    this.init = init;\n  }\n};\nvar WhileStatement = class {\n  type;\n  test;\n  body;\n  constructor(test, body) {\n    this.type = \"WhileStatement\" /* WhileStatement */;\n    this.test = test;\n    this.body = body;\n  }\n};\nvar WithStatement = class {\n  type;\n  object;\n  body;\n  constructor(object, body) {\n    this.type = \"WithStatement\" /* WithStatement */;\n    this.object = object;\n    this.body = body;\n  }\n};\nvar YieldExpression = class {\n  type;\n  argument;\n  delegate;\n  constructor(argument, delegate) {\n    this.type = \"YieldExpression\" /* YieldExpression */;\n    this.argument = argument;\n    this.delegate = delegate;\n  }\n};\n\n// src/assert.ts\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(\"ASSERT: \" + message);\n  }\n}\n\n// src/error-handler.ts\nvar ErrorHandler = class {\n  errors;\n  tolerant;\n  constructor() {\n    this.errors = [];\n    this.tolerant = false;\n  }\n  recordError(error) {\n    this.errors.push(error);\n  }\n  tolerate(error) {\n    if (this.tolerant) {\n      this.recordError(error);\n    } else {\n      throw error;\n    }\n  }\n  constructError(msg, column) {\n    let error = new Error(msg);\n    try {\n      throw error;\n    } catch (base) {\n      if (Object.create && Object.defineProperty) {\n        error = Object.create(base);\n        Object.defineProperty(error, \"column\", { value: column });\n      }\n    }\n    return error;\n  }\n  createError(index, line, col, description) {\n    const msg = \"Line \" + line + \": \" + description;\n    const _error = this.constructError(msg, col);\n    _error.index = index;\n    _error.lineNumber = line;\n    _error.description = description;\n    const error = _error;\n    return error;\n  }\n  throwError(index, line, col, description) {\n    throw this.createError(index, line, col, description);\n  }\n  tolerateError(index, line, col, description) {\n    const error = this.createError(index, line, col, description);\n    if (this.tolerant) {\n      this.recordError(error);\n    } else {\n      throw error;\n    }\n  }\n};\n\n// src/messages.ts\nvar Messages = {\n  AsyncFunctionInSingleStatementContext: \"Async functions can only be declared at the top level or inside a block.\",\n  BadImportCallArity: \"Unexpected token\",\n  BadGetterArity: \"Getter must not have any formal parameters\",\n  BadSetterArity: \"Setter must have exactly one formal parameter\",\n  BadSetterRestParameter: \"Setter function argument must not be a rest parameter\",\n  CannotUseImportMetaOutsideAModule: \"Cannot use 'import.meta' outside a module\",\n  ConstructorIsAsync: \"Class constructor may not be an async method\",\n  ConstructorIsPrivate: \"Class constructor may not be a private method\",\n  ConstructorSpecialMethod: \"Class constructor may not be an accessor\",\n  DeclarationMissingInitializer: \"Missing initializer in %0 declaration\",\n  DefaultRestParameter: \"Unexpected token =\",\n  DefaultRestProperty: \"Unexpected token =\",\n  DuplicateBinding: \"Duplicate binding %0\",\n  DuplicateConstructor: \"A class may only have one constructor\",\n  DuplicateParameter: \"Duplicate parameter name not allowed in this context\",\n  DuplicateProtoProperty: \"Duplicate __proto__ fields are not allowed in object literals\",\n  ForInOfLoopInitializer: \"%0 loop variable declaration may not have an initializer\",\n  GeneratorInLegacyContext: \"Generator declarations are not allowed in legacy contexts\",\n  IllegalBreak: \"Illegal break statement\",\n  IllegalContinue: \"Illegal continue statement\",\n  IllegalExportDeclaration: \"Unexpected token\",\n  IllegalImportDeclaration: \"Unexpected token\",\n  IllegalLanguageModeDirective: \"Illegal 'use strict' directive in function with non-simple parameter list\",\n  IllegalReturn: \"Illegal return statement\",\n  InvalidEscapedReservedWord: \"Keyword must not contain escaped characters\",\n  InvalidHexEscapeSequence: \"Invalid hexadecimal escape sequence\",\n  InvalidLHSInAssignment: \"Invalid left-hand side in assignment\",\n  InvalidLHSInForIn: \"Invalid left-hand side in for-in\",\n  InvalidLHSInForLoop: \"Invalid left-hand side in for-loop\",\n  InvalidModuleSpecifier: \"Unexpected token\",\n  InvalidRegExp: \"Invalid regular expression\",\n  InvalidTaggedTemplateOnOptionalChain: \"Invalid tagged template on optional chain\",\n  InvalidUnicodeEscapeSequence: \"Invalid Unicode escape sequence\",\n  LetInLexicalBinding: \"let is disallowed as a lexically bound name\",\n  MissingFromClause: \"Unexpected token\",\n  MultipleDefaultsInSwitch: \"More than one default clause in switch statement\",\n  NewlineAfterThrow: \"Illegal newline after throw\",\n  NoAsAfterImportNamespace: \"Unexpected token\",\n  NoAsAndFromEscapeSequences: \"The `as` and `from` contextual keywords must not contain Unicode escape sequences.\",\n  NoCatchOrFinally: \"Missing catch or finally after try\",\n  NoSemicolonAfterDecorator: \"Decorators must not be followed by a semicolon.\",\n  NumericSeperatorOneUnderscore: \"Numeric separator must be exactly one underscore\",\n  NumericSeperatorNotAllowedHere: \"Numeric separator is not allowed here\",\n  ParameterAfterRestParameter: \"Rest parameter must be last formal parameter\",\n  PropertyAfterRestProperty: \"Unexpected token\",\n  Redeclaration: \"%0 '%1' has already been declared\",\n  StaticPrototype: \"Classes may not have static property named prototype\",\n  StrictCatchVariable: \"Catch variable may not be eval or arguments in strict mode\",\n  StrictDelete: \"Delete of an unqualified identifier in strict mode.\",\n  StrictFunction: \"In strict mode code, functions can only be declared at top level or inside a block\",\n  StrictFunctionName: \"Function name may not be eval or arguments in strict mode\",\n  StrictLHSAssignment: \"Assignment to eval or arguments is not allowed in strict mode\",\n  StrictLHSPostfix: \"Postfix increment/decrement may not have eval or arguments operand in strict mode\",\n  StrictLHSPrefix: \"Prefix increment/decrement may not have eval or arguments operand in strict mode\",\n  StrictModeWith: \"Strict mode code may not include a with statement\",\n  StrictOctalLiteral: \"Octal literals are not allowed in strict mode.\",\n  StrictParamName: \"Parameter name eval or arguments is not allowed in strict mode\",\n  StrictReservedWord: \"Use of future reserved word in strict mode\",\n  StrictVarName: \"Variable name may not be eval or arguments in strict mode\",\n  TemplateOctalLiteral: \"Octal literals are not allowed in template strings.\",\n  TemplateEscape89: \"\\\\8 and \\\\9 are not allowed in template strings.\",\n  UnexpectedEOS: \"Unexpected end of input\",\n  UnexpectedIdentifier: \"Unexpected identifier\",\n  UnexpectedNumber: \"Unexpected number\",\n  UnexpectedReserved: \"Unexpected reserved word\",\n  UnexpectedString: \"Unexpected string\",\n  UnexpectedSuper: \"'super' keyword unexpected here\",\n  UnexpectedTemplate: \"Unexpected quasi %0\",\n  UnexpectedToken: \"Unexpected token %0\",\n  UnexpectedTokenIllegal: \"Unexpected token ILLEGAL\",\n  UnknownLabel: \"Undefined label '%0'\",\n  UnterminatedRegExp: \"Invalid regular expression: missing /\"\n};\n\n// src/token.ts\nvar TokenName = {};\nTokenName[1 /* BooleanLiteral */] = \"Boolean\";\nTokenName[2 /* EOF */] = \"<end>\";\nTokenName[3 /* Identifier */] = \"Identifier\";\nTokenName[4 /* Keyword */] = \"Keyword\";\nTokenName[5 /* NullLiteral */] = \"Null\";\nTokenName[6 /* NumericLiteral */] = \"Numeric\";\nTokenName[7 /* Punctuator */] = \"Punctuator\";\nTokenName[8 /* StringLiteral */] = \"String\";\nTokenName[9 /* RegularExpression */] = \"RegularExpression\";\nTokenName[10 /* Template */] = \"Template\";\n\n// src/scanner.ts\nfunction hexValue(ch) {\n  return \"0123456789abcdef\".indexOf(ch.toLowerCase());\n}\nfunction octalValue(ch) {\n  return \"01234567\".indexOf(ch);\n}\nvar Scanner = class {\n  source;\n  errorHandler;\n  trackComment;\n  isModule;\n  index;\n  lineNumber;\n  lineStart;\n  curlyStack;\n  length;\n  constructor(code, handler) {\n    this.source = code;\n    this.errorHandler = handler;\n    this.trackComment = false;\n    this.isModule = false;\n    this.length = code.length;\n    this.index = 0;\n    this.lineNumber = code.length > 0 ? 1 : 0;\n    this.lineStart = 0;\n    this.curlyStack = [];\n  }\n  saveState() {\n    return {\n      index: this.index,\n      lineNumber: this.lineNumber,\n      lineStart: this.lineStart,\n      curlyStack: this.curlyStack.slice()\n    };\n  }\n  restoreState(state) {\n    this.index = state.index;\n    this.lineNumber = state.lineNumber;\n    this.lineStart = state.lineStart;\n    this.curlyStack = state.curlyStack;\n  }\n  eof() {\n    return this.index >= this.length;\n  }\n  throwUnexpectedToken(message = Messages.UnexpectedTokenIllegal) {\n    return this.errorHandler.throwError(\n      this.index,\n      this.lineNumber,\n      this.index - this.lineStart + 1,\n      message\n    );\n  }\n  tolerateUnexpectedToken(message = Messages.UnexpectedTokenIllegal) {\n    this.errorHandler.tolerateError(\n      this.index,\n      this.lineNumber,\n      this.index - this.lineStart + 1,\n      message\n    );\n  }\n  // https://tc39.github.io/ecma262/#sec-comments\n  skipSingleLineComment(offset) {\n    let comments = [];\n    let start, loc;\n    if (this.trackComment) {\n      comments = [];\n      start = this.index - offset;\n      loc = {\n        start: {\n          line: this.lineNumber,\n          column: this.index - this.lineStart - offset\n        },\n        end: {}\n      };\n    }\n    while (!this.eof()) {\n      const ch = this.source.charCodeAt(this.index);\n      ++this.index;\n      if (Character.isLineTerminator(ch)) {\n        if (this.trackComment) {\n          loc.end = {\n            line: this.lineNumber,\n            column: this.index - this.lineStart - 1\n          };\n          const entry = {\n            multiLine: false,\n            slice: [start + offset, this.index - 1],\n            range: [start, this.index - 1],\n            loc\n          };\n          comments.push(entry);\n        }\n        if (ch === 13 && this.source.charCodeAt(this.index) === 10) {\n          ++this.index;\n        }\n        ++this.lineNumber;\n        this.lineStart = this.index;\n        return comments;\n      }\n    }\n    if (this.trackComment) {\n      loc.end = {\n        line: this.lineNumber,\n        column: this.index - this.lineStart\n      };\n      const entry = {\n        multiLine: false,\n        slice: [start + offset, this.index],\n        range: [start, this.index],\n        loc\n      };\n      comments.push(entry);\n    }\n    return comments;\n  }\n  skipMultiLineComment() {\n    let comments = [];\n    let start, loc;\n    if (this.trackComment) {\n      comments = [];\n      start = this.index - 2;\n      loc = {\n        start: {\n          line: this.lineNumber,\n          column: this.index - this.lineStart - 2\n        },\n        end: {}\n      };\n    }\n    while (!this.eof()) {\n      const ch = this.source.charCodeAt(this.index);\n      if (Character.isLineTerminator(ch)) {\n        if (ch === 13 && this.source.charCodeAt(this.index + 1) === 10) {\n          ++this.index;\n        }\n        ++this.lineNumber;\n        ++this.index;\n        this.lineStart = this.index;\n      } else if (ch === 42) {\n        if (this.source.charCodeAt(this.index + 1) === 47) {\n          this.index += 2;\n          if (this.trackComment) {\n            loc.end = {\n              line: this.lineNumber,\n              column: this.index - this.lineStart\n            };\n            const entry = {\n              multiLine: true,\n              slice: [start + 2, this.index - 2],\n              range: [start, this.index],\n              loc\n            };\n            comments.push(entry);\n          }\n          return comments;\n        }\n        ++this.index;\n      } else {\n        ++this.index;\n      }\n    }\n    if (this.trackComment) {\n      loc.end = {\n        line: this.lineNumber,\n        column: this.index - this.lineStart\n      };\n      const entry = {\n        multiLine: true,\n        slice: [start + 2, this.index],\n        range: [start, this.index],\n        loc\n      };\n      comments.push(entry);\n    }\n    this.tolerateUnexpectedToken();\n    return comments;\n  }\n  scanComments() {\n    let comments;\n    if (this.trackComment) {\n      comments = [];\n    }\n    let start = this.index === 0;\n    while (!this.eof()) {\n      let ch = this.source.charCodeAt(this.index);\n      if (Character.isWhiteSpace(ch)) {\n        ++this.index;\n      } else if (Character.isLineTerminator(ch)) {\n        ++this.index;\n        if (ch === 13 && this.source.charCodeAt(this.index) === 10) {\n          ++this.index;\n        }\n        ++this.lineNumber;\n        this.lineStart = this.index;\n        start = true;\n      } else if (ch === 47) {\n        ch = this.source.charCodeAt(this.index + 1);\n        if (ch === 47) {\n          this.index += 2;\n          const comment = this.skipSingleLineComment(2);\n          if (this.trackComment) {\n            comments = comments.concat(comment);\n          }\n          start = true;\n        } else if (ch === 42) {\n          this.index += 2;\n          const comment = this.skipMultiLineComment();\n          if (this.trackComment) {\n            comments = comments.concat(comment);\n          }\n        } else {\n          break;\n        }\n      } else if (start && ch === 45) {\n        if (this.source.charCodeAt(this.index + 1) === 45 && this.source.charCodeAt(this.index + 2) === 62) {\n          this.index += 3;\n          const comment = this.skipSingleLineComment(3);\n          if (this.trackComment) {\n            comments = comments.concat(comment);\n          }\n        } else {\n          break;\n        }\n      } else if (ch === 60 && !this.isModule) {\n        if (this.source.slice(this.index + 1, this.index + 4) === \"!--\") {\n          this.index += 4;\n          const comment = this.skipSingleLineComment(4);\n          if (this.trackComment) {\n            comments = comments.concat(comment);\n          }\n        } else {\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n    return comments;\n  }\n  // https://tc39.github.io/ecma262/#sec-future-reserved-words\n  isFutureReservedWord(id) {\n    switch (id) {\n      case \"enum\":\n      case \"export\":\n      case \"import\":\n      case \"super\":\n        return true;\n      default:\n        return false;\n    }\n  }\n  isStrictModeReservedWord(id) {\n    switch (id) {\n      case \"implements\":\n      case \"interface\":\n      case \"package\":\n      case \"private\":\n      case \"protected\":\n      case \"public\":\n      case \"static\":\n      case \"yield\":\n      case \"let\":\n        return true;\n      default:\n        return false;\n    }\n  }\n  isRestrictedWord(id) {\n    return id === \"eval\" || id === \"arguments\";\n  }\n  // https://tc39.github.io/ecma262/#sec-keywords\n  isKeyword(id) {\n    switch (id.length) {\n      case 2:\n        return id === \"if\" || id === \"in\" || id === \"do\";\n      case 3:\n        return id === \"var\" || id === \"for\" || id === \"new\" || id === \"try\" || id === \"let\";\n      case 4:\n        return id === \"this\" || id === \"else\" || id === \"case\" || id === \"void\" || id === \"with\" || id === \"enum\";\n      case 5:\n        return id === \"while\" || id === \"break\" || id === \"catch\" || id === \"throw\" || id === \"const\" || id === \"yield\" || id === \"class\" || id === \"super\";\n      case 6:\n        return id === \"return\" || id === \"typeof\" || id === \"delete\" || id === \"switch\" || id === \"export\" || id === \"import\";\n      case 7:\n        return id === \"default\" || id === \"finally\" || id === \"extends\";\n      case 8:\n        return id === \"function\" || id === \"continue\" || id === \"debugger\";\n      case 10:\n        return id === \"instanceof\";\n      default:\n        return false;\n    }\n  }\n  codePointAt(i) {\n    let cp = this.source.charCodeAt(i);\n    if (cp >= 55296 && cp <= 56319) {\n      const second = this.source.charCodeAt(i + 1);\n      if (second >= 56320 && second <= 57343) {\n        const first = cp;\n        cp = (first - 55296) * 1024 + second - 56320 + 65536;\n      }\n    }\n    return cp;\n  }\n  scanHexEscape(prefix) {\n    const len = prefix === \"u\" ? 4 : 2;\n    let code = 0;\n    for (let i = 0; i < len; ++i) {\n      if (!this.eof() && Character.isHexDigit(this.source.charCodeAt(this.index))) {\n        code = code * 16 + hexValue(this.source[this.index++]);\n      } else {\n        return null;\n      }\n    }\n    return String.fromCharCode(code);\n  }\n  tryToScanUnicodeCodePointEscape() {\n    let ch = this.source[this.index];\n    let code = 0;\n    if (ch === \"}\") {\n      return null;\n    }\n    while (!this.eof()) {\n      ch = this.source[this.index++];\n      if (!Character.isHexDigit(ch.charCodeAt(0))) {\n        break;\n      }\n      code = code * 16 + hexValue(ch);\n    }\n    if (code > 1114111 || ch !== \"}\") {\n      return null;\n    }\n    return Character.fromCodePoint(code);\n  }\n  scanUnicodeCodePointEscape() {\n    const result = this.tryToScanUnicodeCodePointEscape();\n    if (result === null) {\n      return this.throwUnexpectedToken();\n    }\n    return result;\n  }\n  getIdentifier() {\n    const start = this.index++;\n    while (!this.eof()) {\n      const ch = this.source.charCodeAt(this.index);\n      if (ch === 92) {\n        this.index = start;\n        return this.getComplexIdentifier();\n      } else if (ch >= 55296 && ch < 57343) {\n        this.index = start;\n        return this.getComplexIdentifier();\n      }\n      if (Character.isIdentifierPart(ch)) {\n        ++this.index;\n      } else {\n        break;\n      }\n    }\n    return this.source.slice(start, this.index);\n  }\n  getComplexIdentifier() {\n    let cp = this.codePointAt(this.index);\n    let id = Character.fromCodePoint(cp);\n    this.index += id.length;\n    let ch;\n    if (cp === 92) {\n      if (this.source.charCodeAt(this.index) !== 117) {\n        this.throwUnexpectedToken();\n      }\n      ++this.index;\n      if (this.source[this.index] === \"{\") {\n        ++this.index;\n        ch = this.scanUnicodeCodePointEscape();\n      } else {\n        ch = this.scanHexEscape(\"u\");\n        if (ch === null || ch === \"\\\\\" || !Character.isIdentifierStart(ch.charCodeAt(0))) {\n          this.throwUnexpectedToken();\n        }\n      }\n      id = ch;\n    }\n    while (!this.eof()) {\n      cp = this.codePointAt(this.index);\n      if (!Character.isIdentifierPart(cp)) {\n        break;\n      }\n      ch = Character.fromCodePoint(cp);\n      id += ch;\n      this.index += ch.length;\n      if (cp === 92) {\n        id = id.substr(0, id.length - 1);\n        if (this.source.charCodeAt(this.index) !== 117) {\n          this.throwUnexpectedToken();\n        }\n        ++this.index;\n        if (this.source[this.index] === \"{\") {\n          ++this.index;\n          ch = this.scanUnicodeCodePointEscape();\n        } else {\n          ch = this.scanHexEscape(\"u\");\n          if (ch === null || ch === \"\\\\\" || !Character.isIdentifierPart(ch.charCodeAt(0))) {\n            this.throwUnexpectedToken();\n          }\n        }\n        id += ch;\n      }\n    }\n    return id;\n  }\n  octalToDecimal(ch) {\n    let octal = ch !== \"0\";\n    let code = octalValue(ch);\n    if (!this.eof() && Character.isOctalDigit(this.source.charCodeAt(this.index))) {\n      octal = true;\n      code = code * 8 + octalValue(this.source[this.index++]);\n      if (\"0123\".indexOf(ch) >= 0 && !this.eof() && Character.isOctalDigit(this.source.charCodeAt(this.index))) {\n        code = code * 8 + octalValue(this.source[this.index++]);\n      }\n    }\n    return {\n      code,\n      octal\n    };\n  }\n  // https://tc39.github.io/ecma262/#sec-names-and-keywords\n  scanIdentifier() {\n    let type;\n    const start = this.index;\n    const escaped = this.source.charCodeAt(start) === 92;\n    const id = escaped ? this.getComplexIdentifier() : this.getIdentifier();\n    if (id.length === 1) {\n      type = 3 /* Identifier */;\n    } else if (this.isKeyword(id)) {\n      type = 4 /* Keyword */;\n    } else if (id === \"null\") {\n      type = 5 /* NullLiteral */;\n    } else if (id === \"true\" || id === \"false\") {\n      type = 1 /* BooleanLiteral */;\n    } else {\n      type = 3 /* Identifier */;\n    }\n    if (type !== 3 /* Identifier */ && start + id.length !== this.index) {\n      const restore = this.index;\n      this.index = start;\n      this.tolerateUnexpectedToken(Messages.InvalidEscapedReservedWord);\n      this.index = restore;\n    }\n    return {\n      type,\n      value: id,\n      lineNumber: this.lineNumber,\n      lineStart: this.lineStart,\n      start,\n      end: this.index,\n      escaped\n    };\n  }\n  // https://tc39.github.io/ecma262/#sec-punctuators\n  scanPunctuator() {\n    const start = this.index;\n    let str = this.source[this.index];\n    switch (str) {\n      case \"(\":\n      case \"{\":\n        if (str === \"{\") {\n          this.curlyStack.push(\"{\");\n        }\n        ++this.index;\n        break;\n      case \".\":\n        ++this.index;\n        if (this.source[this.index] === \".\" && this.source[this.index + 1] === \".\") {\n          this.index += 2;\n          str = \"...\";\n        }\n        break;\n      case \"}\":\n        ++this.index;\n        this.curlyStack.pop();\n        break;\n      case \"?\":\n        ++this.index;\n        if (this.source[this.index] === \"?\") {\n          ++this.index;\n          if (this.source[this.index] === \"=\") {\n            ++this.index;\n            str = \"??=\";\n          } else {\n            str = \"??\";\n          }\n        }\n        if (this.source[this.index] === \".\" && !/^\\d$/.test(this.source[this.index + 1])) {\n          ++this.index;\n          str = \"?.\";\n        }\n        break;\n      case \"#\":\n      case \")\":\n      case \";\":\n      case \",\":\n      case \"[\":\n      case \"]\":\n      case \":\":\n      case \"~\":\n      case \"@\":\n        ++this.index;\n        break;\n      default:\n        str = this.source.substr(this.index, 4);\n        if (str === \">>>=\") {\n          this.index += 4;\n        } else {\n          str = str.substr(0, 3);\n          if (str === \"===\" || str === \"!==\" || str === \">>>\" || str === \"<<=\" || str === \">>=\" || str === \"**=\" || str === \"&&=\" || str === \"||=\") {\n            this.index += 3;\n          } else {\n            str = str.substr(0, 2);\n            if (str === \"&&\" || str === \"||\" || str === \"==\" || str === \"!=\" || str === \"+=\" || str === \"-=\" || str === \"*=\" || str === \"/=\" || str === \"++\" || str === \"--\" || str === \"<<\" || str === \">>\" || str === \"&=\" || str === \"|=\" || str === \"^=\" || str === \"%=\" || str === \"<=\" || str === \">=\" || str === \"=>\" || str === \"**\") {\n              this.index += 2;\n            } else {\n              str = this.source[this.index];\n              if (\"<>=!+-*%&|^/\".indexOf(str) >= 0) {\n                ++this.index;\n              }\n            }\n          }\n        }\n    }\n    if (this.index === start) {\n      this.throwUnexpectedToken();\n    }\n    return {\n      type: 7 /* Punctuator */,\n      value: str,\n      lineNumber: this.lineNumber,\n      lineStart: this.lineStart,\n      start,\n      end: this.index\n    };\n  }\n  // https://tc39.github.io/ecma262/#sec-literals-numeric-literals\n  scanHexLiteral(start) {\n    let num = this.scanLiteralPart(Character.isHexDigitChar);\n    if (num.length === 0) {\n      this.throwUnexpectedToken();\n    }\n    if (this.source[this.index] === \"n\") {\n      this.index++;\n      return {\n        type: 6 /* NumericLiteral */,\n        value: BigInt(\"0x\" + num),\n        lineNumber: this.lineNumber,\n        lineStart: this.lineStart,\n        start,\n        end: this.index\n      };\n    }\n    if (Character.isIdentifierStart(this.source.charCodeAt(this.index))) {\n      this.throwUnexpectedToken();\n    }\n    return {\n      type: 6 /* NumericLiteral */,\n      value: parseInt(\"0x\" + num, 16),\n      lineNumber: this.lineNumber,\n      lineStart: this.lineStart,\n      start,\n      end: this.index\n    };\n  }\n  scanBinaryLiteral(start) {\n    let ch;\n    let num = this.scanLiteralPart((c) => c === \"0\" || c === \"1\");\n    if (num.length === 0) {\n      this.throwUnexpectedToken();\n    }\n    if (this.source[this.index] === \"n\") {\n      this.index++;\n      return {\n        type: 6 /* NumericLiteral */,\n        value: BigInt(\"0b\" + num),\n        lineNumber: this.lineNumber,\n        lineStart: this.lineStart,\n        start,\n        end: this.index\n      };\n    }\n    if (!this.eof()) {\n      ch = this.source.charCodeAt(this.index);\n      if (Character.isIdentifierStart(ch) || Character.isDecimalDigit(ch)) {\n        this.throwUnexpectedToken();\n      }\n    }\n    return {\n      type: 6 /* NumericLiteral */,\n      value: parseInt(num, 2),\n      lineNumber: this.lineNumber,\n      lineStart: this.lineStart,\n      start,\n      end: this.index\n    };\n  }\n  scanOctalLiteral(prefix, start) {\n    let num = \"\";\n    let octal = false;\n    if (Character.isOctalDigit(prefix.charCodeAt(0))) {\n      octal = true;\n      num = \"0\" + this.source[this.index++];\n    } else {\n      ++this.index;\n    }\n    num += this.scanLiteralPart(Character.isOctalDigitChar);\n    if (!octal && num.length === 0) {\n      this.throwUnexpectedToken();\n    }\n    if (this.source[this.index] === \"n\") {\n      this.index++;\n      return {\n        type: 6 /* NumericLiteral */,\n        value: BigInt(\"0o\" + num),\n        lineNumber: this.lineNumber,\n        lineStart: this.lineStart,\n        start,\n        end: this.index\n      };\n    }\n    if (Character.isIdentifierStart(this.source.charCodeAt(this.index)) || Character.isDecimalDigit(this.source.charCodeAt(this.index))) {\n      this.throwUnexpectedToken();\n    }\n    return {\n      type: 6 /* NumericLiteral */,\n      value: parseInt(num, 8),\n      octal,\n      lineNumber: this.lineNumber,\n      lineStart: this.lineStart,\n      start,\n      end: this.index\n    };\n  }\n  isImplicitOctalLiteral() {\n    for (let i = this.index + 1; i < this.length; ++i) {\n      const ch = this.source[i];\n      if (ch === \"8\" || ch === \"9\" || ch === \"n\") {\n        return false;\n      }\n      if (!Character.isOctalDigit(ch.charCodeAt(0))) {\n        return true;\n      }\n    }\n    return true;\n  }\n  scanLiteralPart(check) {\n    let num = \"\";\n    if (this.source[this.index] === \"_\")\n      this.throwUnexpectedToken(Messages.NumericSeperatorNotAllowedHere);\n    while (this.source[this.index] && (check(this.source[this.index]) || this.source[this.index] === \"_\")) {\n      if (this.source[this.index] !== \"_\")\n        num += this.source[this.index];\n      this.index++;\n      if (this.source[this.index - 1] === \"_\" && this.source[this.index] === \"_\")\n        this.throwUnexpectedToken(Messages.NumericSeperatorOneUnderscore);\n    }\n    if (this.source[this.index - 1] === \"_\")\n      this.throwUnexpectedToken(Messages.NumericSeperatorNotAllowedHere);\n    return num;\n  }\n  scanNumericLiteral() {\n    const start = this.index;\n    let ch = this.source[start];\n    assert(\n      Character.isDecimalDigit(ch.charCodeAt(0)) || ch === \".\",\n      \"Numeric literal must start with a decimal digit or a decimal point\"\n    );\n    let num = \"\";\n    if (ch !== \".\") {\n      num = this.source[this.index++];\n      ch = this.source[this.index];\n      if (num === \"0\") {\n        if (ch === \"x\" || ch === \"X\") {\n          ++this.index;\n          return this.scanHexLiteral(start);\n        }\n        if (ch === \"b\" || ch === \"B\") {\n          ++this.index;\n          return this.scanBinaryLiteral(start);\n        }\n        if (ch === \"o\" || ch === \"O\") {\n          return this.scanOctalLiteral(ch, start);\n        }\n        if (ch && Character.isOctalDigit(ch.charCodeAt(0))) {\n          if (this.isImplicitOctalLiteral()) {\n            return this.scanOctalLiteral(ch, start);\n          }\n        }\n      }\n      this.index--;\n      num = this.scanLiteralPart(Character.isDecimalDigitChar);\n      ch = this.source[this.index];\n    }\n    if (ch === \".\") {\n      num += this.source[this.index++];\n      num += this.scanLiteralPart(Character.isDecimalDigitChar);\n      ch = this.source[this.index];\n    }\n    if (ch === \"e\" || ch === \"E\") {\n      num += this.source[this.index++];\n      ch = this.source[this.index];\n      if (ch === \"+\" || ch === \"-\") {\n        num += this.source[this.index++];\n      }\n      if (Character.isDecimalDigit(this.source.charCodeAt(this.index))) {\n        num += this.scanLiteralPart(Character.isDecimalDigitChar);\n      } else {\n        this.throwUnexpectedToken();\n      }\n    } else if (ch === \"n\") {\n      if (num.length > 1 && num[0] === \"0\") {\n        this.throwUnexpectedToken();\n      }\n      this.index++;\n      return {\n        type: 6 /* NumericLiteral */,\n        value: BigInt(num),\n        lineNumber: this.lineNumber,\n        lineStart: this.lineStart,\n        start,\n        end: this.index\n      };\n    }\n    if (Character.isIdentifierStart(this.source.charCodeAt(this.index))) {\n      this.throwUnexpectedToken();\n    }\n    return {\n      type: 6 /* NumericLiteral */,\n      value: parseFloat(num),\n      lineNumber: this.lineNumber,\n      lineStart: this.lineStart,\n      start,\n      end: this.index\n    };\n  }\n  // https://tc39.github.io/ecma262/#sec-literals-string-literals\n  scanStringLiteral() {\n    const start = this.index;\n    let quote = this.source[start];\n    assert(\n      quote === \"'\" || quote === '\"',\n      \"String literal must starts with a quote\"\n    );\n    ++this.index;\n    let octal = false;\n    let str = \"\";\n    while (!this.eof()) {\n      let ch = this.source[this.index++];\n      if (ch === quote) {\n        quote = \"\";\n        break;\n      } else if (ch === \"\\\\\") {\n        ch = this.source[this.index++];\n        if (!ch || !Character.isLineTerminator(ch.charCodeAt(0))) {\n          switch (ch) {\n            case \"u\":\n              if (this.source[this.index] === \"{\") {\n                ++this.index;\n                str += this.scanUnicodeCodePointEscape();\n              } else {\n                const unescapedChar = this.scanHexEscape(ch);\n                if (unescapedChar === null) {\n                  this.throwUnexpectedToken();\n                }\n                str += unescapedChar;\n              }\n              break;\n            case \"x\":\n              const unescaped = this.scanHexEscape(ch);\n              if (unescaped === null) {\n                this.throwUnexpectedToken(Messages.InvalidHexEscapeSequence);\n              }\n              str += unescaped;\n              break;\n            case \"n\":\n              str += \"\\n\";\n              break;\n            case \"r\":\n              str += \"\\r\";\n              break;\n            case \"t\":\n              str += \"\t\";\n              break;\n            case \"b\":\n              str += \"\\b\";\n              break;\n            case \"f\":\n              str += \"\\f\";\n              break;\n            case \"v\":\n              str += \"\\v\";\n              break;\n            case \"8\":\n            case \"9\":\n              str += ch;\n              this.tolerateUnexpectedToken();\n              break;\n            default:\n              if (ch && Character.isOctalDigit(ch.charCodeAt(0))) {\n                const octToDec = this.octalToDecimal(ch);\n                octal = octToDec.octal || octal;\n                str += String.fromCharCode(octToDec.code);\n              } else {\n                str += ch;\n              }\n              break;\n          }\n        } else {\n          ++this.lineNumber;\n          if (ch === \"\\r\" && this.source[this.index] === \"\\n\") {\n            ++this.index;\n          }\n          this.lineStart = this.index;\n        }\n      } else if (Character.isLineTerminator(ch.charCodeAt(0))) {\n        break;\n      } else {\n        str += ch;\n      }\n    }\n    if (quote !== \"\") {\n      this.index = start;\n      this.throwUnexpectedToken();\n    }\n    return {\n      type: 8 /* StringLiteral */,\n      value: str,\n      octal,\n      lineNumber: this.lineNumber,\n      lineStart: this.lineStart,\n      start,\n      end: this.index\n    };\n  }\n  // https://tc39.github.io/ecma262/#sec-template-literal-lexical-components\n  scanTemplate() {\n    let cooked = \"\";\n    let terminated = false;\n    const start = this.index;\n    const head = this.source[start] === \"`\";\n    let tail = false;\n    let notEscapeSequenceHead = null;\n    let rawOffset = 2;\n    ++this.index;\n    while (!this.eof()) {\n      let ch = this.source[this.index++];\n      if (ch === \"`\") {\n        rawOffset = 1;\n        tail = true;\n        terminated = true;\n        break;\n      } else if (ch === \"$\") {\n        if (this.source[this.index] === \"{\") {\n          this.curlyStack.push(\"${\");\n          ++this.index;\n          terminated = true;\n          break;\n        }\n        cooked += ch;\n      } else if (notEscapeSequenceHead !== null) {\n        continue;\n      } else if (ch === \"\\\\\") {\n        ch = this.source[this.index++];\n        if (!Character.isLineTerminator(ch.charCodeAt(0))) {\n          switch (ch) {\n            case \"n\":\n              cooked += \"\\n\";\n              break;\n            case \"r\":\n              cooked += \"\\r\";\n              break;\n            case \"t\":\n              cooked += \"\t\";\n              break;\n            case \"u\":\n              if (this.source[this.index] === \"{\") {\n                ++this.index;\n                const unicodeCodePointEscape = this.tryToScanUnicodeCodePointEscape();\n                if (unicodeCodePointEscape === null) {\n                  notEscapeSequenceHead = \"u\";\n                } else {\n                  cooked += unicodeCodePointEscape;\n                }\n              } else {\n                const unescapedChar = this.scanHexEscape(ch);\n                if (unescapedChar === null) {\n                  notEscapeSequenceHead = \"u\";\n                } else {\n                  cooked += unescapedChar;\n                }\n              }\n              break;\n            case \"x\":\n              const unescaped = this.scanHexEscape(ch);\n              if (unescaped === null) {\n                notEscapeSequenceHead = \"x\";\n              } else {\n                cooked += unescaped;\n              }\n              break;\n            case \"b\":\n              cooked += \"\\b\";\n              break;\n            case \"f\":\n              cooked += \"\\f\";\n              break;\n            case \"v\":\n              cooked += \"\\v\";\n              break;\n            default:\n              if (ch === \"0\") {\n                if (Character.isDecimalDigit(this.source.charCodeAt(this.index))) {\n                  notEscapeSequenceHead = \"0\";\n                } else {\n                  cooked += \"\\0\";\n                }\n              } else if (Character.isDecimalDigitChar(ch)) {\n                notEscapeSequenceHead = ch;\n              } else {\n                cooked += ch;\n              }\n              break;\n          }\n        } else {\n          ++this.lineNumber;\n          if (ch === \"\\r\" && this.source[this.index] === \"\\n\") {\n            ++this.index;\n          }\n          this.lineStart = this.index;\n        }\n      } else if (Character.isLineTerminator(ch.charCodeAt(0))) {\n        ++this.lineNumber;\n        if (ch === \"\\r\" && this.source[this.index] === \"\\n\") {\n          ++this.index;\n        }\n        this.lineStart = this.index;\n        cooked += \"\\n\";\n      } else {\n        cooked += ch;\n      }\n    }\n    if (!terminated) {\n      this.throwUnexpectedToken();\n    }\n    if (!head) {\n      this.curlyStack.pop();\n    }\n    return {\n      type: 10 /* Template */,\n      value: this.source.slice(start + 1, this.index - rawOffset),\n      cooked: notEscapeSequenceHead === null ? cooked : null,\n      head,\n      tail,\n      notEscapeSequenceHead,\n      lineNumber: this.lineNumber,\n      lineStart: this.lineStart,\n      start,\n      end: this.index\n    };\n  }\n  // https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals\n  testRegExp(pattern, flags) {\n    const astralSubstitute = \"\\uFFFF\";\n    let tmp = pattern;\n    if (flags.indexOf(\"u\") >= 0) {\n      tmp = tmp.replace(/\\\\u\\{([0-9a-fA-F]+)\\}|\\\\u([a-fA-F0-9]{4})/g, ($0, $1, $2) => {\n        const codePoint = parseInt($1 || $2, 16);\n        if (codePoint > 1114111) {\n          this.throwUnexpectedToken(Messages.InvalidRegExp);\n        }\n        if (codePoint <= 65535) {\n          return String.fromCharCode(codePoint);\n        }\n        return astralSubstitute;\n      }).replace(\n        /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g,\n        astralSubstitute\n      );\n    }\n    try {\n      RegExp(tmp);\n    } catch (e) {\n      this.throwUnexpectedToken(Messages.InvalidRegExp);\n    }\n    try {\n      return new RegExp(pattern, flags);\n    } catch (exception) {\n      return null;\n    }\n  }\n  scanRegExpBody() {\n    let ch = this.source[this.index];\n    assert(ch === \"/\", \"Regular expression literal must start with a slash\");\n    let str = this.source[this.index++];\n    let classMarker = false;\n    let terminated = false;\n    while (!this.eof()) {\n      ch = this.source[this.index++];\n      str += ch;\n      if (ch === \"\\\\\") {\n        ch = this.source[this.index++];\n        if (Character.isLineTerminator(ch.charCodeAt(0))) {\n          this.throwUnexpectedToken(Messages.UnterminatedRegExp);\n        }\n        str += ch;\n      } else if (Character.isLineTerminator(ch.charCodeAt(0))) {\n        this.throwUnexpectedToken(Messages.UnterminatedRegExp);\n      } else if (classMarker) {\n        if (ch === \"]\") {\n          classMarker = false;\n        }\n      } else {\n        if (ch === \"/\") {\n          terminated = true;\n          break;\n        } else if (ch === \"[\") {\n          classMarker = true;\n        }\n      }\n    }\n    if (!terminated) {\n      this.throwUnexpectedToken(Messages.UnterminatedRegExp);\n    }\n    return str.substr(1, str.length - 2);\n  }\n  scanRegExpFlags() {\n    let str = \"\";\n    let flags = \"\";\n    while (!this.eof()) {\n      let ch = this.source[this.index];\n      if (!Character.isIdentifierPart(ch.charCodeAt(0))) {\n        break;\n      }\n      ++this.index;\n      if (ch === \"\\\\\" && !this.eof()) {\n        ch = this.source[this.index];\n        if (ch === \"u\") {\n          ++this.index;\n          let restore = this.index;\n          const char = this.scanHexEscape(\"u\");\n          if (char !== null) {\n            flags += char;\n            for (str += \"\\\\u\"; restore < this.index; ++restore) {\n              str += this.source[restore];\n            }\n          } else {\n            this.index = restore;\n            flags += \"u\";\n            str += \"\\\\u\";\n          }\n          this.tolerateUnexpectedToken();\n        } else {\n          str += \"\\\\\";\n          this.tolerateUnexpectedToken();\n        }\n      } else {\n        flags += ch;\n        str += ch;\n      }\n    }\n    return flags;\n  }\n  scanRegExp() {\n    const start = this.index;\n    const pattern = this.scanRegExpBody();\n    const flags = this.scanRegExpFlags();\n    const value = this.testRegExp(pattern, flags);\n    return {\n      type: 9 /* RegularExpression */,\n      value: \"\",\n      pattern,\n      flags,\n      regex: value,\n      lineNumber: this.lineNumber,\n      lineStart: this.lineStart,\n      start,\n      end: this.index\n    };\n  }\n  lex() {\n    if (this.eof()) {\n      return {\n        type: 2 /* EOF */,\n        value: \"\",\n        lineNumber: this.lineNumber,\n        lineStart: this.lineStart,\n        start: this.index,\n        end: this.index\n      };\n    }\n    const cp = this.source.charCodeAt(this.index);\n    if (Character.isIdentifierStart(cp)) {\n      return this.scanIdentifier();\n    }\n    if (cp === 40 || cp === 41 || cp === 59) {\n      return this.scanPunctuator();\n    }\n    if (cp === 39 || cp === 34) {\n      return this.scanStringLiteral();\n    }\n    if (cp === 46) {\n      if (Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) {\n        return this.scanNumericLiteral();\n      }\n      return this.scanPunctuator();\n    }\n    if (Character.isDecimalDigit(cp)) {\n      return this.scanNumericLiteral();\n    }\n    if (cp === 96 || cp === 125 && this.curlyStack[this.curlyStack.length - 1] === \"${\") {\n      return this.scanTemplate();\n    }\n    if (cp >= 55296 && cp < 57343) {\n      if (Character.isIdentifierStart(this.codePointAt(this.index))) {\n        return this.scanIdentifier();\n      }\n    }\n    return this.scanPunctuator();\n  }\n};\n\n// src/parser.ts\nvar ArrowParameterPlaceHolder = \"ArrowParameterPlaceHolder\";\nvar Parser = class {\n  config;\n  delegate;\n  errorHandler;\n  scanner;\n  operatorPrecedence;\n  lookahead;\n  hasLineTerminator;\n  context;\n  tokens;\n  startMarker;\n  lastMarker;\n  constructor(code, options = {}, delegate) {\n    this.config = {\n      range: typeof options.range === \"boolean\" && options.range,\n      loc: typeof options.loc === \"boolean\" && options.loc,\n      source: null,\n      tokens: typeof options.tokens === \"boolean\" && options.tokens,\n      comment: typeof options.comment === \"boolean\" && options.comment,\n      tolerant: typeof options.tolerant === \"boolean\" && options.tolerant\n    };\n    if (this.config.loc && options.source && options.source !== null) {\n      this.config.source = String(options.source);\n    }\n    this.delegate = delegate;\n    this.errorHandler = new ErrorHandler();\n    this.errorHandler.tolerant = this.config.tolerant == true;\n    this.scanner = new Scanner(code, this.errorHandler);\n    this.scanner.trackComment = this.config.comment == true;\n    this.operatorPrecedence = {\n      \")\": 0,\n      \";\": 0,\n      \",\": 0,\n      \"=\": 0,\n      \"]\": 0,\n      \"??\": 5,\n      \"||\": 6,\n      \"&&\": 7,\n      \"|\": 8,\n      \"^\": 9,\n      \"&\": 10,\n      \"==\": 11,\n      \"!=\": 11,\n      \"===\": 11,\n      \"!==\": 11,\n      \"<\": 12,\n      \">\": 12,\n      \"<=\": 12,\n      \">=\": 12,\n      \"<<\": 13,\n      \">>\": 13,\n      \">>>\": 13,\n      \"+\": 14,\n      \"-\": 14,\n      \"*\": 15,\n      \"/\": 15,\n      \"%\": 15\n    };\n    this.lookahead = {\n      type: 2 /* EOF */,\n      value: \"\",\n      lineNumber: this.scanner.lineNumber,\n      lineStart: 0,\n      start: 0,\n      end: 0\n    };\n    this.hasLineTerminator = false;\n    this.context = {\n      isModule: false,\n      isAsync: false,\n      allowIn: true,\n      allowStrictDirective: true,\n      allowSuper: false,\n      allowYield: true,\n      firstCoverInitializedNameError: null,\n      isAssignmentTarget: false,\n      isBindingElement: false,\n      inConstructor: false,\n      inFunctionBody: false,\n      inIteration: false,\n      inSwitch: false,\n      inClassConstructor: false,\n      labelSet: {},\n      strict: false,\n      decorators: null\n    };\n    this.tokens = [];\n    this.startMarker = {\n      index: 0,\n      line: this.scanner.lineNumber,\n      column: 0\n    };\n    this.lastMarker = {\n      index: 0,\n      line: this.scanner.lineNumber,\n      column: 0\n    };\n    this.nextToken();\n    this.lastMarker = {\n      index: this.scanner.index,\n      line: this.scanner.lineNumber,\n      column: this.scanner.index - this.scanner.lineStart\n    };\n  }\n  throwError(messageFormat, ...values) {\n    const args = values.slice();\n    const msg = messageFormat.replace(\n      /%(\\d)/g,\n      (whole, idx) => {\n        assert(idx < args.length, \"Message reference must be in range\");\n        return args[idx];\n      }\n    );\n    const index = this.lastMarker.index;\n    const line = this.lastMarker.line;\n    const column = this.lastMarker.column + 1;\n    throw this.errorHandler.createError(index, line, column, msg);\n  }\n  tolerateError(messageFormat, ...values) {\n    const args = values.slice();\n    const msg = messageFormat.replace(\n      /%(\\d)/g,\n      (whole, idx) => {\n        assert(idx < args.length, \"Message reference must be in range\");\n        return args[idx];\n      }\n    );\n    const index = this.lastMarker.index;\n    const line = this.scanner.lineNumber;\n    const column = this.lastMarker.column + 1;\n    this.errorHandler.tolerateError(index, line, column, msg);\n  }\n  // Throw an exception because of the token.\n  unexpectedTokenError(token, message) {\n    let msg = message || Messages.UnexpectedToken;\n    let value;\n    if (token) {\n      if (!message) {\n        msg = token.type === 2 /* EOF */ ? Messages.UnexpectedEOS : token.type === 3 /* Identifier */ ? Messages.UnexpectedIdentifier : token.type === 6 /* NumericLiteral */ ? Messages.UnexpectedNumber : token.type === 8 /* StringLiteral */ ? Messages.UnexpectedString : token.type === 10 /* Template */ ? Messages.UnexpectedTemplate : Messages.UnexpectedToken;\n        if (token.type === 4 /* Keyword */) {\n          if (this.scanner.isFutureReservedWord(token.value)) {\n            msg = Messages.UnexpectedReserved;\n          } else if (this.context.strict && this.scanner.isStrictModeReservedWord(token.value)) {\n            msg = Messages.StrictReservedWord;\n          }\n        }\n      }\n      value = token.value;\n    } else {\n      value = \"ILLEGAL\";\n    }\n    msg = msg.replace(\"%0\", value);\n    if (token && typeof token.lineNumber === \"number\") {\n      const index = token.start;\n      const line = token.lineNumber;\n      const lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column;\n      const column = token.start - lastMarkerLineStart + 1;\n      return this.errorHandler.createError(index, line, column, msg);\n    } else {\n      const index = this.lastMarker.index;\n      const line = this.lastMarker.line;\n      const column = this.lastMarker.column + 1;\n      return this.errorHandler.createError(index, line, column, msg);\n    }\n  }\n  throwUnexpectedToken(token, message) {\n    throw this.unexpectedTokenError(token, message);\n  }\n  tolerateUnexpectedToken(token, message) {\n    this.errorHandler.tolerate(this.unexpectedTokenError(token, message));\n  }\n  tolerateInvalidLoopStatement() {\n    if (this.matchKeyword(\"class\") || this.matchKeyword(\"function\")) {\n      this.tolerateError(Messages.UnexpectedToken, this.lookahead);\n    }\n  }\n  collectComments() {\n    if (!this.config.comment) {\n      this.scanner.scanComments();\n    } else {\n      const comments = this.scanner.scanComments();\n      if (comments.length > 0 && this.delegate) {\n        for (let i = 0; i < comments.length; ++i) {\n          const e = comments[i];\n          const node = {\n            type: e.multiLine ? \"BlockComment\" : \"LineComment\",\n            value: this.scanner.source.slice(e.slice[0], e.slice[1])\n          };\n          if (this.config.range) {\n            node.range = e.range;\n          }\n          if (this.config.loc) {\n            node.loc = e.loc;\n          }\n          const metadata = {\n            start: {\n              line: e.loc.start.line,\n              column: e.loc.start.column,\n              offset: e.range[0]\n            },\n            end: {\n              line: e.loc.end.line,\n              column: e.loc.end.column,\n              offset: e.range[1]\n            }\n          };\n          this.delegate(node, metadata);\n        }\n      }\n    }\n  }\n  // From internal representation to an external structure\n  getTokenRaw(token) {\n    return this.scanner.source.slice(token.start, token.end);\n  }\n  convertToken(token) {\n    const t = {\n      type: TokenName[token.type],\n      value: this.getTokenRaw(token)\n    };\n    if (this.config.range) {\n      t.range = [token.start, token.end];\n    }\n    if (this.config.loc) {\n      t.loc = {\n        start: {\n          line: this.startMarker.line,\n          column: this.startMarker.column\n        },\n        end: {\n          line: this.scanner.lineNumber,\n          column: this.scanner.index - this.scanner.lineStart\n        }\n      };\n    }\n    if (token.type === 9 /* RegularExpression */) {\n      const pattern = token.pattern;\n      const flags = token.flags;\n      t.regex = { pattern, flags };\n    }\n    return t;\n  }\n  nextToken() {\n    const token = this.lookahead;\n    this.lastMarker.index = this.scanner.index;\n    this.lastMarker.line = this.scanner.lineNumber;\n    this.lastMarker.column = this.scanner.index - this.scanner.lineStart;\n    this.collectComments();\n    if (this.scanner.index !== this.startMarker.index) {\n      this.startMarker.index = this.scanner.index;\n      this.startMarker.line = this.scanner.lineNumber;\n      this.startMarker.column = this.scanner.index - this.scanner.lineStart;\n    }\n    const next = this.scanner.lex();\n    this.hasLineTerminator = token.lineNumber !== next.lineNumber;\n    if (next && this.context.strict && next.type === 3 /* Identifier */) {\n      if (this.scanner.isStrictModeReservedWord(next.value)) {\n        next.type = 4 /* Keyword */;\n      }\n    }\n    this.lookahead = next;\n    if (this.config.tokens && next.type !== 2 /* EOF */) {\n      this.tokens.push(this.convertToken(next));\n    }\n    return token;\n  }\n  nextRegexToken() {\n    this.collectComments();\n    const token = this.scanner.scanRegExp();\n    if (this.config.tokens) {\n      this.tokens.pop();\n      this.tokens.push(this.convertToken(token));\n    }\n    this.lookahead = token;\n    this.nextToken();\n    return token;\n  }\n  createNode() {\n    return {\n      index: this.startMarker.index,\n      line: this.startMarker.line,\n      column: this.startMarker.column\n    };\n  }\n  startNode(token, lastLineStart = 0) {\n    let column = token.start - token.lineStart;\n    let line = token.lineNumber;\n    if (column < 0) {\n      column += lastLineStart;\n      line--;\n    }\n    return {\n      index: token.start,\n      line,\n      column\n    };\n  }\n  finalize(marker, node) {\n    if (this.config.range) {\n      node.range = [marker.index, this.lastMarker.index];\n    }\n    if (this.config.loc) {\n      node.loc = {\n        start: {\n          line: marker.line,\n          column: marker.column\n        },\n        end: {\n          line: this.lastMarker.line,\n          column: this.lastMarker.column\n        }\n      };\n      if (this.config.source) {\n        node.loc.source = this.config.source;\n      }\n    }\n    if (this.delegate) {\n      const metadata = {\n        start: {\n          line: marker.line,\n          column: marker.column,\n          offset: marker.index\n        },\n        end: {\n          line: this.lastMarker.line,\n          column: this.lastMarker.column,\n          offset: this.lastMarker.index\n        }\n      };\n      this.delegate(node, metadata);\n    }\n    return node;\n  }\n  // Expect the next token to match the specified punctuator.\n  // If not, an exception will be thrown.\n  expect(value) {\n    const token = this.nextToken();\n    if (token.type !== 7 /* Punctuator */ || token.value !== value) {\n      this.throwUnexpectedToken(token);\n    }\n  }\n  // Quietly expect a comma when in tolerant mode, otherwise delegates to expect().\n  expectCommaSeparator() {\n    if (this.config.tolerant) {\n      const token = this.lookahead;\n      if (token.type === 7 /* Punctuator */ && token.value === \",\") {\n        this.nextToken();\n      } else if (token.type === 7 /* Punctuator */ && token.value === \";\") {\n        this.nextToken();\n        this.tolerateUnexpectedToken(token);\n      } else {\n        this.tolerateUnexpectedToken(token, Messages.UnexpectedToken);\n      }\n    } else {\n      this.expect(\",\");\n    }\n  }\n  // Expect the next token to match the specified keyword.\n  // If not, an exception will be thrown.\n  expectKeyword(keyword) {\n    const token = this.nextToken();\n    if (token.type !== 4 /* Keyword */ || token.value !== keyword) {\n      this.throwUnexpectedToken(token);\n    }\n  }\n  // Return true if the next token matches the specified punctuator.\n  match(value) {\n    return this.lookahead.type === 7 /* Punctuator */ && this.lookahead.value === value;\n  }\n  // Return true if the next token matches the specified keyword\n  matchKeyword(keyword) {\n    return this.lookahead.type === 4 /* Keyword */ && this.lookahead.value === keyword;\n  }\n  // Return true if the next token matches the specified contextual keyword\n  // (where an identifier is sometimes a keyword depending on the context)\n  matchContextualKeyword(keyword) {\n    return this.lookahead.type === 3 /* Identifier */ && this.lookahead.value === keyword;\n  }\n  // Return true if the next token is an assignment operator\n  matchAssign() {\n    if (this.lookahead.type !== 7 /* Punctuator */) {\n      return false;\n    }\n    const op = this.lookahead.value;\n    return op === \"=\" || op === \"*=\" || op === \"**=\" || op === \"/=\" || op === \"%=\" || op === \"+=\" || op === \"-=\" || op === \"<<=\" || op === \">>=\" || op === \">>>=\" || op === \"&=\" || op === \"^=\" || op === \"|=\" || op === \"&&=\" || op === \"||=\" || op === \"??=\";\n  }\n  // Cover grammar support.\n  //\n  // When an assignment expression position starts with an left parenthesis, the determination of the type\n  // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)\n  // or the first comma. This situation also defers the determination of all the expressions nested in the pair.\n  //\n  // There are three productions that can be parsed in a parentheses pair that needs to be determined\n  // after the outermost pair is closed. They are:\n  //\n  //   1. AssignmentExpression\n  //   2. BindingElements\n  //   3. AssignmentTargets\n  //\n  // In order to avoid exponential backtracking, we use two flags to denote if the production can be\n  // binding element or assignment target.\n  //\n  // The three productions have the relationship:\n  //\n  //   BindingElements ⊆ AssignmentTargets ⊆ AssignmentExpression\n  //\n  // with a single exception that CoverInitializedName when used directly in an Expression, generates\n  // an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the\n  // first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.\n  //\n  // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not\n  // effect the current flags. This means the production the parser parses is only used as an expression. Therefore\n  // the CoverInitializedName check is conducted.\n  //\n  // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates\n  // the flags outside of the parser. This means the production the parser parses is used as a part of a potential\n  // pattern. The CoverInitializedName check is deferred.\n  isolateCoverGrammar(parseFunction) {\n    const previousIsBindingElement = this.context.isBindingElement;\n    const previousIsAssignmentTarget = this.context.isAssignmentTarget;\n    const previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;\n    this.context.isBindingElement = true;\n    this.context.isAssignmentTarget = true;\n    this.context.firstCoverInitializedNameError = null;\n    const result = parseFunction.call(this);\n    if (this.context.firstCoverInitializedNameError !== null) {\n      this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);\n    }\n    this.context.isBindingElement = previousIsBindingElement;\n    this.context.isAssignmentTarget = previousIsAssignmentTarget;\n    this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;\n    return result;\n  }\n  inheritCoverGrammar(parseFunction) {\n    const previousIsBindingElement = this.context.isBindingElement;\n    const previousIsAssignmentTarget = this.context.isAssignmentTarget;\n    const previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;\n    this.context.isBindingElement = true;\n    this.context.isAssignmentTarget = true;\n    this.context.firstCoverInitializedNameError = null;\n    const result = parseFunction.call(this);\n    this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement;\n    this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget;\n    this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError;\n    return result;\n  }\n  consumeSemicolon() {\n    if (this.match(\";\")) {\n      this.nextToken();\n    } else if (!this.hasLineTerminator) {\n      if (this.lookahead.type !== 2 /* EOF */ && !this.match(\"}\")) {\n        this.throwUnexpectedToken(this.lookahead);\n      }\n      this.lastMarker.index = this.startMarker.index;\n      this.lastMarker.line = this.startMarker.line;\n      this.lastMarker.column = this.startMarker.column;\n    }\n  }\n  // https://tc39.github.io/ecma262/#sec-primary-expression\n  parsePrimaryExpression() {\n    const node = this.createNode();\n    let expr;\n    let token, raw;\n    switch (this.lookahead.type) {\n      case 3 /* Identifier */:\n        if ((this.context.isModule || this.context.isAsync) && this.lookahead.value === \"await\") {\n          this.tolerateUnexpectedToken(this.lookahead);\n        }\n        expr = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node, new Identifier(this.nextToken().value));\n        break;\n      case 6 /* NumericLiteral */:\n      case 8 /* StringLiteral */:\n        if (this.context.strict && this.lookahead.octal) {\n          this.tolerateUnexpectedToken(this.lookahead, Messages.StrictOctalLiteral);\n        }\n        this.context.isAssignmentTarget = false;\n        this.context.isBindingElement = false;\n        token = this.nextToken();\n        raw = this.getTokenRaw(token);\n        if (typeof token.value === \"bigint\")\n          expr = this.finalize(node, new BigIntLiteral(token.value, raw, token.value.toString()));\n        else\n          expr = this.finalize(node, new Literal(token.value, raw));\n        break;\n      case 1 /* BooleanLiteral */:\n        this.context.isAssignmentTarget = false;\n        this.context.isBindingElement = false;\n        token = this.nextToken();\n        raw = this.getTokenRaw(token);\n        expr = this.finalize(node, new Literal(token.value === \"true\", raw));\n        break;\n      case 5 /* NullLiteral */:\n        this.context.isAssignmentTarget = false;\n        this.context.isBindingElement = false;\n        token = this.nextToken();\n        raw = this.getTokenRaw(token);\n        expr = this.finalize(node, new Literal(null, raw));\n        break;\n      case 10 /* Template */:\n        expr = this.parseTemplateLiteral({ isTagged: false });\n        break;\n      case 7 /* Punctuator */:\n        switch (this.lookahead.value) {\n          case \"(\":\n            this.context.isBindingElement = false;\n            expr = this.inheritCoverGrammar(this.parseGroupExpression);\n            break;\n          case \"[\":\n            expr = this.inheritCoverGrammar(this.parseArrayInitializer);\n            break;\n          case \"{\":\n            expr = this.inheritCoverGrammar(this.parseObjectInitializer);\n            break;\n          case \"/\":\n          case \"/=\":\n            this.context.isAssignmentTarget = false;\n            this.context.isBindingElement = false;\n            this.scanner.index = this.startMarker.index;\n            token = this.nextRegexToken();\n            raw = this.getTokenRaw(token);\n            expr = this.finalize(node, new RegexLiteral(token.regex, raw, token.pattern, token.flags));\n            break;\n          case \"#\":\n            this.nextToken();\n            expr = this.finalize(node, new PrivateIdentifier(this.nextToken().value));\n            break;\n          case \"@\":\n            let decorators = this.parseDecorators();\n            this.context.decorators = decorators;\n            let expression = this.parsePrimaryExpression();\n            this.context.decorators = null;\n            expr = this.finalize(node, new PrivateIdentifier(this.nextToken().value));\n            break;\n          default:\n            expr = this.throwUnexpectedToken(this.nextToken());\n        }\n        break;\n      case 4 /* Keyword */:\n        if (!this.context.strict && this.context.allowYield && this.matchKeyword(\"yield\")) {\n          expr = this.parseIdentifierName();\n        } else if (!this.context.strict && this.matchKeyword(\"let\")) {\n          expr = this.finalize(node, new Identifier(this.nextToken().value));\n        } else {\n          this.context.isAssignmentTarget = false;\n          this.context.isBindingElement = false;\n          if (this.matchKeyword(\"function\")) {\n            expr = this.parseFunctionExpression();\n          } else if (this.matchKeyword(\"this\")) {\n            this.nextToken();\n            expr = this.finalize(node, new ThisExpression());\n          } else if (this.matchKeyword(\"class\")) {\n            expr = this.parseClassExpression();\n          } else if (this.matchKeyword(\"new\")) {\n            expr = this.parseNewExpression();\n          } else if (this.matchImportCall()) {\n            expr = this.parseImportCall();\n          } else if (this.matchImportMeta()) {\n            if (!this.context.isModule) {\n              this.tolerateUnexpectedToken(this.lookahead, Messages.CannotUseImportMetaOutsideAModule);\n            }\n            expr = this.parseImportMeta();\n          } else {\n            expr = this.throwUnexpectedToken(this.nextToken());\n          }\n        }\n        break;\n      default:\n        expr = this.throwUnexpectedToken(this.nextToken());\n    }\n    return expr;\n  }\n  // https://tc39.github.io/ecma262/#sec-array-initializer\n  parseSpreadElement() {\n    const node = this.createNode();\n    this.expect(\"...\");\n    const arg = this.inheritCoverGrammar(this.parseAssignmentExpression);\n    return this.finalize(node, new SpreadElement(arg));\n  }\n  parseArrayInitializer() {\n    const node = this.createNode();\n    const elements = [];\n    this.expect(\"[\");\n    while (!this.match(\"]\")) {\n      if (this.match(\",\")) {\n        this.nextToken();\n        elements.push(null);\n      } else if (this.match(\"...\")) {\n        const element = this.parseSpreadElement();\n        if (!this.match(\"]\")) {\n          this.context.isAssignmentTarget = false;\n          this.context.isBindingElement = false;\n          this.expect(\",\");\n        }\n        elements.push(element);\n      } else {\n        elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression));\n        if (!this.match(\"]\")) {\n          this.expect(\",\");\n        }\n      }\n    }\n    this.expect(\"]\");\n    return this.finalize(node, new ArrayExpression(elements));\n  }\n  // https://tc39.github.io/ecma262/#sec-object-initializer\n  parsePropertyMethod(params) {\n    this.context.isAssignmentTarget = false;\n    this.context.isBindingElement = false;\n    const previousStrict = this.context.strict;\n    const previousAllowStrictDirective = this.context.allowStrictDirective;\n    this.context.allowStrictDirective = params.simple;\n    const body = this.isolateCoverGrammar(this.parseFunctionSourceElements);\n    if (this.context.strict && params.firstRestricted) {\n      this.tolerateUnexpectedToken(params.firstRestricted, params.message);\n    }\n    if (this.context.strict && params.stricted) {\n      this.tolerateUnexpectedToken(params.stricted, params.message);\n    }\n    this.context.strict = previousStrict;\n    this.context.allowStrictDirective = previousAllowStrictDirective;\n    return body;\n  }\n  parsePropertyMethodFunction(isGenerator) {\n    const node = this.createNode();\n    const previousAllowYield = this.context.allowYield;\n    this.context.allowYield = true;\n    const params = this.parseFormalParameters();\n    const method = this.parsePropertyMethod(params);\n    this.context.allowYield = previousAllowYield;\n    return this.finalize(node, new FunctionExpression(null, params.params, method, isGenerator, false));\n  }\n  parsePropertyMethodAsyncFunction(isGenerator) {\n    const node = this.createNode();\n    const previousAllowYield = this.context.allowYield;\n    const previousIsAsync = this.context.isAsync;\n    this.context.allowYield = false;\n    this.context.isAsync = true;\n    const params = this.parseFormalParameters();\n    const method = this.parsePropertyMethod(params);\n    this.context.allowYield = previousAllowYield;\n    this.context.isAsync = previousIsAsync;\n    return this.finalize(node, new FunctionExpression(null, params.params, method, isGenerator, true));\n  }\n  parseObjectPropertyKey(isPrivate = false) {\n    const node = this.createNode();\n    const token = this.nextToken();\n    let key;\n    switch (token.type) {\n      case 8 /* StringLiteral */:\n      case 6 /* NumericLiteral */:\n        if (this.context.strict && token.octal) {\n          this.tolerateUnexpectedToken(token, Messages.StrictOctalLiteral);\n        }\n        const raw = this.getTokenRaw(token);\n        if (typeof token.value === \"bigint\")\n          key = this.finalize(node, new BigIntLiteral(token.value, raw, token.value.toString()));\n        else\n          key = this.finalize(node, new Literal(token.value, raw));\n        break;\n      case 3 /* Identifier */:\n      case 1 /* BooleanLiteral */:\n      case 5 /* NullLiteral */:\n      case 4 /* Keyword */:\n        key = this.finalize(node, isPrivate ? new PrivateIdentifier(token.value) : new Identifier(token.value));\n        break;\n      case 7 /* Punctuator */:\n        if (token.value === \"[\") {\n          key = this.isolateCoverGrammar(this.parseAssignmentExpression);\n          this.expect(\"]\");\n        } else {\n          key = this.throwUnexpectedToken(token);\n        }\n        break;\n      default:\n        key = this.throwUnexpectedToken(token);\n    }\n    return key;\n  }\n  isPropertyKey(key, value) {\n    return key.type === \"Identifier\" /* Identifier */ && key.name === value || key.type === \"Literal\" /* Literal */ && key.value === value;\n  }\n  parseObjectProperty(hasProto) {\n    const node = this.createNode();\n    const token = this.lookahead;\n    let kind;\n    let key = null;\n    let value = null;\n    let computed = false;\n    let method = false;\n    let shorthand = false;\n    let isAsync = false;\n    let isGenerator = false;\n    if (token.type === 3 /* Identifier */) {\n      const id = token.value;\n      this.nextToken();\n      computed = this.match(\"[\");\n      isAsync = !this.hasLineTerminator && id === \"async\" && !this.match(\":\") && !this.match(\"(\") && !this.match(\",\");\n      isGenerator = this.match(\"*\");\n      if (isGenerator) {\n        this.nextToken();\n      }\n      key = isAsync ? this.parseObjectPropertyKey() : this.finalize(node, new Identifier(id));\n    } else if (this.match(\"*\")) {\n      this.nextToken();\n    } else {\n      computed = this.match(\"[\");\n      key = this.parseObjectPropertyKey();\n    }\n    const lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);\n    if (token.type === 3 /* Identifier */ && !isAsync && token.value === \"get\" && lookaheadPropertyKey) {\n      kind = \"get\";\n      computed = this.match(\"[\");\n      key = this.parseObjectPropertyKey();\n      this.context.allowYield = false;\n      value = this.parseGetterMethod();\n    } else if (token.type === 3 /* Identifier */ && !isAsync && token.value === \"set\" && lookaheadPropertyKey) {\n      kind = \"set\";\n      computed = this.match(\"[\");\n      key = this.parseObjectPropertyKey();\n      value = this.parseSetterMethod();\n    } else if (token.type === 7 /* Punctuator */ && token.value === \"*\" && lookaheadPropertyKey) {\n      kind = \"init\";\n      computed = this.match(\"[\");\n      key = this.parseObjectPropertyKey();\n      value = this.parseGeneratorMethod(false);\n      method = true;\n    } else {\n      if (!key) {\n        this.throwUnexpectedToken(this.lookahead);\n      }\n      kind = \"init\";\n      if (this.match(\":\") && !isAsync) {\n        if (!computed && this.isPropertyKey(key, \"__proto__\")) {\n          if (hasProto.value) {\n            this.tolerateError(Messages.DuplicateProtoProperty);\n          }\n          hasProto.value = true;\n        }\n        this.nextToken();\n        value = this.inheritCoverGrammar(this.parseAssignmentExpression);\n      } else if (this.match(\"(\")) {\n        value = isAsync ? this.parsePropertyMethodAsyncFunction(isGenerator) : this.parsePropertyMethodFunction(isGenerator);\n        method = true;\n      } else if (token.type === 3 /* Identifier */) {\n        const id = this.finalize(node, new Identifier(token.value));\n        if (this.match(\"=\")) {\n          this.context.firstCoverInitializedNameError = this.lookahead;\n          this.nextToken();\n          shorthand = true;\n          const init = this.isolateCoverGrammar(this.parseAssignmentExpression);\n          value = this.finalize(node, new AssignmentPattern(id, init));\n        } else {\n          shorthand = true;\n          value = id;\n        }\n      } else {\n        this.throwUnexpectedToken(this.nextToken());\n      }\n    }\n    return this.finalize(node, new Property(kind, key, computed, value, method, shorthand));\n  }\n  parseObjectInitializer() {\n    const node = this.createNode();\n    this.expect(\"{\");\n    const properties = [];\n    const hasProto = { value: false };\n    while (!this.match(\"}\")) {\n      const property = this.match(\"...\") ? this.parseSpreadElement() : this.parseObjectProperty(hasProto);\n      properties.push(property);\n      if (!this.match(\"}\") && (!property.method || this.match(\",\"))) {\n        this.expectCommaSeparator();\n      }\n    }\n    this.expect(\"}\");\n    return this.finalize(node, new ObjectExpression(properties));\n  }\n  // https://tc39.es/proposal-template-literal-revision/#sec-static-semantics-template-early-errors\n  throwTemplateLiteralEarlyErrors(token) {\n    switch (token.notEscapeSequenceHead) {\n      case \"u\":\n        return this.throwUnexpectedToken(token, Messages.InvalidUnicodeEscapeSequence);\n      case \"x\":\n        return this.throwUnexpectedToken(token, Messages.InvalidHexEscapeSequence);\n      case \"8\":\n      case \"9\":\n        return this.throwUnexpectedToken(token, Messages.TemplateEscape89);\n      default:\n        return this.throwUnexpectedToken(token, Messages.TemplateOctalLiteral);\n    }\n  }\n  // https://tc39.github.io/ecma262/#sec-template-literals\n  parseTemplateHead(options) {\n    assert(this.lookahead.head, \"Template literal must start with a template head\");\n    const node = this.createNode();\n    const token = this.nextToken();\n    if (!options.isTagged && token.notEscapeSequenceHead !== null) {\n      this.throwTemplateLiteralEarlyErrors(token);\n    }\n    const raw = token.value;\n    const cooked = token.cooked;\n    return this.finalize(node, new TemplateElement({ raw, cooked }, token.tail));\n  }\n  parseTemplateElement(options) {\n    if (this.lookahead.type !== 10 /* Template */) {\n      this.throwUnexpectedToken();\n    }\n    const node = this.createNode();\n    const token = this.nextToken();\n    if (!options.isTagged && token.notEscapeSequenceHead !== null) {\n      this.throwTemplateLiteralEarlyErrors(token);\n    }\n    const raw = token.value;\n    const cooked = token.cooked;\n    return this.finalize(node, new TemplateElement({ raw, cooked }, token.tail));\n  }\n  parseTemplateLiteral(options) {\n    const node = this.createNode();\n    const expressions = [];\n    const quasis = [];\n    let quasi = this.parseTemplateHead(options);\n    quasis.push(quasi);\n    while (!quasi.tail) {\n      expressions.push(this.parseExpression());\n      quasi = this.parseTemplateElement(options);\n      quasis.push(quasi);\n    }\n    return this.finalize(node, new TemplateLiteral(quasis, expressions));\n  }\n  // https://tc39.github.io/ecma262/#sec-grouping-operator\n  reinterpretExpressionAsPattern(expr) {\n    switch (expr.type) {\n      case \"Identifier\" /* Identifier */:\n      case \"MemberExpression\" /* MemberExpression */:\n      case \"RestElement\" /* RestElement */:\n      case \"AssignmentPattern\" /* AssignmentPattern */:\n        break;\n      case \"SpreadElement\" /* SpreadElement */:\n        expr.type = \"RestElement\" /* RestElement */;\n        this.reinterpretExpressionAsPattern(expr.argument);\n        break;\n      case \"ArrayExpression\" /* ArrayExpression */:\n        expr.type = \"ArrayPattern\" /* ArrayPattern */;\n        for (let i = 0; i < expr.elements.length; i++) {\n          if (expr.elements[i] !== null) {\n            this.reinterpretExpressionAsPattern(expr.elements[i]);\n          }\n        }\n        break;\n      case \"ObjectExpression\" /* ObjectExpression */:\n        expr.type = \"ObjectPattern\" /* ObjectPattern */;\n        for (let i = 0; i < expr.properties.length; i++) {\n          const property = expr.properties[i];\n          this.reinterpretExpressionAsPattern(property.type === \"SpreadElement\" /* SpreadElement */ ? property : property.value);\n        }\n        break;\n      case \"AssignmentExpression\" /* AssignmentExpression */:\n        expr.type = \"AssignmentPattern\" /* AssignmentPattern */;\n        delete expr.operator;\n        this.reinterpretExpressionAsPattern(expr.left);\n        break;\n      default:\n        break;\n    }\n  }\n  parseGroupExpression() {\n    let expr;\n    this.expect(\"(\");\n    if (this.match(\")\")) {\n      this.nextToken();\n      if (!this.match(\"=>\")) {\n        this.expect(\"=>\");\n      }\n      expr = {\n        type: ArrowParameterPlaceHolder,\n        params: [],\n        async: false\n      };\n    } else {\n      const startToken = this.lookahead;\n      const params = [];\n      if (this.match(\"...\")) {\n        expr = this.parseRestElement(params);\n        this.expect(\")\");\n        if (!this.match(\"=>\")) {\n          this.expect(\"=>\");\n        }\n        expr = {\n          type: ArrowParameterPlaceHolder,\n          params: [expr],\n          async: false\n        };\n      } else {\n        let arrow = false;\n        this.context.isBindingElement = true;\n        expr = this.inheritCoverGrammar(this.parseAssignmentExpression);\n        if (this.match(\",\")) {\n          const expressions = [];\n          this.context.isAssignmentTarget = false;\n          expressions.push(expr);\n          while (this.lookahead.type !== 2 /* EOF */) {\n            if (!this.match(\",\")) {\n              break;\n            }\n            this.nextToken();\n            if (this.match(\")\")) {\n              this.nextToken();\n              for (let i = 0; i < expressions.length; i++) {\n                this.reinterpretExpressionAsPattern(expressions[i]);\n              }\n              arrow = true;\n              expr = {\n                type: ArrowParameterPlaceHolder,\n                params: expressions,\n                async: false\n              };\n            } else if (this.match(\"...\")) {\n              if (!this.context.isBindingElement) {\n                this.throwUnexpectedToken(this.lookahead);\n              }\n              expressions.push(this.parseRestElement(params));\n              this.expect(\")\");\n              if (!this.match(\"=>\")) {\n                this.expect(\"=>\");\n              }\n              this.context.isBindingElement = false;\n              for (let i = 0; i < expressions.length; i++) {\n                this.reinterpretExpressionAsPattern(expressions[i]);\n              }\n              arrow = true;\n              expr = {\n                type: ArrowParameterPlaceHolder,\n                params: expressions,\n                async: false\n              };\n            } else {\n              expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));\n            }\n            if (arrow) {\n              break;\n            }\n          }\n          if (!arrow) {\n            expr = this.finalize(this.startNode(startToken), new SequenceExpression(expressions));\n          }\n        }\n        if (!arrow) {\n          this.expect(\")\");\n          if (this.match(\"=>\")) {\n            if (expr.type === \"Identifier\" /* Identifier */ && expr.name === \"yield\") {\n              arrow = true;\n              expr = {\n                type: ArrowParameterPlaceHolder,\n                params: [expr],\n                async: false\n              };\n            }\n            if (!arrow) {\n              if (!this.context.isBindingElement) {\n                this.throwUnexpectedToken(this.lookahead);\n              }\n              if (expr.type === \"SequenceExpression\" /* SequenceExpression */) {\n                for (let i = 0; i < expr.expressions.length; i++) {\n                  this.reinterpretExpressionAsPattern(expr.expressions[i]);\n                }\n              } else {\n                this.reinterpretExpressionAsPattern(expr);\n              }\n              const parameters = expr.type === \"SequenceExpression\" /* SequenceExpression */ ? expr.expressions : [expr];\n              expr = {\n                type: ArrowParameterPlaceHolder,\n                params: parameters,\n                async: false\n              };\n            }\n          }\n          this.context.isBindingElement = false;\n        }\n      }\n    }\n    return expr;\n  }\n  // https://tc39.github.io/ecma262/#sec-left-hand-side-expressions\n  parseArguments() {\n    this.expect(\"(\");\n    const args = [];\n    if (!this.match(\")\")) {\n      while (true) {\n        const expr = this.match(\"...\") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAssignmentExpression);\n        args.push(expr);\n        if (this.match(\")\")) {\n          break;\n        }\n        this.expectCommaSeparator();\n        if (this.match(\")\")) {\n          break;\n        }\n      }\n    }\n    this.expect(\")\");\n    return args;\n  }\n  isIdentifierName(token) {\n    return token.type === 3 /* Identifier */ || token.type === 4 /* Keyword */ || token.type === 1 /* BooleanLiteral */ || token.type === 5 /* NullLiteral */;\n  }\n  parseIdentifierName(allowPrivateField = false) {\n    let isPrivateField = false;\n    let node = this.createNode();\n    let token = this.nextToken();\n    if (token.value === \"#\" && allowPrivateField) {\n      token = this.nextToken();\n      isPrivateField = true;\n    }\n    if (!this.isIdentifierName(token)) {\n      this.throwUnexpectedToken(token);\n    }\n    return this.finalize(node, isPrivateField ? new PrivateIdentifier(token.value) : new Identifier(token.value));\n  }\n  parseNewExpression() {\n    const node = this.createNode();\n    const id = this.parseIdentifierName();\n    assert(id.name === \"new\", \"New expression must start with `new`\");\n    let expr;\n    if (this.match(\".\")) {\n      this.nextToken();\n      if (this.lookahead.type === 3 /* Identifier */ && this.context.inFunctionBody && this.lookahead.value === \"target\") {\n        const property = this.parseIdentifierName();\n        expr = new MetaProperty(id, property);\n      } else {\n        this.throwUnexpectedToken(this.lookahead);\n      }\n    } else if (this.matchKeyword(\"import\")) {\n      this.throwUnexpectedToken(this.lookahead);\n    } else {\n      const callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression);\n      const args = this.match(\"(\") ? this.parseArguments() : [];\n      expr = new NewExpression(callee, args);\n      this.context.isAssignmentTarget = false;\n      this.context.isBindingElement = false;\n    }\n    return this.finalize(node, expr);\n  }\n  parseAsyncArgument() {\n    const arg = this.parseAssignmentExpression();\n    this.context.firstCoverInitializedNameError = null;\n    return arg;\n  }\n  parseAsyncArguments() {\n    this.expect(\"(\");\n    const args = [];\n    if (!this.match(\")\")) {\n      while (true) {\n        const expr = this.match(\"...\") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAsyncArgument);\n        args.push(expr);\n        if (this.match(\")\")) {\n          break;\n        }\n        this.expectCommaSeparator();\n        if (this.match(\")\")) {\n          break;\n        }\n      }\n    }\n    this.expect(\")\");\n    return args;\n  }\n  matchImportCall() {\n    let match = this.matchKeyword(\"import\");\n    if (match) {\n      const state = this.scanner.saveState();\n      this.scanner.scanComments();\n      const next = this.scanner.lex();\n      this.scanner.restoreState(state);\n      match = next.type === 7 /* Punctuator */ && next.value === \"(\";\n    }\n    return match;\n  }\n  parseImportCall() {\n    const node = this.createNode();\n    this.expectKeyword(\"import\");\n    this.expect(\"(\");\n    var previousIsAssignmentTarget = this.context.isAssignmentTarget;\n    this.context.isAssignmentTarget = true;\n    const source = this.parseAssignmentExpression();\n    let attributes = null;\n    if (this.match(\",\")) {\n      this.nextToken();\n      if (!this.match(\")\"))\n        attributes = this.parseAssignmentExpression();\n    }\n    this.context.isAssignmentTarget = previousIsAssignmentTarget;\n    if (!this.match(\")\")) {\n      if (this.match(\",\")) {\n        this.nextToken();\n      }\n      this.expect(\")\");\n    } else {\n      this.nextToken();\n    }\n    return this.finalize(node, new ImportExpression(source, attributes));\n  }\n  matchImportMeta() {\n    let match = this.matchKeyword(\"import\");\n    if (match) {\n      const state = this.scanner.saveState();\n      this.scanner.scanComments();\n      const dot = this.scanner.lex();\n      if (dot.type === 7 /* Punctuator */ && dot.value === \".\") {\n        this.scanner.scanComments();\n        const meta = this.scanner.lex();\n        match = meta.type === 3 /* Identifier */ && meta.value === \"meta\";\n        if (match) {\n          if (meta.end - meta.start !== \"meta\".length) {\n            this.tolerateUnexpectedToken(meta, Messages.InvalidEscapedReservedWord);\n          }\n        }\n      } else {\n        match = false;\n      }\n      this.scanner.restoreState(state);\n    }\n    return match;\n  }\n  parseImportMeta() {\n    const node = this.createNode();\n    const id = this.parseIdentifierName();\n    this.expect(\".\");\n    const property = this.parseIdentifierName();\n    this.context.isAssignmentTarget = false;\n    return this.finalize(node, new MetaProperty(id, property));\n  }\n  parseLeftHandSideExpressionAllowCall() {\n    const startToken = this.lookahead;\n    const maybeAsync = this.matchContextualKeyword(\"async\");\n    const previousAllowIn = this.context.allowIn;\n    this.context.allowIn = true;\n    let expr;\n    const isSuper = this.matchKeyword(\"super\");\n    if (isSuper && this.context.inFunctionBody) {\n      expr = this.createNode();\n      this.nextToken();\n      expr = this.finalize(expr, new Super());\n      if (!this.match(\"(\") && !this.match(\".\") && !this.match(\"[\")) {\n        this.throwUnexpectedToken(this.lookahead);\n      }\n    } else {\n      expr = this.inheritCoverGrammar(this.matchKeyword(\"new\") ? this.parseNewExpression : this.parsePrimaryExpression);\n    }\n    if (isSuper && this.match(\"(\") && (!this.context.inClassConstructor || !this.context.allowSuper)) {\n      this.tolerateError(Messages.UnexpectedSuper);\n    }\n    let hasOptional = false;\n    while (true) {\n      let optional = false;\n      if (this.match(\"?.\")) {\n        optional = true;\n        hasOptional = true;\n        this.expect(\"?.\");\n      }\n      if (this.match(\"(\")) {\n        const asyncArrow = maybeAsync && startToken.lineNumber === this.lookahead.lineNumber;\n        this.context.isBindingElement = false;\n        this.context.isAssignmentTarget = false;\n        const args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();\n        if (expr.type === \"ImportExpression\" /* ImportExpression */ && args.length !== 1) {\n          this.tolerateError(Messages.BadImportCallArity);\n        }\n        expr = this.finalize(this.startNode(startToken), new CallExpression(expr, args, optional));\n        if (asyncArrow && this.match(\"=>\")) {\n          for (let i = 0; i < args.length; ++i) {\n            this.reinterpretExpressionAsPattern(args[i]);\n          }\n          expr = {\n            type: ArrowParameterPlaceHolder,\n            params: args,\n            async: true\n          };\n        }\n      } else if (this.match(\"[\")) {\n        this.context.isBindingElement = false;\n        this.context.isAssignmentTarget = !optional;\n        this.expect(\"[\");\n        const property = this.isolateCoverGrammar(this.parseExpression);\n        this.expect(\"]\");\n        expr = this.finalize(this.startNode(startToken), new MemberExpression(true, expr, property, optional));\n      } else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {\n        if (optional) {\n          this.throwUnexpectedToken(this.lookahead);\n        }\n        if (hasOptional) {\n          this.throwError(Messages.InvalidTaggedTemplateOnOptionalChain);\n        }\n        const quasi = this.parseTemplateLiteral({ isTagged: true });\n        expr = this.finalize(this.startNode(startToken), new TaggedTemplateExpression(expr, quasi));\n      } else if (this.match(\".\") || optional) {\n        this.context.isBindingElement = false;\n        this.context.isAssignmentTarget = !optional;\n        if (!optional) {\n          this.expect(\".\");\n        }\n        const property = this.parseIdentifierName(true);\n        expr = this.finalize(this.startNode(startToken), new MemberExpression(false, expr, property, optional));\n      } else {\n        break;\n      }\n    }\n    this.context.allowIn = previousAllowIn;\n    if (hasOptional) {\n      expr = this.finalize(this.startNode(startToken), new ChainExpression(expr));\n    }\n    return expr;\n  }\n  parseSuper() {\n    const node = this.createNode();\n    this.expectKeyword(\"super\");\n    if (!this.match(\"[\") && !this.match(\".\")) {\n      this.throwUnexpectedToken(this.lookahead);\n    }\n    return this.finalize(node, new Super());\n  }\n  parseLeftHandSideExpression() {\n    assert(this.context.allowIn, \"callee of new expression always allow in keyword.\");\n    const node = this.startNode(this.lookahead);\n    let expr = this.matchKeyword(\"super\") && this.context.inFunctionBody ? this.parseSuper() : this.inheritCoverGrammar(this.matchKeyword(\"new\") ? this.parseNewExpression : this.parsePrimaryExpression);\n    let hasOptional = false;\n    while (true) {\n      let optional = false;\n      if (this.match(\"?.\")) {\n        optional = true;\n        hasOptional = true;\n        this.expect(\"?.\");\n      }\n      if (this.match(\"[\")) {\n        this.context.isBindingElement = false;\n        this.context.isAssignmentTarget = !optional;\n        this.expect(\"[\");\n        const property = this.isolateCoverGrammar(this.parseExpression);\n        this.expect(\"]\");\n        expr = this.finalize(node, new MemberExpression(true, expr, property, optional));\n      } else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {\n        if (optional) {\n          this.throwUnexpectedToken(this.lookahead);\n        }\n        if (hasOptional) {\n          this.throwError(Messages.InvalidTaggedTemplateOnOptionalChain);\n        }\n        const quasi = this.parseTemplateLiteral({ isTagged: true });\n        expr = this.finalize(node, new TaggedTemplateExpression(expr, quasi));\n      } else if (this.match(\".\") || optional) {\n        this.context.isBindingElement = false;\n        this.context.isAssignmentTarget = !optional;\n        if (!optional) {\n          this.expect(\".\");\n        }\n        const property = this.parseIdentifierName();\n        expr = this.finalize(node, new MemberExpression(false, expr, property, optional));\n      } else {\n        break;\n      }\n    }\n    if (hasOptional) {\n      expr = this.finalize(node, new ChainExpression(expr));\n    }\n    return expr;\n  }\n  // https://tc39.github.io/ecma262/#sec-update-expressions\n  parseUpdateExpression() {\n    let expr;\n    const startToken = this.lookahead;\n    if (this.match(\"++\") || this.match(\"--\")) {\n      const node = this.startNode(startToken);\n      const token = this.nextToken();\n      expr = this.inheritCoverGrammar(this.parseUnaryExpression);\n      if (this.context.strict && expr.type === \"Identifier\" /* Identifier */ && this.scanner.isRestrictedWord(expr.name)) {\n        this.tolerateError(Messages.StrictLHSPrefix);\n      }\n      if (!this.context.isAssignmentTarget) {\n        this.tolerateError(Messages.InvalidLHSInAssignment);\n      }\n      const prefix = true;\n      expr = this.finalize(node, new UpdateExpression(token.value, expr, prefix));\n      this.context.isAssignmentTarget = false;\n      this.context.isBindingElement = false;\n    } else {\n      expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);\n      if (!this.hasLineTerminator && this.lookahead.type === 7 /* Punctuator */) {\n        if (this.match(\"++\") || this.match(\"--\")) {\n          if (this.context.strict && expr.type === \"Identifier\" /* Identifier */ && this.scanner.isRestrictedWord(expr.name)) {\n            this.tolerateError(Messages.StrictLHSPostfix);\n          }\n          if (!this.context.isAssignmentTarget) {\n            this.tolerateError(Messages.InvalidLHSInAssignment);\n          }\n          this.context.isAssignmentTarget = false;\n          this.context.isBindingElement = false;\n          const operator = this.nextToken().value;\n          const prefix = false;\n          expr = this.finalize(this.startNode(startToken), new UpdateExpression(operator, expr, prefix));\n        }\n      }\n    }\n    return expr;\n  }\n  // https://tc39.github.io/ecma262/#sec-unary-operators\n  parseAwaitExpression() {\n    const node = this.createNode();\n    this.nextToken();\n    const argument = this.parseUnaryExpression();\n    return this.finalize(node, new AwaitExpression(argument));\n  }\n  parseUnaryExpression() {\n    let expr;\n    if (this.match(\"+\") || this.match(\"-\") || this.match(\"~\") || this.match(\"!\") || this.matchKeyword(\"delete\") || this.matchKeyword(\"void\") || this.matchKeyword(\"typeof\")) {\n      const node = this.startNode(this.lookahead);\n      const token = this.nextToken();\n      expr = this.inheritCoverGrammar(this.parseUnaryExpression);\n      expr = this.finalize(node, new UnaryExpression(token.value, expr));\n      if (this.context.strict && expr.operator === \"delete\" && expr.argument.type === \"Identifier\" /* Identifier */) {\n        this.tolerateError(Messages.StrictDelete);\n      }\n      this.context.isAssignmentTarget = false;\n      this.context.isBindingElement = false;\n    } else if ((this.context.isModule && !this.context.inFunctionBody || this.context.isAsync) && this.matchContextualKeyword(\"await\")) {\n      expr = this.parseAwaitExpression();\n    } else {\n      expr = this.parseUpdateExpression();\n    }\n    return expr;\n  }\n  parseExponentiationExpression() {\n    const startToken = this.lookahead;\n    const isLeftParenthesized = this.match(\"(\");\n    let expr = this.inheritCoverGrammar(this.parseUnaryExpression);\n    const exponentAllowed = expr.type !== \"UnaryExpression\" /* UnaryExpression */ || isLeftParenthesized;\n    if (exponentAllowed && this.match(\"**\")) {\n      this.nextToken();\n      this.context.isAssignmentTarget = false;\n      this.context.isBindingElement = false;\n      const left = expr;\n      const right = this.isolateCoverGrammar(this.parseExponentiationExpression);\n      expr = this.finalize(this.startNode(startToken), new BinaryExpression(\"**\", left, right));\n    }\n    return expr;\n  }\n  // https://tc39.github.io/ecma262/#sec-exp-operator\n  // https://tc39.github.io/ecma262/#sec-multiplicative-operators\n  // https://tc39.github.io/ecma262/#sec-additive-operators\n  // https://tc39.github.io/ecma262/#sec-bitwise-shift-operators\n  // https://tc39.github.io/ecma262/#sec-relational-operators\n  // https://tc39.github.io/ecma262/#sec-equality-operators\n  // https://tc39.github.io/ecma262/#sec-binary-bitwise-operators\n  // https://tc39.github.io/ecma262/#sec-binary-logical-operators\n  binaryPrecedence(token) {\n    const op = token.value;\n    let precedence;\n    if (token.type === 7 /* Punctuator */) {\n      precedence = this.operatorPrecedence[op] || 0;\n    } else if (token.type === 4 /* Keyword */) {\n      precedence = op === \"instanceof\" || this.context.allowIn && op === \"in\" ? 12 : 0;\n    } else {\n      precedence = 0;\n    }\n    return precedence;\n  }\n  parseBinaryExpression() {\n    const startToken = this.lookahead;\n    let expr = this.inheritCoverGrammar(this.parseExponentiationExpression);\n    let allowAndOr = true;\n    let allowNullishCoalescing = true;\n    const updateNullishCoalescingRestrictions = (token2) => {\n      if (token2.value === \"&&\" || token2.value === \"||\") {\n        allowNullishCoalescing = false;\n      }\n      if (token2.value === \"??\") {\n        allowAndOr = false;\n      }\n    };\n    const token = this.lookahead;\n    let prec = this.binaryPrecedence(token);\n    if (prec > 0) {\n      updateNullishCoalescingRestrictions(token);\n      this.nextToken();\n      this.context.isAssignmentTarget = false;\n      this.context.isBindingElement = false;\n      const markers = [startToken, this.lookahead];\n      let left = expr;\n      let right = this.isolateCoverGrammar(this.parseExponentiationExpression);\n      const stack = [left, token.value, right];\n      const precedences = [prec];\n      while (true) {\n        prec = this.binaryPrecedence(this.lookahead);\n        if (prec <= 0) {\n          break;\n        }\n        if (!allowAndOr && (this.lookahead.value === \"&&\" || this.lookahead.value === \"||\") || !allowNullishCoalescing && this.lookahead.value === \"??\") {\n          this.throwUnexpectedToken(this.lookahead);\n        }\n        updateNullishCoalescingRestrictions(this.lookahead);\n        while (stack.length > 2 && prec <= precedences[precedences.length - 1]) {\n          right = stack.pop();\n          const operator = stack.pop();\n          precedences.pop();\n          left = stack.pop();\n          markers.pop();\n          const marker = markers[markers.length - 1];\n          const node = this.startNode(marker, marker.lineStart);\n          const logical = operator === \"||\" || operator === \"&&\" || operator === \"??\";\n          stack.push(this.finalize(node, logical ? new LogicalExpression(operator, left, right) : new BinaryExpression(operator, left, right)));\n        }\n        stack.push(this.nextToken().value);\n        precedences.push(prec);\n        markers.push(this.lookahead);\n        stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));\n      }\n      let i = stack.length - 1;\n      expr = stack[i];\n      let lastMarker = markers.pop();\n      while (i > 1) {\n        const marker = markers.pop();\n        const lastLineStart = lastMarker && lastMarker.lineStart;\n        const node = this.startNode(marker, lastLineStart);\n        const operator = stack[i - 1];\n        const logical = operator === \"||\" || operator === \"&&\" || operator === \"??\";\n        expr = this.finalize(node, logical ? new LogicalExpression(operator, stack[i - 2], expr) : new BinaryExpression(operator, stack[i - 2], expr));\n        i -= 2;\n        lastMarker = marker;\n      }\n    }\n    return expr;\n  }\n  // https://tc39.github.io/ecma262/#sec-conditional-operator\n  parseConditionalExpression() {\n    const startToken = this.lookahead;\n    let expr = this.inheritCoverGrammar(this.parseBinaryExpression);\n    if (this.match(\"?\")) {\n      this.nextToken();\n      const previousAllowIn = this.context.allowIn;\n      this.context.allowIn = true;\n      const consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);\n      this.context.allowIn = previousAllowIn;\n      this.expect(\":\");\n      const alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);\n      expr = this.finalize(this.startNode(startToken), new ConditionalExpression(expr, consequent, alternate));\n      this.context.isAssignmentTarget = false;\n      this.context.isBindingElement = false;\n    }\n    return expr;\n  }\n  // https://tc39.github.io/ecma262/#sec-assignment-operators\n  checkPatternParam(options, param) {\n    switch (param.type) {\n      case \"Identifier\" /* Identifier */:\n        this.validateParam(options, param, param.name);\n        break;\n      case \"RestElement\" /* RestElement */:\n        this.checkPatternParam(options, param.argument);\n        break;\n      case \"AssignmentPattern\" /* AssignmentPattern */:\n        this.checkPatternParam(options, param.left);\n        break;\n      case \"ArrayPattern\" /* ArrayPattern */:\n        for (let i = 0; i < param.elements.length; i++) {\n          if (param.elements[i] !== null) {\n            this.checkPatternParam(options, param.elements[i]);\n          }\n        }\n        break;\n      case \"ObjectPattern\" /* ObjectPattern */:\n        for (let i = 0; i < param.properties.length; i++) {\n          const property = param.properties[i];\n          this.checkPatternParam(options, property.type === \"RestElement\" /* RestElement */ ? property : property.value);\n        }\n        break;\n      default:\n        break;\n    }\n    options.simple = options.simple && param instanceof Identifier;\n  }\n  reinterpretAsCoverFormalsList(expr) {\n    let params = [expr];\n    const options = {\n      simple: true,\n      paramSet: {}\n    };\n    let asyncArrow = false;\n    switch (expr.type) {\n      case \"Identifier\" /* Identifier */:\n        break;\n      case ArrowParameterPlaceHolder:\n        params = expr.params;\n        asyncArrow = expr.async;\n        break;\n      default:\n        return null;\n    }\n    for (let i = 0; i < params.length; ++i) {\n      const param = params[i];\n      if (param.type === \"AssignmentPattern\" /* AssignmentPattern */) {\n        if (param.right.type === \"YieldExpression\" /* YieldExpression */) {\n          if (param.right.argument) {\n            this.throwUnexpectedToken(this.lookahead);\n          }\n          param.right.type = \"Identifier\" /* Identifier */;\n          param.right.name = \"yield\";\n          delete param.right.argument;\n          delete param.right.delegate;\n        }\n      } else if (asyncArrow && param.type === \"Identifier\" /* Identifier */ && param.name === \"await\") {\n        this.throwUnexpectedToken(this.lookahead);\n      }\n      this.checkPatternParam(options, param);\n      params[i] = param;\n    }\n    if (this.context.strict || !this.context.allowYield) {\n      for (let i = 0; i < params.length; ++i) {\n        const param = params[i];\n        if (param.type === \"YieldExpression\" /* YieldExpression */) {\n          this.throwUnexpectedToken(this.lookahead);\n        }\n      }\n    }\n    if (options.hasDuplicateParameterNames) {\n      const token = this.context.strict ? options.stricted : options.firstRestricted;\n      this.throwUnexpectedToken(token, Messages.DuplicateParameter);\n    }\n    return {\n      simple: options.simple,\n      params,\n      stricted: options.stricted,\n      firstRestricted: options.firstRestricted,\n      message: options.message\n    };\n  }\n  parseAssignmentExpression() {\n    let expr;\n    if (!this.context.allowYield && this.matchKeyword(\"yield\")) {\n      expr = this.parseYieldExpression();\n    } else {\n      const startToken = this.lookahead;\n      let token = startToken;\n      expr = this.parseConditionalExpression();\n      if (token.type === 3 /* Identifier */ && token.lineNumber === this.lookahead.lineNumber && token.value === \"async\") {\n        if (this.lookahead.type === 3 /* Identifier */ || this.matchKeyword(\"yield\")) {\n          const arg = this.parsePrimaryExpression();\n          this.reinterpretExpressionAsPattern(arg);\n          expr = {\n            type: ArrowParameterPlaceHolder,\n            params: [arg],\n            async: true\n          };\n        }\n      }\n      if (expr.type === ArrowParameterPlaceHolder || this.match(\"=>\")) {\n        this.context.isAssignmentTarget = false;\n        this.context.isBindingElement = false;\n        const isAsync = expr.async;\n        const list = this.reinterpretAsCoverFormalsList(expr);\n        if (list) {\n          if (this.hasLineTerminator) {\n            this.tolerateUnexpectedToken(this.lookahead);\n          }\n          this.context.firstCoverInitializedNameError = null;\n          const previousStrict = this.context.strict;\n          const previousAllowStrictDirective = this.context.allowStrictDirective;\n          this.context.allowStrictDirective = list.simple;\n          const previousAllowYield = this.context.allowYield;\n          const previousIsAsync = this.context.isAsync;\n          this.context.allowYield = true;\n          this.context.isAsync = isAsync;\n          const node = this.startNode(startToken);\n          this.expect(\"=>\");\n          let body;\n          if (this.match(\"{\")) {\n            const previousAllowIn = this.context.allowIn;\n            this.context.allowIn = true;\n            body = this.parseFunctionSourceElements();\n            this.context.allowIn = previousAllowIn;\n          } else {\n            body = this.isolateCoverGrammar(this.parseAssignmentExpression);\n          }\n          const expression = body.type !== \"BlockStatement\" /* BlockStatement */;\n          if (this.context.strict && list.firstRestricted) {\n            this.throwUnexpectedToken(list.firstRestricted, list.message);\n          }\n          if (this.context.strict && list.stricted) {\n            this.tolerateUnexpectedToken(list.stricted, list.message);\n          }\n          expr = this.finalize(node, new ArrowFunctionExpression(list.params, body, expression, isAsync));\n          this.context.strict = previousStrict;\n          this.context.allowStrictDirective = previousAllowStrictDirective;\n          this.context.allowYield = previousAllowYield;\n          this.context.isAsync = previousIsAsync;\n        }\n      } else {\n        if (this.matchAssign()) {\n          if (!this.context.isAssignmentTarget) {\n            this.tolerateError(Messages.InvalidLHSInAssignment);\n          }\n          if (this.context.strict && expr.type === \"Identifier\" /* Identifier */) {\n            const id = expr;\n            if (this.scanner.isRestrictedWord(id.name)) {\n              this.tolerateUnexpectedToken(token, Messages.StrictLHSAssignment);\n            }\n            if (this.scanner.isStrictModeReservedWord(id.name)) {\n              this.tolerateUnexpectedToken(token, Messages.StrictReservedWord);\n            }\n          }\n          if (!this.match(\"=\")) {\n            this.context.isAssignmentTarget = false;\n            this.context.isBindingElement = false;\n          } else {\n            this.reinterpretExpressionAsPattern(expr);\n          }\n          token = this.nextToken();\n          const operator = token.value;\n          const right = this.isolateCoverGrammar(this.parseAssignmentExpression);\n          expr = this.finalize(this.startNode(startToken), new AssignmentExpression(operator, expr, right));\n          this.context.firstCoverInitializedNameError = null;\n        }\n      }\n    }\n    return expr;\n  }\n  // https://tc39.github.io/ecma262/#sec-comma-operator\n  parseExpression() {\n    const startToken = this.lookahead;\n    let expr = this.isolateCoverGrammar(this.parseAssignmentExpression);\n    if (this.match(\",\")) {\n      const expressions = [];\n      expressions.push(expr);\n      while (this.lookahead.type !== 2 /* EOF */) {\n        if (!this.match(\",\")) {\n          break;\n        }\n        this.nextToken();\n        expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));\n      }\n      expr = this.finalize(this.startNode(startToken), new SequenceExpression(expressions));\n    }\n    return expr;\n  }\n  // https://tc39.github.io/ecma262/#sec-block\n  parseStatementListItem() {\n    let statement;\n    this.context.isAssignmentTarget = true;\n    this.context.isBindingElement = true;\n    if (this.lookahead.type === 4 /* Keyword */) {\n      switch (this.lookahead.value) {\n        case \"export\":\n          if (!this.context.isModule) {\n            this.tolerateUnexpectedToken(this.lookahead, Messages.IllegalExportDeclaration);\n          }\n          statement = this.parseExportDeclaration();\n          break;\n        case \"import\":\n          if (this.matchImportCall()) {\n            statement = this.parseExpressionStatement();\n          } else if (this.matchImportMeta()) {\n            statement = this.parseStatement();\n          } else {\n            if (!this.context.isModule) {\n              this.tolerateUnexpectedToken(this.lookahead, Messages.IllegalImportDeclaration);\n            }\n            statement = this.parseImportDeclaration();\n          }\n          break;\n        case \"const\":\n          statement = this.parseLexicalDeclaration({ inFor: false });\n          break;\n        case \"function\":\n          statement = this.parseFunctionDeclaration();\n          break;\n        case \"class\":\n          statement = this.parseClassDeclaration();\n          break;\n        case \"let\":\n          statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: false }) : this.parseStatement();\n          break;\n        default:\n          statement = this.parseStatement();\n          break;\n      }\n    } else {\n      statement = this.parseStatement();\n    }\n    return statement;\n  }\n  parseBlock() {\n    const node = this.createNode();\n    this.expect(\"{\");\n    const block = [];\n    while (true) {\n      if (this.match(\"}\")) {\n        break;\n      }\n      block.push(this.parseStatementListItem());\n    }\n    this.expect(\"}\");\n    return this.finalize(node, new BlockStatement(block));\n  }\n  // https://tc39.github.io/ecma262/#sec-let-and-const-declarations\n  parseLexicalBinding(kind, options) {\n    const node = this.createNode();\n    const params = [];\n    const id = this.parsePattern(params, kind);\n    if (this.context.strict && id.type === \"Identifier\" /* Identifier */) {\n      if (this.scanner.isRestrictedWord(id.name)) {\n        this.tolerateError(Messages.StrictVarName);\n      }\n    }\n    let init = null;\n    if (kind === \"const\") {\n      if (!this.matchKeyword(\"in\") && !this.matchContextualKeyword(\"of\")) {\n        if (this.match(\"=\")) {\n          this.nextToken();\n          init = this.isolateCoverGrammar(this.parseAssignmentExpression);\n        } else {\n          this.throwError(Messages.DeclarationMissingInitializer, \"const\");\n        }\n      }\n    } else if (!options.inFor && id.type !== \"Identifier\" /* Identifier */ || this.match(\"=\")) {\n      this.expect(\"=\");\n      init = this.isolateCoverGrammar(this.parseAssignmentExpression);\n    }\n    return this.finalize(node, new VariableDeclarator(id, init));\n  }\n  parseBindingList(kind, options) {\n    const list = [this.parseLexicalBinding(kind, options)];\n    while (this.match(\",\")) {\n      this.nextToken();\n      list.push(this.parseLexicalBinding(kind, options));\n    }\n    return list;\n  }\n  isLexicalDeclaration() {\n    const state = this.scanner.saveState();\n    this.scanner.scanComments();\n    const next = this.scanner.lex();\n    this.scanner.restoreState(state);\n    return next.type === 3 /* Identifier */ || next.type === 7 /* Punctuator */ && next.value === \"[\" || next.type === 7 /* Punctuator */ && next.value === \"{\" || next.type === 4 /* Keyword */ && next.value === \"let\" || next.type === 4 /* Keyword */ && next.value === \"yield\";\n  }\n  parseLexicalDeclaration(options) {\n    const node = this.createNode();\n    const kind = this.nextToken().value;\n    assert(kind === \"let\" || kind === \"const\", \"Lexical declaration must be either let or const\");\n    const declarations = this.parseBindingList(kind, options);\n    this.consumeSemicolon();\n    return this.finalize(node, new VariableDeclaration(declarations, kind));\n  }\n  /**\n   * This function checks to see if a property is initialized in a Class\n   * e.g.\n   * publicProp = 123;\n   * @returns {Boolean}\n   */\n  isInitializedProperty() {\n    let state = this.scanner.saveState();\n    this.scanner.scanComments();\n    let next = this.scanner.lex();\n    this.scanner.restoreState(state);\n    return this.lookahead.type === 3 && next.value === \"=\";\n  }\n  /**\n   * This function checks to see if a property is declared in a Class\n   * e.g.\n   * publicProp;\n   * @returns {Boolean}\n   */\n  isDeclaredProperty() {\n    let state = this.scanner.saveState();\n    this.scanner.scanComments();\n    let next = this.scanner.lex();\n    this.scanner.restoreState(state);\n    return this.lookahead.type === 3 && next.value === \";\" || this.lookahead.type === 3 && next.lineNumber !== this.startMarker.line;\n  }\n  // https://tc39.github.io/ecma262/#sec-destructuring-binding-patterns\n  parseBindingRestElement(params, kind) {\n    const node = this.createNode();\n    this.expect(\"...\");\n    const arg = this.parsePattern(params, kind);\n    return this.finalize(node, new RestElement(arg));\n  }\n  parseArrayPattern(params, kind) {\n    const node = this.createNode();\n    this.expect(\"[\");\n    const elements = [];\n    while (!this.match(\"]\")) {\n      if (this.match(\",\")) {\n        this.nextToken();\n        elements.push(null);\n      } else {\n        if (this.match(\"...\")) {\n          elements.push(this.parseBindingRestElement(params, kind));\n          break;\n        } else {\n          elements.push(this.parsePatternWithDefault(params, kind));\n        }\n        if (!this.match(\"]\")) {\n          this.expect(\",\");\n        }\n      }\n    }\n    this.expect(\"]\");\n    return this.finalize(node, new ArrayPattern(elements));\n  }\n  parsePropertyPattern(params, kind) {\n    const node = this.createNode();\n    let computed = false;\n    let shorthand = false;\n    const method = false;\n    let key;\n    let value;\n    if (this.lookahead.type === 3 /* Identifier */) {\n      const keyToken = this.lookahead;\n      key = this.parseVariableIdentifier();\n      const init = this.finalize(node, new Identifier(keyToken.value));\n      if (this.match(\"=\")) {\n        params.push(keyToken);\n        shorthand = true;\n        this.nextToken();\n        const expr = this.parseAssignmentExpression();\n        value = this.finalize(this.startNode(keyToken), new AssignmentPattern(init, expr));\n      } else if (!this.match(\":\")) {\n        params.push(keyToken);\n        shorthand = true;\n        value = init;\n      } else {\n        this.expect(\":\");\n        value = this.parsePatternWithDefault(params, kind);\n      }\n    } else {\n      computed = this.match(\"[\");\n      key = this.parseObjectPropertyKey();\n      this.expect(\":\");\n      value = this.parsePatternWithDefault(params, kind);\n    }\n    return this.finalize(node, new Property(\"init\", key, computed, value, method, shorthand));\n  }\n  parseRestProperty(params) {\n    const node = this.createNode();\n    this.expect(\"...\");\n    const arg = this.parsePattern(params);\n    if (this.match(\"=\")) {\n      this.throwError(Messages.DefaultRestProperty);\n    }\n    if (!this.match(\"}\")) {\n      this.throwError(Messages.PropertyAfterRestProperty);\n    }\n    return this.finalize(node, new RestElement(arg));\n  }\n  parseObjectPattern(params, kind) {\n    const node = this.createNode();\n    const properties = [];\n    this.expect(\"{\");\n    while (!this.match(\"}\")) {\n      properties.push(this.match(\"...\") ? this.parseRestProperty(params) : this.parsePropertyPattern(params, kind));\n      if (!this.match(\"}\")) {\n        this.expect(\",\");\n      }\n    }\n    this.expect(\"}\");\n    return this.finalize(node, new ObjectPattern(properties));\n  }\n  parsePattern(params, kind) {\n    let pattern;\n    if (this.match(\"[\")) {\n      pattern = this.parseArrayPattern(params, kind);\n    } else if (this.match(\"{\")) {\n      pattern = this.parseObjectPattern(params, kind);\n    } else {\n      if (this.matchKeyword(\"let\") && (kind === \"const\" || kind === \"let\")) {\n        this.tolerateUnexpectedToken(this.lookahead, Messages.LetInLexicalBinding);\n      }\n      params.push(this.lookahead);\n      pattern = this.parseVariableIdentifier(kind);\n    }\n    return pattern;\n  }\n  parsePatternWithDefault(params, kind) {\n    const startToken = this.lookahead;\n    let pattern = this.parsePattern(params, kind);\n    if (this.match(\"=\")) {\n      this.nextToken();\n      const previousAllowYield = this.context.allowYield;\n      this.context.allowYield = true;\n      const right = this.isolateCoverGrammar(this.parseAssignmentExpression);\n      this.context.allowYield = previousAllowYield;\n      pattern = this.finalize(this.startNode(startToken), new AssignmentPattern(pattern, right));\n    }\n    return pattern;\n  }\n  // https://tc39.github.io/ecma262/#sec-variable-statement\n  parseVariableIdentifier(kind) {\n    const node = this.createNode();\n    const token = this.nextToken();\n    if (token.type === 4 /* Keyword */ && token.value === \"yield\") {\n      if (this.context.strict) {\n        this.tolerateUnexpectedToken(token, Messages.StrictReservedWord);\n      } else if (!this.context.allowYield) {\n        this.throwUnexpectedToken(token);\n      }\n    } else if (token.type !== 3 /* Identifier */) {\n      if (this.context.strict && token.type === 4 /* Keyword */ && this.scanner.isStrictModeReservedWord(token.value)) {\n        this.tolerateUnexpectedToken(token, Messages.StrictReservedWord);\n      } else {\n        if (this.context.strict || token.value !== \"let\" || kind !== \"var\") {\n          this.throwUnexpectedToken(token);\n        }\n      }\n    } else if ((this.context.isModule || this.context.isAsync) && token.type === 3 /* Identifier */ && token.value === \"await\") {\n      this.tolerateUnexpectedToken(token);\n    }\n    return this.finalize(node, new Identifier(token.value));\n  }\n  parseVariableDeclaration(options) {\n    const node = this.createNode();\n    const params = [];\n    const id = this.parsePattern(params, \"var\");\n    if (this.context.strict && id.type === \"Identifier\" /* Identifier */) {\n      if (this.scanner.isRestrictedWord(id.name)) {\n        this.tolerateError(Messages.StrictVarName);\n      }\n    }\n    let init = null;\n    if (this.match(\"=\")) {\n      this.nextToken();\n      init = this.isolateCoverGrammar(this.parseAssignmentExpression);\n    } else if (id.type !== \"Identifier\" /* Identifier */ && !options.inFor) {\n      this.expect(\"=\");\n    }\n    return this.finalize(node, new VariableDeclarator(id, init));\n  }\n  parseVariableDeclarationList(options) {\n    const opt = { inFor: options.inFor };\n    const list = [];\n    list.push(this.parseVariableDeclaration(opt));\n    while (this.match(\",\")) {\n      this.nextToken();\n      list.push(this.parseVariableDeclaration(opt));\n    }\n    return list;\n  }\n  parseVariableStatement() {\n    const node = this.createNode();\n    this.expectKeyword(\"var\");\n    const declarations = this.parseVariableDeclarationList({ inFor: false });\n    this.consumeSemicolon();\n    return this.finalize(node, new VariableDeclaration(declarations, \"var\"));\n  }\n  // https://tc39.github.io/ecma262/#sec-empty-statement\n  parseEmptyStatement() {\n    const node = this.createNode();\n    this.expect(\";\");\n    return this.finalize(node, new EmptyStatement());\n  }\n  // https://tc39.github.io/ecma262/#sec-expression-statement\n  parseExpressionStatement() {\n    const node = this.createNode();\n    const expr = this.parseExpression();\n    this.consumeSemicolon();\n    return this.finalize(node, new ExpressionStatement(expr));\n  }\n  // https://tc39.github.io/ecma262/#sec-if-statement\n  parseIfClause() {\n    if (this.context.strict && this.matchKeyword(\"function\")) {\n      this.tolerateError(Messages.StrictFunction);\n    }\n    return this.parseStatement();\n  }\n  parseIfStatement() {\n    const node = this.createNode();\n    let consequent;\n    let alternate = null;\n    this.expectKeyword(\"if\");\n    this.expect(\"(\");\n    const test = this.parseExpression();\n    if (!this.match(\")\") && this.config.tolerant) {\n      this.tolerateUnexpectedToken(this.nextToken());\n      consequent = this.finalize(this.createNode(), new EmptyStatement());\n    } else {\n      this.expect(\")\");\n      consequent = this.parseIfClause();\n      if (this.matchKeyword(\"else\")) {\n        this.nextToken();\n        alternate = this.parseIfClause();\n      }\n    }\n    return this.finalize(node, new IfStatement(test, consequent, alternate));\n  }\n  // https://tc39.github.io/ecma262/#sec-do-while-statement\n  parseDoWhileStatement() {\n    const node = this.createNode();\n    this.expectKeyword(\"do\");\n    this.tolerateInvalidLoopStatement();\n    const previousInIteration = this.context.inIteration;\n    this.context.inIteration = true;\n    const body = this.parseStatement();\n    this.context.inIteration = previousInIteration;\n    this.expectKeyword(\"while\");\n    this.expect(\"(\");\n    const test = this.parseExpression();\n    if (!this.match(\")\") && this.config.tolerant) {\n      this.tolerateUnexpectedToken(this.nextToken());\n    } else {\n      this.expect(\")\");\n      if (this.match(\";\")) {\n        this.nextToken();\n      }\n    }\n    return this.finalize(node, new DoWhileStatement(body, test));\n  }\n  // https://tc39.github.io/ecma262/#sec-while-statement\n  parseWhileStatement() {\n    const node = this.createNode();\n    let body;\n    this.expectKeyword(\"while\");\n    this.expect(\"(\");\n    const test = this.parseExpression();\n    if (!this.match(\")\") && this.config.tolerant) {\n      this.tolerateUnexpectedToken(this.nextToken());\n      body = this.finalize(this.createNode(), new EmptyStatement());\n    } else {\n      this.expect(\")\");\n      const previousInIteration = this.context.inIteration;\n      this.context.inIteration = true;\n      body = this.parseStatement();\n      this.context.inIteration = previousInIteration;\n    }\n    return this.finalize(node, new WhileStatement(test, body));\n  }\n  // https://tc39.github.io/ecma262/#sec-for-statement\n  // https://tc39.github.io/ecma262/#sec-for-in-and-for-of-statements\n  parseForStatement() {\n    let init = null;\n    let test = null;\n    let update = null;\n    let forIn = true;\n    let left, right;\n    let _await = false;\n    const node = this.createNode();\n    this.expectKeyword(\"for\");\n    if (this.matchContextualKeyword(\"await\")) {\n      if (!this.context.isAsync) {\n        this.tolerateUnexpectedToken(this.lookahead);\n      }\n      _await = true;\n      this.nextToken();\n    }\n    this.expect(\"(\");\n    if (this.match(\";\")) {\n      this.nextToken();\n    } else {\n      if (this.matchKeyword(\"var\")) {\n        init = this.createNode();\n        this.nextToken();\n        const previousAllowIn = this.context.allowIn;\n        this.context.allowIn = false;\n        const declarations = this.parseVariableDeclarationList({ inFor: true });\n        this.context.allowIn = previousAllowIn;\n        if (!_await && declarations.length === 1 && this.matchKeyword(\"in\")) {\n          const decl = declarations[0];\n          if (decl.init && (decl.id.type === \"ArrayPattern\" /* ArrayPattern */ || decl.id.type === \"ObjectPattern\" /* ObjectPattern */ || this.context.strict)) {\n            this.tolerateError(Messages.ForInOfLoopInitializer, \"for-in\");\n          }\n          init = this.finalize(init, new VariableDeclaration(declarations, \"var\"));\n          this.nextToken();\n          left = init;\n          right = this.parseExpression();\n          init = null;\n        } else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword(\"of\")) {\n          init = this.finalize(init, new VariableDeclaration(declarations, \"var\"));\n          this.nextToken();\n          left = init;\n          right = this.parseAssignmentExpression();\n          init = null;\n          forIn = false;\n        } else {\n          init = this.finalize(init, new VariableDeclaration(declarations, \"var\"));\n          this.expect(\";\");\n        }\n      } else if (this.matchKeyword(\"const\") || this.matchKeyword(\"let\")) {\n        init = this.createNode();\n        const kind = this.nextToken().value;\n        if (!this.context.strict && this.lookahead.value === \"in\") {\n          init = this.finalize(init, new Identifier(kind));\n          this.nextToken();\n          left = init;\n          right = this.parseExpression();\n          init = null;\n        } else {\n          const previousAllowIn = this.context.allowIn;\n          this.context.allowIn = false;\n          const declarations = this.parseBindingList(kind, { inFor: true });\n          this.context.allowIn = previousAllowIn;\n          if (declarations.length === 1 && declarations[0].init === null && this.matchKeyword(\"in\")) {\n            init = this.finalize(init, new VariableDeclaration(declarations, kind));\n            this.nextToken();\n            left = init;\n            right = this.parseExpression();\n            init = null;\n          } else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword(\"of\")) {\n            init = this.finalize(init, new VariableDeclaration(declarations, kind));\n            this.nextToken();\n            left = init;\n            right = this.parseAssignmentExpression();\n            init = null;\n            forIn = false;\n          } else {\n            this.consumeSemicolon();\n            init = this.finalize(init, new VariableDeclaration(declarations, kind));\n          }\n        }\n      } else {\n        const initStartToken = this.lookahead;\n        const previousIsBindingElement = this.context.isBindingElement;\n        const previousIsAssignmentTarget = this.context.isAssignmentTarget;\n        const previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;\n        const previousAllowIn = this.context.allowIn;\n        this.context.allowIn = false;\n        init = this.inheritCoverGrammar(this.parseAssignmentExpression);\n        this.context.allowIn = previousAllowIn;\n        if (this.matchKeyword(\"in\")) {\n          if (!this.context.isAssignmentTarget || init.type === \"AssignmentExpression\" /* AssignmentExpression */) {\n            this.tolerateError(Messages.InvalidLHSInForIn);\n          }\n          this.nextToken();\n          this.reinterpretExpressionAsPattern(init);\n          left = init;\n          right = this.parseExpression();\n          init = null;\n        } else if (this.matchContextualKeyword(\"of\")) {\n          if (!this.context.isAssignmentTarget || init.type === \"AssignmentExpression\" /* AssignmentExpression */) {\n            this.tolerateError(Messages.InvalidLHSInForLoop);\n          }\n          this.nextToken();\n          this.reinterpretExpressionAsPattern(init);\n          left = init;\n          right = this.parseAssignmentExpression();\n          init = null;\n          forIn = false;\n        } else {\n          this.context.isBindingElement = previousIsBindingElement;\n          this.context.isAssignmentTarget = previousIsAssignmentTarget;\n          this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;\n          if (this.match(\",\")) {\n            const initSeq = [init];\n            while (this.match(\",\")) {\n              this.nextToken();\n              initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));\n            }\n            init = this.finalize(this.startNode(initStartToken), new SequenceExpression(initSeq));\n          }\n          this.expect(\";\");\n        }\n      }\n    }\n    if (typeof left === \"undefined\") {\n      if (!this.match(\";\")) {\n        test = this.isolateCoverGrammar(this.parseExpression);\n      }\n      this.expect(\";\");\n      if (!this.match(\")\")) {\n        update = this.isolateCoverGrammar(this.parseExpression);\n      }\n    }\n    let body;\n    if (!this.match(\")\") && this.config.tolerant) {\n      this.tolerateUnexpectedToken(this.nextToken());\n      body = this.finalize(this.createNode(), new EmptyStatement());\n    } else {\n      this.expect(\")\");\n      this.tolerateInvalidLoopStatement();\n      const previousInIteration = this.context.inIteration;\n      this.context.inIteration = true;\n      body = this.isolateCoverGrammar(this.parseStatement);\n      this.context.inIteration = previousInIteration;\n    }\n    return typeof left === \"undefined\" ? this.finalize(node, new ForStatement(init, test, update, body)) : forIn ? this.finalize(node, new ForInStatement(left, right, body)) : this.finalize(node, new ForOfStatement(left, right, body, _await));\n  }\n  // https://tc39.github.io/ecma262/#sec-continue-statement\n  parseContinueStatement() {\n    const node = this.createNode();\n    this.expectKeyword(\"continue\");\n    let label = null;\n    if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {\n      const id = this.parseVariableIdentifier();\n      label = id;\n      const key = \"$\" + id.name;\n      if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {\n        this.throwError(Messages.UnknownLabel, id.name);\n      }\n    }\n    this.consumeSemicolon();\n    if (label === null && !this.context.inIteration) {\n      this.throwError(Messages.IllegalContinue);\n    }\n    return this.finalize(node, new ContinueStatement(label));\n  }\n  // https://tc39.github.io/ecma262/#sec-break-statement\n  parseBreakStatement() {\n    const node = this.createNode();\n    this.expectKeyword(\"break\");\n    let label = null;\n    if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {\n      const id = this.parseVariableIdentifier();\n      const key = \"$\" + id.name;\n      if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {\n        this.throwError(Messages.UnknownLabel, id.name);\n      }\n      label = id;\n    }\n    this.consumeSemicolon();\n    if (label === null && !this.context.inIteration && !this.context.inSwitch) {\n      this.throwError(Messages.IllegalBreak);\n    }\n    return this.finalize(node, new BreakStatement(label));\n  }\n  // https://tc39.github.io/ecma262/#sec-return-statement\n  parseReturnStatement() {\n    if (!this.context.inFunctionBody) {\n      this.tolerateError(Messages.IllegalReturn);\n    }\n    const node = this.createNode();\n    this.expectKeyword(\"return\");\n    const hasArgument = !this.match(\";\") && !this.match(\"}\") && !this.hasLineTerminator && this.lookahead.type !== 2 /* EOF */ || this.lookahead.type === 8 /* StringLiteral */ || this.lookahead.type === 10 /* Template */;\n    const argument = hasArgument ? this.parseExpression() : null;\n    this.consumeSemicolon();\n    return this.finalize(node, new ReturnStatement(argument));\n  }\n  // https://tc39.github.io/ecma262/#sec-with-statement\n  parseWithStatement() {\n    if (this.context.strict) {\n      this.tolerateError(Messages.StrictModeWith);\n    }\n    const node = this.createNode();\n    let body;\n    this.expectKeyword(\"with\");\n    this.expect(\"(\");\n    const object = this.parseExpression();\n    if (!this.match(\")\") && this.config.tolerant) {\n      this.tolerateUnexpectedToken(this.nextToken());\n      body = this.finalize(this.createNode(), new EmptyStatement());\n    } else {\n      this.expect(\")\");\n      body = this.parseStatement();\n    }\n    return this.finalize(node, new WithStatement(object, body));\n  }\n  // https://tc39.github.io/ecma262/#sec-switch-statement\n  parseSwitchCase() {\n    const node = this.createNode();\n    let test;\n    if (this.matchKeyword(\"default\")) {\n      this.nextToken();\n      test = null;\n    } else {\n      this.expectKeyword(\"case\");\n      test = this.parseExpression();\n    }\n    this.expect(\":\");\n    const consequent = [];\n    while (true) {\n      if (this.match(\"}\") || this.matchKeyword(\"default\") || this.matchKeyword(\"case\")) {\n        break;\n      }\n      consequent.push(this.parseStatementListItem());\n    }\n    return this.finalize(node, new SwitchCase(test, consequent));\n  }\n  parseSwitchStatement() {\n    const node = this.createNode();\n    this.expectKeyword(\"switch\");\n    this.expect(\"(\");\n    const discriminant = this.parseExpression();\n    this.expect(\")\");\n    const previousInSwitch = this.context.inSwitch;\n    this.context.inSwitch = true;\n    const cases = [];\n    let defaultFound = false;\n    this.expect(\"{\");\n    while (true) {\n      if (this.match(\"}\")) {\n        break;\n      }\n      const clause = this.parseSwitchCase();\n      if (clause.test === null) {\n        if (defaultFound) {\n          this.throwError(Messages.MultipleDefaultsInSwitch);\n        }\n        defaultFound = true;\n      }\n      cases.push(clause);\n    }\n    this.expect(\"}\");\n    this.context.inSwitch = previousInSwitch;\n    return this.finalize(node, new SwitchStatement(discriminant, cases));\n  }\n  // https://tc39.github.io/ecma262/#sec-labelled-statements\n  parseLabelledStatement() {\n    const node = this.createNode();\n    const expr = this.parseExpression();\n    let statement;\n    if (expr.type === \"Identifier\" /* Identifier */ && this.match(\":\")) {\n      this.nextToken();\n      const id = expr;\n      const key = \"$\" + id.name;\n      if (Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {\n        this.throwError(Messages.Redeclaration, \"Label\", id.name);\n      }\n      this.context.labelSet[key] = true;\n      let body;\n      if (this.matchKeyword(\"class\")) {\n        this.tolerateUnexpectedToken(this.lookahead);\n        body = this.parseClassDeclaration();\n      } else if (this.matchKeyword(\"function\")) {\n        const token = this.lookahead;\n        const declaration = this.parseFunctionDeclaration();\n        if (this.context.strict) {\n          this.tolerateUnexpectedToken(token, Messages.StrictFunction);\n        } else if (declaration.generator) {\n          this.tolerateUnexpectedToken(token, Messages.GeneratorInLegacyContext);\n        }\n        body = declaration;\n      } else {\n        body = this.parseStatement();\n      }\n      delete this.context.labelSet[key];\n      statement = new LabeledStatement(id, body);\n    } else {\n      this.consumeSemicolon();\n      statement = new ExpressionStatement(expr);\n    }\n    return this.finalize(node, statement);\n  }\n  // https://tc39.github.io/ecma262/#sec-throw-statement\n  parseThrowStatement() {\n    const node = this.createNode();\n    this.expectKeyword(\"throw\");\n    if (this.hasLineTerminator) {\n      this.throwError(Messages.NewlineAfterThrow);\n    }\n    const argument = this.parseExpression();\n    this.consumeSemicolon();\n    return this.finalize(node, new ThrowStatement(argument));\n  }\n  // https://tc39.github.io/ecma262/#sec-try-statement\n  parseCatchClause() {\n    const node = this.createNode();\n    this.expectKeyword(\"catch\");\n    let param = null;\n    if (this.match(\"(\")) {\n      this.expect(\"(\");\n      if (this.match(\")\")) {\n        this.throwUnexpectedToken(this.lookahead);\n      }\n      const params = [];\n      param = this.parsePattern(params);\n      const paramMap = {};\n      for (let i = 0; i < params.length; i++) {\n        const key = \"$\" + params[i].value;\n        if (Object.prototype.hasOwnProperty.call(paramMap, key)) {\n          this.tolerateError(Messages.DuplicateBinding, params[i].value);\n        }\n        paramMap[key] = true;\n      }\n      if (this.context.strict && param.type === \"Identifier\" /* Identifier */) {\n        if (this.scanner.isRestrictedWord(param.name)) {\n          this.tolerateError(Messages.StrictCatchVariable);\n        }\n      }\n      this.expect(\")\");\n    }\n    const body = this.parseBlock();\n    return this.finalize(node, new CatchClause(param, body));\n  }\n  parseFinallyClause() {\n    this.expectKeyword(\"finally\");\n    return this.parseBlock();\n  }\n  parseTryStatement() {\n    const node = this.createNode();\n    this.expectKeyword(\"try\");\n    const block = this.parseBlock();\n    const handler = this.matchKeyword(\"catch\") ? this.parseCatchClause() : null;\n    const finalizer = this.matchKeyword(\"finally\") ? this.parseFinallyClause() : null;\n    if (!handler && !finalizer) {\n      this.throwError(Messages.NoCatchOrFinally);\n    }\n    return this.finalize(node, new TryStatement(block, handler, finalizer));\n  }\n  // https://tc39.github.io/ecma262/#sec-debugger-statement\n  parseDebuggerStatement() {\n    const node = this.createNode();\n    this.expectKeyword(\"debugger\");\n    this.consumeSemicolon();\n    return this.finalize(node, new DebuggerStatement());\n  }\n  // https://tc39.github.io/ecma262/#sec-ecmascript-language-statements-and-declarations\n  parseStatement() {\n    let statement;\n    switch (this.lookahead.type) {\n      case 1 /* BooleanLiteral */:\n      case 5 /* NullLiteral */:\n      case 6 /* NumericLiteral */:\n      case 8 /* StringLiteral */:\n      case 10 /* Template */:\n      case 9 /* RegularExpression */:\n        statement = this.parseExpressionStatement();\n        break;\n      case 7 /* Punctuator */:\n        const value = this.lookahead.value;\n        if (value === \"{\") {\n          statement = this.parseBlock();\n        } else if (value === \"(\") {\n          statement = this.parseExpressionStatement();\n        } else if (value === \";\") {\n          statement = this.parseEmptyStatement();\n        } else {\n          statement = this.parseExpressionStatement();\n        }\n        break;\n      case 3 /* Identifier */:\n        statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();\n        break;\n      case 4 /* Keyword */:\n        switch (this.lookahead.value) {\n          case \"break\":\n            statement = this.parseBreakStatement();\n            break;\n          case \"continue\":\n            statement = this.parseContinueStatement();\n            break;\n          case \"debugger\":\n            statement = this.parseDebuggerStatement();\n            break;\n          case \"do\":\n            statement = this.parseDoWhileStatement();\n            break;\n          case \"for\":\n            statement = this.parseForStatement();\n            break;\n          case \"function\":\n            statement = this.parseFunctionDeclaration();\n            break;\n          case \"if\":\n            statement = this.parseIfStatement();\n            break;\n          case \"return\":\n            statement = this.parseReturnStatement();\n            break;\n          case \"switch\":\n            statement = this.parseSwitchStatement();\n            break;\n          case \"throw\":\n            statement = this.parseThrowStatement();\n            break;\n          case \"try\":\n            statement = this.parseTryStatement();\n            break;\n          case \"var\":\n            statement = this.parseVariableStatement();\n            break;\n          case \"while\":\n            statement = this.parseWhileStatement();\n            break;\n          case \"with\":\n            statement = this.parseWithStatement();\n            break;\n          default:\n            statement = this.parseExpressionStatement();\n            break;\n        }\n        break;\n      default:\n        statement = this.throwUnexpectedToken(this.lookahead);\n    }\n    return statement;\n  }\n  // https://tc39.github.io/ecma262/#sec-function-definitions\n  parseFunctionSourceElements() {\n    const node = this.createNode();\n    this.expect(\"{\");\n    const body = this.parseDirectivePrologues();\n    const previousLabelSet = this.context.labelSet;\n    const previousInIteration = this.context.inIteration;\n    const previousInSwitch = this.context.inSwitch;\n    const previousInFunctionBody = this.context.inFunctionBody;\n    this.context.labelSet = {};\n    this.context.inIteration = false;\n    this.context.inSwitch = false;\n    this.context.inFunctionBody = true;\n    while (this.lookahead.type !== 2 /* EOF */) {\n      if (this.match(\"}\")) {\n        break;\n      }\n      body.push(this.parseStatementListItem());\n    }\n    this.expect(\"}\");\n    this.context.labelSet = previousLabelSet;\n    this.context.inIteration = previousInIteration;\n    this.context.inSwitch = previousInSwitch;\n    this.context.inFunctionBody = previousInFunctionBody;\n    return this.finalize(node, new BlockStatement(body));\n  }\n  validateParam(options, param, name) {\n    const key = \"$\" + name;\n    if (this.context.strict) {\n      if (this.scanner.isRestrictedWord(name)) {\n        options.stricted = param;\n        options.message = Messages.StrictParamName;\n      }\n      if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {\n        options.stricted = param;\n        options.hasDuplicateParameterNames = true;\n      }\n    } else if (!options.firstRestricted) {\n      if (this.scanner.isRestrictedWord(name)) {\n        options.firstRestricted = param;\n        options.message = Messages.StrictParamName;\n      } else if (this.scanner.isStrictModeReservedWord(name)) {\n        options.firstRestricted = param;\n        options.message = Messages.StrictReservedWord;\n      } else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {\n        options.stricted = param;\n        options.hasDuplicateParameterNames = true;\n      }\n    }\n    if (typeof Object.defineProperty === \"function\") {\n      Object.defineProperty(options.paramSet, key, { value: true, enumerable: true, writable: true, configurable: true });\n    } else {\n      options.paramSet[key] = true;\n    }\n  }\n  parseRestElement(params) {\n    const node = this.createNode();\n    this.expect(\"...\");\n    const arg = this.parsePattern(params);\n    if (this.match(\"=\")) {\n      this.throwError(Messages.DefaultRestParameter);\n    }\n    if (!this.match(\")\")) {\n      this.throwError(Messages.ParameterAfterRestParameter);\n    }\n    return this.finalize(node, new RestElement(arg));\n  }\n  parseFormalParameter(options) {\n    const params = [];\n    const param = this.match(\"...\") ? this.parseRestElement(params) : this.parsePatternWithDefault(params);\n    for (let i = 0; i < params.length; i++) {\n      this.validateParam(options, params[i], params[i].value);\n    }\n    options.simple = options.simple && param instanceof Identifier;\n    options.params.push(param);\n  }\n  parseFormalParameters(firstRestricted) {\n    const options = {\n      simple: true,\n      hasDuplicateParameterNames: false,\n      params: [],\n      firstRestricted\n    };\n    this.expect(\"(\");\n    if (!this.match(\")\")) {\n      options.paramSet = {};\n      while (this.lookahead.type !== 2 /* EOF */) {\n        this.parseFormalParameter(options);\n        if (this.match(\")\")) {\n          break;\n        }\n        this.expect(\",\");\n        if (this.match(\")\")) {\n          break;\n        }\n      }\n    }\n    this.expect(\")\");\n    if (options.hasDuplicateParameterNames) {\n      if (this.context.strict || this.context.isAsync || !options.simple) {\n        this.throwError(Messages.DuplicateParameter);\n      }\n    }\n    return {\n      simple: options.simple,\n      params: options.params,\n      stricted: options.stricted,\n      firstRestricted: options.firstRestricted,\n      message: options.message\n    };\n  }\n  matchAsyncFunction() {\n    let match = this.matchContextualKeyword(\"async\");\n    if (match) {\n      const state = this.scanner.saveState();\n      this.scanner.scanComments();\n      const next = this.scanner.lex();\n      this.scanner.restoreState(state);\n      match = state.lineNumber === next.lineNumber && next.type === 4 /* Keyword */ && next.value === \"function\";\n    }\n    return match;\n  }\n  parseFunctionDeclaration(identifierIsOptional) {\n    const node = this.createNode();\n    const isAsync = this.matchContextualKeyword(\"async\");\n    if (isAsync) {\n      if (this.context.inIteration) {\n        this.tolerateError(Messages.AsyncFunctionInSingleStatementContext);\n      }\n      this.nextToken();\n    }\n    this.expectKeyword(\"function\");\n    const isGenerator = this.match(\"*\");\n    if (isGenerator) {\n      this.nextToken();\n    }\n    let message;\n    let id = null;\n    let firstRestricted = null;\n    if (!identifierIsOptional || !this.match(\"(\")) {\n      const token = this.lookahead;\n      id = this.parseVariableIdentifier();\n      if (this.context.strict) {\n        if (this.scanner.isRestrictedWord(token.value)) {\n          this.tolerateUnexpectedToken(token, Messages.StrictFunctionName);\n        }\n      } else {\n        if (this.scanner.isRestrictedWord(token.value)) {\n          firstRestricted = token;\n          message = Messages.StrictFunctionName;\n        } else if (this.scanner.isStrictModeReservedWord(token.value)) {\n          firstRestricted = token;\n          message = Messages.StrictReservedWord;\n        }\n      }\n    }\n    const previousIsAsync = this.context.isAsync;\n    const previousAllowYield = this.context.allowYield;\n    this.context.isAsync = isAsync;\n    this.context.allowYield = !isGenerator;\n    const formalParameters = this.parseFormalParameters(firstRestricted);\n    const params = formalParameters.params;\n    const stricted = formalParameters.stricted;\n    firstRestricted = formalParameters.firstRestricted;\n    if (formalParameters.message) {\n      message = formalParameters.message;\n    }\n    const previousStrict = this.context.strict;\n    const previousAllowStrictDirective = this.context.allowStrictDirective;\n    this.context.allowStrictDirective = formalParameters.simple;\n    const body = this.parseFunctionSourceElements();\n    if (this.context.strict && firstRestricted) {\n      this.throwUnexpectedToken(firstRestricted, message);\n    }\n    if (this.context.strict && stricted) {\n      this.tolerateUnexpectedToken(stricted, message);\n    }\n    this.context.strict = previousStrict;\n    this.context.allowStrictDirective = previousAllowStrictDirective;\n    this.context.isAsync = previousIsAsync;\n    this.context.allowYield = previousAllowYield;\n    return isAsync ? this.finalize(node, new AsyncFunctionDeclaration(id, params, body, isGenerator)) : this.finalize(node, new FunctionDeclaration(id, params, body, isGenerator));\n  }\n  parseFunctionExpression() {\n    const node = this.createNode();\n    const isAsync = this.matchContextualKeyword(\"async\");\n    if (isAsync) {\n      this.nextToken();\n    }\n    this.expectKeyword(\"function\");\n    const isGenerator = this.match(\"*\");\n    if (isGenerator) {\n      this.nextToken();\n    }\n    let message;\n    let id = null;\n    let firstRestricted;\n    const previousIsAsync = this.context.isAsync;\n    const previousAllowYield = this.context.allowYield;\n    this.context.isAsync = isAsync;\n    this.context.allowYield = !isGenerator;\n    if (!this.match(\"(\")) {\n      const token = this.lookahead;\n      id = !this.context.strict && !isGenerator && this.matchKeyword(\"yield\") ? this.parseIdentifierName() : this.parseVariableIdentifier();\n      if (this.context.strict) {\n        if (this.scanner.isRestrictedWord(token.value)) {\n          this.tolerateUnexpectedToken(token, Messages.StrictFunctionName);\n        }\n      } else {\n        if (this.scanner.isRestrictedWord(token.value)) {\n          firstRestricted = token;\n          message = Messages.StrictFunctionName;\n        } else if (this.scanner.isStrictModeReservedWord(token.value)) {\n          firstRestricted = token;\n          message = Messages.StrictReservedWord;\n        }\n      }\n    }\n    const formalParameters = this.parseFormalParameters(firstRestricted);\n    const params = formalParameters.params;\n    const stricted = formalParameters.stricted;\n    firstRestricted = formalParameters.firstRestricted;\n    if (formalParameters.message) {\n      message = formalParameters.message;\n    }\n    const previousStrict = this.context.strict;\n    const previousAllowStrictDirective = this.context.allowStrictDirective;\n    this.context.allowStrictDirective = formalParameters.simple;\n    const body = this.parseFunctionSourceElements();\n    if (this.context.strict && firstRestricted) {\n      this.throwUnexpectedToken(firstRestricted, message);\n    }\n    if (this.context.strict && stricted) {\n      this.tolerateUnexpectedToken(stricted, message);\n    }\n    this.context.strict = previousStrict;\n    this.context.allowStrictDirective = previousAllowStrictDirective;\n    this.context.isAsync = previousIsAsync;\n    this.context.allowYield = previousAllowYield;\n    return this.finalize(node, new FunctionExpression(id, params, body, isGenerator, isAsync));\n  }\n  // https://tc39.github.io/ecma262/#sec-directive-prologues-and-the-use-strict-directive\n  parseDirective() {\n    const token = this.lookahead;\n    const node = this.createNode();\n    const expr = this.parseExpression();\n    const directive = expr.type === \"Literal\" /* Literal */ ? this.getTokenRaw(token).slice(1, -1) : null;\n    this.consumeSemicolon();\n    return this.finalize(node, directive ? new Directive(expr, directive) : new ExpressionStatement(expr));\n  }\n  parseDirectivePrologues() {\n    let firstRestricted = null;\n    const body = [];\n    while (true) {\n      const token = this.lookahead;\n      if (token.type !== 8 /* StringLiteral */) {\n        break;\n      }\n      const statement = this.parseDirective();\n      body.push(statement);\n      const directive = statement.directive;\n      if (typeof directive !== \"string\") {\n        break;\n      }\n      if (directive === \"use strict\") {\n        this.context.strict = true;\n        if (firstRestricted) {\n          this.tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);\n        }\n        if (!this.context.allowStrictDirective) {\n          this.tolerateUnexpectedToken(token, Messages.IllegalLanguageModeDirective);\n        }\n      } else {\n        if (!firstRestricted && token.octal) {\n          firstRestricted = token;\n        }\n      }\n    }\n    return body;\n  }\n  // https://tc39.github.io/ecma262/#sec-method-definitions\n  qualifiedPropertyName(token) {\n    switch (token.type) {\n      case 3 /* Identifier */:\n      case 8 /* StringLiteral */:\n      case 1 /* BooleanLiteral */:\n      case 5 /* NullLiteral */:\n      case 6 /* NumericLiteral */:\n      case 4 /* Keyword */:\n        return true;\n      case 7 /* Punctuator */:\n        return token.value === \"[\" || token.value === \"#\";\n      default:\n        break;\n    }\n    return false;\n  }\n  parseGetterMethod() {\n    const node = this.createNode();\n    const isGenerator = false;\n    const previousAllowYield = this.context.allowYield;\n    this.context.allowYield = !isGenerator;\n    const formalParameters = this.parseFormalParameters();\n    if (formalParameters.params.length > 0) {\n      this.tolerateError(Messages.BadGetterArity);\n    }\n    const method = this.parsePropertyMethod(formalParameters);\n    this.context.allowYield = previousAllowYield;\n    return this.finalize(node, new FunctionExpression(null, formalParameters.params, method, isGenerator, false));\n  }\n  parseSetterMethod() {\n    const node = this.createNode();\n    const isGenerator = false;\n    const previousAllowYield = this.context.allowYield;\n    this.context.allowYield = !isGenerator;\n    const formalParameters = this.parseFormalParameters();\n    if (formalParameters.params.length !== 1) {\n      this.tolerateError(Messages.BadSetterArity);\n    } else if (formalParameters.params[0] instanceof RestElement) {\n      this.tolerateError(Messages.BadSetterRestParameter);\n    }\n    const method = this.parsePropertyMethod(formalParameters);\n    this.context.allowYield = previousAllowYield;\n    return this.finalize(node, new FunctionExpression(null, formalParameters.params, method, isGenerator, false));\n  }\n  parseGeneratorMethod(isAsync) {\n    const node = this.createNode();\n    const isGenerator = true;\n    const previousAllowYield = this.context.allowYield;\n    this.context.allowYield = true;\n    const params = this.parseFormalParameters();\n    this.context.allowYield = false;\n    const method = this.parsePropertyMethod(params);\n    this.context.allowYield = previousAllowYield;\n    return this.finalize(node, new FunctionExpression(null, params.params, method, isGenerator, isAsync));\n  }\n  // https://tc39.github.io/ecma262/#sec-generator-function-definitions\n  isStartOfExpression() {\n    let start = true;\n    const value = this.lookahead.value;\n    switch (this.lookahead.type) {\n      case 7 /* Punctuator */:\n        start = value === \"[\" || value === \"(\" || value === \"{\" || value === \"+\" || value === \"-\" || value === \"!\" || value === \"~\" || value === \"++\" || value === \"--\" || value === \"/\" || value === \"/=\";\n        break;\n      case 4 /* Keyword */:\n        start = value === \"class\" || value === \"delete\" || value === \"function\" || value === \"let\" || value === \"new\" || value === \"super\" || value === \"this\" || value === \"typeof\" || value === \"void\" || value === \"yield\";\n        break;\n      default:\n        break;\n    }\n    return start;\n  }\n  parseYieldExpression() {\n    const node = this.createNode();\n    this.expectKeyword(\"yield\");\n    let argument = null;\n    let delegate = false;\n    if (!this.hasLineTerminator) {\n      const previousAllowYield = this.context.allowYield;\n      this.context.allowYield = false;\n      delegate = this.match(\"*\");\n      if (delegate) {\n        this.nextToken();\n        argument = this.parseAssignmentExpression();\n      } else if (this.isStartOfExpression()) {\n        argument = this.parseAssignmentExpression();\n      }\n      this.context.allowYield = previousAllowYield;\n    }\n    return this.finalize(node, new YieldExpression(argument, delegate));\n  }\n  // https://tc39.github.io/ecma262/#sec-class-definitions\n  parseStaticBlock() {\n    const node = this.createNode();\n    this.expect(\"{\");\n    const block = [];\n    while (true) {\n      if (this.match(\"}\")) {\n        break;\n      }\n      block.push(this.parseStatementListItem());\n    }\n    this.expect(\"}\");\n    return this.finalize(node, new StaticBlock(block));\n  }\n  parseDecorator() {\n    const node = this.createNode();\n    this.expect(\"@\");\n    const previousStrict = this.context.strict;\n    const previousAllowYield = this.context.allowYield;\n    const previousIsAsync = this.context.isAsync;\n    this.context.strict = false;\n    this.context.allowYield = true;\n    this.context.isAsync = false;\n    const expression = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);\n    this.context.strict = previousStrict;\n    this.context.allowYield = previousAllowYield;\n    this.context.isAsync = previousIsAsync;\n    if (this.match(\";\")) {\n      this.throwError(Messages.NoSemicolonAfterDecorator);\n    }\n    return this.finalize(node, new Decorator(expression));\n  }\n  parseDecorators() {\n    let decorators = null;\n    while (this.match(\"@\")) {\n      if (decorators == null)\n        decorators = [];\n      decorators.push(this.parseDecorator());\n    }\n    return decorators;\n  }\n  parseClassElement(hasConstructor) {\n    let token = this.lookahead;\n    const node = this.createNode();\n    const previousInConstructor = this.context.inConstructor;\n    let kind = \"\";\n    let key = null;\n    let value = null;\n    let computed = false;\n    let method = false;\n    let isStatic = false;\n    let isAsync = false;\n    let isGenerator = false;\n    let isPrivate = false;\n    const decorators = this.parseDecorators();\n    if (decorators) {\n      token = this.lookahead;\n    }\n    if (this.match(\"*\")) {\n      this.nextToken();\n    } else {\n      computed = this.match(\"[\");\n      if (this.match(\"#\")) {\n        isPrivate = true;\n        this.nextToken();\n        token = this.lookahead;\n      }\n      key = this.parseObjectPropertyKey(isPrivate);\n      const id = key;\n      this.context.inConstructor = token.type === 3 /* Identifier */ && token.value === \"constructor\";\n      if (id.name === \"static\" && (this.qualifiedPropertyName(this.lookahead) || this.match(\"*\"))) {\n        token = this.lookahead;\n        isStatic = true;\n        computed = this.match(\"[\");\n        if (this.match(\"*\")) {\n          this.nextToken();\n          if (this.match(\"#\")) {\n            isPrivate = true;\n            this.nextToken();\n            token = this.lookahead;\n          }\n        } else {\n          if (this.match(\"#\")) {\n            isPrivate = true;\n            this.nextToken();\n            token = this.lookahead;\n          }\n          key = this.parseObjectPropertyKey(isPrivate);\n        }\n      }\n      if (id.name === \"static\" && this.match(\"{\")) {\n        return this.parseStaticBlock();\n      }\n      if (token.type === 3 /* Identifier */ && !this.hasLineTerminator && token.value === \"async\") {\n        const punctuator = this.lookahead.value;\n        if (punctuator !== \":\" && punctuator !== \"(\") {\n          isAsync = true;\n          isGenerator = this.match(\"*\");\n          if (isGenerator) {\n            this.nextToken();\n          }\n          token = this.lookahead;\n          computed = this.match(\"[\");\n          if (this.match(\"*\")) {\n            this.nextToken();\n            if (this.match(\"#\")) {\n              isPrivate = true;\n              this.nextToken();\n            }\n          } else {\n            if (this.match(\"#\")) {\n              isPrivate = true;\n              this.nextToken();\n              token = this.lookahead;\n            }\n            key = this.parseObjectPropertyKey(isPrivate);\n          }\n          if (token.type === 3 /* Identifier */ && token.value === \"constructor\" && !isStatic) {\n            this.tolerateUnexpectedToken(token, Messages.ConstructorIsAsync);\n          }\n        }\n      }\n    }\n    if (token.type === 3 /* Identifier */ && token.value === \"constructor\" && isPrivate) {\n      this.tolerateUnexpectedToken(token, Messages.ConstructorIsPrivate);\n    }\n    const lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);\n    if (token.type === 3 /* Identifier */ || token.type === 8 /* StringLiteral */) {\n      if (token.value === \"get\" && lookaheadPropertyKey) {\n        kind = \"get\";\n        if (this.match(\"#\")) {\n          isPrivate = true;\n          this.nextToken();\n          token = this.lookahead;\n        }\n        computed = this.match(\"[\");\n        key = this.parseObjectPropertyKey(isPrivate);\n        this.context.allowYield = false;\n        value = this.parseGetterMethod();\n      } else if (token.value === \"set\" && lookaheadPropertyKey) {\n        kind = \"set\";\n        if (this.match(\"#\")) {\n          isPrivate = true;\n          this.nextToken();\n          token = this.lookahead;\n        }\n        computed = this.match(\"[\");\n        key = this.parseObjectPropertyKey(isPrivate);\n        value = this.parseSetterMethod();\n      } else if (!this.match(\"(\")) {\n        kind = \"property\";\n        computed = false;\n        if (this.match(\"=\")) {\n          this.nextToken();\n          value = this.isolateCoverGrammar(this.parseAssignmentExpression);\n        }\n      }\n    } else if (token.type === 7 /* Punctuator */ && token.value === \"*\" && lookaheadPropertyKey) {\n      kind = \"init\";\n      computed = this.match(\"[\");\n      key = this.parseObjectPropertyKey(isPrivate);\n      value = this.parseGeneratorMethod(isAsync);\n      method = true;\n    } else if (token.type === 7 /* Punctuator */ && token.value === \"[\" && !this.match(\"(\")) {\n      kind = \"property\";\n      computed = true;\n      if (this.match(\"=\")) {\n        this.nextToken();\n        value = this.isolateCoverGrammar(this.parseAssignmentExpression);\n      }\n    }\n    if (!kind && key && this.match(\"(\")) {\n      const previousInClassConstructor = this.context.inClassConstructor;\n      this.context.inClassConstructor = token.value === \"constructor\";\n      kind = \"init\";\n      value = isAsync ? this.parsePropertyMethodAsyncFunction(isGenerator) : this.parsePropertyMethodFunction(isGenerator);\n      this.context.inClassConstructor = previousInClassConstructor;\n      method = true;\n    }\n    if (!kind) {\n      this.throwUnexpectedToken(this.lookahead);\n    }\n    if (kind === \"init\") {\n      kind = \"method\";\n    }\n    if (!computed) {\n      if (isStatic && this.isPropertyKey(key, \"prototype\")) {\n        this.throwUnexpectedToken(token, Messages.StaticPrototype);\n      }\n      if (!isStatic && this.isPropertyKey(key, \"constructor\")) {\n        if (kind !== \"method\" || !method || value && value.generator) {\n          this.throwUnexpectedToken(token, Messages.ConstructorSpecialMethod);\n        }\n        if (hasConstructor.value) {\n          this.throwUnexpectedToken(token, Messages.DuplicateConstructor);\n        } else {\n          hasConstructor.value = true;\n        }\n        kind = \"constructor\";\n      }\n    }\n    this.context.inConstructor = previousInConstructor;\n    if (kind === \"property\") {\n      this.consumeSemicolon();\n      return this.finalize(node, new PropertyDefinition(key, computed, value, isStatic, decorators));\n    } else\n      return this.finalize(node, new MethodDefinition(key, computed, value, kind, isStatic, decorators));\n  }\n  parseClassElementList() {\n    const body = [];\n    const hasConstructor = { value: false };\n    this.expect(\"{\");\n    while (!this.match(\"}\")) {\n      if (this.match(\";\")) {\n        this.nextToken();\n      } else {\n        body.push(this.parseClassElement(hasConstructor));\n      }\n    }\n    this.expect(\"}\");\n    return body;\n  }\n  parseClassBody() {\n    const node = this.createNode();\n    const elementList = this.parseClassElementList();\n    return this.finalize(node, new ClassBody(elementList));\n  }\n  parseClassDeclaration(identifierIsOptional) {\n    const node = this.createNode();\n    const previousStrict = this.context.strict;\n    const previousAllowSuper = this.context.allowSuper;\n    this.context.strict = true;\n    this.expectKeyword(\"class\");\n    const id = identifierIsOptional && this.lookahead.type !== 3 /* Identifier */ ? null : this.parseVariableIdentifier();\n    let superClass = null;\n    if (this.matchKeyword(\"extends\")) {\n      this.nextToken();\n      superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);\n      this.context.allowSuper = true;\n    }\n    const classBody = this.parseClassBody();\n    this.context.allowSuper = previousAllowSuper;\n    this.context.strict = previousStrict;\n    return this.finalize(node, new ClassDeclaration(id, superClass, classBody, this.context.decorators));\n  }\n  parseClassExpression() {\n    const node = this.createNode();\n    const previousStrict = this.context.strict;\n    this.context.strict = true;\n    this.expectKeyword(\"class\");\n    const id = this.lookahead.type === 3 /* Identifier */ ? this.parseVariableIdentifier() : null;\n    let superClass = null;\n    if (this.matchKeyword(\"extends\")) {\n      this.nextToken();\n      superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);\n      this.context.allowSuper = true;\n    }\n    const classBody = this.parseClassBody();\n    this.context.strict = previousStrict;\n    return this.finalize(node, new ClassExpression(id, superClass, classBody, this.context.decorators));\n  }\n  // https://tc39.github.io/ecma262/#sec-scripts\n  // https://tc39.github.io/ecma262/#sec-modules\n  parseModule() {\n    this.context.strict = true;\n    this.context.isModule = true;\n    this.scanner.isModule = true;\n    const node = this.createNode();\n    const body = this.parseDirectivePrologues();\n    while (this.lookahead.type !== 2 /* EOF */) {\n      body.push(this.parseStatementListItem());\n    }\n    return this.finalize(node, new Module(body));\n  }\n  parseScript() {\n    const node = this.createNode();\n    const body = this.parseDirectivePrologues();\n    while (this.lookahead.type !== 2 /* EOF */) {\n      body.push(this.parseStatementListItem());\n    }\n    return this.finalize(node, new Script(body));\n  }\n  // https://tc39.github.io/ecma262/#sec-imports\n  parseImportAttributes() {\n    if (this.lookahead.value === \"assert\") {\n      this.nextToken();\n      this.expect(\"{\");\n      const attributes = [];\n      while (!this.match(\"}\")) {\n        attributes.push(this.parseImportAttribute());\n        if (!this.match(\"}\")) {\n          this.expectCommaSeparator();\n        }\n      }\n      this.expect(\"}\");\n      return attributes;\n    }\n    return null;\n  }\n  parseImportAttribute() {\n    const node = this.createNode();\n    if (this.lookahead.type !== 3 /* Identifier */) {\n      this.throwUnexpectedToken(this.nextToken());\n    }\n    const key = this.parseIdentifierName();\n    if (!this.match(\":\")) {\n      this.throwUnexpectedToken(this.nextToken());\n    }\n    this.nextToken();\n    const literalToken = this.nextToken();\n    const raw = this.getTokenRaw(literalToken);\n    const value = this.finalize(node, new Literal(literalToken.value, raw));\n    return this.finalize(node, new ImportAttribute(key, value));\n  }\n  parseModuleSpecifier() {\n    const node = this.createNode();\n    if (this.lookahead.type !== 8 /* StringLiteral */) {\n      this.throwError(Messages.InvalidModuleSpecifier);\n    }\n    const token = this.nextToken();\n    const raw = this.getTokenRaw(token);\n    if (!Character.isStringWellFormedUnicode(token.value)) {\n      this.throwError(Messages.InvalidModuleSpecifier);\n    }\n    return this.finalize(node, new Literal(token.value, raw));\n  }\n  // import {<foo as bar>} ...;\n  parseImportSpecifier() {\n    const node = this.createNode();\n    let imported;\n    let local;\n    if (this.lookahead.type === 3 /* Identifier */) {\n      imported = this.parseVariableIdentifier();\n      local = imported;\n      if (this.matchContextualKeyword(\"as\")) {\n        this.nextToken();\n        local = this.parseVariableIdentifier();\n      }\n    } else {\n      imported = this.lookahead.type == 8 /* StringLiteral */ ? this.parseModuleSpecifier() : this.parseIdentifierName();\n      local = imported;\n      if (this.matchContextualKeyword(\"as\")) {\n        this.nextToken();\n        local = this.parseVariableIdentifier();\n      } else {\n        this.throwUnexpectedToken(this.nextToken());\n      }\n    }\n    return this.finalize(node, new ImportSpecifier(local, imported));\n  }\n  // {foo, bar as bas}\n  parseNamedImports() {\n    this.expect(\"{\");\n    const specifiers = [];\n    while (!this.match(\"}\")) {\n      specifiers.push(this.parseImportSpecifier());\n      if (!this.match(\"}\")) {\n        this.expect(\",\");\n      }\n    }\n    this.expect(\"}\");\n    return specifiers;\n  }\n  // import <foo> ...;\n  parseImportDefaultSpecifier() {\n    const node = this.createNode();\n    const local = this.parseIdentifierName();\n    return this.finalize(node, new ImportDefaultSpecifier(local));\n  }\n  // import <* as foo> ...;\n  parseImportNamespaceSpecifier() {\n    const node = this.createNode();\n    this.expect(\"*\");\n    if (!this.matchContextualKeyword(\"as\")) {\n      this.throwError(Messages.NoAsAfterImportNamespace);\n    }\n    if (this.lookahead.escaped) {\n      this.throwError(Messages.NoAsAndFromEscapeSequences);\n    }\n    this.nextToken();\n    const local = this.parseIdentifierName();\n    return this.finalize(node, new ImportNamespaceSpecifier(local));\n  }\n  parseImportDeclaration() {\n    if (this.context.inFunctionBody) {\n      this.throwError(Messages.IllegalImportDeclaration);\n    }\n    const node = this.createNode();\n    this.expectKeyword(\"import\");\n    let src;\n    let specifiers = [];\n    if (this.lookahead.type === 8 /* StringLiteral */) {\n      src = this.parseModuleSpecifier();\n    } else {\n      if (this.match(\"{\")) {\n        specifiers = specifiers.concat(this.parseNamedImports());\n      } else if (this.match(\"*\")) {\n        specifiers.push(this.parseImportNamespaceSpecifier());\n      } else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword(\"default\")) {\n        specifiers.push(this.parseImportDefaultSpecifier());\n        if (this.match(\",\")) {\n          this.nextToken();\n          if (this.match(\"*\")) {\n            specifiers.push(this.parseImportNamespaceSpecifier());\n          } else if (this.match(\"{\")) {\n            specifiers = specifiers.concat(this.parseNamedImports());\n          } else {\n            this.throwUnexpectedToken(this.lookahead);\n          }\n        }\n      } else {\n        this.throwUnexpectedToken(this.nextToken());\n      }\n      if (!this.matchContextualKeyword(\"from\")) {\n        const message = this.lookahead.value ? Messages.UnexpectedToken : Messages.MissingFromClause;\n        this.throwError(message, this.lookahead.value);\n      }\n      this.nextToken();\n      src = this.parseModuleSpecifier();\n    }\n    const attributes = this.parseImportAttributes();\n    this.consumeSemicolon();\n    return this.finalize(node, new ImportDeclaration(specifiers, src, attributes));\n  }\n  // https://tc39.github.io/ecma262/#sec-exports\n  parseExportSpecifier() {\n    const node = this.createNode();\n    const local = this.lookahead.type == 8 /* StringLiteral */ ? this.parseModuleSpecifier() : this.parseIdentifierName();\n    let exported = local;\n    if (this.matchContextualKeyword(\"as\")) {\n      if (this.lookahead.escaped) {\n        this.throwError(Messages.NoAsAndFromEscapeSequences);\n      }\n      this.nextToken();\n      exported = this.lookahead.type == 8 /* StringLiteral */ ? this.parseModuleSpecifier() : this.parseIdentifierName();\n    }\n    return this.finalize(node, new ExportSpecifier(local, exported));\n  }\n  parseExportDeclaration() {\n    if (this.context.inFunctionBody) {\n      this.throwError(Messages.IllegalExportDeclaration);\n    }\n    const node = this.createNode();\n    this.expectKeyword(\"export\");\n    let exportDeclaration;\n    if (this.matchKeyword(\"default\")) {\n      this.nextToken();\n      if (this.matchKeyword(\"function\")) {\n        const declaration = this.parseFunctionDeclaration(true);\n        exportDeclaration = this.finalize(node, new ExportDefaultDeclaration(declaration));\n      } else if (this.matchKeyword(\"class\")) {\n        const declaration = this.parseClassDeclaration(true);\n        exportDeclaration = this.finalize(node, new ExportDefaultDeclaration(declaration));\n      } else if (this.matchContextualKeyword(\"async\")) {\n        const declaration = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression();\n        exportDeclaration = this.finalize(node, new ExportDefaultDeclaration(declaration));\n      } else {\n        if (this.matchContextualKeyword(\"from\")) {\n          this.throwError(Messages.UnexpectedToken, this.lookahead.value);\n        }\n        const declaration = this.match(\"{\") ? this.parseObjectInitializer() : this.match(\"[\") ? this.parseArrayInitializer() : this.parseAssignmentExpression();\n        this.consumeSemicolon();\n        exportDeclaration = this.finalize(node, new ExportDefaultDeclaration(declaration));\n      }\n    } else if (this.match(\"*\")) {\n      this.nextToken();\n      let exported = null;\n      if (this.matchContextualKeyword(\"as\")) {\n        if (this.lookahead.escaped) {\n          this.throwError(Messages.NoAsAndFromEscapeSequences);\n        }\n        this.nextToken();\n        exported = this.lookahead.type == 8 /* StringLiteral */ ? this.parseModuleSpecifier() : this.parseIdentifierName();\n      }\n      if (!this.matchContextualKeyword(\"from\")) {\n        const message = this.lookahead.value ? Messages.UnexpectedToken : Messages.MissingFromClause;\n        this.throwError(message, this.lookahead.value);\n      }\n      if (this.lookahead.escaped) {\n        this.throwError(Messages.NoAsAndFromEscapeSequences);\n      }\n      this.nextToken();\n      const src = this.parseModuleSpecifier();\n      const attributes = this.parseImportAttributes();\n      this.consumeSemicolon();\n      exportDeclaration = this.finalize(node, new ExportAllDeclaration(src, exported, attributes));\n    } else if (this.lookahead.type === 4 /* Keyword */) {\n      let declaration;\n      switch (this.lookahead.value) {\n        case \"let\":\n        case \"const\":\n          declaration = this.parseLexicalDeclaration({ inFor: false });\n          break;\n        case \"var\":\n        case \"class\":\n        case \"function\":\n          declaration = this.parseStatementListItem();\n          break;\n        default:\n          this.throwUnexpectedToken(this.lookahead);\n      }\n      exportDeclaration = this.finalize(node, new ExportNamedDeclaration(declaration, [], null, null));\n    } else if (this.matchAsyncFunction()) {\n      const declaration = this.parseFunctionDeclaration();\n      exportDeclaration = this.finalize(node, new ExportNamedDeclaration(declaration, [], null, null));\n    } else {\n      const specifiers = [];\n      let source = null;\n      let isExportFromIdentifier = false;\n      let attributes = null;\n      this.expect(\"{\");\n      while (!this.match(\"}\")) {\n        isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword(\"default\");\n        specifiers.push(this.parseExportSpecifier());\n        if (!this.match(\"}\")) {\n          this.expect(\",\");\n        }\n      }\n      this.expect(\"}\");\n      if (this.matchContextualKeyword(\"from\")) {\n        if (this.lookahead.escaped) {\n          this.throwError(Messages.NoAsAndFromEscapeSequences);\n        }\n        this.nextToken();\n        source = this.parseModuleSpecifier();\n        attributes = this.parseImportAttributes();\n        this.consumeSemicolon();\n      } else if (isExportFromIdentifier) {\n        const message = this.lookahead.value ? Messages.UnexpectedToken : Messages.MissingFromClause;\n        this.throwError(message, this.lookahead.value);\n      } else {\n        attributes = this.parseImportAttributes();\n        this.consumeSemicolon();\n      }\n      exportDeclaration = this.finalize(node, new ExportNamedDeclaration(null, specifiers, source, attributes));\n    }\n    return exportDeclaration;\n  }\n};\n\n// src/xhtml-entities.ts\nvar XHTMLEntities = {\n  quot: '\"',\n  amp: \"&\",\n  apos: \"'\",\n  gt: \">\",\n  nbsp: \"\\xA0\",\n  iexcl: \"\\xA1\",\n  cent: \"\\xA2\",\n  pound: \"\\xA3\",\n  curren: \"\\xA4\",\n  yen: \"\\xA5\",\n  brvbar: \"\\xA6\",\n  sect: \"\\xA7\",\n  uml: \"\\xA8\",\n  copy: \"\\xA9\",\n  ordf: \"\\xAA\",\n  laquo: \"\\xAB\",\n  not: \"\\xAC\",\n  shy: \"\\xAD\",\n  reg: \"\\xAE\",\n  macr: \"\\xAF\",\n  deg: \"\\xB0\",\n  plusmn: \"\\xB1\",\n  sup2: \"\\xB2\",\n  sup3: \"\\xB3\",\n  acute: \"\\xB4\",\n  micro: \"\\xB5\",\n  para: \"\\xB6\",\n  middot: \"\\xB7\",\n  cedil: \"\\xB8\",\n  sup1: \"\\xB9\",\n  ordm: \"\\xBA\",\n  raquo: \"\\xBB\",\n  frac14: \"\\xBC\",\n  frac12: \"\\xBD\",\n  frac34: \"\\xBE\",\n  iquest: \"\\xBF\",\n  Agrave: \"\\xC0\",\n  Aacute: \"\\xC1\",\n  Acirc: \"\\xC2\",\n  Atilde: \"\\xC3\",\n  Auml: \"\\xC4\",\n  Aring: \"\\xC5\",\n  AElig: \"\\xC6\",\n  Ccedil: \"\\xC7\",\n  Egrave: \"\\xC8\",\n  Eacute: \"\\xC9\",\n  Ecirc: \"\\xCA\",\n  Euml: \"\\xCB\",\n  Igrave: \"\\xCC\",\n  Iacute: \"\\xCD\",\n  Icirc: \"\\xCE\",\n  Iuml: \"\\xCF\",\n  ETH: \"\\xD0\",\n  Ntilde: \"\\xD1\",\n  Ograve: \"\\xD2\",\n  Oacute: \"\\xD3\",\n  Ocirc: \"\\xD4\",\n  Otilde: \"\\xD5\",\n  Ouml: \"\\xD6\",\n  times: \"\\xD7\",\n  Oslash: \"\\xD8\",\n  Ugrave: \"\\xD9\",\n  Uacute: \"\\xDA\",\n  Ucirc: \"\\xDB\",\n  Uuml: \"\\xDC\",\n  Yacute: \"\\xDD\",\n  THORN: \"\\xDE\",\n  szlig: \"\\xDF\",\n  agrave: \"\\xE0\",\n  aacute: \"\\xE1\",\n  acirc: \"\\xE2\",\n  atilde: \"\\xE3\",\n  auml: \"\\xE4\",\n  aring: \"\\xE5\",\n  aelig: \"\\xE6\",\n  ccedil: \"\\xE7\",\n  egrave: \"\\xE8\",\n  eacute: \"\\xE9\",\n  ecirc: \"\\xEA\",\n  euml: \"\\xEB\",\n  igrave: \"\\xEC\",\n  iacute: \"\\xED\",\n  icirc: \"\\xEE\",\n  iuml: \"\\xEF\",\n  eth: \"\\xF0\",\n  ntilde: \"\\xF1\",\n  ograve: \"\\xF2\",\n  oacute: \"\\xF3\",\n  ocirc: \"\\xF4\",\n  otilde: \"\\xF5\",\n  ouml: \"\\xF6\",\n  divide: \"\\xF7\",\n  oslash: \"\\xF8\",\n  ugrave: \"\\xF9\",\n  uacute: \"\\xFA\",\n  ucirc: \"\\xFB\",\n  uuml: \"\\xFC\",\n  yacute: \"\\xFD\",\n  thorn: \"\\xFE\",\n  yuml: \"\\xFF\",\n  OElig: \"\\u0152\",\n  oelig: \"\\u0153\",\n  Scaron: \"\\u0160\",\n  scaron: \"\\u0161\",\n  Yuml: \"\\u0178\",\n  fnof: \"\\u0192\",\n  circ: \"\\u02C6\",\n  tilde: \"\\u02DC\",\n  Alpha: \"\\u0391\",\n  Beta: \"\\u0392\",\n  Gamma: \"\\u0393\",\n  Delta: \"\\u0394\",\n  Epsilon: \"\\u0395\",\n  Zeta: \"\\u0396\",\n  Eta: \"\\u0397\",\n  Theta: \"\\u0398\",\n  Iota: \"\\u0399\",\n  Kappa: \"\\u039A\",\n  Lambda: \"\\u039B\",\n  Mu: \"\\u039C\",\n  Nu: \"\\u039D\",\n  Xi: \"\\u039E\",\n  Omicron: \"\\u039F\",\n  Pi: \"\\u03A0\",\n  Rho: \"\\u03A1\",\n  Sigma: \"\\u03A3\",\n  Tau: \"\\u03A4\",\n  Upsilon: \"\\u03A5\",\n  Phi: \"\\u03A6\",\n  Chi: \"\\u03A7\",\n  Psi: \"\\u03A8\",\n  Omega: \"\\u03A9\",\n  alpha: \"\\u03B1\",\n  beta: \"\\u03B2\",\n  gamma: \"\\u03B3\",\n  delta: \"\\u03B4\",\n  epsilon: \"\\u03B5\",\n  zeta: \"\\u03B6\",\n  eta: \"\\u03B7\",\n  theta: \"\\u03B8\",\n  iota: \"\\u03B9\",\n  kappa: \"\\u03BA\",\n  lambda: \"\\u03BB\",\n  mu: \"\\u03BC\",\n  nu: \"\\u03BD\",\n  xi: \"\\u03BE\",\n  omicron: \"\\u03BF\",\n  pi: \"\\u03C0\",\n  rho: \"\\u03C1\",\n  sigmaf: \"\\u03C2\",\n  sigma: \"\\u03C3\",\n  tau: \"\\u03C4\",\n  upsilon: \"\\u03C5\",\n  phi: \"\\u03C6\",\n  chi: \"\\u03C7\",\n  psi: \"\\u03C8\",\n  omega: \"\\u03C9\",\n  thetasym: \"\\u03D1\",\n  upsih: \"\\u03D2\",\n  piv: \"\\u03D6\",\n  ensp: \"\\u2002\",\n  emsp: \"\\u2003\",\n  thinsp: \"\\u2009\",\n  zwnj: \"\\u200C\",\n  zwj: \"\\u200D\",\n  lrm: \"\\u200E\",\n  rlm: \"\\u200F\",\n  ndash: \"\\u2013\",\n  mdash: \"\\u2014\",\n  lsquo: \"\\u2018\",\n  rsquo: \"\\u2019\",\n  sbquo: \"\\u201A\",\n  ldquo: \"\\u201C\",\n  rdquo: \"\\u201D\",\n  bdquo: \"\\u201E\",\n  dagger: \"\\u2020\",\n  Dagger: \"\\u2021\",\n  bull: \"\\u2022\",\n  hellip: \"\\u2026\",\n  permil: \"\\u2030\",\n  prime: \"\\u2032\",\n  Prime: \"\\u2033\",\n  lsaquo: \"\\u2039\",\n  rsaquo: \"\\u203A\",\n  oline: \"\\u203E\",\n  frasl: \"\\u2044\",\n  euro: \"\\u20AC\",\n  image: \"\\u2111\",\n  weierp: \"\\u2118\",\n  real: \"\\u211C\",\n  trade: \"\\u2122\",\n  alefsym: \"\\u2135\",\n  larr: \"\\u2190\",\n  uarr: \"\\u2191\",\n  rarr: \"\\u2192\",\n  darr: \"\\u2193\",\n  harr: \"\\u2194\",\n  crarr: \"\\u21B5\",\n  lArr: \"\\u21D0\",\n  uArr: \"\\u21D1\",\n  rArr: \"\\u21D2\",\n  dArr: \"\\u21D3\",\n  hArr: \"\\u21D4\",\n  forall: \"\\u2200\",\n  part: \"\\u2202\",\n  exist: \"\\u2203\",\n  empty: \"\\u2205\",\n  nabla: \"\\u2207\",\n  isin: \"\\u2208\",\n  notin: \"\\u2209\",\n  ni: \"\\u220B\",\n  prod: \"\\u220F\",\n  sum: \"\\u2211\",\n  minus: \"\\u2212\",\n  lowast: \"\\u2217\",\n  radic: \"\\u221A\",\n  prop: \"\\u221D\",\n  infin: \"\\u221E\",\n  ang: \"\\u2220\",\n  and: \"\\u2227\",\n  or: \"\\u2228\",\n  cap: \"\\u2229\",\n  cup: \"\\u222A\",\n  int: \"\\u222B\",\n  there4: \"\\u2234\",\n  sim: \"\\u223C\",\n  cong: \"\\u2245\",\n  asymp: \"\\u2248\",\n  ne: \"\\u2260\",\n  equiv: \"\\u2261\",\n  le: \"\\u2264\",\n  ge: \"\\u2265\",\n  sub: \"\\u2282\",\n  sup: \"\\u2283\",\n  nsub: \"\\u2284\",\n  sube: \"\\u2286\",\n  supe: \"\\u2287\",\n  oplus: \"\\u2295\",\n  otimes: \"\\u2297\",\n  perp: \"\\u22A5\",\n  sdot: \"\\u22C5\",\n  lceil: \"\\u2308\",\n  rceil: \"\\u2309\",\n  lfloor: \"\\u230A\",\n  rfloor: \"\\u230B\",\n  loz: \"\\u25CA\",\n  spades: \"\\u2660\",\n  clubs: \"\\u2663\",\n  hearts: \"\\u2665\",\n  diams: \"\\u2666\",\n  lang: \"\\u27E8\",\n  rang: \"\\u27E9\"\n};\n\n// src/jsx-parser.ts\nTokenName[100 /* Identifier */] = \"JSXIdentifier\";\nTokenName[101 /* Text */] = \"JSXText\";\nfunction getQualifiedElementName(elementName) {\n  let qualifiedName;\n  switch (elementName.type) {\n    case \"JSXIdentifier\" /* JSXIdentifier */:\n      const id = elementName;\n      qualifiedName = id.name;\n      break;\n    case \"JSXNamespacedName\" /* JSXNamespacedName */:\n      const ns = elementName;\n      qualifiedName = getQualifiedElementName(ns.namespace) + \":\" + getQualifiedElementName(ns.name);\n      break;\n    case \"JSXMemberExpression\" /* JSXMemberExpression */:\n      const expr = elementName;\n      qualifiedName = getQualifiedElementName(expr.object) + \".\" + getQualifiedElementName(expr.property);\n      break;\n    default:\n      break;\n  }\n  return qualifiedName;\n}\nvar JSXParser = class extends Parser {\n  constructor(code, options, delegate) {\n    super(code, options, delegate);\n  }\n  //@ts-ignore\n  parsePrimaryExpression() {\n    return this.match(\"<\") ? this.parseJSXRoot() : super.parsePrimaryExpression();\n  }\n  startJSX() {\n    this.scanner.index = this.startMarker.index;\n    this.scanner.lineNumber = this.startMarker.line;\n    this.scanner.lineStart = this.startMarker.index - this.startMarker.column;\n  }\n  finishJSX() {\n    this.nextToken();\n  }\n  reenterJSX() {\n    this.startJSX();\n    this.expectJSX(\"}\");\n    if (this.config.tokens) {\n      this.tokens.pop();\n    }\n  }\n  createJSXNode() {\n    this.collectComments();\n    return {\n      index: this.scanner.index,\n      line: this.scanner.lineNumber,\n      column: this.scanner.index - this.scanner.lineStart\n    };\n  }\n  createJSXChildNode() {\n    return {\n      index: this.scanner.index,\n      line: this.scanner.lineNumber,\n      column: this.scanner.index - this.scanner.lineStart\n    };\n  }\n  scanXHTMLEntity(quote) {\n    let result = \"&\";\n    let valid = true;\n    let terminated = false;\n    let numeric = false;\n    let hex = false;\n    while (!this.scanner.eof() && valid && !terminated) {\n      const ch = this.scanner.source[this.scanner.index];\n      if (ch === quote) {\n        break;\n      }\n      terminated = ch === \";\";\n      result += ch;\n      ++this.scanner.index;\n      if (!terminated) {\n        switch (result.length) {\n          case 2:\n            numeric = ch === \"#\";\n            break;\n          case 3:\n            if (numeric) {\n              hex = ch === \"x\";\n              valid = hex || Character.isDecimalDigit(ch.charCodeAt(0));\n              numeric = numeric && !hex;\n            }\n            break;\n          default:\n            valid = valid && !(numeric && !Character.isDecimalDigit(ch.charCodeAt(0)));\n            valid = valid && !(hex && !Character.isHexDigit(ch.charCodeAt(0)));\n            break;\n        }\n      }\n    }\n    if (valid && terminated && result.length > 2) {\n      const str = result.substr(1, result.length - 2);\n      if (numeric && str.length > 1) {\n        result = String.fromCharCode(parseInt(str.substr(1), 10));\n      } else if (hex && str.length > 2) {\n        result = String.fromCharCode(parseInt(\"0\" + str.substr(1), 16));\n      } else if (!numeric && !hex && XHTMLEntities[str]) {\n        result = XHTMLEntities[str];\n      }\n    }\n    return result;\n  }\n  // Scan the next JSX token. This replaces Scanner#lex when in JSX mode.\n  lexJSX() {\n    const cp = this.scanner.source.charCodeAt(this.scanner.index);\n    if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {\n      const value = this.scanner.source[this.scanner.index++];\n      return {\n        type: 7 /* Punctuator */,\n        value,\n        lineNumber: this.scanner.lineNumber,\n        lineStart: this.scanner.lineStart,\n        start: this.scanner.index - 1,\n        end: this.scanner.index\n      };\n    }\n    if (cp === 34 || cp === 39) {\n      const start = this.scanner.index;\n      const quote = this.scanner.source[this.scanner.index++];\n      let str = \"\";\n      while (!this.scanner.eof()) {\n        const ch = this.scanner.source[this.scanner.index++];\n        if (ch === quote) {\n          break;\n        } else if (ch === \"&\") {\n          str += this.scanXHTMLEntity(quote);\n        } else {\n          str += ch;\n        }\n      }\n      return {\n        type: 8 /* StringLiteral */,\n        value: str,\n        lineNumber: this.scanner.lineNumber,\n        lineStart: this.scanner.lineStart,\n        start,\n        end: this.scanner.index\n      };\n    }\n    if (cp === 46) {\n      const n1 = this.scanner.source.charCodeAt(this.scanner.index + 1);\n      const n2 = this.scanner.source.charCodeAt(this.scanner.index + 2);\n      const value = n1 === 46 && n2 === 46 ? \"...\" : \".\";\n      const start = this.scanner.index;\n      this.scanner.index += value.length;\n      return {\n        type: 7 /* Punctuator */,\n        value,\n        lineNumber: this.scanner.lineNumber,\n        lineStart: this.scanner.lineStart,\n        start,\n        end: this.scanner.index\n      };\n    }\n    if (cp === 96) {\n      return {\n        type: 10 /* Template */,\n        value: \"\",\n        lineNumber: this.scanner.lineNumber,\n        lineStart: this.scanner.lineStart,\n        start: this.scanner.index,\n        end: this.scanner.index\n      };\n    }\n    if (Character.isIdentifierStart(cp) && cp !== 92) {\n      const start = this.scanner.index;\n      ++this.scanner.index;\n      while (!this.scanner.eof()) {\n        const ch = this.scanner.source.charCodeAt(this.scanner.index);\n        if (Character.isIdentifierPart(ch) && ch !== 92) {\n          ++this.scanner.index;\n        } else if (ch === 45) {\n          ++this.scanner.index;\n        } else {\n          break;\n        }\n      }\n      const id = this.scanner.source.slice(start, this.scanner.index);\n      return {\n        type: 100 /* Identifier */,\n        value: id,\n        lineNumber: this.scanner.lineNumber,\n        lineStart: this.scanner.lineStart,\n        start,\n        end: this.scanner.index\n      };\n    }\n    return this.scanner.lex();\n  }\n  nextJSXToken() {\n    this.collectComments();\n    this.startMarker.index = this.scanner.index;\n    this.startMarker.line = this.scanner.lineNumber;\n    this.startMarker.column = this.scanner.index - this.scanner.lineStart;\n    const token = this.lexJSX();\n    this.lastMarker.index = this.scanner.index;\n    this.lastMarker.line = this.scanner.lineNumber;\n    this.lastMarker.column = this.scanner.index - this.scanner.lineStart;\n    if (this.config.tokens) {\n      this.tokens.push(this.convertToken(token));\n    }\n    return token;\n  }\n  nextJSXText() {\n    this.startMarker.index = this.scanner.index;\n    this.startMarker.line = this.scanner.lineNumber;\n    this.startMarker.column = this.scanner.index - this.scanner.lineStart;\n    const start = this.scanner.index;\n    let text = \"\";\n    while (!this.scanner.eof()) {\n      const ch = this.scanner.source[this.scanner.index];\n      if (ch === \"{\" || ch === \"<\") {\n        break;\n      }\n      ++this.scanner.index;\n      text += ch;\n      if (Character.isLineTerminator(ch.charCodeAt(0))) {\n        ++this.scanner.lineNumber;\n        if (ch === \"\\r\" && this.scanner.source[this.scanner.index] === \"\\n\") {\n          ++this.scanner.index;\n        }\n        this.scanner.lineStart = this.scanner.index;\n      }\n    }\n    this.lastMarker.index = this.scanner.index;\n    this.lastMarker.line = this.scanner.lineNumber;\n    this.lastMarker.column = this.scanner.index - this.scanner.lineStart;\n    const token = {\n      type: 101 /* Text */,\n      value: text,\n      lineNumber: this.scanner.lineNumber,\n      lineStart: this.scanner.lineStart,\n      start,\n      end: this.scanner.index\n    };\n    if (text.length > 0 && this.config.tokens) {\n      this.tokens.push(this.convertToken(token));\n    }\n    return token;\n  }\n  peekJSXToken() {\n    const state = this.scanner.saveState();\n    this.scanner.scanComments();\n    const next = this.lexJSX();\n    this.scanner.restoreState(state);\n    return next;\n  }\n  // Expect the next JSX token to match the specified punctuator.\n  // If not, an exception will be thrown.\n  expectJSX(value) {\n    const token = this.nextJSXToken();\n    if (token.type !== 7 /* Punctuator */ || token.value !== value) {\n      this.throwUnexpectedToken(token);\n    }\n  }\n  // Return true if the next JSX token matches the specified punctuator.\n  matchJSX(value) {\n    const next = this.peekJSXToken();\n    return next.type === 7 /* Punctuator */ && next.value === value;\n  }\n  parseJSXIdentifier() {\n    const node = this.createJSXNode();\n    const token = this.nextJSXToken();\n    if (token.type !== 100 /* Identifier */) {\n      this.throwUnexpectedToken(token);\n    }\n    return this.finalize(node, new JSXIdentifier(token.value));\n  }\n  parseJSXElementName() {\n    const node = this.createJSXNode();\n    let elementName = this.parseJSXIdentifier();\n    if (this.matchJSX(\":\")) {\n      const namespace = elementName;\n      this.expectJSX(\":\");\n      const name = this.parseJSXIdentifier();\n      elementName = this.finalize(node, new JSXNamespacedName(namespace, name));\n    } else if (this.matchJSX(\".\")) {\n      while (this.matchJSX(\".\")) {\n        const object = elementName;\n        this.expectJSX(\".\");\n        const property = this.parseJSXIdentifier();\n        elementName = this.finalize(node, new JSXMemberExpression(object, property));\n      }\n    }\n    return elementName;\n  }\n  parseJSXAttributeName() {\n    const node = this.createJSXNode();\n    let attributeName;\n    const identifier = this.parseJSXIdentifier();\n    if (this.matchJSX(\":\")) {\n      const namespace = identifier;\n      this.expectJSX(\":\");\n      const name = this.parseJSXIdentifier();\n      attributeName = this.finalize(node, new JSXNamespacedName(namespace, name));\n    } else {\n      attributeName = identifier;\n    }\n    return attributeName;\n  }\n  parseJSXStringLiteralAttribute() {\n    const node = this.createJSXNode();\n    const token = this.nextJSXToken();\n    if (token.type !== 8 /* StringLiteral */) {\n      this.throwUnexpectedToken(token);\n    }\n    const raw = this.getTokenRaw(token);\n    return this.finalize(node, new Literal(token.value, raw));\n  }\n  parseJSXExpressionAttribute() {\n    const node = this.createJSXNode();\n    this.expectJSX(\"{\");\n    this.finishJSX();\n    if (this.match(\"}\")) {\n      this.tolerateError(\"JSX attributes must only be assigned a non-empty expression\");\n    }\n    const expression = this.parseAssignmentExpression();\n    this.reenterJSX();\n    return this.finalize(node, new JSXExpressionContainer(expression));\n  }\n  parseJSXAttributeValue() {\n    return this.matchJSX(\"{\") ? this.parseJSXExpressionAttribute() : this.matchJSX(\"<\") ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();\n  }\n  parseJSXNameValueAttribute() {\n    const node = this.createJSXNode();\n    const name = this.parseJSXAttributeName();\n    let value = null;\n    if (this.matchJSX(\"=\")) {\n      this.expectJSX(\"=\");\n      value = this.parseJSXAttributeValue();\n    }\n    return this.finalize(node, new JSXAttribute(name, value));\n  }\n  parseJSXSpreadAttribute() {\n    const node = this.createJSXNode();\n    this.expectJSX(\"{\");\n    this.expectJSX(\"...\");\n    this.finishJSX();\n    const argument = this.parseAssignmentExpression();\n    this.reenterJSX();\n    return this.finalize(node, new JSXSpreadAttribute(argument));\n  }\n  parseJSXAttributes() {\n    const attributes = [];\n    while (!this.matchJSX(\"/\") && !this.matchJSX(\">\")) {\n      const attribute = this.matchJSX(\"{\") ? this.parseJSXSpreadAttribute() : this.parseJSXNameValueAttribute();\n      attributes.push(attribute);\n    }\n    return attributes;\n  }\n  parseJSXOpeningElement() {\n    const node = this.createJSXNode();\n    this.expectJSX(\"<\");\n    if (this.matchJSX(\">\")) {\n      this.expectJSX(\">\");\n      return this.finalize(node, new JSXOpeningFragment(false));\n    }\n    const name = this.parseJSXElementName();\n    const attributes = this.parseJSXAttributes();\n    const selfClosing = this.matchJSX(\"/\");\n    if (selfClosing) {\n      this.expectJSX(\"/\");\n    }\n    this.expectJSX(\">\");\n    return this.finalize(node, new JSXOpeningElement(name, selfClosing, attributes));\n  }\n  parseJSXBoundaryElement() {\n    const node = this.createJSXNode();\n    this.expectJSX(\"<\");\n    if (this.matchJSX(\"/\")) {\n      this.expectJSX(\"/\");\n      if (this.matchJSX(\">\")) {\n        this.expectJSX(\">\");\n        return this.finalize(node, new JSXClosingFragment());\n      }\n      const elementName = this.parseJSXElementName();\n      this.expectJSX(\">\");\n      return this.finalize(node, new JSXClosingElement(elementName));\n    }\n    const name = this.parseJSXElementName();\n    const attributes = this.parseJSXAttributes();\n    const selfClosing = this.matchJSX(\"/\");\n    if (selfClosing) {\n      this.expectJSX(\"/\");\n    }\n    this.expectJSX(\">\");\n    return this.finalize(node, new JSXOpeningElement(name, selfClosing, attributes));\n  }\n  parseJSXEmptyExpression() {\n    const node = this.createJSXChildNode();\n    this.collectComments();\n    this.lastMarker.index = this.scanner.index;\n    this.lastMarker.line = this.scanner.lineNumber;\n    this.lastMarker.column = this.scanner.index - this.scanner.lineStart;\n    return this.finalize(node, new JSXEmptyExpression());\n  }\n  parseJSXExpressionContainer() {\n    const node = this.createJSXNode();\n    this.expectJSX(\"{\");\n    let expression;\n    if (this.matchJSX(\"}\")) {\n      expression = this.parseJSXEmptyExpression();\n      this.expectJSX(\"}\");\n    } else {\n      this.finishJSX();\n      expression = this.parseAssignmentExpression();\n      this.reenterJSX();\n    }\n    return this.finalize(node, new JSXExpressionContainer(expression));\n  }\n  parseJSXChildren() {\n    const children = [];\n    while (!this.scanner.eof()) {\n      const node = this.createJSXChildNode();\n      const token = this.nextJSXText();\n      if (token.start < token.end) {\n        const raw = this.getTokenRaw(token);\n        const child = this.finalize(node, new JSXText(token.value, raw));\n        children.push(child);\n      }\n      if (this.scanner.source[this.scanner.index] === \"{\") {\n        const container = this.parseJSXExpressionContainer();\n        children.push(container);\n      } else {\n        break;\n      }\n    }\n    return children;\n  }\n  parseComplexJSXElement(el) {\n    const stack = [];\n    while (!this.scanner.eof()) {\n      el.children = el.children.concat(this.parseJSXChildren());\n      const node = this.createJSXChildNode();\n      const element = this.parseJSXBoundaryElement();\n      if (element.type === \"JSXOpeningElement\" /* JSXOpeningElement */) {\n        const opening = element;\n        if (opening.selfClosing) {\n          const child = this.finalize(node, new JSXElement(opening, [], null));\n          el.children.push(child);\n        } else {\n          stack.push(el);\n          el = { node, opening, closing: null, children: [] };\n        }\n      }\n      if (element.type === \"JSXClosingElement\" /* JSXClosingElement */) {\n        el.closing = element;\n        const open = getQualifiedElementName(el.opening.name);\n        const close = getQualifiedElementName(el.closing.name);\n        if (open !== close) {\n          this.tolerateError(\"Expected corresponding JSX closing tag for %0\", open);\n        }\n        if (stack.length > 0) {\n          const child = this.finalize(el.node, new JSXElement(el.opening, el.children, el.closing));\n          el = stack[stack.length - 1];\n          el.children.push(child);\n          stack.pop();\n        } else {\n          break;\n        }\n      }\n      if (element.type === \"JSXClosingFragment\" /* JSXClosingFragment */) {\n        el.closing = element;\n        if (el.opening.type !== \"JSXOpeningFragment\" /* JSXOpeningFragment */) {\n          this.tolerateError(\"Expected corresponding JSX closing tag for jsx fragment\");\n        } else {\n          break;\n        }\n      }\n    }\n    return el;\n  }\n  parseJSXElement() {\n    const node = this.createJSXNode();\n    const opening = this.parseJSXOpeningElement();\n    let children = [];\n    let closing = null;\n    if (!opening.selfClosing) {\n      const el = this.parseComplexJSXElement({ node, opening, closing, children });\n      children = el.children;\n      closing = el.closing;\n    }\n    return this.finalize(node, new JSXElement(opening, children, closing));\n  }\n  parseJSXRoot() {\n    if (this.config.tokens) {\n      this.tokens.pop();\n    }\n    this.startJSX();\n    const element = this.parseJSXElement();\n    this.finishJSX();\n    return element;\n  }\n  isStartOfExpression() {\n    return super.isStartOfExpression() || this.match(\"<\");\n  }\n};\n\n// src/tokenizer.ts\nvar beforeFunctionExpressionTokens = [\n  \"(\",\n  \"{\",\n  \"[\",\n  \"in\",\n  \"typeof\",\n  \"instanceof\",\n  \"new\",\n  \"return\",\n  \"case\",\n  \"delete\",\n  \"throw\",\n  \"void\",\n  // assignment operators\n  \"=\",\n  \"+=\",\n  \"-=\",\n  \"*=\",\n  \"**=\",\n  \"/=\",\n  \"%=\",\n  \"<<=\",\n  \">>=\",\n  \">>>=\",\n  \"&=\",\n  \"|=\",\n  \"^=\",\n  \",\",\n  // binary/unary operators\n  \"+\",\n  \"-\",\n  \"*\",\n  \"**\",\n  \"/\",\n  \"%\",\n  \"++\",\n  \"--\",\n  \"<<\",\n  \">>\",\n  \">>>\",\n  \"&\",\n  \"|\",\n  \"^\",\n  \"!\",\n  \"~\",\n  \"&&\",\n  \"||\",\n  \"??\",\n  \"?\",\n  \":\",\n  \"===\",\n  \"==\",\n  \">=\",\n  \"<=\",\n  \"<\",\n  \">\",\n  \"!=\",\n  \"!==\"\n];\nvar Reader = class {\n  values;\n  curly;\n  paren;\n  constructor() {\n    this.values = [];\n    this.curly = this.paren = -1;\n  }\n  // A function following one of those tokens is an expression.\n  beforeFunctionExpression(t) {\n    return beforeFunctionExpressionTokens.includes(t);\n  }\n  // Determine if forward slash (/) is an operator or part of a regular expression\n  // https://github.com/mozilla/sweet.js/wiki/design\n  isRegexStart() {\n    const previous = this.values[this.values.length - 1];\n    let regex = previous !== null;\n    switch (previous) {\n      case \"this\":\n      case \"]\":\n        regex = false;\n        break;\n      case \")\":\n        const keyword = this.values[this.paren - 1];\n        regex = keyword === \"if\" || keyword === \"while\" || keyword === \"for\" || keyword === \"with\";\n        break;\n      case \"}\":\n        regex = true;\n        if (this.values[this.curly - 3] === \"function\") {\n          const check = this.values[this.curly - 4];\n          regex = check ? !this.beforeFunctionExpression(check) : false;\n        } else if (this.values[this.curly - 4] === \"function\") {\n          const check = this.values[this.curly - 5];\n          regex = check ? !this.beforeFunctionExpression(check) : true;\n        }\n        break;\n      default:\n        break;\n    }\n    return regex;\n  }\n  push(token) {\n    if (token.type === 7 /* Punctuator */ || token.type === 4 /* Keyword */) {\n      if (token.value === \"{\") {\n        this.curly = this.values.length;\n      } else if (token.value === \"(\") {\n        this.paren = this.values.length;\n      }\n      this.values.push(token.value);\n    } else {\n      this.values.push(null);\n    }\n  }\n};\nvar Tokenizer = class {\n  errorHandler;\n  scanner;\n  trackRange;\n  trackLoc;\n  buffer;\n  reader;\n  constructor(code, config) {\n    this.errorHandler = new ErrorHandler();\n    this.errorHandler.tolerant = config ? typeof config.tolerant === \"boolean\" && config.tolerant : false;\n    this.scanner = new Scanner(code, this.errorHandler);\n    this.scanner.trackComment = config ? typeof config.comment === \"boolean\" && config.comment : false;\n    this.trackRange = config ? typeof config.range === \"boolean\" && config.range : false;\n    this.trackLoc = config ? typeof config.loc === \"boolean\" && config.loc : false;\n    this.buffer = [];\n    this.reader = new Reader();\n  }\n  errors() {\n    return this.errorHandler.errors;\n  }\n  getNextToken() {\n    if (this.buffer.length === 0) {\n      const comments = this.scanner.scanComments();\n      if (this.scanner.trackComment) {\n        for (let i = 0; i < comments.length; ++i) {\n          const e = comments[i];\n          const value = this.scanner.source.slice(e.slice[0], e.slice[1]);\n          const comment = {\n            type: e.multiLine ? \"BlockComment\" : \"LineComment\",\n            value\n          };\n          if (this.trackRange) {\n            comment.range = e.range;\n          }\n          if (this.trackLoc) {\n            comment.loc = e.loc;\n          }\n          this.buffer.push(comment);\n        }\n      }\n      if (!this.scanner.eof()) {\n        let loc;\n        if (this.trackLoc) {\n          loc = {\n            start: {\n              line: this.scanner.lineNumber,\n              column: this.scanner.index - this.scanner.lineStart\n            },\n            end: {}\n          };\n        }\n        const maybeRegex = this.scanner.source[this.scanner.index] === \"/\" && this.reader.isRegexStart();\n        let token;\n        if (maybeRegex) {\n          const state = this.scanner.saveState();\n          try {\n            token = this.scanner.scanRegExp();\n          } catch (e) {\n            this.scanner.restoreState(state);\n            token = this.scanner.lex();\n          }\n        } else {\n          token = this.scanner.lex();\n        }\n        this.reader.push(token);\n        const entry = {\n          type: TokenName[token.type],\n          value: this.scanner.source.slice(token.start, token.end)\n        };\n        if (this.trackRange) {\n          entry.range = [token.start, token.end];\n        }\n        if (this.trackLoc) {\n          loc.end = {\n            line: this.scanner.lineNumber,\n            column: this.scanner.index - this.scanner.lineStart\n          };\n          entry.loc = loc;\n        }\n        if (token.type === 9 /* RegularExpression */) {\n          const pattern = token.pattern;\n          const flags = token.flags;\n          entry.regex = { pattern, flags };\n        }\n        this.buffer.push(entry);\n      }\n    }\n    return this.buffer.shift();\n  }\n};\n\n// src/visitor.ts\nvar Visitor = class {\n  visit(node) {\n    if (node == null)\n      return node;\n    switch (node.type) {\n      case \"AssignmentExpression\" /* AssignmentExpression */:\n        return this.visitAssignmentExpression(node);\n      case \"AssignmentPattern\" /* AssignmentPattern */:\n        return this.visitAssignmentPattern(node);\n      case \"ArrayExpression\" /* ArrayExpression */:\n        return this.visitArrayExpression(node);\n      case \"ArrayPattern\" /* ArrayPattern */:\n        return this.visitArrayPattern(node);\n      case \"ArrowFunctionExpression\" /* ArrowFunctionExpression */:\n        return this.visitArrowFunctionExpression(node);\n      case \"AwaitExpression\" /* AwaitExpression */:\n        return this.visitAwaitExpression(node);\n      case \"BlockStatement\" /* BlockStatement */:\n        return this.visitBlockStatement(node);\n      case \"BinaryExpression\" /* BinaryExpression */:\n        return this.visitBinaryExpression(node);\n      case \"BreakStatement\" /* BreakStatement */:\n        return this.visitBreakStatement(node);\n      case \"CallExpression\" /* CallExpression */:\n        return this.visitCallExpression(node);\n      case \"CatchClause\" /* CatchClause */:\n        return this.visitCatchClause(node);\n      case \"ChainExpression\" /* ChainExpression */:\n        return this.visitChainExpression(node);\n      case \"ClassBody\" /* ClassBody */:\n        return this.visitClassBody(node);\n      case \"ClassDeclaration\" /* ClassDeclaration */:\n        return this.visitClassDeclaration(node);\n      case \"ClassExpression\" /* ClassExpression */:\n        return this.visitClassExpression(node);\n      case \"ConditionalExpression\" /* ConditionalExpression */:\n        return this.visitConditionalExpression(node);\n      case \"ContinueStatement\" /* ContinueStatement */:\n        return this.visitContinueStatement(node);\n      case \"Decorator\" /* Decorator */:\n        return this.visitDecorator(node);\n      case \"DoWhileStatement\" /* DoWhileStatement */:\n        return this.visitDoWhileStatement(node);\n      case \"DebuggerStatement\" /* DebuggerStatement */:\n        return this.visitDebuggerStatement(node);\n      case \"EmptyStatement\" /* EmptyStatement */:\n        return this.visitEmptyStatement(node);\n      case \"ExportAllDeclaration\" /* ExportAllDeclaration */:\n        return this.visitExportAllDeclaration(node);\n      case \"ExportDefaultDeclaration\" /* ExportDefaultDeclaration */:\n        return this.visitExportDefaultDeclaration(node);\n      case \"ExportNamedDeclaration\" /* ExportNamedDeclaration */:\n        return this.visitExportNamedDeclaration(node);\n      case \"ExportSpecifier\" /* ExportSpecifier */:\n        return this.visitExportSpecifier(node);\n      case \"ExpressionStatement\" /* ExpressionStatement */:\n        return this.visitExpressionStatement(node);\n      case \"ForStatement\" /* ForStatement */:\n        return this.visitForStatement(node);\n      case \"ForOfStatement\" /* ForOfStatement */:\n        return this.visitForOfStatement(node);\n      case \"ForInStatement\" /* ForInStatement */:\n        return this.visitForInStatement(node);\n      case \"FunctionDeclaration\" /* FunctionDeclaration */:\n        return this.visitFunctionDeclaration(node);\n      case \"FunctionExpression\" /* FunctionExpression */:\n        return this.visitFunctionExpression(node);\n      case \"Identifier\" /* Identifier */:\n        return this.visitIdentifier(node);\n      case \"IfStatement\" /* IfStatement */:\n        return this.visitIfStatement(node);\n      case \"ImportAttribute\" /* ImportAttribute */:\n        return this.visitImportAttribute(node);\n      case \"ImportExpression\" /* ImportExpression */:\n        return this.visitImportExpression(node);\n      case \"ImportDeclaration\" /* ImportDeclaration */:\n        return this.visitImportDeclaration(node);\n      case \"ImportDefaultSpecifier\" /* ImportDefaultSpecifier */:\n        return this.visitImportDefaultSpecifier(node);\n      case \"ImportNamespaceSpecifier\" /* ImportNamespaceSpecifier */:\n        return this.visitImportNamespaceSpecifier(node);\n      case \"ImportSpecifier\" /* ImportSpecifier */:\n        return this.visitImportSpecifier(node);\n      case \"Literal\" /* Literal */:\n        return this.visitLiteral(node);\n      case \"LabeledStatement\" /* LabeledStatement */:\n        return this.visitLabeledStatement(node);\n      case \"LogicalExpression\" /* LogicalExpression */:\n        return this.visitLogicalExpression(node);\n      case \"MemberExpression\" /* MemberExpression */:\n        return this.visitMemberExpression(node);\n      case \"MetaProperty\" /* MetaProperty */:\n        return this.visitMetaProperty(node);\n      case \"MethodDefinition\" /* MethodDefinition */:\n        return this.visitMethodDefinition(node);\n      case \"NewExpression\" /* NewExpression */:\n        return this.visitNewExpression(node);\n      case \"ObjectExpression\" /* ObjectExpression */:\n        return this.visitObjectExpression(node);\n      case \"ObjectPattern\" /* ObjectPattern */:\n        return this.visitObjectPattern(node);\n      case \"Program\" /* Program */:\n        return this.visitProgram(node);\n      case \"Property\" /* Property */:\n        return this.visitProperty(node);\n      case \"PrivateIdentifier\" /* PrivateIdentifier */:\n        return this.visitPrivateIdentifier(node);\n      case \"RestElement\" /* RestElement */:\n        return this.visitRestElement(node);\n      case \"ReturnStatement\" /* ReturnStatement */:\n        return this.visitReturnStatement(node);\n      case \"SequenceExpression\" /* SequenceExpression */:\n        return this.visitSequenceExpression(node);\n      case \"SpreadElement\" /* SpreadElement */:\n        return this.visitSpreadElement(node);\n      case \"StaticBlock\" /* StaticBlock */:\n        return this.visitStaticBlock(node);\n      case \"Super\" /* Super */:\n        return this.visitSuper(node);\n      case \"SwitchCase\" /* SwitchCase */:\n        return this.visitSwitchCase(node);\n      case \"SwitchStatement\" /* SwitchStatement */:\n        return this.visitSwitchStatement(node);\n      case \"TaggedTemplateExpression\" /* TaggedTemplateExpression */:\n        return this.visitTaggedTemplateExpression(node);\n      case \"TemplateElement\" /* TemplateElement */:\n        return this.visitTemplateElement(node);\n      case \"TemplateLiteral\" /* TemplateLiteral */:\n        return this.visitTemplateLiteral(node);\n      case \"ThisExpression\" /* ThisExpression */:\n        return this.visitThisExpression(node);\n      case \"ThrowStatement\" /* ThrowStatement */:\n        return this.visitThrowStatement(node);\n      case \"TryStatement\" /* TryStatement */:\n        return this.visitTryStatement(node);\n      case \"UnaryExpression\" /* UnaryExpression */:\n        return this.visitUnaryExpression(node);\n      case \"UpdateExpression\" /* UpdateExpression */:\n        return this.visitUpdateExpression(node);\n      case \"VariableDeclaration\" /* VariableDeclaration */:\n        return this.visitVariableDeclaration(node);\n      case \"VariableDeclarator\" /* VariableDeclarator */:\n        return this.visitVariableDeclarator(node);\n      case \"WhileStatement\" /* WhileStatement */:\n        return this.visitWhileStatement(node);\n      case \"WithStatement\" /* WithStatement */:\n        return this.visitWithStatement(node);\n      case \"YieldExpression\" /* YieldExpression */:\n        return this.visitYieldExpression(node);\n    }\n  }\n  visitNodeList(original) {\n    if (original == null)\n      return original;\n    let list = null;\n    for (let i = 0, n = original.length; i < n; i++) {\n      let p = this.visit(original[i]);\n      if (list != null) {\n        list.push(p);\n      } else if (p != original[i]) {\n        list = [];\n        for (let j = 0; j < i; j++) {\n          list.push(original[j]);\n        }\n        list.push(p);\n      }\n    }\n    if (list != null)\n      return list;\n    return original;\n  }\n  visitAssignmentExpression(node) {\n    const left = this.visit(node.left);\n    const right = this.visit(node.right);\n    if (left !== node.left || right !== node.right)\n      return new AssignmentExpression(node.operator, left, right);\n    return node;\n  }\n  visitAssignmentPattern(node) {\n    const left = this.visit(node.left);\n    const right = this.visit(node.right);\n    if (left !== node.left || right !== node.right)\n      return new AssignmentPattern(left, right);\n    return node;\n  }\n  visitArrayExpression(node) {\n    const elements = this.visitNodeList(node.elements);\n    if (elements !== node.elements)\n      return new ArrayExpression(elements);\n    return node;\n  }\n  visitArrayPattern(node) {\n    const elements = this.visitNodeList(node.elements);\n    if (elements !== node.elements)\n      return new ArrayPattern(elements);\n    return node;\n  }\n  visitArrowFunctionExpression(node) {\n    const id = this.visit(node.id);\n    const params = this.visitNodeList(node.params);\n    const body = this.visit(node.body);\n    if (id !== node.id || params !== node.params || body !== node.body) {\n      const ret = new ArrowFunctionExpression(params, body, node.expression, node.async);\n      ret.id = id;\n      return ret;\n    }\n    return node;\n  }\n  visitAwaitExpression(node) {\n    const argument = this.visit(node.argument);\n    if (argument !== node.argument)\n      return new AwaitExpression(argument);\n    return node;\n  }\n  visitBlockStatement(node) {\n    const body = this.visitNodeList(node.body);\n    if (body !== node.body)\n      return new BlockStatement(body);\n    return node;\n  }\n  visitBinaryExpression(node) {\n    const left = this.visit(node.left);\n    const right = this.visit(node.right);\n    if (left !== node.left || right !== node.right)\n      return new BinaryExpression(node.operator, left, right);\n    return node;\n  }\n  visitBreakStatement(node) {\n    const label = this.visit(node.label);\n    if (label !== node.label)\n      return new BreakStatement(label);\n    return node;\n  }\n  visitCallExpression(node) {\n    const callee = this.visit(node.callee);\n    const args = this.visitNodeList(node.arguments);\n    if (callee !== node.callee || args !== node.arguments)\n      return new CallExpression(callee, args, node.optional);\n    return node;\n  }\n  visitCatchClause(node) {\n    const param = this.visit(node.param);\n    const body = this.visit(node.body);\n    if (param !== node.param || body !== node.body)\n      return new CatchClause(param, body);\n    return node;\n  }\n  visitChainExpression(node) {\n    const expression = this.visit(node.expression);\n    if (expression !== node.expression)\n      return new ChainExpression(expression);\n    return node;\n  }\n  visitClassBody(node) {\n    const body = this.visitNodeList(node.body);\n    if (body !== node.body)\n      return new ClassBody(body);\n    return node;\n  }\n  visitClassDeclaration(node) {\n    const id = this.visit(node.id);\n    const superClass = this.visit(node.superClass);\n    const body = this.visit(node.body);\n    const decorators = this.visitNodeList(node.decorators);\n    if (id !== node.id || superClass !== node.superClass || body !== node.body || decorators !== node.decorators)\n      return new ClassDeclaration(id, superClass, body, decorators);\n    return node;\n  }\n  visitClassExpression(node) {\n    const id = this.visit(node.id);\n    const superClass = this.visit(node.superClass);\n    const body = this.visit(node.body);\n    const decorators = this.visitNodeList(node.decorators);\n    if (id !== node.id || superClass !== node.superClass || body !== node.body || decorators !== node.decorators)\n      return new ClassExpression(id, superClass, body, decorators);\n    return node;\n  }\n  visitConditionalExpression(node) {\n    const test = this.visit(node.test);\n    const consequent = this.visit(node.consequent);\n    const alternate = this.visit(node.alternate);\n    if (test !== node.test || consequent !== node.consequent || alternate !== node.alternate)\n      return new ConditionalExpression(test, consequent, alternate);\n    return node;\n  }\n  visitContinueStatement(node) {\n    const label = this.visit(node.label);\n    if (label !== node.label)\n      return new ContinueStatement(label);\n    return node;\n  }\n  visitDecorator(node) {\n    const expression = this.visit(node.expression);\n    if (expression !== node.expression)\n      return new Decorator(expression);\n    return node;\n  }\n  visitDoWhileStatement(node) {\n    const body = this.visit(node.body);\n    const test = this.visit(node.test);\n    if (body !== node.body || test !== node.test)\n      return new DoWhileStatement(body, test);\n    return node;\n  }\n  visitDebuggerStatement(node) {\n    return node;\n  }\n  visitEmptyStatement(node) {\n    return node;\n  }\n  visitExportAllDeclaration(node) {\n    const source = this.visit(node.source);\n    const exported = this.visit(node.exported);\n    const assertions = this.visitNodeList(node.assertions);\n    if (source !== node.source || exported !== node.exported || assertions !== node.assertions)\n      return new ExportAllDeclaration(source, exported, assertions);\n    return node;\n  }\n  visitExportDefaultDeclaration(node) {\n    const declaration = this.visit(node.declaration);\n    if (declaration !== node.declaration)\n      return new ExportDefaultDeclaration(declaration);\n    return node;\n  }\n  visitExportNamedDeclaration(node) {\n    const declaration = this.visit(node.declaration);\n    const specifiers = this.visitNodeList(node.specifiers);\n    const source = this.visit(node.source);\n    const assertions = this.visitNodeList(node.assertions);\n    if (declaration !== node.declaration || specifiers !== node.specifiers || source !== node.source || assertions !== node.assertions)\n      return new ExportNamedDeclaration(declaration, specifiers, source, assertions);\n    return node;\n  }\n  visitExportSpecifier(node) {\n    const exported = this.visit(node.exported);\n    const local = this.visit(node.local);\n    if (exported !== node.exported || local !== node.local)\n      return new ExportSpecifier(exported, local);\n    return node;\n  }\n  visitExpressionStatement(node) {\n    const expression = this.visit(node.expression);\n    if (expression !== node.expression)\n      return new ExpressionStatement(expression);\n    return node;\n  }\n  visitForStatement(node) {\n    const init = this.visit(node.init);\n    const test = this.visit(node.test);\n    const update = this.visit(node.update);\n    const body = this.visit(node.body);\n    if (init !== node.init || test !== node.test || update !== node.update || body !== node.body)\n      return new ForStatement(init, test, update, body);\n    return node;\n  }\n  visitForOfStatement(node) {\n    const left = this.visit(node.left);\n    const right = this.visit(node.right);\n    const body = this.visit(node.body);\n    if (left !== node.left || right !== node.right || body !== node.body)\n      return new ForOfStatement(left, right, body, node.await);\n    return node;\n  }\n  visitForInStatement(node) {\n    const left = this.visit(node.left);\n    const right = this.visit(node.right);\n    const body = this.visit(node.body);\n    if (left !== node.left || right !== node.right || body !== node.body)\n      return new ForInStatement(left, right, body);\n    return node;\n  }\n  visitFunctionDeclaration(node) {\n    const id = this.visit(node.id);\n    const params = this.visitNodeList(node.params);\n    const body = this.visit(node.body);\n    if (id !== node.id || params !== node.params || body !== node.body)\n      return new FunctionDeclaration(id, params, body, node.generator);\n    return node;\n  }\n  visitFunctionExpression(node) {\n    const id = this.visit(node.id);\n    const params = this.visitNodeList(node.params);\n    const body = this.visit(node.body);\n    if (id !== node.id || params !== node.params || body !== node.body)\n      return new FunctionExpression(id, params, body, node.generator, node.async);\n    return node;\n  }\n  visitIdentifier(node) {\n    return node;\n  }\n  visitIfStatement(node) {\n    const test = this.visit(node.test);\n    const consequent = this.visit(node.consequent);\n    const alternate = this.visit(node.alternate);\n    if (test !== node.test || consequent !== node.consequent || alternate !== node.alternate)\n      return new IfStatement(test, consequent, alternate);\n    return node;\n  }\n  visitImportAttribute(node) {\n    const key = this.visit(node.key);\n    const value = this.visit(node.value);\n    if (key !== node.key || value !== node.value)\n      return new ImportAttribute(key, value);\n    return node;\n  }\n  visitImportExpression(node) {\n    const source = this.visit(node.source);\n    const attributes = this.visit(node.attributes);\n    if (source !== node.source || attributes !== node.attributes)\n      return new ImportExpression(source, attributes);\n    return node;\n  }\n  visitImportDeclaration(node) {\n    const specifiers = this.visitNodeList(node.specifiers);\n    const source = this.visit(node.source);\n    const assertions = this.visitNodeList(node.assertions);\n    if (specifiers !== node.specifiers || source !== node.source || assertions !== node.assertions)\n      return new ImportDeclaration(specifiers, source, assertions);\n    return node;\n  }\n  visitImportDefaultSpecifier(node) {\n    const local = this.visit(node.local);\n    if (local !== node.local)\n      return new ImportDefaultSpecifier(local);\n    return node;\n  }\n  visitImportNamespaceSpecifier(node) {\n    const local = this.visit(node.local);\n    if (local !== node.local)\n      return new ImportNamespaceSpecifier(local);\n    return node;\n  }\n  visitImportSpecifier(node) {\n    const local = this.visit(node.local);\n    const imported = this.visit(node.imported);\n    if (local !== node.local || imported !== node.imported)\n      return new ImportSpecifier(local, imported);\n    return node;\n  }\n  visitLiteral(node) {\n    return node;\n  }\n  visitLabeledStatement(node) {\n    const label = this.visit(node.label);\n    const body = this.visit(node.body);\n    if (label !== node.label || body !== node.body)\n      return new LabeledStatement(label, body);\n    return node;\n  }\n  visitLogicalExpression(node) {\n    const left = this.visit(node.left);\n    const right = this.visit(node.right);\n    if (left !== node.left || right !== node.right)\n      return new LogicalExpression(node.operator, left, right);\n    return node;\n  }\n  visitMemberExpression(node) {\n    const _object = this.visit(node.object);\n    const property = this.visit(node.property);\n    if (_object !== node.object || property !== node.property)\n      return new MemberExpression(node.computed, _object, property, node.optional);\n    return node;\n  }\n  visitMetaProperty(node) {\n    const meta = this.visit(node.meta);\n    const property = this.visit(node.property);\n    if (meta !== node.meta || property !== node.property)\n      return new MetaProperty(meta, property);\n    return node;\n  }\n  visitMethodDefinition(node) {\n    const key = this.visit(node.key);\n    const value = this.visit(node.value);\n    const decorators = this.visitNodeList(node.decorators);\n    if (key !== node.key || value !== node.value || decorators !== node.decorators)\n      return new MethodDefinition(key, node.computed, value, node.kind, node.static, decorators);\n    return node;\n  }\n  visitNewExpression(node) {\n    const callee = this.visit(node.callee);\n    const args = this.visitNodeList(node.arguments);\n    if (callee !== node.callee || args !== node.arguments)\n      return new NewExpression(callee, args);\n    return node;\n  }\n  visitObjectExpression(node) {\n    const properties = this.visitNodeList(node.properties);\n    if (properties !== node.properties)\n      return new ObjectExpression(properties);\n    return node;\n  }\n  visitObjectPattern(node) {\n    const properties = this.visitNodeList(node.properties);\n    if (properties !== node.properties)\n      return new ObjectPattern(properties);\n    return node;\n  }\n  visitProgram(node) {\n    const body = this.visitNodeList(node.body);\n    if (body !== node.body)\n      return new Program(node.sourceType, body);\n    return node;\n  }\n  visitProperty(node) {\n    const key = this.visit(node.key);\n    const value = this.visit(node.value);\n    const decorators = this.visitNodeList(node.decorators);\n    if (key !== node.key || value !== node.value || decorators !== decorators) {\n      if (\"kind\" in node)\n        return new Property(node.kind, key, node.computed, value, node.method, node.shorthand);\n      else\n        return new PropertyDefinition(key, node.computed, value, node.static, decorators);\n    }\n    return node;\n  }\n  visitPrivateIdentifier(node) {\n    return node;\n  }\n  visitRestElement(node) {\n    const argument = this.visit(node.argument);\n    if (argument !== node.argument)\n      return new RestElement(argument);\n    return node;\n  }\n  visitReturnStatement(node) {\n    const argument = this.visit(node.argument);\n    if (argument !== node.argument)\n      return new ReturnStatement(argument);\n    return node;\n  }\n  visitSequenceExpression(node) {\n    const expressions = this.visitNodeList(node.expressions);\n    if (expressions !== node.expressions)\n      return new SequenceExpression(expressions);\n    return node;\n  }\n  visitSpreadElement(node) {\n    const argument = this.visit(node.argument);\n    if (argument !== node.argument)\n      return new SpreadElement(argument);\n    return node;\n  }\n  visitStaticBlock(node) {\n    const body = this.visitNodeList(node.body);\n    if (body !== node.body)\n      return new StaticBlock(body);\n    return node;\n  }\n  visitSuper(node) {\n    return node;\n  }\n  visitSwitchCase(node) {\n    const test = this.visit(node.test);\n    const consequent = this.visitNodeList(node.consequent);\n    if (test !== node.test || consequent !== node.consequent)\n      return new SwitchCase(test, consequent);\n    return node;\n  }\n  visitSwitchStatement(node) {\n    const discriminant = this.visit(node.discriminant);\n    const cases = this.visitNodeList(node.cases);\n    if (discriminant !== node.discriminant || cases !== node.cases)\n      return new SwitchStatement(discriminant, cases);\n    return node;\n  }\n  visitTaggedTemplateExpression(node) {\n    const tag = this.visit(node.tag);\n    const quasi = this.visit(node.quasi);\n    if (tag !== node.tag || quasi !== node.quasi)\n      return new TaggedTemplateExpression(tag, quasi);\n    return node;\n  }\n  visitTemplateElement(node) {\n    return node;\n  }\n  visitTemplateLiteral(node) {\n    const quasis = this.visitNodeList(node.quasis);\n    const expressions = this.visitNodeList(node.expressions);\n    if (quasis !== node.quasis || expressions !== node.expressions)\n      return new TemplateLiteral(quasis, expressions);\n    return node;\n  }\n  visitThisExpression(node) {\n    return node;\n  }\n  visitThrowStatement(node) {\n    const argument = this.visit(node.argument);\n    if (argument !== node.argument)\n      return new ThrowStatement(argument);\n    return node;\n  }\n  visitTryStatement(node) {\n    const block = this.visit(node.block);\n    const handler = this.visit(node.handler);\n    const finalizer = this.visit(node.finalizer);\n    if (block !== node.block || handler !== node.handler || finalizer !== node.finalizer)\n      return new TryStatement(block, handler, finalizer);\n    return node;\n  }\n  visitUnaryExpression(node) {\n    const argument = this.visit(node.argument);\n    if (argument !== node.argument)\n      return new UnaryExpression(node.operator, argument);\n    return node;\n  }\n  visitUpdateExpression(node) {\n    const argument = this.visit(node.argument);\n    if (argument !== node.argument)\n      return new UpdateExpression(node.operator, argument, node.prefix);\n    return node;\n  }\n  visitVariableDeclaration(node) {\n    const declarations = this.visitNodeList(node.declarations);\n    if (declarations !== node.declarations)\n      return new VariableDeclaration(declarations, node.kind);\n    return node;\n  }\n  visitVariableDeclarator(node) {\n    const id = this.visit(node.id);\n    const init = this.visit(node.init);\n    if (id !== node.id || init !== node.init)\n      return new VariableDeclarator(id, init);\n    return node;\n  }\n  visitWhileStatement(node) {\n    const test = this.visit(node.test);\n    const body = this.visit(node.body);\n    if (test !== node.test || body !== node.body)\n      return new WhileStatement(test, body);\n    return node;\n  }\n  visitWithStatement(node) {\n    const _object = this.visit(node.object);\n    const body = this.visit(node.body);\n    if (_object !== node.object || body !== node.body)\n      return new WithStatement(_object, body);\n    return node;\n  }\n  visitYieldExpression(node) {\n    const argument = this.visit(node.argument);\n    if (argument !== node.argument)\n      return new YieldExpression(argument, node.delegate);\n    return node;\n  }\n};\n\n// src/esprima.ts\nfunction parse(code, options, delegate) {\n  let commentHandler = null;\n  const proxyDelegate = (node, metadata) => {\n    if (delegate) {\n      delegate(node, metadata);\n    }\n    if (commentHandler) {\n      commentHandler.visit(node, metadata);\n    }\n  };\n  let parserDelegate = typeof delegate === \"function\" ? proxyDelegate : null;\n  let collectComment = false;\n  if (options) {\n    collectComment = typeof options.comment === \"boolean\" && options.comment;\n    const attachComment = typeof options.attachComment === \"boolean\" && options.attachComment;\n    if (collectComment || attachComment) {\n      commentHandler = new CommentHandler();\n      commentHandler.attach = attachComment;\n      options.comment = true;\n      parserDelegate = proxyDelegate;\n    }\n  }\n  let isModule = false;\n  if (options && typeof options.sourceType === \"string\") {\n    isModule = options.sourceType === \"module\";\n  }\n  let parser;\n  if (options && typeof options.jsx === \"boolean\" && options.jsx) {\n    parser = new JSXParser(code, options, parserDelegate);\n  } else {\n    parser = new Parser(code, options, parserDelegate);\n  }\n  const program = isModule ? parser.parseModule() : parser.parseScript();\n  const ast = program;\n  if (collectComment && commentHandler) {\n    ast.comments = commentHandler.comments;\n  }\n  if (parser.config.tokens) {\n    ast.tokens = parser.tokens;\n  }\n  if (parser.config.tolerant) {\n    ast.errors = parser.errorHandler.errors;\n  }\n  return ast;\n}\nfunction parseModule(code, options, delegate) {\n  const parsingOptions = options || {};\n  parsingOptions.sourceType = \"module\";\n  return parse(code, parsingOptions, delegate);\n}\nfunction parseScript(code, options, delegate) {\n  const parsingOptions = options || {};\n  parsingOptions.sourceType = \"script\";\n  return parse(code, parsingOptions, delegate);\n}\nfunction tokenize(code, options, delegate) {\n  const tokenizer = new Tokenizer(code, options);\n  const tokens = [];\n  try {\n    while (true) {\n      let token = tokenizer.getNextToken();\n      if (!token) {\n        break;\n      }\n      if (delegate) {\n        token = delegate(token);\n      }\n      tokens.push(token);\n    }\n  } catch (e) {\n    tokenizer.errorHandler.tolerate(e);\n  }\n  if (tokenizer.errorHandler.tolerant) {\n    tokens.errors = tokenizer.errors();\n  }\n  return tokens;\n}\nvar version = \"6.0.3\";\nvar esprima_default = {\n  parse,\n  parseModule,\n  parseScript,\n  tokenize,\n  Syntax,\n  version\n};\n\n\n\n//# sourceURL=webpack://WTBenchmark/./node_modules/esprima-next/dist/esprima.js?\n}");

/***/ }),

/***/ "./src/esprima-next.mjs":
/*!******************************!*\
  !*** ./src/esprima-next.mjs ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   runTest: () => (/* binding */ runTest)\n/* harmony export */ });\n/* harmony import */ var esprima_next__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! esprima-next */ \"./node_modules/esprima-next/dist/esprima.js\");\n// Copyright 2017 the V8 project authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n\n\nconst payloads = [\n  \"backbone-1.6.1.js\",\n  \"jquery-3.7.1.js\",\n  \"mootools-core-1.6.0.js\",\n  \"underscore-1.13.7.js\",\n];\n\nfunction runTest(fileData) {\n  const testData = payloads.map((name) => fileData[name]);\n\n  return testData.map((payload) => {\n    let count = 0;\n    count += esprima_next__WEBPACK_IMPORTED_MODULE_0__.tokenize(payload, { loc: true, range: true }).length;\n    count += esprima_next__WEBPACK_IMPORTED_MODULE_0__.parse(payload, { loc: true, range: true }).body.length;\n    return count;\n  });\n}\n\n\n//# sourceURL=webpack://WTBenchmark/./src/esprima-next.mjs?\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/esprima-next.mjs");
/******/ 	self.WTBenchmark = __webpack_exports__;
/******/ 	
/******/ })()
;